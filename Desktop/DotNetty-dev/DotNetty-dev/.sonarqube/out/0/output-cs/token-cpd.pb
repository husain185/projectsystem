∫M
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\AbstractEventExecutor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

abstract 
class !
AbstractEventExecutor /
:0 1#
AbstractExecutorService2 I
,I J
IEventExecutorK Y
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S!
AbstractEventExecutorS h
>h i
(i j
)j k
;k l
static 
readonly 
TimeSpan  &
DefaultShutdownQuietPeriod! ;
=< =
TimeSpan> F
.F G
FromSecondsG R
(R S
$numS T
)T U
;U V
static 
readonly 
TimeSpan  "
DefaultShutdownTimeout! 7
=8 9
TimeSpan: B
.B C
FromSecondsC N
(N O
$numO Q
)Q R
;R S
	protected !
AbstractEventExecutor '
(' (
)( )
: 
this 
( 
null 
) 
{ 	
} 	
	protected !
AbstractEventExecutor '
(' (
IEventExecutorGroup( ;
parent< B
)B C
{ 	
this 
. 
Parent 
= 
parent  
;  !
}   	
public## 
abstract## 
bool## 
IsShuttingDown## +
{##, -
get##. 1
;##1 2
}##3 4
public&& 
abstract&& 
Task&& !
TerminationCompletion&& 2
{&&3 4
get&&5 8
;&&8 9
}&&: ;
public)) 
IEventExecutor)) 
GetNext)) %
())% &
)))& '
=>))( *
this))+ /
;))/ 0
public,, 
IEventExecutorGroup,, "
Parent,,# )
{,,* +
get,,, /
;,,/ 0
},,1 2
public// 
bool// 
InEventLoop// 
=>//  "
this//# '
.//' (
IsInEventLoop//( 5
(//5 6
Thread//6 <
.//< =
CurrentThread//= J
)//J K
;//K L
public22 
IEnumerable22 
<22 
IEventExecutor22 )
>22) *
Items22+ 0
=>221 3
this224 8
.228 9
GetItems229 A
(22A B
)22B C
;22C D
	protected44 
abstract44 
IEnumerable44 &
<44& '
IEventExecutor44' 5
>445 6
GetItems447 ?
(44? @
)44@ A
;44A B
public77 
abstract77 
bool77 
IsInEventLoop77 *
(77* +
Thread77+ 1
thread772 8
)778 9
;779 :
public:: 
virtual:: 
IScheduledTask:: %
Schedule::& .
(::. /
	IRunnable::/ 8
action::9 ?
,::? @
TimeSpan::A I
delay::J O
)::O P
{;; 	
throw<< 
new<< !
NotSupportedException<< +
(<<+ ,
)<<, -
;<<- .
}== 	
public@@ 
virtual@@ 
IScheduledTask@@ %
Schedule@@& .
(@@. /
Action@@/ 5
action@@6 <
,@@< =
TimeSpan@@> F
delay@@G L
)@@L M
{AA 	
throwBB 
newBB !
NotSupportedExceptionBB +
(BB+ ,
)BB, -
;BB- .
}CC 	
publicFF 
virtualFF 
IScheduledTaskFF %
ScheduleFF& .
(FF. /
ActionFF/ 5
<FF5 6
objectFF6 <
>FF< =
actionFF> D
,FFD E
objectFFF L
stateFFM R
,FFR S
TimeSpanFFT \
delayFF] b
)FFb c
{GG 	
throwHH 
newHH !
NotSupportedExceptionHH +
(HH+ ,
)HH, -
;HH- .
}II 	
publicLL 
virtualLL 
IScheduledTaskLL %
ScheduleLL& .
(LL. /
ActionLL/ 5
<LL5 6
objectLL6 <
,LL< =
objectLL> D
>LLD E
actionLLF L
,LLL M
objectLLN T
contextLLU \
,LL\ ]
objectLL^ d
stateLLe j
,LLj k
TimeSpanLLl t
delayLLu z
)LLz {
{MM 	
throwNN 
newNN !
NotSupportedExceptionNN +
(NN+ ,
)NN, -
;NN- .
}OO 	
publicRR 
virtualRR 
TaskRR 
ScheduleAsyncRR )
(RR) *
ActionRR* 0
actionRR1 7
,RR7 8
TimeSpanRR9 A
delayRRB G
)RRG H
=>RRI K
thisSS 
.SS 
ScheduleAsyncSS 
(SS 
actionSS %
,SS% &
delaySS' ,
,SS, -
CancellationTokenSS. ?
.SS? @
NoneSS@ D
)SSD E
;SSE F
publicVV 
virtualVV 
TaskVV 
ScheduleAsyncVV )
(VV) *
ActionVV* 0
<VV0 1
objectVV1 7
>VV7 8
actionVV9 ?
,VV? @
objectVVA G
stateVVH M
,VVM N
TimeSpanVVO W
delayVVX ]
,VV] ^
CancellationTokenVV_ p
cancellationToken	VVq Ç
)
VVÇ É
{WW 	
throwXX 
newXX !
NotSupportedExceptionXX +
(XX+ ,
)XX, -
;XX- .
}YY 	
public\\ 
virtual\\ 
Task\\ 
ScheduleAsync\\ )
(\\) *
Action\\* 0
<\\0 1
object\\1 7
>\\7 8
action\\9 ?
,\\? @
object\\A G
state\\H M
,\\M N
TimeSpan\\O W
delay\\X ]
)\\] ^
=>\\_ a
this]] 
.]] 
ScheduleAsync]] 
(]] 
action]] %
,]]% &
state]]' ,
,]], -
delay]]. 3
,]]3 4
CancellationToken]]5 F
.]]F G
None]]G K
)]]K L
;]]L M
public`` 
virtual`` 
Task`` 
ScheduleAsync`` )
(``) *
Action``* 0
action``1 7
,``7 8
TimeSpan``9 A
delay``B G
,``G H
CancellationToken``I Z
cancellationToken``[ l
)``l m
{aa 	
throwbb 
newbb !
NotSupportedExceptionbb +
(bb+ ,
)bb, -
;bb- .
}cc 	
publicff 
virtualff 
Taskff 
ScheduleAsyncff )
(ff) *
Actionff* 0
<ff0 1
objectff1 7
,ff7 8
objectff9 ?
>ff? @
actionffA G
,ffG H
objectffI O
contextffP W
,ffW X
objectffY _
stateff` e
,ffe f
TimeSpanffg o
delayffp u
)ffu v
=>ffw y
thisgg 
.gg 
ScheduleAsyncgg 
(gg 
actiongg %
,gg% &
contextgg' .
,gg. /
stategg0 5
,gg5 6
delaygg7 <
,gg< =
CancellationTokengg> O
.ggO P
NoneggP T
)ggT U
;ggU V
publicjj 
virtualjj 
Taskjj 
ScheduleAsyncjj )
(jj) *
Actionkk 
<kk 
objectkk 
,kk 
objectkk !
>kk! "
actionkk# )
,kk) *
objectll 
contextll 
,ll 
objectmm 
statemm 
,mm 
TimeSpannn 
delaynn 
,nn 
CancellationTokenoo 
cancellationTokenoo /
)oo/ 0
{pp 	
throwqq 
newqq !
NotSupportedExceptionqq +
(qq+ ,
)qq, -
;qq- .
}rr 	
publicuu 
Taskuu #
ShutdownGracefullyAsyncuu +
(uu+ ,
)uu, -
=>uu. 0
thisuu1 5
.uu5 6#
ShutdownGracefullyAsyncuu6 M
(uuM N&
DefaultShutdownQuietPerioduuN h
,uuh i#
DefaultShutdownTimeout	uuj Ä
)
uuÄ Å
;
uuÅ Ç
publicxx 
abstractxx 
Taskxx #
ShutdownGracefullyAsyncxx 4
(xx4 5
TimeSpanxx5 =
quietPeriodxx> I
,xxI J
TimeSpanxxK S
timeoutxxT [
)xx[ \
;xx\ ]
	protected{{ 
void{{ 
SetCurrentExecutor{{ )
({{) *
IEventExecutor{{* 8
executor{{9 A
){{A B
=>{{C E 
ExecutionEnvironment{{F Z
.{{Z [
SetCurrentExecutor{{[ m
({{m n
executor{{n v
){{v w
;{{w x
	protected}} 
static}} 
void}} 
SafeExecute}} )
(}}) *
	IRunnable}}* 3
task}}4 8
)}}8 9
{~~ 	
try 
{
ÄÄ 
task
ÅÅ 
.
ÅÅ 
Run
ÅÅ 
(
ÅÅ 
)
ÅÅ 
;
ÅÅ 
}
ÇÇ 
catch
ÉÉ 
(
ÉÉ 
	Exception
ÉÉ 
ex
ÉÉ 
)
ÉÉ  
{
ÑÑ 
Logger
ÖÖ 
.
ÖÖ 
Warn
ÖÖ 
(
ÖÖ 
$str
ÖÖ B
,
ÖÖB C
task
ÖÖD H
,
ÖÖH I
ex
ÖÖJ L
)
ÖÖL M
;
ÖÖM N
}
ÜÜ 
}
áá 	
}
àà 
}ââ ëp
xC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\AbstractEventExecutorGroup.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

abstract 
class &
AbstractEventExecutorGroup 4
:5 6
IEventExecutorGroup7 J
{ 
static 
readonly 
TimeSpan  &
DefaultShutdownQuietPeriod! ;
=< =
TimeSpan> F
.F G
FromSecondsG R
(R S
$numS T
)T U
;U V
static 
readonly 
TimeSpan  "
DefaultShutdownTimeout! 7
=8 9
TimeSpan: B
.B C
FromSecondsC N
(N O
$numO Q
)Q R
;R S
public 
abstract 
bool 

IsShutdown '
{( )
get* -
;- .
}/ 0
public 
abstract 
bool 
IsTerminated )
{* +
get, /
;/ 0
}1 2
public 
abstract 
bool 
IsShuttingDown +
{, -
get. 1
;1 2
}3 4
public 
abstract 
Task !
TerminationCompletion 2
{3 4
get5 8
;8 9
}: ;
public 
IEnumerable 
< 
IEventExecutor )
>) *
Items+ 0
=>1 3
this4 8
.8 9
GetItems9 A
(A B
)B C
;C D
public 
abstract 
IEventExecutor &
GetNext' .
(. /
)/ 0
;0 1
public 
void 
Execute 
( 
	IRunnable %
task& *
)* +
=>, .
this/ 3
.3 4
GetNext4 ;
(; <
)< =
.= >
Execute> E
(E F
taskF J
)J K
;K L
public 
void 
Execute 
( 
Action "
<" #
object# )
>) *
action+ 1
,1 2
object3 9
state: ?
)? @
=>A C
thisD H
.H I
GetNextI P
(P Q
)Q R
.R S
ExecuteS Z
(Z [
action[ a
,a b
statec h
)h i
;i j
public   
void   
Execute   
(   
Action   "
action  # )
)  ) *
=>  + -
this  . 2
.  2 3
GetNext  3 :
(  : ;
)  ; <
.  < =
Execute  = D
(  D E
action  E K
)  K L
;  L M
public"" 
void"" 
Execute"" 
("" 
Action"" "
<""" #
object""# )
,"") *
object""+ 1
>""1 2
action""3 9
,""9 :
object""; A
context""B I
,""I J
object""K Q
state""R W
)""W X
=>""Y [
this""\ `
.""` a
GetNext""a h
(""h i
)""i j
.""j k
Execute""k r
(""r s
action""s y
,""y z
context	""{ Ç
,
""Ç É
state
""Ñ â
)
""â ä
;
""ä ã
public$$ 
Task$$ 
<$$ 
T$$ 
>$$ 
SubmitAsync$$ "
<$$" #
T$$# $
>$$$ %
($$% &
Func$$& *
<$$* +
T$$+ ,
>$$, -
func$$. 2
)$$2 3
=>$$4 6
this$$7 ;
.$$; <
GetNext$$< C
($$C D
)$$D E
.$$E F
SubmitAsync$$F Q
($$Q R
func$$R V
)$$V W
;$$W X
public&& 
Task&& 
<&& 
T&& 
>&& 
SubmitAsync&& "
<&&" #
T&&# $
>&&$ %
(&&% &
Func&&& *
<&&* +
T&&+ ,
>&&, -
func&&. 2
,&&2 3
CancellationToken&&4 E
cancellationToken&&F W
)&&W X
=>&&Y [
this&&\ `
.&&` a
GetNext&&a h
(&&h i
)&&i j
.&&j k
SubmitAsync&&k v
(&&v w
func&&w {
,&&{ |
cancellationToken	&&} é
)
&&é è
;
&&è ê
public(( 
Task(( 
<(( 
T(( 
>(( 
SubmitAsync(( "
<((" #
T((# $
>(($ %
(((% &
Func((& *
<((* +
object((+ 1
,((1 2
T((3 4
>((4 5
func((6 :
,((: ;
object((< B
state((C H
)((H I
=>((J L
GetNext((M T
(((T U
)((U V
.((V W
SubmitAsync((W b
(((b c
func((c g
,((g h
state((i n
)((n o
;((o p
public** 
Task** 
<** 
T** 
>** 
SubmitAsync** "
<**" #
T**# $
>**$ %
(**% &
Func**& *
<*** +
object**+ 1
,**1 2
T**3 4
>**4 5
func**6 :
,**: ;
object**< B
state**C H
,**H I
CancellationToken**J [
cancellationToken**\ m
)**m n
=>**o q
this**r v
.**v w
GetNext**w ~
(**~ 
)	** Ä
.
**Ä Å
SubmitAsync
**Å å
(
**å ç
func
**ç ë
,
**ë í
state
**ì ò
,
**ò ô
cancellationToken
**ö ´
)
**´ ¨
;
**¨ ≠
public,, 
Task,, 
<,, 
T,, 
>,, 
SubmitAsync,, "
<,," #
T,,# $
>,,$ %
(,,% &
Func,,& *
<,,* +
object,,+ 1
,,,1 2
object,,3 9
,,,9 :
T,,; <
>,,< =
func,,> B
,,,B C
object,,D J
context,,K R
,,,R S
object,,T Z
state,,[ `
),,` a
=>,,b d
this,,e i
.,,i j
GetNext,,j q
(,,q r
),,r s
.,,s t
SubmitAsync,,t 
(	,, Ä
func
,,Ä Ñ
,
,,Ñ Ö
context
,,Ü ç
,
,,ç é
state
,,è î
)
,,î ï
;
,,ï ñ
public.. 
Task.. 
<.. 
T.. 
>.. 
SubmitAsync.. "
<.." #
T..# $
>..$ %
(..% &
Func..& *
<..* +
object..+ 1
,..1 2
object..3 9
,..9 :
T..; <
>..< =
func..> B
,..B C
object..D J
context..K R
,..R S
object..T Z
state..[ `
,..` a
CancellationToken..b s
cancellationToken	..t Ö
)
..Ö Ü
=>
..á â
this
..ä é
.
..é è
GetNext
..è ñ
(
..ñ ó
)
..ó ò
.
..ò ô
SubmitAsync
..ô §
(
..§ •
func
..• ©
,
..© ™
context
..´ ≤
,
..≤ ≥
cancellationToken
..¥ ≈
)
..≈ ∆
;
..∆ «
public00 
IScheduledTask00 
Schedule00 &
(00& '
	IRunnable00' 0
action001 7
,007 8
TimeSpan009 A
delay00B G
)00G H
=>00I K
this00L P
.00P Q
GetNext00Q X
(00X Y
)00Y Z
.00Z [
Schedule00[ c
(00c d
action00d j
,00j k
delay00l q
)00q r
;00r s
public22 
IScheduledTask22 
Schedule22 &
(22& '
Action22' -
action22. 4
,224 5
TimeSpan226 >
delay22? D
)22D E
=>22F H
this22I M
.22M N
GetNext22N U
(22U V
)22V W
.22W X
Schedule22X `
(22` a
action22a g
,22g h
delay22i n
)22n o
;22o p
public44 
IScheduledTask44 
Schedule44 &
(44& '
Action44' -
<44- .
object44. 4
>444 5
action446 <
,44< =
object44> D
state44E J
,44J K
TimeSpan44L T
delay44U Z
)44Z [
=>44\ ^
this44_ c
.44c d
GetNext44d k
(44k l
)44l m
.44m n
Schedule44n v
(44v w
action44w }
,44} ~
state	44 Ñ
,
44Ñ Ö
delay
44Ü ã
)
44ã å
;
44å ç
public66 
IScheduledTask66 
Schedule66 &
(66& '
Action66' -
<66- .
object66. 4
,664 5
object666 <
>66< =
action66> D
,66D E
object66F L
context66M T
,66T U
object66V \
state66] b
,66b c
TimeSpan66d l
delay66m r
)66r s
=>66t v
this66w {
.66{ |
GetNext	66| É
(
66É Ñ
)
66Ñ Ö
.
66Ö Ü
Schedule
66Ü é
(
66é è
action
66è ï
,
66ï ñ
context
66ó û
,
66û ü
state
66† •
,
66• ¶
delay
66ß ¨
)
66¨ ≠
;
66≠ Æ
public88 
Task88 
ScheduleAsync88 !
(88! "
Action88" (
<88( )
object88) /
>88/ 0
action881 7
,887 8
object889 ?
state88@ E
,88E F
TimeSpan88G O
delay88P U
,88U V
CancellationToken88W h
cancellationToken88i z
)88z {
=>88| ~
this	88 É
.
88É Ñ
GetNext
88Ñ ã
(
88ã å
)
88å ç
.
88ç é
ScheduleAsync
88é õ
(
88õ ú
action
88ú ¢
,
88¢ £
state
88§ ©
,
88© ™
delay
88´ ∞
,
88∞ ±
cancellationToken
88≤ √
)
88√ ƒ
;
88ƒ ≈
public:: 
Task:: 
ScheduleAsync:: !
(::! "
Action::" (
<::( )
object::) /
>::/ 0
action::1 7
,::7 8
object::9 ?
state::@ E
,::E F
TimeSpan::G O
delay::P U
)::U V
=>::W Y
this::Z ^
.::^ _
GetNext::_ f
(::f g
)::g h
.::h i
ScheduleAsync::i v
(::v w
action::w }
,::} ~
state	:: Ñ
,
::Ñ Ö
delay
::Ü ã
)
::ã å
;
::å ç
public<< 
Task<< 
ScheduleAsync<< !
(<<! "
Action<<" (
action<<) /
,<</ 0
TimeSpan<<1 9
delay<<: ?
,<<? @
CancellationToken<<A R
cancellationToken<<S d
)<<d e
=><<f h
this<<i m
.<<m n
GetNext<<n u
(<<u v
)<<v w
.<<w x
ScheduleAsync	<<x Ö
(
<<Ö Ü
action
<<Ü å
,
<<å ç
delay
<<é ì
,
<<ì î
cancellationToken
<<ï ¶
)
<<¶ ß
;
<<ß ®
public>> 
Task>> 
ScheduleAsync>> !
(>>! "
Action>>" (
action>>) /
,>>/ 0
TimeSpan>>1 9
delay>>: ?
)>>? @
=>>>A C
this>>D H
.>>H I
GetNext>>I P
(>>P Q
)>>Q R
.>>R S
ScheduleAsync>>S `
(>>` a
action>>a g
,>>g h
delay>>i n
)>>n o
;>>o p
public@@ 
Task@@ 
ScheduleAsync@@ !
(@@! "
Action@@" (
<@@( )
object@@) /
,@@/ 0
object@@1 7
>@@7 8
action@@9 ?
,@@? @
object@@A G
context@@H O
,@@O P
object@@Q W
state@@X ]
,@@] ^
TimeSpan@@_ g
delay@@h m
)@@m n
=>@@o q
this@@r v
.@@v w
GetNext@@w ~
(@@~ 
)	@@ Ä
.
@@Ä Å
ScheduleAsync
@@Å é
(
@@é è
action
@@è ï
,
@@ï ñ
context
@@ó û
,
@@û ü
state
@@† •
,
@@• ¶
delay
@@ß ¨
)
@@¨ ≠
;
@@≠ Æ
publicBB 
TaskBB 
ScheduleAsyncBB !
(BB! "
ActionBB" (
<BB( )
objectBB) /
,BB/ 0
objectBB1 7
>BB7 8
actionBB9 ?
,BB? @
objectBBA G
contextBBH O
,BBO P
objectBBQ W
stateBBX ]
,BB] ^
TimeSpanBB_ g
delayBBh m
,BBm n
CancellationToken	BBo Ä
cancellationToken
BBÅ í
)
BBí ì
=>
BBî ñ
this
BBó õ
.
BBõ ú
GetNext
BBú £
(
BB£ §
)
BB§ •
.
BB• ¶
ScheduleAsync
BB¶ ≥
(
BB≥ ¥
action
BB¥ ∫
,
BB∫ ª
context
BBº √
,
BB√ ƒ
state
BB≈  
,
BB  À
delay
BBÃ —
)
BB— “
;
BB“ ”
publicDD 
TaskDD #
ShutdownGracefullyAsyncDD +
(DD+ ,
)DD, -
=>DD. 0
thisDD1 5
.DD5 6#
ShutdownGracefullyAsyncDD6 M
(DDM N&
DefaultShutdownQuietPeriodDDN h
,DDh i#
DefaultShutdownTimeout	DDj Ä
)
DDÄ Å
;
DDÅ Ç
publicFF 
abstractFF 
TaskFF #
ShutdownGracefullyAsyncFF 4
(FF4 5
TimeSpanFF5 =
quietPeriodFF> I
,FFI J
TimeSpanFFK S
timeoutFFT [
)FF[ \
;FF\ ]
	protectedHH 
abstractHH 
IEnumerableHH &
<HH& '
IEventExecutorHH' 5
>HH5 6
GetItemsHH7 ?
(HH? @
)HH@ A
;HHA B
}II 
}JJ œä
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\AbstractExecutorService.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public

 

abstract

 
class

 #
AbstractExecutorService

 1
:

2 3
IExecutorService

4 D
{ 
public 
abstract 
bool 

IsShutdown '
{( )
get* -
;- .
}/ 0
public 
abstract 
bool 
IsTerminated )
{* +
get, /
;/ 0
}1 2
public 
Task 
< 
T 
> 
SubmitAsync "
<" #
T# $
>$ %
(% &
Func& *
<* +
T+ ,
>, -
func. 2
)2 3
=>4 6
this7 ;
.; <
SubmitAsync< G
(G H
funcH L
,L M
CancellationTokenN _
._ `
None` d
)d e
;e f
public 
Task 
< 
T 
> 
SubmitAsync "
<" #
T# $
>$ %
(% &
Func& *
<* +
T+ ,
>, -
func. 2
,2 3
CancellationToken4 E
cancellationTokenF W
)W X
{ 	
var 
node 
= 
new 
FuncSubmitQueueNode .
<. /
T/ 0
>0 1
(1 2
func2 6
,6 7
cancellationToken8 I
)I J
;J K
this 
. 
Execute 
( 
node 
) 
; 
return 
node 
. 

Completion "
;" #
} 	
public 
Task 
< 
T 
> 
SubmitAsync "
<" #
T# $
>$ %
(% &
Func& *
<* +
object+ 1
,1 2
T3 4
>4 5
func6 :
,: ;
object< B
stateC H
)H I
=>J L
thisM Q
.Q R
SubmitAsyncR ]
(] ^
func^ b
,b c
stated i
,i j
CancellationTokenk |
.| }
None	} Å
)
Å Ç
;
Ç É
public!! 
Task!! 
<!! 
T!! 
>!! 
SubmitAsync!! "
<!!" #
T!!# $
>!!$ %
(!!% &
Func!!& *
<!!* +
object!!+ 1
,!!1 2
T!!3 4
>!!4 5
func!!6 :
,!!: ;
object!!< B
state!!C H
,!!H I
CancellationToken!!J [
cancellationToken!!\ m
)!!m n
{"" 	
var## 
node## 
=## 
new## $
StateFuncSubmitQueueNode## 3
<##3 4
T##4 5
>##5 6
(##6 7
func##7 ;
,##; <
state##= B
,##B C
cancellationToken##D U
)##U V
;##V W
this$$ 
.$$ 
Execute$$ 
($$ 
node$$ 
)$$ 
;$$ 
return%% 
node%% 
.%% 

Completion%% "
;%%" #
}&& 	
public)) 
Task)) 
<)) 
T)) 
>)) 
SubmitAsync)) "
<))" #
T))# $
>))$ %
())% &
Func))& *
<))* +
object))+ 1
,))1 2
object))3 9
,))9 :
T)); <
>))< =
func))> B
,))B C
object))D J
context))K R
,))R S
object))T Z
state))[ `
)))` a
=>))b d
this** 
.** 
SubmitAsync** 
(** 
func** !
,**! "
context**# *
,*** +
state**, 1
,**1 2
CancellationToken**3 D
.**D E
None**E I
)**I J
;**J K
public-- 
Task-- 
<-- 
T-- 
>-- 
SubmitAsync-- "
<--" #
T--# $
>--$ %
(--% &
Func.. 
<.. 
object.. 
,.. 
object.. 
,..  
T..! "
>.." #
func..$ (
,..( )
object// 
context// 
,// 
object00 
state00 
,00 
CancellationToken11 
cancellationToken11 /
)11/ 0
{22 	
var33 
node33 
=33 
new33 /
#StateFuncWithContextSubmitQueueNode33 >
<33> ?
T33? @
>33@ A
(33A B
func33B F
,33F G
context33H O
,33O P
state33Q V
,33V W
cancellationToken33X i
)33i j
;33j k
this44 
.44 
Execute44 
(44 
node44 
)44 
;44 
return55 
node55 
.55 

Completion55 "
;55" #
}66 	
public99 
abstract99 
void99 
Execute99 $
(99$ %
	IRunnable99% .
task99/ 3
)993 4
;994 5
public<< 
void<< 
Execute<< 
(<< 
Action<< "
<<<" #
object<<# )
><<) *
action<<+ 1
,<<1 2
object<<3 9
state<<: ?
)<<? @
=><<A C
this<<D H
.<<H I
Execute<<I P
(<<P Q
new<<Q T$
StateActionTaskQueueNode<<U m
(<<m n
action<<n t
,<<t u
state<<v {
)<<{ |
)<<| }
;<<} ~
public?? 
void?? 
Execute?? 
(?? 
Action?? "
<??" #
object??# )
,??) *
object??+ 1
>??1 2
action??3 9
,??9 :
object??; A
context??B I
,??I J
object??K Q
state??R W
)??W X
=>??Y [
this??\ `
.??` a
Execute??a h
(??h i
new??i l0
#StateActionWithContextTaskQueueNode	??m ê
(
??ê ë
action
??ë ó
,
??ó ò
context
??ô †
,
??† °
state
??¢ ß
)
??ß ®
)
??® ©
;
??© ™
publicBB 
voidBB 
ExecuteBB 
(BB 
ActionBB "
actionBB# )
)BB) *
=>BB+ -
thisBB. 2
.BB2 3
ExecuteBB3 :
(BB: ;
newBB; >
ActionTaskQueueNodeBB? R
(BBR S
actionBBS Y
)BBY Z
)BBZ [
;BB[ \
sealedFF 
classFF 
ActionTaskQueueNodeFF (
:FF) *
	IRunnableFF+ 4
{GG 	
readonlyHH 
ActionHH 
actionHH "
;HH" #
publicJJ 
ActionTaskQueueNodeJJ &
(JJ& '
ActionJJ' -
actionJJ. 4
)JJ4 5
{KK 
thisLL 
.LL 
actionLL 
=LL 
actionLL $
;LL$ %
}MM 
publicOO 
voidOO 
RunOO 
(OO 
)OO 
=>OO  
thisOO! %
.OO% &
actionOO& ,
(OO, -
)OO- .
;OO. /
}PP 	
sealedRR 
classRR $
StateActionTaskQueueNodeRR -
:RR. /
	IRunnableRR0 9
{SS 	
readonlyTT 
ActionTT 
<TT 
objectTT "
>TT" #
actionTT$ *
;TT* +
readonlyUU 
objectUU 
stateUU !
;UU! "
publicWW $
StateActionTaskQueueNodeWW +
(WW+ ,
ActionWW, 2
<WW2 3
objectWW3 9
>WW9 :
actionWW; A
,WWA B
objectWWC I
stateWWJ O
)WWO P
{XX 
thisYY 
.YY 
actionYY 
=YY 
actionYY $
;YY$ %
thisZZ 
.ZZ 
stateZZ 
=ZZ 
stateZZ "
;ZZ" #
}[[ 
public]] 
void]] 
Run]] 
(]] 
)]] 
=>]]  
this]]! %
.]]% &
action]]& ,
(]], -
this]]- 1
.]]1 2
state]]2 7
)]]7 8
;]]8 9
}^^ 	
sealed`` 
class`` /
#StateActionWithContextTaskQueueNode`` 8
:``9 :
	IRunnable``; D
{aa 	
readonlybb 
Actionbb 
<bb 
objectbb "
,bb" #
objectbb$ *
>bb* +
actionbb, 2
;bb2 3
readonlycc 
objectcc 
contextcc #
;cc# $
readonlydd 
objectdd 
statedd !
;dd! "
publicff /
#StateActionWithContextTaskQueueNodeff 6
(ff6 7
Actionff7 =
<ff= >
objectff> D
,ffD E
objectffF L
>ffL M
actionffN T
,ffT U
objectffV \
contextff] d
,ffd e
objectfff l
stateffm r
)ffr s
{gg 
thishh 
.hh 
actionhh 
=hh 
actionhh $
;hh$ %
thisii 
.ii 
contextii 
=ii 
contextii &
;ii& '
thisjj 
.jj 
statejj 
=jj 
statejj "
;jj" #
}kk 
publicmm 
voidmm 
Runmm 
(mm 
)mm 
=>mm  
thismm! %
.mm% &
actionmm& ,
(mm, -
thismm- 1
.mm1 2
contextmm2 9
,mm9 :
thismm; ?
.mm? @
statemm@ E
)mmE F
;mmF G
}nn 	
abstractpp 
classpp 
FuncQueueNodeBasepp (
<pp( )
Tpp) *
>pp* +
:pp, -
	IRunnablepp. 7
{qq 	
readonlyrr  
TaskCompletionSourcerr )
<rr) *
Trr* +
>rr+ ,
promiserr- 4
;rr4 5
readonlyss 
CancellationTokenss &
cancellationTokenss' 8
;ss8 9
	protecteduu 
FuncQueueNodeBaseuu '
(uu' ( 
TaskCompletionSourceuu( <
<uu< =
Tuu= >
>uu> ?
promiseuu@ G
,uuG H
CancellationTokenuuI Z
cancellationTokenuu[ l
)uul m
{vv 
thisww 
.ww 
promiseww 
=ww 
promiseww &
;ww& '
thisxx 
.xx 
cancellationTokenxx &
=xx' (
cancellationTokenxx) :
;xx: ;
}yy 
public{{ 
Task{{ 
<{{ 
T{{ 
>{{ 

Completion{{ %
=>{{& (
this{{) -
.{{- .
promise{{. 5
.{{5 6
Task{{6 :
;{{: ;
public}} 
void}} 
Run}} 
(}} 
)}} 
{~~ 
if 
( 
this 
. 
cancellationToken *
.* +#
IsCancellationRequested+ B
)B C
{
ÄÄ 
this
ÅÅ 
.
ÅÅ 
promise
ÅÅ  
.
ÅÅ  !
TrySetCanceled
ÅÅ! /
(
ÅÅ/ 0
)
ÅÅ0 1
;
ÅÅ1 2
return
ÇÇ 
;
ÇÇ 
}
ÉÉ 
try
ÖÖ 
{
ÜÜ 
T
áá 
result
áá 
=
áá 
this
áá #
.
áá# $
Call
áá$ (
(
áá( )
)
áá) *
;
áá* +
this
àà 
.
àà 
promise
àà  
.
àà  !
TrySetResult
àà! -
(
àà- .
result
àà. 4
)
àà4 5
;
àà5 6
}
ââ 
catch
ää 
(
ää 
	Exception
ää  
ex
ää! #
)
ää# $
{
ãã 
this
çç 
.
çç 
promise
çç  
.
çç  !
TrySetException
çç! 0
(
çç0 1
ex
çç1 3
)
çç3 4
;
çç4 5
}
éé 
}
èè 
	protected
ëë 
abstract
ëë 
T
ëë  
Call
ëë! %
(
ëë% &
)
ëë& '
;
ëë' (
}
íí 	
sealed
îî 
class
îî !
FuncSubmitQueueNode
îî (
<
îî( )
T
îî) *
>
îî* +
:
îî, -
FuncQueueNodeBase
îî. ?
<
îî? @
T
îî@ A
>
îîA B
{
ïï 	
readonly
ññ 
Func
ññ 
<
ññ 
T
ññ 
>
ññ 
func
ññ !
;
ññ! "
public
òò !
FuncSubmitQueueNode
òò &
(
òò& '
Func
òò' +
<
òò+ ,
T
òò, -
>
òò- .
func
òò/ 3
,
òò3 4
CancellationToken
òò5 F
cancellationToken
òòG X
)
òòX Y
:
ôô 
base
ôô 
(
ôô 
new
ôô "
TaskCompletionSource
ôô /
<
ôô/ 0
T
ôô0 1
>
ôô1 2
(
ôô2 3
)
ôô3 4
,
ôô4 5
cancellationToken
ôô6 G
)
ôôG H
{
öö 
this
õõ 
.
õõ 
func
õõ 
=
õõ 
func
õõ  
;
õõ  !
}
úú 
	protected
ûû 
override
ûû 
T
ûû  
Call
ûû! %
(
ûû% &
)
ûû& '
=>
ûû( *
this
ûû+ /
.
ûû/ 0
func
ûû0 4
(
ûû4 5
)
ûû5 6
;
ûû6 7
}
üü 	
sealed
°° 
class
°° &
StateFuncSubmitQueueNode
°° -
<
°°- .
T
°°. /
>
°°/ 0
:
°°1 2
FuncQueueNodeBase
°°3 D
<
°°D E
T
°°E F
>
°°F G
{
¢¢ 	
readonly
££ 
Func
££ 
<
££ 
object
££  
,
££  !
T
££" #
>
££# $
func
££% )
;
££) *
public
•• &
StateFuncSubmitQueueNode
•• +
(
••+ ,
Func
••, 0
<
••0 1
object
••1 7
,
••7 8
T
••9 :
>
••: ;
func
••< @
,
••@ A
object
••B H
state
••I N
,
••N O
CancellationToken
••P a
cancellationToken
••b s
)
••s t
:
¶¶ 
base
¶¶ 
(
¶¶ 
new
¶¶ "
TaskCompletionSource
¶¶ /
<
¶¶/ 0
T
¶¶0 1
>
¶¶1 2
(
¶¶2 3
state
¶¶3 8
)
¶¶8 9
,
¶¶9 :
cancellationToken
¶¶; L
)
¶¶L M
{
ßß 
this
®® 
.
®® 
func
®® 
=
®® 
func
®®  
;
®®  !
}
©© 
	protected
´´ 
override
´´ 
T
´´  
Call
´´! %
(
´´% &
)
´´& '
=>
´´( *
this
´´+ /
.
´´/ 0
func
´´0 4
(
´´4 5
this
´´5 9
.
´´9 :

Completion
´´: D
.
´´D E

AsyncState
´´E O
)
´´O P
;
´´P Q
}
¨¨ 	
sealed
ÆÆ 
class
ÆÆ 1
#StateFuncWithContextSubmitQueueNode
ÆÆ 8
<
ÆÆ8 9
T
ÆÆ9 :
>
ÆÆ: ;
:
ÆÆ< =
FuncQueueNodeBase
ÆÆ> O
<
ÆÆO P
T
ÆÆP Q
>
ÆÆQ R
{
ØØ 	
readonly
∞∞ 
Func
∞∞ 
<
∞∞ 
object
∞∞  
,
∞∞  !
object
∞∞" (
,
∞∞( )
T
∞∞* +
>
∞∞+ ,
func
∞∞- 1
;
∞∞1 2
readonly
±± 
object
±± 
context
±± #
;
±±# $
public
≥≥ 1
#StateFuncWithContextSubmitQueueNode
≥≥ 6
(
≥≥6 7
Func
¥¥ 
<
¥¥ 
object
¥¥ 
,
¥¥ 
object
¥¥ #
,
¥¥# $
T
¥¥% &
>
¥¥& '
func
¥¥( ,
,
¥¥, -
object
µµ 
context
µµ 
,
µµ 
object
∂∂ 
state
∂∂ 
,
∂∂ 
CancellationToken
∑∑ !
cancellationToken
∑∑" 3
)
∑∑3 4
:
∏∏ 
base
∏∏ 
(
∏∏ 
new
∏∏ "
TaskCompletionSource
∏∏ /
<
∏∏/ 0
T
∏∏0 1
>
∏∏1 2
(
∏∏2 3
state
∏∏3 8
)
∏∏8 9
,
∏∏9 :
cancellationToken
∏∏; L
)
∏∏L M
{
ππ 
this
∫∫ 
.
∫∫ 
func
∫∫ 
=
∫∫ 
func
∫∫  
;
∫∫  !
this
ªª 
.
ªª 
context
ªª 
=
ªª 
context
ªª &
;
ªª& '
}
ºº 
	protected
ææ 
override
ææ 
T
ææ  
Call
ææ! %
(
ææ% &
)
ææ& '
=>
ææ( *
this
ææ+ /
.
ææ/ 0
func
ææ0 4
(
ææ4 5
this
ææ5 9
.
ææ9 :
context
ææ: A
,
ææA B
this
ææC G
.
ææG H

Completion
ææH R
.
ææR S

AsyncState
ææS ]
)
ææ] ^
;
ææ^ _
}
øø 	
}
¬¬ 
}√√ Ìç
|C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\AbstractScheduledEventExecutor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

abstract 
class *
AbstractScheduledEventExecutor 8
:9 :!
AbstractEventExecutor; P
{ 
	protected 
readonly 
PriorityQueue (
<( )
IScheduledRunnable) ;
>; <
ScheduledTaskQueue= O
=P Q
newR U
PriorityQueueV c
<c d
IScheduledRunnabled v
>v w
(w x
)x y
;y z
	protected *
AbstractScheduledEventExecutor 0
(0 1
)1 2
{ 	
} 	
	protected *
AbstractScheduledEventExecutor 0
(0 1
IEventExecutorGroup1 D
parentE K
)K L
: 
base 
( 
parent 
) 
{ 	
} 	
	protected 
static 
PreciseTimeSpan (
GetNanos) 1
(1 2
)2 3
=>4 6
PreciseTimeSpan7 F
.F G
	FromStartG P
;P Q
	protected 
static 
bool 
IsNullOrEmpty +
<+ ,
T, -
>- .
(. /
PriorityQueue/ <
<< =
T= >
>> ?
	taskQueue@ I
)I J
where   
T   
:   
class   
{!! 	
return"" 
	taskQueue"" 
=="" 
null""  $
||""% '
	taskQueue""( 1
.""1 2
Count""2 7
==""8 :
$num""; <
;""< =
}## 	
	protected)) 
virtual)) 
void))  
CancelScheduledTasks)) 3
())3 4
)))4 5
{** 	
Contract++ 
.++ 
Assert++ 
(++ 
this++  
.++  !
InEventLoop++! ,
)++, -
;++- .
PriorityQueue,, 
<,, 
IScheduledRunnable,, ,
>,,, -
scheduledTaskQueue,,. @
=,,A B
this,,C G
.,,G H
ScheduledTaskQueue,,H Z
;,,Z [
if-- 
(-- 
IsNullOrEmpty-- 
(-- 
scheduledTaskQueue-- 0
)--0 1
)--1 2
{.. 
return// 
;// 
}00 
IScheduledRunnable22 
[22 
]22  
tasks22! &
=22' (
scheduledTaskQueue22) ;
.22; <
ToArray22< C
(22C D
)22D E
;22E F
foreach33 
(33 
IScheduledRunnable33 '
t33( )
in33* ,
tasks33- 2
)332 3
{44 
t55 
.55 
Cancel55 
(55 
)55 
;55 
}66 
this88 
.88 
ScheduledTaskQueue88 #
.88# $
Clear88$ )
(88) *
)88* +
;88+ ,
}99 	
	protected;; 
IScheduledRunnable;; $
PollScheduledTask;;% 6
(;;6 7
);;7 8
=>;;9 ;
this;;< @
.;;@ A
PollScheduledTask;;A R
(;;R S
GetNanos;;S [
(;;[ \
);;\ ]
);;] ^
;;;^ _
	protected== 
IScheduledRunnable== $
PollScheduledTask==% 6
(==6 7
PreciseTimeSpan==7 F
nanoTime==G O
)==O P
{>> 	
Contract?? 
.?? 
Assert?? 
(?? 
this??  
.??  !
InEventLoop??! ,
)??, -
;??- .
IScheduledRunnableAA 
scheduledTaskAA ,
=AA- .
thisAA/ 3
.AA3 4
ScheduledTaskQueueAA4 F
.AAF G
PeekAAG K
(AAK L
)AAL M
;AAM N
ifBB 
(BB 
scheduledTaskBB 
==BB  
nullBB! %
)BB% &
{CC 
returnDD 
nullDD 
;DD 
}EE 
ifGG 
(GG 
scheduledTaskGG 
.GG 
DeadlineGG &
<=GG' )
nanoTimeGG* 2
)GG2 3
{HH 
thisII 
.II 
ScheduledTaskQueueII '
.II' (
DequeueII( /
(II/ 0
)II0 1
;II1 2
returnJJ 
scheduledTaskJJ $
;JJ$ %
}KK 
returnLL 
nullLL 
;LL 
}MM 	
	protectedOO 
PreciseTimeSpanOO !"
NextScheduledTaskNanosOO" 8
(OO8 9
)OO9 :
{PP 	
IScheduledRunnableQQ !
nextScheduledRunnableQQ 4
=QQ5 6
thisQQ7 ;
.QQ; <
PeekScheduledTaskQQ< M
(QQM N
)QQN O
;QQO P
returnRR !
nextScheduledRunnableRR (
?RR( )
.RR) *
DeadlineRR* 2
??RR3 5
PreciseTimeSpanRR6 E
.RRE F
MinusOneRRF N
;RRN O
}SS 	
	protectedUU 
IScheduledRunnableUU $
PeekScheduledTaskUU% 6
(UU6 7
)UU7 8
{VV 	
PriorityQueueWW 
<WW 
IScheduledRunnableWW ,
>WW, -
scheduledTaskQueueWW. @
=WWA B
thisWWC G
.WWG H
ScheduledTaskQueueWWH Z
;WWZ [
returnXX 
IsNullOrEmptyXX  
(XX  !
scheduledTaskQueueXX! 3
)XX3 4
?XX5 6
nullXX7 ;
:XX< =
scheduledTaskQueueXX> P
.XXP Q
PeekXXQ U
(XXU V
)XXV W
;XXW X
}YY 	
	protected[[ 
bool[[ 
HasScheduledTasks[[ (
([[( )
)[[) *
{\\ 	
IScheduledRunnable]] 
scheduledTask]] ,
=]]- .
this]]/ 3
.]]3 4
ScheduledTaskQueue]]4 F
.]]F G
Peek]]G K
(]]K L
)]]L M
;]]M N
return^^ 
scheduledTask^^  
!=^^! #
null^^$ (
&&^^) +
scheduledTask^^, 9
.^^9 :
Deadline^^: B
<=^^C E
PreciseTimeSpan^^F U
.^^U V
	FromStart^^V _
;^^_ `
}__ 	
publicaa 
overrideaa 
IScheduledTaskaa &
Scheduleaa' /
(aa/ 0
	IRunnableaa0 9
actionaa: @
,aa@ A
TimeSpanaaB J
delayaaK P
)aaP Q
{bb 	
Contractcc 
.cc 
Requirescc 
(cc 
actioncc $
!=cc% '
nullcc( ,
)cc, -
;cc- .
returnee 
thisee 
.ee 
Scheduleee  
(ee  !
newee! $!
RunnableScheduledTaskee% :
(ee: ;
thisee; ?
,ee? @
actioneeA G
,eeG H
PreciseTimeSpaneeI X
.eeX Y
DeadlineeeY a
(eea b
delayeeb g
)eeg h
)eeh i
)eei j
;eej k
}ff 	
publichh 
overridehh 
IScheduledTaskhh &
Schedulehh' /
(hh/ 0
Actionhh0 6
actionhh7 =
,hh= >
TimeSpanhh? G
delayhhH M
)hhM N
{ii 	
Contractjj 
.jj 
Requiresjj 
(jj 
actionjj $
!=jj% '
nulljj( ,
)jj, -
;jj- .
returnll 
thisll 
.ll 
Schedulell  
(ll  !
newll! $
ActionScheduledTaskll% 8
(ll8 9
thisll9 =
,ll= >
actionll? E
,llE F
PreciseTimeSpanllG V
.llV W
DeadlinellW _
(ll_ `
delayll` e
)lle f
)llf g
)llg h
;llh i
}mm 	
publicoo 
overrideoo 
IScheduledTaskoo &
Scheduleoo' /
(oo/ 0
Actionoo0 6
<oo6 7
objectoo7 =
>oo= >
actionoo? E
,ooE F
objectooG M
stateooN S
,ooS T
TimeSpanooU ]
delayoo^ c
)ooc d
{pp 	
Contractqq 
.qq 
Requiresqq 
(qq 
actionqq $
!=qq% '
nullqq( ,
)qq, -
;qq- .
returnss 
thisss 
.ss 
Scheduless  
(ss  !
newss! $$
StateActionScheduledTaskss% =
(ss= >
thisss> B
,ssB C
actionssD J
,ssJ K
statessL Q
,ssQ R
PreciseTimeSpanssS b
.ssb c
Deadlinessc k
(ssk l
delayssl q
)ssq r
)ssr s
)sss t
;sst u
}tt 	
publicvv 
overridevv 
IScheduledTaskvv &
Schedulevv' /
(vv/ 0
Actionvv0 6
<vv6 7
objectvv7 =
,vv= >
objectvv? E
>vvE F
actionvvG M
,vvM N
objectvvO U
contextvvV ]
,vv] ^
objectvv_ e
statevvf k
,vvk l
TimeSpanvvm u
delayvvv {
)vv{ |
{ww 	
Contractxx 
.xx 
Requiresxx 
(xx 
actionxx $
!=xx% '
nullxx( ,
)xx, -
;xx- .
returnzz 
thiszz 
.zz 
Schedulezz  
(zz  !
newzz! $/
#StateActionWithContextScheduledTaskzz% H
(zzH I
thiszzI M
,zzM N
actionzzO U
,zzU V
contextzzW ^
,zz^ _
statezz` e
,zze f
PreciseTimeSpanzzg v
.zzv w
Deadlinezzw 
(	zz Ä
delay
zzÄ Ö
)
zzÖ Ü
)
zzÜ á
)
zzá à
;
zzà â
}{{ 	
public}} 
override}} 
Task}} 
ScheduleAsync}} *
(}}* +
Action}}+ 1
action}}2 8
,}}8 9
TimeSpan}}: B
delay}}C H
,}}H I
CancellationToken}}J [
cancellationToken}}\ m
)}}m n
{~~ 	
Contract 
. 
Requires 
( 
action $
!=% '
null( ,
), -
;- .
if
ÅÅ 
(
ÅÅ 
cancellationToken
ÅÅ !
.
ÅÅ! "%
IsCancellationRequested
ÅÅ" 9
)
ÅÅ9 :
{
ÇÇ 
return
ÉÉ 
TaskEx
ÉÉ 
.
ÉÉ 
	Cancelled
ÉÉ '
;
ÉÉ' (
}
ÑÑ 
if
ÜÜ 
(
ÜÜ 
!
ÜÜ 
cancellationToken
ÜÜ "
.
ÜÜ" #
CanBeCanceled
ÜÜ# 0
)
ÜÜ0 1
{
áá 
return
àà 
this
àà 
.
àà 
Schedule
àà $
(
àà$ %
action
àà% +
,
àà+ ,
delay
àà- 2
)
àà2 3
.
àà3 4

Completion
àà4 >
;
àà> ?
}
ââ 
return
ãã 
this
ãã 
.
ãã 
Schedule
ãã  
(
ãã  !
new
ãã! $&
ActionScheduledAsyncTask
ãã% =
(
ãã= >
this
ãã> B
,
ããB C
action
ããD J
,
ããJ K
PreciseTimeSpan
ããL [
.
ãã[ \
Deadline
ãã\ d
(
ããd e
delay
ããe j
)
ããj k
,
ããk l
cancellationToken
ããm ~
)
ãã~ 
)ãã Ä
.ããÄ Å

CompletionããÅ ã
;ããã å
}
åå 	
public
éé 
override
éé 
Task
éé 
ScheduleAsync
éé *
(
éé* +
Action
éé+ 1
<
éé1 2
object
éé2 8
>
éé8 9
action
éé: @
,
éé@ A
object
ééB H
state
ééI N
,
ééN O
TimeSpan
ééP X
delay
ééY ^
,
éé^ _
CancellationToken
éé` q 
cancellationTokenéér É
)ééÉ Ñ
{
èè 	
if
êê 
(
êê 
cancellationToken
êê !
.
êê! "%
IsCancellationRequested
êê" 9
)
êê9 :
{
ëë 
return
íí 
TaskEx
íí 
.
íí 
	Cancelled
íí '
;
íí' (
}
ìì 
if
ïï 
(
ïï 
!
ïï 
cancellationToken
ïï "
.
ïï" #
CanBeCanceled
ïï# 0
)
ïï0 1
{
ññ 
return
óó 
this
óó 
.
óó 
Schedule
óó $
(
óó$ %
action
óó% +
,
óó+ ,
state
óó- 2
,
óó2 3
delay
óó4 9
)
óó9 :
.
óó: ;

Completion
óó; E
;
óóE F
}
òò 
return
öö 
this
öö 
.
öö 
Schedule
öö  
(
öö  !
new
öö! $+
StateActionScheduledAsyncTask
öö% B
(
ööB C
this
ööC G
,
ööG H
action
ööI O
,
ööO P
state
ööQ V
,
ööV W
PreciseTimeSpan
ööX g
.
öög h
Deadline
ööh p
(
ööp q
delay
ööq v
)
ööv w
,
ööw x 
cancellationTokenööy ä
)ööä ã
)ööã å
.ööå ç

Completionööç ó
;ööó ò
}
õõ 	
public
ùù 
override
ùù 
Task
ùù 
ScheduleAsync
ùù *
(
ùù* +
Action
ùù+ 1
<
ùù1 2
object
ùù2 8
,
ùù8 9
object
ùù: @
>
ùù@ A
action
ùùB H
,
ùùH I
object
ùùJ P
context
ùùQ X
,
ùùX Y
object
ùùZ `
state
ùùa f
,
ùùf g
TimeSpan
ùùh p
delay
ùùq v
,
ùùv w 
CancellationTokenùùx â!
cancellationTokenùùä õ
)ùùõ ú
{
ûû 	
if
üü 
(
üü 
cancellationToken
üü !
.
üü! "%
IsCancellationRequested
üü" 9
)
üü9 :
{
†† 
return
°° 
TaskEx
°° 
.
°° 
	Cancelled
°° '
;
°°' (
}
¢¢ 
if
§§ 
(
§§ 
!
§§ 
cancellationToken
§§ "
.
§§" #
CanBeCanceled
§§# 0
)
§§0 1
{
•• 
return
¶¶ 
this
¶¶ 
.
¶¶ 
Schedule
¶¶ $
(
¶¶$ %
action
¶¶% +
,
¶¶+ ,
context
¶¶- 4
,
¶¶4 5
state
¶¶6 ;
,
¶¶; <
delay
¶¶= B
)
¶¶B C
.
¶¶C D

Completion
¶¶D N
;
¶¶N O
}
ßß 
return
©© 
this
©© 
.
©© 
Schedule
©©  
(
©©  !
new
©©! $6
(StateActionWithContextScheduledAsyncTask
©©% M
(
©©M N
this
©©N R
,
©©R S
action
©©T Z
,
©©Z [
context
©©\ c
,
©©c d
state
©©e j
,
©©j k
PreciseTimeSpan
©©l {
.
©©{ |
Deadline©©| Ñ
(©©Ñ Ö
delay©©Ö ä
)©©ä ã
,©©ã å!
cancellationToken©©ç û
)©©û ü
)©©ü †
.©©† °

Completion©©° ´
;©©´ ¨
}
™™ 	
	protected
¨¨  
IScheduledRunnable
¨¨ $
Schedule
¨¨% -
(
¨¨- . 
IScheduledRunnable
¨¨. @
task
¨¨A E
)
¨¨E F
{
≠≠ 	
if
ÆÆ 
(
ÆÆ 
this
ÆÆ 
.
ÆÆ 
InEventLoop
ÆÆ  
)
ÆÆ  !
{
ØØ 
this
∞∞ 
.
∞∞  
ScheduledTaskQueue
∞∞ '
.
∞∞' (
Enqueue
∞∞( /
(
∞∞/ 0
task
∞∞0 4
)
∞∞4 5
;
∞∞5 6
}
±± 
else
≤≤ 
{
≥≥ 
this
¥¥ 
.
¥¥ 
Execute
¥¥ 
(
¥¥ 
(
¥¥ 
e
¥¥ 
,
¥¥  
t
¥¥! "
)
¥¥" #
=>
¥¥$ &
(
¥¥' (
(
¥¥( ),
AbstractScheduledEventExecutor
¥¥) G
)
¥¥G H
e
¥¥H I
)
¥¥I J
.
¥¥J K 
ScheduledTaskQueue
¥¥K ]
.
¥¥] ^
Enqueue
¥¥^ e
(
¥¥e f
(
¥¥f g 
IScheduledRunnable
¥¥g y
)
¥¥y z
t
¥¥z {
)
¥¥{ |
,
¥¥| }
this¥¥~ Ç
,¥¥Ç É
task¥¥Ñ à
)¥¥à â
;¥¥â ä
}
µµ 
return
∂∂ 
task
∂∂ 
;
∂∂ 
}
∑∑ 	
internal
ππ 
void
ππ 
RemoveScheduled
ππ %
(
ππ% & 
IScheduledRunnable
ππ& 8
task
ππ9 =
)
ππ= >
{
∫∫ 	
if
ªª 
(
ªª 
this
ªª 
.
ªª 
InEventLoop
ªª  
)
ªª  !
{
ºº 
this
ΩΩ 
.
ΩΩ  
ScheduledTaskQueue
ΩΩ '
.
ΩΩ' (
Remove
ΩΩ( .
(
ΩΩ. /
task
ΩΩ/ 3
)
ΩΩ3 4
;
ΩΩ4 5
}
ææ 
else
øø 
{
¿¿ 
this
¡¡ 
.
¡¡ 
Execute
¡¡ 
(
¡¡ 
(
¡¡ 
e
¡¡ 
,
¡¡  
t
¡¡! "
)
¡¡" #
=>
¡¡$ &
(
¡¡' (
(
¡¡( ),
AbstractScheduledEventExecutor
¡¡) G
)
¡¡G H
e
¡¡H I
)
¡¡I J
.
¡¡J K 
ScheduledTaskQueue
¡¡K ]
.
¡¡] ^
Remove
¡¡^ d
(
¡¡d e
(
¡¡e f 
IScheduledRunnable
¡¡f x
)
¡¡x y
t
¡¡y z
)
¡¡z {
,
¡¡{ |
this¡¡} Å
,¡¡Å Ç
task¡¡É á
)¡¡á à
;¡¡à â
}
¬¬ 
}
√√ 	
}
ƒƒ 
}≈≈ ≈
vC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ActionScheduledAsyncTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed		 

class		 $
ActionScheduledAsyncTask		 )
:		* +
ScheduledAsyncTask		, >
{

 
readonly 
Action 
action 
; 
public $
ActionScheduledAsyncTask '
(' (*
AbstractScheduledEventExecutor( F
executorG O
,O P
ActionQ W
actionX ^
,^ _
PreciseTimeSpan` o
deadlinep x
,x y
CancellationToken	z ã
cancellationToken
å ù
)
ù û
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
)@ A
,A B
cancellationTokenC T
)T U
{ 	
this 
. 
action 
= 
action  
;  !
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
)9 :
;: ;
} 
} ±

qC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ActionScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed 

class 
ActionScheduledTask $
:% &
ScheduledTask' 4
{		 
readonly

 
Action

 
action

 
;

 
public 
ActionScheduledTask "
(" #*
AbstractScheduledEventExecutor# A
executorB J
,J K
ActionL R
actionS Y
,Y Z
PreciseTimeSpan[ j
deadlinek s
)s t
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
)@ A
)A B
{ 	
this 
. 
action 
= 
action  
;  !
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
)9 :
;: ;
} 
} ®	
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ExecutionEnvironment.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

static 
class  
ExecutionEnvironment ,
{		 
[

 	
ThreadStatic

	 
]

 
static 
IEventExecutor 
currentExecutor -
;- .
public 
static 
bool !
TryGetCurrentExecutor 0
(0 1
out1 4
IEventExecutor5 C
executorD L
)L M
{ 	
executor 
= 
currentExecutor &
;& '
return 
executor 
!= 
null #
;# $
} 	
internal 
static 
void 
SetCurrentExecutor /
(/ 0
IEventExecutor0 >
executor? G
)G H
=>I K
currentExecutorL [
=\ ]
executor^ f
;f g
} 
} Ä
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ExecutorTaskScheduler.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public		 

sealed		 
class		 !
ExecutorTaskScheduler		 -
:		. /
TaskScheduler		0 =
{

 
readonly 
IEventExecutor 
executor  (
;( )
bool 
started 
; 
public !
ExecutorTaskScheduler $
($ %
IEventExecutor% 3
executor4 <
)< =
{ 	
this 
. 
executor 
= 
executor $
;$ %
} 	
	protected 
override 
void 
	QueueTask  )
() *
Task* .
task/ 3
)3 4
{ 	
if 
( 
this 
. 
started 
) 
{ 
this 
. 
executor 
. 
Execute %
(% &
new& )
TaskQueueNode* 7
(7 8
this8 <
,< =
task> B
)B C
)C D
;D E
} 
else 
{ 
this 
. 
started 
= 
true #
;# $
this 
. 
TryExecuteTask #
(# $
task$ (
)( )
;) *
} 
}   	
	protected"" 
override"" 
bool""  
TryExecuteTaskInline""  4
(""4 5
Task""5 9
task"": >
,""> ?
bool""@ D#
taskWasPreviouslyQueued""E \
)""\ ]
{## 	
if$$ 
($$ #
taskWasPreviouslyQueued$$ '
||$$( *
!$$+ ,
this$$, 0
.$$0 1
executor$$1 9
.$$9 :
InEventLoop$$: E
)$$E F
{%% 
return&& 
false&& 
;&& 
}'' 
return)) 
this)) 
.)) 
TryExecuteTask)) &
())& '
task))' +
)))+ ,
;)), -
}** 	
	protected,, 
override,, 
IEnumerable,, &
<,,& '
Task,,' +
>,,+ ,
GetScheduledTasks,,- >
(,,> ?
),,? @
=>,,A C
null,,D H
;,,H I
	protected.. 
override.. 
bool.. 

TryDequeue..  *
(..* +
Task..+ /
task..0 4
)..4 5
=>..6 8
false..9 >
;..> ?
sealed00 
class00 
TaskQueueNode00 "
:00# $
	IRunnable00% .
{11 	
readonly22 !
ExecutorTaskScheduler22 *
	scheduler22+ 4
;224 5
readonly33 
Task33 
task33 
;33 
public55 
TaskQueueNode55  
(55  !!
ExecutorTaskScheduler55! 6
	scheduler557 @
,55@ A
Task55B F
task55G K
)55K L
{66 
this77 
.77 
	scheduler77 
=77  
	scheduler77! *
;77* +
this88 
.88 
task88 
=88 
task88  
;88  !
}99 
public;; 
void;; 
Run;; 
(;; 
);; 
=>;;  
this;;! %
.;;% &
	scheduler;;& /
.;;/ 0
TryExecuteTask;;0 >
(;;> ?
this;;? C
.;;C D
task;;D H
);;H I
;;;I J
}<< 	
}== 
}>> Á
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ICallable`T.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
	ICallable 
< 
out "
T# $
>$ %
{ 
T 	
Call
 
( 
) 
; 
}		 
}

 Ò
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IEventExecutor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
IEventExecutor #
:$ %
IEventExecutorGroup& 9
{		 
IEventExecutorGroup 
Parent "
{# $
get% (
;( )
}* +
bool 
InEventLoop 
{ 
get 
; 
}  !
bool 
IsInEventLoop 
( 
Thread !
thread" (
)( )
;) *
} 
} µ	
qC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IEventExecutorGroup.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
IEventExecutorGroup (
:) *%
IScheduledExecutorService+ D
{ 
IEnumerable 
< 
IEventExecutor "
>" #
Items$ )
{* +
get, /
;/ 0
}1 2
bool 
IsShuttingDown 
{ 
get !
;! "
}# $
Task #
ShutdownGracefullyAsync $
($ %
)% &
;& '
Task## #
ShutdownGracefullyAsync## $
(##$ %
TimeSpan##% -
quietPeriod##. 9
,##9 :
TimeSpan##; C
timeout##D K
)##K L
;##L M
Task(( !
TerminationCompletion(( "
{((# $
get((% (
;((( )
}((* +
IEventExecutor-- 
GetNext-- 
(-- 
)--  
;--  !
}.. 
}// ı
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IExecutor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
	IExecutor 
{ 
void 
Execute 
( 
	IRunnable 
task #
)# $
;$ %
void 
Execute 
( 
Action 
< 
object "
>" #
action$ *
,* +
object, 2
state3 8
)8 9
;9 :
void 
Execute 
( 
Action 
action "
)" #
;# $
void'' 
Execute'' 
('' 
Action'' 
<'' 
object'' "
,''" #
object''$ *
>''* +
action'', 2
,''2 3
object''4 :
context''; B
,''B C
object''D J
state''K P
)''P Q
;''Q R
}(( 
})) Û
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IExecutorService.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public		 

	interface		 
IExecutorService		 %
:		& '
	IExecutor		( 1
{

 
bool 

IsShutdown 
{ 
get 
; 
}  
bool 
IsTerminated 
{ 
get 
;  
}! "
Task 
< 
T 
> 
SubmitAsync 
< 
T 
> 
( 
Func #
<# $
T$ %
>% &
func' +
)+ ,
;, -
Task'' 
<'' 
T'' 
>'' 
SubmitAsync'' 
<'' 
T'' 
>'' 
('' 
Func'' #
<''# $
T''$ %
>''% &
func''' +
,''+ ,
CancellationToken''- >
cancellationToken''? P
)''P Q
;''Q R
Task11 
<11 
T11 
>11 
SubmitAsync11 
<11 
T11 
>11 
(11 
Func11 #
<11# $
object11$ *
,11* +
T11, -
>11- .
func11/ 3
,113 4
object115 ;
state11< A
)11A B
;11B C
Task;; 
<;; 
T;; 
>;; 
SubmitAsync;; 
<;; 
T;; 
>;; 
(;; 
Func;; #
<;;# $
object;;$ *
,;;* +
T;;, -
>;;- .
func;;/ 3
,;;3 4
object;;5 ;
state;;< A
,;;A B
CancellationToken;;C T
cancellationToken;;U f
);;f g
;;;g h
TaskEE 
<EE 
TEE 
>EE 
SubmitAsyncEE 
<EE 
TEE 
>EE 
(EE 
FuncEE #
<EE# $
objectEE$ *
,EE* +
objectEE, 2
,EE2 3
TEE4 5
>EE5 6
funcEE7 ;
,EE; <
objectEE= C
contextEED K
,EEK L
objectEEM S
stateEET Y
)EEY Z
;EEZ [
TaskOO 
<OO 
TOO 
>OO 
SubmitAsyncOO 
<OO 
TOO 
>OO 
(OO 
FuncOO #
<OO# $
objectOO$ *
,OO* +
objectOO, 2
,OO2 3
TOO4 5
>OO5 6
funcOO7 ;
,OO; <
objectOO= C
contextOOD K
,OOK L
objectOOM S
stateOOT Y
,OOY Z
CancellationTokenOO[ l
cancellationTokenOOm ~
)OO~ 
;	OO Ä
}PP 
}QQ ©
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IRunnable.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
	IRunnable 
{ 
void 
Run 
( 
) 
; 
}		 
}

 Ó
wC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IScheduledExecutorService.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public

 

	interface

 %
IScheduledExecutorService

 .
:

/ 0
IExecutorService

1 A
{ 
IScheduledTask 
Schedule 
(  
	IRunnable  )
action* 0
,0 1
TimeSpan2 :
delay; @
)@ A
;A B
IScheduledTask 
Schedule 
(  
Action  &
action' -
,- .
TimeSpan/ 7
delay8 =
)= >
;> ?
IScheduledTask$$ 
Schedule$$ 
($$  
Action$$  &
<$$& '
object$$' -
>$$- .
action$$/ 5
,$$5 6
object$$7 =
state$$> C
,$$C D
TimeSpan$$E M
delay$$N S
)$$S T
;$$T U
IScheduledTask.. 
Schedule.. 
(..  
Action..  &
<..& '
object..' -
,..- .
object../ 5
>..5 6
action..7 =
,..= >
object..? E
context..F M
,..M N
object..O U
state..V [
,..[ \
TimeSpan..] e
delay..f k
)..k l
;..l m
Task88 
ScheduleAsync88 
(88 
Action88 !
<88! "
object88" (
>88( )
action88* 0
,880 1
object882 8
state889 >
,88> ?
TimeSpan88@ H
delay88I N
,88N O
CancellationToken88P a
cancellationToken88b s
)88s t
;88t u
TaskBB 
ScheduleAsyncBB 
(BB 
ActionBB !
<BB! "
objectBB" (
>BB( )
actionBB* 0
,BB0 1
objectBB2 8
stateBB9 >
,BB> ?
TimeSpanBB@ H
delayBBI N
)BBN O
;BBO P
TaskJJ 
ScheduleAsyncJJ 
(JJ 
ActionJJ !
actionJJ" (
,JJ( )
TimeSpanJJ* 2
delayJJ3 8
,JJ8 9
CancellationTokenJJ: K
cancellationTokenJJL ]
)JJ] ^
;JJ^ _
TaskRR 
ScheduleAsyncRR 
(RR 
ActionRR !
actionRR" (
,RR( )
TimeSpanRR* 2
delayRR3 8
)RR8 9
;RR9 :
Task\\ 
ScheduleAsync\\ 
(\\ 
Action\\ !
<\\! "
object\\" (
,\\( )
object\\* 0
>\\0 1
action\\2 8
,\\8 9
object\\: @
context\\A H
,\\H I
object\\J P
state\\Q V
,\\V W
TimeSpan\\X `
delay\\a f
)\\f g
;\\g h
Taskff 
ScheduleAsyncff 
(ff 
Actionff !
<ff! "
objectff" (
,ff( )
objectff* 0
>ff0 1
actionff2 8
,ff8 9
objectff: @
contextffA H
,ffH I
objectffJ P
stateffQ V
,ffV W
TimeSpanffX `
delayffa f
,fff g
CancellationTokenffh y
cancellationToken	ffz ã
)
ffã å
;
ffå ç
}gg 
}hh ¢
pC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IScheduledRunnable.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

	interface 
IScheduledRunnable '
:( )
	IRunnable* 3
,3 4
IScheduledTask5 C
,C D
IComparableE P
<P Q
IScheduledRunnableQ c
>c d
{		 
}

 
} Ì
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\IScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public		 

	interface		 
IScheduledTask		 #
{

 
bool 
Cancel 
( 
) 
; 
PreciseTimeSpan 
Deadline  
{! "
get# &
;& '
}( )
Task 

Completion 
{ 
get 
; 
}  
TaskAwaiter 

GetAwaiter 
( 
)  
;  !
} 
} ä
xC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\RejectedExecutionException.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

class &
RejectedExecutionException +
:, -
	Exception. 7
{		 
public

 &
RejectedExecutionException

 )
(

) *
)

* +
{ 	
} 	
public &
RejectedExecutionException )
() *
string* 0
message1 8
)8 9
: 
base 
( 
message 
) 
{ 	
} 	
} 
} ›

sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\RunnableScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed 

class !
RunnableScheduledTask &
:' (
ScheduledTask) 6
{ 
readonly 
	IRunnable 
action !
;! "
public

 !
RunnableScheduledTask

 $
(

$ %*
AbstractScheduledEventExecutor

% C
executor

D L
,

L M
	IRunnable

N W
action

X ^
,

^ _
PreciseTimeSpan

` o
deadline

p x
)

x y
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
)@ A
)A B
{ 	
this 
. 
action 
= 
action  
;  !
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
.8 9
Run9 <
(< =
)= >
;> ?
} 
} ƒ
pC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ScheduledAsyncTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
abstract 
class 
ScheduledAsyncTask %
:& '
ScheduledTask( 5
{		 
readonly

 
CancellationToken

 "
cancellationToken

# 4
;

4 5)
CancellationTokenRegistration %)
cancellationTokenRegistration& C
;C D
	protected 
ScheduledAsyncTask $
($ %*
AbstractScheduledEventExecutor% C
executorD L
,L M
PreciseTimeSpanN ]
deadline^ f
,f g 
TaskCompletionSourceh |
promise	} Ñ
,
Ñ Ö
CancellationToken
Ü ó
cancellationToken
ò ©
)
© ™
: 
base 
( 
executor 
, 
deadline %
,% &
promise' .
). /
{ 	
this 
. 
cancellationToken "
=# $
cancellationToken% 6
;6 7
this 
. )
cancellationTokenRegistration .
=/ 0
cancellationToken1 B
.B C
RegisterC K
(K L
sL M
=>N P
(Q R
(R S
ScheduledAsyncTaskS e
)e f
sf g
)g h
.h i
Canceli o
(o p
)p q
,q r
thiss w
)w x
;x y
} 	
public 
override 
void 
Run  
(  !
)! "
{ 	
this 
. )
cancellationTokenRegistration .
.. /
Dispose/ 6
(6 7
)7 8
;8 9
if 
( 
this 
. 
cancellationToken &
.& '#
IsCancellationRequested' >
)> ?
{ 
this 
. 
Promise 
. 
TrySetCanceled +
(+ ,
), -
;- .
} 
else 
{ 
base 
. 
Run 
( 
) 
; 
} 
} 	
}   
}!! »3
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\ScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
abstract 
class 
ScheduledTask  
:! "
IScheduledRunnable# 5
{ 
const 
int "
CancellationProhibited (
=) *
$num+ ,
;, -
const 
int !
CancellationRequested '
=( )
$num* +
<<, .
$num/ 0
;0 1
	protected 
readonly  
TaskCompletionSource /
Promise0 7
;7 8
	protected 
readonly *
AbstractScheduledEventExecutor 9
Executor: B
;B C
int %
volatileCancellationState %
;% &
	protected 
ScheduledTask 
(  *
AbstractScheduledEventExecutor  >
executor? G
,G H
PreciseTimeSpanI X
deadlineY a
,a b 
TaskCompletionSourcec w
promisex 
)	 Ä
{ 	
this 
. 
Executor 
= 
executor $
;$ %
this 
. 
Promise 
= 
promise "
;" #
this 
. 
Deadline 
= 
deadline $
;$ %
} 	
public 
PreciseTimeSpan 
Deadline '
{( )
get* -
;- .
}/ 0
public 
bool 
Cancel 
( 
) 
{ 	
if   
(   
!   
this   
.   )
AtomicCancellationStateUpdate   3
(  3 4!
CancellationRequested  4 I
,  I J"
CancellationProhibited  K a
)  a b
)  b c
{!! 
return"" 
false"" 
;"" 
}## 
bool%% 
canceled%% 
=%% 
this%%  
.%%  !
Promise%%! (
.%%( )
TrySetCanceled%%) 7
(%%7 8
)%%8 9
;%%9 :
if&& 
(&& 
canceled&& 
)&& 
{'' 
this(( 
.(( 
Executor(( 
.(( 
RemoveScheduled(( -
(((- .
this((. 2
)((2 3
;((3 4
})) 
return** 
canceled** 
;** 
}++ 	
public-- 
Task-- 

Completion-- 
=>-- !
this--" &
.--& '
Promise--' .
.--. /
Task--/ 3
;--3 4
public// 
TaskAwaiter// 

GetAwaiter// %
(//% &
)//& '
=>//( *
this//+ /
./// 0

Completion//0 :
.//: ;

GetAwaiter//; E
(//E F
)//F G
;//G H
int11 
IComparable11 
<11 
IScheduledRunnable11 *
>11* +
.11+ ,
	CompareTo11, 5
(115 6
IScheduledRunnable116 H
other11I N
)11N O
{22 	
Contract33 
.33 
Requires33 
(33 
other33 #
!=33$ &
null33' +
)33+ ,
;33, -
return55 
this55 
.55 
Deadline55  
.55  !
	CompareTo55! *
(55* +
other55+ 0
.550 1
Deadline551 9
)559 :
;55: ;
}66 	
public88 
virtual88 
void88 
Run88 
(88  
)88  !
{99 	
if:: 
(:: 
this:: 
.:: 
TrySetUncancelable:: '
(::' (
)::( )
)::) *
{;; 
try<< 
{== 
this>> 
.>> 
Execute>>  
(>>  !
)>>! "
;>>" #
this?? 
.?? 
Promise??  
.??  !
TryComplete??! ,
(??, -
)??- .
;??. /
}@@ 
catchAA 
(AA 
	ExceptionAA  
exAA! #
)AA# $
{BB 
thisDD 
.DD 
PromiseDD  
.DD  !
TrySetExceptionDD! 0
(DD0 1
exDD1 3
)DD3 4
;DD4 5
}EE 
}FF 
}GG 	
	protectedII 
abstractII 
voidII 
ExecuteII  '
(II' (
)II( )
;II) *
boolKK 
TrySetUncancelableKK 
(KK  
)KK  !
=>KK" $
thisKK% )
.KK) *)
AtomicCancellationStateUpdateKK* G
(KKG H"
CancellationProhibitedKKH ^
,KK^ _!
CancellationRequestedKK` u
)KKu v
;KKv w
boolMM )
AtomicCancellationStateUpdateMM *
(MM* +
intMM+ .
newBitsMM/ 6
,MM6 7
intMM8 ;
illegalBitsMM< G
)MMG H
{NN 	
intOO 
cancellationStateOO !
=OO" #
VolatileOO$ ,
.OO, -
ReadOO- 1
(OO1 2
refOO2 5
thisOO6 :
.OO: ;%
volatileCancellationStateOO; T
)OOT U
;OOU V
intPP  
oldCancellationStatePP $
;PP$ %
doQQ 
{RR  
oldCancellationStateSS $
=SS% &
cancellationStateSS' 8
;SS8 9
ifTT 
(TT 
(TT 
cancellationStateTT &
&TT' (
illegalBitsTT) 4
)TT4 5
!=TT6 8
$numTT9 :
)TT: ;
{UU 
returnVV 
falseVV  
;VV  !
}WW 
cancellationStateXX !
=XX" #
InterlockedXX$ /
.XX/ 0
CompareExchangeXX0 ?
(XX? @
refXX@ C
thisXXD H
.XXH I%
volatileCancellationStateXXI b
,XXb c
cancellationStateXXd u
|XXv w
newBitsXXx 
,	XX Ä
cancellationState
XXÅ í
)
XXí ì
;
XXì î
}YY 
whileZZ 
(ZZ 
cancellationStateZZ $
!=ZZ% ' 
oldCancellationStateZZ( <
)ZZ< =
;ZZ= >
return\\ 
true\\ 
;\\ 
}]] 	
}^^ 
}__ ’ü
wC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\SingleThreadEventExecutor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

class %
SingleThreadEventExecutor *
:+ ,*
AbstractScheduledEventExecutor- K
{ 
const 
int 
ST_NOT_STARTED  
=! "
$num# $
;$ %
const 
int 

ST_STARTED 
= 
$num  
;  !
const 
int 
ST_SHUTTING_DOWN "
=# $
$num% &
;& '
const 
int 
ST_SHUTDOWN 
= 
$num  !
;! "
const 
int 
ST_TERMINATED 
=  !
$num" #
;# $
const 
string #
DefaultWorkerThreadName ,
=- .
$str/ Q
;Q R
static 
readonly 
	IRunnable !
WAKEUP_TASK" -
=. /
new0 3
NoOpRunnable4 @
(@ A
)A B
;B C
static   
readonly   
IInternalLogger   '
Logger  ( .
=  / 0!
InternalLoggerFactory!! !
.!!! "
GetInstance!!" -
<!!- .%
SingleThreadEventExecutor!!. G
>!!G H
(!!H I
)!!I J
;!!J K
readonly## 
IQueue## 
<## 
	IRunnable## !
>##! "
	taskQueue### ,
;##, -
readonly$$ 
Thread$$ 
thread$$ 
;$$ 
volatile%% 
int%% 
executionState%% #
=%%$ %
ST_NOT_STARTED%%& 4
;%%4 5
readonly&& 
PreciseTimeSpan&&  #
preciseBreakoutInterval&&! 8
;&&8 9
PreciseTimeSpan'' 
lastExecutionTime'' )
;'') *
readonly((  
ManualResetEventSlim(( %

emptyEvent((& 0
=((1 2
new((3 6 
ManualResetEventSlim((7 K
(((K L
false((L Q
,((Q R
$num((S T
)((T U
;((U V
readonly)) 
TaskScheduler)) 
	scheduler)) (
;))( )
readonly**  
TaskCompletionSource** %'
terminationCompletionSource**& A
;**A B
PreciseTimeSpan++ %
gracefulShutdownStartTime++ 1
;++1 2
PreciseTimeSpan,, '
gracefulShutdownQuietPeriod,, 3
;,,3 4
PreciseTimeSpan-- #
gracefulShutdownTimeout-- /
;--/ 0
readonly.. 
ISet.. 
<.. 
Action.. 
>.. 
shutdownHooks.. +
=.., -
new... 1
HashSet..2 9
<..9 :
Action..: @
>..@ A
(..A B
)..B C
;..C D
long// 
progress// 
;// 
public22 %
SingleThreadEventExecutor22 (
(22( )
string22) /

threadName220 :
,22: ;
TimeSpan22< D
breakoutInterval22E U
)22U V
:33 
this33 
(33 
null33 
,33 

threadName33 #
,33# $
breakoutInterval33% 5
,335 6
new337 :%
CompatibleConcurrentQueue33; T
<33T U
	IRunnable33U ^
>33^ _
(33_ `
)33` a
)33a b
{44 	
}55 	
public88 %
SingleThreadEventExecutor88 (
(88( )
IEventExecutorGroup88) <
parent88= C
,88C D
string88E K

threadName88L V
,88V W
TimeSpan88X `
breakoutInterval88a q
)88q r
:99 
this99 
(99 
parent99 
,99 

threadName99 %
,99% &
breakoutInterval99' 7
,997 8
new999 <%
CompatibleConcurrentQueue99= V
<99V W
	IRunnable99W `
>99` a
(99a b
)99b c
)99c d
{:: 	
};; 	
	protected== %
SingleThreadEventExecutor== +
(==+ ,
string==, 2

threadName==3 =
,=== >
TimeSpan==? G
breakoutInterval==H X
,==X Y
IQueue==Z `
<==` a
	IRunnable==a j
>==j k
	taskQueue==l u
)==u v
:>> 
this>> 
(>> 
null>> 
,>> 

threadName>> #
,>># $
breakoutInterval>>% 5
,>>5 6
	taskQueue>>7 @
)>>@ A
{?? 	
}??
 
	protectedAA %
SingleThreadEventExecutorAA +
(AA+ ,
IEventExecutorGroupAA, ?
parentAA@ F
,AAF G
stringAAH N

threadNameAAO Y
,AAY Z
TimeSpanAA[ c
breakoutIntervalAAd t
,AAt u
IQueueAAv |
<AA| }
	IRunnable	AA} Ü
>
AAÜ á
	taskQueue
AAà ë
)
AAë í
:BB 
baseBB 
(BB 
parentBB 
)BB 
{CC 	
thisDD 
.DD '
terminationCompletionSourceDD ,
=DD- .
newDD/ 2 
TaskCompletionSourceDD3 G
(DDG H
)DDH I
;DDI J
thisEE 
.EE 
	taskQueueEE 
=EE 
	taskQueueEE &
;EE& '
thisFF 
.FF #
preciseBreakoutIntervalFF (
=FF) *
PreciseTimeSpanFF+ :
.FF: ;
FromTimeSpanFF; G
(FFG H
breakoutIntervalFFH X
)FFX Y
;FFY Z
thisGG 
.GG 
	schedulerGG 
=GG 
newGG  !
ExecutorTaskSchedulerGG! 6
(GG6 7
thisGG7 ;
)GG; <
;GG< =
thisHH 
.HH 
threadHH 
=HH 
newHH 
ThreadHH $
(HH$ %
thisHH% )
.HH) *
LoopHH* .
)HH. /
;HH/ 0
ifII 
(II 
stringII 
.II 
IsNullOrEmptyII $
(II$ %

threadNameII% /
)II/ 0
)II0 1
{JJ 
thisKK 
.KK 
threadKK 
.KK 
NameKK  
=KK! "#
DefaultWorkerThreadNameKK# :
;KK: ;
}LL 
elseMM 
{NN 
thisOO 
.OO 
threadOO 
.OO 
NameOO  
=OO! "

threadNameOO# -
;OO- .
}PP 
thisQQ 
.QQ 
threadQQ 
.QQ 
IsBackgroundQQ $
=QQ% &
trueQQ' +
;QQ+ ,
thisRR 
.RR 
threadRR 
.RR 
StartRR 
(RR 
)RR 
;RR  
}SS 	
publicXX 
TaskSchedulerXX 
	SchedulerXX &
=>XX' )
thisXX* .
.XX. /
	schedulerXX/ 8
;XX8 9
public]] 
long]] 
Progress]] 
=>]] 
Volatile]]  (
.]]( )
Read]]) -
(]]- .
ref]]. 1
this]]2 6
.]]6 7
progress]]7 ?
)]]? @
;]]@ A
publicbb 
boolbb 
IsBacklogEmptybb "
=>bb# %
thisbb& *
.bb* +
	taskQueuebb+ 4
.bb4 5
IsEmptybb5 <
;bb< =
publicgg 
intgg 
BacklogLengthgg  
=>gg! #
thisgg$ (
.gg( )
	taskQueuegg) 2
.gg2 3
Countgg3 8
;gg8 9
voidii 
Loopii 
(ii 
)ii 
{jj 	
thiskk 
.kk 
SetCurrentExecutorkk #
(kk# $
thiskk$ (
)kk( )
;kk) *
Taskmm 
.mm 
Factorymm 
.mm 
StartNewmm !
(mm! "
(nn 
)nn 
=>nn 
{oo 
trypp 
{qq 
Interlockedrr #
.rr# $
CompareExchangerr$ 3
(rr3 4
refrr4 7
thisrr8 <
.rr< =
executionStaterr= K
,rrK L

ST_STARTEDrrM W
,rrW X
ST_NOT_STARTEDrrY g
)rrg h
;rrh i
whiless 
(ss 
!ss  
thisss  $
.ss$ %
ConfirmShutdownss% 4
(ss4 5
)ss5 6
)ss6 7
{tt 
thisuu  
.uu  !
RunAllTasksuu! ,
(uu, -
thisuu- 1
.uu1 2#
preciseBreakoutIntervaluu2 I
)uuI J
;uuJ K
}vv 
thisww 
.ww 
CleanupAndTerminateww 0
(ww0 1
trueww1 5
)ww5 6
;ww6 7
}xx 
catchyy 
(yy 
	Exceptionyy $
exyy% '
)yy' (
{zz 
Logger{{ 
.{{ 
Error{{ $
({{$ %
$str{{% @
,{{@ A
this{{B F
.{{F G
thread{{G M
.{{M N
Name{{N R
,{{R S
ex{{T V
){{V W
;{{W X
this|| 
.|| 
executionState|| +
=||, -
ST_TERMINATED||. ;
;||; <
this}} 
.}} '
terminationCompletionSource}} 8
.}}8 9
TrySetException}}9 H
(}}H I
ex}}I K
)}}K L
;}}L M
}~~ 
} 
, 
CancellationToken
ÄÄ !
.
ÄÄ! "
None
ÄÄ" &
,
ÄÄ& '!
TaskCreationOptions
ÅÅ #
.
ÅÅ# $
None
ÅÅ$ (
,
ÅÅ( )
this
ÇÇ 
.
ÇÇ 
	scheduler
ÇÇ 
)
ÇÇ 
;
ÇÇ  
}
ÉÉ 	
public
ÜÜ 
override
ÜÜ 
bool
ÜÜ 
IsShuttingDown
ÜÜ +
=>
ÜÜ, .
this
ÜÜ/ 3
.
ÜÜ3 4
executionState
ÜÜ4 B
>=
ÜÜC E
ST_SHUTTING_DOWN
ÜÜF V
;
ÜÜV W
public
ââ 
override
ââ 
Task
ââ #
TerminationCompletion
ââ 2
=>
ââ3 5
this
ââ6 :
.
ââ: ;)
terminationCompletionSource
ââ; V
.
ââV W
Task
ââW [
;
ââ[ \
public
åå 
override
åå 
bool
åå 

IsShutdown
åå '
=>
åå( *
this
åå+ /
.
åå/ 0
executionState
åå0 >
>=
åå? A
ST_SHUTDOWN
ååB M
;
ååM N
public
èè 
override
èè 
bool
èè 
IsTerminated
èè )
=>
èè* ,
this
èè- 1
.
èè1 2
executionState
èè2 @
==
èèA C
ST_TERMINATED
èèD Q
;
èèQ R
public
íí 
override
íí 
bool
íí 
IsInEventLoop
íí *
(
íí* +
Thread
íí+ 1
t
íí2 3
)
íí3 4
=>
íí5 7
this
íí8 <
.
íí< =
thread
íí= C
==
ííD F
t
ííG H
;
ííH I
public
ïï 
override
ïï 
void
ïï 
Execute
ïï $
(
ïï$ %
	IRunnable
ïï% .
task
ïï/ 3
)
ïï3 4
{
ññ 	
this
óó 
.
óó 
	taskQueue
óó 
.
óó 

TryEnqueue
óó %
(
óó% &
task
óó& *
)
óó* +
;
óó+ ,
if
ôô 
(
ôô 
!
ôô 
this
ôô 
.
ôô 
InEventLoop
ôô !
)
ôô! "
{
öö 
this
õõ 
.
õõ 

emptyEvent
õõ 
.
õõ  
Set
õõ  #
(
õõ# $
)
õõ$ %
;
õõ% &
}
úú 
}
ùù 	
	protected
üü 
override
üü 
IEnumerable
üü &
<
üü& '
IEventExecutor
üü' 5
>
üü5 6
GetItems
üü7 ?
(
üü? @
)
üü@ A
=>
üüB D
new
üüE H
[
üüH I
]
üüI J
{
üüK L
this
üüM Q
}
üüR S
;
üüS T
	protected
°° 
void
°° 
WakeUp
°° 
(
°° 
bool
°° "
inEventLoop
°°# .
)
°°. /
{
¢¢ 	
if
££ 
(
££ 
!
££ 
inEventLoop
££ 
||
££ 
(
££  !
this
££! %
.
££% &
executionState
££& 4
==
££5 7
ST_SHUTTING_DOWN
££8 H
)
££H I
)
££I J
{
§§ 
this
•• 
.
•• 
Execute
•• 
(
•• 
WAKEUP_TASK
•• (
)
••( )
;
••) *
}
¶¶ 
}
ßß 	
public
≠≠ 
void
≠≠ 
AddShutdownHook
≠≠ #
(
≠≠# $
Action
≠≠$ *
action
≠≠+ 1
)
≠≠1 2
{
ÆÆ 	
if
ØØ 
(
ØØ 
this
ØØ 
.
ØØ 
InEventLoop
ØØ  
)
ØØ  !
{
∞∞ 
this
±± 
.
±± 
shutdownHooks
±± "
.
±±" #
Add
±±# &
(
±±& '
action
±±' -
)
±±- .
;
±±. /
}
≤≤ 
else
≥≥ 
{
¥¥ 
this
µµ 
.
µµ 
Execute
µµ 
(
µµ 
(
µµ 
)
µµ 
=>
µµ  "
this
µµ# '
.
µµ' (
shutdownHooks
µµ( 5
.
µµ5 6
Add
µµ6 9
(
µµ9 :
action
µµ: @
)
µµ@ A
)
µµA B
;
µµB C
}
∂∂ 
}
∑∑ 	
public
ææ 
void
ææ  
RemoveShutdownHook
ææ &
(
ææ& '
Action
ææ' -
action
ææ. 4
)
ææ4 5
{
øø 	
if
¿¿ 
(
¿¿ 
this
¿¿ 
.
¿¿ 
InEventLoop
¿¿  
)
¿¿  !
{
¡¡ 
this
¬¬ 
.
¬¬ 
shutdownHooks
¬¬ "
.
¬¬" #
Remove
¬¬# )
(
¬¬) *
action
¬¬* 0
)
¬¬0 1
;
¬¬1 2
}
√√ 
else
ƒƒ 
{
≈≈ 
this
∆∆ 
.
∆∆ 
Execute
∆∆ 
(
∆∆ 
(
∆∆ 
)
∆∆ 
=>
∆∆  "
this
∆∆# '
.
∆∆' (
shutdownHooks
∆∆( 5
.
∆∆5 6
Remove
∆∆6 <
(
∆∆< =
action
∆∆= C
)
∆∆C D
)
∆∆D E
;
∆∆E F
}
«« 
}
»» 	
bool
   
RunShutdownHooks
   
(
   
)
   
{
ÀÀ 	
bool
ÃÃ 
ran
ÃÃ 
=
ÃÃ 
false
ÃÃ 
;
ÃÃ 
while
œœ 
(
œœ 
this
œœ 
.
œœ 
shutdownHooks
œœ %
.
œœ% &
Count
œœ& +
>
œœ, -
$num
œœ. /
)
œœ/ 0
{
–– 
var
—— 
copy
—— 
=
—— 
this
—— 
.
——  
shutdownHooks
——  -
.
——- .
ToArray
——. 5
(
——5 6
)
——6 7
;
——7 8
this
““ 
.
““ 
shutdownHooks
““ "
.
““" #
Clear
““# (
(
““( )
)
““) *
;
““* +
for
‘‘ 
(
‘‘ 
var
‘‘ 
i
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
i
‘‘  !
<
‘‘" #
copy
‘‘$ (
.
‘‘( )
Length
‘‘) /
;
‘‘/ 0
i
‘‘1 2
++
‘‘2 4
)
‘‘4 5
{
’’ 
try
÷÷ 
{
◊◊ 
copy
ÿÿ 
[
ÿÿ 
i
ÿÿ 
]
ÿÿ 
(
ÿÿ  
)
ÿÿ  !
;
ÿÿ! "
}
ŸŸ 
catch
⁄⁄ 
(
⁄⁄ 
	Exception
⁄⁄ $
ex
⁄⁄% '
)
⁄⁄' (
{
€€ 
Logger
‹‹ 
.
‹‹ 
Warn
‹‹ #
(
‹‹# $
$str
‹‹$ H
,
‹‹H I
ex
‹‹J L
)
‹‹L M
;
‹‹M N
}
›› 
finally
ﬁﬁ 
{
ﬂﬂ 
ran
‡‡ 
=
‡‡ 
true
‡‡ "
;
‡‡" #
}
·· 
}
‚‚ 
}
„„ 
if
ÂÂ 
(
ÂÂ 
ran
ÂÂ 
)
ÂÂ 
{
ÊÊ 
this
ÁÁ 
.
ÁÁ 
lastExecutionTime
ÁÁ &
=
ÁÁ' (
PreciseTimeSpan
ÁÁ) 8
.
ÁÁ8 9
	FromStart
ÁÁ9 B
;
ÁÁB C
}
ËË 
return
ÍÍ 
ran
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ÔÔ 
override
ÔÔ 
Task
ÔÔ %
ShutdownGracefullyAsync
ÔÔ 4
(
ÔÔ4 5
TimeSpan
ÔÔ5 =
quietPeriod
ÔÔ> I
,
ÔÔI J
TimeSpan
ÔÔK S
timeout
ÔÔT [
)
ÔÔ[ \
{
 	
Contract
ÒÒ 
.
ÒÒ 
Requires
ÒÒ 
(
ÒÒ 
quietPeriod
ÒÒ )
>=
ÒÒ* ,
TimeSpan
ÒÒ- 5
.
ÒÒ5 6
Zero
ÒÒ6 :
)
ÒÒ: ;
;
ÒÒ; <
Contract
ÚÚ 
.
ÚÚ 
Requires
ÚÚ 
(
ÚÚ 
timeout
ÚÚ %
>=
ÚÚ& (
quietPeriod
ÚÚ) 4
)
ÚÚ4 5
;
ÚÚ5 6
if
ÙÙ 
(
ÙÙ 
this
ÙÙ 
.
ÙÙ 
IsShuttingDown
ÙÙ #
)
ÙÙ# $
{
ıı 
return
ˆˆ 
this
ˆˆ 
.
ˆˆ #
TerminationCompletion
ˆˆ 1
;
ˆˆ1 2
}
˜˜ 
bool
˘˘ 
inEventLoop
˘˘ 
=
˘˘ 
this
˘˘ #
.
˘˘# $
InEventLoop
˘˘$ /
;
˘˘/ 0
bool
˙˙ 
wakeup
˙˙ 
;
˙˙ 
int
˚˚ 
oldState
˚˚ 
;
˚˚ 
while
¸¸ 
(
¸¸ 
true
¸¸ 
)
¸¸ 
{
˝˝ 
if
˛˛ 
(
˛˛ 
this
˛˛ 
.
˛˛ 
IsShuttingDown
˛˛ '
)
˛˛' (
{
ˇˇ 
return
ÄÄ 
this
ÄÄ 
.
ÄÄ  #
TerminationCompletion
ÄÄ  5
;
ÄÄ5 6
}
ÅÅ 
int
ÇÇ 
newState
ÇÇ 
;
ÇÇ 
wakeup
ÉÉ 
=
ÉÉ 
true
ÉÉ 
;
ÉÉ 
oldState
ÑÑ 
=
ÑÑ 
this
ÑÑ 
.
ÑÑ  
executionState
ÑÑ  .
;
ÑÑ. /
if
ÖÖ 
(
ÖÖ 
inEventLoop
ÖÖ 
)
ÖÖ  
{
ÜÜ 
newState
áá 
=
áá 
ST_SHUTTING_DOWN
áá /
;
áá/ 0
}
àà 
else
ââ 
{
ää 
switch
ãã 
(
ãã 
oldState
ãã $
)
ãã$ %
{
åå 
case
çç 
ST_NOT_STARTED
çç +
:
çç+ ,
case
éé 

ST_STARTED
éé '
:
éé' (
newState
èè $
=
èè% &
ST_SHUTTING_DOWN
èè' 7
;
èè7 8
break
êê !
;
êê! "
default
ëë 
:
ëë  
newState
íí $
=
íí% &
oldState
íí' /
;
íí/ 0
wakeup
ìì "
=
ìì# $
false
ìì% *
;
ìì* +
break
îî !
;
îî! "
}
ïï 
}
ññ 
if
óó 
(
óó 
Interlocked
óó 
.
óó  
CompareExchange
óó  /
(
óó/ 0
ref
óó0 3
this
óó4 8
.
óó8 9
executionState
óó9 G
,
óóG H
newState
óóI Q
,
óóQ R
oldState
óóS [
)
óó[ \
==
óó] _
oldState
óó` h
)
óóh i
{
òò 
break
ôô 
;
ôô 
}
öö 
}
õõ 
this
úú 
.
úú )
gracefulShutdownQuietPeriod
úú ,
=
úú- .
PreciseTimeSpan
úú/ >
.
úú> ?
FromTimeSpan
úú? K
(
úúK L
quietPeriod
úúL W
)
úúW X
;
úúX Y
this
ùù 
.
ùù %
gracefulShutdownTimeout
ùù (
=
ùù) *
PreciseTimeSpan
ùù+ :
.
ùù: ;
FromTimeSpan
ùù; G
(
ùùG H
timeout
ùùH O
)
ùùO P
;
ùùP Q
if
•• 
(
•• 
wakeup
•• 
)
•• 
{
¶¶ 
this
ßß 
.
ßß 
WakeUp
ßß 
(
ßß 
inEventLoop
ßß '
)
ßß' (
;
ßß( )
}
®® 
return
™™ 
this
™™ 
.
™™ #
TerminationCompletion
™™ -
;
™™- .
}
´´ 	
	protected
≠≠ 
bool
≠≠ 
ConfirmShutdown
≠≠ &
(
≠≠& '
)
≠≠' (
{
ÆÆ 	
if
ØØ 
(
ØØ 
!
ØØ 
this
ØØ 
.
ØØ 
IsShuttingDown
ØØ $
)
ØØ$ %
{
∞∞ 
return
±± 
false
±± 
;
±± 
}
≤≤ 
Contract
¥¥ 
.
¥¥ 
Assert
¥¥ 
(
¥¥ 
this
¥¥  
.
¥¥  !
InEventLoop
¥¥! ,
,
¥¥, -
$str
¥¥. R
)
¥¥R S
;
¥¥S T
this
∂∂ 
.
∂∂ "
CancelScheduledTasks
∂∂ %
(
∂∂% &
)
∂∂& '
;
∂∂' (
if
∏∏ 
(
∏∏ 
this
∏∏ 
.
∏∏ '
gracefulShutdownStartTime
∏∏ .
==
∏∏/ 1
PreciseTimeSpan
∏∏2 A
.
∏∏A B
Zero
∏∏B F
)
∏∏F G
{
ππ 
this
∫∫ 
.
∫∫ '
gracefulShutdownStartTime
∫∫ .
=
∫∫/ 0
PreciseTimeSpan
∫∫1 @
.
∫∫@ A
	FromStart
∫∫A J
;
∫∫J K
}
ªª 
if
ΩΩ 
(
ΩΩ 
this
ΩΩ 
.
ΩΩ 
RunAllTasks
ΩΩ  
(
ΩΩ  !
)
ΩΩ! "
||
ΩΩ# %
this
ΩΩ& *
.
ΩΩ* +
RunShutdownHooks
ΩΩ+ ;
(
ΩΩ; <
)
ΩΩ< =
)
ΩΩ= >
{
ææ 
if
øø 
(
øø 
this
øø 
.
øø 

IsShutdown
øø #
)
øø# $
{
¿¿ 
return
¬¬ 
true
¬¬ 
;
¬¬  
}
√√ 
this
∆∆ 
.
∆∆ 
WakeUp
∆∆ 
(
∆∆ 
true
∆∆  
)
∆∆  !
;
∆∆! "
return
«« 
false
«« 
;
«« 
}
»» 
PreciseTimeSpan
   
nanoTime
   $
=
  % &
PreciseTimeSpan
  ' 6
.
  6 7
	FromStart
  7 @
;
  @ A
if
ÃÃ 
(
ÃÃ 
this
ÃÃ 
.
ÃÃ 

IsShutdown
ÃÃ 
||
ÃÃ  "
(
ÃÃ# $
nanoTime
ÃÃ$ ,
-
ÃÃ- .
this
ÃÃ/ 3
.
ÃÃ3 4'
gracefulShutdownStartTime
ÃÃ4 M
>
ÃÃN O
this
ÃÃP T
.
ÃÃT U%
gracefulShutdownTimeout
ÃÃU l
)
ÃÃl m
)
ÃÃm n
{
ÕÕ 
return
ŒŒ 
true
ŒŒ 
;
ŒŒ 
}
œœ 
if
—— 
(
—— 
nanoTime
—— 
-
—— 
this
—— 
.
——  
lastExecutionTime
——  1
<=
——2 4
this
——5 9
.
——9 :)
gracefulShutdownQuietPeriod
——: U
)
——U V
{
““ 
this
÷÷ 
.
÷÷ 
WakeUp
÷÷ 
(
÷÷ 
true
÷÷  
)
÷÷  !
;
÷÷! "
Thread
◊◊ 
.
◊◊ 
Sleep
◊◊ 
(
◊◊ 
$num
◊◊  
)
◊◊  !
;
◊◊! "
return
ŸŸ 
false
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
return
ﬁﬁ 
true
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
	protected
·· 
void
·· !
CleanupAndTerminate
·· *
(
··* +
bool
··+ /
success
··0 7
)
··7 8
{
‚‚ 	
while
„„ 
(
„„ 
true
„„ 
)
„„ 
{
‰‰ 
int
ÂÂ 
oldState
ÂÂ 
=
ÂÂ 
this
ÂÂ #
.
ÂÂ# $
executionState
ÂÂ$ 2
;
ÂÂ2 3
if
ÊÊ 
(
ÊÊ 
(
ÊÊ 
oldState
ÊÊ 
>=
ÊÊ  
ST_SHUTTING_DOWN
ÊÊ! 1
)
ÊÊ1 2
||
ÊÊ3 5
(
ÊÊ6 7
Interlocked
ÊÊ7 B
.
ÊÊB C
CompareExchange
ÊÊC R
(
ÊÊR S
ref
ÊÊS V
this
ÊÊW [
.
ÊÊ[ \
executionState
ÊÊ\ j
,
ÊÊj k
ST_SHUTTING_DOWN
ÊÊl |
,
ÊÊ| }
oldStateÊÊ~ Ü
)ÊÊÜ á
==ÊÊà ä
oldStateÊÊã ì
)ÊÊì î
)ÊÊî ï
{
ÁÁ 
break
ËË 
;
ËË 
}
ÈÈ 
}
ÍÍ 
if
ÌÌ 
(
ÌÌ 
success
ÌÌ 
&&
ÌÌ 
(
ÌÌ 
this
ÌÌ  
.
ÌÌ  !'
gracefulShutdownStartTime
ÌÌ! :
==
ÌÌ; =
PreciseTimeSpan
ÌÌ> M
.
ÌÌM N
Zero
ÌÌN R
)
ÌÌR S
)
ÌÌS T
{
ÓÓ 
Logger
ÔÔ 
.
ÔÔ 
Error
ÔÔ 
(
ÔÔ 
$"
 
$str
 
{
 
typeof
 #
(
# $
IEventExecutor
$ 2
)
2 3
.
3 4
Name
4 8
}
8 9
$str
9 J
{
J K
typeof
K Q
(
Q R'
SingleThreadEventExecutor
R k
)
k l
.
l m
Name
m q
}
q r
$strr î
"î ï
+
ÒÒ 
$str
ÒÒ ?
)
ÒÒ? @
;
ÒÒ@ A
}
ÚÚ 
try
ÙÙ 
{
ıı 
while
˜˜ 
(
˜˜ 
true
˜˜ 
)
˜˜ 
{
¯¯ 
if
˘˘ 
(
˘˘ 
this
˘˘ 
.
˘˘ 
ConfirmShutdown
˘˘ ,
(
˘˘, -
)
˘˘- .
)
˘˘. /
{
˙˙ 
break
˚˚ 
;
˚˚ 
}
¸¸ 
}
˝˝ 
}
˛˛ 
finally
ˇˇ 
{
ÄÄ 
try
ÅÅ 
{
ÇÇ 
this
ÉÉ 
.
ÉÉ 
Cleanup
ÉÉ  
(
ÉÉ  !
)
ÉÉ! "
;
ÉÉ" #
}
ÑÑ 
finally
ÖÖ 
{
ÜÜ 
Interlocked
áá 
.
áá  
Exchange
áá  (
(
áá( )
ref
áá) ,
this
áá- 1
.
áá1 2
executionState
áá2 @
,
áá@ A
ST_TERMINATED
ááB O
)
ááO P
;
ááP Q
if
àà 
(
àà 
!
àà 
this
àà 
.
àà 
	taskQueue
àà '
.
àà' (
IsEmpty
àà( /
)
àà/ 0
{
ââ 
Logger
ää 
.
ää 
Warn
ää #
(
ää# $
$"
ää$ &
$str
ää& ^
{
ää^ _
this
ää_ c
.
ääc d
	taskQueue
ääd m
.
ääm n
Count
ään s
}
ääs t
$str
äät u
"
ääu v
)
ääv w
;
ääw x
}
ãã 
this
éé 
.
éé )
terminationCompletionSource
éé 4
.
éé4 5
Complete
éé5 =
(
éé= >
)
éé> ?
;
éé? @
}
èè 
}
êê 
}
ëë 	
	protected
ìì 
virtual
ìì 
void
ìì 
Cleanup
ìì &
(
ìì& '
)
ìì' (
{
îî 	
}
ññ 	
	protected
òò 
bool
òò 
RunAllTasks
òò "
(
òò" #
)
òò# $
{
ôô 	
this
öö 
.
öö )
FetchFromScheduledTaskQueue
öö ,
(
öö, -
)
öö- .
;
öö. /
	IRunnable
õõ 
task
õõ 
=
õõ 
this
õõ !
.
õõ! "
PollTask
õõ" *
(
õõ* +
)
õõ+ ,
;
õõ, -
if
úú 
(
úú 
task
úú 
==
úú 
null
úú 
)
úú 
{
ùù 
return
ûû 
false
ûû 
;
ûû 
}
üü 
while
°° 
(
°° 
true
°° 
)
°° 
{
¢¢ 
Volatile
££ 
.
££ 
Write
££ 
(
££ 
ref
££ "
this
££# '
.
££' (
progress
££( 0
,
££0 1
this
££2 6
.
££6 7
progress
££7 ?
+
££@ A
$num
££B C
)
££C D
;
££D E
SafeExecute
§§ 
(
§§ 
task
§§  
)
§§  !
;
§§! "
task
•• 
=
•• 
this
•• 
.
•• 
PollTask
•• $
(
••$ %
)
••% &
;
••& '
if
¶¶ 
(
¶¶ 
task
¶¶ 
==
¶¶ 
null
¶¶  
)
¶¶  !
{
ßß 
this
®® 
.
®® 
lastExecutionTime
®® *
=
®®+ ,
PreciseTimeSpan
®®- <
.
®®< =
	FromStart
®®= F
;
®®F G
return
©© 
true
©© 
;
©©  
}
™™ 
}
´´ 
}
¨¨ 	
bool
ÆÆ 
RunAllTasks
ÆÆ 
(
ÆÆ 
PreciseTimeSpan
ÆÆ (
timeout
ÆÆ) 0
)
ÆÆ0 1
{
ØØ 	
this
∞∞ 
.
∞∞ )
FetchFromScheduledTaskQueue
∞∞ ,
(
∞∞, -
)
∞∞- .
;
∞∞. /
	IRunnable
±± 
task
±± 
=
±± 
this
±± !
.
±±! "
PollTask
±±" *
(
±±* +
)
±±+ ,
;
±±, -
if
≤≤ 
(
≤≤ 
task
≤≤ 
==
≤≤ 
null
≤≤ 
)
≤≤ 
{
≥≥ 
return
¥¥ 
false
¥¥ 
;
¥¥ 
}
µµ 
PreciseTimeSpan
∑∑ 
deadline
∑∑ $
=
∑∑% &
PreciseTimeSpan
∑∑' 6
.
∑∑6 7
Deadline
∑∑7 ?
(
∑∑? @
timeout
∑∑@ G
)
∑∑G H
;
∑∑H I
long
∏∏ 
runTasks
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
PreciseTimeSpan
ππ 
executionTime
ππ )
;
ππ) *
while
∫∫ 
(
∫∫ 
true
∫∫ 
)
∫∫ 
{
ªª 
SafeExecute
ºº 
(
ºº 
task
ºº  
)
ºº  !
;
ºº! "
runTasks
ææ 
++
ææ 
;
ææ 
if
¬¬ 
(
¬¬ 
(
¬¬ 
runTasks
¬¬ 
&
¬¬ 
$num
¬¬  $
)
¬¬$ %
==
¬¬& (
$num
¬¬) *
)
¬¬* +
{
√√ 
executionTime
ƒƒ !
=
ƒƒ" #
PreciseTimeSpan
ƒƒ$ 3
.
ƒƒ3 4
	FromStart
ƒƒ4 =
;
ƒƒ= >
if
≈≈ 
(
≈≈ 
executionTime
≈≈ %
>=
≈≈& (
deadline
≈≈) 1
)
≈≈1 2
{
∆∆ 
break
«« 
;
«« 
}
»» 
}
…… 
task
ÀÀ 
=
ÀÀ 
this
ÀÀ 
.
ÀÀ 
PollTask
ÀÀ $
(
ÀÀ$ %
)
ÀÀ% &
;
ÀÀ& '
if
ÃÃ 
(
ÃÃ 
task
ÃÃ 
==
ÃÃ 
null
ÃÃ  
)
ÃÃ  !
{
ÕÕ 
executionTime
ŒŒ !
=
ŒŒ" #
PreciseTimeSpan
ŒŒ$ 3
.
ŒŒ3 4
	FromStart
ŒŒ4 =
;
ŒŒ= >
break
œœ 
;
œœ 
}
–– 
}
—— 
this
”” 
.
”” 
lastExecutionTime
”” "
=
””# $
executionTime
””% 2
;
””2 3
return
‘‘ 
true
‘‘ 
;
‘‘ 
}
’’ 	
bool
◊◊ )
FetchFromScheduledTaskQueue
◊◊ (
(
◊◊( )
)
◊◊) *
{
ÿÿ 	
PreciseTimeSpan
ŸŸ 
nanoTime
ŸŸ $
=
ŸŸ% &
PreciseTimeSpan
ŸŸ' 6
.
ŸŸ6 7
	FromStart
ŸŸ7 @
;
ŸŸ@ A 
IScheduledRunnable
⁄⁄ 
scheduledTask
⁄⁄ ,
=
⁄⁄- .
this
⁄⁄/ 3
.
⁄⁄3 4
PollScheduledTask
⁄⁄4 E
(
⁄⁄E F
nanoTime
⁄⁄F N
)
⁄⁄N O
;
⁄⁄O P
while
€€ 
(
€€ 
scheduledTask
€€  
!=
€€! #
null
€€$ (
)
€€( )
{
‹‹ 
if
›› 
(
›› 
!
›› 
this
›› 
.
›› 
	taskQueue
›› #
.
››# $

TryEnqueue
››$ .
(
››. /
scheduledTask
››/ <
)
››< =
)
››= >
{
ﬁﬁ 
this
‡‡ 
.
‡‡  
ScheduledTaskQueue
‡‡ +
.
‡‡+ ,
Enqueue
‡‡, 3
(
‡‡3 4
scheduledTask
‡‡4 A
)
‡‡A B
;
‡‡B C
return
·· 
false
··  
;
··  !
}
‚‚ 
scheduledTask
„„ 
=
„„ 
this
„„  $
.
„„$ %
PollScheduledTask
„„% 6
(
„„6 7
nanoTime
„„7 ?
)
„„? @
;
„„@ A
}
‰‰ 
return
ÂÂ 
true
ÂÂ 
;
ÂÂ 
}
ÊÊ 	
	IRunnable
ËË 
PollTask
ËË 
(
ËË 
)
ËË 
{
ÈÈ 	
Contract
ÍÍ 
.
ÍÍ 
Assert
ÍÍ 
(
ÍÍ 
this
ÍÍ  
.
ÍÍ  !
InEventLoop
ÍÍ! ,
)
ÍÍ, -
;
ÍÍ- .
	IRunnable
ÏÏ 
task
ÏÏ 
;
ÏÏ 
if
ÌÌ 
(
ÌÌ 
!
ÌÌ 
this
ÌÌ 
.
ÌÌ 
	taskQueue
ÌÌ 
.
ÌÌ  

TryDequeue
ÌÌ  *
(
ÌÌ* +
out
ÌÌ+ .
task
ÌÌ/ 3
)
ÌÌ3 4
)
ÌÌ4 5
{
ÓÓ 
this
ÔÔ 
.
ÔÔ 

emptyEvent
ÔÔ 
.
ÔÔ  
Reset
ÔÔ  %
(
ÔÔ% &
)
ÔÔ& '
;
ÔÔ' (
if
 
(
 
!
 
this
 
.
 
	taskQueue
 #
.
# $

TryDequeue
$ .
(
. /
out
/ 2
task
3 7
)
7 8
&&
9 ;
!
< =
this
= A
.
A B
IsShuttingDown
B P
)
P Q
{
ÒÒ  
IScheduledRunnable
ÚÚ &
nextScheduledTask
ÚÚ' 8
=
ÚÚ9 :
this
ÚÚ; ?
.
ÚÚ? @ 
ScheduledTaskQueue
ÚÚ@ R
.
ÚÚR S
Peek
ÚÚS W
(
ÚÚW X
)
ÚÚX Y
;
ÚÚY Z
if
ÛÛ 
(
ÛÛ 
nextScheduledTask
ÛÛ )
!=
ÛÛ* ,
null
ÛÛ- 1
)
ÛÛ1 2
{
ÙÙ 
PreciseTimeSpan
ıı '
wakeupTimeout
ıı( 5
=
ıı6 7
nextScheduledTask
ıı8 I
.
ııI J
Deadline
ııJ R
-
ııS T
PreciseTimeSpan
ııU d
.
ııd e
	FromStart
ııe n
;
ıın o
if
ˆˆ 
(
ˆˆ 
wakeupTimeout
ˆˆ )
.
ˆˆ) *
Ticks
ˆˆ* /
>
ˆˆ0 1
$num
ˆˆ2 3
)
ˆˆ3 4
{
˜˜ 
double
¯¯ "
timeout
¯¯# *
=
¯¯+ ,
wakeupTimeout
¯¯- :
.
¯¯: ;

ToTimeSpan
¯¯; E
(
¯¯E F
)
¯¯F G
.
¯¯G H
TotalMilliseconds
¯¯H Y
;
¯¯Y Z
this
˘˘  
.
˘˘  !

emptyEvent
˘˘! +
.
˘˘+ ,
Wait
˘˘, 0
(
˘˘0 1
(
˘˘1 2
int
˘˘2 5
)
˘˘5 6
Math
˘˘6 :
.
˘˘: ;
Min
˘˘; >
(
˘˘> ?
timeout
˘˘? F
,
˘˘F G
int
˘˘H K
.
˘˘K L
MaxValue
˘˘L T
-
˘˘U V
$num
˘˘W X
)
˘˘X Y
)
˘˘Y Z
;
˘˘Z [
}
˙˙ 
}
˚˚ 
else
¸¸ 
{
˝˝ 
this
˛˛ 
.
˛˛ 

emptyEvent
˛˛ '
.
˛˛' (
Wait
˛˛( ,
(
˛˛, -
)
˛˛- .
;
˛˛. /
this
ˇˇ 
.
ˇˇ 
	taskQueue
ˇˇ &
.
ˇˇ& '

TryDequeue
ˇˇ' 1
(
ˇˇ1 2
out
ˇˇ2 5
task
ˇˇ6 :
)
ˇˇ: ;
;
ˇˇ; <
}
ÄÄ 
}
ÅÅ 
}
ÇÇ 
return
ÑÑ 
task
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
sealed
áá 
class
áá 
NoOpRunnable
áá !
:
áá" #
	IRunnable
áá$ -
{
àà 	
public
ââ 
void
ââ 
Run
ââ 
(
ââ 
)
ââ 
{
ää 
}
ãã 
}
åå 	
}
çç 
}éé ·
{C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\StateActionScheduledAsyncTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed		 

class		 )
StateActionScheduledAsyncTask		 .
:		/ 0
ScheduledAsyncTask		1 C
{

 
readonly 
Action 
< 
object 
> 
action  &
;& '
public )
StateActionScheduledAsyncTask ,
(, -*
AbstractScheduledEventExecutor- K
executorL T
,T U
ActionV \
<\ ]
object] c
>c d
actione k
,k l
objectm s
statet y
,y z
PreciseTimeSpan	{ ä
deadline
ã ì
,
ì î
CancellationToken 
cancellationToken /
)/ 0
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
state@ E
)E F
,F G
cancellationTokenH Y
)Y Z
{ 	
this 
. 
action 
= 
action  
;  !
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
this9 =
.= >

Completion> H
.H I

AsyncStateI S
)S T
;T U
} 
} “
vC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\StateActionScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed 

class $
StateActionScheduledTask )
:* +
ScheduledTask, 9
{		 
readonly

 
Action

 
<

 
object

 
>

 
action

  &
;

& '
public $
StateActionScheduledTask '
(' (*
AbstractScheduledEventExecutor( F
executorG O
,O P
ActionQ W
<W X
objectX ^
>^ _
action` f
,f g
objecth n
stateo t
,t u
PreciseTimeSpan	v Ö
deadline
Ü é
)
é è
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
state@ E
)E F
)F G
{ 	
this 
. 
action 
= 
action  
;  !
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
this9 =
.= >

Completion> H
.H I

AsyncStateI S
)S T
;T U
} 
} Ñ
ÜC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\StateActionWithContextScheduledAsyncTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed		 

class		 4
(StateActionWithContextScheduledAsyncTask		 9
:		: ;
ScheduledAsyncTask		< N
{

 
readonly 
Action 
< 
object 
, 
object  &
>& '
action( .
;. /
readonly 
object 
context 
;  
public 4
(StateActionWithContextScheduledAsyncTask 7
(7 8*
AbstractScheduledEventExecutor8 V
executorW _
,_ `
Actiona g
<g h
objecth n
,n o
objectp v
>v w
actionx ~
,~ 
object
Ä Ü
context
á é
,
é è
object
ê ñ
state
ó ú
,
ú ù
PreciseTimeSpan 
deadline $
,$ %
CancellationToken& 7
cancellationToken8 I
)I J
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
state@ E
)E F
,F G
cancellationTokenH Y
)Y Z
{ 	
this 
. 
action 
= 
action  
;  !
this 
. 
context 
= 
context "
;" #
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
this9 =
.= >
context> E
,E F
thisG K
.K L

CompletionL V
.V W

AsyncStateW a
)a b
;b c
} 
} Ù
ÅC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\StateActionWithContextScheduledTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
sealed 

class /
#StateActionWithContextScheduledTask 4
:5 6
ScheduledTask7 D
{		 
readonly

 
Action

 
<

 
object

 
,

 
object

  &
>

& '
action

( .
;

. /
readonly 
object 
context 
;  
public /
#StateActionWithContextScheduledTask 2
(2 3*
AbstractScheduledEventExecutor3 Q
executorR Z
,Z [
Action\ b
<b c
objectc i
,i j
objectk q
>q r
actions y
,y z
object	{ Å
context
Ç â
,
â ä
object
ã ë
state
í ó
,
ó ò
PreciseTimeSpan 
deadline $
)$ %
: 
base 
( 
executor 
, 
deadline %
,% &
new' * 
TaskCompletionSource+ ?
(? @
state@ E
)E F
)F G
{ 	
this 
. 
action 
= 
action  
;  !
this 
. 
context 
= 
context "
;" #
} 	
	protected 
override 
void 
Execute  '
(' (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
this9 =
.= >
context> E
,E F
thisG K
.K L

CompletionL V
.V W

AsyncStateW a
)a b
;b c
} 
} Ñ
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Concurrency\TaskCompletionSource.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Concurrency %
{ 
public 

sealed 
class  
TaskCompletionSource ,
:- . 
TaskCompletionSource/ C
<C D
intD G
>G H
{		 
public

 
static

 
readonly

  
TaskCompletionSource

 3
Void

4 8
=

9 :
CreateVoidTcs

; H
(

H I
)

I J
;

J K
public  
TaskCompletionSource #
(# $
object$ *
state+ 0
)0 1
: 
base 
( 
state 
) 
{ 	
} 	
public  
TaskCompletionSource #
(# $
)$ %
{ 	
} 	
public 
bool 
TryComplete 
(  
)  !
=>" $
this% )
.) *
TrySetResult* 6
(6 7
$num7 8
)8 9
;9 :
public 
void 
Complete 
( 
) 
=> !
this" &
.& '
	SetResult' 0
(0 1
$num1 2
)2 3
;3 4
public 
bool 
SetUncancellable $
($ %
)% &
=>' )
true* .
;. /
public 
override 
string 
ToString '
(' (
)( )
=>* ,
$str- L
+M N
thisO S
.S T
TaskT X
.X Y
StatusY _
._ `
ToString` h
(h i
)i j
+k l
$strm p
;p q
static  
TaskCompletionSource #
CreateVoidTcs$ 1
(1 2
)2 3
{ 	
var   
tcs   
=   
new    
TaskCompletionSource   .
(  . /
)  / 0
;  0 1
tcs!! 
.!! 
TryComplete!! 
(!! 
)!! 
;!! 
return"" 
tcs"" 
;"" 
}## 	
}$$ 
}%% ”d
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\FastThreadLocal.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public		 

abstract		 
class		 
FastThreadLocal		 )
{

 
static 
readonly 
int "
VariablesToRemoveIndex 2
=3 4"
InternalThreadLocalMap5 K
.K L
NextVariableIndexL ]
(] ^
)^ _
;_ `
public 
static 
void 
	RemoveAll $
($ %
)% &
{ 	"
InternalThreadLocalMap "
threadLocalMap# 1
=2 3"
InternalThreadLocalMap4 J
.J K
GetIfSetK S
(S T
)T U
;U V
if 
( 
threadLocalMap 
== !
null" &
)& '
{ 
return 
; 
} 
try 
{ 
object 
v 
= 
threadLocalMap )
.) *
GetIndexedVariable* <
(< ="
VariablesToRemoveIndex= S
)S T
;T U
if 
( 
v 
!= 
null 
&&  
v! "
!=# %"
InternalThreadLocalMap& <
.< =
Unset= B
)B C
{ 
var 
variablesToRemove )
=* +
(, -
HashSet- 4
<4 5
FastThreadLocal5 D
>D E
)E F
vF G
;G H
foreach   
(   
FastThreadLocal   ,
tlv  - 0
in  1 3
variablesToRemove  4 E
)  E F
{!! 
tlv"" 
."" 
Remove"" "
(""" #
threadLocalMap""# 1
)""1 2
;""2 3
}## 
}$$ 
}%% 
finally&& 
{'' "
InternalThreadLocalMap(( &
.((& '
Remove((' -
(((- .
)((. /
;((/ 0
})) 
}** 	
public22 
static22 
void22 
Destroy22 "
(22" #
)22# $
=>22% '"
InternalThreadLocalMap22( >
.22> ?
Destroy22? F
(22F G
)22G H
;22H I
	protected44 
static44 
void44 "
AddToVariablesToRemove44 4
(444 5"
InternalThreadLocalMap445 K
threadLocalMap44L Z
,44Z [
FastThreadLocal44\ k
variable44l t
)44t u
{55 	
object66 
v66 
=66 
threadLocalMap66 %
.66% &
GetIndexedVariable66& 8
(668 9"
VariablesToRemoveIndex669 O
)66O P
;66P Q
HashSet77 
<77 
FastThreadLocal77 #
>77# $
variablesToRemove77% 6
;776 7
if88 
(88 
v88 
==88 "
InternalThreadLocalMap88 +
.88+ ,
Unset88, 1
||882 4
v885 6
==887 9
null88: >
)88> ?
{99 
variablesToRemove:: !
=::" #
new::$ '
HashSet::( /
<::/ 0
FastThreadLocal::0 ?
>::? @
(::@ A
)::A B
;::B C
threadLocalMap;; 
.;; 
SetIndexedVariable;; 1
(;;1 2"
VariablesToRemoveIndex;;2 H
,;;H I
variablesToRemove;;J [
);;[ \
;;;\ ]
}<< 
else== 
{>> 
variablesToRemove?? !
=??" #
(??$ %
HashSet??% ,
<??, -
FastThreadLocal??- <
>??< =
)??= >
v??> ?
;??? @
}@@ 
variablesToRemoveBB 
.BB 
AddBB !
(BB! "
variableBB" *
)BB* +
;BB+ ,
}CC 	
	protectedEE 
staticEE 
voidEE '
RemoveFromVariablesToRemoveEE 9
(EE9 :"
InternalThreadLocalMapEE: P
threadLocalMapEEQ _
,EE_ `
FastThreadLocalEEa p
variableEEq y
)EEy z
{FF 	
objectGG 
vGG 
=GG 
threadLocalMapGG %
.GG% &
GetIndexedVariableGG& 8
(GG8 9"
VariablesToRemoveIndexGG9 O
)GGO P
;GGP Q
ifII 
(II 
vII 
==II "
InternalThreadLocalMapII +
.II+ ,
UnsetII, 1
||II2 4
vII5 6
==II7 9
nullII: >
)II> ?
{JJ 
returnKK 
;KK 
}LL 
varNN 
variablesToRemoveNN !
=NN" #
(NN$ %
HashSetNN% ,
<NN, -
FastThreadLocalNN- <
>NN< =
)NN= >
vNN> ?
;NN? @
variablesToRemoveOO 
.OO 
RemoveOO $
(OO$ %
variableOO% -
)OO- .
;OO. /
}PP 	
publicVV 
abstractVV 
voidVV 
RemoveVV #
(VV# $"
InternalThreadLocalMapVV$ :
threadLocalMapVV; I
)VVI J
;VVJ K
}WW 
publicYY 

classYY 
FastThreadLocalYY  
<YY  !
TYY! "
>YY" #
:YY$ %
FastThreadLocalYY& 5
whereZZ 
TZZ 
:ZZ 
classZZ 
{[[ 
readonly\\ 
int\\ 
index\\ 
;\\ 
publicaa 
staticaa 
intaa 
Countaa 
=>aa  ""
InternalThreadLocalMapaa# 9
.aa9 :
GetIfSetaa: B
(aaB C
)aaC D
?aaD E
.aaE F
CountaaF K
??aaL N
$numaaO P
;aaP Q
publiccc 
FastThreadLocalcc 
(cc 
)cc  
{dd 	
thisee 
.ee 
indexee 
=ee "
InternalThreadLocalMapee /
.ee/ 0
NextVariableIndexee0 A
(eeA B
)eeB C
;eeC D
}ff 	
publickk 
Tkk 
Valuekk 
{ll 	
getmm 
{mm 
returnmm 
thismm 
.mm 
Getmm !
(mm! ""
InternalThreadLocalMapmm" 8
.mm8 9
Getmm9 <
(mm< =
)mm= >
)mm> ?
;mm? @
}mmA B
setnn 
{nn 
thisnn 
.nn 
Setnn 
(nn "
InternalThreadLocalMapnn 1
.nn1 2
Getnn2 5
(nn5 6
)nn6 7
,nn7 8
valuenn9 >
)nn> ?
;nn? @
}nnA B
}oo 	
[uu 	

MethodImpluu	 
(uu 
MethodImplOptionsuu %
.uu% &
AggressiveInlininguu& 8
)uu8 9
]uu9 :
publicvv 
Tvv 
Getvv 
(vv "
InternalThreadLocalMapvv +
threadLocalMapvv, :
)vv: ;
{ww 	
objectxx 
vxx 
=xx 
threadLocalMapxx %
.xx% &
GetIndexedVariablexx& 8
(xx8 9
thisxx9 =
.xx= >
indexxx> C
)xxC D
;xxD E
ifyy 
(yy 
vyy 
!=yy "
InternalThreadLocalMapyy +
.yy+ ,
Unsetyy, 1
)yy1 2
{zz 
return{{ 
({{ 
T{{ 
){{ 
v{{ 
;{{ 
}|| 
return~~ 
this~~ 
.~~ 

Initialize~~ "
(~~" #
threadLocalMap~~# 1
)~~1 2
;~~2 3
} 	
[
ÅÅ 	

MethodImpl
ÅÅ	 
(
ÅÅ 
MethodImplOptions
ÅÅ %
.
ÅÅ% & 
AggressiveInlining
ÅÅ& 8
)
ÅÅ8 9
]
ÅÅ9 :
T
ÇÇ 	

Initialize
ÇÇ
 
(
ÇÇ $
InternalThreadLocalMap
ÇÇ +
threadLocalMap
ÇÇ, :
)
ÇÇ: ;
{
ÉÉ 	
T
ÑÑ 
v
ÑÑ 
=
ÑÑ 
this
ÑÑ 
.
ÑÑ 
GetInitialValue
ÑÑ &
(
ÑÑ& '
)
ÑÑ' (
;
ÑÑ( )
threadLocalMap
ÜÜ 
.
ÜÜ  
SetIndexedVariable
ÜÜ -
(
ÜÜ- .
this
ÜÜ. 2
.
ÜÜ2 3
index
ÜÜ3 8
,
ÜÜ8 9
v
ÜÜ: ;
)
ÜÜ; <
;
ÜÜ< =$
AddToVariablesToRemove
áá "
(
áá" #
threadLocalMap
áá# 1
,
áá1 2
this
áá3 7
)
áá7 8
;
áá8 9
return
àà 
v
àà 
;
àà 
}
ââ 	
[
éé 	

MethodImpl
éé	 
(
éé 
MethodImplOptions
éé %
.
éé% & 
AggressiveInlining
éé& 8
)
éé8 9
]
éé9 :
public
èè 
void
èè 
Set
èè 
(
èè $
InternalThreadLocalMap
èè .
threadLocalMap
èè/ =
,
èè= >
T
èè? @
value
èèA F
)
èèF G
{
êê 	
if
ëë 
(
ëë 
threadLocalMap
ëë 
.
ëë  
SetIndexedVariable
ëë 1
(
ëë1 2
this
ëë2 6
.
ëë6 7
index
ëë7 <
,
ëë< =
value
ëë> C
)
ëëC D
)
ëëD E
{
íí $
AddToVariablesToRemove
ìì &
(
ìì& '
threadLocalMap
ìì' 5
,
ìì5 6
this
ìì7 ;
)
ìì; <
;
ìì< =
}
îî 
}
ïï 	
public
öö 
bool
öö 
IsSet
öö 
(
öö 
)
öö 
=>
öö 
this
öö #
.
öö# $
IsSet
öö$ )
(
öö) *$
InternalThreadLocalMap
öö* @
.
öö@ A
GetIfSet
ööA I
(
ööI J
)
ööJ K
)
ööK L
;
ööL M
[
†† 	

MethodImpl
††	 
(
†† 
MethodImplOptions
†† %
.
††% & 
AggressiveInlining
††& 8
)
††8 9
]
††9 :
public
°° 
bool
°° 
IsSet
°° 
(
°° $
InternalThreadLocalMap
°° 0
threadLocalMap
°°1 ?
)
°°? @
=>
°°A C
threadLocalMap
°°D R
!=
°°S U
null
°°V Z
&&
°°[ ]
threadLocalMap
°°^ l
.
°°l m#
IsIndexedVariableSet°°m Å
(°°Å Ç
this°°Ç Ü
.°°Ü á
index°°á å
)°°å ç
;°°ç é
	protected
¶¶ 
virtual
¶¶ 
T
¶¶ 
GetInitialValue
¶¶ +
(
¶¶+ ,
)
¶¶, -
=>
¶¶. 0
null
¶¶1 5
;
¶¶5 6
public
®® 
void
®® 
Remove
®® 
(
®® 
)
®® 
=>
®® 
this
®®  $
.
®®$ %
Remove
®®% +
(
®®+ ,$
InternalThreadLocalMap
®®, B
.
®®B C
GetIfSet
®®C K
(
®®K L
)
®®L M
)
®®M N
;
®®N O
[
≤≤ 	

MethodImpl
≤≤	 
(
≤≤ 
MethodImplOptions
≤≤ %
.
≤≤% & 
AggressiveInlining
≤≤& 8
)
≤≤8 9
]
≤≤9 :
public
≥≥ 
sealed
≥≥ 
override
≥≥ 
void
≥≥ #
Remove
≥≥$ *
(
≥≥* +$
InternalThreadLocalMap
≥≥+ A
threadLocalMap
≥≥B P
)
≥≥P Q
{
¥¥ 	
if
µµ 
(
µµ 
threadLocalMap
µµ 
==
µµ !
null
µµ" &
)
µµ& '
{
∂∂ 
return
∑∑ 
;
∑∑ 
}
∏∏ 
object
∫∫ 
v
∫∫ 
=
∫∫ 
threadLocalMap
∫∫ %
.
∫∫% &#
RemoveIndexedVariable
∫∫& ;
(
∫∫; <
this
∫∫< @
.
∫∫@ A
index
∫∫A F
)
∫∫F G
;
∫∫G H)
RemoveFromVariablesToRemove
ªª '
(
ªª' (
threadLocalMap
ªª( 6
,
ªª6 7
this
ªª8 <
)
ªª< =
;
ªª= >
if
ΩΩ 
(
ΩΩ 
v
ΩΩ 
!=
ΩΩ $
InternalThreadLocalMap
ΩΩ +
.
ΩΩ+ ,
Unset
ΩΩ, 1
)
ΩΩ1 2
{
ææ 
this
øø 
.
øø 
	OnRemoval
øø 
(
øø 
(
øø  
T
øø  !
)
øø! "
v
øø" #
)
øø# $
;
øø$ %
}
¿¿ 
}
¡¡ 	
	protected
∆∆ 
virtual
∆∆ 
void
∆∆ 
	OnRemoval
∆∆ (
(
∆∆( )
T
∆∆) *
value
∆∆+ 0
)
∆∆0 1
{
«« 	
}
»» 	
}
…… 
}   ØÖ
hC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\InternalThreadLocalMap.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

sealed 
class "
InternalThreadLocalMap .
{ 
const 
int +
DefaultArrayListInitialCapacity 1
=2 3
$num4 5
;5 6
public 
static 
readonly 
object %
Unset& +
=, -
new. 1
object2 8
(8 9
)9 :
;: ;
[ 	
ThreadStatic	 
] 
static "
InternalThreadLocalMap %
slowThreadLocalMap& 8
;8 9
static 
int 
	nextIndex 
; 
object 
[ 
] 
indexedVariables !
;! "
int"" $
futureListenerStackDepth"" $
;""$ %
int## (
localChannelReaderStackDepth## (
;##( )
StringBuilder&& 
stringBuilder&& #
;&&# $
List)) 
<)) 
ICharSequence)) 
>)) 
charSequences)) )
;))) *
List** 
<** 
AsciiString** 
>** 
asciiStrings** &
;**& '
internal,, 
static,, 
int,, 
NextVariableIndex,, -
(,,- .
),,. /
{-- 	
int.. 
index.. 
=.. 
Interlocked.. #
...# $
	Increment..$ -
(..- .
ref... 1
	nextIndex..2 ;
)..; <
;..< =
if// 
(// 
index// 
<// 
$num// 
)// 
{00 
Interlocked11 
.11 
	Decrement11 %
(11% &
ref11& )
	nextIndex11* 3
)113 4
;114 5
throw22 
new22 %
InvalidOperationException22 3
(223 4
$str224 ]
)22] ^
;22^ _
}33 
return44 
index44 
;44 
}55 	
[77 	

MethodImpl77	 
(77 
MethodImplOptions77 %
.77% &
AggressiveInlining77& 8
)778 9
]779 :
public88 
static88 "
InternalThreadLocalMap88 ,
GetIfSet88- 5
(885 6
)886 7
=>888 :
slowThreadLocalMap88; M
;88M N
[:: 	

MethodImpl::	 
(:: 
MethodImplOptions:: %
.::% &
AggressiveInlining::& 8
)::8 9
]::9 :
public;; 
static;; "
InternalThreadLocalMap;; ,
Get;;- 0
(;;0 1
);;1 2
{<< 	"
InternalThreadLocalMap== "
ret==# &
===' (
slowThreadLocalMap==) ;
;==; <
if>> 
(>> 
ret>> 
==>> 
null>> 
)>> 
{?? 
ret@@ 
=@@ 
new@@ "
InternalThreadLocalMap@@ 0
(@@0 1
)@@1 2
;@@2 3
slowThreadLocalMapAA "
=AA# $
retAA% (
;AA( )
}BB 
returnCC 
retCC 
;CC 
}DD 	
publicFF 
staticFF 
voidFF 
RemoveFF !
(FF! "
)FF" #
=>FF$ &
slowThreadLocalMapFF' 9
=FF: ;
nullFF< @
;FF@ A
publicHH 
staticHH 
voidHH 
DestroyHH "
(HH" #
)HH# $
=>HH% '
slowThreadLocalMapHH( :
=HH; <
nullHH= A
;HHA B
publicMM 
longMM 
rp1MM 
,MM 
rp2MM 
,MM 
rp3MM !
,MM! "
rp4MM# &
,MM& '
rp5MM( +
,MM+ ,
rp6MM- 0
,MM0 1
rp7MM2 5
,MM5 6
rp8MM7 :
,MM: ;
rp9MM< ?
;MM? @"
InternalThreadLocalMapPP 
(PP 
)PP  
{QQ 	
thisRR 
.RR 
indexedVariablesRR !
=RR" #&
CreateIndexedVariableTableRR$ >
(RR> ?
)RR? @
;RR@ A
}SS 	
staticUU 
objectUU 
[UU 
]UU &
CreateIndexedVariableTableUU 2
(UU2 3
)UU3 4
{VV 	
varWW 
arrayWW 
=WW 
newWW 
objectWW "
[WW" #
$numWW# %
]WW% &
;WW& '
arrayYY 
.YY 
FillYY 
(YY 
UnsetYY 
)YY 
;YY 
returnZZ 
arrayZZ 
;ZZ 
}[[ 	
public]] 
int]] 
Count]] 
{^^ 	
get__ 
{`` 
intaa 
countaa 
=aa 
$numaa 
;aa 
ifcc 
(cc 
thiscc 
.cc $
futureListenerStackDepthcc 1
!=cc2 4
$numcc5 6
)cc6 7
{dd 
countee 
++ee 
;ee 
}ff 
ifgg 
(gg 
thisgg 
.gg (
localChannelReaderStackDepthgg 5
!=gg6 8
$numgg9 :
)gg: ;
{hh 
countii 
++ii 
;ii 
}jj 
ifkk 
(kk 
thiskk 
.kk 
stringBuilderkk &
!=kk' )
nullkk* .
)kk. /
{ll 
countmm 
++mm 
;mm 
}nn 
foreachoo 
(oo 
objectoo 
ooo  !
inoo" $
thisoo% )
.oo) *
indexedVariablesoo* :
)oo: ;
{pp 
ifqq 
(qq 
oqq 
!=qq 
Unsetqq "
)qq" #
{rr 
countss 
++ss 
;ss  
}tt 
}uu 
returnyy 
countyy 
-yy 
$numyy  
;yy  !
}zz 
}{{ 	
public}} 
StringBuilder}} 
StringBuilder}} *
{~~ 	
get 
{
ÄÄ 
StringBuilder
ÅÅ 
builder
ÅÅ %
=
ÅÅ& '
this
ÅÅ( ,
.
ÅÅ, -
stringBuilder
ÅÅ- :
;
ÅÅ: ;
if
ÇÇ 
(
ÇÇ 
builder
ÇÇ 
==
ÇÇ 
null
ÇÇ #
)
ÇÇ# $
{
ÉÉ 
this
ÑÑ 
.
ÑÑ 
stringBuilder
ÑÑ &
=
ÑÑ' (
builder
ÑÑ) 0
=
ÑÑ1 2
new
ÑÑ3 6
StringBuilder
ÑÑ7 D
(
ÑÑD E
$num
ÑÑE H
)
ÑÑH I
;
ÑÑI J
}
ÖÖ 
else
ÜÜ 
{
áá 
builder
àà 
.
àà 
Length
àà "
=
àà# $
$num
àà% &
;
àà& '
}
ââ 
return
ää 
builder
ää 
;
ää 
}
ãã 
}
åå 	
public
éé 
List
éé 
<
éé 
ICharSequence
éé !
>
éé! "
CharSequenceList
éé# 3
(
éé3 4
int
éé4 7
minCapacity
éé8 C
=
ééD E-
DefaultArrayListInitialCapacity
ééF e
)
éée f
{
èè 	
List
êê 
<
êê 
ICharSequence
êê 
>
êê 
	localList
êê  )
=
êê* +
this
êê, 0
.
êê0 1
charSequences
êê1 >
;
êê> ?
if
ëë 
(
ëë 
	localList
ëë 
==
ëë 
null
ëë !
)
ëë! "
{
íí 
this
ìì 
.
ìì 
charSequences
ìì "
=
ìì# $
new
ìì% (
List
ìì) -
<
ìì- .
ICharSequence
ìì. ;
>
ìì; <
(
ìì< =
minCapacity
ìì= H
)
ììH I
;
ììI J
return
îî 
this
îî 
.
îî 
charSequences
îî )
;
îî) *
}
ïï 
	localList
óó 
.
óó 
Clear
óó 
(
óó 
)
óó 
;
óó 
	localList
ôô 
.
ôô 
Capacity
ôô 
=
ôô  
minCapacity
ôô! ,
;
ôô, -
return
öö 
	localList
öö 
;
öö 
}
õõ 	
public
ùù 
List
ùù 
<
ùù 
AsciiString
ùù 
>
ùù  
AsciiStringList
ùù! 0
(
ùù0 1
int
ùù1 4
minCapacity
ùù5 @
=
ùùA B-
DefaultArrayListInitialCapacity
ùùC b
)
ùùb c
{
ûû 	
List
üü 
<
üü 
AsciiString
üü 
>
üü 
	localList
üü '
=
üü( )
this
üü* .
.
üü. /
asciiStrings
üü/ ;
;
üü; <
if
†† 
(
†† 
	localList
†† 
==
†† 
null
†† !
)
††! "
{
°° 
this
¢¢ 
.
¢¢ 
asciiStrings
¢¢ !
=
¢¢" #
new
¢¢$ '
List
¢¢( ,
<
¢¢, -
AsciiString
¢¢- 8
>
¢¢8 9
(
¢¢9 :
minCapacity
¢¢: E
)
¢¢E F
;
¢¢F G
return
££ 
this
££ 
.
££ 
asciiStrings
££ (
;
££( )
}
§§ 
	localList
¶¶ 
.
¶¶ 
Clear
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶ 
	localList
®® 
.
®® 
Capacity
®® 
=
®®  
minCapacity
®®! ,
;
®®, -
return
©© 
	localList
©© 
;
©© 
}
™™ 	
public
¨¨ 
int
¨¨ &
FutureListenerStackDepth
¨¨ +
{
≠≠ 	
get
ÆÆ 
=>
ÆÆ 
this
ÆÆ 
.
ÆÆ &
futureListenerStackDepth
ÆÆ 0
;
ÆÆ0 1
set
ØØ 
=>
ØØ 
this
ØØ 
.
ØØ &
futureListenerStackDepth
ØØ 0
=
ØØ1 2
value
ØØ3 8
;
ØØ8 9
}
∞∞ 	
public
≤≤ 
int
≤≤ *
LocalChannelReaderStackDepth
≤≤ /
{
≥≥ 	
get
¥¥ 
=>
¥¥ 
this
¥¥ 
.
¥¥ *
localChannelReaderStackDepth
¥¥ 4
;
¥¥4 5
set
µµ 
=>
µµ 
this
µµ 
.
µµ *
localChannelReaderStackDepth
µµ 4
=
µµ5 6
value
µµ7 <
;
µµ< =
}
∂∂ 	
[
∏∏ 	

MethodImpl
∏∏	 
(
∏∏ 
MethodImplOptions
∏∏ %
.
∏∏% & 
AggressiveInlining
∏∏& 8
)
∏∏8 9
]
∏∏9 :
public
ππ 
object
ππ  
GetIndexedVariable
ππ (
(
ππ( )
int
ππ) ,
index
ππ- 2
)
ππ2 3
{
∫∫ 	
object
ªª 
[
ªª 
]
ªª 
lookup
ªª 
=
ªª 
this
ªª "
.
ªª" #
indexedVariables
ªª# 3
;
ªª3 4
return
ºº 
index
ºº 
<
ºº 
lookup
ºº !
.
ºº! "
Length
ºº" (
?
ºº) *
lookup
ºº+ 1
[
ºº1 2
index
ºº2 7
]
ºº7 8
:
ºº9 :
Unset
ºº; @
;
ºº@ A
}
ΩΩ 	
public
≈≈ 
bool
≈≈  
SetIndexedVariable
≈≈ &
(
≈≈& '
int
≈≈' *
index
≈≈+ 0
,
≈≈0 1
object
≈≈2 8
value
≈≈9 >
)
≈≈> ?
{
∆∆ 	
object
«« 
[
«« 
]
«« 
lookup
«« 
=
«« 
this
«« "
.
««" #
indexedVariables
««# 3
;
««3 4
if
»» 
(
»» 
index
»» 
<
»» 
lookup
»» 
.
»» 
Length
»» %
)
»»% &
{
…… 
object
   
oldValue
   
=
    !
lookup
  " (
[
  ( )
index
  ) .
]
  . /
;
  / 0
lookup
ÀÀ 
[
ÀÀ 
index
ÀÀ 
]
ÀÀ 
=
ÀÀ 
value
ÀÀ  %
;
ÀÀ% &
return
ÃÃ 
oldValue
ÃÃ 
==
ÃÃ  "
Unset
ÃÃ# (
;
ÃÃ( )
}
ÕÕ 
else
ŒŒ 
{
œœ 
this
–– 
.
–– .
 ExpandIndexedVariableTableAndSet
–– 5
(
––5 6
index
––6 ;
,
––; <
value
––= B
)
––B C
;
––C D
return
—— 
true
—— 
;
—— 
}
““ 
}
”” 	
void
’’ .
 ExpandIndexedVariableTableAndSet
’’ -
(
’’- .
int
’’. 1
index
’’2 7
,
’’7 8
object
’’9 ?
value
’’@ E
)
’’E F
{
÷÷ 	
object
◊◊ 
[
◊◊ 
]
◊◊ 
oldArray
◊◊ 
=
◊◊ 
this
◊◊  $
.
◊◊$ %
indexedVariables
◊◊% 5
;
◊◊5 6
int
ÿÿ 
oldCapacity
ÿÿ 
=
ÿÿ 
oldArray
ÿÿ &
.
ÿÿ& '
Length
ÿÿ' -
;
ÿÿ- .
int
ŸŸ 
newCapacity
ŸŸ 
=
ŸŸ 
index
ŸŸ #
;
ŸŸ# $
newCapacity
⁄⁄ 
|=
⁄⁄ 
newCapacity
⁄⁄ &
.
⁄⁄& '
RightUShift
⁄⁄' 2
(
⁄⁄2 3
$num
⁄⁄3 4
)
⁄⁄4 5
;
⁄⁄5 6
newCapacity
€€ 
|=
€€ 
newCapacity
€€ &
.
€€& '
RightUShift
€€' 2
(
€€2 3
$num
€€3 4
)
€€4 5
;
€€5 6
newCapacity
‹‹ 
|=
‹‹ 
newCapacity
‹‹ &
.
‹‹& '
RightUShift
‹‹' 2
(
‹‹2 3
$num
‹‹3 4
)
‹‹4 5
;
‹‹5 6
newCapacity
›› 
|=
›› 
newCapacity
›› &
.
››& '
RightUShift
››' 2
(
››2 3
$num
››3 4
)
››4 5
;
››5 6
newCapacity
ﬁﬁ 
|=
ﬁﬁ 
newCapacity
ﬁﬁ &
.
ﬁﬁ& '
RightUShift
ﬁﬁ' 2
(
ﬁﬁ2 3
$num
ﬁﬁ3 5
)
ﬁﬁ5 6
;
ﬁﬁ6 7
newCapacity
ﬂﬂ 
++
ﬂﬂ 
;
ﬂﬂ 
var
·· 
newArray
·· 
=
·· 
new
·· 
object
·· %
[
··% &
newCapacity
··& 1
]
··1 2
;
··2 3
oldArray
‚‚ 
.
‚‚ 
CopyTo
‚‚ 
(
‚‚ 
newArray
‚‚ $
,
‚‚$ %
$num
‚‚& '
)
‚‚' (
;
‚‚( )
newArray
„„ 
.
„„ 
Fill
„„ 
(
„„ 
oldCapacity
„„ %
,
„„% &
newArray
„„' /
.
„„/ 0
Length
„„0 6
-
„„7 8
oldCapacity
„„9 D
,
„„D E
Unset
„„F K
)
„„K L
;
„„L M
newArray
‰‰ 
[
‰‰ 
index
‰‰ 
]
‰‰ 
=
‰‰ 
value
‰‰ #
;
‰‰# $
this
ÂÂ 
.
ÂÂ 
indexedVariables
ÂÂ !
=
ÂÂ" #
newArray
ÂÂ$ ,
;
ÂÂ, -
}
ÊÊ 	
public
ËË 
object
ËË #
RemoveIndexedVariable
ËË +
(
ËË+ ,
int
ËË, /
index
ËË0 5
)
ËË5 6
{
ÈÈ 	
object
ÍÍ 
[
ÍÍ 
]
ÍÍ 
lookup
ÍÍ 
=
ÍÍ 
this
ÍÍ "
.
ÍÍ" #
indexedVariables
ÍÍ# 3
;
ÍÍ3 4
if
ÎÎ 
(
ÎÎ 
index
ÎÎ 
<
ÎÎ 
lookup
ÎÎ 
.
ÎÎ 
Length
ÎÎ %
)
ÎÎ% &
{
ÏÏ 
object
ÌÌ 
v
ÌÌ 
=
ÌÌ 
lookup
ÌÌ !
[
ÌÌ! "
index
ÌÌ" '
]
ÌÌ' (
;
ÌÌ( )
lookup
ÓÓ 
[
ÓÓ 
index
ÓÓ 
]
ÓÓ 
=
ÓÓ 
Unset
ÓÓ  %
;
ÓÓ% &
return
ÔÔ 
v
ÔÔ 
;
ÔÔ 
}
 
else
ÒÒ 
{
ÚÚ 
return
ÛÛ 
Unset
ÛÛ 
;
ÛÛ 
}
ÙÙ 
}
ıı 	
public
˜˜ 
bool
˜˜ "
IsIndexedVariableSet
˜˜ (
(
˜˜( )
int
˜˜) ,
index
˜˜- 2
)
˜˜2 3
{
¯¯ 	
object
˘˘ 
[
˘˘ 
]
˘˘ 
lookup
˘˘ 
=
˘˘ 
this
˘˘ "
.
˘˘" #
indexedVariables
˘˘# 3
;
˘˘3 4
return
˙˙ 
index
˙˙ 
<
˙˙ 
lookup
˙˙ !
.
˙˙! "
Length
˙˙" (
&&
˙˙) +
lookup
˙˙, 2
[
˙˙2 3
index
˙˙3 8
]
˙˙8 9
!=
˙˙: <
Unset
˙˙= B
;
˙˙B C
}
˚˚ 	
}
¸¸ 
}˝˝ Ü
hC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\AbstractQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

abstract 
class 
AbstractQueue '
<' (
T( )
>) *
:+ ,
IQueue- 3
<3 4
T4 5
>5 6
{ 
public 
abstract 
bool 

TryEnqueue '
(' (
T( )
item* .
). /
;/ 0
public

 
abstract

 
bool

 

TryDequeue

 '
(

' (
out

( +
T

, -
item

. 2
)

2 3
;

3 4
public 
abstract 
bool 
TryPeek $
($ %
out% (
T) *
item+ /
)/ 0
;0 1
public 
abstract 
int 
Count !
{" #
get$ '
;' (
}) *
public 
abstract 
bool 
IsEmpty $
{% &
get' *
;* +
}, -
public 
abstract 
void 
Clear "
(" #
)# $
;$ %
} 
} ¯¢
qC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\AppendableCharSequence.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

sealed 
class "
AppendableCharSequence .
:/ 0
ICharSequence1 >
,> ?
IAppendable@ K
,K L

IEquatableM W
<W X"
AppendableCharSequenceX n
>n o
{   
byte!! 
[!! 
]!! 
chars!! 
;!! 
int"" 
pos"" 
;"" 
public$$ "
AppendableCharSequence$$ %
($$% &
int$$& )
length$$* 0
)$$0 1
{%% 	
Contract&& 
.&& 
Requires&& 
(&& 
length&& $
>&&% &
$num&&' (
)&&( )
;&&) *
this(( 
.(( 
chars(( 
=(( 
new(( 
byte(( !
[((! "
length((" (
]((( )
;(() *
})) 	
public++ "
AppendableCharSequence++ %
(++% &
byte++& *
[++* +
]+++ ,
chars++- 2
)++2 3
{,, 	
Contract-- 
.-- 
Requires-- 
(-- 
chars-- #
.--# $
Length--$ *
>--+ ,
$num--- .
)--. /
;--/ 0
this// 
.// 
chars// 
=// 
chars// 
;// 
this00 
.00 
pos00 
=00 
chars00 
.00 
Length00 #
;00# $
}11 	
public33 
IEnumerator33 
<33 
char33 
>33  
GetEnumerator33! .
(33. /
)33/ 0
=>331 3
new334 7"
CharSequenceEnumerator338 N
(33N O
this33O S
)33S T
;33T U
IEnumerator55 
IEnumerable55 
.55  
GetEnumerator55  -
(55- .
)55. /
=>550 2
this553 7
.557 8
GetEnumerator558 E
(55E F
)55F G
;55G H
public77 
int77 
Count77 
=>77 
this77  
.77  !
pos77! $
;77$ %
public99 
char99 
this99 
[99 
int99 
index99 "
]99" #
{:: 	
get;; 
{<< 
Contract== 
.== 
Requires== !
(==! "
index==" '
<===( *
this==+ /
.==/ 0
pos==0 3
)==3 4
;==4 5
return>> 
AsciiString>> "
.>>" #

ByteToChar>># -
(>>- .
this>>. 2
.>>2 3
chars>>3 8
[>>8 9
index>>9 >
]>>> ?
)>>? @
;>>@ A
}?? 
}@@ 	
publicBB 
refBB 
byteBB 
[BB 
]BB 
BytesBB 
=>BB  "
refBB# &
thisBB' +
.BB+ ,
charsBB, 1
;BB1 2
publicDD 
ICharSequenceDD 
SubSequenceDD (
(DD( )
intDD) ,
startDD- 2
)DD2 3
=>DD4 6
thisDD7 ;
.DD; <
SubSequenceDD< G
(DDG H
startDDH M
,DDM N
thisDDO S
.DDS T
posDDT W
)DDW X
;DDX Y
publicFF 
ICharSequenceFF 
SubSequenceFF (
(FF( )
intFF) ,
startFF- 2
,FF2 3
intFF4 7
endFF8 ;
)FF; <
{GG 	
intHH 
lengthHH 
=HH 
endHH 
-HH 
startHH $
;HH$ %
varII 
dataII 
=II 
newII 
byteII 
[II  
lengthII  &
]II& '
;II' (
PlatformDependentJJ 
.JJ 

CopyMemoryJJ (
(JJ( )
thisJJ) -
.JJ- .
charsJJ. 3
,JJ3 4
startJJ5 :
,JJ: ;
dataJJ< @
,JJ@ A
$numJJB C
,JJC D
lengthJJE K
)JJK L
;JJL M
returnKK 
newKK "
AppendableCharSequenceKK -
(KK- .
dataKK. 2
)KK2 3
;KK3 4
}LL 	
publicNN 
intNN 
IndexOfNN 
(NN 
charNN 
chNN  "
,NN" #
intNN$ '
startNN( -
=NN. /
$numNN0 1
)NN1 2
=>NN3 5
CharUtilNN6 >
.NN> ?
IndexOfNN? F
(NNF G
thisNNG K
,NNK L
chNNM O
,NNO P
startNNQ V
)NNV W
;NNW X
publicPP 
boolPP 
RegionMatchesPP !
(PP! "
intPP" %
	thisStartPP& /
,PP/ 0
ICharSequencePP1 >
seqPP? B
,PPB C
intPPD G
startPPH M
,PPM N
intPPO R
lengthPPS Y
)PPY Z
=>PP[ ]
CharUtilQQ 
.QQ 
RegionMatchesQQ "
(QQ" #
thisQQ# '
,QQ' (
	thisStartQQ) 2
,QQ2 3
seqQQ4 7
,QQ7 8
startQQ9 >
,QQ> ?
lengthQQ@ F
)QQF G
;QQG H
publicSS 
boolSS #
RegionMatchesIgnoreCaseSS +
(SS+ ,
intSS, /
	thisStartSS0 9
,SS9 :
ICharSequenceSS; H
seqSSI L
,SSL M
intSSN Q
startSSR W
,SSW X
intSSY \
lengthSS] c
)SSc d
=>SSe g
CharUtilTT 
.TT #
RegionMatchesIgnoreCaseTT ,
(TT, -
thisTT- 1
,TT1 2
	thisStartTT3 <
,TT< =
seqTT> A
,TTA B
startTTC H
,TTH I
lengthTTJ P
)TTP Q
;TTQ R
publicVV 
boolVV 
ContentEqualsVV !
(VV! "
ICharSequenceVV" /
otherVV0 5
)VV5 6
=>VV7 9
CharUtilVV: B
.VVB C
ContentEqualsVVC P
(VVP Q
thisVVQ U
,VVU V
otherVVW \
)VV\ ]
;VV] ^
publicXX 
boolXX #
ContentEqualsIgnoreCaseXX +
(XX+ ,
ICharSequenceXX, 9
otherXX: ?
)XX? @
=>XXA C
CharUtilXXD L
.XXL M#
ContentEqualsIgnoreCaseXXM d
(XXd e
thisXXe i
,XXi j
otherXXk p
)XXp q
;XXq r
publicZZ 
boolZZ 
EqualsZZ 
(ZZ "
AppendableCharSequenceZZ 1
otherZZ2 7
)ZZ7 8
{[[ 	
if\\ 
(\\ 
other\\ 
==\\ 
null\\ 
)\\ 
{]] 
return^^ 
false^^ 
;^^ 
}__ 
if`` 
(`` 
ReferenceEquals`` 
(``  
this``  $
,``$ %
other``& +
)``+ ,
)``, -
{aa 
returnbb 
truebb 
;bb 
}cc 
returnee 
thisee 
.ee 
posee 
==ee 
otheree $
.ee$ %
posee% (
&&ff 
PlatformDependentff $
.ff$ %
ByteArrayEqualsff% 4
(ff4 5
thisff5 9
.ff9 :
charsff: ?
,ff? @
$numffA B
,ffB C
otherffD I
.ffI J
charsffJ O
,ffO P
$numffQ R
,ffR S
thisffT X
.ffX Y
posffY \
)ff\ ]
;ff] ^
}gg 	
publicii 
overrideii 
boolii 
Equalsii #
(ii# $
objectii$ *
objii+ .
)ii. /
{jj 	
ifkk 
(kk 
objkk 
==kk 
nullkk 
)kk 
{ll 
returnmm 
falsemm 
;mm 
}nn 
ifoo 
(oo 
ReferenceEqualsoo 
(oo  
thisoo  $
,oo$ %
objoo& )
)oo) *
)oo* +
{pp 
returnqq 
trueqq 
;qq 
}rr 
iftt 
(tt 
objtt 
istt "
AppendableCharSequencett -
othertt. 3
)tt3 4
{uu 
returnvv 
thisvv 
.vv 
Equalsvv "
(vv" #
othervv# (
)vv( )
;vv) *
}ww 
ifxx 
(xx 
objxx 
isxx 
ICharSequencexx $
seqxx% (
)xx( )
{yy 
returnzz 
thiszz 
.zz 
ContentEqualszz )
(zz) *
seqzz* -
)zz- .
;zz. /
}{{ 
return}} 
false}} 
;}} 
}~~ 	
public
ÄÄ 
int
ÄÄ 
HashCode
ÄÄ 
(
ÄÄ 
bool
ÄÄ  

ignoreCase
ÄÄ! +
)
ÄÄ+ ,
=>
ÄÄ- /

ignoreCase
ÄÄ0 :
?
ÅÅ 
StringComparer
ÅÅ 
.
ÅÅ 
OrdinalIgnoreCase
ÅÅ .
.
ÅÅ. /
GetHashCode
ÅÅ/ :
(
ÅÅ: ;
this
ÅÅ; ?
.
ÅÅ? @
ToString
ÅÅ@ H
(
ÅÅH I
)
ÅÅI J
)
ÅÅJ K
:
ÇÇ 
StringComparer
ÇÇ 
.
ÇÇ 
Ordinal
ÇÇ $
.
ÇÇ$ %
GetHashCode
ÇÇ% 0
(
ÇÇ0 1
this
ÇÇ1 5
.
ÇÇ5 6
ToString
ÇÇ6 >
(
ÇÇ> ?
)
ÇÇ? @
)
ÇÇ@ A
;
ÇÇA B
public
ÑÑ 
override
ÑÑ 
int
ÑÑ 
GetHashCode
ÑÑ '
(
ÑÑ' (
)
ÑÑ( )
=>
ÑÑ* ,
this
ÑÑ- 1
.
ÑÑ1 2
HashCode
ÑÑ2 :
(
ÑÑ: ;
true
ÑÑ; ?
)
ÑÑ? @
;
ÑÑ@ A
public
ÜÜ 
IAppendable
ÜÜ 
Append
ÜÜ !
(
ÜÜ! "
char
ÜÜ" &
c
ÜÜ' (
)
ÜÜ( )
=>
ÜÜ* ,
this
ÜÜ- 1
.
ÜÜ1 2
Append
ÜÜ2 8
(
ÜÜ8 9
(
ÜÜ9 :
byte
ÜÜ: >
)
ÜÜ> ?
c
ÜÜ? @
)
ÜÜ@ A
;
ÜÜA B
[
àà 	

MethodImpl
àà	 
(
àà 
MethodImplOptions
àà %
.
àà% & 
AggressiveInlining
àà& 8
)
àà8 9
]
àà9 :
public
ââ 
IAppendable
ââ 
Append
ââ !
(
ââ! "
byte
ââ" &
c
ââ' (
)
ââ( )
{
ää 	
if
ãã 
(
ãã 
this
ãã 
.
ãã 
pos
ãã 
==
ãã 
this
ãã  
.
ãã  !
chars
ãã! &
.
ãã& '
Length
ãã' -
)
ãã- .
{
åå 
byte
çç 
[
çç 
]
çç 
old
çç 
=
çç 
this
çç !
.
çç! "
chars
çç" '
;
çç' (
this
éé 
.
éé 
chars
éé 
=
éé 
new
éé  
byte
éé! %
[
éé% &
old
éé& )
.
éé) *
Length
éé* 0
<<
éé1 3
$num
éé4 5
]
éé5 6
;
éé6 7
PlatformDependent
èè !
.
èè! "

CopyMemory
èè" ,
(
èè, -
old
èè- 0
,
èè0 1
$num
èè2 3
,
èè3 4
this
èè5 9
.
èè9 :
chars
èè: ?
,
èè? @
$num
èèA B
,
èèB C
old
èèD G
.
èèG H
Length
èèH N
)
èèN O
;
èèO P
}
êê 
this
ëë 
.
ëë 
chars
ëë 
[
ëë 
this
ëë 
.
ëë 
pos
ëë 
++
ëë !
]
ëë! "
=
ëë# $
c
ëë% &
;
ëë& '
return
íí 
this
íí 
;
íí 
}
ìì 	
public
ïï 
IAppendable
ïï 
Append
ïï !
(
ïï! "
ICharSequence
ïï" /
sequence
ïï0 8
)
ïï8 9
=>
ïï: <
this
ïï= A
.
ïïA B
Append
ïïB H
(
ïïH I
sequence
ïïI Q
,
ïïQ R
$num
ïïS T
,
ïïT U
sequence
ïïV ^
.
ïï^ _
Count
ïï_ d
)
ïïd e
;
ïïe f
public
óó 
IAppendable
óó 
Append
óó !
(
óó! "
ICharSequence
óó" /
sequence
óó0 8
,
óó8 9
int
óó: =
start
óó> C
,
óóC D
int
óóE H
end
óóI L
)
óóL M
{
òò 	
Contract
ôô 
.
ôô 
Requires
ôô 
(
ôô 
sequence
ôô &
.
ôô& '
Count
ôô' ,
>=
ôô- /
end
ôô0 3
)
ôô3 4
;
ôô4 5
int
õõ 
length
õõ 
=
õõ 
end
õõ 
-
õõ 
start
õõ $
;
õõ$ %
if
úú 
(
úú 
length
úú 
>
úú 
this
úú 
.
úú 
chars
úú #
.
úú# $
Length
úú$ *
-
úú+ ,
this
úú- 1
.
úú1 2
pos
úú2 5
)
úú5 6
{
ùù 
this
ûû 
.
ûû 
chars
ûû 
=
ûû 
Expand
ûû #
(
ûû# $
this
ûû$ (
.
ûû( )
chars
ûû) .
,
ûû. /
this
ûû0 4
.
ûû4 5
pos
ûû5 8
+
ûû9 :
length
ûû; A
,
ûûA B
this
ûûC G
.
ûûG H
pos
ûûH K
)
ûûK L
;
ûûL M
}
üü 
if
°° 
(
°° 
sequence
°° 
is
°° $
AppendableCharSequence
°° 2
seq
°°3 6
)
°°6 7
{
¢¢ 
byte
§§ 
[
§§ 
]
§§ 
src
§§ 
=
§§ 
seq
§§  
.
§§  !
chars
§§! &
;
§§& '
PlatformDependent
•• !
.
••! "

CopyMemory
••" ,
(
••, -
src
••- 0
,
••0 1
start
••2 7
,
••7 8
this
••9 =
.
••= >
chars
••> C
,
••C D
this
••E I
.
••I J
pos
••J M
,
••M N
length
••O U
)
••U V
;
••V W
this
¶¶ 
.
¶¶ 
pos
¶¶ 
+=
¶¶ 
length
¶¶ "
;
¶¶" #
return
®® 
this
®® 
;
®® 
}
©© 
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
start
´´ 
;
´´ 
i
´´  !
<
´´" #
end
´´$ '
;
´´' (
i
´´) *
++
´´* ,
)
´´, -
{
¨¨ 
this
≠≠ 
.
≠≠ 
chars
≠≠ 
[
≠≠ 
this
≠≠ 
.
≠≠  
pos
≠≠  #
++
≠≠# %
]
≠≠% &
=
≠≠' (
(
≠≠) *
byte
≠≠* .
)
≠≠. /
sequence
≠≠/ 7
[
≠≠7 8
i
≠≠8 9
]
≠≠9 :
;
≠≠: ;
}
ÆÆ 
return
∞∞ 
this
∞∞ 
;
∞∞ 
}
±± 	
public
∑∑ 
void
∑∑ 
Reset
∑∑ 
(
∑∑ 
)
∑∑ 
=>
∑∑ 
this
∑∑ #
.
∑∑# $
pos
∑∑$ '
=
∑∑( )
$num
∑∑* +
;
∑∑+ ,
public
ππ 
string
ππ 
ToString
ππ 
(
ππ 
int
ππ "
start
ππ# (
)
ππ( )
{
∫∫ 	
Contract
ªª 
.
ªª 
Requires
ªª 
(
ªª 
start
ªª #
>=
ªª$ &
$num
ªª' (
&&
ªª) +
start
ªª, 1
<
ªª2 3
this
ªª4 8
.
ªª8 9
pos
ªª9 <
)
ªª< =
;
ªª= >
return
ºº 
Encoding
ºº 
.
ºº 
ASCII
ºº !
.
ºº! "
	GetString
ºº" +
(
ºº+ ,
this
ºº, 0
.
ºº0 1
chars
ºº1 6
,
ºº6 7
start
ºº8 =
,
ºº= >
this
ºº? C
.
ººC D
pos
ººD G
)
ººG H
;
ººH I
}
ΩΩ 	
public
øø 
override
øø 
string
øø 
ToString
øø '
(
øø' (
)
øø( )
=>
øø* ,
this
øø- 1
.
øø1 2
pos
øø2 5
==
øø6 8
$num
øø9 :
?
øø; <
string
øø= C
.
øøC D
Empty
øøD I
:
øøJ K
this
øøL P
.
øøP Q
ToString
øøQ Y
(
øøY Z
$num
øøZ [
)
øø[ \
;
øø\ ]
public
¡¡ 
AsciiString
¡¡ 
ToAsciiString
¡¡ (
(
¡¡( )
)
¡¡) *
=>
¡¡+ -
this
¡¡. 2
.
¡¡2 3
pos
¡¡3 6
==
¡¡7 9
$num
¡¡: ;
?
¡¡< =
AsciiString
¡¡> I
.
¡¡I J
Empty
¡¡J O
:
¡¡P Q
new
¡¡R U
AsciiString
¡¡V a
(
¡¡a b
this
¡¡b f
.
¡¡f g
chars
¡¡g l
,
¡¡l m
$num
¡¡n o
,
¡¡o p
this
¡¡q u
.
¡¡u v
pos
¡¡v y
,
¡¡y z
true
¡¡{ 
)¡¡ Ä
;¡¡Ä Å
[
«« 	

MethodImpl
««	 
(
«« 
MethodImplOptions
«« %
.
««% & 
AggressiveInlining
««& 8
)
««8 9
]
««9 :
public
»» 
unsafe
»» 
AsciiString
»» !
SubStringUnsafe
»»" 1
(
»»1 2
int
»»2 5
start
»»6 ;
,
»»; <
int
»»= @
end
»»A D
)
»»D E
{
…… 	
var
   
bytes
   
=
   
new
   
byte
    
[
    !
end
  ! $
-
  % &
start
  ' ,
]
  , -
;
  - .
fixed
ÀÀ 
(
ÀÀ 
byte
ÀÀ 
*
ÀÀ 
src
ÀÀ 
=
ÀÀ 
&
ÀÀ  
this
ÀÀ  $
.
ÀÀ$ %
chars
ÀÀ% *
[
ÀÀ* +
start
ÀÀ+ 0
]
ÀÀ0 1
)
ÀÀ1 2
fixed
ÃÃ 
(
ÃÃ 
byte
ÃÃ 
*
ÃÃ 
dst
ÃÃ 
=
ÃÃ 
bytes
ÃÃ $
)
ÃÃ$ %
{
ÕÕ 
PlatformDependent
ŒŒ !
.
ŒŒ! "

CopyMemory
ŒŒ" ,
(
ŒŒ, -
src
ŒŒ- 0
,
ŒŒ0 1
dst
ŒŒ2 5
,
ŒŒ5 6
bytes
ŒŒ7 <
.
ŒŒ< =
Length
ŒŒ= C
)
ŒŒC D
;
ŒŒD E
}
œœ 
return
–– 
new
–– 
AsciiString
–– "
(
––" #
bytes
––# (
)
––( )
;
––) *
}
—— 	
static
”” 
byte
”” 
[
”” 
]
”” 
Expand
”” 
(
”” 
byte
”” !
[
””! "
]
””" #
array
””$ )
,
””) *
int
””+ .
neededSpace
””/ :
,
””: ;
int
””< ?
size
””@ D
)
””D E
{
‘‘ 	
int
’’ 
newCapacity
’’ 
=
’’ 
array
’’ #
.
’’# $
Length
’’$ *
;
’’* +
do
÷÷ 
{
◊◊ 
newCapacity
ŸŸ 
<<=
ŸŸ 
$num
ŸŸ  !
;
ŸŸ! "
if
€€ 
(
€€ 
newCapacity
€€ 
<
€€  !
$num
€€" #
)
€€# $
{
‹‹ 
throw
›› 
new
›› '
InvalidOperationException
›› 7
(
››7 8
$"
››8 :
$str
››: G
{
››G H
newCapacity
››H S
}
››S T
$str
››T e
"
››e f
)
››f g
;
››g h
}
ﬁﬁ 
}
ﬂﬂ 
while
‡‡ 
(
‡‡ 
neededSpace
‡‡ 
>
‡‡  
newCapacity
‡‡! ,
)
‡‡, -
;
‡‡- .
var
‚‚ 
newArray
‚‚ 
=
‚‚ 
new
‚‚ 
byte
‚‚ #
[
‚‚# $
newCapacity
‚‚$ /
]
‚‚/ 0
;
‚‚0 1
PlatformDependent
„„ 
.
„„ 

CopyMemory
„„ (
(
„„( )
array
„„) .
,
„„. /
$num
„„0 1
,
„„1 2
newArray
„„3 ;
,
„„; <
$num
„„= >
,
„„> ?
size
„„@ D
)
„„D E
;
„„E F
return
‰‰ 
newArray
‰‰ 
;
‰‰ 
}
ÂÂ 	
}
ÊÊ 
}ÁÁ ∫

tC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\CompatibleConcurrentQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

class %
CompatibleConcurrentQueue *
<* +
T+ ,
>, -
:. /
ConcurrentQueue0 ?
<? @
T@ A
>A B
,B C
IQueueD J
<J K
TK L
>L M
{		 
public

 
bool

 

TryEnqueue

 
(

 
T

  
element

! (
)

( )
{ 	
this 
. 
Enqueue 
( 
element  
)  !
;! "
return 
true 
; 
} 	
void 
IQueue 
< 
T 
> 
. 
Clear 
( 
) 
{ 	
T 
item 
; 
while 
( 
this 
. 

TryDequeue "
(" #
out# &
item' +
)+ ,
), -
{ 
} 
} 	
} 
} £'
wC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\ConcurrentCircularArrayQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
abstract 
class (
ConcurrentCircularArrayQueue /
</ 0
T0 1
>1 2
:3 4-
!ConcurrentCircularArrayQueueL0Pad5 V
<V W
TW X
>X Y
where 
T 
: 
class 
{ 
	protected 
long 
Mask 
; 
	protected 
readonly 
T 
[ 
] 
Buffer %
;% &
	protected (
ConcurrentCircularArrayQueue .
(. /
int/ 2
capacity3 ;
); <
{ 	
int 
actualCapacity 
=  
IntegerExtensions! 2
.2 3
RoundUpToPowerOfTwo3 F
(F G
capacityG O
)O P
;P Q
this   
.   
Mask   
=   
actualCapacity   &
-  ' (
$num  ) *
;  * +
this"" 
."" 
Buffer"" 
="" 
new"" 
T"" 
[""  
actualCapacity""  .
+""/ 0
RefArrayAccessUtil""1 C
.""C D
RefBufferPad""D P
*""Q R
$num""S T
]""T U
;""U V
}## 	
	protected** 
long** 
CalcElementOffset** (
(**( )
long**) -
index**. 3
)**3 4
=>**5 7
RefArrayAccessUtil**8 J
.**J K
CalcElementOffset**K \
(**\ ]
index**] b
,**b c
this**d h
.**h i
Mask**i m
)**m n
;**n o
	protected11 
void11 
	SpElement11  
(11  !
long11! %
offset11& ,
,11, -
T11. /
e110 1
)111 2
=>113 5
RefArrayAccessUtil116 H
.11H I
	SpElement11I R
(11R S
this11S W
.11W X
Buffer11X ^
,11^ _
offset11` f
,11f g
e11h i
)11i j
;11j k
	protected88 
void88 
	SoElement88  
(88  !
long88! %
offset88& ,
,88, -
T88. /
e880 1
)881 2
=>883 5
RefArrayAccessUtil886 H
.88H I
	SoElement88I R
(88R S
this88S W
.88W X
Buffer88X ^
,88^ _
offset88` f
,88f g
e88h i
)88i j
;88j k
	protected?? 
T?? 
	LpElement?? 
(?? 
long?? "
offset??# )
)??) *
=>??+ -
RefArrayAccessUtil??. @
.??@ A
	LpElement??A J
(??J K
this??K O
.??O P
Buffer??P V
,??V W
offset??X ^
)??^ _
;??_ `
	protectedFF 
TFF 
	LvElementFF 
(FF 
longFF "
offsetFF# )
)FF) *
=>FF+ -
RefArrayAccessUtilFF. @
.FF@ A
	LvElementFFA J
(FFJ K
thisFFK O
.FFO P
BufferFFP V
,FFV W
offsetFFX ^
)FF^ _
;FF_ `
publicHH 
overrideHH 
voidHH 
ClearHH "
(HH" #
)HH# $
{II 	
whileJJ 
(JJ 
thisJJ 
.JJ 

TryDequeueJJ "
(JJ" #
outJJ# &
TJJ' (
_JJ) *
)JJ* +
||JJ, .
!JJ/ 0
thisJJ0 4
.JJ4 5
IsEmptyJJ5 <
)JJ< =
{KK 
}MM 
}NN 	
publicPP 
intPP 
CapacityPP 
(PP 
)PP 
=>PP  
(PP! "
intPP" %
)PP% &
(PP& '
thisPP' +
.PP+ ,
MaskPP, 0
+PP1 2
$numPP3 4
)PP4 5
;PP5 6
}QQ 
abstractSS 
classSS -
!ConcurrentCircularArrayQueueL0PadSS 4
<SS4 5
TSS5 6
>SS6 7
:SS8 9
AbstractQueueSS: G
<SSG H
TSSH I
>SSI J
{TT 
longVV 
p00VV 
,VV 
p01VV 
,VV 
p02VV 
,VV 
p03VV 
,VV  
p04VV! $
,VV$ %
p05VV& )
,VV) *
p06VV+ .
,VV. /
p07VV0 3
;VV3 4
longWW 
p30WW 
,WW 
p31WW 
,WW 
p32WW 
,WW 
p33WW 
,WW  
p34WW! $
,WW$ %
p35WW& )
,WW) *
p36WW+ .
,WW. /
p37WW0 3
;WW3 4
}YY 
}ZZ °
xC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\DefaultPlatformImplementation.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
class		 	
DefaultPlatform		
 
:		 
	IPlatform		 %
{

 
int 
	processId 
; 
public 
DefaultPlatform 
( 
)  
{ 	
var 
processGuid 
= 
Guid "
." #
NewGuid# *
(* +
)+ ,
;, -
	processId 
= 
BitConverter $
.$ %
ToInt32% ,
(, -
processGuid- 8
.8 9
ToByteArray9 D
(D E
)E F
,F G
$numH I
)I J
;J K
	processId 
= 
	processId !
&" #
$num$ ,
;, -
Contract 
. 
Assert 
( 
	processId %
<=& (
$num) 1
)1 2
;2 3
} 	
int 
	IPlatform 
. 
GetCurrentProcessId )
() *
)* +
=>, .
	processId/ 8
;8 9
byte 
[ 
] 
	IPlatform 
. 
GetDefaultDeviceId +
(+ ,
), -
=>. 0
MacAddressUtil1 ?
.? @
GetBestAvailableMac@ S
(S T
)T U
;U V
} 
} á
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\EmptyArrays.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

static 
class 
EmptyArrays #
{		 
public

 
static

 
readonly

 
int

 "
[

" #
]

# $
	EmptyInts

% .
=

/ 0
{

1 2
}

3 4
;

4 5
public 
static 
readonly 
byte #
[# $
]$ %

EmptyBytes& 0
=1 2
{3 4
}5 6
;6 7
public 
static 
readonly 
char #
[# $
]$ %

EmptyChars& 0
=1 2
{3 4
}5 6
;6 7
public 
static 
readonly 
object %
[% &
]& '
EmptyObjects( 4
=5 6
{7 8
}9 :
;: ;
public 
static 
readonly 
string %
[% &
]& '
EmptyStrings( 4
=5 6
{7 8
}9 :
;: ;
public 
static 
readonly 
AsciiString *
[* +
]+ ,
EmptyAsciiStrings- >
=? @
{A B
}C D
;D E
} 
} Ã
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\IAppendable.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

	interface 
IAppendable  
{		 
IAppendable

 
Append

 
(

 
char

 
c

  !
)

! "
;

" #
IAppendable 
Append 
( 
ICharSequence (
sequence) 1
)1 2
;2 3
IAppendable 
Append 
( 
ICharSequence (
sequence) 1
,1 2
int3 6
start7 <
,< =
int> A
endB E
)E F
;F G
} 
} ◊
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\IDeque.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

	interface 
IDeque 
< 
T 
> 
:  
IQueue! '
<' (
T( )
>) *
{ 
bool 
TryDequeueLast 
( 
out 
T  !
item" &
)& '
;' (
}		 
}

 Ø
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\IPlatform.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

	interface 
	IPlatform 
{ 
int 
GetCurrentProcessId 
(  
)  !
;! "
byte

 
[

 
]

 
GetDefaultDeviceId

 !
(

! "
)

" #
;

# $
} 
} ö
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\IQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

	interface 
IQueue 
< 
T 
> 
{ 
bool 

TryEnqueue 
( 
T 
item 
) 
;  
bool

 

TryDequeue

 
(

 
out

 
T

 
item

 "
)

" #
;

# $
bool 
TryPeek 
( 
out 
T 
item 
)  
;  !
int 
Count 
{ 
get 
; 
} 
bool 
IsEmpty 
{ 
get 
; 
} 
void 
Clear 
( 
) 
; 
} 
} ™∑
yC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\AbstractInternalLogger.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public 

abstract 
class "
AbstractInternalLogger 0
:1 2
IInternalLogger3 B
{ 
static 
readonly 
string 
EXCEPTION_MESSAGE 0
=1 2
$str3 J
;J K
	protected "
AbstractInternalLogger (
(( )
string) /
name0 4
)4 5
{ 	
Contract 
. 
Requires 
( 
name "
!=# %
null& *
)* +
;+ ,
this 
. 
Name 
= 
name 
; 
} 	
public 
string 
Name 
{ 
get  
;  !
}" #
public 
bool 
	IsEnabled 
( 
InternalLogLevel .
level/ 4
)4 5
{   	
switch!! 
(!! 
level!! 
)!! 
{"" 
case## 
InternalLogLevel## %
.##% &
TRACE##& +
:##+ ,
return$$ 
this$$ 
.$$  
TraceEnabled$$  ,
;$$, -
case%% 
InternalLogLevel%% %
.%%% &
DEBUG%%& +
:%%+ ,
return&& 
this&& 
.&&  
DebugEnabled&&  ,
;&&, -
case'' 
InternalLogLevel'' %
.''% &
INFO''& *
:''* +
return(( 
this(( 
.((  
InfoEnabled((  +
;((+ ,
case)) 
InternalLogLevel)) %
.))% &
WARN))& *
:))* +
return** 
this** 
.**  
WarnEnabled**  +
;**+ ,
case++ 
InternalLogLevel++ %
.++% &
ERROR++& +
:+++ ,
return,, 
this,, 
.,,  
ErrorEnabled,,  ,
;,,, -
default-- 
:-- 
throw.. 
new.. '
ArgumentOutOfRangeException.. 9
(..9 :
)..: ;
;..; <
}// 
}00 	
public22 
abstract22 
bool22 
TraceEnabled22 )
{22* +
get22, /
;22/ 0
}221 2
public44 
abstract44 
void44 
Trace44 "
(44" #
string44# )
msg44* -
)44- .
;44. /
public66 
abstract66 
void66 
Trace66 "
(66" #
string66# )
format66* 0
,660 1
object662 8
arg669 <
)66< =
;66= >
public88 
abstract88 
void88 
Trace88 "
(88" #
string88# )
format88* 0
,880 1
object882 8
argA889 =
,88= >
object88? E
argB88F J
)88J K
;88K L
public:: 
abstract:: 
void:: 
Trace:: "
(::" #
string::# )
format::* 0
,::0 1
params::2 8
object::9 ?
[::? @
]::@ A
	arguments::B K
)::K L
;::L M
public<< 
abstract<< 
void<< 
Trace<< "
(<<" #
string<<# )
msg<<* -
,<<- .
	Exception<</ 8
t<<9 :
)<<: ;
;<<; <
public>> 
void>> 
Trace>> 
(>> 
	Exception>> #
t>>$ %
)>>% &
=>>>' )
this>>* .
.>>. /
Trace>>/ 4
(>>4 5
EXCEPTION_MESSAGE>>5 F
,>>F G
t>>H I
)>>I J
;>>J K
public@@ 
abstract@@ 
bool@@ 
DebugEnabled@@ )
{@@* +
get@@, /
;@@/ 0
}@@1 2
publicBB 
abstractBB 
voidBB 
DebugBB "
(BB" #
stringBB# )
msgBB* -
)BB- .
;BB. /
publicDD 
abstractDD 
voidDD 
DebugDD "
(DD" #
stringDD# )
formatDD* 0
,DD0 1
objectDD2 8
argDD9 <
)DD< =
;DD= >
publicFF 
abstractFF 
voidFF 
DebugFF "
(FF" #
stringFF# )
formatFF* 0
,FF0 1
objectFF2 8
argAFF9 =
,FF= >
objectFF? E
argBFFF J
)FFJ K
;FFK L
publicHH 
abstractHH 
voidHH 
DebugHH "
(HH" #
stringHH# )
formatHH* 0
,HH0 1
paramsHH2 8
objectHH9 ?
[HH? @
]HH@ A
	argumentsHHB K
)HHK L
;HHL M
publicJJ 
abstractJJ 
voidJJ 
DebugJJ "
(JJ" #
stringJJ# )
msgJJ* -
,JJ- .
	ExceptionJJ/ 8
tJJ9 :
)JJ: ;
;JJ; <
publicLL 
voidLL 
DebugLL 
(LL 
	ExceptionLL #
tLL$ %
)LL% &
=>LL' )
thisLL* .
.LL. /
DebugLL/ 4
(LL4 5
EXCEPTION_MESSAGELL5 F
,LLF G
tLLH I
)LLI J
;LLJ K
publicNN 
abstractNN 
boolNN 
InfoEnabledNN (
{NN) *
getNN+ .
;NN. /
}NN0 1
publicPP 
abstractPP 
voidPP 
InfoPP !
(PP! "
stringPP" (
msgPP) ,
)PP, -
;PP- .
publicRR 
abstractRR 
voidRR 
InfoRR !
(RR! "
stringRR" (
formatRR) /
,RR/ 0
objectRR1 7
argRR8 ;
)RR; <
;RR< =
publicTT 
abstractTT 
voidTT 
InfoTT !
(TT! "
stringTT" (
formatTT) /
,TT/ 0
objectTT1 7
argATT8 <
,TT< =
objectTT> D
argBTTE I
)TTI J
;TTJ K
publicVV 
abstractVV 
voidVV 
InfoVV !
(VV! "
stringVV" (
formatVV) /
,VV/ 0
paramsVV1 7
objectVV8 >
[VV> ?
]VV? @
	argumentsVVA J
)VVJ K
;VVK L
publicXX 
abstractXX 
voidXX 
InfoXX !
(XX! "
stringXX" (
msgXX) ,
,XX, -
	ExceptionXX. 7
tXX8 9
)XX9 :
;XX: ;
publicZZ 
voidZZ 
InfoZZ 
(ZZ 
	ExceptionZZ "
tZZ# $
)ZZ$ %
=>ZZ& (
thisZZ) -
.ZZ- .
InfoZZ. 2
(ZZ2 3
EXCEPTION_MESSAGEZZ3 D
,ZZD E
tZZF G
)ZZG H
;ZZH I
public\\ 
abstract\\ 
bool\\ 
WarnEnabled\\ (
{\\) *
get\\+ .
;\\. /
}\\0 1
public^^ 
abstract^^ 
void^^ 
Warn^^ !
(^^! "
string^^" (
msg^^) ,
)^^, -
;^^- .
public`` 
abstract`` 
void`` 
Warn`` !
(``! "
string``" (
format``) /
,``/ 0
object``1 7
arg``8 ;
)``; <
;``< =
publicbb 
abstractbb 
voidbb 
Warnbb !
(bb! "
stringbb" (
formatbb) /
,bb/ 0
paramsbb1 7
objectbb8 >
[bb> ?
]bb? @
	argumentsbbA J
)bbJ K
;bbK L
publicdd 
abstractdd 
voiddd 
Warndd !
(dd! "
stringdd" (
formatdd) /
,dd/ 0
objectdd1 7
argAdd8 <
,dd< =
objectdd> D
argBddE I
)ddI J
;ddJ K
publicff 
abstractff 
voidff 
Warnff !
(ff! "
stringff" (
msgff) ,
,ff, -
	Exceptionff. 7
tff8 9
)ff9 :
;ff: ;
publichh 
voidhh 
Warnhh 
(hh 
	Exceptionhh "
thh# $
)hh$ %
=>hh& (
thishh) -
.hh- .
Warnhh. 2
(hh2 3
EXCEPTION_MESSAGEhh3 D
,hhD E
thhF G
)hhG H
;hhH I
publicjj 
abstractjj 
booljj 
ErrorEnabledjj )
{jj* +
getjj, /
;jj/ 0
}jj1 2
publicll 
abstractll 
voidll 
Errorll "
(ll" #
stringll# )
msgll* -
)ll- .
;ll. /
publicnn 
abstractnn 
voidnn 
Errornn "
(nn" #
stringnn# )
formatnn* 0
,nn0 1
objectnn2 8
argnn9 <
)nn< =
;nn= >
publicpp 
abstractpp 
voidpp 
Errorpp "
(pp" #
stringpp# )
formatpp* 0
,pp0 1
objectpp2 8
argApp9 =
,pp= >
objectpp? E
argBppF J
)ppJ K
;ppK L
publicrr 
abstractrr 
voidrr 
Errorrr "
(rr" #
stringrr# )
formatrr* 0
,rr0 1
paramsrr2 8
objectrr9 ?
[rr? @
]rr@ A
	argumentsrrB K
)rrK L
;rrL M
publictt 
abstracttt 
voidtt 
Errortt "
(tt" #
stringtt# )
msgtt* -
,tt- .
	Exceptiontt/ 8
ttt9 :
)tt: ;
;tt; <
publicvv 
voidvv 
Errorvv 
(vv 
	Exceptionvv #
tvv$ %
)vv% &
=>vv' )
thisvv* .
.vv. /
Errorvv/ 4
(vv4 5
EXCEPTION_MESSAGEvv5 F
,vvF G
tvvH I
)vvI J
;vvJ K
publicxx 
voidxx 
Logxx 
(xx 
InternalLogLevelxx (
levelxx) .
,xx. /
stringxx0 6
msgxx7 :
,xx: ;
	Exceptionxx< E
causexxF K
)xxK L
{yy 	
switchzz 
(zz 
levelzz 
)zz 
{{{ 
case|| 
InternalLogLevel|| %
.||% &
TRACE||& +
:||+ ,
this}} 
.}} 
Trace}} 
(}} 
msg}} "
,}}" #
cause}}$ )
)}}) *
;}}* +
break~~ 
;~~ 
case 
InternalLogLevel %
.% &
DEBUG& +
:+ ,
this
ÄÄ 
.
ÄÄ 
Debug
ÄÄ 
(
ÄÄ 
msg
ÄÄ "
,
ÄÄ" #
cause
ÄÄ$ )
)
ÄÄ) *
;
ÄÄ* +
break
ÅÅ 
;
ÅÅ 
case
ÇÇ 
InternalLogLevel
ÇÇ %
.
ÇÇ% &
INFO
ÇÇ& *
:
ÇÇ* +
this
ÉÉ 
.
ÉÉ 
Info
ÉÉ 
(
ÉÉ 
msg
ÉÉ !
,
ÉÉ! "
cause
ÉÉ# (
)
ÉÉ( )
;
ÉÉ) *
break
ÑÑ 
;
ÑÑ 
case
ÖÖ 
InternalLogLevel
ÖÖ %
.
ÖÖ% &
WARN
ÖÖ& *
:
ÖÖ* +
this
ÜÜ 
.
ÜÜ 
Warn
ÜÜ 
(
ÜÜ 
msg
ÜÜ !
,
ÜÜ! "
cause
ÜÜ# (
)
ÜÜ( )
;
ÜÜ) *
break
áá 
;
áá 
case
àà 
InternalLogLevel
àà %
.
àà% &
ERROR
àà& +
:
àà+ ,
this
ââ 
.
ââ 
Error
ââ 
(
ââ 
msg
ââ "
,
ââ" #
cause
ââ$ )
)
ââ) *
;
ââ* +
break
ää 
;
ää 
default
ãã 
:
ãã 
throw
åå 
new
åå )
ArgumentOutOfRangeException
åå 9
(
åå9 :
)
åå: ;
;
åå; <
}
çç 
}
éé 	
public
êê 
void
êê 
Log
êê 
(
êê 
InternalLogLevel
êê (
level
êê) .
,
êê. /
	Exception
êê0 9
cause
êê: ?
)
êê? @
{
ëë 	
switch
íí 
(
íí 
level
íí 
)
íí 
{
ìì 
case
îî 
InternalLogLevel
îî %
.
îî% &
TRACE
îî& +
:
îî+ ,
this
ïï 
.
ïï 
Trace
ïï 
(
ïï 
cause
ïï $
)
ïï$ %
;
ïï% &
break
ññ 
;
ññ 
case
óó 
InternalLogLevel
óó %
.
óó% &
DEBUG
óó& +
:
óó+ ,
this
òò 
.
òò 
Debug
òò 
(
òò 
cause
òò $
)
òò$ %
;
òò% &
break
ôô 
;
ôô 
case
öö 
InternalLogLevel
öö %
.
öö% &
INFO
öö& *
:
öö* +
this
õõ 
.
õõ 
Info
õõ 
(
õõ 
cause
õõ #
)
õõ# $
;
õõ$ %
break
úú 
;
úú 
case
ùù 
InternalLogLevel
ùù %
.
ùù% &
WARN
ùù& *
:
ùù* +
this
ûû 
.
ûû 
Warn
ûû 
(
ûû 
cause
ûû #
)
ûû# $
;
ûû$ %
break
üü 
;
üü 
case
†† 
InternalLogLevel
†† %
.
††% &
ERROR
††& +
:
††+ ,
this
°° 
.
°° 
Error
°° 
(
°° 
cause
°° $
)
°°$ %
;
°°% &
break
¢¢ 
;
¢¢ 
default
££ 
:
££ 
throw
§§ 
new
§§ )
ArgumentOutOfRangeException
§§ 9
(
§§9 :
)
§§: ;
;
§§; <
}
•• 
}
¶¶ 	
public
®® 
void
®® 
Log
®® 
(
®® 
InternalLogLevel
®® (
level
®®) .
,
®®. /
string
®®0 6
msg
®®7 :
)
®®: ;
{
©© 	
switch
™™ 
(
™™ 
level
™™ 
)
™™ 
{
´´ 
case
¨¨ 
InternalLogLevel
¨¨ %
.
¨¨% &
TRACE
¨¨& +
:
¨¨+ ,
this
≠≠ 
.
≠≠ 
Trace
≠≠ 
(
≠≠ 
msg
≠≠ "
)
≠≠" #
;
≠≠# $
break
ÆÆ 
;
ÆÆ 
case
ØØ 
InternalLogLevel
ØØ %
.
ØØ% &
DEBUG
ØØ& +
:
ØØ+ ,
this
∞∞ 
.
∞∞ 
Debug
∞∞ 
(
∞∞ 
msg
∞∞ "
)
∞∞" #
;
∞∞# $
break
±± 
;
±± 
case
≤≤ 
InternalLogLevel
≤≤ %
.
≤≤% &
INFO
≤≤& *
:
≤≤* +
this
≥≥ 
.
≥≥ 
Info
≥≥ 
(
≥≥ 
msg
≥≥ !
)
≥≥! "
;
≥≥" #
break
¥¥ 
;
¥¥ 
case
µµ 
InternalLogLevel
µµ %
.
µµ% &
WARN
µµ& *
:
µµ* +
this
∂∂ 
.
∂∂ 
Warn
∂∂ 
(
∂∂ 
msg
∂∂ !
)
∂∂! "
;
∂∂" #
break
∑∑ 
;
∑∑ 
case
∏∏ 
InternalLogLevel
∏∏ %
.
∏∏% &
ERROR
∏∏& +
:
∏∏+ ,
this
ππ 
.
ππ 
Error
ππ 
(
ππ 
msg
ππ "
)
ππ" #
;
ππ# $
break
∫∫ 
;
∫∫ 
default
ªª 
:
ªª 
throw
ºº 
new
ºº )
ArgumentOutOfRangeException
ºº 9
(
ºº9 :
)
ºº: ;
;
ºº; <
}
ΩΩ 
}
ææ 	
public
¿¿ 
void
¿¿ 
Log
¿¿ 
(
¿¿ 
InternalLogLevel
¿¿ (
level
¿¿) .
,
¿¿. /
string
¿¿0 6
format
¿¿7 =
,
¿¿= >
object
¿¿? E
arg
¿¿F I
)
¿¿I J
{
¡¡ 	
switch
¬¬ 
(
¬¬ 
level
¬¬ 
)
¬¬ 
{
√√ 
case
ƒƒ 
InternalLogLevel
ƒƒ %
.
ƒƒ% &
TRACE
ƒƒ& +
:
ƒƒ+ ,
this
≈≈ 
.
≈≈ 
Trace
≈≈ 
(
≈≈ 
format
≈≈ %
,
≈≈% &
arg
≈≈' *
)
≈≈* +
;
≈≈+ ,
break
∆∆ 
;
∆∆ 
case
«« 
InternalLogLevel
«« %
.
««% &
DEBUG
««& +
:
««+ ,
this
»» 
.
»» 
Debug
»» 
(
»» 
format
»» %
,
»»% &
arg
»»' *
)
»»* +
;
»»+ ,
break
…… 
;
…… 
case
   
InternalLogLevel
   %
.
  % &
INFO
  & *
:
  * +
this
ÀÀ 
.
ÀÀ 
Info
ÀÀ 
(
ÀÀ 
format
ÀÀ $
,
ÀÀ$ %
arg
ÀÀ& )
)
ÀÀ) *
;
ÀÀ* +
break
ÃÃ 
;
ÃÃ 
case
ÕÕ 
InternalLogLevel
ÕÕ %
.
ÕÕ% &
WARN
ÕÕ& *
:
ÕÕ* +
this
ŒŒ 
.
ŒŒ 
Warn
ŒŒ 
(
ŒŒ 
format
ŒŒ $
,
ŒŒ$ %
arg
ŒŒ& )
)
ŒŒ) *
;
ŒŒ* +
break
œœ 
;
œœ 
case
–– 
InternalLogLevel
–– %
.
––% &
ERROR
––& +
:
––+ ,
this
—— 
.
—— 
Error
—— 
(
—— 
format
—— %
,
——% &
arg
——' *
)
——* +
;
——+ ,
break
““ 
;
““ 
default
”” 
:
”” 
throw
‘‘ 
new
‘‘ )
ArgumentOutOfRangeException
‘‘ 9
(
‘‘9 :
)
‘‘: ;
;
‘‘; <
}
’’ 
}
÷÷ 	
public
ÿÿ 
void
ÿÿ 
Log
ÿÿ 
(
ÿÿ 
InternalLogLevel
ÿÿ (
level
ÿÿ) .
,
ÿÿ. /
string
ÿÿ0 6
format
ÿÿ7 =
,
ÿÿ= >
object
ÿÿ? E
argA
ÿÿF J
,
ÿÿJ K
object
ÿÿL R
argB
ÿÿS W
)
ÿÿW X
{
ŸŸ 	
switch
⁄⁄ 
(
⁄⁄ 
level
⁄⁄ 
)
⁄⁄ 
{
€€ 
case
‹‹ 
InternalLogLevel
‹‹ %
.
‹‹% &
TRACE
‹‹& +
:
‹‹+ ,
this
›› 
.
›› 
Trace
›› 
(
›› 
format
›› %
,
››% &
argA
››' +
,
››+ ,
argB
››- 1
)
››1 2
;
››2 3
break
ﬁﬁ 
;
ﬁﬁ 
case
ﬂﬂ 
InternalLogLevel
ﬂﬂ %
.
ﬂﬂ% &
DEBUG
ﬂﬂ& +
:
ﬂﬂ+ ,
this
‡‡ 
.
‡‡ 
Debug
‡‡ 
(
‡‡ 
format
‡‡ %
,
‡‡% &
argA
‡‡' +
,
‡‡+ ,
argB
‡‡- 1
)
‡‡1 2
;
‡‡2 3
break
·· 
;
·· 
case
‚‚ 
InternalLogLevel
‚‚ %
.
‚‚% &
INFO
‚‚& *
:
‚‚* +
this
„„ 
.
„„ 
Info
„„ 
(
„„ 
format
„„ $
,
„„$ %
argA
„„& *
,
„„* +
argB
„„, 0
)
„„0 1
;
„„1 2
break
‰‰ 
;
‰‰ 
case
ÂÂ 
InternalLogLevel
ÂÂ %
.
ÂÂ% &
WARN
ÂÂ& *
:
ÂÂ* +
this
ÊÊ 
.
ÊÊ 
Warn
ÊÊ 
(
ÊÊ 
format
ÊÊ $
,
ÊÊ$ %
argA
ÊÊ& *
,
ÊÊ* +
argB
ÊÊ, 0
)
ÊÊ0 1
;
ÊÊ1 2
break
ÁÁ 
;
ÁÁ 
case
ËË 
InternalLogLevel
ËË %
.
ËË% &
ERROR
ËË& +
:
ËË+ ,
this
ÈÈ 
.
ÈÈ 
Error
ÈÈ 
(
ÈÈ 
format
ÈÈ %
,
ÈÈ% &
argA
ÈÈ' +
,
ÈÈ+ ,
argB
ÈÈ- 1
)
ÈÈ1 2
;
ÈÈ2 3
break
ÍÍ 
;
ÍÍ 
default
ÎÎ 
:
ÎÎ 
throw
ÏÏ 
new
ÏÏ )
ArgumentOutOfRangeException
ÏÏ 9
(
ÏÏ9 :
)
ÏÏ: ;
;
ÏÏ; <
}
ÌÌ 
}
ÓÓ 	
public
 
void
 
Log
 
(
 
InternalLogLevel
 (
level
) .
,
. /
string
0 6
format
7 =
,
= >
params
? E
object
F L
[
L M
]
M N
	arguments
O X
)
X Y
{
ÒÒ 	
switch
ÚÚ 
(
ÚÚ 
level
ÚÚ 
)
ÚÚ 
{
ÛÛ 
case
ÙÙ 
InternalLogLevel
ÙÙ %
.
ÙÙ% &
TRACE
ÙÙ& +
:
ÙÙ+ ,
this
ıı 
.
ıı 
Trace
ıı 
(
ıı 
format
ıı %
,
ıı% &
	arguments
ıı' 0
)
ıı0 1
;
ıı1 2
break
ˆˆ 
;
ˆˆ 
case
˜˜ 
InternalLogLevel
˜˜ %
.
˜˜% &
DEBUG
˜˜& +
:
˜˜+ ,
this
¯¯ 
.
¯¯ 
Debug
¯¯ 
(
¯¯ 
format
¯¯ %
,
¯¯% &
	arguments
¯¯' 0
)
¯¯0 1
;
¯¯1 2
break
˘˘ 
;
˘˘ 
case
˙˙ 
InternalLogLevel
˙˙ %
.
˙˙% &
INFO
˙˙& *
:
˙˙* +
this
˚˚ 
.
˚˚ 
Info
˚˚ 
(
˚˚ 
format
˚˚ $
,
˚˚$ %
	arguments
˚˚& /
)
˚˚/ 0
;
˚˚0 1
break
¸¸ 
;
¸¸ 
case
˝˝ 
InternalLogLevel
˝˝ %
.
˝˝% &
WARN
˝˝& *
:
˝˝* +
this
˛˛ 
.
˛˛ 
Warn
˛˛ 
(
˛˛ 
format
˛˛ $
,
˛˛$ %
	arguments
˛˛& /
)
˛˛/ 0
;
˛˛0 1
break
ˇˇ 
;
ˇˇ 
case
ÄÄ 
InternalLogLevel
ÄÄ %
.
ÄÄ% &
ERROR
ÄÄ& +
:
ÄÄ+ ,
this
ÅÅ 
.
ÅÅ 
Error
ÅÅ 
(
ÅÅ 
format
ÅÅ %
,
ÅÅ% &
	arguments
ÅÅ' 0
)
ÅÅ0 1
;
ÅÅ1 2
break
ÇÇ 
;
ÇÇ 
default
ÉÉ 
:
ÉÉ 
throw
ÑÑ 
new
ÑÑ )
ArgumentOutOfRangeException
ÑÑ 9
(
ÑÑ9 :
)
ÑÑ: ;
;
ÑÑ; <
}
ÖÖ 
}
ÜÜ 	
public
àà 
override
àà 
string
àà 
ToString
àà '
(
àà' (
)
àà( )
=>
àà* ,
this
àà- 1
.
àà1 2
GetType
àà2 9
(
àà9 :
)
àà: ;
.
àà; <
Name
àà< @
+
ààA B
$char
ààC F
+
ààG H
this
ààI M
.
ààM N
Name
ààN R
+
ààS T
$char
ààU X
;
ààX Y
}
ââ 
}ää Õs
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\DefaultEventSource.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
[		 
EventSource		 
(		 
Name

 
=

 
$str

 !
,

! "
Guid 
= 
$str 5
)5 6
]6 7
public 

sealed 
class 
DefaultEventSource *
:+ ,
EventSource- 8
{ 
const 
int 
TraceEventId 
=  
$num! "
;" #
const 
int 
DebugEventId 
=  
$num! "
;" #
const 
int 
InfoEventId 
= 
$num  !
;! "
const 
int 
WarningEventId  
=! "
$num# $
;$ %
const 
int 
ErrorEventId 
=  
$num! "
;" #
public 
class 
Keywords 
{ 	
public 
const 
EventKeywords &
TraceEventKeyword' 8
=9 :
(; <
EventKeywords< I
)I J
$numJ K
;K L
public 
const 
EventKeywords &
DebugEventKeyword' 8
=9 :
(; <
EventKeywords< I
)I J
(J K
$numK L
<<M O
$numP Q
)Q R
;R S
} 	
public 
static 
readonly 
DefaultEventSource 1
Log2 5
=6 7
new8 ;
DefaultEventSource< N
(N O
)O P
;P Q
DefaultEventSource 
( 
) 
{ 	
} 	
public   
bool   
IsTraceEnabled   "
=>  # %
this  & *
.  * +
	IsEnabled  + 4
(  4 5

EventLevel  5 ?
.  ? @
Verbose  @ G
,  G H
Keywords  I Q
.  Q R
TraceEventKeyword  R c
)  c d
;  d e
public"" 
bool"" 
IsDebugEnabled"" "
=>""# %
this""& *
.""* +
	IsEnabled""+ 4
(""4 5

EventLevel""5 ?
.""? @
Verbose""@ G
,""G H
Keywords""I Q
.""Q R
DebugEventKeyword""R c
)""c d
;""d e
public$$ 
bool$$ 
IsInfoEnabled$$ !
=>$$" $
this$$% )
.$$) *
	IsEnabled$$* 3
($$3 4

EventLevel$$4 >
.$$> ?
Informational$$? L
,$$L M
EventKeywords$$N [
.$$[ \
None$$\ `
)$$` a
;$$a b
public&& 
bool&& 
IsWarningEnabled&& $
=>&&% '
this&&( ,
.&&, -
	IsEnabled&&- 6
(&&6 7

EventLevel&&7 A
.&&A B
Warning&&B I
,&&I J
EventKeywords&&K X
.&&X Y
None&&Y ]
)&&] ^
;&&^ _
public(( 
bool(( 
IsErrorEnabled(( "
=>((# %
this((& *
.((* +
	IsEnabled((+ 4
(((4 5

EventLevel((5 ?
.((? @
Error((@ E
,((E F
EventKeywords((G T
.((T U
None((U Y
)((Y Z
;((Z [
[** 	
NonEvent**	 
]** 
public++ 
void++ 
Trace++ 
(++ 
string++  
source++! '
,++' (
string++) /
message++0 7
)++7 8
=>++9 ;
this++< @
.++@ A
Trace++A F
(++F G
source++G M
,++M N
message++O V
,++V W
string++X ^
.++^ _
Empty++_ d
)++d e
;++e f
[-- 	
NonEvent--	 
]-- 
public.. 
void.. 
Trace.. 
(.. 
string..  
source..! '
,..' (
string..) /
message..0 7
,..7 8
	Exception..9 B
	exception..C L
)..L M
{// 	
if00 
(00 
this00 
.00 
IsTraceEnabled00 #
)00# $
{11 
this22 
.22 
Trace22 
(22 
source22 !
,22! "
message22# *
,22* +
	exception22, 5
?225 6
.226 7
ToString227 ?
(22? @
)22@ A
??22B D
string22E K
.22K L
Empty22L Q
)22Q R
;22R S
}33 
}44 	
[66 	
Event66	 
(66 
TraceEventId66 
,66 
Level66 "
=66# $

EventLevel66% /
.66/ 0
Verbose660 7
,667 8
Keywords669 A
=66B C
Keywords66D L
.66L M
TraceEventKeyword66M ^
)66^ _
]66_ `
public77 
void77 
Trace77 
(77 
string77  
source77! '
,77' (
string77) /
message770 7
,777 8
string779 ?
info77@ D
)77D E
{88 	
if99 
(99 
this99 
.99 
IsTraceEnabled99 #
)99# $
{:: 
this;; 
.;; 

WriteEvent;; 
(;;  
TraceEventId;;  ,
,;;, -
source;;. 4
,;;4 5
message;;6 =
,;;= >
info;;? C
);;C D
;;;D E
}<< 
}== 	
[?? 	
NonEvent??	 
]?? 
public@@ 
void@@ 
Debug@@ 
(@@ 
string@@  
source@@! '
,@@' (
string@@) /
message@@0 7
)@@7 8
=>@@9 ;
this@@< @
.@@@ A
Debug@@A F
(@@F G
source@@G M
,@@M N
message@@O V
,@@V W
string@@X ^
.@@^ _
Empty@@_ d
)@@d e
;@@e f
[BB 	
NonEventBB	 
]BB 
publicCC 
voidCC 
DebugCC 
(CC 
stringCC  
sourceCC! '
,CC' (
stringCC) /
messageCC0 7
,CC7 8
	ExceptionCC9 B
	exceptionCCC L
)CCL M
{DD 	
ifEE 
(EE 
thisEE 
.EE 
IsDebugEnabledEE #
)EE# $
{FF 
thisGG 
.GG 
DebugGG 
(GG 
sourceGG !
,GG! "
messageGG# *
,GG* +
	exceptionGG, 5
?GG5 6
.GG6 7
ToStringGG7 ?
(GG? @
)GG@ A
??GGB D
stringGGE K
.GGK L
EmptyGGL Q
)GGQ R
;GGR S
}HH 
}II 	
[KK 	
EventKK	 
(KK 
DebugEventIdKK 
,KK 
LevelKK "
=KK# $

EventLevelKK% /
.KK/ 0
VerboseKK0 7
,KK7 8
KeywordsKK9 A
=KKB C
KeywordsKKD L
.KKL M
DebugEventKeywordKKM ^
)KK^ _
]KK_ `
publicLL 
voidLL 
DebugLL 
(LL 
stringLL  
sourceLL! '
,LL' (
stringLL) /
messageLL0 7
,LL7 8
stringLL9 ?
infoLL@ D
)LLD E
{MM 	
ifNN 
(NN 
thisNN 
.NN 
IsDebugEnabledNN #
)NN# $
{OO 
thisPP 
.PP 

WriteEventPP 
(PP  
DebugEventIdPP  ,
,PP, -
sourcePP. 4
,PP4 5
messagePP6 =
,PP= >
infoPP? C
)PPC D
;PPD E
}QQ 
}RR 	
[TT 	
NonEventTT	 
]TT 
publicUU 
voidUU 
InfoUU 
(UU 
stringUU 
sourceUU  &
,UU& '
stringUU( .
messageUU/ 6
)UU6 7
=>UU8 :
thisUU; ?
.UU? @
InfoUU@ D
(UUD E
sourceUUE K
,UUK L
messageUUM T
,UUT U
stringUUV \
.UU\ ]
EmptyUU] b
)UUb c
;UUc d
[WW 	
NonEventWW	 
]WW 
publicXX 
voidXX 
InfoXX 
(XX 
stringXX 
sourceXX  &
,XX& '
stringXX( .
messageXX/ 6
,XX6 7
	ExceptionXX8 A
	exceptionXXB K
)XXK L
{YY 	
ifZZ 
(ZZ 
thisZZ 
.ZZ 
IsInfoEnabledZZ "
)ZZ" #
{[[ 
this\\ 
.\\ 
Info\\ 
(\\ 
source\\  
,\\  !
message\\" )
,\\) *
	exception\\+ 4
?\\4 5
.\\5 6
ToString\\6 >
(\\> ?
)\\? @
??\\A C
string\\D J
.\\J K
Empty\\K P
)\\P Q
;\\Q R
}]] 
}^^ 	
[`` 	
Event``	 
(`` 
InfoEventId`` 
,`` 
Level`` !
=``" #

EventLevel``$ .
.``. /
Informational``/ <
)``< =
]``= >
publicaa 
voidaa 
Infoaa 
(aa 
stringaa 
sourceaa  &
,aa& '
stringaa( .
messageaa/ 6
,aa6 7
stringaa8 >
infoaa? C
)aaC D
{bb 	
ifcc 
(cc 
thiscc 
.cc 
IsInfoEnabledcc "
)cc" #
{dd 
thisee 
.ee 

WriteEventee 
(ee  
InfoEventIdee  +
,ee+ ,
sourceee- 3
,ee3 4
messageee5 <
,ee< =
infoee> B
)eeB C
;eeC D
}ff 
}gg 	
[ii 	
NonEventii	 
]ii 
publicjj 
voidjj 
Warningjj 
(jj 
stringjj "
sourcejj# )
,jj) *
stringjj+ 1
messagejj2 9
)jj9 :
=>jj; =
thisjj> B
.jjB C
WarningjjC J
(jjJ K
sourcejjK Q
,jjQ R
messagejjS Z
,jjZ [
stringjj\ b
.jjb c
Emptyjjc h
)jjh i
;jji j
[ll 	
NonEventll	 
]ll 
publicmm 
voidmm 
Warningmm 
(mm 
stringmm "
sourcemm# )
,mm) *
stringmm+ 1
messagemm2 9
,mm9 :
	Exceptionmm; D
	exceptionmmE N
)mmN O
{nn 	
ifoo 
(oo 
thisoo 
.oo 
IsWarningEnabledoo %
)oo% &
{pp 
thisqq 
.qq 
Warningqq 
(qq 
sourceqq #
,qq# $
messageqq% ,
,qq, -
	exceptionqq. 7
?qq7 8
.qq8 9
ToStringqq9 A
(qqA B
)qqB C
??qqD F
stringqqG M
.qqM N
EmptyqqN S
)qqS T
;qqT U
}rr 
}ss 	
[uu 	
Eventuu	 
(uu 
WarningEventIduu 
,uu 
Leveluu $
=uu% &

EventLeveluu' 1
.uu1 2
Warninguu2 9
)uu9 :
]uu: ;
publicvv 
voidvv 
Warningvv 
(vv 
stringvv "
sourcevv# )
,vv) *
stringvv+ 1
messagevv2 9
,vv9 :
stringvv; A
	exceptionvvB K
)vvK L
{ww 	
ifxx 
(xx 
thisxx 
.xx 
IsWarningEnabledxx %
)xx% &
{yy 
thiszz 
.zz 

WriteEventzz 
(zz  
WarningEventIdzz  .
,zz. /
sourcezz0 6
,zz6 7
messagezz8 ?
,zz? @
	exceptionzzA J
)zzJ K
;zzK L
}{{ 
}|| 	
[~~ 	
NonEvent~~	 
]~~ 
public 
void 
Error 
( 
string  
source! '
,' (
string) /
message0 7
)7 8
=>9 ;
this< @
.@ A
ErrorA F
(F G
sourceG M
,M N
messageO V
,V W
stringX ^
.^ _
Empty_ d
)d e
;e f
[
ÅÅ 	
NonEvent
ÅÅ	 
]
ÅÅ 
public
ÇÇ 
void
ÇÇ 
Error
ÇÇ 
(
ÇÇ 
string
ÇÇ  
source
ÇÇ! '
,
ÇÇ' (
string
ÇÇ) /
message
ÇÇ0 7
,
ÇÇ7 8
	Exception
ÇÇ9 B
	exception
ÇÇC L
)
ÇÇL M
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ 
this
ÑÑ 
.
ÑÑ 
IsErrorEnabled
ÑÑ #
)
ÑÑ# $
{
ÖÖ 
this
ÜÜ 
.
ÜÜ 
Error
ÜÜ 
(
ÜÜ 
source
ÜÜ !
,
ÜÜ! "
message
ÜÜ# *
,
ÜÜ* +
	exception
ÜÜ, 5
?
ÜÜ5 6
.
ÜÜ6 7
ToString
ÜÜ7 ?
(
ÜÜ? @
)
ÜÜ@ A
??
ÜÜB D
string
ÜÜE K
.
ÜÜK L
Empty
ÜÜL Q
)
ÜÜQ R
;
ÜÜR S
}
áá 
}
àà 	
[
ää 	
Event
ää	 
(
ää 
ErrorEventId
ää 
,
ää 
Level
ää "
=
ää# $

EventLevel
ää% /
.
ää/ 0
Error
ää0 5
)
ää5 6
]
ää6 7
public
ãã 
void
ãã 
Error
ãã 
(
ãã 
string
ãã  
source
ãã! '
,
ãã' (
string
ãã) /
message
ãã0 7
,
ãã7 8
string
ãã9 ?
	exception
ãã@ I
)
ããI J
{
åå 	
if
çç 
(
çç 
this
çç 
.
çç 
IsErrorEnabled
çç #
)
çç# $
{
éé 
this
èè 
.
èè 

WriteEvent
èè 
(
èè  
ErrorEventId
èè  ,
,
èè, -
source
èè. 4
,
èè4 5
message
èè6 =
,
èè= >
	exception
èè? H
)
èèH I
;
èèI J
}
êê 
}
ëë 	
}
íí 
}ìì à<
tC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\EventSourceLogger.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
sealed		 

class		 
EventSourceLogger		 "
:		# $
ILogger		% ,
{

 
readonly 
string 
name 
; 
public 
EventSourceLogger  
(  !
string! '
name( ,
), -
{ 	
this 
. 
name 
= 
name 
; 
} 	
public 
void 
Log 
< 
TState 
> 
(  
LogLevel  (
logLevel) 1
,1 2
EventId3 :
eventId; B
,B C
TStateD J
stateK P
,P Q
	ExceptionR [
	exception\ e
,e f
Funcg k
<k l
TStatel r
,r s
	Exceptiont }
,} ~
string	 Ö
>
Ö Ü
	formatter
á ê
)
ê ë
{ 	
switch 
( 
logLevel 
) 
{ 
case 
LogLevel 
. 
Trace #
:# $
DefaultEventSource &
.& '
Log' *
.* +
Trace+ 0
(0 1
this1 5
.5 6
name6 :
,: ;
	formatter< E
(E F
stateF K
,K L
	exceptionM V
)V W
,W X
	exceptionY b
)b c
;c d
break 
; 
case 
LogLevel 
. 
Debug #
:# $
DefaultEventSource &
.& '
Log' *
.* +
Debug+ 0
(0 1
this1 5
.5 6
name6 :
,: ;
	formatter< E
(E F
stateF K
,K L
	exceptionM V
)V W
,W X
	exceptionY b
)b c
;c d
break 
; 
case 
LogLevel 
. 
Information )
:) *
DefaultEventSource &
.& '
Log' *
.* +
Info+ /
(/ 0
this0 4
.4 5
name5 9
,9 :
	formatter; D
(D E
stateE J
,J K
	exceptionL U
)U V
,V W
	exceptionX a
)a b
;b c
break 
; 
case 
LogLevel 
. 
Warning %
:% &
DefaultEventSource   &
.  & '
Log  ' *
.  * +
Warning  + 2
(  2 3
this  3 7
.  7 8
name  8 <
,  < =
	formatter  > G
(  G H
state  H M
,  M N
	exception  O X
)  X Y
,  Y Z
	exception  [ d
)  d e
;  e f
break!! 
;!! 
case"" 
LogLevel"" 
."" 
Error"" #
:""# $
DefaultEventSource## &
.##& '
Log##' *
.##* +
Error##+ 0
(##0 1
this##1 5
.##5 6
name##6 :
,##: ;
	formatter##< E
(##E F
state##F K
,##K L
	exception##M V
)##V W
,##W X
	exception##Y b
)##b c
;##c d
break$$ 
;$$ 
case%% 
LogLevel%% 
.%% 
Critical%% &
:%%& '
DefaultEventSource&& &
.&&& '
Log&&' *
.&&* +
Error&&+ 0
(&&0 1
this&&1 5
.&&5 6
name&&6 :
,&&: ;
	formatter&&< E
(&&E F
state&&F K
,&&K L
	exception&&M V
)&&V W
,&&W X
	exception&&Y b
)&&b c
;&&c d
break'' 
;'' 
case(( 
LogLevel(( 
.(( 
None(( "
:((" #
break)) 
;)) 
default** 
:** 
throw++ 
new++ '
ArgumentOutOfRangeException++ 9
(++9 :
nameof++: @
(++@ A
logLevel++A I
)++I J
,++J K
logLevel++L T
,++T U
null++V Z
)++Z [
;++[ \
},, 
}-- 	
public// 
bool// 
	IsEnabled// 
(// 
LogLevel// &
logLevel//' /
)/// 0
{00 	
switch11 
(11 
logLevel11 
)11 
{22 
case33 
LogLevel33 
.33 
Trace33 #
:33# $
return44 
DefaultEventSource44 -
.44- .
Log44. 1
.441 2
IsTraceEnabled442 @
;44@ A
case55 
LogLevel55 
.55 
Debug55 #
:55# $
return66 
DefaultEventSource66 -
.66- .
Log66. 1
.661 2
IsDebugEnabled662 @
;66@ A
case77 
LogLevel77 
.77 
Information77 )
:77) *
return88 
DefaultEventSource88 -
.88- .
Log88. 1
.881 2
IsInfoEnabled882 ?
;88? @
case99 
LogLevel99 
.99 
Warning99 %
:99% &
return:: 
DefaultEventSource:: -
.::- .
Log::. 1
.::1 2
IsWarningEnabled::2 B
;::B C
case;; 
LogLevel;; 
.;; 
Error;; #
:;;# $
return<< 
DefaultEventSource<< -
.<<- .
Log<<. 1
.<<1 2
IsErrorEnabled<<2 @
;<<@ A
case== 
LogLevel== 
.== 
Critical== &
:==& '
return>> 
DefaultEventSource>> -
.>>- .
Log>>. 1
.>>1 2
IsErrorEnabled>>2 @
;>>@ A
case?? 
LogLevel?? 
.?? 
None?? "
:??" #
return@@ 
true@@ 
;@@  
defaultAA 
:AA 
throwBB 
newBB '
ArgumentOutOfRangeExceptionBB 9
(BB9 :
nameofBB: @
(BB@ A
logLevelBBA I
)BBI J
,BBJ K
logLevelBBL T
,BBT U
nullBBV Z
)BBZ [
;BB[ \
}CC 
}DD 	
publicFF 
IDisposableFF 

BeginScopeFF %
<FF% &
TStateFF& ,
>FF, -
(FF- .
TStateFF. 4
stateFF5 :
)FF: ;
=>FF< >
NoOpDisposableFF? M
.FFM N
InstanceFFN V
;FFV W
sealedHH 
classHH 
NoOpDisposableHH #
:HH$ %
IDisposableHH& 1
{II 	
publicJJ 
staticJJ 
readonlyJJ "
NoOpDisposableJJ# 1
InstanceJJ2 :
=JJ; <
newJJ= @
NoOpDisposableJJA O
(JJO P
)JJP Q
;JJQ R
NoOpDisposableLL 
(LL 
)LL 
{MM 
}NN 
publicPP 
voidPP 
DisposePP 
(PP  
)PP  !
{QQ 
}RR 
}SS 	
}TT 
}UU Ë
|C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\EventSourceLoggerProvider.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public 

sealed 
class %
EventSourceLoggerProvider 1
:2 3
ILoggerProvider4 C
{		 
public

 
void

 
Dispose

 
(

 
)

 
{ 	
} 	
public 
ILogger 
CreateLogger #
(# $
string$ *
categoryName+ 7
)7 8
=>9 ;
new< ?
EventSourceLogger@ Q
(Q R
categoryNameR ^
)^ _
;_ `
} 
} Ó
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\FormattingTuple.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public 

struct 
FormattingTuple !
{ 
static 
readonly 
FormattingTuple '
NULL( ,
=- .
new/ 2
FormattingTuple3 B
(B C
nullC G
)G H
;H I
public 
FormattingTuple 
( 
string %
message& -
)- .
: 
this 
( 
message 
, 
null  
,  !
null" &
)& '
{ 	
} 	
public 
FormattingTuple 
( 
string %
message& -
,- .
object/ 5
[5 6
]6 7
argArray8 @
,@ A
	ExceptionB K
	exceptionL U
)U V
{ 	
this 
. 
Message 
= 
message "
;" #
this 
. 
	Exception 
= 
	exception &
;& '
if 
( 
	exception 
== 
null !
)! "
{ 
this 
. 
ArgArray 
= 
argArray  (
;( )
} 
else 
{ 
this 
. 
ArgArray 
= 
GetTrimmedCopy  .
(. /
argArray/ 7
)7 8
;8 9
}   
}!! 	
static## 
object## 
[## 
]## 
GetTrimmedCopy## &
(##& '
object##' -
[##- .
]##. /
argArray##0 8
)##8 9
{$$ 	
Contract%% 
.%% 
Requires%% 
(%% 
argArray%% &
!=%%' )
null%%* .
&&%%/ 1
argArray%%2 :
.%%: ;
Length%%; A
>%%B C
$num%%D E
)%%E F
;%%F G
int'' 

trimemdLen'' 
='' 
argArray'' %
.''% &
Length''& ,
-''- .
$num''/ 0
;''0 1
var(( 
trimmed(( 
=(( 
new(( 
object(( $
[(($ %

trimemdLen((% /
]((/ 0
;((0 1
Array)) 
.)) 
Copy)) 
()) 
argArray)) 
,))  
$num))! "
,))" #
trimmed))$ +
,))+ ,
$num))- .
,)). /

trimemdLen))0 :
))): ;
;)); <
return** 
trimmed** 
;** 
}++ 	
public-- 
string-- 
Message-- 
{-- 
get--  #
;--# $
private--% ,
set--- 0
;--0 1
}--2 3
public// 
object// 
[// 
]// 
ArgArray//  
{//! "
get//# &
;//& '
private//( /
set//0 3
;//3 4
}//5 6
public11 
	Exception11 
	Exception11 "
{11# $
get11% (
;11( )
private11* 1
set112 5
;115 6
}117 8
}22 
}33 ûø
pC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\GenericLogger.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
sealed		 

class		 
GenericLogger		 
:		  "
AbstractInternalLogger		! 7
{

 
static 
readonly 
Func 
< 
string #
,# $
	Exception% .
,. /
string0 6
>6 7 
MessageFormatterFunc8 L
=M N
(O P
sP Q
,Q R
eS T
)T U
=>V X
sY Z
;Z [
readonly 
ILogger 
logger 
;  
public 
GenericLogger 
( 
string #
name$ (
,( )
ILogger* 1
logger2 8
)8 9
: 
base 
( 
name 
) 
{ 	
this 
. 
logger 
= 
logger  
;  !
} 	
public 
override 
bool 
TraceEnabled )
=>* ,
this- 1
.1 2
logger2 8
.8 9
	IsEnabled9 B
(B C
LogLevelC K
.K L
TraceL Q
)Q R
;R S
public 
override 
void 
Trace "
(" #
string# )
msg* -
)- .
=>/ 1
this2 6
.6 7
logger7 =
.= >
Log> A
(A B
LogLevelB J
.J K
TraceK P
,P Q
$numR S
,S T
msgU X
,X Y
nullZ ^
,^ _ 
MessageFormatterFunc` t
)t u
;u v
public 
override 
void 
Trace "
(" #
string# )
format* 0
,0 1
object2 8
arg9 <
)< =
{ 	
if 
( 
this 
. 
TraceEnabled !
)! "
{ 
FormattingTuple 
ft  "
=# $
MessageFormatter% 5
.5 6
Format6 <
(< =
format= C
,C D
argE H
)H I
;I J
this 
. 
logger 
. 
Log 
(  
LogLevel  (
.( )
Trace) .
,. /
$num0 1
,1 2
ft3 5
.5 6
Message6 =
,= >
ft? A
.A B
	ExceptionB K
,K L 
MessageFormatterFuncM a
)a b
;b c
} 
} 	
public!! 
override!! 
void!! 
Trace!! "
(!!" #
string!!# )
format!!* 0
,!!0 1
object!!2 8
argA!!9 =
,!!= >
object!!? E
argB!!F J
)!!J K
{"" 	
if## 
(## 
this## 
.## 
TraceEnabled## !
)##! "
{$$ 
FormattingTuple%% 
ft%%  "
=%%# $
MessageFormatter%%% 5
.%%5 6
Format%%6 <
(%%< =
format%%= C
,%%C D
argA%%E I
,%%I J
argB%%K O
)%%O P
;%%P Q
this&& 
.&& 
logger&& 
.&& 
Log&& 
(&&  
LogLevel&&  (
.&&( )
Trace&&) .
,&&. /
$num&&0 1
,&&1 2
ft&&3 5
.&&5 6
Message&&6 =
,&&= >
ft&&? A
.&&A B
	Exception&&B K
,&&K L 
MessageFormatterFunc&&M a
)&&a b
;&&b c
}'' 
}(( 	
public** 
override** 
void** 
Trace** "
(**" #
string**# )
format*** 0
,**0 1
params**2 8
object**9 ?
[**? @
]**@ A
	arguments**B K
)**K L
{++ 	
if,, 
(,, 
this,, 
.,, 
TraceEnabled,, !
),,! "
{-- 
FormattingTuple.. 
ft..  "
=..# $
MessageFormatter..% 5
...5 6
ArrayFormat..6 A
(..A B
format..B H
,..H I
	arguments..J S
)..S T
;..T U
this// 
.// 
logger// 
.// 
Log// 
(//  
LogLevel//  (
.//( )
Trace//) .
,//. /
$num//0 1
,//1 2
ft//3 5
.//5 6
Message//6 =
,//= >
ft//? A
.//A B
	Exception//B K
,//K L 
MessageFormatterFunc//M a
)//a b
;//b c
}00 
}11 	
public33 
override33 
void33 
Trace33 "
(33" #
string33# )
msg33* -
,33- .
	Exception33/ 8
t339 :
)33: ;
=>33< >
this33? C
.33C D
logger33D J
.33J K
Log33K N
(33N O
LogLevel33O W
.33W X
Trace33X ]
,33] ^
$num33_ `
,33` a
msg33b e
,33e f
t33g h
,33h i 
MessageFormatterFunc33j ~
)33~ 
;	33 Ä
public55 
override55 
bool55 
DebugEnabled55 )
=>55* ,
this55- 1
.551 2
logger552 8
.558 9
	IsEnabled559 B
(55B C
LogLevel55C K
.55K L
Debug55L Q
)55Q R
;55R S
public77 
override77 
void77 
Debug77 "
(77" #
string77# )
msg77* -
)77- .
=>77/ 1
this772 6
.776 7
logger777 =
.77= >
Log77> A
(77A B
LogLevel77B J
.77J K
Debug77K P
,77P Q
$num77R S
,77S T
msg77U X
,77X Y
null77Z ^
,77^ _ 
MessageFormatterFunc77` t
)77t u
;77u v
public99 
override99 
void99 
Debug99 "
(99" #
string99# )
format99* 0
,990 1
object992 8
arg999 <
)99< =
{:: 	
if;; 
(;; 
this;; 
.;; 
DebugEnabled;; !
);;! "
{<< 
FormattingTuple== 
ft==  "
===# $
MessageFormatter==% 5
.==5 6
Format==6 <
(==< =
format=== C
,==C D
arg==E H
)==H I
;==I J
this>> 
.>> 
logger>> 
.>> 
Log>> 
(>>  
LogLevel>>  (
.>>( )
Debug>>) .
,>>. /
$num>>0 1
,>>1 2
ft>>3 5
.>>5 6
Message>>6 =
,>>= >
ft>>? A
.>>A B
	Exception>>B K
,>>K L 
MessageFormatterFunc>>M a
)>>a b
;>>b c
}?? 
}@@ 	
publicBB 
overrideBB 
voidBB 
DebugBB "
(BB" #
stringBB# )
formatBB* 0
,BB0 1
objectBB2 8
argABB9 =
,BB= >
objectBB? E
argBBBF J
)BBJ K
{CC 	
ifDD 
(DD 
thisDD 
.DD 
DebugEnabledDD !
)DD! "
{EE 
FormattingTupleFF 
ftFF  "
=FF# $
MessageFormatterFF% 5
.FF5 6
FormatFF6 <
(FF< =
formatFF= C
,FFC D
argAFFE I
,FFI J
argBFFK O
)FFO P
;FFP Q
thisGG 
.GG 
loggerGG 
.GG 
LogGG 
(GG  
LogLevelGG  (
.GG( )
DebugGG) .
,GG. /
$numGG0 1
,GG1 2
ftGG3 5
.GG5 6
MessageGG6 =
,GG= >
ftGG? A
.GGA B
	ExceptionGGB K
,GGK L 
MessageFormatterFuncGGM a
)GGa b
;GGb c
}HH 
}II 	
publicKK 
overrideKK 
voidKK 
DebugKK "
(KK" #
stringKK# )
formatKK* 0
,KK0 1
paramsKK2 8
objectKK9 ?
[KK? @
]KK@ A
	argumentsKKB K
)KKK L
{LL 	
ifMM 
(MM 
thisMM 
.MM 
DebugEnabledMM !
)MM! "
{NN 
FormattingTupleOO 
ftOO  "
=OO# $
MessageFormatterOO% 5
.OO5 6
ArrayFormatOO6 A
(OOA B
formatOOB H
,OOH I
	argumentsOOJ S
)OOS T
;OOT U
thisPP 
.PP 
loggerPP 
.PP 
LogPP 
(PP  
LogLevelPP  (
.PP( )
DebugPP) .
,PP. /
$numPP0 1
,PP1 2
ftPP3 5
.PP5 6
MessagePP6 =
,PP= >
ftPP? A
.PPA B
	ExceptionPPB K
,PPK L 
MessageFormatterFuncPPM a
)PPa b
;PPb c
}QQ 
}RR 	
publicTT 
overrideTT 
voidTT 
DebugTT "
(TT" #
stringTT# )
msgTT* -
,TT- .
	ExceptionTT/ 8
tTT9 :
)TT: ;
=>TT< >
thisTT? C
.TTC D
loggerTTD J
.TTJ K
LogTTK N
(TTN O
LogLevelTTO W
.TTW X
DebugTTX ]
,TT] ^
$numTT_ `
,TT` a
msgTTb e
,TTe f
tTTg h
,TTh i 
MessageFormatterFuncTTj ~
)TT~ 
;	TT Ä
publicVV 
overrideVV 
boolVV 
InfoEnabledVV (
=>VV) +
thisVV, 0
.VV0 1
loggerVV1 7
.VV7 8
	IsEnabledVV8 A
(VVA B
LogLevelVVB J
.VVJ K
InformationVVK V
)VVV W
;VVW X
publicXX 
overrideXX 
voidXX 
InfoXX !
(XX! "
stringXX" (
msgXX) ,
)XX, -
=>XX. 0
thisXX1 5
.XX5 6
loggerXX6 <
.XX< =
LogXX= @
(XX@ A
LogLevelXXA I
.XXI J
InformationXXJ U
,XXU V
$numXXW X
,XXX Y
msgXXZ ]
,XX] ^
nullXX_ c
,XXc d 
MessageFormatterFuncXXe y
)XXy z
;XXz {
publicZZ 
overrideZZ 
voidZZ 
InfoZZ !
(ZZ! "
stringZZ" (
formatZZ) /
,ZZ/ 0
objectZZ1 7
argZZ8 ;
)ZZ; <
{[[ 	
if\\ 
(\\ 
this\\ 
.\\ 
InfoEnabled\\  
)\\  !
{]] 
FormattingTuple^^ 
ft^^  "
=^^# $
MessageFormatter^^% 5
.^^5 6
Format^^6 <
(^^< =
format^^= C
,^^C D
arg^^E H
)^^H I
;^^I J
this__ 
.__ 
logger__ 
.__ 
Log__ 
(__  
LogLevel__  (
.__( )
Information__) 4
,__4 5
$num__6 7
,__7 8
ft__9 ;
.__; <
Message__< C
,__C D
ft__E G
.__G H
	Exception__H Q
,__Q R 
MessageFormatterFunc__S g
)__g h
;__h i
}`` 
}aa 	
publiccc 
overridecc 
voidcc 
Infocc !
(cc! "
stringcc" (
formatcc) /
,cc/ 0
objectcc1 7
argAcc8 <
,cc< =
objectcc> D
argBccE I
)ccI J
{dd 	
ifee 
(ee 
thisee 
.ee 
InfoEnabledee  
)ee  !
{ff 
FormattingTuplegg 
ftgg  "
=gg# $
MessageFormattergg% 5
.gg5 6
Formatgg6 <
(gg< =
formatgg= C
,ggC D
argAggE I
,ggI J
argBggK O
)ggO P
;ggP Q
thishh 
.hh 
loggerhh 
.hh 
Loghh 
(hh  
LogLevelhh  (
.hh( )
Informationhh) 4
,hh4 5
$numhh6 7
,hh7 8
fthh9 ;
.hh; <
Messagehh< C
,hhC D
fthhE G
.hhG H
	ExceptionhhH Q
,hhQ R 
MessageFormatterFunchhS g
)hhg h
;hhh i
}ii 
}jj 	
publicll 
overridell 
voidll 
Infoll !
(ll! "
stringll" (
formatll) /
,ll/ 0
paramsll1 7
objectll8 >
[ll> ?
]ll? @
	argumentsllA J
)llJ K
{mm 	
ifnn 
(nn 
thisnn 
.nn 
InfoEnablednn  
)nn  !
{oo 
FormattingTuplepp 
ftpp  "
=pp# $
MessageFormatterpp% 5
.pp5 6
ArrayFormatpp6 A
(ppA B
formatppB H
,ppH I
	argumentsppJ S
)ppS T
;ppT U
thisqq 
.qq 
loggerqq 
.qq 
Logqq 
(qq  
LogLevelqq  (
.qq( )
Informationqq) 4
,qq4 5
$numqq6 7
,qq7 8
ftqq9 ;
.qq; <
Messageqq< C
,qqC D
ftqqE G
.qqG H
	ExceptionqqH Q
,qqQ R 
MessageFormatterFuncqqS g
)qqg h
;qqh i
}rr 
}ss 	
publicuu 
overrideuu 
voiduu 
Infouu !
(uu! "
stringuu" (
msguu) ,
,uu, -
	Exceptionuu. 7
tuu8 9
)uu9 :
=>uu; =
thisuu> B
.uuB C
loggeruuC I
.uuI J
LoguuJ M
(uuM N
LogLeveluuN V
.uuV W
InformationuuW b
,uub c
$numuud e
,uue f
msguug j
,uuj k
tuul m
,uum n!
MessageFormatterFunc	uuo É
)
uuÉ Ñ
;
uuÑ Ö
publicww 
overrideww 
boolww 
WarnEnabledww (
=>ww) +
thisww, 0
.ww0 1
loggerww1 7
.ww7 8
	IsEnabledww8 A
(wwA B
LogLevelwwB J
.wwJ K
WarningwwK R
)wwR S
;wwS T
publicyy 
overrideyy 
voidyy 
Warnyy !
(yy! "
stringyy" (
msgyy) ,
)yy, -
=>yy. 0
thisyy1 5
.yy5 6
loggeryy6 <
.yy< =
Logyy= @
(yy@ A
LogLevelyyA I
.yyI J
WarningyyJ Q
,yyQ R
$numyyS T
,yyT U
msgyyV Y
,yyY Z
nullyy[ _
,yy_ ` 
MessageFormatterFuncyya u
)yyu v
;yyv w
public{{ 
override{{ 
void{{ 
Warn{{ !
({{! "
string{{" (
format{{) /
,{{/ 0
object{{1 7
arg{{8 ;
){{; <
{|| 	
if}} 
(}} 
this}} 
.}} 
WarnEnabled}}  
)}}  !
{~~ 
FormattingTuple 
ft  "
=# $
MessageFormatter% 5
.5 6
Format6 <
(< =
format= C
,C D
argE H
)H I
;I J
this
ÄÄ 
.
ÄÄ 
logger
ÄÄ 
.
ÄÄ 
Log
ÄÄ 
(
ÄÄ  
LogLevel
ÄÄ  (
.
ÄÄ( )
Warning
ÄÄ) 0
,
ÄÄ0 1
$num
ÄÄ2 3
,
ÄÄ3 4
ft
ÄÄ5 7
.
ÄÄ7 8
Message
ÄÄ8 ?
,
ÄÄ? @
ft
ÄÄA C
.
ÄÄC D
	Exception
ÄÄD M
,
ÄÄM N"
MessageFormatterFunc
ÄÄO c
)
ÄÄc d
;
ÄÄd e
}
ÅÅ 
}
ÇÇ 	
public
ÑÑ 
override
ÑÑ 
void
ÑÑ 
Warn
ÑÑ !
(
ÑÑ! "
string
ÑÑ" (
format
ÑÑ) /
,
ÑÑ/ 0
object
ÑÑ1 7
argA
ÑÑ8 <
,
ÑÑ< =
object
ÑÑ> D
argB
ÑÑE I
)
ÑÑI J
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
this
ÜÜ 
.
ÜÜ 
WarnEnabled
ÜÜ  
)
ÜÜ  !
{
áá 
FormattingTuple
àà 
ft
àà  "
=
àà# $
MessageFormatter
àà% 5
.
àà5 6
Format
àà6 <
(
àà< =
format
àà= C
,
ààC D
argA
ààE I
,
ààI J
argB
ààK O
)
ààO P
;
ààP Q
this
ââ 
.
ââ 
logger
ââ 
.
ââ 
Log
ââ 
(
ââ  
LogLevel
ââ  (
.
ââ( )
Warning
ââ) 0
,
ââ0 1
$num
ââ2 3
,
ââ3 4
ft
ââ5 7
.
ââ7 8
Message
ââ8 ?
,
ââ? @
ft
ââA C
.
ââC D
	Exception
ââD M
,
ââM N"
MessageFormatterFunc
ââO c
)
ââc d
;
ââd e
}
ää 
}
ãã 	
public
çç 
override
çç 
void
çç 
Warn
çç !
(
çç! "
string
çç" (
format
çç) /
,
çç/ 0
params
çç1 7
object
çç8 >
[
çç> ?
]
çç? @
	arguments
ççA J
)
ççJ K
{
éé 	
if
èè 
(
èè 
this
èè 
.
èè 
WarnEnabled
èè  
)
èè  !
{
êê 
FormattingTuple
ëë 
ft
ëë  "
=
ëë# $
MessageFormatter
ëë% 5
.
ëë5 6
ArrayFormat
ëë6 A
(
ëëA B
format
ëëB H
,
ëëH I
	arguments
ëëJ S
)
ëëS T
;
ëëT U
this
íí 
.
íí 
logger
íí 
.
íí 
Log
íí 
(
íí  
LogLevel
íí  (
.
íí( )
Warning
íí) 0
,
íí0 1
$num
íí2 3
,
íí3 4
ft
íí5 7
.
íí7 8
Message
íí8 ?
,
íí? @
ft
ííA C
.
ííC D
	Exception
ííD M
,
ííM N"
MessageFormatterFunc
ííO c
)
ííc d
;
ííd e
}
ìì 
}
îî 	
public
ññ 
override
ññ 
void
ññ 
Warn
ññ !
(
ññ! "
string
ññ" (
msg
ññ) ,
,
ññ, -
	Exception
ññ. 7
t
ññ8 9
)
ññ9 :
=>
ññ; =
this
ññ> B
.
ññB C
logger
ññC I
.
ññI J
Log
ññJ M
(
ññM N
LogLevel
ññN V
.
ññV W
Warning
ññW ^
,
ññ^ _
$num
ññ` a
,
ñña b
msg
ññc f
,
ññf g
t
ññh i
,
ññi j"
MessageFormatterFunc
ññk 
)ññ Ä
;ññÄ Å
public
òò 
override
òò 
bool
òò 
ErrorEnabled
òò )
=>
òò* ,
this
òò- 1
.
òò1 2
logger
òò2 8
.
òò8 9
	IsEnabled
òò9 B
(
òòB C
LogLevel
òòC K
.
òòK L
Error
òòL Q
)
òòQ R
;
òòR S
public
öö 
override
öö 
void
öö 
Error
öö "
(
öö" #
string
öö# )
msg
öö* -
)
öö- .
=>
öö/ 1
this
öö2 6
.
öö6 7
logger
öö7 =
.
öö= >
Log
öö> A
(
ööA B
LogLevel
ööB J
.
ööJ K
Error
ööK P
,
ööP Q
$num
ööR S
,
ööS T
msg
ööU X
,
ööX Y
null
ööZ ^
,
öö^ _"
MessageFormatterFunc
öö` t
)
ööt u
;
ööu v
public
úú 
override
úú 
void
úú 
Error
úú "
(
úú" #
string
úú# )
format
úú* 0
,
úú0 1
object
úú2 8
arg
úú9 <
)
úú< =
{
ùù 	
if
ûû 
(
ûû 
this
ûû 
.
ûû 
ErrorEnabled
ûû !
)
ûû! "
{
üü 
FormattingTuple
†† 
ft
††  "
=
††# $
MessageFormatter
††% 5
.
††5 6
Format
††6 <
(
††< =
format
††= C
,
††C D
arg
††E H
)
††H I
;
††I J
this
°° 
.
°° 
logger
°° 
.
°° 
Log
°° 
(
°°  
LogLevel
°°  (
.
°°( )
Error
°°) .
,
°°. /
$num
°°0 1
,
°°1 2
ft
°°3 5
.
°°5 6
Message
°°6 =
,
°°= >
ft
°°? A
.
°°A B
	Exception
°°B K
,
°°K L"
MessageFormatterFunc
°°M a
)
°°a b
;
°°b c
}
¢¢ 
}
££ 	
public
•• 
override
•• 
void
•• 
Error
•• "
(
••" #
string
••# )
format
••* 0
,
••0 1
object
••2 8
argA
••9 =
,
••= >
object
••? E
argB
••F J
)
••J K
{
¶¶ 	
if
ßß 
(
ßß 
this
ßß 
.
ßß 
ErrorEnabled
ßß !
)
ßß! "
{
®® 
FormattingTuple
©© 
ft
©©  "
=
©©# $
MessageFormatter
©©% 5
.
©©5 6
Format
©©6 <
(
©©< =
format
©©= C
,
©©C D
argA
©©E I
,
©©I J
argB
©©K O
)
©©O P
;
©©P Q
this
™™ 
.
™™ 
logger
™™ 
.
™™ 
Log
™™ 
(
™™  
LogLevel
™™  (
.
™™( )
Error
™™) .
,
™™. /
$num
™™0 1
,
™™1 2
ft
™™3 5
.
™™5 6
Message
™™6 =
,
™™= >
ft
™™? A
.
™™A B
	Exception
™™B K
,
™™K L"
MessageFormatterFunc
™™M a
)
™™a b
;
™™b c
}
´´ 
}
¨¨ 	
public
ÆÆ 
override
ÆÆ 
void
ÆÆ 
Error
ÆÆ "
(
ÆÆ" #
string
ÆÆ# )
format
ÆÆ* 0
,
ÆÆ0 1
params
ÆÆ2 8
object
ÆÆ9 ?
[
ÆÆ? @
]
ÆÆ@ A
	arguments
ÆÆB K
)
ÆÆK L
{
ØØ 	
if
∞∞ 
(
∞∞ 
this
∞∞ 
.
∞∞ 
ErrorEnabled
∞∞ !
)
∞∞! "
{
±± 
FormattingTuple
≤≤ 
ft
≤≤  "
=
≤≤# $
MessageFormatter
≤≤% 5
.
≤≤5 6
ArrayFormat
≤≤6 A
(
≤≤A B
format
≤≤B H
,
≤≤H I
	arguments
≤≤J S
)
≤≤S T
;
≤≤T U
this
≥≥ 
.
≥≥ 
logger
≥≥ 
.
≥≥ 
Log
≥≥ 
(
≥≥  
LogLevel
≥≥  (
.
≥≥( )
Error
≥≥) .
,
≥≥. /
$num
≥≥0 1
,
≥≥1 2
ft
≥≥3 5
.
≥≥5 6
Message
≥≥6 =
,
≥≥= >
ft
≥≥? A
.
≥≥A B
	Exception
≥≥B K
,
≥≥K L"
MessageFormatterFunc
≥≥M a
)
≥≥a b
;
≥≥b c
}
¥¥ 
}
µµ 	
public
∑∑ 
override
∑∑ 
void
∑∑ 
Error
∑∑ "
(
∑∑" #
string
∑∑# )
msg
∑∑* -
,
∑∑- .
	Exception
∑∑/ 8
t
∑∑9 :
)
∑∑: ;
=>
∑∑< >
this
∑∑? C
.
∑∑C D
logger
∑∑D J
.
∑∑J K
Log
∑∑K N
(
∑∑N O
LogLevel
∑∑O W
.
∑∑W X
Error
∑∑X ]
,
∑∑] ^
$num
∑∑_ `
,
∑∑` a
msg
∑∑b e
,
∑∑e f
t
∑∑g h
,
∑∑h i"
MessageFormatterFunc
∑∑j ~
)
∑∑~ 
;∑∑ Ä
}
∏∏ 
}ππ ÷A
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\IInternalLogger.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public 

	interface 
IInternalLogger $
{ 
string 
Name 
{ 
get 
; 
} 
bool 
TraceEnabled 
{ 
get 
;  
}! "
void 
Trace 
( 
string 
msg 
) 
; 
void** 
Trace** 
(** 
string** 
format**  
,**  !
object**" (
arg**) ,
)**, -
;**- .
void77 
Trace77 
(77 
string77 
format77  
,77  !
object77" (
argA77) -
,77- .
object77/ 5
argB776 :
)77: ;
;77; <
voidHH 
TraceHH 
(HH 
stringHH 
formatHH  
,HH  !
paramsHH" (
objectHH) /
[HH/ 0
]HH0 1
	argumentsHH2 ;
)HH; <
;HH< =
voidOO 
TraceOO 
(OO 
stringOO 
msgOO 
,OO 
	ExceptionOO (
tOO) *
)OO* +
;OO+ ,
voidUU 
TraceUU 
(UU 
	ExceptionUU 
tUU 
)UU 
;UU  
bool[[ 
DebugEnabled[[ 
{[[ 
get[[ 
;[[  
}[[! "
voidaa 
Debugaa 
(aa 
stringaa 
msgaa 
)aa 
;aa 
voidmm 
Debugmm 
(mm 
stringmm 
formatmm  
,mm  !
objectmm" (
argmm) ,
)mm, -
;mm- .
voidzz 
Debugzz 
(zz 
stringzz 
formatzz  
,zz  !
objectzz" (
argAzz) -
,zz- .
objectzz/ 5
argBzz6 :
)zz: ;
;zz; <
void
ãã 
Debug
ãã 
(
ãã 
string
ãã 
format
ãã  
,
ãã  !
params
ãã" (
object
ãã) /
[
ãã/ 0
]
ãã0 1
	arguments
ãã2 ;
)
ãã; <
;
ãã< =
void
íí 
Debug
íí 
(
íí 
string
íí 
msg
íí 
,
íí 
	Exception
íí (
t
íí) *
)
íí* +
;
íí+ ,
void
òò 
Debug
òò 
(
òò 
	Exception
òò 
t
òò 
)
òò 
;
òò  
bool
ûû 
InfoEnabled
ûû 
{
ûû 
get
ûû 
;
ûû 
}
ûû  !
void
§§ 
Info
§§ 
(
§§ 
string
§§ 
msg
§§ 
)
§§ 
;
§§ 
void
∞∞ 
Info
∞∞ 
(
∞∞ 
string
∞∞ 
format
∞∞ 
,
∞∞  
object
∞∞! '
arg
∞∞( +
)
∞∞+ ,
;
∞∞, -
void
ΩΩ 
Info
ΩΩ 
(
ΩΩ 
string
ΩΩ 
format
ΩΩ 
,
ΩΩ  
object
ΩΩ! '
argA
ΩΩ( ,
,
ΩΩ, -
object
ΩΩ. 4
argB
ΩΩ5 9
)
ΩΩ9 :
;
ΩΩ: ;
void
ŒŒ 
Info
ŒŒ 
(
ŒŒ 
string
ŒŒ 
format
ŒŒ 
,
ŒŒ  
params
ŒŒ! '
object
ŒŒ( .
[
ŒŒ. /
]
ŒŒ/ 0
	arguments
ŒŒ1 :
)
ŒŒ: ;
;
ŒŒ; <
void
’’ 
Info
’’ 
(
’’ 
string
’’ 
msg
’’ 
,
’’ 
	Exception
’’ '
t
’’( )
)
’’) *
;
’’* +
void
€€ 
Info
€€ 
(
€€ 
	Exception
€€ 
t
€€ 
)
€€ 
;
€€ 
bool
·· 
WarnEnabled
·· 
{
·· 
get
·· 
;
·· 
}
··  !
void
ÁÁ 
Warn
ÁÁ 
(
ÁÁ 
string
ÁÁ 
msg
ÁÁ 
)
ÁÁ 
;
ÁÁ 
void
ÛÛ 
Warn
ÛÛ 
(
ÛÛ 
string
ÛÛ 
format
ÛÛ 
,
ÛÛ  
object
ÛÛ! '
arg
ÛÛ( +
)
ÛÛ+ ,
;
ÛÛ, -
void
ÑÑ 
Warn
ÑÑ 
(
ÑÑ 
string
ÑÑ 
format
ÑÑ 
,
ÑÑ  
params
ÑÑ! '
object
ÑÑ( .
[
ÑÑ. /
]
ÑÑ/ 0
	arguments
ÑÑ1 :
)
ÑÑ: ;
;
ÑÑ; <
void
ëë 
Warn
ëë 
(
ëë 
string
ëë 
format
ëë 
,
ëë  
object
ëë! '
argA
ëë( ,
,
ëë, -
object
ëë. 4
argB
ëë5 9
)
ëë9 :
;
ëë: ;
void
òò 
Warn
òò 
(
òò 
string
òò 
msg
òò 
,
òò 
	Exception
òò '
t
òò( )
)
òò) *
;
òò* +
void
ûû 
Warn
ûû 
(
ûû 
	Exception
ûû 
t
ûû 
)
ûû 
;
ûû 
bool
§§ 
ErrorEnabled
§§ 
{
§§ 
get
§§ 
;
§§  
}
§§! "
void
™™ 
Error
™™ 
(
™™ 
string
™™ 
msg
™™ 
)
™™ 
;
™™ 
void
∂∂ 
Error
∂∂ 
(
∂∂ 
string
∂∂ 
format
∂∂  
,
∂∂  !
object
∂∂" (
arg
∂∂) ,
)
∂∂, -
;
∂∂- .
void
√√ 
Error
√√ 
(
√√ 
string
√√ 
format
√√  
,
√√  !
object
√√" (
argA
√√) -
,
√√- .
object
√√/ 5
argB
√√6 :
)
√√: ;
;
√√; <
void
‘‘ 
Error
‘‘ 
(
‘‘ 
string
‘‘ 
format
‘‘  
,
‘‘  !
params
‘‘" (
object
‘‘) /
[
‘‘/ 0
]
‘‘0 1
	arguments
‘‘2 ;
)
‘‘; <
;
‘‘< =
void
€€ 
Error
€€ 
(
€€ 
string
€€ 
msg
€€ 
,
€€ 
	Exception
€€ (
t
€€) *
)
€€* +
;
€€+ ,
void
·· 
Error
·· 
(
·· 
	Exception
·· 
t
·· 
)
·· 
;
··  
bool
ËË 
	IsEnabled
ËË 
(
ËË 
InternalLogLevel
ËË '
level
ËË( -
)
ËË- .
;
ËË. /
void
ÔÔ 
Log
ÔÔ 
(
ÔÔ 
InternalLogLevel
ÔÔ !
level
ÔÔ" '
,
ÔÔ' (
string
ÔÔ) /
msg
ÔÔ0 3
)
ÔÔ3 4
;
ÔÔ4 5
void
¸¸ 
Log
¸¸ 
(
¸¸ 
InternalLogLevel
¸¸ !
level
¸¸" '
,
¸¸' (
string
¸¸) /
format
¸¸0 6
,
¸¸6 7
object
¸¸8 >
arg
¸¸? B
)
¸¸B C
;
¸¸C D
void
ää 
Log
ää 
(
ää 
InternalLogLevel
ää !
level
ää" '
,
ää' (
string
ää) /
format
ää0 6
,
ää6 7
object
ää8 >
argA
ää? C
,
ääC D
object
ääE K
argB
ääL P
)
ääP Q
;
ääQ R
void
úú 
Log
úú 
(
úú 
InternalLogLevel
úú !
level
úú" '
,
úú' (
string
úú) /
format
úú0 6
,
úú6 7
params
úú8 >
object
úú? E
[
úúE F
]
úúF G
	arguments
úúH Q
)
úúQ R
;
úúR S
void
•• 
Log
•• 
(
•• 
InternalLogLevel
•• !
level
••" '
,
••' (
string
••) /
msg
••0 3
,
••3 4
	Exception
••5 >
t
••? @
)
••@ A
;
••A B
void
¨¨ 
Log
¨¨ 
(
¨¨ 
InternalLogLevel
¨¨ !
level
¨¨" '
,
¨¨' (
	Exception
¨¨) 2
t
¨¨3 4
)
¨¨4 5
;
¨¨5 6
}
≠≠ 
}ÆÆ É
xC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\InternalLoggerFactory.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public 

static 
class !
InternalLoggerFactory -
{ 
static 
ILoggerFactory 
defaultFactory ,
;, -
static(( 
ILoggerFactory(( 
NewDefaultFactory(( /
(((/ 0
string((0 6
name((7 ;
)((; <
{)) 	
var** 
f** 
=** 
new** 
LoggerFactory** %
(**% &
)**& '
;**' (
f++ 
.++ 
AddProvider++ 
(++ 
new++ %
EventSourceLoggerProvider++ 7
(++7 8
)++8 9
)++9 :
;++: ;
f,, 
.,, 
CreateLogger,, 
(,, 
name,, 
),,  
.,,  !
LogDebug,,! )
(,,) *
$str,,* ^
),,^ _
;,,_ `
return-- 
f-- 
;-- 
}.. 	
public33 
static33 
ILoggerFactory33 $
DefaultFactory33% 3
{44 	
get55 
{66 
ILoggerFactory77 
factory77 &
=77' (
Volatile77) 1
.771 2
Read772 6
(776 7
ref777 :
defaultFactory77; I
)77I J
;77J K
if88 
(88 
factory88 
==88 
null88 #
)88# $
{99 
factory:: 
=:: 
NewDefaultFactory:: /
(::/ 0
typeof::0 6
(::6 7!
InternalLoggerFactory::7 L
)::L M
.::M N
FullName::N V
)::V W
;::W X
ILoggerFactory;; "
current;;# *
=;;+ ,
Interlocked;;- 8
.;;8 9
CompareExchange;;9 H
(;;H I
ref;;I L
defaultFactory;;M [
,;;[ \
factory;;] d
,;;d e
null;;f j
);;j k
;;;k l
if<< 
(<< 
current<< 
!=<<  "
null<<# '
)<<' (
{== 
return>> 
current>> &
;>>& '
}?? 
}@@ 
returnAA 
factoryAA 
;AA 
}BB 
setCC 
{DD 
ContractEE 
.EE 
RequiresEE !
(EE! "
valueEE" '
!=EE( *
nullEE+ /
)EE/ 0
;EE0 1
VolatileGG 
.GG 
WriteGG 
(GG 
refGG "
defaultFactoryGG# 1
,GG1 2
valueGG3 8
)GG8 9
;GG9 :
}HH 
}II 	
publicPP 
staticPP 
IInternalLoggerPP %
GetInstancePP& 1
<PP1 2
TPP2 3
>PP3 4
(PP4 5
)PP5 6
=>PP7 9
GetInstancePP: E
(PPE F
typeofPPF L
(PPL M
TPPM N
)PPN O
)PPO P
;PPP Q
publicWW 
staticWW 
IInternalLoggerWW %
GetInstanceWW& 1
(WW1 2
TypeWW2 6
typeWW7 ;
)WW; <
=>WW= ?
GetInstanceWW@ K
(WWK L
typeWWL P
.WWP Q
FullNameWWQ Y
)WWY Z
;WWZ [
public^^ 
static^^ 
IInternalLogger^^ %
GetInstance^^& 1
(^^1 2
string^^2 8
name^^9 =
)^^= >
=>^^? A
new^^B E
GenericLogger^^F S
(^^S T
name^^T X
,^^X Y
DefaultFactory^^Z h
.^^h i
CreateLogger^^i u
(^^u v
name^^v z
)^^z {
)^^{ |
;^^| }
}__ 
}`` °
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\InternalLogLevel.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public		 

enum		 
InternalLogLevel		  
{

 
TRACE 
, 
DEBUG 
, 
INFO 
, 
WARN 
, 
ERROR"" 
}## 
}$$ ¥Ù
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Logging\MessageFormatter.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
." #
Logging# *
{ 
public99 

static99 
class99 
MessageFormatter99 (
{:: 
static;; 
readonly;; 
char;; 
DELIM_START;; (
=;;) *
$char;;+ .
;;;. /
static<< 
readonly<< 
string<< 
	DELIM_STR<< (
=<<) *
$str<<+ /
;<</ 0
static== 
readonly== 
char== 
ESCAPE_CHAR== (
===) *
$char==+ /
;==/ 0
publicNN 
staticNN 
FormattingTupleNN %
FormatNN& ,
(NN, -
stringNN- 3
messagePatternNN4 B
,NNB C
objectNND J
argNNK N
)NNN O
=>NNP R
ArrayFormatNNS ^
(NN^ _
messagePatternNN_ m
,NNm n
newNNo r
[NNr s
]NNs t
{NNu v
argNNw z
}NN{ |
)NN| }
;NN} ~
public`` 
static`` 
FormattingTuple`` %
Format``& ,
(``, -
string``- 3
messagePattern``4 B
,``B C
object``D J
argA``K O
,``O P
object``Q W
argB``X \
)``\ ]
=>``^ `
ArrayFormat``a l
(``l m
messagePattern``m {
,``{ |
new	``} Ä
[
``Ä Å
]
``Å Ç
{
``É Ñ
argA
``Ö â
,
``â ä
argB
``ã è
}
``ê ë
)
``ë í
;
``í ì
publicbb 
staticbb 
	Exceptionbb !
GetThrowableCandidatebb  5
(bb5 6
objectbb6 <
[bb< =
]bb= >
argArraybb? G
)bbG H
{cc 	
ifdd 
(dd 
argArraydd 
==dd 
nulldd  
||dd! #
argArraydd$ ,
.dd, -
Lengthdd- 3
==dd4 6
$numdd7 8
)dd8 9
{ee 
returnff 
nullff 
;ff 
}gg 
returnii 
argArrayii 
[ii 
argArrayii $
.ii$ %
Lengthii% +
-ii, -
$numii. /
]ii/ 0
asii1 3
	Exceptionii4 =
;ii= >
}jj 	
publicss 
staticss 
FormattingTupless %
ArrayFormatss& 1
(ss1 2
stringss2 8
messagePatternss9 G
,ssG H
objecttt 
[tt 
]tt 
argArraytt 
)tt 
{uu 	
	Exceptionvv 
throwableCandidatevv (
=vv) *!
GetThrowableCandidatevv+ @
(vv@ A
argArrayvvA I
)vvI J
;vvJ K
ifxx 
(xx 
messagePatternxx 
==xx !
nullxx" &
)xx& '
{yy 
returnzz 
newzz 
FormattingTuplezz *
(zz* +
nullzz+ /
,zz/ 0
argArrayzz1 9
,zz9 :
throwableCandidatezz; M
)zzM N
;zzN O
}{{ 
if}} 
(}} 
argArray}} 
==}} 
null}}  
)}}  !
{~~ 
return 
new 
FormattingTuple *
(* +
messagePattern+ 9
)9 :
;: ;
}
ÄÄ 
int
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
var
ÉÉ 
sbuf
ÉÉ 
=
ÉÉ 
new
ÉÉ 
StringBuilder
ÉÉ (
(
ÉÉ( )
messagePattern
ÉÉ) 7
.
ÉÉ7 8
Length
ÉÉ8 >
+
ÉÉ? @
$num
ÉÉA C
)
ÉÉC D
;
ÉÉD E
int
ÖÖ 
l
ÖÖ 
;
ÖÖ 
for
ÜÜ 
(
ÜÜ 
l
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
l
ÜÜ 
<
ÜÜ 
argArray
ÜÜ $
.
ÜÜ$ %
Length
ÜÜ% +
;
ÜÜ+ ,
l
ÜÜ- .
++
ÜÜ. 0
)
ÜÜ0 1
{
áá 
int
àà 
j
àà 
=
àà 
messagePattern
àà &
.
àà& '
IndexOf
àà' .
(
àà. /
	DELIM_STR
àà/ 8
,
àà8 9
i
àà: ;
,
àà; <
StringComparison
àà= M
.
ààM N
Ordinal
ààN U
)
ààU V
;
ààV W
if
ää 
(
ää 
j
ää 
==
ää 
-
ää 
$num
ää 
)
ää 
{
ãã 
if
çç 
(
çç 
i
çç 
==
çç 
$num
çç 
)
çç 
{
éé 
return
êê 
new
êê "
FormattingTuple
êê# 2
(
êê2 3
messagePattern
êê3 A
,
êêA B
argArray
êêC K
,
êêK L 
throwableCandidate
ëë .
)
ëë. /
;
ëë/ 0
}
íí 
else
ìì 
{
îî 
sbuf
óó 
.
óó 
Append
óó #
(
óó# $
messagePattern
óó$ 2
.
óó2 3
	Substring
óó3 <
(
óó< =
i
óó= >
,
óó> ?
messagePattern
óó@ N
.
óóN O
Length
óóO U
-
óóV W
i
óóX Y
)
óóY Z
)
óóZ [
;
óó[ \
return
òò 
new
òò "
FormattingTuple
òò# 2
(
òò2 3
sbuf
òò3 7
.
òò7 8
ToString
òò8 @
(
òò@ A
)
òòA B
,
òòB C
argArray
òòD L
,
òòL M 
throwableCandidate
ôô .
)
ôô. /
;
ôô/ 0
}
öö 
}
õõ 
else
úú 
{
ùù 
if
ûû 
(
ûû  
IsEscapedDelimeter
ûû *
(
ûû* +
messagePattern
ûû+ 9
,
ûû9 :
j
ûû; <
)
ûû< =
)
ûû= >
{
üü 
if
†† 
(
†† 
!
†† 
IsDoubleEscaped
†† ,
(
††, -
messagePattern
††- ;
,
††; <
j
††= >
)
††> ?
)
††? @
{
°° 
l
¢¢ 
--
¢¢ 
;
¢¢  
sbuf
££  
.
££  !
Append
££! '
(
££' (
messagePattern
££( 6
.
££6 7
	Substring
££7 @
(
££@ A
i
££A B
,
££B C
j
££D E
-
££F G
$num
££H I
-
££J K
i
££L M
)
££M N
)
££N O
;
££O P
sbuf
§§  
.
§§  !
Append
§§! '
(
§§' (
DELIM_START
§§( 3
)
§§3 4
;
§§4 5
i
•• 
=
•• 
j
••  !
+
••" #
$num
••$ %
;
••% &
}
¶¶ 
else
ßß 
{
®® 
sbuf
¨¨  
.
¨¨  !
Append
¨¨! '
(
¨¨' (
messagePattern
¨¨( 6
.
¨¨6 7
	Substring
¨¨7 @
(
¨¨@ A
i
¨¨A B
,
¨¨B C
j
¨¨D E
-
¨¨F G
$num
¨¨H I
-
¨¨J K
i
¨¨L M
)
¨¨M N
)
¨¨N O
;
¨¨O P#
DeeplyAppendParameter
≠≠ 1
(
≠≠1 2
sbuf
≠≠2 6
,
≠≠6 7
argArray
≠≠8 @
[
≠≠@ A
l
≠≠A B
]
≠≠B C
,
≠≠C D
new
≠≠E H
HashSet
≠≠I P
<
≠≠P Q
object
≠≠Q W
[
≠≠W X
]
≠≠X Y
>
≠≠Y Z
(
≠≠Z [
)
≠≠[ \
)
≠≠\ ]
;
≠≠] ^
i
ÆÆ 
=
ÆÆ 
j
ÆÆ  !
+
ÆÆ" #
$num
ÆÆ$ %
;
ÆÆ% &
}
ØØ 
}
∞∞ 
else
±± 
{
≤≤ 
sbuf
¥¥ 
.
¥¥ 
Append
¥¥ #
(
¥¥# $
messagePattern
¥¥$ 2
.
¥¥2 3
	Substring
¥¥3 <
(
¥¥< =
i
¥¥= >
,
¥¥> ?
j
¥¥@ A
-
¥¥B C
i
¥¥D E
)
¥¥E F
)
¥¥F G
;
¥¥G H#
DeeplyAppendParameter
µµ -
(
µµ- .
sbuf
µµ. 2
,
µµ2 3
argArray
µµ4 <
[
µµ< =
l
µµ= >
]
µµ> ?
,
µµ? @
new
µµA D
HashSet
µµE L
<
µµL M
object
µµM S
[
µµS T
]
µµT U
>
µµU V
(
µµV W
)
µµW X
)
µµX Y
;
µµY Z
i
∂∂ 
=
∂∂ 
j
∂∂ 
+
∂∂ 
$num
∂∂  !
;
∂∂! "
}
∑∑ 
}
∏∏ 
}
ππ 
sbuf
ªª 
.
ªª 
Append
ªª 
(
ªª 
messagePattern
ªª &
.
ªª& '
	Substring
ªª' 0
(
ªª0 1
i
ªª1 2
,
ªª2 3
messagePattern
ªª4 B
.
ªªB C
Length
ªªC I
-
ªªJ K
i
ªªL M
)
ªªM N
)
ªªN O
;
ªªO P
if
ºº 
(
ºº 
l
ºº 
<
ºº 
argArray
ºº 
.
ºº 
Length
ºº #
-
ºº$ %
$num
ºº& '
)
ºº' (
{
ΩΩ 
return
ææ 
new
ææ 
FormattingTuple
ææ *
(
ææ* +
sbuf
ææ+ /
.
ææ/ 0
ToString
ææ0 8
(
ææ8 9
)
ææ9 :
,
ææ: ;
argArray
ææ< D
,
ææD E 
throwableCandidate
ææF X
)
ææX Y
;
ææY Z
}
øø 
else
¿¿ 
{
¡¡ 
return
¬¬ 
new
¬¬ 
FormattingTuple
¬¬ *
(
¬¬* +
sbuf
¬¬+ /
.
¬¬/ 0
ToString
¬¬0 8
(
¬¬8 9
)
¬¬9 :
,
¬¬: ;
argArray
¬¬< D
,
¬¬D E
null
¬¬F J
)
¬¬J K
;
¬¬K L
}
√√ 
}
ƒƒ 	
public
∆∆ 
static
∆∆ 
bool
∆∆  
IsEscapedDelimeter
∆∆ -
(
∆∆- .
string
∆∆. 4
messagePattern
∆∆5 C
,
∆∆C D
int
«« !
delimeterStartIndex
«« #
)
««# $
{
»» 	
if
…… 
(
…… !
delimeterStartIndex
…… #
==
……$ &
$num
……' (
)
……( )
{
   
return
ÀÀ 
false
ÀÀ 
;
ÀÀ 
}
ÃÃ 
return
ÕÕ 
messagePattern
ÕÕ !
[
ÕÕ! "!
delimeterStartIndex
ÕÕ" 5
-
ÕÕ6 7
$num
ÕÕ8 9
]
ÕÕ9 :
==
ÕÕ; =
ESCAPE_CHAR
ÕÕ> I
;
ÕÕI J
}
ŒŒ 	
public
–– 
static
–– 
bool
–– 
IsDoubleEscaped
–– *
(
––* +
string
––+ 1
messagePattern
––2 @
,
––@ A
int
––B E!
delimeterStartIndex
––F Y
)
––Y Z
=>
––[ ]!
delimeterStartIndex
––^ q
>=
––r t
$num
––u v
&&
––w y
messagePattern––z à
[––à â#
delimeterStartIndex––â ú
-––ù û
$num––ü †
]––† °
==––¢ §
ESCAPE_CHAR––• ∞
;––∞ ±
static
”” 
void
”” #
DeeplyAppendParameter
”” )
(
””) *
StringBuilder
””* 7
sbuf
””8 <
,
””< =
object
””> D
o
””E F
,
””F G
ISet
‘‘ 
<
‘‘ 
object
‘‘ 
[
‘‘ 
]
‘‘ 
>
‘‘ 
seenMap
‘‘ "
)
‘‘" #
{
’’ 	
if
÷÷ 
(
÷÷ 
o
÷÷ 
==
÷÷ 
null
÷÷ 
)
÷÷ 
{
◊◊ 
sbuf
ÿÿ 
.
ÿÿ 
Append
ÿÿ 
(
ÿÿ 
$str
ÿÿ "
)
ÿÿ" #
;
ÿÿ# $
return
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
if
€€ 
(
€€ 
!
€€ 
o
€€ 
.
€€ 
GetType
€€ 
(
€€ 
)
€€ 
.
€€ 
IsArray
€€ $
)
€€$ %
{
‹‹ 
SafeObjectAppend
››  
(
››  !
sbuf
››! %
,
››% &
o
››' (
)
››( )
;
››) *
}
ﬁﬁ 
else
ﬂﬂ 
{
‡‡ 
if
„„ 
(
„„ 
o
„„ 
is
„„ 
bool
„„ 
[
„„ 
]
„„ 
)
„„  
{
‰‰  
BooleanArrayAppend
ÂÂ &
(
ÂÂ& '
sbuf
ÂÂ' +
,
ÂÂ+ ,
(
ÂÂ- .
bool
ÂÂ. 2
[
ÂÂ2 3
]
ÂÂ3 4
)
ÂÂ4 5
o
ÂÂ5 6
)
ÂÂ6 7
;
ÂÂ7 8
}
ÊÊ 
else
ÁÁ 
if
ÁÁ 
(
ÁÁ 
o
ÁÁ 
is
ÁÁ 
byte
ÁÁ "
[
ÁÁ" #
]
ÁÁ# $
)
ÁÁ$ %
{
ËË 
ByteArrayAppend
ÈÈ #
(
ÈÈ# $
sbuf
ÈÈ$ (
,
ÈÈ( )
(
ÈÈ* +
byte
ÈÈ+ /
[
ÈÈ/ 0
]
ÈÈ0 1
)
ÈÈ1 2
o
ÈÈ2 3
)
ÈÈ3 4
;
ÈÈ4 5
}
ÍÍ 
else
ÎÎ 
if
ÎÎ 
(
ÎÎ 
o
ÎÎ 
is
ÎÎ 
char
ÎÎ "
[
ÎÎ" #
]
ÎÎ# $
)
ÎÎ$ %
{
ÏÏ 
CharArrayAppend
ÌÌ #
(
ÌÌ# $
sbuf
ÌÌ$ (
,
ÌÌ( )
(
ÌÌ* +
char
ÌÌ+ /
[
ÌÌ/ 0
]
ÌÌ0 1
)
ÌÌ1 2
o
ÌÌ2 3
)
ÌÌ3 4
;
ÌÌ4 5
}
ÓÓ 
else
ÔÔ 
if
ÔÔ 
(
ÔÔ 
o
ÔÔ 
is
ÔÔ 
short
ÔÔ #
[
ÔÔ# $
]
ÔÔ$ %
)
ÔÔ% &
{
 
ShortArrayAppend
ÒÒ $
(
ÒÒ$ %
sbuf
ÒÒ% )
,
ÒÒ) *
(
ÒÒ+ ,
short
ÒÒ, 1
[
ÒÒ1 2
]
ÒÒ2 3
)
ÒÒ3 4
o
ÒÒ4 5
)
ÒÒ5 6
;
ÒÒ6 7
}
ÚÚ 
else
ÛÛ 
if
ÛÛ 
(
ÛÛ 
o
ÛÛ 
is
ÛÛ 
int
ÛÛ !
[
ÛÛ! "
]
ÛÛ" #
)
ÛÛ# $
{
ÙÙ 
IntArrayAppend
ıı "
(
ıı" #
sbuf
ıı# '
,
ıı' (
(
ıı) *
int
ıı* -
[
ıı- .
]
ıı. /
)
ıı/ 0
o
ıı0 1
)
ıı1 2
;
ıı2 3
}
ˆˆ 
else
˜˜ 
if
˜˜ 
(
˜˜ 
o
˜˜ 
is
˜˜ 
long
˜˜ "
[
˜˜" #
]
˜˜# $
)
˜˜$ %
{
¯¯ 
LongArrayAppend
˘˘ #
(
˘˘# $
sbuf
˘˘$ (
,
˘˘( )
(
˘˘* +
long
˘˘+ /
[
˘˘/ 0
]
˘˘0 1
)
˘˘1 2
o
˘˘2 3
)
˘˘3 4
;
˘˘4 5
}
˙˙ 
else
˚˚ 
if
˚˚ 
(
˚˚ 
o
˚˚ 
is
˚˚ 
float
˚˚ #
[
˚˚# $
]
˚˚$ %
)
˚˚% &
{
¸¸ 
FloatArrayAppend
˝˝ $
(
˝˝$ %
sbuf
˝˝% )
,
˝˝) *
(
˝˝+ ,
float
˝˝, 1
[
˝˝1 2
]
˝˝2 3
)
˝˝3 4
o
˝˝4 5
)
˝˝5 6
;
˝˝6 7
}
˛˛ 
else
ˇˇ 
if
ˇˇ 
(
ˇˇ 
o
ˇˇ 
is
ˇˇ 
double
ˇˇ $
[
ˇˇ$ %
]
ˇˇ% &
)
ˇˇ& '
{
ÄÄ 
DoubleArrayAppend
ÅÅ %
(
ÅÅ% &
sbuf
ÅÅ& *
,
ÅÅ* +
(
ÅÅ, -
double
ÅÅ- 3
[
ÅÅ3 4
]
ÅÅ4 5
)
ÅÅ5 6
o
ÅÅ6 7
)
ÅÅ7 8
;
ÅÅ8 9
}
ÇÇ 
else
ÉÉ 
{
ÑÑ 
ObjectArrayAppend
ÖÖ %
(
ÖÖ% &
sbuf
ÖÖ& *
,
ÖÖ* +
(
ÖÖ, -
object
ÖÖ- 3
[
ÖÖ3 4
]
ÖÖ4 5
)
ÖÖ5 6
o
ÖÖ6 7
,
ÖÖ7 8
seenMap
ÖÖ9 @
)
ÖÖ@ A
;
ÖÖA B
}
ÜÜ 
}
áá 
}
àà 	
public
ää 
static
ää 
void
ää 
SafeObjectAppend
ää +
(
ää+ ,
StringBuilder
ää, 9
sbuf
ää: >
,
ää> ?
object
ää@ F
o
ääG H
)
ääH I
{
ãã 	
try
åå 
{
çç 
string
éé 
	oAsString
éé  
=
éé! "
o
éé# $
.
éé$ %
ToString
éé% -
(
éé- .
)
éé. /
;
éé/ 0
sbuf
èè 
.
èè 
Append
èè 
(
èè 
	oAsString
èè %
)
èè% &
;
èè& '
}
êê 
catch
ëë 
(
ëë 
	Exception
ëë 
t
ëë 
)
ëë 
{
íí 
Console
ìì 
.
ìì 
Error
ìì 
.
ìì 
	WriteLine
ìì '
(
ìì' (
$str
ìì( ]
+
îî 
o
îî 
.
îî 
GetType
îî 
(
îî  
)
îî  !
.
îî! "
Name
îî" &
+
îî' (
$str
îî) -
+
îî. /
Environment
îî0 ;
.
îî; <
NewLine
îî< C
+
îîD E
t
îîF G
)
îîG H
;
îîH I
sbuf
ïï 
.
ïï 
Append
ïï 
(
ïï 
$str
ïï 1
)
ïï1 2
;
ïï2 3
}
ññ 
}
óó 	
static
ôô 
void
ôô 
ObjectArrayAppend
ôô %
(
ôô% &
StringBuilder
ôô& 3
sbuf
ôô4 8
,
ôô8 9
object
ôô: @
[
ôô@ A
]
ôôA B
a
ôôC D
,
ôôD E
ISet
öö 
<
öö 
object
öö 
[
öö 
]
öö 
>
öö 
seenMap
öö "
)
öö" #
{
õõ 	
sbuf
úú 
.
úú 
Append
úú 
(
úú 
$char
úú 
)
úú 
;
úú 
if
ùù 
(
ùù 
!
ùù 
seenMap
ùù 
.
ùù 
Contains
ùù !
(
ùù! "
a
ùù" #
)
ùù# $
)
ùù$ %
{
ûû 
seenMap
üü 
.
üü 
Add
üü 
(
üü 
a
üü 
)
üü 
;
üü 
int
†† 
len
†† 
=
†† 
a
†† 
.
†† 
Length
†† "
;
††" #
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°°  !
<
°°" #
len
°°$ '
;
°°' (
i
°°) *
++
°°* ,
)
°°, -
{
¢¢ #
DeeplyAppendParameter
££ )
(
££) *
sbuf
££* .
,
££. /
a
££0 1
[
££1 2
i
££2 3
]
££3 4
,
££4 5
seenMap
££6 =
)
££= >
;
££> ?
if
§§ 
(
§§ 
i
§§ 
!=
§§ 
len
§§  
-
§§! "
$num
§§# $
)
§§$ %
{
•• 
sbuf
¶¶ 
.
¶¶ 
Append
¶¶ #
(
¶¶# $
$str
¶¶$ (
)
¶¶( )
;
¶¶) *
}
ßß 
}
®® 
seenMap
™™ 
.
™™ 
Remove
™™ 
(
™™ 
a
™™  
)
™™  !
;
™™! "
}
´´ 
else
¨¨ 
{
≠≠ 
sbuf
ÆÆ 
.
ÆÆ 
Append
ÆÆ 
(
ÆÆ 
$str
ÆÆ !
)
ÆÆ! "
;
ÆÆ" #
}
ØØ 
sbuf
∞∞ 
.
∞∞ 
Append
∞∞ 
(
∞∞ 
$char
∞∞ 
)
∞∞ 
;
∞∞ 
}
±± 	
static
≥≥ 
void
≥≥  
BooleanArrayAppend
≥≥ &
(
≥≥& '
StringBuilder
≥≥' 4
sbuf
≥≥5 9
,
≥≥9 :
bool
≥≥; ?
[
≥≥? @
]
≥≥@ A
a
≥≥B C
)
≥≥C D
{
¥¥ 	
sbuf
µµ 
.
µµ 
Append
µµ 
(
µµ 
$char
µµ 
)
µµ 
;
µµ 
int
∂∂ 
len
∂∂ 
=
∂∂ 
a
∂∂ 
.
∂∂ 
Length
∂∂ 
;
∂∂ 
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
len
∑∑  #
;
∑∑# $
i
∑∑% &
++
∑∑& (
)
∑∑( )
{
∏∏ 
sbuf
ππ 
.
ππ 
Append
ππ 
(
ππ 
a
ππ 
[
ππ 
i
ππ 
]
ππ  
)
ππ  !
;
ππ! "
if
∫∫ 
(
∫∫ 
i
∫∫ 
!=
∫∫ 
len
∫∫ 
-
∫∫ 
$num
∫∫  
)
∫∫  !
{
ªª 
sbuf
ºº 
.
ºº 
Append
ºº 
(
ºº  
$str
ºº  $
)
ºº$ %
;
ºº% &
}
ΩΩ 
}
ææ 
sbuf
øø 
.
øø 
Append
øø 
(
øø 
$char
øø 
)
øø 
;
øø 
}
¿¿ 	
static
¬¬ 
void
¬¬ 
ByteArrayAppend
¬¬ #
(
¬¬# $
StringBuilder
¬¬$ 1
sbuf
¬¬2 6
,
¬¬6 7
byte
¬¬8 <
[
¬¬< =
]
¬¬= >
a
¬¬? @
)
¬¬@ A
{
√√ 	
sbuf
ƒƒ 
.
ƒƒ 
Append
ƒƒ 
(
ƒƒ 
$char
ƒƒ 
)
ƒƒ 
;
ƒƒ 
int
≈≈ 
len
≈≈ 
=
≈≈ 
a
≈≈ 
.
≈≈ 
Length
≈≈ 
;
≈≈ 
for
∆∆ 
(
∆∆ 
int
∆∆ 
i
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
i
∆∆ 
<
∆∆ 
len
∆∆  #
;
∆∆# $
i
∆∆% &
++
∆∆& (
)
∆∆( )
{
«« 
sbuf
»» 
.
»» 
Append
»» 
(
»» 
a
»» 
[
»» 
i
»» 
]
»»  
)
»»  !
;
»»! "
if
…… 
(
…… 
i
…… 
!=
…… 
len
…… 
-
…… 
$num
……  
)
……  !
{
   
sbuf
ÀÀ 
.
ÀÀ 
Append
ÀÀ 
(
ÀÀ  
$str
ÀÀ  $
)
ÀÀ$ %
;
ÀÀ% &
}
ÃÃ 
}
ÕÕ 
sbuf
ŒŒ 
.
ŒŒ 
Append
ŒŒ 
(
ŒŒ 
$char
ŒŒ 
)
ŒŒ 
;
ŒŒ 
}
œœ 	
static
—— 
void
—— 
CharArrayAppend
—— #
(
——# $
StringBuilder
——$ 1
sbuf
——2 6
,
——6 7
char
——8 <
[
——< =
]
——= >
a
——? @
)
——@ A
{
““ 	
sbuf
”” 
.
”” 
Append
”” 
(
”” 
$char
”” 
)
”” 
;
”” 
int
‘‘ 
len
‘‘ 
=
‘‘ 
a
‘‘ 
.
‘‘ 
Length
‘‘ 
;
‘‘ 
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
;
’’ 
i
’’ 
<
’’ 
len
’’  #
;
’’# $
i
’’% &
++
’’& (
)
’’( )
{
÷÷ 
sbuf
◊◊ 
.
◊◊ 
Append
◊◊ 
(
◊◊ 
a
◊◊ 
[
◊◊ 
i
◊◊ 
]
◊◊  
)
◊◊  !
;
◊◊! "
if
ÿÿ 
(
ÿÿ 
i
ÿÿ 
!=
ÿÿ 
len
ÿÿ 
-
ÿÿ 
$num
ÿÿ  
)
ÿÿ  !
{
ŸŸ 
sbuf
⁄⁄ 
.
⁄⁄ 
Append
⁄⁄ 
(
⁄⁄  
$str
⁄⁄  $
)
⁄⁄$ %
;
⁄⁄% &
}
€€ 
}
‹‹ 
sbuf
›› 
.
›› 
Append
›› 
(
›› 
$char
›› 
)
›› 
;
›› 
}
ﬁﬁ 	
static
‡‡ 
void
‡‡ 
ShortArrayAppend
‡‡ $
(
‡‡$ %
StringBuilder
‡‡% 2
sbuf
‡‡3 7
,
‡‡7 8
short
‡‡9 >
[
‡‡> ?
]
‡‡? @
a
‡‡A B
)
‡‡B C
{
·· 	
sbuf
‚‚ 
.
‚‚ 
Append
‚‚ 
(
‚‚ 
$char
‚‚ 
)
‚‚ 
;
‚‚ 
int
„„ 
len
„„ 
=
„„ 
a
„„ 
.
„„ 
Length
„„ 
;
„„ 
for
‰‰ 
(
‰‰ 
int
‰‰ 
i
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
i
‰‰ 
<
‰‰ 
len
‰‰  #
;
‰‰# $
i
‰‰% &
++
‰‰& (
)
‰‰( )
{
ÂÂ 
sbuf
ÊÊ 
.
ÊÊ 
Append
ÊÊ 
(
ÊÊ 
a
ÊÊ 
[
ÊÊ 
i
ÊÊ 
]
ÊÊ  
)
ÊÊ  !
;
ÊÊ! "
if
ÁÁ 
(
ÁÁ 
i
ÁÁ 
!=
ÁÁ 
len
ÁÁ 
-
ÁÁ 
$num
ÁÁ  
)
ÁÁ  !
{
ËË 
sbuf
ÈÈ 
.
ÈÈ 
Append
ÈÈ 
(
ÈÈ  
$str
ÈÈ  $
)
ÈÈ$ %
;
ÈÈ% &
}
ÍÍ 
}
ÎÎ 
sbuf
ÏÏ 
.
ÏÏ 
Append
ÏÏ 
(
ÏÏ 
$char
ÏÏ 
)
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
static
ÔÔ 
void
ÔÔ 
IntArrayAppend
ÔÔ "
(
ÔÔ" #
StringBuilder
ÔÔ# 0
sbuf
ÔÔ1 5
,
ÔÔ5 6
int
ÔÔ7 :
[
ÔÔ: ;
]
ÔÔ; <
a
ÔÔ= >
)
ÔÔ> ?
{
 	
sbuf
ÒÒ 
.
ÒÒ 
Append
ÒÒ 
(
ÒÒ 
$char
ÒÒ 
)
ÒÒ 
;
ÒÒ 
int
ÚÚ 
len
ÚÚ 
=
ÚÚ 
a
ÚÚ 
.
ÚÚ 
Length
ÚÚ 
;
ÚÚ 
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
i
ÛÛ 
<
ÛÛ 
len
ÛÛ  #
;
ÛÛ# $
i
ÛÛ% &
++
ÛÛ& (
)
ÛÛ( )
{
ÙÙ 
sbuf
ıı 
.
ıı 
Append
ıı 
(
ıı 
a
ıı 
[
ıı 
i
ıı 
]
ıı  
)
ıı  !
;
ıı! "
if
ˆˆ 
(
ˆˆ 
i
ˆˆ 
!=
ˆˆ 
len
ˆˆ 
-
ˆˆ 
$num
ˆˆ  
)
ˆˆ  !
{
˜˜ 
sbuf
¯¯ 
.
¯¯ 
Append
¯¯ 
(
¯¯  
$str
¯¯  $
)
¯¯$ %
;
¯¯% &
}
˘˘ 
}
˙˙ 
sbuf
˚˚ 
.
˚˚ 
Append
˚˚ 
(
˚˚ 
$char
˚˚ 
)
˚˚ 
;
˚˚ 
}
¸¸ 	
static
˛˛ 
void
˛˛ 
LongArrayAppend
˛˛ #
(
˛˛# $
StringBuilder
˛˛$ 1
sbuf
˛˛2 6
,
˛˛6 7
long
˛˛8 <
[
˛˛< =
]
˛˛= >
a
˛˛? @
)
˛˛@ A
{
ˇˇ 	
sbuf
ÄÄ 
.
ÄÄ 
Append
ÄÄ 
(
ÄÄ 
$char
ÄÄ 
)
ÄÄ 
;
ÄÄ 
int
ÅÅ 
len
ÅÅ 
=
ÅÅ 
a
ÅÅ 
.
ÅÅ 
Length
ÅÅ 
;
ÅÅ 
for
ÇÇ 
(
ÇÇ 
int
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
i
ÇÇ 
<
ÇÇ 
len
ÇÇ  #
;
ÇÇ# $
i
ÇÇ% &
++
ÇÇ& (
)
ÇÇ( )
{
ÉÉ 
sbuf
ÑÑ 
.
ÑÑ 
Append
ÑÑ 
(
ÑÑ 
a
ÑÑ 
[
ÑÑ 
i
ÑÑ 
]
ÑÑ  
)
ÑÑ  !
;
ÑÑ! "
if
ÖÖ 
(
ÖÖ 
i
ÖÖ 
!=
ÖÖ 
len
ÖÖ 
-
ÖÖ 
$num
ÖÖ  
)
ÖÖ  !
{
ÜÜ 
sbuf
áá 
.
áá 
Append
áá 
(
áá  
$str
áá  $
)
áá$ %
;
áá% &
}
àà 
}
ââ 
sbuf
ää 
.
ää 
Append
ää 
(
ää 
$char
ää 
)
ää 
;
ää 
}
ãã 	
static
çç 
void
çç 
FloatArrayAppend
çç $
(
çç$ %
StringBuilder
çç% 2
sbuf
çç3 7
,
çç7 8
float
çç9 >
[
çç> ?
]
çç? @
a
ççA B
)
ççB C
{
éé 	
sbuf
èè 
.
èè 
Append
èè 
(
èè 
$char
èè 
)
èè 
;
èè 
int
êê 
len
êê 
=
êê 
a
êê 
.
êê 
Length
êê 
;
êê 
for
ëë 
(
ëë 
int
ëë 
i
ëë 
=
ëë 
$num
ëë 
;
ëë 
i
ëë 
<
ëë 
len
ëë  #
;
ëë# $
i
ëë% &
++
ëë& (
)
ëë( )
{
íí 
sbuf
ìì 
.
ìì 
Append
ìì 
(
ìì 
a
ìì 
[
ìì 
i
ìì 
]
ìì  
)
ìì  !
;
ìì! "
if
îî 
(
îî 
i
îî 
!=
îî 
len
îî 
-
îî 
$num
îî  
)
îî  !
{
ïï 
sbuf
ññ 
.
ññ 
Append
ññ 
(
ññ  
$str
ññ  $
)
ññ$ %
;
ññ% &
}
óó 
}
òò 
sbuf
ôô 
.
ôô 
Append
ôô 
(
ôô 
$char
ôô 
)
ôô 
;
ôô 
}
öö 	
static
úú 
void
úú 
DoubleArrayAppend
úú %
(
úú% &
StringBuilder
úú& 3
sbuf
úú4 8
,
úú8 9
double
úú: @
[
úú@ A
]
úúA B
a
úúC D
)
úúD E
{
ùù 	
sbuf
ûû 
.
ûû 
Append
ûû 
(
ûû 
$char
ûû 
)
ûû 
;
ûû 
int
üü 
len
üü 
=
üü 
a
üü 
.
üü 
Length
üü 
;
üü 
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
†† 
<
†† 
len
††  #
;
††# $
i
††% &
++
††& (
)
††( )
{
°° 
sbuf
¢¢ 
.
¢¢ 
Append
¢¢ 
(
¢¢ 
a
¢¢ 
[
¢¢ 
i
¢¢ 
]
¢¢  
)
¢¢  !
;
¢¢! "
if
££ 
(
££ 
i
££ 
!=
££ 
len
££ 
-
££ 
$num
££  
)
££  !
{
§§ 
sbuf
•• 
.
•• 
Append
•• 
(
••  
$str
••  $
)
••$ %
;
••% &
}
¶¶ 
}
ßß 
sbuf
®® 
.
®® 
Append
®® 
(
®® 
$char
®® 
)
®® 
;
®® 
}
©© 	
}
™™ 
}´´ ˙h
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\MacAddressUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

static 
class 
MacAddressUtil &
{ 
public 
const 
int 
MacAddressLength )
=* +
$num, -
;- .
static 
readonly 
byte 
[ 
] 
NotFound '
=( )
{* +
byte, 0
.0 1
MaxValue1 9
}: ;
;; <
static 
readonly 
IInternalLogger '
logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
MacAddressUtilZ h
)h i
)i j
;j k
public 
static 
byte 
[ 
] 
GetBestAvailableMac 0
(0 1
)1 2
{ 	
byte   
[   
]   
bestMacAddr   
=    
NotFound  ! )
;  ) *
	IPAddress!! 
bestInetAddr!! "
=!!# $
	IPAddress!!% .
.!!. /
Loopback!!/ 7
;!!7 8

Dictionary$$ 
<$$ 
NetworkInterface$$ '
,$$' (
	IPAddress$$) 2
>$$2 3
ifaces$$4 :
=$$; <
new$$= @

Dictionary$$A K
<$$K L
NetworkInterface$$L \
,$$\ ]
	IPAddress$$^ g
>$$g h
($$h i
)$$i j
;$$j k
try%% 
{&& 
foreach'' 
('' 
var'' 
iface'' "
in''# %
NetworkInterface''& 6
.''6 7#
GetAllNetworkInterfaces''7 N
(''N O
)''O P
)''P Q
{(( 
var** 
addrs** 
=** 
iface**  %
.**% &
GetIPProperties**& 5
(**5 6
)**6 7
.**7 8
UnicastAddresses**8 H
;**H I
if++ 
(++ 
addrs++ 
.++ 
Count++ #
>++$ %
$num++& '
)++' (
{,, 
var-- 
addressInfo-- '
=--( )
addrs--* /
.--/ 0
First--0 5
(--5 6
)--6 7
;--7 8
if.. 
(.. 
!.. 
	IPAddress.. &
...& '

IsLoopback..' 1
(..1 2
addressInfo..2 =
...= >
Address..> E
)..E F
)..F G
{// 
ifaces00 "
.00" #
Add00# &
(00& '
iface00' ,
,00, -
addressInfo00. 9
.009 :
Address00: A
)00A B
;00B C
}11 
}22 
}33 
}44 
catch55 
(55 
SocketException55 "
e55# $
)55$ %
{66 
logger77 
.77 
Warn77 
(77 
$str77 Y
,77Y Z
e77[ \
)77\ ]
;77] ^
}88 
foreach:: 
(:: 
var:: 
entry:: 
in:: !
ifaces::" (
)::( )
{;; 
NetworkInterface<<  
iface<<! &
=<<' (
entry<<) .
.<<. /
Key<</ 2
;<<2 3
	IPAddress== 
inetAddr== "
===# $
entry==% *
.==* +
Value==+ 0
;==0 1
byte?? 
[?? 
]?? 
macAddr?? 
=??  
iface??! &
.??& '
GetPhysicalAddress??' 9
(??9 :
)??: ;
???; <
.??< =
GetAddressBytes??= L
(??L M
)??M N
;??N O
bool@@ 
replace@@ 
=@@ 
false@@ $
;@@$ %
intAA 
resAA 
=AA 
CompareAddressesAA *
(AA* +
bestMacAddrAA+ 6
,AA6 7
macAddrAA8 ?
)AA? @
;AA@ A
ifBB 
(BB 
resBB 
<BB 
$numBB 
)BB 
{CC 
replaceEE 
=EE 
trueEE "
;EE" #
}FF 
elseGG 
ifGG 
(GG 
resGG 
==GG 
$numGG  !
)GG! "
{HH 
resJJ 
=JJ 
CompareAddressesJJ *
(JJ* +
bestInetAddrJJ+ 7
,JJ7 8
inetAddrJJ9 A
)JJA B
;JJB C
ifKK 
(KK 
resKK 
<KK 
$numKK 
)KK  
{LL 
replaceNN 
=NN  !
trueNN" &
;NN& '
}OO 
elsePP 
ifPP 
(PP 
resPP  
==PP! #
$numPP$ %
)PP% &
{QQ 
ifSS 
(SS 
bestMacAddrSS '
.SS' (
LengthSS( .
<SS/ 0
macAddrSS1 8
.SS8 9
LengthSS9 ?
)SS? @
{TT 
replaceUU #
=UU$ %
trueUU& *
;UU* +
}VV 
}WW 
}XX 
ifZZ 
(ZZ 
replaceZZ 
)ZZ 
{[[ 
bestMacAddr\\ 
=\\  !
macAddr\\" )
;\\) *
bestInetAddr]]  
=]]! "
inetAddr]]# +
;]]+ ,
}^^ 
}__ 
ifaa 
(aa 
bestMacAddraa 
==aa 
NotFoundaa '
)aa' (
{bb 
returncc 
nullcc 
;cc 
}dd 
switchff 
(ff 
bestMacAddrff 
.ff  
Lengthff  &
)ff& '
{gg 
casehh 
$numhh 
:hh 
varii 
newAddrii 
=ii  !
newii" %
byteii& *
[ii* +
MacAddressLengthii+ ;
]ii; <
;ii< =
Arrayjj 
.jj 
Copyjj 
(jj 
bestMacAddrjj *
,jj* +
$numjj, -
,jj- .
newAddrjj/ 6
,jj6 7
$numjj8 9
,jj9 :
$numjj; <
)jj< =
;jj= >
newAddrkk 
[kk 
$numkk 
]kk 
=kk  
$numkk! %
;kk% &
newAddrll 
[ll 
$numll 
]ll 
=ll  
$numll! %
;ll% &
Arraymm 
.mm 
Copymm 
(mm 
bestMacAddrmm *
,mm* +
$nummm, -
,mm- .
newAddrmm/ 6
,mm6 7
$nummm8 9
,mm9 :
$nummm; <
)mm< =
;mm= >
bestMacAddrnn 
=nn  !
newAddrnn" )
;nn) *
breakoo 
;oo 
defaultpp 
:pp 
bestMacAddrqq 
=qq  !
bestMacAddrqq" -
.qq- .
Sliceqq. 3
(qq3 4
$numqq4 5
,qq5 6
Mathqq7 ;
.qq; <
Minqq< ?
(qq? @
bestMacAddrqq@ K
.qqK L
LengthqqL R
,qqR S
MacAddressLengthqqT d
)qqd e
)qqe f
;qqf g
breakrr 
;rr 
}ss 
returnuu 
bestMacAddruu 
;uu 
}vv 	
publiczz 
staticzz 
stringzz 
FormatAddresszz *
(zz* +
bytezz+ /
[zz/ 0
]zz0 1
addrzz2 6
)zz6 7
{{{ 	
StringBuilder|| 
buf|| 
=|| 
new||  #
StringBuilder||$ 1
(||1 2
$num||2 4
)||4 5
;||5 6
foreach}} 
(}} 
byte}} 
b}} 
in}} 
addr}} #
)}}# $
{~~ 
buf 
. 
Append 
( 
( 
b 
& 
$num  $
)$ %
.% &
ToString& .
(. /
$str/ 3
)3 4
)4 5
.5 6
Append6 <
(< =
$str= @
)@ A
;A B
}
ÄÄ 
return
ÅÅ 
buf
ÅÅ 
.
ÅÅ 
ToString
ÅÅ 
(
ÅÅ  
$num
ÅÅ  !
,
ÅÅ! "
buf
ÅÅ# &
.
ÅÅ& '
Length
ÅÅ' -
-
ÅÅ. /
$num
ÅÅ0 1
)
ÅÅ1 2
;
ÅÅ2 3
}
ÇÇ 	
static
ÖÖ 
int
ÖÖ 
CompareAddresses
ÖÖ #
(
ÖÖ# $
byte
ÖÖ$ (
[
ÖÖ( )
]
ÖÖ) *
current
ÖÖ+ 2
,
ÖÖ2 3
byte
ÖÖ4 8
[
ÖÖ8 9
]
ÖÖ9 :
	candidate
ÖÖ; D
)
ÖÖD E
{
ÜÜ 	
if
áá 
(
áá 
	candidate
áá 
==
áá 
null
áá !
)
áá! "
{
àà 
return
ââ 
$num
ââ 
;
ââ 
}
ää 
if
çç 
(
çç 
	candidate
çç 
.
çç 
Length
çç  
<
çç! "
$num
çç# $
)
çç$ %
{
éé 
return
èè 
$num
èè 
;
èè 
}
êê 
bool
ìì 
onlyZeroAndOne
ìì 
=
ìì  !
true
ìì" &
;
ìì& '
foreach
îî 
(
îî 
byte
îî 
b
îî 
in
îî 
	candidate
îî (
)
îî( )
{
ïï 
if
ññ 
(
ññ 
b
ññ 
!=
ññ 
$num
ññ 
&&
ññ 
b
ññ 
!=
ññ  "
$num
ññ# $
)
ññ$ %
{
óó 
onlyZeroAndOne
òò "
=
òò# $
false
òò% *
;
òò* +
break
ôô 
;
ôô 
}
öö 
}
õõ 
if
ùù 
(
ùù 
onlyZeroAndOne
ùù 
)
ùù 
{
ûû 
return
üü 
$num
üü 
;
üü 
}
†† 
if
££ 
(
££ 
(
££ 
	candidate
££ 
[
££ 
$num
££ 
]
££ 
&
££ 
$num
££  !
)
££! "
!=
££# %
$num
££& '
)
££' (
{
§§ 
return
•• 
$num
•• 
;
•• 
}
¶¶ 
if
©© 
(
©© 
(
©© 
current
©© 
[
©© 
$num
©© 
]
©© 
&
©© 
$num
©© 
)
©©  
==
©©! #
$num
©©$ %
)
©©% &
{
™™ 
if
´´ 
(
´´ 
(
´´ 
	candidate
´´ 
[
´´ 
$num
´´  
]
´´  !
&
´´" #
$num
´´$ %
)
´´% &
==
´´' )
$num
´´* +
)
´´+ ,
{
¨¨ 
return
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
}
ØØ 
else
∞∞ 
{
±± 
return
≥≥ 
$num
≥≥ 
;
≥≥ 
}
¥¥ 
}
µµ 
else
∂∂ 
{
∑∑ 
if
∏∏ 
(
∏∏ 
(
∏∏ 
	candidate
∏∏ 
[
∏∏ 
$num
∏∏  
]
∏∏  !
&
∏∏" #
$num
∏∏$ %
)
∏∏% &
==
∏∏' )
$num
∏∏* +
)
∏∏+ ,
{
ππ 
return
ªª 
-
ªª 
$num
ªª 
;
ªª 
}
ºº 
else
ΩΩ 
{
ææ 
return
¿¿ 
$num
¿¿ 
;
¿¿ 
}
¡¡ 
}
¬¬ 
}
√√ 	
static
∆∆ 
int
∆∆ 
CompareAddresses
∆∆ #
(
∆∆# $
	IPAddress
∆∆$ -
current
∆∆. 5
,
∆∆5 6
	IPAddress
∆∆7 @
	candidate
∆∆A J
)
∆∆J K
=>
∆∆L N
ScoreAddress
∆∆O [
(
∆∆[ \
current
∆∆\ c
)
∆∆c d
-
∆∆e f
ScoreAddress
∆∆g s
(
∆∆s t
	candidate
∆∆t }
)
∆∆} ~
;
∆∆~ 
static
»» 
int
»» 
ScoreAddress
»» 
(
»»  
	IPAddress
»»  )
addr
»»* .
)
»». /
{
…… 	
if
   
(
   
	IPAddress
   
.
   

IsLoopback
   $
(
  $ %
addr
  % )
)
  ) *
)
  * +
{
ÀÀ 
return
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
}
ÕÕ 
if
ŒŒ 
(
ŒŒ 
addr
ŒŒ 
.
ŒŒ 
IsIPv6Multicast
ŒŒ $
)
ŒŒ$ %
{
œœ 
return
–– 
$num
–– 
;
–– 
}
—— 
if
““ 
(
““ 
addr
““ 
.
““ 
IsIPv6LinkLocal
““ $
)
““$ %
{
”” 
return
‘‘ 
$num
‘‘ 
;
‘‘ 
}
’’ 
if
÷÷ 
(
÷÷ 
addr
÷÷ 
.
÷÷ 
IsIPv6SiteLocal
÷÷ $
)
÷÷$ %
{
◊◊ 
return
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
}
ŸŸ 
return
€€ 
$num
€€ 
;
€€ 
}
‹‹ 	
}
›› 
}ﬁﬁ Õ$
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\MathUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public		 

static		 
class		 
MathUtil		  
{

 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
public 
static 
bool 
IsOutOfBounds (
(( )
int) ,
index- 2
,2 3
int4 7
length8 >
,> ?
int@ C
capacityD L
)L M
=>N P
( 
index 
| 
length 
| 
( 
index $
+% &
length' -
)- .
|/ 0
(1 2
capacity2 :
-; <
(= >
index> C
+D E
lengthF L
)L M
)M N
)N O
<P Q
$numR S
;S T
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
public 
static 
int &
FindNextPositivePowerOfTwo 4
(4 5
int5 8
value9 >
)> ?
{ 	
Debug 
. 
Assert 
( 
value 
>  
int! $
.$ %
MinValue% -
&&. 0
value1 6
<7 8
$num9 C
)C D
;D E
return 
$num 
<< 
( 
$num 
-  
NumberOfLeadingZeros 2
(2 3
value3 8
-9 :
$num; <
)< =
)= >
;> ?
} 	
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
public 
static 
int *
SafeFindNextPositivePowerOfTwo 8
(8 9
int9 <
value= B
)B C
=>D F
value 
<= 
$num 
? 
$num 
: 
value "
>=# %
$num& 0
?1 2
$num3 =
:> ?&
FindNextPositivePowerOfTwo@ Z
(Z [
value[ `
)` a
;a b
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
public 
static 
int  
NumberOfLeadingZeros .
(. /
this/ 3
int4 7
i8 9
)9 :
{ 	
i 
|= 
i 
>> 
$num 
; 
i 
|= 
i 
>> 
$num 
; 
i 
|= 
i 
>> 
$num 
; 
i   
|=   
i   
>>   
$num   
;   
i!! 
|=!! 
i!! 
>>!! 
$num!! 
;!! 
i"" 
="" 
~"" 
i"" 
;"" 
i%% 
-=%% 
(%% 
(%% 
i%% 
>>%% 
$num%% 
)%% 
&%% 
$num%% '
)%%' (
;%%( )
i&& 
=&& 
(&& 
i&& 
&&& 
$num&& 
)&&  
+&&! "
(&&# $
(&&$ %
i&&% &
>>&&' )
$num&&* +
)&&+ ,
&&&- .
$num&&/ 9
)&&9 :
;&&: ;
i'' 
='' 
('' 
('' 
('' 
i'' 
>>'' 
$num'' 
)'' 
+'' 
i'' 
)'' 
&''  !
$num''" ,
)'', -
;''- .
i(( 
+=(( 
((( 
i(( 
>>(( 
$num(( 
)(( 
;(( 
i)) 
+=)) 
()) 
i)) 
>>)) 
$num)) 
))) 
;)) 
return** 
(** 
i** 
&** 
$num** "
)**" #
;**# $
}++ 	
},, 
}-- áû
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\MpscArrayQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
sealed 

class 
MpscArrayQueue 
<  
T  !
>! "
:# $'
MpscArrayQueueConsumerField% @
<@ A
TA B
>B C
where 
T 
: 
class 
{ 
long 
p40 
, 
p41 
, 
p42 
, 
p43 
,  
p44! $
,$ %
p45& )
,) *
p46+ .
;. /
long 
p30 
, 
p31 
, 
p32 
, 
p33 
,  
p34! $
,$ %
p35& )
,) *
p36+ .
,. /
p370 3
;3 4
public   
MpscArrayQueue   
(   
int   !
capacity  " *
)  * +
:!! 
base!! 
(!! 
capacity!! 
)!! 
{"" 	
}## 	
public,, 
override,, 
bool,, 

TryEnqueue,, '
(,,' (
T,,( )
e,,* +
),,+ ,
{-- 	
Contract.. 
... 
Requires.. 
(.. 
e.. 
!=..  "
null..# '
)..' (
;..( )
long11 
mask11 
=11 
this11 
.11 
Mask11 !
;11! "
long22 
capacity22 
=22 
mask22  
+22! "
$num22# $
;22$ %
long33 
consumerIndexCache33 #
=33$ %
this33& *
.33* +
ConsumerIndexCache33+ =
;33= >
long44  
currentProducerIndex44 %
;44% &
do55 
{66  
currentProducerIndex77 $
=77% &
this77' +
.77+ ,
ProducerIndex77, 9
;779 :
long88 
	wrapPoint88 
=88   
currentProducerIndex88! 5
-886 7
capacity888 @
;88@ A
if99 
(99 
consumerIndexCache99 &
<=99' )
	wrapPoint99* 3
)993 4
{:: 
long;; 
currHead;; !
=;;" #
this;;$ (
.;;( )
ConsumerIndex;;) 6
;;;6 7
if<< 
(<< 
currHead<<  
<=<<! #
	wrapPoint<<$ -
)<<- .
{== 
return>> 
false>> $
;>>$ %
}?? 
else@@ 
{AA 
thisCC 
.CC 
ConsumerIndexCacheCC /
=CC0 1
currHeadCC2 :
;CC: ;
consumerIndexCacheEE *
=EE+ ,
currHeadEE- 5
;EE5 6
}FF 
}GG 
}HH 
whileII 
(II 
!II 
thisII 
.II 
TrySetProducerIndexII ,
(II, - 
currentProducerIndexII- A
,IIA B 
currentProducerIndexIIC W
+IIX Y
$numIIZ [
)II[ \
)II\ ]
;II] ^
longOO 
offsetOO 
=OO 
RefArrayAccessUtilOO ,
.OO, -
CalcElementOffsetOO- >
(OO> ? 
currentProducerIndexOO? S
,OOS T
maskOOU Y
)OOY Z
;OOZ [
thisPP 
.PP 
	SoElementPP 
(PP 
offsetPP !
,PP! "
ePP# $
)PP$ %
;PP% &
returnQQ 
trueQQ 
;QQ 
}RR 	
publicYY 
intYY 
WeakEnqueueYY 
(YY 
TYY  
eYY! "
)YY" #
{ZZ 	
Contract[[ 
.[[ 
Requires[[ 
([[ 
e[[ 
!=[[  "
null[[# '
)[[' (
;[[( )
long]] 
mask]] 
=]] 
this]] 
.]] 
Mask]] !
;]]! "
long^^ 
capacity^^ 
=^^ 
mask^^  
+^^! "
$num^^# $
;^^$ %
long__ 
currentTail__ 
=__ 
this__ #
.__# $
ProducerIndex__$ 1
;__1 2
long`` 
consumerIndexCache`` #
=``$ %
this``& *
.``* +
ConsumerIndexCache``+ =
;``= >
longaa 
	wrapPointaa 
=aa 
currentTailaa (
-aa) *
capacityaa+ 3
;aa3 4
ifbb 
(bb 
consumerIndexCachebb "
<=bb# %
	wrapPointbb& /
)bb/ 0
{cc 
longdd 
currHeaddd 
=dd 
thisdd  $
.dd$ %
ConsumerIndexdd% 2
;dd2 3
ifee 
(ee 
currHeadee 
<=ee 
	wrapPointee  )
)ee) *
{ff 
returngg 
$numgg 
;gg 
}hh 
elseii 
{jj 
thiskk 
.kk 
ConsumerIndexCachekk +
=kk, -
currHeadkk. 6
;kk6 7
}ll 
}mm 
ifpp 
(pp 
!pp 
thispp 
.pp 
TrySetProducerIndexpp )
(pp) *
currentTailpp* 5
,pp5 6
currentTailpp7 B
+ppC D
$numppE F
)ppF G
)ppG H
{qq 
returnrr 
-rr 
$numrr 
;rr 
}ss 
longvv 
offsetvv 
=vv 
RefArrayAccessUtilvv ,
.vv, -
CalcElementOffsetvv- >
(vv> ?
currentTailvv? J
,vvJ K
maskvvL P
)vvP Q
;vvQ R
thisww 
.ww 
	SoElementww 
(ww 
offsetww !
,ww! "
eww# $
)ww$ %
;ww% &
returnxx 
$numxx 
;xx 
}yy 	
public
ÅÅ 
override
ÅÅ 
bool
ÅÅ 

TryDequeue
ÅÅ '
(
ÅÅ' (
out
ÅÅ( +
T
ÅÅ, -
item
ÅÅ. 2
)
ÅÅ2 3
{
ÇÇ 	
long
ÉÉ 
consumerIndex
ÉÉ 
=
ÉÉ  
this
ÉÉ! %
.
ÉÉ% &
ConsumerIndex
ÉÉ& 3
;
ÉÉ3 4
long
ÑÑ 
offset
ÑÑ 
=
ÑÑ 
this
ÑÑ 
.
ÑÑ 
CalcElementOffset
ÑÑ 0
(
ÑÑ0 1
consumerIndex
ÑÑ1 >
)
ÑÑ> ?
;
ÑÑ? @
T
ÜÜ 
[
ÜÜ 
]
ÜÜ 
buffer
ÜÜ 
=
ÜÜ 
this
ÜÜ 
.
ÜÜ 
Buffer
ÜÜ $
;
ÜÜ$ %
T
ââ 
e
ââ 
=
ââ  
RefArrayAccessUtil
ââ $
.
ââ$ %
	LvElement
ââ% .
(
ââ. /
buffer
ââ/ 5
,
ââ5 6
offset
ââ7 =
)
ââ= >
;
ââ> ?
if
ää 
(
ää 
null
ää 
==
ää 
e
ää 
)
ää 
{
ãã 
if
êê 
(
êê 
consumerIndex
êê !
!=
êê" $
this
êê% )
.
êê) *
ProducerIndex
êê* 7
)
êê7 8
{
ëë 
do
íí 
{
ìì 
e
îî 
=
îî  
RefArrayAccessUtil
îî .
.
îî. /
	LvElement
îî/ 8
(
îî8 9
buffer
îî9 ?
,
îî? @
offset
îîA G
)
îîG H
;
îîH I
}
ïï 
while
ññ 
(
ññ 
e
ññ 
==
ññ 
null
ññ  $
)
ññ$ %
;
ññ% &
}
óó 
else
òò 
{
ôô 
item
öö 
=
öö 
default
öö "
(
öö" #
T
öö# $
)
öö$ %
;
öö% &
return
õõ 
false
õõ  
;
õõ  !
}
úú 
}
ùù  
RefArrayAccessUtil
üü 
.
üü 
	SpElement
üü (
(
üü( )
buffer
üü) /
,
üü/ 0
offset
üü1 7
,
üü7 8
default
üü9 @
(
üü@ A
T
üüA B
)
üüB C
)
üüC D
;
üüD E
this
†† 
.
†† 
ConsumerIndex
†† 
=
††  
consumerIndex
††! .
+
††/ 0
$num
††1 2
;
††2 3
item
°° 
=
°° 
e
°° 
;
°° 
return
¢¢ 
true
¢¢ 
;
¢¢ 
}
££ 	
public
´´ 
override
´´ 
bool
´´ 
TryPeek
´´ $
(
´´$ %
out
´´% (
T
´´) *
item
´´+ /
)
´´/ 0
{
¨¨ 	
T
ÆÆ 
[
ÆÆ 
]
ÆÆ 
buffer
ÆÆ 
=
ÆÆ 
this
ÆÆ 
.
ÆÆ 
Buffer
ÆÆ $
;
ÆÆ$ %
long
∞∞ 
consumerIndex
∞∞ 
=
∞∞  
this
∞∞! %
.
∞∞% &
ConsumerIndex
∞∞& 3
;
∞∞3 4
long
±± 
offset
±± 
=
±± 
this
±± 
.
±± 
CalcElementOffset
±± 0
(
±±0 1
consumerIndex
±±1 >
)
±±> ?
;
±±? @
T
≤≤ 
e
≤≤ 
=
≤≤  
RefArrayAccessUtil
≤≤ $
.
≤≤$ %
	LvElement
≤≤% .
(
≤≤. /
buffer
≤≤/ 5
,
≤≤5 6
offset
≤≤7 =
)
≤≤= >
;
≤≤> ?
if
≥≥ 
(
≥≥ 
null
≥≥ 
==
≥≥ 
e
≥≥ 
)
≥≥ 
{
¥¥ 
if
ππ 
(
ππ 
consumerIndex
ππ !
!=
ππ" $
this
ππ% )
.
ππ) *
ProducerIndex
ππ* 7
)
ππ7 8
{
∫∫ 
do
ªª 
{
ºº 
e
ΩΩ 
=
ΩΩ  
RefArrayAccessUtil
ΩΩ .
.
ΩΩ. /
	LvElement
ΩΩ/ 8
(
ΩΩ8 9
buffer
ΩΩ9 ?
,
ΩΩ? @
offset
ΩΩA G
)
ΩΩG H
;
ΩΩH I
}
ææ 
while
øø 
(
øø 
e
øø 
==
øø 
null
øø  $
)
øø$ %
;
øø% &
}
¿¿ 
else
¡¡ 
{
¬¬ 
item
√√ 
=
√√ 
default
√√ "
(
√√" #
T
√√# $
)
√√$ %
;
√√% &
return
ƒƒ 
false
ƒƒ  
;
ƒƒ  !
}
≈≈ 
}
∆∆ 
item
«« 
=
«« 
e
«« 
;
«« 
return
…… 
true
…… 
;
…… 
}
   	
public
œœ 
override
œœ 
int
œœ 
Count
œœ !
{
–– 	
get
—— 
{
““ 
long
ÿÿ 
after
ÿÿ 
=
ÿÿ 
this
ÿÿ !
.
ÿÿ! "
ConsumerIndex
ÿÿ" /
;
ÿÿ/ 0
while
ŸŸ 
(
ŸŸ 
true
ŸŸ 
)
ŸŸ 
{
⁄⁄ 
long
€€ 
before
€€ 
=
€€  !
after
€€" '
;
€€' (
long
‹‹ "
currentProducerIndex
‹‹ -
=
‹‹. /
this
‹‹0 4
.
‹‹4 5
ProducerIndex
‹‹5 B
;
‹‹B C
after
›› 
=
›› 
this
››  
.
››  !
ConsumerIndex
››! .
;
››. /
if
ﬁﬁ 
(
ﬁﬁ 
before
ﬁﬁ 
==
ﬁﬁ !
after
ﬁﬁ" '
)
ﬁﬁ' (
{
ﬂﬂ 
return
‡‡ 
(
‡‡  
int
‡‡  #
)
‡‡# $
(
‡‡$ %"
currentProducerIndex
‡‡% 9
-
‡‡: ;
after
‡‡< A
)
‡‡A B
;
‡‡B C
}
·· 
}
‚‚ 
}
„„ 
}
‰‰ 	
public
ÊÊ 
override
ÊÊ 
bool
ÊÊ 
IsEmpty
ÊÊ $
{
ÁÁ 	
get
ËË 
{
ÈÈ 
return
ÔÔ 
this
ÔÔ 
.
ÔÔ 
ConsumerIndex
ÔÔ )
==
ÔÔ* ,
this
ÔÔ- 1
.
ÔÔ1 2
ProducerIndex
ÔÔ2 ?
;
ÔÔ? @
}
 
}
ÒÒ 	
}
ÚÚ 
abstract
ÙÙ 
class
ÙÙ !
MpscArrayQueueL1Pad
ÙÙ &
<
ÙÙ& '
T
ÙÙ' (
>
ÙÙ( )
:
ÙÙ* +*
ConcurrentCircularArrayQueue
ÙÙ, H
<
ÙÙH I
T
ÙÙI J
>
ÙÙJ K
where
ıı 
T
ıı 
:
ıı 
class
ıı 
{
ˆˆ 
long
¯¯ 
p10
¯¯ 
,
¯¯ 
p11
¯¯ 
,
¯¯ 
p12
¯¯ 
,
¯¯ 
p13
¯¯ 
,
¯¯  
p14
¯¯! $
,
¯¯$ %
p15
¯¯& )
,
¯¯) *
p16
¯¯+ .
;
¯¯. /
long
˘˘ 
p30
˘˘ 
,
˘˘ 
p31
˘˘ 
,
˘˘ 
p32
˘˘ 
,
˘˘ 
p33
˘˘ 
,
˘˘  
p34
˘˘! $
,
˘˘$ %
p35
˘˘& )
,
˘˘) *
p36
˘˘+ .
,
˘˘. /
p37
˘˘0 3
;
˘˘3 4
	protected
¸¸ !
MpscArrayQueueL1Pad
¸¸ %
(
¸¸% &
int
¸¸& )
capacity
¸¸* 2
)
¸¸2 3
:
˝˝ 
base
˝˝ 
(
˝˝ 
capacity
˝˝ 
)
˝˝ 
{
˛˛ 	
}
ˇˇ 	
}
ÄÄ 
abstract
ÇÇ 
class
ÇÇ %
MpscArrayQueueTailField
ÇÇ *
<
ÇÇ* +
T
ÇÇ+ ,
>
ÇÇ, -
:
ÇÇ. /!
MpscArrayQueueL1Pad
ÇÇ0 C
<
ÇÇC D
T
ÇÇD E
>
ÇÇE F
where
ÉÉ 
T
ÉÉ 
:
ÉÉ 
class
ÉÉ 
{
ÑÑ 
long
ÖÖ 
producerIndex
ÖÖ 
;
ÖÖ 
	protected
áá %
MpscArrayQueueTailField
áá )
(
áá) *
int
áá* -
capacity
áá. 6
)
áá6 7
:
àà 
base
àà 
(
àà 
capacity
àà 
)
àà 
{
ââ 	
}
ää 	
	protected
åå 
long
åå 
ProducerIndex
åå $
=>
åå% '
Volatile
åå( 0
.
åå0 1
Read
åå1 5
(
åå5 6
ref
åå6 9
this
åå: >
.
åå> ?
producerIndex
åå? L
)
ååL M
;
ååM N
	protected
éé 
bool
éé !
TrySetProducerIndex
éé *
(
éé* +
long
éé+ /
expect
éé0 6
,
éé6 7
long
éé8 <
newValue
éé= E
)
ééE F
=>
ééG I
Interlocked
ééJ U
.
ééU V
CompareExchange
ééV e
(
éée f
ref
ééf i
this
ééj n
.
één o
producerIndex
ééo |
,
éé| }
newValueéé~ Ü
,ééÜ á
expectééà é
)ééé è
==ééê í
expectééì ô
;ééô ö
}
èè 
abstract
ëë 
class
ëë "
MpscArrayQueueMidPad
ëë '
<
ëë' (
T
ëë( )
>
ëë) *
:
ëë+ ,%
MpscArrayQueueTailField
ëë- D
<
ëëD E
T
ëëE F
>
ëëF G
where
íí 
T
íí 
:
íí 
class
íí 
{
ìì 
long
ïï 
p20
ïï 
,
ïï 
p21
ïï 
,
ïï 
p22
ïï 
,
ïï 
p23
ïï 
,
ïï  
p24
ïï! $
,
ïï$ %
p25
ïï& )
,
ïï) *
p26
ïï+ .
;
ïï. /
long
ññ 
p30
ññ 
,
ññ 
p31
ññ 
,
ññ 
p32
ññ 
,
ññ 
p33
ññ 
,
ññ  
p34
ññ! $
,
ññ$ %
p35
ññ& )
,
ññ) *
p36
ññ+ .
,
ññ. /
p37
ññ0 3
;
ññ3 4
	protected
ôô "
MpscArrayQueueMidPad
ôô &
(
ôô& '
int
ôô' *
capacity
ôô+ 3
)
ôô3 4
:
öö 
base
öö 
(
öö 
capacity
öö 
)
öö 
{
õõ 	
}
úú 	
}
ùù 
abstract
üü 
class
üü *
MpscArrayQueueHeadCacheField
üü /
<
üü/ 0
T
üü0 1
>
üü1 2
:
üü3 4"
MpscArrayQueueMidPad
üü5 I
<
üüI J
T
üüJ K
>
üüK L
where
†† 
T
†† 
:
†† 
class
†† 
{
°° 
long
¢¢ 
	headCache
¢¢ 
;
¢¢ 
	protected
§§ *
MpscArrayQueueHeadCacheField
§§ .
(
§§. /
int
§§/ 2
capacity
§§3 ;
)
§§; <
:
•• 
base
•• 
(
•• 
capacity
•• 
)
•• 
{
¶¶ 	
}
ßß 	
	protected
©© 
long
©©  
ConsumerIndexCache
©© )
{
™™ 	
get
´´ 
{
´´ 
return
´´ 
Volatile
´´ !
.
´´! "
Read
´´" &
(
´´& '
ref
´´' *
this
´´+ /
.
´´/ 0
	headCache
´´0 9
)
´´9 :
;
´´: ;
}
´´< =
set
¨¨ 
{
¨¨ 
Volatile
¨¨ 
.
¨¨ 
Write
¨¨  
(
¨¨  !
ref
¨¨! $
this
¨¨% )
.
¨¨) *
	headCache
¨¨* 3
,
¨¨3 4
value
¨¨5 :
)
¨¨: ;
;
¨¨; <
}
¨¨= >
}
≠≠ 	
}
ÆÆ 
abstract
∞∞ 
class
∞∞ !
MpscArrayQueueL2Pad
∞∞ &
<
∞∞& '
T
∞∞' (
>
∞∞( )
:
∞∞* +*
MpscArrayQueueHeadCacheField
∞∞, H
<
∞∞H I
T
∞∞I J
>
∞∞J K
where
±± 
T
±± 
:
±± 
class
±± 
{
≤≤ 
long
¥¥ 
p20
¥¥ 
,
¥¥ 
p21
¥¥ 
,
¥¥ 
p22
¥¥ 
,
¥¥ 
p23
¥¥ 
,
¥¥  
p24
¥¥! $
,
¥¥$ %
p25
¥¥& )
,
¥¥) *
p26
¥¥+ .
;
¥¥. /
long
µµ 
p30
µµ 
,
µµ 
p31
µµ 
,
µµ 
p32
µµ 
,
µµ 
p33
µµ 
,
µµ  
p34
µµ! $
,
µµ$ %
p35
µµ& )
,
µµ) *
p36
µµ+ .
,
µµ. /
p37
µµ0 3
;
µµ3 4
	protected
∏∏ !
MpscArrayQueueL2Pad
∏∏ %
(
∏∏% &
int
∏∏& )
capacity
∏∏* 2
)
∏∏2 3
:
ππ 
base
ππ 
(
ππ 
capacity
ππ 
)
ππ 
{
∫∫ 	
}
ªª 	
}
ºº 
abstract
ææ 
class
ææ )
MpscArrayQueueConsumerField
ææ .
<
ææ. /
T
ææ/ 0
>
ææ0 1
:
ææ2 3!
MpscArrayQueueL2Pad
ææ4 G
<
ææG H
T
ææH I
>
ææI J
where
øø 
T
øø 
:
øø 
class
øø 
{
¿¿ 
long
¡¡ 
consumerIndex
¡¡ 
;
¡¡ 
	protected
√√ )
MpscArrayQueueConsumerField
√√ -
(
√√- .
int
√√. 1
capacity
√√2 :
)
√√: ;
:
ƒƒ 
base
ƒƒ 
(
ƒƒ 
capacity
ƒƒ 
)
ƒƒ 
{
≈≈ 	
}
∆∆ 	
	protected
»» 
long
»» 
ConsumerIndex
»» $
{
…… 	
get
   
{
   
return
   
Volatile
   !
.
  ! "
Read
  " &
(
  & '
ref
  ' *
this
  + /
.
  / 0
consumerIndex
  0 =
)
  = >
;
  > ?
}
  @ A
set
ÀÀ 
{
ÀÀ 
Volatile
ÀÀ 
.
ÀÀ 
Write
ÀÀ  
(
ÀÀ  !
ref
ÀÀ! $
this
ÀÀ% )
.
ÀÀ) *
consumerIndex
ÀÀ* 7
,
ÀÀ7 8
value
ÀÀ9 >
)
ÀÀ> ?
;
ÀÀ? @
}
ÀÀA B
}
ÃÃ 	
}
ÕÕ 
}ŒŒ ©
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\Platform.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public		 

static		 
class		 
Platform		  
{

 
public 
static 
int 
GetCurrentProcessId -
(- .
). /
=>0 2
PlatformProvider3 C
.C D
PlatformD L
.L M
GetCurrentProcessIdM `
(` a
)a b
;b c
public 
static 
byte 
[ 
] 
GetDefaultDeviceId /
(/ 0
)0 1
=>2 4
PlatformProvider5 E
.E F
PlatformF N
.N O
GetDefaultDeviceIdO a
(a b
)b c
;c d
} 
} ª⁄
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\PlatformDependent.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

static 
class 
PlatformDependent )
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
PlatformDependentZ k
)k l
)l m
;m n
static 
readonly 
bool 
UseDirectBuffer ,
;, -
static 
PlatformDependent  
(  !
)! "
{ 	
UseDirectBuffer 
= 
! 
SystemPropertyUtil 1
.1 2

GetBoolean2 <
(< =
$str= V
,V W
trueX \
)\ ]
;] ^
if 
( 
Logger 
. 
DebugEnabled #
)# $
{ 
Logger 
. 
Debug 
( 
$str <
,< =
!> ?
UseDirectBuffer? N
)N O
;O P
} 
} 	
public!! 
static!! 
bool!! !
DirectBufferPreferred!! 0
=>!!1 3
UseDirectBuffer!!4 C
;!!C D
static## 
int## 
seed## 
=## 
(## 
int## 
)## 
(##  
	Stopwatch##  )
.##) *
GetTimestamp##* 6
(##6 7
)##7 8
&##9 :
$num##; E
)##E F
;##F G
static$$ 
readonly$$ 
ThreadLocal$$ #
<$$# $
Random$$$ *
>$$* +
ThreadLocalRandom$$, =
=$$> ?
new$$@ C
ThreadLocal$$D O
<$$O P
Random$$P V
>$$V W
($$W X
($$X Y
)$$Y Z
=>$$[ ]
new$$^ a
Random$$b h
($$h i
Interlocked$$i t
.$$t u
	Increment$$u ~
($$~ 
ref	$$ Ç
seed
$$É á
)
$$á à
)
$$à â
)
$$â ä
;
$$ä ã
static%% 
readonly%% 
bool%% 
IsLittleEndian%% +
=%%, -
BitConverter%%. :
.%%: ;
IsLittleEndian%%; I
;%%I J
public'' 
static'' 
IQueue'' 
<'' 
T'' 
>'' 
NewFixedMpscQueue''  1
<''1 2
T''2 3
>''3 4
(''4 5
int''5 8
capacity''9 A
)''A B
where''C H
T''I J
:''K L
class''M R
=>''S U
new''V Y
MpscArrayQueue''Z h
<''h i
T''i j
>''j k
(''k l
capacity''l t
)''t u
;''u v
public)) 
static)) 
IQueue)) 
<)) 
T)) 
>)) 
NewMpscQueue))  ,
<)), -
T))- .
>)). /
())/ 0
)))0 1
where))2 7
T))8 9
:)): ;
class))< A
=>))B D
new))E H%
CompatibleConcurrentQueue))I b
<))b c
T))c d
>))d e
())e f
)))f g
;))g h
public++ 
static++ 
IDictionary++ !
<++! "
TKey++" &
,++& '
TValue++( .
>++. / 
NewConcurrentHashMap++0 D
<++D E
TKey++E I
,++I J
TValue++K Q
>++Q R
(++R S
)++S T
=>++U W
new++X [ 
ConcurrentDictionary++\ p
<++p q
TKey++q u
,++u v
TValue++w }
>++} ~
(++~ 
)	++ Ä
;
++Ä Å
public-- 
static-- 
ILinkedQueue-- "
<--" #
T--# $
>--$ %
NewSpscLinkedQueue--& 8
<--8 9
T--9 :
>--: ;
(--; <
)--< =
where--> C
T--D E
:--F G
class--H M
=>--N P
new--Q T
SpscLinkedQueue--U d
<--d e
T--e f
>--f g
(--g h
)--h i
;--i j
public// 
static// 
Random//  
GetThreadLocalRandom// 1
(//1 2
)//2 3
=>//4 6
ThreadLocalRandom//7 H
.//H I
Value//I N
;//N O
public11 
static11 
unsafe11 
bool11 !
ByteArrayEquals11" 1
(111 2
byte112 6
[116 7
]117 8
bytes1119 ?
,11? @
int11A D
	startPos111E N
,11N O
byte11P T
[11T U
]11U V
bytes211W ]
,11] ^
int11_ b
	startPos211c l
,11l m
int11n q
length11r x
)11x y
{22 	
if33 
(33 
length33 
<=33 
$num33 
)33 
{44 
return55 
true55 
;55 
}66 
fixed88 
(88 
byte88 
*88 
array188 
=88  !
&88" #
bytes188# )
[88) *
	startPos188* 3
]883 4
)884 5
fixed99 
(99 
byte99 
*99 
array299 #
=99$ %
&99& '
bytes299' -
[99- .
	startPos299. 7
]997 8
)998 9
return:: 
PlatformDependent0:: -
.::- .
ByteArrayEquals::. =
(::= >
array1::> D
,::D E
array2::F L
,::L M
length::N T
)::T U
;::U V
};; 	
[== 	

MethodImpl==	 
(== 
MethodImplOptions== %
.==% &
AggressiveInlining==& 8
)==8 9
]==9 :
public>> 
static>> 
unsafe>> 
int>>  
HashCodeAscii>>! .
(>>. /
byte>>/ 3
[>>3 4
]>>4 5
bytes>>6 ;
,>>; <
int>>= @
startPos>>A I
,>>I J
int>>K N
length>>O U
)>>U V
{?? 	
if@@ 
(@@ 
length@@ 
==@@ 
$num@@ 
)@@ 
{AA 
returnBB 
HashCodeAsciiSeedBB (
;BB( )
}CC 
fixedEE 
(EE 
byteEE 
*EE 
arrayEE 
=EE  
&EE! "
bytesEE" '
[EE' (
startPosEE( 0
]EE0 1
)EE1 2
returnFF 
PlatformDependent0FF )
.FF) *
HashCodeAsciiFF* 7
(FF7 8
arrayFF8 =
,FF= >
lengthFF? E
)FFE F
;FFF G
}GG 	
publicII 
staticII 
intII 
HashCodeAsciiII '
(II' (
ICharSequenceII( 5
bytesII6 ;
)II; <
{JJ 	
intKK 
hashKK 
=KK 
HashCodeAsciiSeedKK (
;KK( )
intLL 
remainingBytesLL 
=LL  
bytesLL! &
.LL& '
CountLL' ,
&LL- .
$numLL/ 0
;LL0 1
switchQQ 
(QQ 
bytesQQ 
.QQ 
CountQQ 
)QQ  
{RR 
caseSS 
$numSS 
:SS 
caseTT 
$numTT 
:TT 
caseUU 
$numUU 
:UU 
caseVV 
$numVV 
:VV 
caseWW 
$numWW 
:WW 
caseXX 
$numXX 
:XX 
caseYY 
$numYY 
:YY 
caseZZ 
$numZZ 
:ZZ 
hash[[ 
=[[  
HashCodeAsciiCompute[[ /
([[/ 0
bytes\\ 
,\\ 
bytes]] 
.]] 
Count]] #
-]]$ %
$num]]& (
,]]( ) 
HashCodeAsciiCompute^^ ,
(^^, -
bytes__ !
,__! "
bytes`` !
.``! "
Count``" '
-``( )
$num``* ,
,``, - 
HashCodeAsciiComputeaa 0
(aa0 1
bytesaa1 6
,aa6 7
bytesaa8 =
.aa= >
Countaa> C
-aaD E
$numaaF G
,aaG H
hashaaI M
)aaM N
)aaN O
)aaO P
;aaP Q
breakbb 
;bb 
casecc 
$numcc 
:cc 
casedd 
$numdd 
:dd 
caseee 
$numee 
:ee 
caseff 
$numff 
:ff 
casegg 
$numgg 
:gg 
casehh 
$numhh 
:hh 
caseii 
$numii 
:ii 
casejj 
$numjj 
:jj 
hashkk 
=kk  
HashCodeAsciiComputekk /
(kk/ 0
bytesll 
,ll 
bytesmm 
.mm 
Countmm #
-mm$ %
$nummm& (
,mm( ) 
HashCodeAsciiComputenn ,
(nn, -
bytesnn- 2
,nn2 3
bytesnn4 9
.nn9 :
Countnn: ?
-nn@ A
$numnnB C
,nnC D
hashnnE I
)nnI J
)nnJ K
;nnK L
breakoo 
;oo 
casepp 
$numpp 
:pp 
caseqq 
$numqq 
:qq 
caserr 
$numrr 
:rr 
casess 
$numss 
:ss 
casett 
$numtt 
:tt 
caseuu 
$numuu 
:uu 
casevv 
$numvv 
:vv 
caseww 
$numww 
:ww 
hashxx 
=xx  
HashCodeAsciiComputexx /
(xx/ 0
bytesxx0 5
,xx5 6
bytesxx7 <
.xx< =
Countxx= B
-xxC D
$numxxE F
,xxF G
hashxxH L
)xxL M
;xxM N
breakyy 
;yy 
casezz 
$numzz 
:zz 
case{{ 
$num{{ 
:{{ 
case|| 
$num|| 
:|| 
case}} 
$num}} 
:}} 
case~~ 
$num~~ 
:~~ 
case 
$num 
: 
case
ÄÄ 
$num
ÄÄ 
:
ÄÄ 
case
ÅÅ 
$num
ÅÅ 
:
ÅÅ 
break
ÇÇ 
;
ÇÇ 
default
ÉÉ 
:
ÉÉ 
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
=
ÑÑ  
bytes
ÑÑ! &
.
ÑÑ& '
Count
ÑÑ' ,
-
ÑÑ- .
$num
ÑÑ/ 0
;
ÑÑ0 1
i
ÑÑ2 3
>=
ÑÑ4 6
remainingBytes
ÑÑ7 E
;
ÑÑE F
i
ÑÑG H
-=
ÑÑI K
$num
ÑÑL M
)
ÑÑM N
{
ÖÖ 
hash
ÜÜ 
=
ÜÜ "
HashCodeAsciiCompute
ÜÜ 3
(
ÜÜ3 4
bytes
ÜÜ4 9
,
ÜÜ9 :
i
ÜÜ; <
,
ÜÜ< =
hash
ÜÜ> B
)
ÜÜB C
;
ÜÜC D
}
áá 
break
àà 
;
àà 
}
ââ 
switch
ää 
(
ää 
remainingBytes
ää "
)
ää" #
{
ãã 
case
åå 
$num
åå 
:
åå 
return
çç 
(
çç 
(
çç 
hash
çç !
*
éé 

HashCodeC1
éé $
+
éé% &'
HashCodeAsciiSanitizsByte
éé' @
(
éé@ A
bytes
ééA F
[
ééF G
$num
ééG H
]
ééH I
)
ééI J
)
ééJ K
*
èè 

HashCodeC2
èè $
+
èè% &(
HashCodeAsciiSanitizeShort
èè' A
(
èèA B
bytes
èèB G
,
èèG H
$num
èèI J
)
èèJ K
)
èèK L
*
êê 

HashCodeC1
êê $
+
êê% &&
HashCodeAsciiSanitizeInt
êê' ?
(
êê? @
bytes
êê@ E
,
êêE F
$num
êêG H
)
êêH I
;
êêI J
case
ëë 
$num
ëë 
:
ëë 
return
íí 
(
íí 
hash
íí  
*
ìì 

HashCodeC1
ìì $
+
ìì% &(
HashCodeAsciiSanitizeShort
ìì' A
(
ììA B
bytes
ììB G
,
ììG H
$num
ììI J
)
ììJ K
)
ììK L
*
îî 

HashCodeC2
îî $
+
îî% &&
HashCodeAsciiSanitizeInt
îî' ?
(
îî? @
bytes
îî@ E
,
îîE F
$num
îîG H
)
îîH I
;
îîI J
case
ïï 
$num
ïï 
:
ïï 
return
ññ 
(
ññ 
hash
ññ  
*
óó 

HashCodeC1
óó $
+
óó% &'
HashCodeAsciiSanitizsByte
óó' @
(
óó@ A
bytes
óóA F
[
óóF G
$num
óóG H
]
óóH I
)
óóI J
)
óóJ K
*
òò 

HashCodeC2
òò $
+
òò% &&
HashCodeAsciiSanitizeInt
òò' ?
(
òò? @
bytes
òò@ E
,
òòE F
$num
òòG H
)
òòH I
;
òòI J
case
ôô 
$num
ôô 
:
ôô 
return
öö 
hash
öö 
*
õõ 

HashCodeC1
õõ $
+
õõ% &&
HashCodeAsciiSanitizeInt
õõ' ?
(
õõ? @
bytes
õõ@ E
,
õõE F
$num
õõG H
)
õõH I
;
õõI J
case
úú 
$num
úú 
:
úú 
return
ùù 
(
ùù 
hash
ùù  
*
ûû 

HashCodeC1
ûû $
+
ûû% &'
HashCodeAsciiSanitizsByte
ûû' @
(
ûû@ A
bytes
ûûA F
[
ûûF G
$num
ûûG H
]
ûûH I
)
ûûI J
)
ûûJ K
*
üü 

HashCodeC2
üü $
+
üü% &(
HashCodeAsciiSanitizeShort
üü' A
(
üüA B
bytes
üüB G
,
üüG H
$num
üüI J
)
üüJ K
;
üüK L
case
†† 
$num
†† 
:
†† 
return
°° 
hash
°° 
*
¢¢ 

HashCodeC1
¢¢ $
+
¢¢% &(
HashCodeAsciiSanitizeShort
¢¢' A
(
¢¢A B
bytes
¢¢B G
,
¢¢G H
$num
¢¢I J
)
¢¢J K
;
¢¢K L
case
££ 
$num
££ 
:
££ 
return
§§ 
hash
§§ 
*
•• 

HashCodeC1
•• $
+
••% &'
HashCodeAsciiSanitizsByte
••' @
(
••@ A
bytes
••A F
[
••F G
$num
••G H
]
••H I
)
••I J
;
••J K
default
¶¶ 
:
¶¶ 
return
ßß 
hash
ßß 
;
ßß  
}
®® 
}
©© 	
[
´´ 	

MethodImpl
´´	 
(
´´ 
MethodImplOptions
´´ %
.
´´% & 
AggressiveInlining
´´& 8
)
´´8 9
]
´´9 :
static
¨¨ 
int
¨¨ "
HashCodeAsciiCompute
¨¨ '
(
¨¨' (
ICharSequence
¨¨( 5
value
¨¨6 ;
,
¨¨; <
int
¨¨= @
offset
¨¨A G
,
¨¨G H
int
¨¨I L
hash
¨¨M Q
)
¨¨Q R
{
≠≠ 	
if
ÆÆ 
(
ÆÆ 
!
ÆÆ 
IsLittleEndian
ÆÆ 
)
ÆÆ  
{
ØØ 
return
∞∞ 
hash
∞∞ 
*
∞∞ 

HashCodeC1
∞∞ (
+
∞∞) *&
HashCodeAsciiSanitizeInt
≤≤ ,
(
≤≤, -
value
≤≤- 2
,
≤≤2 3
offset
≤≤4 :
+
≤≤; <
$num
≤≤= >
)
≤≤> ?
*
≤≤@ A

HashCodeC2
≤≤B L
+
≤≤M N&
HashCodeAsciiSanitizeInt
¥¥ ,
(
¥¥, -
value
¥¥- 2
,
¥¥2 3
offset
¥¥4 :
)
¥¥: ;
;
¥¥; <
}
µµ 
return
∂∂ 
hash
∂∂ 
*
∂∂ 

HashCodeC1
∂∂ $
+
∂∂% &&
HashCodeAsciiSanitizeInt
∏∏ (
(
∏∏( )
value
∏∏) .
,
∏∏. /
offset
∏∏0 6
)
∏∏6 7
*
∏∏8 9

HashCodeC2
∏∏: D
+
∏∏E F&
HashCodeAsciiSanitizeInt
∫∫ (
(
∫∫( )
value
∫∫) .
,
∫∫. /
offset
∫∫0 6
+
∫∫7 8
$num
∫∫9 :
)
∫∫: ;
;
∫∫; <
}
ªª 	
[
ΩΩ 	

MethodImpl
ΩΩ	 
(
ΩΩ 
MethodImplOptions
ΩΩ %
.
ΩΩ% & 
AggressiveInlining
ΩΩ& 8
)
ΩΩ8 9
]
ΩΩ9 :
static
ææ 
int
ææ &
HashCodeAsciiSanitizeInt
ææ +
(
ææ+ ,
ICharSequence
ææ, 9
value
ææ: ?
,
ææ? @
int
ææA D
offset
ææE K
)
ææK L
{
øø 	
if
¿¿ 
(
¿¿ 
!
¿¿ 
IsLittleEndian
¿¿ 
)
¿¿  
{
¡¡ 
return
√√ 
(
√√ 
value
√√ 
[
√√ 
offset
√√ $
+
√√% &
$num
√√' (
]
√√( )
&
√√* +
$num
√√, 0
)
√√0 1
|
ƒƒ 
(
ƒƒ 
value
ƒƒ 
[
ƒƒ 
offset
ƒƒ #
+
ƒƒ$ %
$num
ƒƒ& '
]
ƒƒ' (
&
ƒƒ) *
$num
ƒƒ+ /
)
ƒƒ/ 0
<<
ƒƒ1 3
$num
ƒƒ4 5
|
≈≈ 
(
≈≈ 
value
≈≈ 
[
≈≈ 
offset
≈≈ #
+
≈≈$ %
$num
≈≈& '
]
≈≈' (
&
≈≈) *
$num
≈≈+ /
)
≈≈/ 0
<<
≈≈1 3
$num
≈≈4 6
|
∆∆ 
(
∆∆ 
value
∆∆ 
[
∆∆ 
offset
∆∆ #
]
∆∆# $
&
∆∆% &
$num
∆∆' +
)
∆∆+ ,
<<
∆∆- /
$num
∆∆0 2
;
∆∆2 3
}
«« 
return
…… 
(
…… 
value
…… 
[
…… 
offset
……  
+
……! "
$num
……# $
]
……$ %
&
……& '
$num
……( ,
)
……, -
<<
……. 0
$num
……1 3
|
   
(
   
value
   
[
   
offset
   
+
    !
$num
  " #
]
  # $
&
  % &
$num
  ' +
)
  + ,
<<
  - /
$num
  0 2
|
ÀÀ 
(
ÀÀ 
value
ÀÀ 
[
ÀÀ 
offset
ÀÀ 
+
ÀÀ  !
$num
ÀÀ" #
]
ÀÀ# $
&
ÀÀ% &
$num
ÀÀ' +
)
ÀÀ+ ,
<<
ÀÀ- /
$num
ÀÀ0 1
|
ÃÃ 
(
ÃÃ 
value
ÃÃ 
[
ÃÃ 
offset
ÃÃ 
]
ÃÃ  
&
ÃÃ! "
$num
ÃÃ# '
)
ÃÃ' (
;
ÃÃ( )
}
ÕÕ 	
[
œœ 	

MethodImpl
œœ	 
(
œœ 
MethodImplOptions
œœ %
.
œœ% & 
AggressiveInlining
œœ& 8
)
œœ8 9
]
œœ9 :
static
–– 
int
–– (
HashCodeAsciiSanitizeShort
–– -
(
––- .
ICharSequence
––. ;
value
––< A
,
––A B
int
––C F
offset
––G M
)
––M N
{
—— 	
if
““ 
(
““ 
!
““ 
IsLittleEndian
““ 
)
““  
{
”” 
return
’’ 
(
’’ 
value
’’ 
[
’’ 
offset
’’ $
+
’’% &
$num
’’' (
]
’’( )
&
’’* +
$num
’’, 0
)
’’0 1
|
÷÷ 
(
÷÷ 
value
÷÷ 
[
÷÷ 
offset
÷÷ #
]
÷÷# $
&
÷÷% &
$num
÷÷' +
)
÷÷+ ,
<<
÷÷- /
$num
÷÷0 1
;
÷÷1 2
}
◊◊ 
return
ŸŸ 
(
ŸŸ 
value
ŸŸ 
[
ŸŸ 
offset
ŸŸ  
+
ŸŸ! "
$num
ŸŸ# $
]
ŸŸ$ %
&
ŸŸ& '
$num
ŸŸ( ,
)
ŸŸ, -
<<
ŸŸ. 0
$num
ŸŸ1 2
|
⁄⁄ 
(
⁄⁄ 
value
⁄⁄ 
[
⁄⁄ 
offset
⁄⁄ 
]
⁄⁄  
&
⁄⁄! "
$num
⁄⁄# '
)
⁄⁄' (
;
⁄⁄( )
}
€€ 	
[
›› 	

MethodImpl
››	 
(
›› 
MethodImplOptions
›› %
.
››% & 
AggressiveInlining
››& 8
)
››8 9
]
››9 :
static
ﬁﬁ 
int
ﬁﬁ '
HashCodeAsciiSanitizsByte
ﬁﬁ ,
(
ﬁﬁ, -
char
ﬁﬁ- 1
value
ﬁﬁ2 7
)
ﬁﬁ7 8
=>
ﬁﬁ9 ;
value
ﬁﬁ< A
&
ﬁﬁB C
$num
ﬁﬁD H
;
ﬁﬁH I
public
‡‡ 
static
‡‡ 
void
‡‡ 

CopyMemory
‡‡ %
(
‡‡% &
byte
‡‡& *
[
‡‡* +
]
‡‡+ ,
src
‡‡- 0
,
‡‡0 1
int
‡‡2 5
srcIndex
‡‡6 >
,
‡‡> ?
byte
‡‡@ D
[
‡‡D E
]
‡‡E F
dst
‡‡G J
,
‡‡J K
int
‡‡L O
dstIndex
‡‡P X
,
‡‡X Y
int
‡‡Z ]
length
‡‡^ d
)
‡‡d e
{
·· 	
if
‚‚ 
(
‚‚ 
length
‚‚ 
>
‚‚ 
$num
‚‚ 
)
‚‚ 
{
„„ 
Unsafe
‰‰ 
.
‰‰  
CopyBlockUnaligned
‰‰ )
(
‰‰) *
ref
‰‰* -
dst
‰‰. 1
[
‰‰1 2
dstIndex
‰‰2 :
]
‰‰: ;
,
‰‰; <
ref
‰‰= @
src
‰‰A D
[
‰‰D E
srcIndex
‰‰E M
]
‰‰M N
,
‰‰N O
	unchecked
‰‰P Y
(
‰‰Y Z
(
‰‰Z [
uint
‰‰[ _
)
‰‰_ `
length
‰‰` f
)
‰‰f g
)
‰‰g h
;
‰‰h i
}
ÂÂ 
}
ÊÊ 	
public
ËË 
static
ËË 
unsafe
ËË 
void
ËË !

CopyMemory
ËË" ,
(
ËË, -
byte
ËË- 1
*
ËË1 2
src
ËË3 6
,
ËË6 7
byte
ËË8 <
*
ËË< =
dst
ËË> A
,
ËËA B
int
ËËC F
length
ËËG M
)
ËËM N
{
ÈÈ 	
if
ÍÍ 
(
ÍÍ 
length
ÍÍ 
>
ÍÍ 
$num
ÍÍ 
)
ÍÍ 
{
ÎÎ 
Unsafe
ÏÏ 
.
ÏÏ  
CopyBlockUnaligned
ÏÏ )
(
ÏÏ) *
dst
ÏÏ* -
,
ÏÏ- .
src
ÏÏ/ 2
,
ÏÏ2 3
	unchecked
ÏÏ4 =
(
ÏÏ= >
(
ÏÏ> ?
uint
ÏÏ? C
)
ÏÏC D
length
ÏÏD J
)
ÏÏJ K
)
ÏÏK L
;
ÏÏL M
}
ÌÌ 
}
ÓÓ 	
public
 
static
 
unsafe
 
void
 !

CopyMemory
" ,
(
, -
byte
- 1
*
1 2
src
3 6
,
6 7
byte
8 <
[
< =
]
= >
dst
? B
,
B C
int
D G
dstIndex
H P
,
P Q
int
R U
length
V \
)
\ ]
{
ÒÒ 	
if
ÚÚ 
(
ÚÚ 
length
ÚÚ 
>
ÚÚ 
$num
ÚÚ 
)
ÚÚ 
{
ÛÛ 
fixed
ÙÙ 
(
ÙÙ 
byte
ÙÙ 
*
ÙÙ 
destination
ÙÙ (
=
ÙÙ) *
&
ÙÙ+ ,
dst
ÙÙ, /
[
ÙÙ/ 0
dstIndex
ÙÙ0 8
]
ÙÙ8 9
)
ÙÙ9 :
Unsafe
ıı 
.
ıı  
CopyBlockUnaligned
ıı -
(
ıı- .
destination
ıı. 9
,
ıı9 :
src
ıı; >
,
ıı> ?
	unchecked
ıı@ I
(
ııI J
(
ııJ K
uint
ııK O
)
ııO P
length
ııP V
)
ııV W
)
ııW X
;
ııX Y
}
ˆˆ 
}
˜˜ 	
public
˘˘ 
static
˘˘ 
unsafe
˘˘ 
void
˘˘ !

CopyMemory
˘˘" ,
(
˘˘, -
byte
˘˘- 1
[
˘˘1 2
]
˘˘2 3
src
˘˘4 7
,
˘˘7 8
int
˘˘9 <
srcIndex
˘˘= E
,
˘˘E F
byte
˘˘G K
*
˘˘K L
dst
˘˘M P
,
˘˘P Q
int
˘˘R U
length
˘˘V \
)
˘˘\ ]
{
˙˙ 	
if
˚˚ 
(
˚˚ 
length
˚˚ 
>
˚˚ 
$num
˚˚ 
)
˚˚ 
{
¸¸ 
fixed
˝˝ 
(
˝˝ 
byte
˝˝ 
*
˝˝ 
source
˝˝ #
=
˝˝$ %
&
˝˝& '
src
˝˝' *
[
˝˝* +
srcIndex
˝˝+ 3
]
˝˝3 4
)
˝˝4 5
Unsafe
˛˛ 
.
˛˛  
CopyBlockUnaligned
˛˛ -
(
˛˛- .
dst
˛˛. 1
,
˛˛1 2
source
˛˛3 9
,
˛˛9 :
	unchecked
˛˛; D
(
˛˛D E
(
˛˛E F
uint
˛˛F J
)
˛˛J K
length
˛˛K Q
)
˛˛Q R
)
˛˛R S
;
˛˛S T
}
ˇˇ 
}
ÄÄ 	
public
ÇÇ 
static
ÇÇ 
void
ÇÇ 
Clear
ÇÇ  
(
ÇÇ  !
byte
ÇÇ! %
[
ÇÇ% &
]
ÇÇ& '
src
ÇÇ( +
,
ÇÇ+ ,
int
ÇÇ- 0
srcIndex
ÇÇ1 9
,
ÇÇ9 :
int
ÇÇ; >
length
ÇÇ? E
)
ÇÇE F
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ 
length
ÑÑ 
>
ÑÑ 
$num
ÑÑ 
)
ÑÑ 
{
ÖÖ 
Unsafe
ÜÜ 
.
ÜÜ  
InitBlockUnaligned
ÜÜ )
(
ÜÜ) *
ref
ÜÜ* -
src
ÜÜ. 1
[
ÜÜ1 2
srcIndex
ÜÜ2 :
]
ÜÜ: ;
,
ÜÜ; <
default
ÜÜ= D
(
ÜÜD E
byte
ÜÜE I
)
ÜÜI J
,
ÜÜJ K
	unchecked
ÜÜL U
(
ÜÜU V
(
ÜÜV W
uint
ÜÜW [
)
ÜÜ[ \
length
ÜÜ\ b
)
ÜÜb c
)
ÜÜc d
;
ÜÜd e
}
áá 
}
àà 	
public
ää 
static
ää 
unsafe
ää 
void
ää !
	SetMemory
ää" +
(
ää+ ,
byte
ää, 0
*
ää0 1
src
ää2 5
,
ää5 6
int
ää7 :
length
ää; A
,
ääA B
byte
ääC G
value
ääH M
)
ääM N
{
ãã 	
if
åå 
(
åå 
length
åå 
>
åå 
$num
åå 
)
åå 
{
çç 
Unsafe
éé 
.
éé  
InitBlockUnaligned
éé )
(
éé) *
src
éé* -
,
éé- .
value
éé/ 4
,
éé4 5
	unchecked
éé6 ?
(
éé? @
(
éé@ A
uint
ééA E
)
ééE F
length
ééF L
)
ééL M
)
ééM N
;
ééN O
}
èè 
}
êê 	
public
íí 
static
íí 
void
íí 
	SetMemory
íí $
(
íí$ %
byte
íí% )
[
íí) *
]
íí* +
src
íí, /
,
íí/ 0
int
íí1 4
srcIndex
íí5 =
,
íí= >
int
íí? B
length
ííC I
,
ííI J
byte
ííK O
value
ííP U
)
ííU V
{
ìì 	
if
îî 
(
îî 
length
îî 
>
îî 
$num
îî 
)
îî 
{
ïï 
Unsafe
ññ 
.
ññ  
InitBlockUnaligned
ññ )
(
ññ) *
ref
ññ* -
src
ññ. 1
[
ññ1 2
srcIndex
ññ2 :
]
ññ: ;
,
ññ; <
value
ññ= B
,
ññB C
	unchecked
ññD M
(
ññM N
(
ññN O
uint
ññO S
)
ññS T
length
ññT Z
)
ññZ [
)
ññ[ \
;
ññ\ ]
}
óó 
}
òò 	
}
ôô 
}öö ≤a
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\PlatformDependent0.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
static		 

class		 
PlatformDependent0		 #
{

 
internal 
static 
readonly  
int! $
HashCodeAsciiSeed% 6
=7 8
	unchecked9 B
(B C
(C D
intD G
)G H
$numH R
)R S
;S T
internal 
static 
readonly  
int! $

HashCodeC1% /
=0 1
	unchecked2 ;
(; <
(< =
int= @
)@ A
$numA K
)K L
;L M
internal 
static 
readonly  
int! $

HashCodeC2% /
=0 1
$num2 <
;< =
internal 
static 
unsafe 
bool #
ByteArrayEquals$ 3
(3 4
byte4 8
*8 9
bytes1: @
,@ A
byteB F
*F G
bytes2H N
,N O
intP S
lengthT Z
)Z [
{ 	
if 
( 
length 
<= 
$num 
) 
{ 
return 
true 
; 
} 
byte 
* 
baseOffset1 
= 
bytes1  &
;& '
byte 
* 
baseOffset2 
= 
bytes2  &
;& '
int 
remainingBytes 
=  
length! '
&( )
$num* +
;+ ,
byte 
* 
end 
= 
baseOffset1 #
+$ %
remainingBytes& 4
;4 5
for 
( 
byte 
* 
i 
= 
baseOffset1 &
-' (
$num) *
++ ,
length- 3
,3 4
j5 6
=7 8
baseOffset29 D
-E F
$numG H
+I J
lengthK Q
;Q R
iS T
>=U W
endX [
;[ \
i] ^
-=_ a
$numb c
,c d
je f
-=g i
$numj k
)k l
{ 
if 
( 
Unsafe 
. 
ReadUnaligned (
<( )
long) -
>- .
(. /
i/ 0
)0 1
!=2 4
Unsafe5 ;
.; <
ReadUnaligned< I
<I J
longJ N
>N O
(O P
jP Q
)Q R
)R S
{ 
return 
false  
;  !
} 
}   
if"" 
("" 
remainingBytes"" 
>="" !
$num""" #
)""# $
{## 
remainingBytes$$ 
-=$$ !
$num$$" #
;$$# $
if%% 
(%% 
Unsafe%% 
.%% 
ReadUnaligned%% (
<%%( )
int%%) ,
>%%, -
(%%- .
baseOffset1%%. 9
+%%: ;
remainingBytes%%< J
)%%J K
!=%%L N
Unsafe%%O U
.%%U V
ReadUnaligned%%V c
<%%c d
int%%d g
>%%g h
(%%h i
baseOffset2%%i t
+%%u v
remainingBytes	%%w Ö
)
%%Ö Ü
)
%%Ü á
{&& 
return'' 
false''  
;''  !
}(( 
})) 
if** 
(** 
remainingBytes** 
>=** !
$num**" #
)**# $
{++ 
return,, 
Unsafe,, 
.,, 
ReadUnaligned,, +
<,,+ ,
short,,, 1
>,,1 2
(,,2 3
baseOffset1,,3 >
),,> ?
==,,@ B
Unsafe,,C I
.,,I J
ReadUnaligned,,J W
<,,W X
short,,X ]
>,,] ^
(,,^ _
baseOffset2,,_ j
),,j k
&&-- 
(-- 
remainingBytes-- &
==--' )
$num--* +
||--, .
*--/ 0
(--0 1
bytes1--1 7
+--8 9
$num--: ;
)--; <
==--= ?
*--@ A
(--A B
bytes2--B H
+--I J
$num--K L
)--L M
)--M N
;--N O
}.. 
return// 
*// 
baseOffset1// 
==//  "
*//# $
baseOffset2//$ /
;/// 0
}00 	
[22 	

MethodImpl22	 
(22 
MethodImplOptions22 %
.22% &
AggressiveInlining22& 8
)228 9
]229 :
internal33 
static33 
unsafe33 
int33 "
HashCodeAscii33# 0
(330 1
byte331 5
*335 6
bytes337 <
,33< =
int33? B
length33C I
)33I J
{44 	
int55 
hash55 
=55 
HashCodeAsciiSeed55 (
;55( )
int66 
remainingBytes66 
=66  
length66! '
&66( )
$num66* +
;66+ ,
byte77 
*77 
end77 
=77 
bytes77 
+77 
remainingBytes77  .
;77. /
for88 
(88 
byte88 
*88 
i88 
=88 
bytes88  
-88! "
$num88# $
+88% &
length88' -
;88- .
i88/ 0
>=881 3
end884 7
;887 8
i889 :
-=88; =
$num88> ?
)88? @
{99 
hash:: 
=::  
HashCodeAsciiCompute:: +
(::+ ,
Unsafe::, 2
.::2 3
ReadUnaligned::3 @
<::@ A
long::A E
>::E F
(::F G
i::G H
)::H I
,::I J
hash::K O
)::O P
;::P Q
};; 
switch== 
(== 
remainingBytes== "
)==" #
{>> 
case?? 
$num?? 
:?? 
return@@ 
(@@ 
(@@ 
hash@@ !
*@@" #

HashCodeC1@@$ .
+@@/ 0!
HashCodeAsciiSanitize@@1 F
(@@F G
*@@G H
bytes@@H M
)@@M N
)@@N O
*AA 

HashCodeC2AA $
+AA% &!
HashCodeAsciiSanitizeAA' <
(AA< =
UnsafeAA= C
.AAC D
ReadUnalignedAAD Q
<AAQ R
shortAAR W
>AAW X
(AAX Y
bytesAAY ^
+AA_ `
$numAAa b
)AAb c
)AAc d
)AAd e
*BB 

HashCodeC1BB $
+BB% &!
HashCodeAsciiSanitizeBB' <
(BB< =
UnsafeBB= C
.BBC D
ReadUnalignedBBD Q
<BBQ R
intBBR U
>BBU V
(BBV W
bytesBBW \
+BB] ^
$numBB_ `
)BB` a
)BBa b
;BBb c
caseCC 
$numCC 
:CC 
returnDD 
(DD 
hashDD  
*DD! "

HashCodeC1DD# -
+DD. /!
HashCodeAsciiSanitizeDD0 E
(DDE F
UnsafeDDF L
.DDL M
ReadUnalignedDDM Z
<DDZ [
shortDD[ `
>DD` a
(DDa b
bytesDDb g
)DDg h
)DDh i
)DDi j
*EE 

HashCodeC2EE $
+EE% &!
HashCodeAsciiSanitizeEE' <
(EE< =
UnsafeEE= C
.EEC D
ReadUnalignedEED Q
<EEQ R
intEER U
>EEU V
(EEV W
bytesEEW \
+EE] ^
$numEE_ `
)EE` a
)EEa b
;EEb c
caseFF 
$numFF 
:FF 
returnGG 
(GG 
hashGG  
*GG! "

HashCodeC1GG# -
+GG. /!
HashCodeAsciiSanitizeGG0 E
(GGE F
*GGF G
bytesGGG L
)GGL M
)GGM N
*HH 

HashCodeC2HH $
+HH% &!
HashCodeAsciiSanitizeHH' <
(HH< =
UnsafeHH= C
.HHC D
ReadUnalignedHHD Q
<HHQ R
intHHR U
>HHU V
(HHV W
bytesHHW \
+HH] ^
$numHH_ `
)HH` a
)HHa b
;HHb c
caseII 
$numII 
:II 
returnJJ 
hashJJ 
*JJ  !

HashCodeC1JJ" ,
+JJ- .!
HashCodeAsciiSanitizeJJ/ D
(JJD E
UnsafeJJE K
.JJK L
ReadUnalignedJJL Y
<JJY Z
intJJZ ]
>JJ] ^
(JJ^ _
bytesJJ_ d
)JJd e
)JJe f
;JJf g
caseKK 
$numKK 
:KK 
returnLL 
(LL 
hashLL  
*LL! "

HashCodeC1LL# -
+LL. /!
HashCodeAsciiSanitizeLL0 E
(LLE F
*LLF G
bytesLLG L
)LLL M
)LLM N
*MM 

HashCodeC2MM $
+MM% &!
HashCodeAsciiSanitizeMM' <
(MM< =
UnsafeMM= C
.MMC D
ReadUnalignedMMD Q
<MMQ R
shortMMR W
>MMW X
(MMX Y
bytesMMY ^
+MM_ `
$numMMa b
)MMb c
)MMc d
;MMd e
caseNN 
$numNN 
:NN 
returnOO 
hashOO 
*OO  !

HashCodeC1OO" ,
+OO- .!
HashCodeAsciiSanitizeOO/ D
(OOD E
UnsafeOOE K
.OOK L
ReadUnalignedOOL Y
<OOY Z
shortOOZ _
>OO_ `
(OO` a
bytesOOa f
)OOf g
)OOg h
;OOh i
casePP 
$numPP 
:PP 
returnQQ 
hashQQ 
*QQ  !

HashCodeC1QQ" ,
+QQ- .!
HashCodeAsciiSanitizeQQ/ D
(QQD E
*QQE F
bytesQQF K
)QQK L
;QQL M
defaultRR 
:RR 
returnSS 
hashSS 
;SS  
}TT 
}UU 	
[WW 	

MethodImplWW	 
(WW 
MethodImplOptionsWW %
.WW% &
AggressiveInliningWW& 8
)WW8 9
]WW9 :
internalXX 
staticXX 
intXX  
HashCodeAsciiComputeXX 0
(XX0 1
longXX1 5
valueXX6 ;
,XX; <
intXX= @
hashXXA E
)XXE F
{YY 	
	unchecked\\ 
{]] 
return^^ 
hash^^ 
*^^ 

HashCodeC1^^ (
+^^) *!
HashCodeAsciiSanitize`` )
(``) *
(``* +
int``+ .
)``. /
value``/ 4
)``4 5
*``6 7

HashCodeC2``8 B
+``C D
(bb 
intbb 
)bb 
(bb 
valuebb 
&bb  !
$numbb" 5
)bb5 6
.bb6 7
RightUShiftbb7 B
(bbB C
$numbbC E
)bbE F
;bbF G
}cc 
}dd 	
[ff 	

MethodImplff	 
(ff 
MethodImplOptionsff %
.ff% &
AggressiveInliningff& 8
)ff8 9
]ff9 :
staticgg 
intgg !
HashCodeAsciiSanitizegg (
(gg( )
intgg) ,
valuegg- 2
)gg2 3
=>gg4 6
valuegg7 <
&gg= >
$numgg? I
;ggI J
[ii 	

MethodImplii	 
(ii 
MethodImplOptionsii %
.ii% &
AggressiveInliningii& 8
)ii8 9
]ii9 :
staticjj 
intjj !
HashCodeAsciiSanitizejj (
(jj( )
shortjj) .
valuejj/ 4
)jj4 5
=>jj6 8
valuejj: ?
&jj@ A
$numjjB H
;jjH I
[ll 	

MethodImplll	 
(ll 
MethodImplOptionsll %
.ll% &
AggressiveInliningll& 8
)ll8 9
]ll9 :
staticmm 
intmm !
HashCodeAsciiSanitizemm (
(mm( )
bytemm) -
valuemm. 3
)mm3 4
=>mm5 7
valuemm8 =
&mm> ?
$nummm@ D
;mmD E
}nn 
}oo “
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\PlatformProvider.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public

 

static

 
class

 
PlatformProvider

 (
{ 
static 
	IPlatform 
defaultPlatform (
;( )
public 
static 
	IPlatform 
Platform  (
{ 	
get 
{ 
	IPlatform 
platform "
=# $
Volatile% -
.- .
Read. 2
(2 3
ref3 6
defaultPlatform7 F
)F G
;G H
if 
( 
platform 
== 
null #
)# $
{ 
platform 
= 
new "
DefaultPlatform# 2
(2 3
)3 4
;4 5
	IPlatform 
current %
=& '
Interlocked( 3
.3 4
CompareExchange4 C
(C D
refD G
defaultPlatformH W
,W X
platformY a
,a b
nullc g
)g h
;h i
if 
( 
current 
!=  "
null# '
)' (
{ 
return 
current &
;& '
} 
} 
return 
platform 
;  
} 
set 
{   
Contract!! 
.!! 
Requires!! !
(!!! "
value!!" '
!=!!( *
null!!+ /
)!!/ 0
;!!0 1
Volatile"" 
."" 
Write"" 
("" 
ref"" "
defaultPlatform""# 2
,""2 3
value""4 9
)""9 :
;"": ;
}## 
}$$ 	
}%% 
}&& â
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\RefArrayAccessUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
static 

class 
RefArrayAccessUtil #
{ 
public 
static 
readonly 
int "
RefBufferPad# /
=0 1
$num2 4
*5 6
$num7 8
/9 :
IntPtr; A
.A B
SizeB F
;F G
public 
static 
void 
	SpElement $
<$ %
T% &
>& '
(' (
T( )
[) *
]* +
buffer, 2
,2 3
long4 8
offset9 ?
,? @
TA B
eC D
)D E
=>F H
bufferI O
[O P
offsetP V
]V W
=X Y
eZ [
;[ \
public 
static 
void 
	SoElement $
<$ %
T% &
>& '
(' (
T( )
[) *
]* +
buffer, 2
,2 3
long4 8
offset9 ?
,? @
TA B
eC D
)D E
whereF K
TL M
:N O
classP U
=>V X
VolatileY a
.a b
Writeb g
(g h
refh k
bufferl r
[r s
offsets y
]y z
,z {
e| }
)} ~
;~ 
public## 
static## 
T## 
	LpElement## !
<##! "
T##" #
>### $
(##$ %
T##% &
[##& '
]##' (
buffer##) /
,##/ 0
long##1 5
offset##6 <
)##< =
=>##> @
buffer##A G
[##G H
offset##H N
]##N O
;##O P
public,, 
static,, 
T,, 
	LvElement,, !
<,,! "
T,," #
>,,# $
(,,$ %
T,,% &
[,,& '
],,' (
buffer,,) /
,,,/ 0
long,,1 5
offset,,6 <
),,< =
where,,> C
T,,D E
:,,F G
class,,H M
=>,,N P
Volatile,,Q Y
.,,Y Z
Read,,Z ^
(,,^ _
ref,,_ b
buffer,,c i
[,,i j
offset,,j p
],,p q
),,q r
;,,r s
public44 
static44 
long44 
CalcElementOffset44 ,
(44, -
long44- 1
index442 7
,447 8
long449 =
mask44> B
)44B C
=>44D F
RefBufferPad44G S
+44T U
(44V W
index44W \
&44] ^
mask44_ c
)44c d
;44d e
}55 
}66 ÓÄ
jC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\SpscLinkedQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
sealed		 

class		 
SpscLinkedQueue		  
<		  !
T		! "
>		" #
:		$ %
BaseLinkedQueue		& 5
<		5 6
T		6 7
>		7 8
,		8 9
ILinkedQueue		: F
<		F G
T		G H
>		H I
where

 
T

 
:

 
class

 
{ 
public 
SpscLinkedQueue 
( 
)  
{ 	
this 
. 
SpProducerNode 
(  
new  #
LinkedQueueNode$ 3
<3 4
T4 5
>5 6
(6 7
)7 8
)8 9
;9 :
this 
. 
SpConsumerNode 
(  
this  $
.$ %
ProducerNode% 1
)1 2
;2 3
this 
. 
ConsumerNode 
. 
SoNext $
($ %
null% )
)) *
;* +
} 	
public 
override 
bool 
Offer "
(" #
T# $
e% &
)& '
{ 	
Contract 
. 
Requires 
( 
e 
!=  "
null# '
)' (
;( )
var 
nextNode 
= 
new 
LinkedQueueNode .
<. /
T/ 0
>0 1
(1 2
e2 3
)3 4
;4 5
LinkedQueueNode 
< 
T 
> 
producerNode +
=, -
this. 2
.2 3
LpProducerNode3 A
(A B
)B C
;C D
producerNode 
. 
SoNext 
(  
nextNode  (
)( )
;) *
this 
. 
SpProducerNode 
(  
nextNode  (
)( )
;) *
return 
true 
; 
} 	
public 
override 
T 
Poll 
( 
)  
=>! #
this$ (
.( )
RelaxedPoll) 4
(4 5
)5 6
;6 7
public!! 
override!! 
T!! 
Peek!! 
(!! 
)!!  
=>!!! #
this!!$ (
.!!( )
RelaxedPeek!!) 4
(!!4 5
)!!5 6
;!!6 7
public## 
override## 
void## 
Clear## "
(##" #
)### $
{$$ 	
T%% 
value%% 
;%% 
do&& 
{'' 
value(( 
=(( 
this(( 
.(( 
Poll(( !
(((! "
)((" #
;((# $
})) 
while** 
(** 
null** 
!=** 
value**  
)**  !
;**! "
}++ 	
},, 
abstract.. 
class.. 
BaseLinkedQueue.. "
<.." #
T..# $
>..$ %
:..& '*
BaseLinkedQueueConsumerNodeRef..( F
<..F G
T..G H
>..H I
where// 
T// 
:// 
class// 
{00 
	protected11 
T11 
RelaxedPoll11 
(11  
)11  !
{22 	
LinkedQueueNode33 
<33 
T33 
>33 
currConsumerNode33 /
=330 1
this332 6
.336 7
LpConsumerNode337 E
(33E F
)33F G
;33G H
LinkedQueueNode44 
<44 
T44 
>44 
nextNode44 '
=44( )
currConsumerNode44* :
.44: ;
LvNext44; A
(44A B
)44B C
;44C D
return55 
nextNode55 
!=55 
null55 #
?66 
this66 
.66 &
GetSingleConsumerNodeValue66 1
(661 2
currConsumerNode662 B
,66B C
nextNode66D L
)66L M
:77 
null77 
;77 
}88 	
	protected:: 
T:: 
RelaxedPeek:: 
(::  
)::  !
{;; 	
LinkedQueueNode<< 
<<< 
T<< 
><< 
currConsumerNode<< /
=<<0 1
this<<2 6
.<<6 7
ConsumerNode<<7 C
;<<C D
LinkedQueueNode== 
<== 
T== 
>== 
nextNode== '
===( )
currConsumerNode==* :
.==: ;
LvNext==; A
(==A B
)==B C
;==C D
return?? 
nextNode?? 
??? 
.?? 
LpValue?? $
(??$ %
)??% &
;??& '
}@@ 	
	protectedBB 
TBB &
GetSingleConsumerNodeValueBB .
(BB. /
LinkedQueueNodeBB/ >
<BB> ?
TBB? @
>BB@ A
currConsumerNodeBBB R
,BBR S
LinkedQueueNodeBBT c
<BBc d
TBBd e
>BBe f
nextNodeBBg o
)BBo p
{CC 	
TEE 
	nextValueEE 
=EE 
nextNodeEE "
.EE" #
GetAndNullValueEE# 2
(EE2 3
)EE3 4
;EE4 5
currConsumerNodeJJ 
.JJ 
SoNextJJ #
(JJ# $
currConsumerNodeJJ$ 4
)JJ4 5
;JJ5 6
thisKK 
.KK 
SpConsumerNodeKK 
(KK  
nextNodeKK  (
)KK( )
;KK) *
returnNN 
	nextValueNN 
;NN 
}OO 	
publicQQ 
sealedQQ 
overrideQQ 
intQQ "
CountQQ# (
{RR 	
getSS 
{TT 
LinkedQueueNodeWW 
<WW  
TWW  !
>WW! "

chaserNodeWW# -
=WW. /
thisWW0 4
.WW4 5
LvConsumerNodeWW5 C
(WWC D
)WWD E
;WWE F
LinkedQueueNodeXX 
<XX  
TXX  !
>XX! "
producerNodeXX# /
=XX0 1
thisXX2 6
.XX6 7
LvProducerNodeXX7 E
(XXE F
)XXF G
;XXG H
intYY 
sizeYY 
=YY 
$numYY 
;YY 
while[[ 
([[ 

chaserNode[[ !
!=[[" $
producerNode[[% 1
&&[[2 4

chaserNode\\ 
!=\\ !
null\\" &
&&\\' )
size]] 
<]] 
int]] 
.]] 
MaxValue]] '
)]]' (
{^^ 
LinkedQueueNode__ #
<__# $
T__$ %
>__% &
next__' +
=__, -

chaserNode__. 8
.__8 9
LvNext__9 ?
(__? @
)__@ A
;__A B
ifaa 
(aa 
nextaa 
==aa 

chaserNodeaa  *
)aa* +
{bb 
returncc 
sizecc #
;cc# $
}dd 

chaserNodeee 
=ee  
nextee! %
;ee% &
sizeff 
++ff 
;ff 
}gg 
returnhh 
sizehh 
;hh 
}ii 
}jj 	
publicll 
sealedll 
overridell 
boolll #
IsEmptyll$ +
=>ll, .
thisll/ 3
.ll3 4
LvConsumerNodell4 B
(llB C
)llC D
==llE G
thisllH L
.llL M
LvProducerNodellM [
(ll[ \
)ll\ ]
;ll] ^
}mm 
abstractoo 
classoo *
BaseLinkedQueueConsumerNodeRefoo 1
<oo1 2
Too2 3
>oo3 4
:oo5 6
BaseLinkedQueuePad1oo7 J
<ooJ K
TooK L
>ooL M
wherepp 
Tpp 
:pp 
classpp 
{qq 
	protectedrr 
LinkedQueueNoderr !
<rr! "
Trr" #
>rr# $
ConsumerNoderr% 1
;rr1 2
	protectedtt 
voidtt 
SpConsumerNodett %
(tt% &
LinkedQueueNodett& 5
<tt5 6
Ttt6 7
>tt7 8
nodett9 =
)tt= >
=>tt? A
thisttB F
.ttF G
ConsumerNodettG S
=ttT U
nodettV Z
;ttZ [
	protectedvv 
LinkedQueueNodevv !
<vv! "
Tvv" #
>vv# $
LvConsumerNodevv% 3
(vv3 4
)vv4 5
=>vv6 8
Volatilevv9 A
.vvA B
ReadvvB F
(vvF G
refvvG J
thisvvK O
.vvO P
ConsumerNodevvP \
)vv\ ]
;vv] ^
	protectedxx 
LinkedQueueNodexx !
<xx! "
Txx" #
>xx# $
LpConsumerNodexx% 3
(xx3 4
)xx4 5
=>xx6 8
thisxx9 =
.xx= >
ConsumerNodexx> J
;xxJ K
}yy 
abstract{{ 
class{{ 
BaseLinkedQueuePad1{{ &
<{{& '
T{{' (
>{{( )
:{{* +*
BaseLinkedQueueProducerNodeRef{{, J
<{{J K
T{{K L
>{{L M
where|| 
T|| 
:|| 
class|| 
{}} 
long 
p01 
, 
p02 
, 
p03 
, 
p04 
,  
p05! $
,$ %
p06& )
,) *
p07+ .
;. /
long
ÄÄ 
p10
ÄÄ 
,
ÄÄ 
p11
ÄÄ 
,
ÄÄ 
p12
ÄÄ 
,
ÄÄ 
p13
ÄÄ 
,
ÄÄ  
p14
ÄÄ! $
,
ÄÄ$ %
p15
ÄÄ& )
,
ÄÄ) *
p16
ÄÄ+ .
,
ÄÄ. /
p17
ÄÄ0 3
;
ÄÄ3 4
}
ÇÇ 
abstract
ÑÑ 
class
ÑÑ ,
BaseLinkedQueueProducerNodeRef
ÑÑ 1
<
ÑÑ1 2
T
ÑÑ2 3
>
ÑÑ3 4
:
ÑÑ5 6!
BaseLinkedQueuePad0
ÑÑ7 J
<
ÑÑJ K
T
ÑÑK L
>
ÑÑL M
where
ÖÖ 
T
ÖÖ 
:
ÖÖ 
class
ÖÖ 
{
ÜÜ 
	protected
áá 
LinkedQueueNode
áá !
<
áá! "
T
áá" #
>
áá# $
ProducerNode
áá% 1
;
áá1 2
	protected
ââ 
void
ââ 
SpProducerNode
ââ %
(
ââ% &
LinkedQueueNode
ââ& 5
<
ââ5 6
T
ââ6 7
>
ââ7 8
node
ââ9 =
)
ââ= >
=>
ââ? A
this
ââB F
.
ââF G
ProducerNode
ââG S
=
ââT U
node
ââV Z
;
ââZ [
	protected
ãã 
LinkedQueueNode
ãã !
<
ãã! "
T
ãã" #
>
ãã# $
LvProducerNode
ãã% 3
(
ãã3 4
)
ãã4 5
=>
ãã6 8
Volatile
ãã9 A
.
ããA B
Read
ããB F
(
ããF G
ref
ããG J
this
ããK O
.
ããO P
ProducerNode
ããP \
)
ãã\ ]
;
ãã] ^
	protected
çç 
LinkedQueueNode
çç !
<
çç! "
T
çç" #
>
çç# $
LpProducerNode
çç% 3
(
çç3 4
)
çç4 5
=>
çç6 8
this
çç9 =
.
çç= >
ProducerNode
çç> J
;
ççJ K
}
éé 
abstract
êê 
class
êê !
BaseLinkedQueuePad0
êê &
<
êê& '
T
êê' (
>
êê( )
where
ëë 
T
ëë 
:
ëë 
class
ëë 
{
íí 
long
îî 
p00
îî 
,
îî 
p01
îî 
,
îî 
p02
îî 
,
îî 
p03
îî 
,
îî  
p04
îî! $
,
îî$ %
p05
îî& )
,
îî) *
p06
îî+ .
,
îî. /
p07
îî0 3
;
îî3 4
long
ïï 
p10
ïï 
,
ïï 
p11
ïï 
,
ïï 
p12
ïï 
,
ïï 
p13
ïï 
,
ïï  
p14
ïï! $
,
ïï$ %
p15
ïï& )
,
ïï) *
p16
ïï+ .
;
ïï. /
public
ûû 
abstract
ûû 
bool
ûû 
Offer
ûû "
(
ûû" #
T
ûû# $
e
ûû% &
)
ûû& '
;
ûû' (
public
•• 
abstract
•• 
T
•• 
Poll
•• 
(
•• 
)
••  
;
••  !
public
¨¨ 
abstract
¨¨ 
T
¨¨ 
Peek
¨¨ 
(
¨¨ 
)
¨¨  
;
¨¨  !
public
ÆÆ 
abstract
ÆÆ 
int
ÆÆ 
Count
ÆÆ !
{
ÆÆ" #
get
ÆÆ$ '
;
ÆÆ' (
}
ÆÆ) *
public
∞∞ 
abstract
∞∞ 
bool
∞∞ 
IsEmpty
∞∞ $
{
∞∞% &
get
∞∞' *
;
∞∞* +
}
∞∞, -
public
≤≤ 
abstract
≤≤ 
void
≤≤ 
Clear
≤≤ "
(
≤≤" #
)
≤≤# $
;
≤≤$ %
}
≥≥ 
sealed
µµ 

class
µµ 
LinkedQueueNode
µµ  
<
µµ  !
T
µµ! "
>
µµ" #
where
∂∂ 
T
∂∂ 
:
∂∂ 
class
∂∂ 
{
∑∑ 
T
∏∏ 	
value
∏∏
 
;
∏∏ 
LinkedQueueNode
ππ 
<
ππ 
T
ππ 
>
ππ 
next
ππ 
;
ππ  
public
ªª 
LinkedQueueNode
ªª 
(
ªª 
)
ªª  
:
ªª! "
this
ªª# '
(
ªª' (
null
ªª( ,
)
ªª, -
{
ºº 	
}
ºº
 
public
ææ 
LinkedQueueNode
ææ 
(
ææ 
T
ææ  
value
ææ! &
)
ææ& '
{
øø 	
this
¿¿ 
.
¿¿ 
value
¿¿ 
=
¿¿ 
value
¿¿ 
;
¿¿ 
}
¡¡ 	
public
√√ 
T
√√ 
GetAndNullValue
√√  
(
√√  !
)
√√! "
{
ƒƒ 	
T
≈≈ 
temp
≈≈ 
=
≈≈ 
this
≈≈ 
.
≈≈ 
LpValue
≈≈ !
(
≈≈! "
)
≈≈" #
;
≈≈# $
this
∆∆ 
.
∆∆ 
SpValue
∆∆ 
(
∆∆ 
null
∆∆ 
)
∆∆ 
;
∆∆ 
return
«« 
temp
«« 
;
«« 
}
»» 	
public
   
T
   
LpValue
   
(
   
)
   
=>
   
this
   "
.
  " #
value
  # (
;
  ( )
public
ÃÃ 
void
ÃÃ 
SpValue
ÃÃ 
(
ÃÃ 
T
ÃÃ 
newValue
ÃÃ &
)
ÃÃ& '
=>
ÃÃ( *
this
ÃÃ+ /
.
ÃÃ/ 0
value
ÃÃ0 5
=
ÃÃ6 7
newValue
ÃÃ8 @
;
ÃÃ@ A
public
ŒŒ 
void
ŒŒ 
SoNext
ŒŒ 
(
ŒŒ 
LinkedQueueNode
ŒŒ *
<
ŒŒ* +
T
ŒŒ+ ,
>
ŒŒ, -
n
ŒŒ. /
)
ŒŒ/ 0
=>
ŒŒ1 3
Volatile
ŒŒ4 <
.
ŒŒ< =
Write
ŒŒ= B
(
ŒŒB C
ref
ŒŒC F
this
ŒŒG K
.
ŒŒK L
next
ŒŒL P
,
ŒŒP Q
n
ŒŒR S
)
ŒŒS T
;
ŒŒT U
public
–– 
LinkedQueueNode
–– 
<
–– 
T
––  
>
––  !
LvNext
––" (
(
––( )
)
––) *
=>
––+ -
Volatile
––. 6
.
––6 7
Read
––7 ;
(
––; <
ref
––< ?
this
––@ D
.
––D E
next
––E I
)
––I J
;
––J K
}
—— 
public
”” 

	interface
”” 
ILinkedQueue
”” !
<
””! "
T
””" #
>
””# $
{
‘‘ 
bool
’’ 
Offer
’’ 
(
’’ 
T
’’ 
e
’’ 
)
’’ 
;
’’ 
T
◊◊ 	
Poll
◊◊
 
(
◊◊ 
)
◊◊ 
;
◊◊ 
T
ŸŸ 	
Peek
ŸŸ
 
(
ŸŸ 
)
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
}€€ ÇE
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Internal\SystemPropertyUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
Internal "
{ 
public 

static 
class 
SystemPropertyUtil *
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
SystemPropertyUtilZ l
)l m
)m n
;n o
static 
bool 
loggedException #
;# $
public 
static 
bool 
Contains #
(# $
string$ *
key+ .
). /
=>0 2
Get3 6
(6 7
key7 :
): ;
!=< >
null? C
;C D
public 
static 
string 
Get  
(  !
string! '
key( +
)+ ,
=>- /
Get0 3
(3 4
key4 7
,7 8
null9 =
)= >
;> ?
public)) 
static)) 
string)) 
Get))  
())  !
string))! '
key))( +
,))+ ,
string))- 3
def))4 7
)))7 8
{** 	
Contract++ 
.++ 
Requires++ 
(++ 
!++ 
string++ %
.++% &
IsNullOrEmpty++& 3
(++3 4
key++4 7
)++7 8
)++8 9
;++9 :
try-- 
{.. 
return// 
Environment// "
.//" #"
GetEnvironmentVariable//# 9
(//9 :
key//: =
)//= >
??//? A
def//B E
;//E F
}00 
catch11 
(11 
	Exception11 
e11 
)11 
{22 
if33 
(33 
!33 
loggedException33 $
)33$ %
{44 
Log55 
(55 
$str55 @
+55A B
key55C F
+55G H
$str55I j
,55j k
e55l m
)55m n
;55n o
loggedException66 #
=66$ %
true66& *
;66* +
}77 
return88 
def88 
;88 
}99 
}:: 	
publicEE 
staticEE 
boolEE 

GetBooleanEE %
(EE% &
stringEE& ,
keyEE- 0
,EE0 1
boolEE2 6
defEE7 :
)EE: ;
{FF 	
stringGG 
valueGG 
=GG 
GetGG 
(GG 
keyGG "
)GG" #
;GG# $
ifHH 
(HH 
valueHH 
==HH 
nullHH 
)HH 
{II 
returnJJ 
defJJ 
;JJ 
}KK 
valueMM 
=MM 
valueMM 
.MM 
TrimMM 
(MM 
)MM  
.MM  !
ToLowerInvariantMM! 1
(MM1 2
)MM2 3
;MM3 4
ifNN 
(NN 
valueNN 
.NN 
LengthNN 
==NN 
$numNN  !
)NN! "
{OO 
returnPP 
truePP 
;PP 
}QQ 
ifSS 
(SS 
$strSS 
.SS 
EqualsSS 
(SS 
valueSS #
,SS# $
StringComparisonSS% 5
.SS5 6
OrdinalIgnoreCaseSS6 G
)SSG H
||TT 
$strTT 
.TT 
EqualsTT 
(TT  
valueTT  %
,TT% &
StringComparisonTT' 7
.TT7 8
OrdinalIgnoreCaseTT8 I
)TTI J
||UU 
$strUU 
.UU 
EqualsUU 
(UU 
valueUU #
,UU# $
StringComparisonUU% 5
.UU5 6
OrdinalUU6 =
)UU= >
)UU> ?
{VV 
returnWW 
trueWW 
;WW 
}XX 
ifZZ 
(ZZ 
$strZZ 
.ZZ 
EqualsZZ 
(ZZ 
valueZZ $
,ZZ$ %
StringComparisonZZ& 6
.ZZ6 7
OrdinalIgnoreCaseZZ7 H
)ZZH I
||[[ 
$str[[ 
.[[ 
Equals[[ 
([[ 
value[[ $
,[[$ %
StringComparison[[& 6
.[[6 7
OrdinalIgnoreCase[[7 H
)[[H I
||\\ 
$str\\ 
.\\ 
Equals\\ 
(\\ 
value\\ #
,\\# $
StringComparison\\% 5
.\\5 6
Ordinal\\6 =
)\\= >
)\\> ?
{]] 
return^^ 
false^^ 
;^^ 
}__ 
Logaa 
(aa 
$strbb ?
+bb@ A
keybbB E
+bbF G
$strbbH L
+bbM N
valuebbO T
+bbU V
$strbbW \
+bb] ^
$strcc /
+cc0 1
defcc2 5
)cc5 6
;cc6 7
returnee 
defee 
;ee 
}ff 	
publicrr 
staticrr 
intrr 
GetIntrr  
(rr  !
stringrr! '
keyrr( +
,rr+ ,
intrr- 0
defrr1 4
)rr4 5
{ss 	
stringtt 
valuett 
=tt 
Gettt 
(tt 
keytt "
)tt" #
;tt# $
ifuu 
(uu 
valueuu 
==uu 
nulluu 
)uu 
{vv 
returnww 
defww 
;ww 
}xx 
valuezz 
=zz 
valuezz 
.zz 
Trimzz 
(zz 
)zz  
.zz  !
ToLowerInvariantzz! 1
(zz1 2
)zz2 3
;zz3 4
int{{ 
result{{ 
;{{ 
if|| 
(|| 
!|| 
int|| 
.|| 
TryParse|| 
(|| 
value|| #
,||# $
out||% (
result||) /
)||/ 0
)||0 1
{}} 
result~~ 
=~~ 
def~~ 
;~~ 
Log
ÄÄ 
(
ÄÄ 
$str
ÅÅ C
+
ÅÅD E
key
ÅÅF I
+
ÅÅJ K
$str
ÅÅL P
+
ÅÅQ R
value
ÅÅS X
+
ÅÅY Z
$str
ÅÅ[ `
+
ÅÅa b
$str
ÇÇ 3
+
ÇÇ4 5
def
ÇÇ6 9
)
ÇÇ9 :
;
ÇÇ: ;
}
ÉÉ 
return
ÑÑ 
result
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
ëë 
static
ëë 
long
ëë 
GetLong
ëë "
(
ëë" #
string
ëë# )
key
ëë* -
,
ëë- .
long
ëë/ 3
def
ëë4 7
)
ëë7 8
{
íí 	
string
ìì 
value
ìì 
=
ìì 
Get
ìì 
(
ìì 
key
ìì "
)
ìì" #
;
ìì# $
if
îî 
(
îî 
value
îî 
==
îî 
null
îî 
)
îî 
{
ïï 
return
ññ 
def
ññ 
;
ññ 
}
óó 
long
ôô 
result
ôô 
;
ôô 
if
öö 
(
öö 
!
öö 
long
öö 
.
öö 
TryParse
öö 
(
öö 
value
öö $
,
öö$ %
out
öö& )
result
öö* 0
)
öö0 1
)
öö1 2
{
õõ 
result
úú 
=
úú 
def
úú 
;
úú 
Log
ùù 
(
ùù 
$str
ûû H
+
ûûI J
key
ûûK N
+
ûûO P
$str
ûûQ U
+
ûûV W
value
ûûX ]
+
ûû^ _
$str
ûû` e
+
ûûf g
$str
üü 3
+
üü4 5
def
üü6 9
)
üü9 :
;
üü: ;
}
†† 
return
°° 
result
°° 
;
°° 
}
¢¢ 	
static
§§ 
void
§§ 
Log
§§ 
(
§§ 
string
§§ 
msg
§§ "
)
§§" #
=>
§§$ &
Logger
§§' -
.
§§- .
Warn
§§. 2
(
§§2 3
msg
§§3 6
)
§§6 7
;
§§7 8
static
¶¶ 
void
¶¶ 
Log
¶¶ 
(
¶¶ 
string
¶¶ 
msg
¶¶ "
,
¶¶" #
	Exception
¶¶$ -
e
¶¶. /
)
¶¶/ 0
=>
¶¶1 3
Logger
¶¶4 :
.
¶¶: ;
Warn
¶¶; ?
(
¶¶? @
msg
¶¶@ C
,
¶¶C D
e
¶¶E F
)
¶¶F G
;
¶¶G H
}
ßß 
}®® º
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\IReferenceCounted.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public		 

	interface		 
IReferenceCounted		 &
{

 
int 
ReferenceCount 
{ 
get  
;  !
}" #
IReferenceCounted 
Retain  
(  !
)! "
;" #
IReferenceCounted 
Retain  
(  !
int! $
	increment% .
). /
;/ 0
IReferenceCounted!! 
Touch!! 
(!!  
)!!  !
;!!! "
IReferenceCounted(( 
Touch(( 
(((  
object((  &
hint((' +
)((+ ,
;((, -
bool.. 
Release.. 
(.. 
).. 
;.. 
bool55 
Release55 
(55 
int55 
	decrement55 "
)55" #
;55# $
}66 
}77 ê
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\IResourceLeakHint.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public		 

	interface		 
IResourceLeakHint		 &
{

 
string 
ToHintString 
( 
) 
; 
} 
} à
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\IResourceLeakTracker.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

	interface  
IResourceLeakTracker )
{ 
void 
Record 
( 
) 
; 
void 
Record 
( 
object 
hint 
)  
;  !
bool 
Close 
( 
object 
trackedObject '
)' (
;( )
} 
} ÖU
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\PreciseTimeSpan.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public		 

struct		 
PreciseTimeSpan		 !
:		" #
IComparable		$ /
<		/ 0
PreciseTimeSpan		0 ?
>		? @
,		@ A

IEquatable		B L
<		L M
PreciseTimeSpan		M \
>		\ ]
{

 
static 
readonly 
long 
	StartTime &
=' (
	Stopwatch) 2
.2 3
GetTimestamp3 ?
(? @
)@ A
;A B
static 
readonly 
double 
PrecisionRatio -
=. /
(0 1
double1 7
)7 8
	Stopwatch8 A
.A B
	FrequencyB K
/L M
TimeSpanN V
.V W
TicksPerSecondW e
;e f
static 
readonly 
double !
ReversePrecisionRatio 4
=5 6
(7 8
double8 >
)> ?
TimeSpan? G
.G H
TicksPerSecondH V
/W X
	StopwatchY b
.b c
	Frequencyc l
;l m
readonly 
long 
ticks 
; 
PreciseTimeSpan 
( 
long 
ticks "
)" #
: 
this 
( 
) 
{ 	
this 
. 
ticks 
= 
ticks 
; 
} 	
public 
long 
Ticks 
=> 
this !
.! "
ticks" '
;' (
public 
static 
readonly 
PreciseTimeSpan .
Zero/ 3
=4 5
new6 9
PreciseTimeSpan: I
(I J
$numJ K
)K L
;L M
public 
static 
readonly 
PreciseTimeSpan .
MinusOne/ 7
=8 9
new: =
PreciseTimeSpan> M
(M N
-N O
$numO P
)P Q
;Q R
public 
static 
PreciseTimeSpan %
	FromTicks& /
(/ 0
long0 4
ticks5 :
): ;
=>< >
new? B
PreciseTimeSpanC R
(R S
ticksS X
)X Y
;Y Z
public 
static 
PreciseTimeSpan %
	FromStart& /
=>0 2
new3 6
PreciseTimeSpan7 F
(F G#
GetTimeChangeSinceStartG ^
(^ _
)_ `
)` a
;a b
public!! 
static!! 
PreciseTimeSpan!! %
FromTimeSpan!!& 2
(!!2 3
TimeSpan!!3 ;
timeSpan!!< D
)!!D E
=>!!F H
new!!I L
PreciseTimeSpan!!M \
(!!\ ]
TicksToPreciseTicks!!] p
(!!p q
timeSpan!!q y
.!!y z
Ticks!!z 
)	!! Ä
)
!!Ä Å
;
!!Å Ç
public## 
static## 
PreciseTimeSpan## %
Deadline##& .
(##. /
TimeSpan##/ 7
deadline##8 @
)##@ A
=>##B D
new##E H
PreciseTimeSpan##I X
(##X Y#
GetTimeChangeSinceStart##Y p
(##p q
)##q r
+##s t 
TicksToPreciseTicks	##u à
(
##à â
deadline
##â ë
.
##ë í
Ticks
##í ó
)
##ó ò
)
##ò ô
;
##ô ö
public%% 
static%% 
PreciseTimeSpan%% %
Deadline%%& .
(%%. /
PreciseTimeSpan%%/ >
deadline%%? G
)%%G H
=>%%I K
new%%L O
PreciseTimeSpan%%P _
(%%_ `#
GetTimeChangeSinceStart%%` w
(%%w x
)%%x y
+%%z {
deadline	%%| Ñ
.
%%Ñ Ö
ticks
%%Ö ä
)
%%ä ã
;
%%ã å
static'' 
long'' 
TicksToPreciseTicks'' '
(''' (
long''( ,
ticks''- 2
)''2 3
=>''4 6
	Stopwatch''7 @
.''@ A
IsHighResolution''A Q
?''R S
(''T U
long''U Y
)''Y Z
(''Z [
ticks''[ `
*''a b
PrecisionRatio''c q
)''q r
:''s t
ticks''u z
;''z {
public)) 
TimeSpan)) 

ToTimeSpan)) "
())" #
)))# $
=>))% '
TimeSpan))( 0
.))0 1
	FromTicks))1 :
()): ;
()); <
long))< @
)))@ A
())A B
this))B F
.))F G
ticks))G L
*))M N!
ReversePrecisionRatio))O d
)))d e
)))e f
;))f g
static++ 
long++ #
GetTimeChangeSinceStart++ +
(+++ ,
)++, -
=>++. 0
	Stopwatch++1 :
.++: ;
GetTimestamp++; G
(++G H
)++H I
-++J K
	StartTime++L U
;++U V
public-- 
bool-- 
Equals-- 
(-- 
PreciseTimeSpan-- *
other--+ 0
)--0 1
=>--2 4
this--5 9
.--9 :
ticks--: ?
==--@ B
other--C H
.--H I
ticks--I N
;--N O
public// 
override// 
bool// 
Equals// #
(//# $
object//$ *
obj//+ .
)//. /
{00 	
if11 
(11 
obj11 
is11 
PreciseTimeSpan11 &
)11& '
{22 
return33 
this33 
.33 
Equals33 "
(33" #
(33# $
PreciseTimeSpan33$ 3
)333 4
obj334 7
)337 8
;338 9
}44 
return66 
false66 
;66 
}77 	
public99 
override99 
int99 
GetHashCode99 '
(99' (
)99( )
=>99* ,
this99- 1
.991 2
ticks992 7
.997 8
GetHashCode998 C
(99C D
)99D E
;99E F
public;; 
int;; 
	CompareTo;; 
(;; 
PreciseTimeSpan;; ,
other;;- 2
);;2 3
=>;;4 6
this;;7 ;
.;;; <
ticks;;< A
.;;A B
	CompareTo;;B K
(;;K L
other;;L Q
.;;Q R
ticks;;R W
);;W X
;;;X Y
public== 
static== 
bool== 
operator== #
====$ &
(==& '
PreciseTimeSpan==' 6
t1==7 9
,==9 :
PreciseTimeSpan==; J
t2==K M
)==M N
=>==O Q
t1==R T
.==T U
ticks==U Z
====[ ]
t2==^ `
.==` a
ticks==a f
;==f g
public?? 
static?? 
bool?? 
operator?? #
!=??$ &
(??& '
PreciseTimeSpan??' 6
t1??7 9
,??9 :
PreciseTimeSpan??; J
t2??K M
)??M N
=>??O Q
t1??R T
.??T U
ticks??U Z
!=??[ ]
t2??^ `
.??` a
ticks??a f
;??f g
publicAA 
staticAA 
boolAA 
operatorAA #
>AA$ %
(AA% &
PreciseTimeSpanAA& 5
t1AA6 8
,AA8 9
PreciseTimeSpanAA: I
t2AAJ L
)AAL M
=>AAN P
t1AAQ S
.AAS T
ticksAAT Y
>AAZ [
t2AA\ ^
.AA^ _
ticksAA_ d
;AAd e
publicCC 
staticCC 
boolCC 
operatorCC #
<CC$ %
(CC% &
PreciseTimeSpanCC& 5
t1CC6 8
,CC8 9
PreciseTimeSpanCC: I
t2CCJ L
)CCL M
=>CCN P
t1CCQ S
.CCS T
ticksCCT Y
<CCZ [
t2CC\ ^
.CC^ _
ticksCC_ d
;CCd e
publicEE 
staticEE 
boolEE 
operatorEE #
>=EE$ &
(EE& '
PreciseTimeSpanEE' 6
t1EE7 9
,EE9 :
PreciseTimeSpanEE; J
t2EEK M
)EEM N
=>EEO Q
t1EER T
.EET U
ticksEEU Z
>=EE[ ]
t2EE^ `
.EE` a
ticksEEa f
;EEf g
publicGG 
staticGG 
boolGG 
operatorGG #
<=GG$ &
(GG& '
PreciseTimeSpanGG' 6
t1GG7 9
,GG9 :
PreciseTimeSpanGG; J
t2GGK M
)GGM N
=>GGO Q
t1GGR T
.GGT U
ticksGGU Z
<=GG[ ]
t2GG^ `
.GG` a
ticksGGa f
;GGf g
publicII 
staticII 
PreciseTimeSpanII %
operatorII& .
+II/ 0
(II0 1
PreciseTimeSpanII1 @
tIIA B
,IIB C
TimeSpanIID L
durationIIM U
)IIU V
{JJ 	
longKK 
ticksKK 
=KK 
tKK 
.KK 
ticksKK  
+KK! "
TicksToPreciseTicksKK# 6
(KK6 7
durationKK7 ?
.KK? @
TicksKK@ E
)KKE F
;KKF G
returnLL 
newLL 
PreciseTimeSpanLL &
(LL& '
ticksLL' ,
)LL, -
;LL- .
}MM 	
publicOO 
staticOO 
PreciseTimeSpanOO %
operatorOO& .
-OO/ 0
(OO0 1
PreciseTimeSpanOO1 @
tOOA B
,OOB C
TimeSpanOOD L
durationOOM U
)OOU V
{PP 	
longQQ 
ticksQQ 
=QQ 
tQQ 
.QQ 
ticksQQ  
-QQ! "
TicksToPreciseTicksQQ# 6
(QQ6 7
durationQQ7 ?
.QQ? @
TicksQQ@ E
)QQE F
;QQF G
returnRR 
newRR 
PreciseTimeSpanRR &
(RR& '
ticksRR' ,
)RR, -
;RR- .
}SS 	
publicUU 
staticUU 
PreciseTimeSpanUU %
operatorUU& .
-UU/ 0
(UU0 1
PreciseTimeSpanUU1 @
t1UUA C
,UUC D
PreciseTimeSpanUUE T
t2UUU W
)UUW X
{VV 	
longWW 
ticksWW 
=WW 
t1WW 
.WW 
ticksWW !
-WW" #
t2WW$ &
.WW& '
ticksWW' ,
;WW, -
returnXX 
newXX 
PreciseTimeSpanXX &
(XX& '
ticksXX' ,
)XX, -
;XX- .
}YY 	
}ZZ 
}[[ ≤
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 
$
NeutralResourcesLanguage #
(# $
$str$ +
)+ ,
], -
[ 
assembly 	
:	 

AssemblyMetadata 
( 
$str )
,) *
$str+ 1
)1 2
]2 3¸
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Properties\Friends.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str	 Å
)
Å Ç
]
Ç Éòõ
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\ResourceLeakDetector.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

class  
ResourceLeakDetector %
{ 
const 
string 
	PropLevel 
=  
$str! ?
;? @
const 
DetectionLevel 
DefaultLevel )
=* +
DetectionLevel, :
.: ;
Simple; A
;A B
const 
string 
PropTargetRecords &
=' (
$str) O
;O P
const 
int  
DefaultTargetRecords &
=' (
$num) *
;* +
static 
readonly 
int 
TargetRecords )
;) *
public 
enum 
DetectionLevel "
{   	
Disabled$$ 
,$$ 
Simple** 
,** 
Advanced00 
,00 
Paranoid66 
}77 	
static99 
readonly99 
IInternalLogger99 '
Logger99( .
=99/ 0!
InternalLoggerFactory991 F
.99F G
GetInstance99G R
<99R S 
ResourceLeakDetector99S g
>99g h
(99h i
)99i j
;99j k
static;;  
ResourceLeakDetector;; #
(;;# $
);;$ %
{<< 	
string>> 
levelStr>> 
=>> 
SystemPropertyUtil>> 0
.>>0 1
Get>>1 4
(>>4 5
	PropLevel>>5 >
,>>> ?
DefaultLevel>>@ L
.>>L M
ToString>>M U
(>>U V
)>>V W
)>>W X
;>>X Y
if?? 
(?? 
!?? 
Enum?? 
.?? 
TryParse?? 
(?? 
levelStr?? '
,??' (
true??) -
,??- .
out??/ 2
DetectionLevel??3 A
level??B G
)??G H
)??H I
{@@ 
levelAA 
=AA 
DefaultLevelAA $
;AA$ %
}BB 
TargetRecordsDD 
=DD 
SystemPropertyUtilDD .
.DD. /
GetIntDD/ 5
(DD5 6
PropTargetRecordsDD6 G
,DDG H 
DefaultTargetRecordsDDI ]
)DD] ^
;DD^ _
LevelEE 
=EE 
levelEE 
;EE 
ifGG 
(GG 
LoggerGG 
.GG 
DebugEnabledGG #
)GG# $
{HH 
LoggerII 
.II 
DebugII 
(II 
$strII '
,II' (
	PropLevelII) 2
,II2 3
levelII4 9
.II9 :
ToStringII: B
(IIB C
)IIC D
.IID E
ToLowerIIE L
(IIL M
)IIM N
)IIN O
;IIO P
LoggerJJ 
.JJ 
DebugJJ 
(JJ 
$strJJ '
,JJ' (
PropTargetRecordsJJ) :
,JJ: ;
TargetRecordsJJ< I
)JJI J
;JJJ K
}KK 
}LL 	
constOO 
intOO #
DefaultSamplingIntervalOO )
=OO* +
$numOO, /
;OO/ 0
publicRR 
staticRR 
boolRR 
EnabledRR "
=>RR# %
LevelRR& +
>RR, -
DetectionLevelRR. <
.RR< =
DisabledRR= E
;RRE F
publicWW 
staticWW 
DetectionLevelWW $
LevelWW% *
{WW+ ,
getWW- 0
;WW0 1
setWW2 5
;WW5 6
}WW7 8
readonlyYY  
ConditionalWeakTableYY %
<YY% &
objectYY& ,
,YY, -
GCNoticeYY. 6
>YY6 7
gcNotificationMapYY8 I
=YYJ K
newYYL O 
ConditionalWeakTableYYP d
<YYd e
objectYYe k
,YYk l
GCNoticeYYm u
>YYu v
(YYv w
)YYw x
;YYx y
readonlyZZ  
ConcurrentDictionaryZZ %
<ZZ% &
stringZZ& ,
,ZZ, -
boolZZ. 2
>ZZ2 3
reportedLeaksZZ4 A
=ZZB C
newZZD G 
ConcurrentDictionaryZZH \
<ZZ\ ]
stringZZ] c
,ZZc d
boolZZe i
>ZZi j
(ZZj k
)ZZk l
;ZZl m
readonly\\ 
string\\ 
resourceType\\ $
;\\$ %
readonly]] 
int]] 
samplingInterval]] %
;]]% &
public__  
ResourceLeakDetector__ #
(__# $
string__$ *
resourceType__+ 7
)__7 8
:`` 
this`` 
(`` 
resourceType`` 
,``  #
DefaultSamplingInterval``! 8
)``8 9
{aa 	
}bb 	
publicdd  
ResourceLeakDetectordd #
(dd# $
stringdd$ *
resourceTypedd+ 7
,dd7 8
intdd9 <
samplingIntervaldd= M
)ddM N
{ee 	
Contractff 
.ff 
Requiresff 
(ff 
resourceTypeff *
!=ff+ -
nullff. 2
)ff2 3
;ff3 4
Contractgg 
.gg 
Requiresgg 
(gg 
samplingIntervalgg .
>gg/ 0
$numgg1 2
)gg2 3
;gg3 4
thisii 
.ii 
resourceTypeii 
=ii 
resourceTypeii  ,
;ii, -
thisjj 
.jj 
samplingIntervaljj !
=jj" #
samplingIntervaljj$ 4
;jj4 5
}kk 	
publicmm 
staticmm  
ResourceLeakDetectormm *
Createmm+ 1
<mm1 2
Tmm2 3
>mm3 4
(mm4 5
)mm5 6
=>mm7 9
newmm: = 
ResourceLeakDetectormm> R
(mmR S

StringUtilmmS ]
.mm] ^
SimpleClassNamemm^ m
<mmm n
Tmmn o
>mmo p
(mmp q
)mmq r
)mmr s
;mms t
publicuu  
IResourceLeakTrackeruu #
Trackuu$ )
(uu) *
objectuu* 0
objuu1 4
)uu4 5
{vv 	
DetectionLevelww 
levelww  
=ww! "
Levelww# (
;ww( )
ifxx 
(xx 
levelxx 
==xx 
DetectionLevelxx '
.xx' (
Disabledxx( 0
)xx0 1
{yy 
returnzz 
nullzz 
;zz 
}{{ 
if}} 
(}} 
level}} 
<}} 
DetectionLevel}} &
.}}& '
Paranoid}}' /
)}}/ 0
{~~ 
if 
( 
( 
PlatformDependent &
.& ' 
GetThreadLocalRandom' ;
(; <
)< =
.= >
Next> B
(B C
thisC G
.G H
samplingIntervalH X
)X Y
)Y Z
==[ ]
$num^ _
)_ `
{
ÄÄ 
return
ÅÅ 
new
ÅÅ !
DefaultResourceLeak
ÅÅ 2
(
ÅÅ2 3
this
ÅÅ3 7
,
ÅÅ7 8
obj
ÅÅ9 <
)
ÅÅ< =
;
ÅÅ= >
}
ÇÇ 
else
ÉÉ 
{
ÑÑ 
return
ÖÖ 
null
ÖÖ 
;
ÖÖ  
}
ÜÜ 
}
áá 
else
àà 
{
ââ 
return
ää 
new
ää !
DefaultResourceLeak
ää .
(
ää. /
this
ää/ 3
,
ää3 4
obj
ää5 8
)
ää8 9
;
ää9 :
}
ãã 
}
åå 	
void
éé 

ReportLeak
éé 
(
éé !
DefaultResourceLeak
éé +
resourceLeak
éé, 8
)
éé8 9
{
èè 	
if
êê 
(
êê 
!
êê 
Logger
êê 
.
êê 
ErrorEnabled
êê $
)
êê$ %
{
ëë 
resourceLeak
íí 
.
íí 
Dispose
íí $
(
íí$ %
)
íí% &
;
íí& '
return
ìì 
;
ìì 
}
îî 
string
ññ 
records
ññ 
=
ññ 
resourceLeak
ññ )
.
ññ) *
Dump
ññ* .
(
ññ. /
)
ññ/ 0
;
ññ0 1
if
óó 
(
óó 
this
óó 
.
óó 
reportedLeaks
óó "
.
óó" #
TryAdd
óó# )
(
óó) *
records
óó* 1
,
óó1 2
true
óó3 7
)
óó7 8
)
óó8 9
{
òò 
if
ôô 
(
ôô 
records
ôô 
.
ôô 
Length
ôô "
==
ôô# %
$num
ôô& '
)
ôô' (
{
öö 
this
õõ 
.
õõ  
ReportUntracedLeak
õõ +
(
õõ+ ,
this
õõ, 0
.
õõ0 1
resourceType
õõ1 =
)
õõ= >
;
õõ> ?
}
úú 
else
ùù 
{
ûû 
this
üü 
.
üü 
ReportTracedLeak
üü )
(
üü) *
this
üü* .
.
üü. /
resourceType
üü/ ;
,
üü; <
records
üü= D
)
üüD E
;
üüE F
}
†† 
}
°° 
}
¢¢ 	
	protected
§§ 
void
§§ 
ReportTracedLeak
§§ '
(
§§' (
string
§§( .
type
§§/ 3
,
§§3 4
string
§§5 ;
records
§§< C
)
§§C D
{
•• 	
Logger
¶¶ 
.
¶¶ 
Error
¶¶ 
(
¶¶ 
$str
ßß S
+
ßßT U
$str
®® a
,
®®a b
type
©© 
,
©© 
records
©© 
)
©© 
;
©© 
}
™™ 	
	protected
¨¨ 
void
¨¨  
ReportUntracedLeak
¨¨ )
(
¨¨) *
string
¨¨* 0
type
¨¨1 5
)
¨¨5 6
{
≠≠ 	
Logger
ÆÆ 
.
ÆÆ 
Error
ÆÆ 
(
ÆÆ 
$str
ÆÆ \
+
ÆÆ] ^
$str
ØØ V
+
ØØW X
$str
∞∞ 5
+
∞∞6 7
$str
±± I
+
±±J K
$str
≤≤ _
,
≤≤_ `
type
≥≥ 
,
≥≥ 
	PropLevel
≥≥ 
,
≥≥  
DetectionLevel
≥≥! /
.
≥≥/ 0
Advanced
≥≥0 8
.
≥≥8 9
ToString
≥≥9 A
(
≥≥A B
)
≥≥B C
.
≥≥C D
ToLower
≥≥D K
(
≥≥K L
)
≥≥L M
,
≥≥M N

StringUtil
≥≥O Y
.
≥≥Y Z
SimpleClassName
≥≥Z i
(
≥≥i j
this
≥≥j n
)
≥≥n o
)
≥≥o p
;
≥≥p q
}
¥¥ 	
sealed
∂∂ 
class
∂∂ !
DefaultResourceLeak
∂∂ (
:
∂∂) *"
IResourceLeakTracker
∂∂+ ?
{
∑∑ 	
readonly
∏∏ "
ResourceLeakDetector
∏∏ )
owner
∏∏* /
;
∏∏/ 0
RecordEntry
∫∫ 
head
∫∫ 
;
∫∫ 
long
ªª 
droppedRecords
ªª 
;
ªª  
readonly
ºº 
WeakReference
ºº "
<
ºº" #
GCNotice
ºº# +
>
ºº+ ,
gcNotice
ºº- 5
;
ºº5 6
public
ææ !
DefaultResourceLeak
ææ &
(
ææ& '"
ResourceLeakDetector
ææ' ;
owner
ææ< A
,
ææA B
object
ææC I
referent
ææJ R
)
ææR S
{
øø 
Debug
¿¿ 
.
¿¿ 
Assert
¿¿ 
(
¿¿ 
referent
¿¿ %
!=
¿¿& (
null
¿¿) -
)
¿¿- .
;
¿¿. /
this
¬¬ 
.
¬¬ 
owner
¬¬ 
=
¬¬ 
owner
¬¬ "
;
¬¬" #
GCNotice
√√ 
gcNotice
√√ !
;
√√! "
do
ƒƒ 
{
≈≈ 
GCNotice
∆∆ 
	gcNotice0
∆∆ &
=
∆∆' (
null
∆∆) -
;
∆∆- .
gcNotice
«« 
=
«« 
owner
«« $
.
««$ %
gcNotificationMap
««% 6
.
««6 7
GetValue
««7 ?
(
««? @
referent
««@ H
,
««H I
	referent0
««J S
=>
««T V
{
»» 
	gcNotice0
…… !
=
……" #
new
……$ '
GCNotice
……( 0
(
……0 1
	referent0
……1 :
,
……: ;
owner
……< A
)
……A B
;
……B C
return
   
	gcNotice0
   (
;
  ( )
}
ÀÀ 
)
ÀÀ 
;
ÀÀ 
if
ÃÃ 
(
ÃÃ 
	gcNotice0
ÃÃ !
!=
ÃÃ" $
null
ÃÃ% )
&&
ÃÃ* ,
	gcNotice0
ÃÃ- 6
!=
ÃÃ7 9
gcNotice
ÃÃ: B
)
ÃÃB C
{
ÕÕ 
GC
ŒŒ 
.
ŒŒ 
SuppressFinalize
ŒŒ +
(
ŒŒ+ ,
	gcNotice0
ŒŒ, 5
)
ŒŒ5 6
;
ŒŒ6 7
}
œœ 
}
–– 
while
—— 
(
—— 
!
—— 
gcNotice
——  
.
——  !
Arm
——! $
(
——$ %
this
——% )
,
——) *
owner
——+ 0
,
——0 1
referent
——2 :
)
——: ;
)
——; <
;
——< =
this
““ 
.
““ 
gcNotice
““ 
=
““ 
new
““  #
WeakReference
““$ 1
<
““1 2
GCNotice
““2 :
>
““: ;
(
““; <
gcNotice
““< D
)
““D E
;
““E F
this
”” 
.
”” 
head
”” 
=
”” 
RecordEntry
”” '
.
””' (
Bottom
””( .
;
””. /
Record
‘‘ 
(
‘‘ 
)
‘‘ 
;
‘‘ 
}
’’ 
public
◊◊ 
void
◊◊ 
Record
◊◊ 
(
◊◊ 
)
◊◊  
=>
◊◊! #
this
◊◊$ (
.
◊◊( )
Record0
◊◊) 0
(
◊◊0 1
null
◊◊1 5
)
◊◊5 6
;
◊◊6 7
public
ŸŸ 
void
ŸŸ 
Record
ŸŸ 
(
ŸŸ 
object
ŸŸ %
hint
ŸŸ& *
)
ŸŸ* +
=>
ŸŸ, .
this
ŸŸ/ 3
.
ŸŸ3 4
Record0
ŸŸ4 ;
(
ŸŸ; <
hint
ŸŸ< @
)
ŸŸ@ A
;
ŸŸA B
void
€€ 
Record0
€€ 
(
€€ 
object
€€ 
hint
€€  $
)
€€$ %
{
‹‹ 
if
ﬁﬁ 
(
ﬁﬁ 
TargetRecords
ﬁﬁ !
>
ﬁﬁ" #
$num
ﬁﬁ$ %
)
ﬁﬁ% &
{
ﬂﬂ 
string
‡‡ 

stackTrace
‡‡ %
=
‡‡& '
Environment
‡‡( 3
.
‡‡3 4

StackTrace
‡‡4 >
;
‡‡> ?
RecordEntry
‚‚ 
oldHead
‚‚  '
;
‚‚' (
RecordEntry
„„ 
prevHead
„„  (
;
„„( )
RecordEntry
‰‰ 
newHead
‰‰  '
;
‰‰' (
bool
ÂÂ 
dropped
ÂÂ  
;
ÂÂ  !
do
ÊÊ 
{
ÁÁ 
if
ËË 
(
ËË 
(
ËË 
prevHead
ËË %
=
ËË& '
oldHead
ËË( /
=
ËË0 1
Volatile
ËË2 :
.
ËË: ;
Read
ËË; ?
(
ËË? @
ref
ËË@ C
this
ËËD H
.
ËËH I
head
ËËI M
)
ËËM N
)
ËËN O
==
ËËP R
null
ËËS W
)
ËËW X
{
ÈÈ 
return
ÎÎ "
;
ÎÎ" #
}
ÏÏ 
int
ÌÌ 
numElements
ÌÌ '
=
ÌÌ( )
oldHead
ÌÌ* 1
.
ÌÌ1 2
Pos
ÌÌ2 5
+
ÌÌ6 7
$num
ÌÌ8 9
;
ÌÌ9 :
if
ÓÓ 
(
ÓÓ 
numElements
ÓÓ '
>=
ÓÓ( *
TargetRecords
ÓÓ+ 8
)
ÓÓ8 9
{
ÔÔ 
int
 
backOffFactor
  -
=
. /
Math
0 4
.
4 5
Min
5 8
(
8 9
numElements
9 D
-
E F
TargetRecords
G T
,
T U
$num
V X
)
X Y
;
Y Z
dropped
ÒÒ #
=
ÒÒ$ %
PlatformDependent
ÒÒ& 7
.
ÒÒ7 8"
GetThreadLocalRandom
ÒÒ8 L
(
ÒÒL M
)
ÒÒM N
.
ÒÒN O
Next
ÒÒO S
(
ÒÒS T
$num
ÒÒT U
<<
ÒÒV X
backOffFactor
ÒÒY f
)
ÒÒf g
!=
ÒÒh j
$num
ÒÒk l
;
ÒÒl m
if
ÚÚ 
(
ÚÚ  
dropped
ÚÚ  '
)
ÚÚ' (
{
ÛÛ 
prevHead
ÙÙ  (
=
ÙÙ) *
oldHead
ÙÙ+ 2
.
ÙÙ2 3
Next
ÙÙ3 7
;
ÙÙ7 8
}
ıı 
}
ˆˆ 
else
˜˜ 
{
¯¯ 
dropped
˘˘ #
=
˘˘$ %
false
˘˘& +
;
˘˘+ ,
}
˙˙ 
newHead
˚˚ 
=
˚˚  !
hint
˚˚" &
!=
˚˚' )
null
˚˚* .
?
˚˚/ 0
new
˚˚1 4
RecordEntry
˚˚5 @
(
˚˚@ A
prevHead
˚˚A I
,
˚˚I J

stackTrace
˚˚K U
,
˚˚U V
hint
˚˚W [
)
˚˚[ \
:
˚˚] ^
new
˚˚_ b
RecordEntry
˚˚c n
(
˚˚n o
prevHead
˚˚o w
,
˚˚w x

stackTrace˚˚y É
)˚˚É Ñ
;˚˚Ñ Ö
}
¸¸ 
while
˝˝ 
(
˝˝ 
Interlocked
˝˝ &
.
˝˝& '
CompareExchange
˝˝' 6
(
˝˝6 7
ref
˝˝7 :
this
˝˝; ?
.
˝˝? @
head
˝˝@ D
,
˝˝D E
newHead
˝˝F M
,
˝˝M N
oldHead
˝˝O V
)
˝˝V W
!=
˝˝X Z
oldHead
˝˝[ b
)
˝˝b c
;
˝˝c d
if
˛˛ 
(
˛˛ 
dropped
˛˛ 
)
˛˛  
{
ˇˇ 
Interlocked
ÄÄ #
.
ÄÄ# $
	Increment
ÄÄ$ -
(
ÄÄ- .
ref
ÄÄ. 1
this
ÄÄ2 6
.
ÄÄ6 7
droppedRecords
ÄÄ7 E
)
ÄÄE F
;
ÄÄF G
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 
public
ÖÖ 
bool
ÖÖ 
Close
ÖÖ 
(
ÖÖ 
object
ÖÖ $
trackedObject
ÖÖ% 2
)
ÖÖ2 3
{
ÜÜ 
if
áá 
(
áá 
gcNotice
áá 
.
áá 
TryGetTarget
áá )
(
áá) *
out
áá* -
var
áá. 1
notice
áá2 8
)
áá8 9
)
áá9 :
{
àà 
if
ââ 
(
ââ 
notice
ââ 
.
ââ 
UnArm
ââ $
(
ââ$ %
this
ââ% )
,
ââ) *
owner
ââ+ 0
,
ââ0 1
trackedObject
ââ2 ?
)
ââ? @
)
ââ@ A
{
ää 
this
ãã 
.
ãã 
Dispose
ãã $
(
ãã$ %
)
ãã% &
;
ãã& '
return
åå 
true
åå #
;
åå# $
}
çç 
}
éé 
return
êê 
false
êê 
;
êê 
}
ëë 
internal
îî 
void
îî 

CloseFinal
îî $
(
îî$ %
)
îî% &
{
ïï 
if
ññ 
(
ññ 
Volatile
ññ 
.
ññ 
Read
ññ !
(
ññ! "
ref
ññ" %
this
ññ& *
.
ññ* +
head
ññ+ /
)
ññ/ 0
!=
ññ1 3
null
ññ4 8
)
ññ8 9
{
óó 
this
òò 
.
òò 
owner
òò 
.
òò 

ReportLeak
òò )
(
òò) *
this
òò* .
)
òò. /
;
òò/ 0
}
ôô 
}
öö 
public
úú 
string
úú 
Dump
úú 
(
úú 
)
úú  
{
ùù 
RecordEntry
ûû 
oldHead
ûû #
=
ûû$ %
Interlocked
ûû& 1
.
ûû1 2
Exchange
ûû2 :
(
ûû: ;
ref
ûû; >
this
ûû? C
.
ûûC D
head
ûûD H
,
ûûH I
null
ûûJ N
)
ûûN O
;
ûûO P
if
üü 
(
üü 
oldHead
üü 
==
üü 
null
üü #
)
üü# $
{
†† 
return
¢¢ 
string
¢¢ !
.
¢¢! "
Empty
¢¢" '
;
¢¢' (
}
££ 
long
•• 
dropped
•• 
=
•• 
Interlocked
•• *
.
••* +
Read
••+ /
(
••/ 0
ref
••0 3
this
••4 8
.
••8 9
droppedRecords
••9 G
)
••G H
;
••H I
int
¶¶ 
duped
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
int
®® 
present
®® 
=
®® 
oldHead
®® %
.
®®% &
Pos
®®& )
+
®®* +
$num
®®, -
;
®®- .
var
™™ 
buf
™™ 
=
™™ 
new
™™ 
StringBuilder
™™ +
(
™™+ ,
present
™™, 3
*
™™4 5
$num
™™6 :
)
™™: ;
;
™™; <
buf
´´ 
.
´´ 
Append
´´ 
(
´´ 

StringUtil
´´ %
.
´´% &
Newline
´´& -
)
´´- .
;
´´. /
buf
¨¨ 
.
¨¨ 
Append
¨¨ 
(
¨¨ 
$str
¨¨ 4
)
¨¨4 5
.
¨¨5 6
Append
¨¨6 <
(
¨¨< =

StringUtil
¨¨= G
.
¨¨G H
Newline
¨¨H O
)
¨¨O P
;
¨¨P Q
int
ÆÆ 
i
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
var
ØØ 
seen
ØØ 
=
ØØ 
new
ØØ 
HashSet
ØØ &
<
ØØ& '
string
ØØ' -
>
ØØ- .
(
ØØ. /
)
ØØ/ 0
;
ØØ0 1
for
∞∞ 
(
∞∞ 
;
∞∞ 
oldHead
∞∞ 
!=
∞∞ !
RecordEntry
∞∞" -
.
∞∞- .
Bottom
∞∞. 4
;
∞∞4 5
oldHead
∞∞6 =
=
∞∞> ?
oldHead
∞∞@ G
.
∞∞G H
Next
∞∞H L
)
∞∞L M
{
±± 
string
≤≤ 
s
≤≤ 
=
≤≤ 
oldHead
≤≤ &
.
≤≤& '
ToString
≤≤' /
(
≤≤/ 0
)
≤≤0 1
;
≤≤1 2
if
≥≥ 
(
≥≥ 
seen
≥≥ 
.
≥≥ 
Add
≥≥  
(
≥≥  !
s
≥≥! "
)
≥≥" #
)
≥≥# $
{
¥¥ 
if
µµ 
(
µµ 
oldHead
µµ #
.
µµ# $
Next
µµ$ (
==
µµ) +
RecordEntry
µµ, 7
.
µµ7 8
Bottom
µµ8 >
)
µµ> ?
{
∂∂ 
buf
∑∑ 
.
∑∑  
Append
∑∑  &
(
∑∑& '
$str
∑∑' 4
)
∑∑4 5
.
∑∑5 6
Append
∑∑6 <
(
∑∑< =

StringUtil
∑∑= G
.
∑∑G H
Newline
∑∑H O
)
∑∑O P
.
∑∑P Q
Append
∑∑Q W
(
∑∑W X
s
∑∑X Y
)
∑∑Y Z
;
∑∑Z [
}
∏∏ 
else
ππ 
{
∫∫ 
buf
ªª 
.
ªª  
Append
ªª  &
(
ªª& '
$char
ªª' *
)
ªª* +
.
ªª+ ,
Append
ªª, 2
(
ªª2 3
i
ªª3 4
++
ªª4 6
)
ªª6 7
.
ªª7 8
Append
ªª8 >
(
ªª> ?
$char
ªª? B
)
ªªB C
.
ªªC D
Append
ªªD J
(
ªªJ K

StringUtil
ªªK U
.
ªªU V
Newline
ªªV ]
)
ªª] ^
.
ªª^ _
Append
ªª_ e
(
ªªe f
s
ªªf g
)
ªªg h
;
ªªh i
}
ºº 
}
ΩΩ 
else
ææ 
{
øø 
duped
¿¿ 
++
¿¿ 
;
¿¿  
}
¡¡ 
}
¬¬ 
if
ƒƒ 
(
ƒƒ 
duped
ƒƒ 
>
ƒƒ 
$num
ƒƒ 
)
ƒƒ 
{
≈≈ 
buf
∆∆ 
.
∆∆ 
Append
∆∆ 
(
∆∆ 
$str
∆∆ #
)
∆∆# $
.
«« 
Append
«« 
(
««  
duped
««  %
)
««% &
.
»» 
Append
»» 
(
»»  
$str
»»  [
)
»»[ \
.
…… 
Append
…… 
(
……  

StringUtil
……  *
.
……* +
Newline
……+ 2
)
……2 3
;
……3 4
}
   
if
ÃÃ 
(
ÃÃ 
dropped
ÃÃ 
>
ÃÃ 
$num
ÃÃ 
)
ÃÃ  
{
ÕÕ 
buf
ŒŒ 
.
ŒŒ 
Append
ŒŒ 
(
ŒŒ 
$str
ŒŒ #
)
ŒŒ# $
.
œœ 
Append
œœ 
(
œœ  
dropped
œœ  '
)
œœ' (
.
–– 
Append
–– 
(
––  
$str
––  l
)
––l m
.
—— 
Append
—— 
(
——  
TargetRecords
——  -
)
——- .
.
““ 
Append
““ 
(
““  
$str
““  8
)
““8 9
.
”” 
Append
”” 
(
””  
PropTargetRecords
””  1
)
””1 2
.
‘‘ 
Append
‘‘ 
(
‘‘  
$str
‘‘  9
)
‘‘9 :
.
’’ 
Append
’’ 
(
’’  

StringUtil
’’  *
.
’’* +
Newline
’’+ 2
)
’’2 3
;
’’3 4
}
÷÷ 
buf
ÿÿ 
.
ÿÿ 
Length
ÿÿ 
=
ÿÿ 
buf
ÿÿ  
.
ÿÿ  !
Length
ÿÿ! '
-
ÿÿ( )

StringUtil
ÿÿ* 4
.
ÿÿ4 5
Newline
ÿÿ5 <
.
ÿÿ< =
Length
ÿÿ= C
;
ÿÿC D
return
ŸŸ 
buf
ŸŸ 
.
ŸŸ 
ToString
ŸŸ #
(
ŸŸ# $
)
ŸŸ$ %
;
ŸŸ% &
}
⁄⁄ 
internal
‹‹ 
void
‹‹ 
Dispose
‹‹ !
(
‹‹! "
)
‹‹" #
{
›› 
Interlocked
ﬁﬁ 
.
ﬁﬁ 
Exchange
ﬁﬁ $
(
ﬁﬁ$ %
ref
ﬁﬁ% (
this
ﬁﬁ) -
.
ﬁﬁ- .
head
ﬁﬁ. 2
,
ﬁﬁ2 3
null
ﬁﬁ4 8
)
ﬁﬁ8 9
;
ﬁﬁ9 :
}
ﬂﬂ 
}
‡‡ 	
sealed
„„ 
class
„„ 
RecordEntry
„„  
{
‰‰ 	
internal
ÂÂ 
static
ÂÂ 
readonly
ÂÂ $
RecordEntry
ÂÂ% 0
Bottom
ÂÂ1 7
=
ÂÂ8 9
new
ÂÂ: =
RecordEntry
ÂÂ> I
(
ÂÂI J
)
ÂÂJ K
;
ÂÂK L
readonly
ÁÁ 
string
ÁÁ 

hintString
ÁÁ &
;
ÁÁ& '
internal
ËË 
readonly
ËË 
RecordEntry
ËË )
Next
ËË* .
;
ËË. /
internal
ÈÈ 
readonly
ÈÈ 
int
ÈÈ !
Pos
ÈÈ" %
;
ÈÈ% &
readonly
ÍÍ 
string
ÍÍ 

stackTrace
ÍÍ &
;
ÍÍ& '
internal
ÏÏ 
RecordEntry
ÏÏ  
(
ÏÏ  !
RecordEntry
ÏÏ! ,
next
ÏÏ- 1
,
ÏÏ1 2
string
ÏÏ3 9

stackTrace
ÏÏ: D
,
ÏÏD E
object
ÏÏF L
hint
ÏÏM Q
)
ÏÏQ R
{
ÌÌ 
this
ÔÔ 
.
ÔÔ 

hintString
ÔÔ 
=
ÔÔ  !
hint
ÔÔ" &
is
ÔÔ' )
IResourceLeakHint
ÔÔ* ;
leakHint
ÔÔ< D
?
ÔÔE F
leakHint
ÔÔG O
.
ÔÔO P
ToHintString
ÔÔP \
(
ÔÔ\ ]
)
ÔÔ] ^
:
ÔÔ_ `
null
ÔÔa e
;
ÔÔe f
this
 
.
 
Next
 
=
 
next
  
;
  !
this
ÒÒ 
.
ÒÒ 
Pos
ÒÒ 
=
ÒÒ 
next
ÒÒ 
.
ÒÒ  
Pos
ÒÒ  #
+
ÒÒ$ %
$num
ÒÒ& '
;
ÒÒ' (
this
ÚÚ 
.
ÚÚ 

stackTrace
ÚÚ 
=
ÚÚ  !

stackTrace
ÚÚ" ,
;
ÚÚ, -
}
ÛÛ 
internal
ıı 
RecordEntry
ıı  
(
ıı  !
RecordEntry
ıı! ,
next
ıı- 1
,
ıı1 2
string
ıı3 9

stackTrace
ıı: D
)
ııD E
{
ˆˆ 
this
˜˜ 
.
˜˜ 

hintString
˜˜ 
=
˜˜  !
null
˜˜" &
;
˜˜& '
this
¯¯ 
.
¯¯ 
Next
¯¯ 
=
¯¯ 
next
¯¯  
;
¯¯  !
this
˘˘ 
.
˘˘ 
Pos
˘˘ 
=
˘˘ 
next
˘˘ 
.
˘˘  
Pos
˘˘  #
+
˘˘$ %
$num
˘˘& '
;
˘˘' (
this
˙˙ 
.
˙˙ 

stackTrace
˙˙ 
=
˙˙  !

stackTrace
˙˙" ,
;
˙˙, -
}
˚˚ 
RecordEntry
˛˛ 
(
˛˛ 
)
˛˛ 
{
ˇˇ 
this
ÄÄ 
.
ÄÄ 

hintString
ÄÄ 
=
ÄÄ  !
null
ÄÄ" &
;
ÄÄ& '
this
ÅÅ 
.
ÅÅ 
Next
ÅÅ 
=
ÅÅ 
null
ÅÅ  
;
ÅÅ  !
this
ÇÇ 
.
ÇÇ 
Pos
ÇÇ 
=
ÇÇ 
-
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
this
ÉÉ 
.
ÉÉ 

stackTrace
ÉÉ 
=
ÉÉ  !
string
ÉÉ" (
.
ÉÉ( )
Empty
ÉÉ) .
;
ÉÉ. /
}
ÑÑ 
public
ÜÜ 
override
ÜÜ 
string
ÜÜ "
ToString
ÜÜ# +
(
ÜÜ+ ,
)
ÜÜ, -
{
áá 
var
àà 
buf
àà 
=
àà 
new
àà 
StringBuilder
àà +
(
àà+ ,
$num
àà, 0
)
àà0 1
;
àà1 2
if
ââ 
(
ââ 
this
ââ 
.
ââ 

hintString
ââ #
!=
ââ$ &
null
ââ' +
)
ââ+ ,
{
ää 
buf
ãã 
.
ãã 
Append
ãã 
(
ãã 
$str
ãã )
)
ãã) *
.
ãã* +
Append
ãã+ 1
(
ãã1 2
this
ãã2 6
.
ãã6 7

hintString
ãã7 A
)
ããA B
.
ããB C
Append
ããC I
(
ããI J

StringUtil
ããJ T
.
ããT U
Newline
ããU \
)
ãã\ ]
;
ãã] ^
}
åå 
buf
êê 
.
êê 
Append
êê 
(
êê 
this
êê 
.
êê  

stackTrace
êê  *
)
êê* +
.
êê+ ,
Append
êê, 2
(
êê2 3

StringUtil
êê3 =
.
êê= >
Newline
êê> E
)
êêE F
;
êêF G
return
ëë 
buf
ëë 
.
ëë 
ToString
ëë #
(
ëë# $
)
ëë$ %
;
ëë% &
}
íí 
}
ìì 	
class
ïï 
GCNotice
ïï 
{
ññ 	
private
•• 
readonly
•• 

LinkedList
•• '
<
••' (!
DefaultResourceLeak
••( ;
>
••; <
leakList
••= E
=
••F G
new
••H K

LinkedList
••L V
<
••V W!
DefaultResourceLeak
••W j
>
••j k
(
••k l
)
••l m
;
••m n
object
¶¶ 
referent
¶¶ 
;
¶¶ "
ResourceLeakDetector
ßß  
owner
ßß! &
;
ßß& '
public
®® 
GCNotice
®® 
(
®® 
object
®® "
referent
®®# +
,
®®+ ,"
ResourceLeakDetector
®®- A
owner
®®B G
)
®®G H
{
©© 
this
™™ 
.
™™ 
referent
™™ 
=
™™ 
referent
™™  (
;
™™( )
this
´´ 
.
´´ 
owner
´´ 
=
´´ 
owner
´´ "
;
´´" #
}
¨¨ 
~
ÆÆ 
GCNotice
ÆÆ 
(
ÆÆ 
)
ÆÆ 
{
ØØ 
lock
∞∞ 
(
∞∞ 
this
∞∞ 
.
∞∞ 
leakList
∞∞ #
)
∞∞# $
{
±± 
foreach
≤≤ 
(
≤≤ 
var
≤≤  
leak
≤≤! %
in
≤≤& (
this
≤≤) -
.
≤≤- .
leakList
≤≤. 6
)
≤≤6 7
{
≥≥ 
leak
¥¥ 
.
¥¥ 

CloseFinal
¥¥ '
(
¥¥' (
)
¥¥( )
;
¥¥) *
}
µµ 
this
∂∂ 
.
∂∂ 
leakList
∂∂ !
.
∂∂! "
Clear
∂∂" '
(
∂∂' (
)
∂∂( )
;
∂∂) *
this
ªª 
.
ªª 
owner
ªª 
=
ªª  
null
ªª! %
;
ªª% &
}
ºº 
}
ΩΩ 
public
øø 
bool
øø 
Arm
øø 
(
øø !
DefaultResourceLeak
øø /
leak
øø0 4
,
øø4 5"
ResourceLeakDetector
øø6 J
owner
øøK P
,
øøP Q
object
øøR X
referent
øøY a
)
øøa b
{
¿¿ 
lock
¡¡ 
(
¡¡ 
this
¡¡ 
.
¡¡ 
leakList
¡¡ #
)
¡¡# $
{
¬¬ 
if
√√ 
(
√√ 
this
√√ 
.
√√ 
owner
√√ "
==
√√# %
null
√√& *
)
√√* +
{
ƒƒ 
return
∆∆ 
false
∆∆ $
;
∆∆$ %
}
«« 
Debug
»» 
.
»» 
Assert
»»  
(
»»  !
owner
»»! &
==
»»' )
this
»»* .
.
»». /
owner
»»/ 4
)
»»4 5
;
»»5 6
Debug
…… 
.
…… 
Assert
……  
(
……  !
referent
……! )
==
……* ,
this
……- 1
.
……1 2
referent
……2 :
)
……: ;
;
……; <
this
ÀÀ 
.
ÀÀ 
leakList
ÀÀ !
.
ÀÀ! "
AddLast
ÀÀ" )
(
ÀÀ) *
leak
ÀÀ* .
)
ÀÀ. /
;
ÀÀ/ 0
return
ÃÃ 
true
ÃÃ 
;
ÃÃ  
}
ÕÕ 
}
ŒŒ 
public
–– 
bool
–– 
UnArm
–– 
(
–– !
DefaultResourceLeak
–– 1
leak
––2 6
,
––6 7"
ResourceLeakDetector
––8 L
owner
––M R
,
––R S
object
––T Z
referent
––[ c
)
––c d
{
—— 
lock
““ 
(
““ 
this
““ 
.
““ 
leakList
““ #
)
““# $
{
”” 
if
‘‘ 
(
‘‘ 
this
‘‘ 
.
‘‘ 
owner
‘‘ "
==
‘‘# %
null
‘‘& *
)
‘‘* +
{
’’ 
return
◊◊ 
false
◊◊ $
;
◊◊$ %
}
ÿÿ 
Debug
ŸŸ 
.
ŸŸ 
Assert
ŸŸ  
(
ŸŸ  !
owner
ŸŸ! &
==
ŸŸ' )
this
ŸŸ* .
.
ŸŸ. /
owner
ŸŸ/ 4
)
ŸŸ4 5
;
ŸŸ5 6
Debug
⁄⁄ 
.
⁄⁄ 
Assert
⁄⁄  
(
⁄⁄  !
referent
⁄⁄! )
==
⁄⁄* ,
this
⁄⁄- 1
.
⁄⁄1 2
referent
⁄⁄2 :
)
⁄⁄: ;
;
⁄⁄; <
bool
‹‹ 
res
‹‹ 
=
‹‹ 
this
‹‹ #
.
‹‹# $
leakList
‹‹$ ,
.
‹‹, -
Remove
‹‹- 3
(
‹‹3 4
leak
‹‹4 8
)
‹‹8 9
;
‹‹9 :
if
›› 
(
›› 
this
›› 
.
›› 
leakList
›› %
.
››% &
Count
››& +
==
››, .
$num
››/ 0
)
››0 1
{
ﬁﬁ 
GC
‰‰ 
.
‰‰ 
SuppressFinalize
‰‰ +
(
‰‰+ ,
this
‰‰, 0
)
‰‰0 1
;
‰‰1 2
bool
ËË 
removed
ËË $
=
ËË% &
this
ËË' +
.
ËË+ ,
owner
ËË, 1
.
ËË1 2
gcNotificationMap
ËË2 C
.
ËËC D
Remove
ËËD J
(
ËËJ K
this
ËËK O
.
ËËO P
referent
ËËP X
)
ËËX Y
;
ËËY Z
Debug
ÈÈ 
.
ÈÈ 
Assert
ÈÈ $
(
ÈÈ$ %
removed
ÈÈ% ,
)
ÈÈ, -
;
ÈÈ- .
this
ÏÏ 
.
ÏÏ 
owner
ÏÏ "
=
ÏÏ# $
null
ÏÏ% )
;
ÏÏ) *
}
ÌÌ 
return
ÓÓ 
res
ÓÓ 
;
ÓÓ 
}
ÔÔ 
}
 
}
ÒÒ 	
}
ÚÚ 
}ÛÛ ƒk
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\ThreadDeathWatcher.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

static 
class 
ThreadDeathWatcher *
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
ThreadDeathWatcherZ l
)l m
)m n
;n o
static 
readonly 
IQueue 
< 
Entry $
>$ %
PendingEntries& 4
=5 6
PlatformDependent7 H
.H I
NewMpscQueueI U
<U V
EntryV [
>[ \
(\ ]
)] ^
;^ _
static 
readonly 
Watcher 
watcher  '
=( )
new* -
Watcher. 5
(5 6
)6 7
;7 8
static 
int 
started 
; 
static 
volatile 
Thread 
watcherThread ,
;, -
static 
ThreadDeathWatcher !
(! "
)" #
{ 	
string 
poolName 
= 
$str 2
;2 3
string 
serviceThreadPrefix &
=' (
SystemPropertyUtil) ;
.; <
Get< ?
(? @
$str@ ^
)^ _
;_ `
if 
( 
! 
string 
. 
IsNullOrEmpty %
(% &
serviceThreadPrefix& 9
)9 :
): ;
{ 
poolName 
= 
serviceThreadPrefix .
+/ 0
poolName1 9
;9 :
} 
} 	
public$$ 
static$$ 
void$$ 
Watch$$  
($$  !
Thread$$! '
thread$$( .
,$$. /
Action$$0 6
task$$7 ;
)$$; <
{%% 	
Contract&& 
.&& 
Requires&& 
(&& 
thread&& $
!=&&% '
null&&( ,
)&&, -
;&&- .
Contract'' 
.'' 
Requires'' 
('' 
task'' "
!=''# %
null''& *
)''* +
;''+ ,
Contract(( 
.(( 
Requires(( 
((( 
thread(( $
.(($ %
IsAlive((% ,
)((, -
;((- .
Schedule** 
(** 
thread** 
,** 
task** !
,**! "
true**# '
)**' (
;**( )
}++ 	
public00 
static00 
void00 
Unwatch00 "
(00" #
Thread00# )
thread00* 0
,000 1
Action002 8
task009 =
)00= >
{11 	
Contract22 
.22 
Requires22 
(22 
thread22 $
!=22% '
null22( ,
)22, -
;22- .
Contract33 
.33 
Requires33 
(33 
task33 "
!=33# %
null33& *
)33* +
;33+ ,
Schedule55 
(55 
thread55 
,55 
task55 !
,55! "
false55# (
)55( )
;55) *
}66 	
static88 
void88 
Schedule88 
(88 
Thread88 #
thread88$ *
,88* +
Action88, 2
task883 7
,887 8
bool889 =
isWatch88> E
)88E F
{99 	
PendingEntries:: 
.:: 

TryEnqueue:: %
(::% &
new::& )
Entry::* /
(::/ 0
thread::0 6
,::6 7
task::8 <
,::< =
isWatch::> E
)::E F
)::F G
;::G H
if<< 
(<< 
Interlocked<< 
.<< 
CompareExchange<< +
(<<+ ,
ref<<, /
started<<0 7
,<<7 8
$num<<9 :
,<<: ;
$num<<< =
)<<= >
==<<? A
$num<<B C
)<<C D
{== 
var>> 
watcherThread>> !
=>>" #
new>>$ '
Thread>>( .
(>>. /
s>>/ 0
=>>>1 3
(>>4 5
(>>5 6
	IRunnable>>6 ?
)>>? @
s>>@ A
)>>A B
.>>B C
Run>>C F
(>>F G
)>>G H
)>>H I
;>>I J
watcherThread?? 
.?? 
IsBackground?? *
=??+ ,
true??- 1
;??1 2
watcherThread@@ 
.@@ 
Start@@ #
(@@# $
watcher@@$ +
)@@+ ,
;@@, -
ThreadDeathWatcherAA "
.AA" #
watcherThreadAA# 0
=AA1 2
watcherThreadAA3 @
;AA@ A
}BB 
}CC 	
publicNN 
staticNN 
boolNN 
AwaitInactivityNN *
(NN* +
TimeSpanNN+ 3
timeoutNN4 ;
)NN; <
{OO 	
ThreadPP 
watcherThreadPP  
=PP! "
ThreadDeathWatcherPP# 5
.PP5 6
watcherThreadPP6 C
;PPC D
ifQQ 
(QQ 
watcherThreadQQ 
!=QQ  
nullQQ! %
)QQ% &
{RR 
watcherThreadSS 
.SS 
JoinSS "
(SS" #
timeoutSS# *
)SS* +
;SS+ ,
returnTT 
!TT 
watcherThreadTT %
.TT% &
IsAliveTT& -
;TT- .
}UU 
elseVV 
{WW 
returnXX 
trueXX 
;XX 
}YY 
}ZZ 	
sealed\\ 
class\\ 
Watcher\\ 
:\\ 
	IRunnable\\ (
{]] 	
readonly^^ 
List^^ 
<^^ 
Entry^^ 
>^^  
watchees^^! )
=^^* +
new^^, /
List^^0 4
<^^4 5
Entry^^5 :
>^^: ;
(^^; <
)^^< =
;^^= >
public`` 
void`` 
Run`` 
(`` 
)`` 
{aa 
forbb 
(bb 
;bb 
;bb 
)bb 
{cc 
thisdd 
.dd 
FetchWatcheesdd &
(dd& '
)dd' (
;dd( )
thisee 
.ee 
NotifyWatcheesee '
(ee' (
)ee( )
;ee) *
thishh 
.hh 
FetchWatcheeshh &
(hh& '
)hh' (
;hh( )
thisii 
.ii 
NotifyWatcheesii '
(ii' (
)ii( )
;ii) *
Threadkk 
.kk 
Sleepkk  
(kk  !
$numkk! %
)kk% &
;kk& '
ifmm 
(mm 
thismm 
.mm 
watcheesmm %
.mm% &
Countmm& +
==mm, .
$nummm/ 0
&&mm1 3
PendingEntriesmm4 B
.mmB C
IsEmptymmC J
)mmJ K
{nn 
boolrr 
stoppedrr $
=rr% &
Interlockedrr' 2
.rr2 3
CompareExchangerr3 B
(rrB C
refrrC F
startedrrG N
,rrN O
$numrrP Q
,rrQ R
$numrrS T
)rrT U
==rrV X
$numrrY Z
;rrZ [
Contractss  
.ss  !
Assertss! '
(ss' (
stoppedss( /
)ss/ 0
;ss0 1
ifvv 
(vv 
PendingEntriesvv *
.vv* +
IsEmptyvv+ 2
)vv2 3
{ww 
break|| !
;||! "
}}} 
if
ÄÄ 
(
ÄÄ 
Interlocked
ÄÄ '
.
ÄÄ' (
CompareExchange
ÄÄ( 7
(
ÄÄ7 8
ref
ÄÄ8 ;
started
ÄÄ< C
,
ÄÄC D
$num
ÄÄE F
,
ÄÄF G
$num
ÄÄH I
)
ÄÄI J
!=
ÄÄK M
$num
ÄÄN O
)
ÄÄO P
{
ÅÅ 
break
ÑÑ !
;
ÑÑ! "
}
ÖÖ 
}
ää 
}
ãã 
}
åå 
void
éé 
FetchWatchees
éé 
(
éé 
)
éé  
{
èè 
for
êê 
(
êê 
;
êê 
;
êê 
)
êê 
{
ëë 
Entry
íí 
e
íí 
;
íí 
if
ìì 
(
ìì 
!
ìì 
PendingEntries
ìì '
.
ìì' (

TryDequeue
ìì( 2
(
ìì2 3
out
ìì3 6
e
ìì7 8
)
ìì8 9
)
ìì9 :
{
îî 
break
ïï 
;
ïï 
}
ññ 
if
òò 
(
òò 
e
òò 
.
òò 
IsWatch
òò !
)
òò! "
{
ôô 
this
öö 
.
öö 
watchees
öö %
.
öö% &
Add
öö& )
(
öö) *
e
öö* +
)
öö+ ,
;
öö, -
}
õõ 
else
úú 
{
ùù 
this
ûû 
.
ûû 
watchees
ûû %
.
ûû% &
Remove
ûû& ,
(
ûû, -
e
ûû- .
)
ûû. /
;
ûû/ 0
}
üü 
}
†† 
}
°° 
void
££ 
NotifyWatchees
££ 
(
££  
)
££  !
{
§§ 
List
•• 
<
•• 
Entry
•• 
>
•• 
watchees
•• $
=
••% &
this
••' +
.
••+ ,
watchees
••, 4
;
••4 5
for
¶¶ 
(
¶¶ 
int
¶¶ 
i
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
i
¶¶  !
<
¶¶" #
watchees
¶¶$ ,
.
¶¶, -
Count
¶¶- 2
;
¶¶2 3
)
¶¶3 4
{
ßß 
Entry
®® 
e
®® 
=
®® 
watchees
®® &
[
®®& '
i
®®' (
]
®®( )
;
®®) *
if
©© 
(
©© 
!
©© 
e
©© 
.
©© 
Thread
©© !
.
©©! "
IsAlive
©©" )
)
©©) *
{
™™ 
watchees
´´  
.
´´  !
RemoveAt
´´! )
(
´´) *
i
´´* +
)
´´+ ,
;
´´, -
try
¨¨ 
{
≠≠ 
e
ÆÆ 
.
ÆÆ 
Task
ÆÆ "
(
ÆÆ" #
)
ÆÆ# $
;
ÆÆ$ %
}
ØØ 
catch
∞∞ 
(
∞∞ 
	Exception
∞∞ (
t
∞∞) *
)
∞∞* +
{
±± 
Logger
≤≤ "
.
≤≤" #
Warn
≤≤# '
(
≤≤' (
$str
≤≤( X
,
≤≤X Y
t
≤≤Z [
)
≤≤[ \
;
≤≤\ ]
}
≥≥ 
}
¥¥ 
else
µµ 
{
∂∂ 
i
∑∑ 
++
∑∑ 
;
∑∑ 
}
∏∏ 
}
ππ 
}
∫∫ 
}
ªª 	
sealed
ΩΩ 
class
ΩΩ 
Entry
ΩΩ 
{
ææ 	
internal
øø 
readonly
øø 
Thread
øø $
Thread
øø% +
;
øø+ ,
internal
¿¿ 
readonly
¿¿ 
Action
¿¿ $
Task
¿¿% )
;
¿¿) *
internal
¡¡ 
readonly
¡¡ 
bool
¡¡ "
IsWatch
¡¡# *
;
¡¡* +
public
√√ 
Entry
√√ 
(
√√ 
Thread
√√ 
thread
√√  &
,
√√& '
Action
√√( .
task
√√/ 3
,
√√3 4
bool
√√5 9
isWatch
√√: A
)
√√A B
{
ƒƒ 
this
≈≈ 
.
≈≈ 
Thread
≈≈ 
=
≈≈ 
thread
≈≈ $
;
≈≈$ %
this
∆∆ 
.
∆∆ 
Task
∆∆ 
=
∆∆ 
task
∆∆  
;
∆∆  !
this
«« 
.
«« 
IsWatch
«« 
=
«« 
isWatch
«« &
;
««& '
}
»» 
public
   
override
   
int
   
GetHashCode
    +
(
  + ,
)
  , -
=>
  . 0
this
  1 5
.
  5 6
Thread
  6 <
.
  < =
GetHashCode
  = H
(
  H I
)
  I J
^
  K L
this
  M Q
.
  Q R
Task
  R V
.
  V W
GetHashCode
  W b
(
  b c
)
  c d
;
  d e
public
ÃÃ 
override
ÃÃ 
bool
ÃÃ  
Equals
ÃÃ! '
(
ÃÃ' (
object
ÃÃ( .
obj
ÃÃ/ 2
)
ÃÃ2 3
{
ÕÕ 
if
ŒŒ 
(
ŒŒ 
obj
ŒŒ 
==
ŒŒ 
this
ŒŒ 
)
ŒŒ  
{
œœ 
return
–– 
true
–– 
;
––  
}
—— 
if
”” 
(
”” 
!
”” 
(
”” 
obj
”” 
is
”” 
Entry
”” "
)
””" #
)
””# $
{
‘‘ 
return
’’ 
false
’’  
;
’’  !
}
÷÷ 
var
ÿÿ 
that
ÿÿ 
=
ÿÿ 
(
ÿÿ 
Entry
ÿÿ !
)
ÿÿ! "
obj
ÿÿ" %
;
ÿÿ% &
return
ŸŸ 
this
ŸŸ 
.
ŸŸ 
Thread
ŸŸ "
==
ŸŸ# %
that
ŸŸ& *
.
ŸŸ* +
Thread
ŸŸ+ 1
&&
ŸŸ2 4
this
ŸŸ5 9
.
ŸŸ9 :
Task
ŸŸ: >
==
ŸŸ? A
that
ŸŸB F
.
ŸŸF G
Task
ŸŸG K
;
ŸŸK L
}
⁄⁄ 
}
€€ 	
}
‹‹ 
}›› ≤
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\ThreadLocalObjectList.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

class !
ThreadLocalObjectList &
:' (
List) -
<- .
object. 4
>4 5
{		 
const

 
int

 "
DefaultInitialCapacity

 (
=

) *
$num

+ ,
;

, -
static 
readonly 
ThreadLocalPool '
<' (!
ThreadLocalObjectList( =
>= >
Pool? C
=D E
newF I
ThreadLocalPoolJ Y
<Y Z!
ThreadLocalObjectListZ o
>o p
(p q
handleq w
=>x z
new{ ~"
ThreadLocalObjectList	 î
(
î ï
handle
ï õ
)
õ ú
)
ú ù
;
ù û
readonly 
ThreadLocalPool  
.  !
Handle! '
returnHandle( 4
;4 5!
ThreadLocalObjectList 
( 
ThreadLocalPool -
.- .
Handle. 4
returnHandle5 A
)A B
{ 	
this 
. 
returnHandle 
= 
returnHandle  ,
;, -
} 	
public 
static !
ThreadLocalObjectList +
NewInstance, 7
(7 8
)8 9
=>: <
NewInstance= H
(H I"
DefaultInitialCapacityI _
)_ `
;` a
public 
static !
ThreadLocalObjectList +
NewInstance, 7
(7 8
int8 ;
minCapacity< G
)G H
{ 	!
ThreadLocalObjectList !
ret" %
=& '
Pool( ,
., -
Take- 1
(1 2
)2 3
;3 4
if 
( 
ret 
. 
Capacity 
< 
minCapacity *
)* +
{ 
ret 
. 
Capacity 
= 
minCapacity *
;* +
} 
return 
ret 
; 
}   	
public"" 
void"" 
Return"" 
("" 
)"" 
{## 	
this$$ 
.$$ 
Clear$$ 
($$ 
)$$ 
;$$ 
this%% 
.%% 
returnHandle%% 
.%% 
Release%% %
(%%% &
this%%& *
)%%* +
;%%+ ,
}&& 	
}'' 
}(( ¿˜
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\ThreadLocalPool.cs
	namespace 	
DotNetty
 
. 
Common 
{ 
public 

class 
ThreadLocalPool  
{ 
public 
abstract 
class 
Handle $
{ 	
public 
abstract 
void  
Release! (
<( )
T) *
>* +
(+ ,
T, -
value. 3
)3 4
where 
T 
: 
class 
;  
} 	
	protected 
sealed 
class 

NoopHandle )
:* +
Handle, 2
{ 	
public 
static 
readonly "

NoopHandle# -
Instance. 6
=7 8
new9 <

NoopHandle= G
(G H
)H I
;I J

NoopHandle 
( 
) 
{ 
} 
public 
override 
void  
Release! (
<( )
T) *
>* +
(+ ,
T, -
value. 3
)3 4
{ 
}   
}!! 	
	protected## 
sealed## 
class## 
DefaultHandle## ,
:##- .
Handle##/ 5
{$$ 	
internal%% 
int%% 
lastRecycledId%% '
;%%' (
internal&& 
int&& 
	recycleId&& "
;&&" #
internal(( 
bool(( 
hasBeenRecycled(( )
;(() *
internal** 
object** 
Value** !
;**! "
internal++ 
Stack++ 
Stack++  
;++  !
internal-- 
DefaultHandle-- "
(--" #
Stack--# (
stack--) .
)--. /
{.. 
this// 
.// 
Stack// 
=// 
stack// "
;//" #
}00 
public22 
override22 
void22  
Release22! (
<22( )
T22) *
>22* +
(22+ ,
T22, -
value22. 3
)223 4
{33 
Contract44 
.44 
Requires44 !
(44! "
value44" '
==44( *
this44+ /
.44/ 0
Value440 5
,445 6
$str447 f
)44f g
;44g h
Stack66 
stack66 
=66 
this66 "
.66" #
Stack66# (
;66( )
if77 
(77 
lastRecycledId77 "
!=77# %
	recycleId77& /
||770 2
stack773 8
==779 ;
null77< @
)77@ A
{88 
throw99 
new99 %
InvalidOperationException99 7
(997 8
$str998 J
)99J K
;99K L
}:: 
stack;; 
.;; 
Push;; 
(;; 
this;; 
);;  
;;;  !
}<< 
}== 	
	protectedAA 
sealedAA 
classAA 
WeakOrderQueueAA -
{BB 	
internalCC 
staticCC 
readonlyCC $
WeakOrderQueueCC% 3
DummyCC4 9
=CC: ;
newCC< ?
WeakOrderQueueCC@ N
(CCN O
)CCO P
;CCP Q
sealedEE 
classEE 
LinkEE 
{FF 
privateGG 
intGG 

writeIndexGG &
;GG& '
internalII 
readonlyII !
DefaultHandleII" /
[II/ 0
]II0 1
elementsII2 :
=II; <
newII= @
DefaultHandleIIA N
[IIN O
LinkCapacityIIO [
]II[ \
;II\ ]
internalJJ 
LinkJJ 
nextJJ "
;JJ" #
internalLL 
intLL 
	ReadIndexLL &
{LL' (
getLL) ,
;LL, -
setLL. 1
;LL1 2
}LL3 4
internalNN 
intNN 

WriteIndexNN '
{OO 
getPP 
=>PP 
VolatilePP #
.PP# $
ReadPP$ (
(PP( )
refPP) ,

writeIndexPP- 7
)PP7 8
;PP8 9
setQQ 
=>QQ 
VolatileQQ #
.QQ# $
WriteQQ$ )
(QQ) *
refQQ* -

writeIndexQQ. 8
,QQ8 9
valueQQ: ?
)QQ? @
;QQ@ A
}RR 
internalTT 
voidTT 
LazySetWriteIndexTT /
(TT/ 0
intTT0 3
valueTT4 9
)TT9 :
=>TT; =

writeIndexTT> H
=TTI J
valueTTK P
;TTP Q
}UU 
sealedYY 
classYY 
HeadYY 
{ZZ 
readonly[[ 
	StrongBox[[ "
<[[" #
int[[# &
>[[& '#
availableSharedCapacity[[( ?
;[[? @
readonly\\ 
	StrongBox\\ "
<\\" #
int\\# &
>\\& '
weakTableCounter\\( 8
;\\8 9
internal^^ 
Link^^ 
link^^ "
;^^" #
internal`` 
Head`` 
(`` 
	StrongBox`` '
<``' (
int``( +
>``+ ,#
availableSharedCapacity``- D
,``D E
	StrongBox``F O
<``O P
int``P S
>``S T
weakTableCounter``U e
)``e f
{aa 
thisbb 
.bb #
availableSharedCapacitybb 0
=bb1 2#
availableSharedCapacitybb3 J
;bbJ K
thiscc 
.cc 
weakTableCountercc )
=cc* +
weakTableCountercc, <
;cc< =
ifdd 
(dd 
weakTableCounterdd (
!=dd) +
nulldd, 0
)dd0 1
Interlockedee #
.ee# $
	Incrementee$ -
(ee- .
refee. 1
weakTableCounteree2 B
.eeB C
ValueeeC H
)eeH I
;eeI J
}ff 
~hh 
Headhh 
(hh 
)hh 
{ii 
ifjj 
(jj 
thisjj 
.jj 
weakTableCounterjj -
!=jj. 0
nulljj1 5
)jj5 6
{kk 
Interlockedll #
.ll# $
	Decrementll$ -
(ll- .
refll. 1
thisll2 6
.ll6 7
weakTableCounterll7 G
.llG H
ValuellH M
)llM N
;llN O
}mm 
ifnn 
(nn 
thisnn 
.nn #
availableSharedCapacitynn 4
==nn5 7
nullnn8 <
)nn< =
{oo 
returnpp 
;pp 
}qq 
Linkss 
headss 
=ss 
thisss  $
.ss$ %
linkss% )
;ss) *
thistt 
.tt 
linktt 
=tt 
nulltt  $
;tt$ %
whileuu 
(uu 
headuu 
!=uu  "
nulluu# '
)uu' (
{vv 
ReclaimSpaceww $
(ww$ %
LinkCapacityww% 1
)ww1 2
;ww2 3
Linkxx 
nextxx !
=xx" #
headxx$ (
.xx( )
nextxx) -
;xx- .
headzz 
.zz 
nextzz !
=zz" #
nullzz$ (
;zz( )
head{{ 
={{ 
next{{ #
;{{# $
}|| 
}}} 
internal 
void 
ReclaimSpace *
(* +
int+ .
space/ 4
)4 5
{
ÄÄ 
Debug
ÅÅ 
.
ÅÅ 
Assert
ÅÅ  
(
ÅÅ  !
space
ÅÅ! &
>=
ÅÅ' )
$num
ÅÅ* +
)
ÅÅ+ ,
;
ÅÅ, -
Interlocked
ÇÇ 
.
ÇÇ  
Add
ÇÇ  #
(
ÇÇ# $
ref
ÇÇ$ '%
availableSharedCapacity
ÇÇ( ?
.
ÇÇ? @
Value
ÇÇ@ E
,
ÇÇE F
space
ÇÇG L
)
ÇÇL M
;
ÇÇM N
}
ÉÉ 
internal
ÖÖ 
bool
ÖÖ 
ReserveSpace
ÖÖ *
(
ÖÖ* +
int
ÖÖ+ .
space
ÖÖ/ 4
)
ÖÖ4 5
{
ÜÜ 
return
áá 
ReserveSpace
áá '
(
áá' (%
availableSharedCapacity
áá( ?
,
áá? @
space
ááA F
)
ááF G
;
ááG H
}
àà 
internal
ää 
static
ää 
bool
ää  $
ReserveSpace
ää% 1
(
ää1 2
	StrongBox
ää2 ;
<
ää; <
int
ää< ?
>
ää? @%
availableSharedCapacity
ääA X
,
ääX Y
int
ääZ ]
space
ää^ c
)
ääc d
{
ãã 
Debug
åå 
.
åå 
Assert
åå  
(
åå  !
space
åå! &
>=
åå' )
$num
åå* +
)
åå+ ,
;
åå, -
for
çç 
(
çç 
;
çç 
;
çç 
)
çç 
{
éé 
int
èè 
	available
èè %
=
èè& '
Volatile
èè( 0
.
èè0 1
Read
èè1 5
(
èè5 6
ref
èè6 9%
availableSharedCapacity
èè: Q
.
èèQ R
Value
èèR W
)
èèW X
;
èèX Y
if
êê 
(
êê 
	available
êê %
<
êê& '
space
êê( -
)
êê- .
{
ëë 
return
íí "
false
íí# (
;
íí( )
}
ìì 
if
îî 
(
îî 
Interlocked
îî '
.
îî' (
CompareExchange
îî( 7
(
îî7 8
ref
îî8 ;%
availableSharedCapacity
îî< S
.
îîS T
Value
îîT Y
,
îîY Z
	available
îî[ d
-
îîe f
space
îîg l
,
îîl m
	available
îîn w
)
îîw x
==
îîy {
	availableîî| Ö
)îîÖ Ü
{
ïï 
return
ññ "
true
ññ# '
;
ññ' (
}
óó 
}
òò 
}
ôô 
}
öö 
readonly
ùù 
Head
ùù 
head
ùù 
;
ùù 
Link
ûû 
tail
ûû 
;
ûû 
internal
†† 
WeakOrderQueue
†† #
next
††$ (
;
††( )
internal
°° 
readonly
°° 
WeakReference
°° +
<
°°+ ,
Thread
°°, 2
>
°°2 3
owner
°°4 9
;
°°9 :
readonly
¢¢ 
int
¢¢ 
id
¢¢ 
=
¢¢ 
Interlocked
¢¢ )
.
¢¢) *
	Increment
¢¢* 3
(
¢¢3 4
ref
¢¢4 7
idSource
¢¢8 @
)
¢¢@ A
;
¢¢A B
WeakOrderQueue
§§ 
(
§§ 
)
§§ 
{
•• 
owner
¶¶ 
=
¶¶ 
null
¶¶ 
;
¶¶ 
head
ßß 
=
ßß 
new
ßß 
Head
ßß 
(
ßß  
null
ßß  $
,
ßß$ %
null
ßß& *
)
ßß* +
;
ßß+ ,
}
®® 
WeakOrderQueue
™™ 
(
™™ 
Stack
™™  
stack
™™! &
,
™™& '
Thread
™™( .
thread
™™/ 5
,
™™5 6 
DelayedThreadLocal
™™7 I
.
™™I J
CountedWeakTable
™™J Z
countedWeakTable
™™[ k
)
™™k l
{
´´ 
this
¨¨ 
.
¨¨ 
tail
¨¨ 
=
¨¨ 
new
¨¨ 
Link
¨¨  $
(
¨¨$ %
)
¨¨% &
;
¨¨& '
this
±± 
.
±± 
head
±± 
=
±± 
new
±± 
Head
±±  $
(
±±$ %
stack
±±% *
.
±±* +%
availableSharedCapacity
±±+ B
,
±±B C
countedWeakTable
±±D T
.
±±T U
Counter
±±U \
)
±±\ ]
;
±±] ^
this
≤≤ 
.
≤≤ 
head
≤≤ 
.
≤≤ 
link
≤≤ 
=
≤≤  
tail
≤≤! %
;
≤≤% &
this
≥≥ 
.
≥≥ 
owner
≥≥ 
=
≥≥ 
new
≥≥  
WeakReference
≥≥! .
<
≥≥. /
Thread
≥≥/ 5
>
≥≥5 6
(
≥≥6 7
thread
≥≥7 =
)
≥≥= >
;
≥≥> ?
}
¥¥ 
static
∂∂ 
WeakOrderQueue
∂∂ !
NewQueue
∂∂" *
(
∂∂* +
Stack
∂∂+ 0
stack
∂∂1 6
,
∂∂6 7
Thread
∂∂8 >
thread
∂∂? E
,
∂∂E F 
DelayedThreadLocal
∂∂G Y
.
∂∂Y Z
CountedWeakTable
∂∂Z j
countedWeakTable
∂∂k {
)
∂∂{ |
{
∑∑ 
WeakOrderQueue
∏∏ 
queue
∏∏ $
=
∏∏% &
new
∏∏' *
WeakOrderQueue
∏∏+ 9
(
∏∏9 :
stack
∏∏: ?
,
∏∏? @
thread
∏∏A G
,
∏∏G H
countedWeakTable
∏∏I Y
)
∏∏Y Z
;
∏∏Z [
stack
ªª 
.
ªª 
Head
ªª 
=
ªª 
queue
ªª "
;
ªª" #
return
ΩΩ 
queue
ΩΩ 
;
ΩΩ 
}
ææ 
internal
¿¿ 
WeakOrderQueue
¿¿ #
Next
¿¿$ (
{
¡¡ 
set
¬¬ 
{
√√ 
Debug
ƒƒ 
.
ƒƒ 
Assert
ƒƒ  
(
ƒƒ  !
value
ƒƒ! &
!=
ƒƒ' )
this
ƒƒ* .
)
ƒƒ. /
;
ƒƒ/ 0
this
≈≈ 
.
≈≈ 
next
≈≈ 
=
≈≈ 
value
≈≈  %
;
≈≈% &
}
∆∆ 
}
«« 
internal
ÃÃ 
static
ÃÃ 
WeakOrderQueue
ÃÃ *
Allocate
ÃÃ+ 3
(
ÃÃ3 4
Stack
ÃÃ4 9
stack
ÃÃ: ?
,
ÃÃ? @
Thread
ÃÃA G
thread
ÃÃH N
,
ÃÃN O 
DelayedThreadLocal
ÃÃP b
.
ÃÃb c
CountedWeakTable
ÃÃc s
countedWeakTableÃÃt Ñ
)ÃÃÑ Ö
{
ÕÕ 
return
œœ 
Head
œœ 
.
œœ 
ReserveSpace
œœ (
(
œœ( )
stack
œœ) .
.
œœ. /%
availableSharedCapacity
œœ/ F
,
œœF G
LinkCapacity
œœH T
)
œœT U
?
œœV W
NewQueue
œœX `
(
œœ` a
stack
œœa f
,
œœf g
thread
œœh n
,
œœn o
countedWeakTableœœp Ä
)œœÄ Å
:œœÇ É
nullœœÑ à
;œœà â
}
–– 
internal
““ 
void
““ 
Add
““ 
(
““ 
DefaultHandle
““ +
handle
““, 2
)
““2 3
{
”” 
handle
‘‘ 
.
‘‘ 
lastRecycledId
‘‘ %
=
‘‘& '
this
‘‘( ,
.
‘‘, -
id
‘‘- /
;
‘‘/ 0
Link
÷÷ 
tail
÷÷ 
=
÷÷ 
this
÷÷  
.
÷÷  !
tail
÷÷! %
;
÷÷% &
int
◊◊ 

writeIndex
◊◊ 
=
◊◊  
tail
◊◊! %
.
◊◊% &

WriteIndex
◊◊& 0
;
◊◊0 1
if
ÿÿ 
(
ÿÿ 

writeIndex
ÿÿ 
==
ÿÿ !
LinkCapacity
ÿÿ" .
)
ÿÿ. /
{
ŸŸ 
if
⁄⁄ 
(
⁄⁄ 
!
⁄⁄ 
head
⁄⁄ 
.
⁄⁄ 
ReserveSpace
⁄⁄ *
(
⁄⁄* +
LinkCapacity
⁄⁄+ 7
)
⁄⁄7 8
)
⁄⁄8 9
{
€€ 
return
›› 
;
›› 
}
ﬁﬁ 
this
‡‡ 
.
‡‡ 
tail
‡‡ 
=
‡‡ 
tail
‡‡  $
=
‡‡% &
tail
‡‡' +
.
‡‡+ ,
next
‡‡, 0
=
‡‡1 2
new
‡‡3 6
Link
‡‡7 ;
(
‡‡; <
)
‡‡< =
;
‡‡= >

writeIndex
·· 
=
··  
tail
··! %
.
··% &

WriteIndex
··& 0
;
··0 1
}
‚‚ 
tail
„„ 
.
„„ 
elements
„„ 
[
„„ 

writeIndex
„„ (
]
„„( )
=
„„* +
handle
„„, 2
;
„„2 3
handle
‰‰ 
.
‰‰ 
Stack
‰‰ 
=
‰‰ 
null
‰‰ #
;
‰‰# $
tail
ÁÁ 
.
ÁÁ 
LazySetWriteIndex
ÁÁ &
(
ÁÁ& '

writeIndex
ÁÁ' 1
+
ÁÁ2 3
$num
ÁÁ4 5
)
ÁÁ5 6
;
ÁÁ6 7
}
ËË 
internal
ÍÍ 
bool
ÍÍ 
HasFinalData
ÍÍ &
=>
ÍÍ' )
this
ÍÍ* .
.
ÍÍ. /
tail
ÍÍ/ 3
.
ÍÍ3 4
	ReadIndex
ÍÍ4 =
!=
ÍÍ> @
this
ÍÍA E
.
ÍÍE F
tail
ÍÍF J
.
ÍÍJ K

WriteIndex
ÍÍK U
;
ÍÍU V
internal
ÌÌ 
bool
ÌÌ 
Transfer
ÌÌ "
(
ÌÌ" #
Stack
ÌÌ# (
dst
ÌÌ) ,
)
ÌÌ, -
{
ÓÓ 
Link
ÔÔ 
head
ÔÔ 
=
ÔÔ 
this
ÔÔ  
.
ÔÔ  !
head
ÔÔ! %
.
ÔÔ% &
link
ÔÔ& *
;
ÔÔ* +
if
 
(
 
head
 
==
 
null
  
)
  !
{
ÒÒ 
return
ÚÚ 
false
ÚÚ  
;
ÚÚ  !
}
ÛÛ 
if
ıı 
(
ıı 
head
ıı 
.
ıı 
	ReadIndex
ıı "
==
ıı# %
LinkCapacity
ıı& 2
)
ıı2 3
{
ˆˆ 
if
˜˜ 
(
˜˜ 
head
˜˜ 
.
˜˜ 
next
˜˜ !
==
˜˜" $
null
˜˜% )
)
˜˜) *
{
¯¯ 
return
˘˘ 
false
˘˘ $
;
˘˘$ %
}
˙˙ 
this
˚˚ 
.
˚˚ 
head
˚˚ 
.
˚˚ 
link
˚˚ "
=
˚˚# $
head
˚˚% )
=
˚˚* +
head
˚˚, 0
.
˚˚0 1
next
˚˚1 5
;
˚˚5 6
}
¸¸ 
int
˛˛ 
srcStart
˛˛ 
=
˛˛ 
head
˛˛ #
.
˛˛# $
	ReadIndex
˛˛$ -
;
˛˛- .
int
ˇˇ 
srcEnd
ˇˇ 
=
ˇˇ 
head
ˇˇ !
.
ˇˇ! "

WriteIndex
ˇˇ" ,
;
ˇˇ, -
int
ÄÄ 
srcSize
ÄÄ 
=
ÄÄ 
srcEnd
ÄÄ $
-
ÄÄ% &
srcStart
ÄÄ' /
;
ÄÄ/ 0
if
ÅÅ 
(
ÅÅ 
srcSize
ÅÅ 
==
ÅÅ 
$num
ÅÅ  
)
ÅÅ  !
{
ÇÇ 
return
ÉÉ 
false
ÉÉ  
;
ÉÉ  !
}
ÑÑ 
int
ÜÜ 
dstSize
ÜÜ 
=
ÜÜ 
dst
ÜÜ !
.
ÜÜ! "
size
ÜÜ" &
;
ÜÜ& '
int
áá 
expectedCapacity
áá $
=
áá% &
dstSize
áá' .
+
áá/ 0
srcSize
áá1 8
;
áá8 9
if
ââ 
(
ââ 
expectedCapacity
ââ $
>
ââ% &
dst
ââ' *
.
ââ* +
elements
ââ+ 3
.
ââ3 4
Length
ââ4 :
)
ââ: ;
{
ää 
int
ãã 
actualCapacity
ãã &
=
ãã' (
dst
ãã) ,
.
ãã, -
IncreaseCapacity
ãã- =
(
ãã= >
expectedCapacity
ãã> N
)
ããN O
;
ããO P
srcEnd
åå 
=
åå 
Math
åå !
.
åå! "
Min
åå" %
(
åå% &
srcStart
åå& .
+
åå/ 0
actualCapacity
åå1 ?
-
åå@ A
dstSize
ååB I
,
ååI J
srcEnd
ååK Q
)
ååQ R
;
ååR S
}
çç 
if
èè 
(
èè 
srcStart
èè 
!=
èè 
srcEnd
èè  &
)
èè& '
{
êê 
DefaultHandle
ëë !
[
ëë! "
]
ëë" #
srcElems
ëë$ ,
=
ëë- .
head
ëë/ 3
.
ëë3 4
elements
ëë4 <
;
ëë< =
DefaultHandle
íí !
[
íí! "
]
íí" #
dstElems
íí$ ,
=
íí- .
dst
íí/ 2
.
íí2 3
elements
íí3 ;
;
íí; <
int
ìì 

newDstSize
ìì "
=
ìì# $
dstSize
ìì% ,
;
ìì, -
for
îî 
(
îî 
int
îî 
i
îî 
=
îî  
srcStart
îî! )
;
îî) *
i
îî+ ,
<
îî- .
srcEnd
îî/ 5
;
îî5 6
i
îî7 8
++
îî8 :
)
îî: ;
{
ïï 
DefaultHandle
ññ %
element
ññ& -
=
ññ. /
srcElems
ññ0 8
[
ññ8 9
i
ññ9 :
]
ññ: ;
;
ññ; <
if
óó 
(
óó 
element
óó #
.
óó# $
	recycleId
óó$ -
==
óó. 0
$num
óó1 2
)
óó2 3
{
òò 
element
ôô #
.
ôô# $
	recycleId
ôô$ -
=
ôô. /
element
ôô0 7
.
ôô7 8
lastRecycledId
ôô8 F
;
ôôF G
}
öö 
else
õõ 
if
õõ 
(
õõ  !
element
õõ! (
.
õõ( )
	recycleId
õõ) 2
!=
õõ3 5
element
õõ6 =
.
õõ= >
lastRecycledId
õõ> L
)
õõL M
{
úú 
throw
ùù !
new
ùù" %'
InvalidOperationException
ùù& ?
(
ùù? @
$str
ùù@ R
)
ùùR S
;
ùùS T
}
ûû 
srcElems
üü  
[
üü  !
i
üü! "
]
üü" #
=
üü$ %
null
üü& *
;
üü* +
if
°° 
(
°° 
dst
°° 
.
°°  

DropHandle
°°  *
(
°°* +
element
°°+ 2
)
°°2 3
)
°°3 4
{
¢¢ 
continue
§§ $
;
§§$ %
}
•• 
element
¶¶ 
.
¶¶  
Stack
¶¶  %
=
¶¶& '
dst
¶¶( +
;
¶¶+ ,
dstElems
ßß  
[
ßß  !

newDstSize
ßß! +
++
ßß+ -
]
ßß- .
=
ßß/ 0
element
ßß1 8
;
ßß8 9
}
®® 
if
™™ 
(
™™ 
srcEnd
™™ 
==
™™ !
LinkCapacity
™™" .
&&
™™/ 1
head
™™2 6
.
™™6 7
next
™™7 ;
!=
™™< >
null
™™? C
)
™™C D
{
´´ 
this
≠≠ 
.
≠≠ 
head
≠≠ !
.
≠≠! "
ReclaimSpace
≠≠" .
(
≠≠. /
LinkCapacity
≠≠/ ;
)
≠≠; <
;
≠≠< =
this
ÆÆ 
.
ÆÆ 
head
ÆÆ !
.
ÆÆ! "
link
ÆÆ" &
=
ÆÆ' (
head
ÆÆ) -
.
ÆÆ- .
next
ÆÆ. 2
;
ÆÆ2 3
}
ØØ 
head
±± 
.
±± 
	ReadIndex
±± "
=
±±# $
srcEnd
±±% +
;
±±+ ,
if
≤≤ 
(
≤≤ 
dst
≤≤ 
.
≤≤ 
size
≤≤  
==
≤≤! #

newDstSize
≤≤$ .
)
≤≤. /
{
≥≥ 
return
¥¥ 
false
¥¥ $
;
¥¥$ %
}
µµ 
dst
∂∂ 
.
∂∂ 
size
∂∂ 
=
∂∂ 

newDstSize
∂∂ )
;
∂∂) *
return
∑∑ 
true
∑∑ 
;
∑∑  
}
∏∏ 
else
ππ 
{
∫∫ 
return
ºº 
false
ºº  
;
ºº  !
}
ΩΩ 
}
ææ 
}
øø 	
	protected
¡¡ 
sealed
¡¡ 
class
¡¡ 
Stack
¡¡ $
{
¬¬ 	
internal
«« 
readonly
«« 
ThreadLocalPool
«« -
parent
««. 4
;
««4 5
internal
œœ 
readonly
œœ 
WeakReference
œœ +
<
œœ+ ,
Thread
œœ, 2
>
œœ2 3
	threadRef
œœ4 =
;
œœ= >
internal
–– 
readonly
–– 
	StrongBox
–– '
<
––' (
int
––( +
>
––+ ,%
availableSharedCapacity
––- D
;
––D E
internal
—— 
readonly
—— 
int
—— !
maxDelayedQueues
——" 2
;
——2 3
readonly
”” 
int
”” 
maxCapacity
”” $
;
””$ %
readonly
‘‘ 
int
‘‘ 
	ratioMask
‘‘ "
;
‘‘" #
internal
’’ 
DefaultHandle
’’ "
[
’’" #
]
’’# $
elements
’’% -
;
’’- .
internal
÷÷ 
int
÷÷ 
size
÷÷ 
;
÷÷ 
int
◊◊  
handleRecycleCount
◊◊ "
=
◊◊# $
-
◊◊% &
$num
◊◊& '
;
◊◊' (
WeakOrderQueue
ÿÿ 
cursorQueue
ÿÿ &
,
ÿÿ& '
	prevQueue
ÿÿ( 1
;
ÿÿ1 2
volatile
ŸŸ 
WeakOrderQueue
ŸŸ #
	headQueue
ŸŸ$ -
;
ŸŸ- .
internal
€€ 
Stack
€€ 
(
€€ 
ThreadLocalPool
€€ *
parent
€€+ 1
,
€€1 2
Thread
€€3 9
thread
€€: @
,
€€@ A
int
€€B E
maxCapacity
€€F Q
,
€€Q R
int
€€S V%
maxSharedCapacityFactor
€€W n
,
€€n o
int
‹‹ 
	ratioMask
‹‹ 
,
‹‹ 
int
‹‹ "
maxDelayedQueues
‹‹# 3
)
‹‹3 4
{
›› 
this
ﬁﬁ 
.
ﬁﬁ 
parent
ﬁﬁ 
=
ﬁﬁ 
parent
ﬁﬁ $
;
ﬁﬁ$ %
this
ﬂﬂ 
.
ﬂﬂ 
	threadRef
ﬂﬂ 
=
ﬂﬂ  
new
ﬂﬂ! $
WeakReference
ﬂﬂ% 2
<
ﬂﬂ2 3
Thread
ﬂﬂ3 9
>
ﬂﬂ9 :
(
ﬂﬂ: ;
thread
ﬂﬂ; A
)
ﬂﬂA B
;
ﬂﬂB C
this
‡‡ 
.
‡‡ 
maxCapacity
‡‡  
=
‡‡! "
maxCapacity
‡‡# .
;
‡‡. /
this
·· 
.
·· %
availableSharedCapacity
·· ,
=
··- .
new
··/ 2
	StrongBox
··3 <
<
··< =
int
··= @
>
··@ A
(
··A B
Math
··B F
.
··F G
Max
··G J
(
··J K
maxCapacity
··K V
/
··W X%
maxSharedCapacityFactor
··Y p
,
··p q
LinkCapacity
··r ~
)
··~ 
)·· Ä
;··Ä Å
this
‚‚ 
.
‚‚ 
elements
‚‚ 
=
‚‚ 
new
‚‚  #
DefaultHandle
‚‚$ 1
[
‚‚1 2
Math
‚‚2 6
.
‚‚6 7
Min
‚‚7 :
(
‚‚: ;$
DefaultInitialCapacity
‚‚; Q
,
‚‚Q R
maxCapacity
‚‚S ^
)
‚‚^ _
]
‚‚_ `
;
‚‚` a
this
„„ 
.
„„ 
	ratioMask
„„ 
=
„„  
	ratioMask
„„! *
;
„„* +
this
‰‰ 
.
‰‰ 
maxDelayedQueues
‰‰ %
=
‰‰& '
maxDelayedQueues
‰‰( 8
;
‰‰8 9
}
ÂÂ 
internal
ÁÁ 
WeakOrderQueue
ÁÁ #
Head
ÁÁ$ (
{
ËË 
set
ÈÈ 
{
ÍÍ 
lock
ÎÎ 
(
ÎÎ 
this
ÎÎ 
)
ÎÎ 
{
ÏÏ 
value
ÌÌ 
.
ÌÌ 
next
ÌÌ "
=
ÌÌ# $
	headQueue
ÌÌ% .
;
ÌÌ. /
	headQueue
ÓÓ !
=
ÓÓ" #
value
ÓÓ$ )
;
ÓÓ) *
}
ÔÔ 
}
 
}
ÒÒ 
internal
ÛÛ 
int
ÛÛ 
IncreaseCapacity
ÛÛ )
(
ÛÛ) *
int
ÛÛ* -
expectedCapacity
ÛÛ. >
)
ÛÛ> ?
{
ÙÙ 
int
ıı 
newCapacity
ıı 
=
ıı  !
this
ıı" &
.
ıı& '
elements
ıı' /
.
ıı/ 0
Length
ıı0 6
;
ıı6 7
int
ˆˆ 
maxCapacity
ˆˆ 
=
ˆˆ  !
this
ˆˆ" &
.
ˆˆ& '
maxCapacity
ˆˆ' 2
;
ˆˆ2 3
do
˜˜ 
{
¯¯ 
newCapacity
˘˘ 
<<=
˘˘  #
$num
˘˘$ %
;
˘˘% &
}
˙˙ 
while
˚˚ 
(
˚˚ 
newCapacity
˚˚ "
<
˚˚# $
expectedCapacity
˚˚% 5
&&
˚˚6 8
newCapacity
˚˚9 D
<
˚˚E F
maxCapacity
˚˚G R
)
˚˚R S
;
˚˚S T
newCapacity
˝˝ 
=
˝˝ 
Math
˝˝ "
.
˝˝" #
Min
˝˝# &
(
˝˝& '
newCapacity
˝˝' 2
,
˝˝2 3
maxCapacity
˝˝4 ?
)
˝˝? @
;
˝˝@ A
if
˛˛ 
(
˛˛ 
newCapacity
˛˛ 
!=
˛˛  "
this
˛˛# '
.
˛˛' (
elements
˛˛( 0
.
˛˛0 1
Length
˛˛1 7
)
˛˛7 8
{
ˇˇ 
Array
ÄÄ 
.
ÄÄ 
Resize
ÄÄ  
(
ÄÄ  !
ref
ÄÄ! $
this
ÄÄ% )
.
ÄÄ) *
elements
ÄÄ* 2
,
ÄÄ2 3
newCapacity
ÄÄ4 ?
)
ÄÄ? @
;
ÄÄ@ A
}
ÅÅ 
return
ÉÉ 
newCapacity
ÉÉ "
;
ÉÉ" #
}
ÑÑ 
internal
ÜÜ 
void
ÜÜ 
Push
ÜÜ 
(
ÜÜ 
DefaultHandle
ÜÜ ,
item
ÜÜ- 1
)
ÜÜ1 2
{
áá 
Thread
àà 
currentThread
àà $
=
àà% &
Thread
àà' -
.
àà- .
CurrentThread
àà. ;
;
àà; <
if
ââ 
(
ââ 
	threadRef
ââ 
.
ââ 
TryGetTarget
ââ *
(
ââ* +
out
ââ+ .
Thread
ââ/ 5
thread
ââ6 <
)
ââ< =
&&
ââ> @
thread
ââA G
==
ââH J
currentThread
ââK X
)
ââX Y
{
ää 
PushNow
åå 
(
åå 
item
åå  
)
åå  !
;
åå! "
}
çç 
else
éé 
{
èè 
	PushLater
ìì 
(
ìì 
item
ìì "
,
ìì" #
currentThread
ìì$ 1
)
ìì1 2
;
ìì2 3
}
îî 
}
ïï 
void
óó 
PushNow
óó 
(
óó 
DefaultHandle
óó &
item
óó' +
)
óó+ ,
{
òò 
if
ôô 
(
ôô 
(
ôô 
item
ôô 
.
ôô 
	recycleId
ôô #
|
ôô$ %
item
ôô& *
.
ôô* +
lastRecycledId
ôô+ 9
)
ôô9 :
!=
ôô; =
$num
ôô> ?
)
ôô? @
{
öö 
throw
õõ 
new
õõ '
InvalidOperationException
õõ 7
(
õõ7 8
$str
õõ8 J
)
õõJ K
;
õõK L
}
úú 
item
ùù 
.
ùù 
	recycleId
ùù 
=
ùù  
item
ùù! %
.
ùù% &
lastRecycledId
ùù& 4
=
ùù5 6
ownThreadId
ùù7 B
;
ùùB C
int
üü 
size
üü 
=
üü 
this
üü 
.
üü  
size
üü  $
;
üü$ %
if
†† 
(
†† 
size
†† 
>=
†† 
this
††  
.
††  !
maxCapacity
††! ,
||
††- /

DropHandle
††0 :
(
††: ;
item
††; ?
)
††? @
)
††@ A
{
°° 
return
££ 
;
££ 
}
§§ 
if
•• 
(
•• 
size
•• 
==
•• 
this
••  
.
••  !
elements
••! )
.
••) *
Length
••* 0
)
••0 1
{
¶¶ 
Array
ßß 
.
ßß 
Resize
ßß  
(
ßß  !
ref
ßß! $
this
ßß% )
.
ßß) *
elements
ßß* 2
,
ßß2 3
Math
ßß4 8
.
ßß8 9
Min
ßß9 <
(
ßß< =
size
ßß= A
<<
ßßB D
$num
ßßE F
,
ßßF G
this
ßßH L
.
ßßL M
maxCapacity
ßßM X
)
ßßX Y
)
ßßY Z
;
ßßZ [
}
®® 
this
™™ 
.
™™ 
elements
™™ 
[
™™ 
size
™™ "
]
™™" #
=
™™$ %
item
™™& *
;
™™* +
this
´´ 
.
´´ 
size
´´ 
=
´´ 
size
´´  
+
´´! "
$num
´´# $
;
´´$ %
}
¨¨ 
void
ÆÆ 
	PushLater
ÆÆ 
(
ÆÆ 
DefaultHandle
ÆÆ (
item
ÆÆ) -
,
ÆÆ- .
Thread
ÆÆ/ 5
thread
ÆÆ6 <
)
ÆÆ< =
{
ØØ  
DelayedThreadLocal
≥≥ "
.
≥≥" #
CountedWeakTable
≥≥# 3
countedWeakTable
≥≥4 D
=
≥≥E F
DelayedPool
≥≥G R
.
≥≥R S
Value
≥≥S X
;
≥≥X Y"
ConditionalWeakTable
¥¥ $
<
¥¥$ %
Stack
¥¥% *
,
¥¥* +
WeakOrderQueue
¥¥, :
>
¥¥: ;
delayedRecycled
¥¥< K
=
¥¥L M
countedWeakTable
¥¥N ^
.
¥¥^ _
	WeakTable
¥¥_ h
;
¥¥h i
delayedRecycled
µµ 
.
µµ  
TryGetValue
µµ  +
(
µµ+ ,
this
µµ, 0
,
µµ0 1
out
µµ2 5
WeakOrderQueue
µµ6 D
queue
µµE J
)
µµJ K
;
µµK L
if
∂∂ 
(
∂∂ 
queue
∂∂ 
==
∂∂ 
null
∂∂ !
)
∂∂! "
{
∑∑ 
if
∏∏ 
(
∏∏ 
Volatile
∏∏  
.
∏∏  !
Read
∏∏! %
(
∏∏% &
ref
∏∏& )
countedWeakTable
∏∏* :
.
∏∏: ;
Counter
∏∏; B
.
∏∏B C
Value
∏∏C H
)
∏∏H I
>=
∏∏J L
maxDelayedQueues
∏∏M ]
)
∏∏] ^
{
ππ 
delayedRecycled
ªª '
.
ªª' (
Add
ªª( +
(
ªª+ ,
this
ªª, 0
,
ªª0 1
WeakOrderQueue
ªª2 @
.
ªª@ A
Dummy
ªªA F
)
ªªF G
;
ªªG H
return
ºº 
;
ºº 
}
ΩΩ 
if
øø 
(
øø 
(
øø 
queue
øø 
=
øø  
WeakOrderQueue
øø! /
.
øø/ 0
Allocate
øø0 8
(
øø8 9
this
øø9 =
,
øø= >
thread
øø? E
,
øøE F
countedWeakTable
øøG W
)
øøW X
)
øøX Y
==
øøZ \
null
øø] a
)
øøa b
{
¿¿ 
return
¬¬ 
;
¬¬ 
}
√√ 
delayedRecycled
ƒƒ #
.
ƒƒ# $
Add
ƒƒ$ '
(
ƒƒ' (
this
ƒƒ( ,
,
ƒƒ, -
queue
ƒƒ. 3
)
ƒƒ3 4
;
ƒƒ4 5
}
≈≈ 
else
∆∆ 
if
∆∆ 
(
∆∆ 
queue
∆∆ 
==
∆∆ !
WeakOrderQueue
∆∆" 0
.
∆∆0 1
Dummy
∆∆1 6
)
∆∆6 7
{
«« 
return
…… 
;
…… 
}
   
queue
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
item
ÃÃ 
)
ÃÃ 
;
ÃÃ  
}
ÕÕ 
internal
œœ 
bool
œœ 

DropHandle
œœ $
(
œœ$ %
DefaultHandle
œœ% 2
handle
œœ3 9
)
œœ9 :
{
–– 
if
—— 
(
—— 
!
—— 
handle
—— 
.
—— 
hasBeenRecycled
—— +
)
——+ ,
{
““ 
if
”” 
(
”” 
(
”” 
++
””  
handleRecycleCount
”” -
&
””. /
	ratioMask
””0 9
)
””9 :
!=
””; =
$num
””> ?
)
””? @
{
‘‘ 
return
÷÷ 
true
÷÷ #
;
÷÷# $
}
◊◊ 
handle
ÿÿ 
.
ÿÿ 
hasBeenRecycled
ÿÿ *
=
ÿÿ+ ,
true
ÿÿ- 1
;
ÿÿ1 2
}
ŸŸ 
return
⁄⁄ 
false
⁄⁄ 
;
⁄⁄ 
}
€€ 
internal
›› 
DefaultHandle
›› "
	NewHandle
››# ,
(
››, -
)
››- .
=>
››/ 1
new
››2 5
DefaultHandle
››6 C
(
››C D
this
››D H
)
››H I
;
››I J
internal
ﬂﬂ 
bool
ﬂﬂ 
TryPop
ﬂﬂ  
(
ﬂﬂ  !
out
ﬂﬂ! $
DefaultHandle
ﬂﬂ% 2
item
ﬂﬂ3 7
)
ﬂﬂ7 8
{
‡‡ 
int
·· 
size
·· 
=
·· 
this
·· 
.
··  
size
··  $
;
··$ %
if
‚‚ 
(
‚‚ 
size
‚‚ 
==
‚‚ 
$num
‚‚ 
)
‚‚ 
{
„„ 
if
‰‰ 
(
‰‰ 
!
‰‰ 
this
‰‰ 
.
‰‰ 
Scavenge
‰‰ &
(
‰‰& '
)
‰‰' (
)
‰‰( )
{
ÂÂ 
item
ÊÊ 
=
ÊÊ 
null
ÊÊ #
;
ÊÊ# $
return
ÁÁ 
false
ÁÁ $
;
ÁÁ$ %
}
ËË 
size
ÈÈ 
=
ÈÈ 
this
ÈÈ 
.
ÈÈ  
size
ÈÈ  $
;
ÈÈ$ %
}
ÍÍ 
size
ÎÎ 
--
ÎÎ 
;
ÎÎ 
DefaultHandle
ÏÏ 
ret
ÏÏ !
=
ÏÏ" #
this
ÏÏ$ (
.
ÏÏ( )
elements
ÏÏ) 1
[
ÏÏ1 2
size
ÏÏ2 6
]
ÏÏ6 7
;
ÏÏ7 8
elements
ÌÌ 
[
ÌÌ 
size
ÌÌ 
]
ÌÌ 
=
ÌÌ  
null
ÌÌ! %
;
ÌÌ% &
if
ÓÓ 
(
ÓÓ 
ret
ÓÓ 
.
ÓÓ 
lastRecycledId
ÓÓ &
!=
ÓÓ' )
ret
ÓÓ* -
.
ÓÓ- .
	recycleId
ÓÓ. 7
)
ÓÓ7 8
{
ÔÔ 
throw
 
new
 '
InvalidOperationException
 7
(
7 8
$str
8 Q
)
Q R
;
R S
}
ÒÒ 
ret
ÚÚ 
.
ÚÚ 
	recycleId
ÚÚ 
=
ÚÚ 
$num
ÚÚ  !
;
ÚÚ! "
ret
ÛÛ 
.
ÛÛ 
lastRecycledId
ÛÛ "
=
ÛÛ# $
$num
ÛÛ% &
;
ÛÛ& '
this
ÙÙ 
.
ÙÙ 
size
ÙÙ 
=
ÙÙ 
size
ÙÙ  
;
ÙÙ  !
item
ˆˆ 
=
ˆˆ 
ret
ˆˆ 
;
ˆˆ 
return
˜˜ 
true
˜˜ 
;
˜˜ 
}
¯¯ 
bool
˙˙ 
Scavenge
˙˙ 
(
˙˙ 
)
˙˙ 
{
˚˚ 
if
˝˝ 
(
˝˝ 
this
˝˝ 
.
˝˝ 
ScavengeSome
˝˝ %
(
˝˝% &
)
˝˝& '
)
˝˝' (
{
˛˛ 
return
ˇˇ 
true
ˇˇ 
;
ˇˇ  
}
ÄÄ 
this
ÉÉ 
.
ÉÉ 
	prevQueue
ÉÉ 
=
ÉÉ  
null
ÉÉ! %
;
ÉÉ% &
this
ÑÑ 
.
ÑÑ 
cursorQueue
ÑÑ  
=
ÑÑ! "
this
ÑÑ# '
.
ÑÑ' (
	headQueue
ÑÑ( 1
;
ÑÑ1 2
return
ÖÖ 
false
ÖÖ 
;
ÖÖ 
}
ÜÜ 
bool
àà 
ScavengeSome
àà 
(
àà 
)
àà 
{
ââ 
WeakOrderQueue
ää 
prev
ää #
;
ää# $
WeakOrderQueue
ãã 
cursor
ãã %
=
ãã& '
this
ãã( ,
.
ãã, -
cursorQueue
ãã- 8
;
ãã8 9
if
åå 
(
åå 
cursor
åå 
==
åå 
null
åå "
)
åå" #
{
çç 
prev
éé 
=
éé 
null
éé 
;
éé  
cursor
èè 
=
èè 
this
èè !
.
èè! "
	headQueue
èè" +
;
èè+ ,
if
êê 
(
êê 
cursor
êê 
==
êê !
null
êê" &
)
êê& '
{
ëë 
return
íí 
false
íí $
;
íí$ %
}
ìì 
}
îî 
else
ïï 
{
ññ 
prev
óó 
=
óó 
this
óó 
.
óó  
	prevQueue
óó  )
;
óó) *
}
òò 
bool
öö 
success
öö 
=
öö 
false
öö $
;
öö$ %
do
õõ 
{
úú 
if
ùù 
(
ùù 
cursor
ùù 
.
ùù 
Transfer
ùù '
(
ùù' (
this
ùù( ,
)
ùù, -
)
ùù- .
{
ûû 
success
üü 
=
üü  !
true
üü" &
;
üü& '
break
†† 
;
†† 
}
°° 
WeakOrderQueue
££ "
next
££# '
=
££( )
cursor
££* 0
.
££0 1
next
££1 5
;
££5 6
if
§§ 
(
§§ 
!
§§ 
cursor
§§ 
.
§§  
owner
§§  %
.
§§% &
TryGetTarget
§§& 2
(
§§2 3
out
§§3 6
_
§§7 8
)
§§8 9
)
§§9 :
{
•• 
if
©© 
(
©© 
cursor
©© "
.
©©" #
HasFinalData
©©# /
)
©©/ 0
{
™™ 
for
´´ 
(
´´  !
;
´´! "
;
´´" #
)
´´# $
{
¨¨ 
if
≠≠  "
(
≠≠# $
cursor
≠≠$ *
.
≠≠* +
Transfer
≠≠+ 3
(
≠≠3 4
this
≠≠4 8
)
≠≠8 9
)
≠≠9 :
{
ÆÆ  !
success
ØØ$ +
=
ØØ, -
true
ØØ. 2
;
ØØ2 3
}
∞∞  !
else
±±  $
{
≤≤  !
break
≥≥$ )
;
≥≥) *
}
¥¥  !
}
µµ 
}
∂∂ 
if
∑∑ 
(
∑∑ 
prev
∑∑  
!=
∑∑! #
null
∑∑$ (
)
∑∑( )
{
∏∏ 
prev
ππ  
.
ππ  !
Next
ππ! %
=
ππ& '
next
ππ( ,
;
ππ, -
}
∫∫ 
}
ªª 
else
ºº 
{
ΩΩ 
prev
ææ 
=
ææ 
cursor
ææ %
;
ææ% &
}
øø 
cursor
¡¡ 
=
¡¡ 
next
¡¡ !
;
¡¡! "
}
¬¬ 
while
√√ 
(
√√ 
cursor
√√ 
!=
√√  
null
√√! %
&&
√√& (
!
√√) *
success
√√* 1
)
√√1 2
;
√√2 3
this
≈≈ 
.
≈≈ 
	prevQueue
≈≈ 
=
≈≈  
prev
≈≈! %
;
≈≈% &
this
∆∆ 
.
∆∆ 
cursorQueue
∆∆  
=
∆∆! "
cursor
∆∆# )
;
∆∆) *
return
«« 
success
«« 
;
«« 
}
»» 
}
…… 	
const
ÀÀ 
int
ÀÀ 0
"DefaultInitialMaxCapacityPerThread
ÀÀ 4
=
ÀÀ5 6
$num
ÀÀ7 8
*
ÀÀ9 :
$num
ÀÀ; ?
;
ÀÀ? @
	protected
ÃÃ 
static
ÃÃ 
readonly
ÃÃ !
int
ÃÃ" %)
DefaultMaxCapacityPerThread
ÃÃ& A
;
ÃÃA B
	protected
ÕÕ 
static
ÕÕ 
readonly
ÕÕ !
int
ÕÕ" %$
DefaultInitialCapacity
ÕÕ& <
;
ÕÕ< =
	protected
ŒŒ 
static
ŒŒ 
readonly
ŒŒ !
int
ŒŒ" %,
DefaultMaxSharedCapacityFactor
ŒŒ& D
;
ŒŒD E
	protected
œœ 
static
œœ 
readonly
œœ !
int
œœ" %.
 DefaultMaxDelayedQueuesPerThread
œœ& F
;
œœF G
	protected
–– 
static
–– 
readonly
–– !
int
––" %
LinkCapacity
––& 2
;
––2 3
	protected
—— 
static
—— 
readonly
—— !
int
——" %
DefaultRatio
——& 2
;
——2 3
static
““ 
int
““ 
idSource
““ 
=
““ 
int
““ !
.
““! "
MinValue
““" *
;
““* +
static
”” 
readonly
”” 
int
”” 
ownThreadId
”” '
=
””( )
Interlocked
””* 5
.
””5 6
	Increment
””6 ?
(
””? @
ref
””@ C
idSource
””D L
)
””L M
;
””M N
	protected
’’ 
static
’’ 
readonly
’’ ! 
DelayedThreadLocal
’’" 4
DelayedPool
’’5 @
=
’’A B
new
’’C F 
DelayedThreadLocal
’’G Y
(
’’Y Z
)
’’Z [
;
’’[ \
	protected
◊◊ 
sealed
◊◊ 
class
◊◊  
DelayedThreadLocal
◊◊ 1
:
◊◊2 3
FastThreadLocal
◊◊4 C
<
◊◊C D 
DelayedThreadLocal
◊◊D V
.
◊◊V W
CountedWeakTable
◊◊W g
>
◊◊g h
{
ÿÿ 	
public
ŸŸ 
class
ŸŸ 
CountedWeakTable
ŸŸ )
{
⁄⁄ 
internal
€€ 
readonly
€€ !"
ConditionalWeakTable
€€" 6
<
€€6 7
Stack
€€7 <
,
€€< =
WeakOrderQueue
€€> L
>
€€L M
	WeakTable
€€N W
=
€€X Y
new
€€Z ]"
ConditionalWeakTable
€€^ r
<
€€r s
Stack
€€s x
,
€€x y
WeakOrderQueue€€z à
>€€à â
(€€â ä
)€€ä ã
;€€ã å
internal
›› 
readonly
›› !
	StrongBox
››" +
<
››+ ,
int
››, /
>
››/ 0
Counter
››1 8
=
››9 :
new
››; >
	StrongBox
››? H
<
››H I
int
››I L
>
››L M
(
››M N
)
››N O
;
››O P
}
ﬁﬁ 
	protected
ﬂﬂ 
override
ﬂﬂ 
CountedWeakTable
ﬂﬂ /
GetInitialValue
ﬂﬂ0 ?
(
ﬂﬂ? @
)
ﬂﬂ@ A
=>
ﬂﬂB D
new
ﬂﬂE H
CountedWeakTable
ﬂﬂI Y
(
ﬂﬂY Z
)
ﬂﬂZ [
;
ﬂﬂ[ \
}
‡‡ 	
static
‚‚ 
ThreadLocalPool
‚‚ 
(
‚‚ 
)
‚‚  
{
„„ 	
int
ÁÁ "
maxCapacityPerThread
ÁÁ $
=
ÁÁ% & 
SystemPropertyUtil
ÁÁ' 9
.
ÁÁ9 :
GetInt
ÁÁ: @
(
ÁÁ@ A
$str
ÁÁA i
,
ÁÁi j 
SystemPropertyUtil
ËË &
.
ËË& '
GetInt
ËË' -
(
ËË- .
$str
ËË. M
,
ËËM N0
"DefaultInitialMaxCapacityPerThread
ËËO q
)
ËËq r
)
ËËr s
;
ËËs t
if
ÈÈ 
(
ÈÈ "
maxCapacityPerThread
ÈÈ $
<
ÈÈ% &
$num
ÈÈ' (
)
ÈÈ( )
{
ÍÍ "
maxCapacityPerThread
ÎÎ $
=
ÎÎ% &0
"DefaultInitialMaxCapacityPerThread
ÎÎ' I
;
ÎÎI J
}
ÏÏ )
DefaultMaxCapacityPerThread
ÓÓ '
=
ÓÓ( )"
maxCapacityPerThread
ÓÓ* >
;
ÓÓ> ?,
DefaultMaxSharedCapacityFactor
 *
=
+ ,
Math
- 1
.
1 2
Max
2 5
(
5 6
$num
6 7
,
7 8 
SystemPropertyUtil
ÒÒ &
.
ÒÒ& '
GetInt
ÒÒ' -
(
ÒÒ- .
$str
ÒÒ. Y
,
ÒÒY Z
$num
ÚÚ 
)
ÚÚ 
)
ÚÚ 
;
ÚÚ  .
 DefaultMaxDelayedQueuesPerThread
ÙÙ ,
=
ÙÙ- .
Math
ÙÙ/ 3
.
ÙÙ3 4
Max
ÙÙ4 7
(
ÙÙ7 8
$num
ÙÙ8 9
,
ÙÙ9 : 
SystemPropertyUtil
ıı &
.
ıı& '
GetInt
ıı' -
(
ıı- .
$str
ıı. [
,
ıı[ \
Environment
˜˜ '
.
˜˜' (
ProcessorCount
˜˜( 6
*
˜˜7 8
$num
˜˜9 :
)
˜˜: ;
)
˜˜; <
;
˜˜< =
LinkCapacity
˘˘ 
=
˘˘ 
MathUtil
˘˘ #
.
˘˘# $,
SafeFindNextPositivePowerOfTwo
˘˘$ B
(
˘˘B C
Math
˙˙ 
.
˙˙ 
Max
˙˙ 
(
˙˙  
SystemPropertyUtil
˙˙ /
.
˙˙/ 0
GetInt
˙˙0 6
(
˙˙6 7
$str
˙˙7 W
,
˙˙W X
$num
˙˙Y [
)
˙˙[ \
,
˙˙\ ]
$num
˙˙^ `
)
˙˙` a
)
˙˙a b
;
˙˙b c
DefaultRatio
ˇˇ 
=
ˇˇ 
MathUtil
ˇˇ #
.
ˇˇ# $,
SafeFindNextPositivePowerOfTwo
ˇˇ$ B
(
ˇˇB C 
SystemPropertyUtil
ˇˇC U
.
ˇˇU V
GetInt
ˇˇV \
(
ˇˇ\ ]
$str
ˇˇ] v
,
ˇˇv w
$num
ˇˇx y
)
ˇˇy z
)
ˇˇz {
;
ˇˇ{ |
IInternalLogger
ÅÅ 
logger
ÅÅ "
=
ÅÅ# $#
InternalLoggerFactory
ÅÅ% :
.
ÅÅ: ;
GetInstance
ÅÅ; F
(
ÅÅF G
typeof
ÅÅG M
(
ÅÅM N
ThreadLocalPool
ÅÅN ]
)
ÅÅ] ^
)
ÅÅ^ _
;
ÅÅ_ `
if
ÇÇ 
(
ÇÇ 
logger
ÇÇ 
.
ÇÇ 
DebugEnabled
ÇÇ #
)
ÇÇ# $
{
ÉÉ 
if
ÑÑ 
(
ÑÑ )
DefaultMaxCapacityPerThread
ÑÑ /
==
ÑÑ0 2
$num
ÑÑ3 4
)
ÑÑ4 5
{
ÖÖ 
logger
ÜÜ 
.
ÜÜ 
Debug
ÜÜ  
(
ÜÜ  !
$str
ÜÜ! U
)
ÜÜU V
;
ÜÜV W
logger
áá 
.
áá 
Debug
áá  
(
áá  !
$str
áá! X
)
ááX Y
;
ááY Z
logger
àà 
.
àà 
Debug
àà  
(
àà  !
$str
àà! Z
)
ààZ [
;
àà[ \
logger
ââ 
.
ââ 
Debug
ââ  
(
ââ  !
$str
ââ! M
)
ââM N
;
ââN O
logger
ää 
.
ää 
Debug
ää  
(
ää  !
$str
ää! F
)
ääF G
;
ääG H
}
ãã 
else
åå 
{
çç 
logger
éé 
.
éé 
Debug
éé  
(
éé  !
$str
éé! O
,
ééO P)
DefaultMaxCapacityPerThread
ééQ l
)
éél m
;
éém n
logger
èè 
.
èè 
Debug
èè  
(
èè  !
$str
èè! R
,
èèR S,
DefaultMaxSharedCapacityFactor
èèT r
)
èèr s
;
èès t
logger
êê 
.
êê 
Debug
êê  
(
êê  !
$str
êê! T
,
êêT U.
 DefaultMaxDelayedQueuesPerThread
êêV v
)
êêv w
;
êêw x
logger
ëë 
.
ëë 
Debug
ëë  
(
ëë  !
$str
ëë! G
,
ëëG H
LinkCapacity
ëëI U
)
ëëU V
;
ëëV W
logger
íí 
.
íí 
Debug
íí  
(
íí  !
$str
íí! @
,
íí@ A
DefaultRatio
ííB N
)
ííN O
;
ííO P
}
ìì 
}
îî $
DefaultInitialCapacity
ññ "
=
ññ# $
Math
ññ% )
.
ññ) *
Min
ññ* -
(
ññ- .)
DefaultMaxCapacityPerThread
ññ. I
,
ññI J
$num
ññK N
)
ññN O
;
ññO P
}
óó 	
public
ôô 
ThreadLocalPool
ôô 
(
ôô 
int
ôô ""
maxCapacityPerThread
ôô# 7
)
ôô7 8
:
öö 
this
öö 
(
öö "
maxCapacityPerThread
öö (
,
öö( ),
DefaultMaxSharedCapacityFactor
öö* H
,
ööH I
DefaultRatio
ööJ V
,
ööV W.
 DefaultMaxDelayedQueuesPerThread
ööX x
)
ööx y
{
õõ 	
}
úú 	
public
ûû 
ThreadLocalPool
ûû 
(
ûû 
int
ûû ""
maxCapacityPerThread
ûû# 7
,
ûû7 8
int
ûû9 <%
maxSharedCapacityFactor
ûû= T
,
ûûT U
int
üü 
ratio
üü  
,
üü  !
int
üü" %'
maxDelayedQueuesPerThread
üü& ?
)
üü? @
{
†† 	
this
°° 
.
°° 
	ratioMask
°° 
=
°° 
MathUtil
°° %
.
°°% &,
SafeFindNextPositivePowerOfTwo
°°& D
(
°°D E
ratio
°°E J
)
°°J K
-
°°L M
$num
°°N O
;
°°O P
if
¢¢ 
(
¢¢ "
maxCapacityPerThread
¢¢ $
<=
¢¢% '
$num
¢¢( )
)
¢¢) *
{
££ 
this
§§ 
.
§§ "
maxCapacityPerThread
§§ )
=
§§* +
$num
§§, -
;
§§- .
this
•• 
.
•• %
maxSharedCapacityFactor
•• ,
=
••- .
$num
••/ 0
;
••0 1
this
¶¶ 
.
¶¶ '
maxDelayedQueuesPerThread
¶¶ .
=
¶¶/ 0
$num
¶¶1 2
;
¶¶2 3
}
ßß 
else
®® 
{
©© 
this
™™ 
.
™™ "
maxCapacityPerThread
™™ )
=
™™* +"
maxCapacityPerThread
™™, @
;
™™@ A
this
´´ 
.
´´ %
maxSharedCapacityFactor
´´ ,
=
´´- .
Math
´´/ 3
.
´´3 4
Max
´´4 7
(
´´7 8
$num
´´8 9
,
´´9 :%
maxSharedCapacityFactor
´´; R
)
´´R S
;
´´S T
this
¨¨ 
.
¨¨ '
maxDelayedQueuesPerThread
¨¨ .
=
¨¨/ 0
Math
¨¨1 5
.
¨¨5 6
Max
¨¨6 9
(
¨¨9 :
$num
¨¨: ;
,
¨¨; <'
maxDelayedQueuesPerThread
¨¨= V
)
¨¨V W
;
¨¨W X
}
≠≠ 
}
ÆÆ 	
	protected
∞∞ 
readonly
∞∞ 
int
∞∞ "
maxCapacityPerThread
∞∞ 3
;
∞∞3 4
	protected
±± 
readonly
±± 
int
±± 
	ratioMask
±± (
;
±±( )
	protected
≤≤ 
readonly
≤≤ 
int
≤≤ %
maxSharedCapacityFactor
≤≤ 6
;
≤≤6 7
	protected
≥≥ 
readonly
≥≥ 
int
≥≥ '
maxDelayedQueuesPerThread
≥≥ 8
;
≥≥8 9
}
¥¥ 
public
∂∂ 

sealed
∂∂ 
class
∂∂ 
ThreadLocalPool
∂∂ '
<
∂∂' (
T
∂∂( )
>
∂∂) *
:
∂∂+ ,
ThreadLocalPool
∂∂- <
where
∑∑ 
T
∑∑ 
:
∑∑ 
class
∑∑ 
{
∏∏ 
readonly
ππ 
ThreadLocalStack
ππ !
threadLocal
ππ" -
;
ππ- .
readonly
∫∫ 
bool
∫∫ 
	preCreate
∫∫ 
;
∫∫  
readonly
ªª 
Func
ªª 
<
ªª 
Handle
ªª 
,
ªª 
T
ªª 
>
ªª  
valueFactory
ªª! -
;
ªª- .
public
ΩΩ 
ThreadLocalPool
ΩΩ 
(
ΩΩ 
Func
ΩΩ #
<
ΩΩ# $
Handle
ΩΩ$ *
,
ΩΩ* +
T
ΩΩ, -
>
ΩΩ- .
valueFactory
ΩΩ/ ;
)
ΩΩ; <
:
ææ 
this
ææ 
(
ææ 
valueFactory
ææ 
,
ææ  )
DefaultMaxCapacityPerThread
ææ! <
)
ææ< =
{
øø 	
}
¿¿ 	
public
¬¬ 
ThreadLocalPool
¬¬ 
(
¬¬ 
Func
¬¬ #
<
¬¬# $
Handle
¬¬$ *
,
¬¬* +
T
¬¬, -
>
¬¬- .
valueFactory
¬¬/ ;
,
¬¬; <
int
¬¬= @"
maxCapacityPerThread
¬¬A U
)
¬¬U V
:
√√ 
this
√√ 
(
√√ 
valueFactory
√√ 
,
√√  "
maxCapacityPerThread
√√! 5
,
√√5 6)
DefaultMaxCapacityPerThread
√√7 R
,
√√R S
DefaultRatio
√√T `
,
√√` a)
DefaultMaxCapacityPerThread
√√b }
,
√√} ~
false√√ Ñ
)√√Ñ Ö
{
ƒƒ 	
}
≈≈ 	
public
«« 
ThreadLocalPool
«« 
(
«« 
Func
«« #
<
««# $
Handle
««$ *
,
««* +
T
««, -
>
««- .
valueFactory
««/ ;
,
««; <
int
««= @"
maxCapacityPerThread
««A U
,
««U V
bool
««W [
	preCreate
««\ e
)
««e f
:
»» 
this
»» 
(
»» 
valueFactory
»» 
,
»»  "
maxCapacityPerThread
»»! 5
,
»»5 6)
DefaultMaxCapacityPerThread
»»7 R
,
»»R S
DefaultRatio
»»T `
,
»»` a)
DefaultMaxCapacityPerThread
»»b }
,
»»} ~
false»» Ñ
)»»Ñ Ö
{
…… 	
}
   	
public
ÃÃ 
ThreadLocalPool
ÃÃ 
(
ÃÃ 
Func
ÃÃ #
<
ÃÃ# $
Handle
ÃÃ$ *
,
ÃÃ* +
T
ÃÃ, -
>
ÃÃ- .
valueFactory
ÃÃ/ ;
,
ÃÃ; <
int
ÃÃ= @"
maxCapacityPerThread
ÃÃA U
,
ÃÃU V
int
ÃÃW Z%
maxSharedCapacityFactor
ÃÃ[ r
)
ÃÃr s
:
ÕÕ 
this
ÕÕ 
(
ÕÕ 
valueFactory
ÕÕ 
,
ÕÕ  "
maxCapacityPerThread
ÕÕ! 5
,
ÕÕ5 6%
maxSharedCapacityFactor
ÕÕ7 N
,
ÕÕN O
DefaultRatio
ÕÕP \
,
ÕÕ\ ])
DefaultMaxCapacityPerThread
ÕÕ^ y
,
ÕÕy z
falseÕÕ{ Ä
)ÕÕÄ Å
{
ŒŒ 	
}
œœ 	
public
—— 
ThreadLocalPool
—— 
(
—— 
Func
—— #
<
——# $
Handle
——$ *
,
——* +
T
——, -
>
——- .
valueFactory
——/ ;
,
——; <
int
——= @"
maxCapacityPerThread
——A U
,
——U V
int
——W Z%
maxSharedCapacityFactor
——[ r
,
——r s
int
““ 
ratio
““  
,
““  !
int
““" %'
maxDelayedQueuesPerThread
““& ?
,
““? @
bool
““A E
	preCreate
““F O
=
““P Q
false
““R W
)
““W X
:
”” 
base
”” 
(
”” "
maxCapacityPerThread
”” '
,
””' (%
maxSharedCapacityFactor
””) @
,
””@ A
ratio
””B G
,
””G H'
maxDelayedQueuesPerThread
””I b
)
””b c
{
‘‘ 	
Contract
’’ 
.
’’ 
Requires
’’ 
(
’’ 
valueFactory
’’ *
!=
’’+ -
null
’’. 2
)
’’2 3
;
’’3 4
this
◊◊ 
.
◊◊ 
	preCreate
◊◊ 
=
◊◊ 
	preCreate
◊◊ &
;
◊◊& '
this
ŸŸ 
.
ŸŸ 
threadLocal
ŸŸ 
=
ŸŸ 
new
ŸŸ "
ThreadLocalStack
ŸŸ# 3
(
ŸŸ3 4
this
ŸŸ4 8
)
ŸŸ8 9
;
ŸŸ9 :
this
⁄⁄ 
.
⁄⁄ 
valueFactory
⁄⁄ 
=
⁄⁄ 
valueFactory
⁄⁄  ,
;
⁄⁄, -
}
€€ 	
public
›› 
T
›› 
Take
›› 
(
›› 
)
›› 
{
ﬁﬁ 	
if
ﬂﬂ 
(
ﬂﬂ "
maxCapacityPerThread
ﬂﬂ $
==
ﬂﬂ% '
$num
ﬂﬂ( )
)
ﬂﬂ) *
{
‡‡ 
return
·· 
this
·· 
.
·· 
valueFactory
·· (
(
··( )

NoopHandle
··) 3
.
··3 4
Instance
··4 <
)
··< =
;
··= >
}
‚‚ 
Stack
‰‰ 
stack
‰‰ 
=
‰‰ 
this
‰‰ 
.
‰‰ 
threadLocal
‰‰ *
.
‰‰* +
Value
‰‰+ 0
;
‰‰0 1
DefaultHandle
ÂÂ 
handle
ÂÂ  
;
ÂÂ  !
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
stack
ÊÊ 
.
ÊÊ 
TryPop
ÊÊ 
(
ÊÊ 
out
ÊÊ !
handle
ÊÊ" (
)
ÊÊ( )
)
ÊÊ) *
{
ÁÁ 
handle
ËË 
=
ËË 
CreateValue
ËË $
(
ËË$ %
stack
ËË% *
)
ËË* +
;
ËË+ ,
}
ÈÈ 
return
ÍÍ 
(
ÍÍ 
T
ÍÍ 
)
ÍÍ 
handle
ÍÍ 
.
ÍÍ 
Value
ÍÍ "
;
ÍÍ" #
}
ÎÎ 	
DefaultHandle
ÌÌ 
CreateValue
ÌÌ !
(
ÌÌ! "
Stack
ÌÌ" '
stack
ÌÌ( -
)
ÌÌ- .
{
ÓÓ 	
var
ÔÔ 
handle
ÔÔ 
=
ÔÔ 
stack
ÔÔ 
.
ÔÔ 
	NewHandle
ÔÔ (
(
ÔÔ( )
)
ÔÔ) *
;
ÔÔ* +
handle
 
.
 
Value
 
=
 
this
 
.
  
valueFactory
  ,
(
, -
handle
- 3
)
3 4
;
4 5
return
ÒÒ 
handle
ÒÒ 
;
ÒÒ 
}
ÚÚ 	
internal
ÙÙ 
int
ÙÙ !
ThreadLocalCapacity
ÙÙ (
=>
ÙÙ) +
this
ÙÙ, 0
.
ÙÙ0 1
threadLocal
ÙÙ1 <
.
ÙÙ< =
Value
ÙÙ= B
.
ÙÙB C
elements
ÙÙC K
.
ÙÙK L
Length
ÙÙL R
;
ÙÙR S
internal
ˆˆ 
int
ˆˆ 
ThreadLocalSize
ˆˆ $
=>
ˆˆ% '
this
ˆˆ( ,
.
ˆˆ, -
threadLocal
ˆˆ- 8
.
ˆˆ8 9
Value
ˆˆ9 >
.
ˆˆ> ?
size
ˆˆ? C
;
ˆˆC D
sealed
¯¯ 
class
¯¯ 
ThreadLocalStack
¯¯ %
:
¯¯& '
FastThreadLocal
¯¯( 7
<
¯¯7 8
Stack
¯¯8 =
>
¯¯= >
{
˘˘ 	
readonly
˙˙ 
ThreadLocalPool
˙˙ $
<
˙˙$ %
T
˙˙% &
>
˙˙& '
owner
˙˙( -
;
˙˙- .
public
¸¸ 
ThreadLocalStack
¸¸ #
(
¸¸# $
ThreadLocalPool
¸¸$ 3
<
¸¸3 4
T
¸¸4 5
>
¸¸5 6
owner
¸¸7 <
)
¸¸< =
{
˝˝ 
this
˛˛ 
.
˛˛ 
owner
˛˛ 
=
˛˛ 
owner
˛˛ "
;
˛˛" #
}
ˇˇ 
	protected
ÅÅ 
override
ÅÅ 
Stack
ÅÅ $
GetInitialValue
ÅÅ% 4
(
ÅÅ4 5
)
ÅÅ5 6
{
ÇÇ 
var
ÉÉ 
stack
ÉÉ 
=
ÉÉ 
new
ÉÉ 
Stack
ÉÉ  %
(
ÉÉ% &
this
ÉÉ& *
.
ÉÉ* +
owner
ÉÉ+ 0
,
ÉÉ0 1
Thread
ÉÉ2 8
.
ÉÉ8 9
CurrentThread
ÉÉ9 F
,
ÉÉF G
this
ÉÉH L
.
ÉÉL M
owner
ÉÉM R
.
ÉÉR S"
maxCapacityPerThread
ÉÉS g
,
ÉÉg h
this
ÑÑ 
.
ÑÑ 
owner
ÑÑ "
.
ÑÑ" #%
maxSharedCapacityFactor
ÑÑ# :
,
ÑÑ: ;
this
ÑÑ< @
.
ÑÑ@ A
owner
ÑÑA F
.
ÑÑF G
	ratioMask
ÑÑG P
,
ÑÑP Q
this
ÑÑR V
.
ÑÑV W
owner
ÑÑW \
.
ÑÑ\ ]'
maxDelayedQueuesPerThread
ÑÑ] v
)
ÑÑv w
;
ÑÑw x
if
ÖÖ 
(
ÖÖ 
this
ÖÖ 
.
ÖÖ 
owner
ÖÖ 
.
ÖÖ 
	preCreate
ÖÖ (
)
ÖÖ( )
{
ÜÜ 
for
áá 
(
áá 
int
áá 
i
áá 
=
áá  
$num
áá! "
;
áá" #
i
áá$ %
<
áá& '
this
áá( ,
.
áá, -
owner
áá- 2
.
áá2 3"
maxCapacityPerThread
áá3 G
;
ááG H
i
ááI J
++
ááJ L
)
ááL M
{
àà 
stack
ââ 
.
ââ 
Push
ââ "
(
ââ" #
this
ââ# '
.
ââ' (
owner
ââ( -
.
ââ- .
CreateValue
ââ. 9
(
ââ9 :
stack
ââ: ?
)
ââ? @
)
ââ@ A
;
ââA B
}
ää 
}
ãã 
return
åå 
stack
åå 
;
åå 
}
çç 
	protected
èè 
override
èè 
void
èè #
	OnRemoval
èè$ -
(
èè- .
Stack
èè. 3
value
èè4 9
)
èè9 :
{
êê 
if
íí 
(
íí 
value
íí 
.
íí 
	threadRef
íí #
.
íí# $
TryGetTarget
íí$ 0
(
íí0 1
out
íí1 4
Thread
íí5 ;
valueThread
íí< G
)
ííG H
&&
ííI K
valueThread
ííL W
==
ííX Z
Thread
íí[ a
.
íía b
CurrentThread
ííb o
)
íío p
{
ìì 
if
îî 
(
îî 
DelayedPool
îî #
.
îî# $
IsSet
îî$ )
(
îî) *
)
îî* +
)
îî+ ,
{
ïï 
DelayedPool
ññ #
.
ññ# $
Value
ññ$ )
.
ññ) *
	WeakTable
ññ* 3
.
ññ3 4
Remove
ññ4 :
(
ññ: ;
value
ññ; @
)
ññ@ A
;
ññA B
}
óó 
}
òò 
}
ôô 
}
öö 	
}
õõ 
}úú ÿ/
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\AbstractConstant.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public		 

abstract		 
class		 
AbstractConstant		 *
:		+ ,
	IConstant		- 6
{

 
static 
long 
nextUniquifier "
;" #
long 
volatileUniquifier 
;  
	protected 
AbstractConstant "
(" #
int# &
id' )
,) *
string+ 1
name2 6
)6 7
{ 	
this 
. 
Id 
= 
id 
; 
this 
. 
Name 
= 
name 
; 
} 	
public 
int 
Id 
{ 
get 
; 
} 
public 
string 
Name 
{ 
get  
;  !
}" #
public 
sealed 
override 
string %
ToString& .
(. /
)/ 0
=>1 3
this4 8
.8 9
Name9 =
;= >
	protected 
long 

Uniquifier !
{ 	
get 
{ 
long 
result 
; 
if   
(   
(   
result   
=   
Volatile   &
.  & '
Read  ' +
(  + ,
ref  , /
this  0 4
.  4 5
volatileUniquifier  5 G
)  G H
)  H I
==  J L
$num  M N
)  N O
{!! 
result"" 
="" 
Interlocked"" (
.""( )
	Increment"") 2
(""2 3
ref""3 6
nextUniquifier""7 E
)""E F
;""F G
long## 
previousUniquifier## +
=##, -
Interlocked##. 9
.##9 :
CompareExchange##: I
(##I J
ref##J M
this##N R
.##R S
volatileUniquifier##S e
,##e f
result##g m
,##m n
$num##o p
)##p q
;##q r
if$$ 
($$ 
previousUniquifier$$ *
!=$$+ -
$num$$. /
)$$/ 0
{%% 
result&& 
=&&  
previousUniquifier&&! 3
;&&3 4
}'' 
}(( 
return** 
result** 
;** 
}++ 
},, 	
}-- 
public00 

abstract00 
class00 
AbstractConstant00 *
<00* +
T00+ ,
>00, -
:00. /
AbstractConstant000 @
,00@ A
IComparable00B M
<00M N
T00N O
>00O P
,00P Q

IEquatable00R \
<00\ ]
T00] ^
>00^ _
where11 
T11 
:11 
AbstractConstant11 "
<11" #
T11# $
>11$ %
{22 
	protected44 
AbstractConstant44 "
(44" #
int44# &
id44' )
,44) *
string44+ 1
name442 6
)446 7
:55 
base55 
(55 
id55 
,55 
name55 
)55 
{66 	
}77 	
public99 
sealed99 
override99 
int99 "
GetHashCode99# .
(99. /
)99/ 0
=>991 3
base994 8
.998 9
GetHashCode999 D
(99D E
)99E F
;99F G
public;; 
sealed;; 
override;; 
bool;; #
Equals;;$ *
(;;* +
object;;+ 1
obj;;2 5
);;5 6
=>;;7 9
base;;: >
.;;> ?
Equals;;? E
(;;E F
obj;;F I
);;I J
;;;J K
public== 
bool== 
Equals== 
(== 
T== 
other== "
)==" #
=>==$ &
ReferenceEquals==' 6
(==6 7
this==7 ;
,==; <
other=== B
)==B C
;==C D
public?? 
int?? 
	CompareTo?? 
(?? 
T?? 
o??  
)??  !
{@@ 	
ifAA 
(AA 
ReferenceEqualsAA 
(AA  
thisAA  $
,AA$ %
oAA& '
)AA' (
)AA( )
{BB 
returnCC 
$numCC 
;CC 
}DD 
AbstractConstantFF 
<FF 
TFF 
>FF 
otherFF  %
=FF& '
oFF( )
;FF) *
intHH 

returnCodeHH 
=HH 
thisHH !
.HH! "
GetHashCodeHH" -
(HH- .
)HH. /
-HH0 1
otherHH2 7
.HH7 8
GetHashCodeHH8 C
(HHC D
)HHD E
;HHE F
ifII 
(II 

returnCodeII 
!=II 
$numII 
)II  
{JJ 
returnKK 

returnCodeKK !
;KK! "
}LL 
longNN 
thisUVNN 
=NN 
thisNN 
.NN 

UniquifierNN )
;NN) *
longOO 
otherUVOO 
=OO 
otherOO  
.OO  !

UniquifierOO! +
;OO+ ,
ifPP 
(PP 
thisUVPP 
<PP 
otherUVPP  
)PP  !
{QQ 
returnRR 
-RR 
$numRR 
;RR 
}SS 
ifTT 
(TT 
thisUVTT 
>TT 
otherUVTT  
)TT  !
{UU 
returnVV 
$numVV 
;VV 
}WW 
throwYY 
newYY 
	ExceptionYY 
(YY  
$strYY  K
)YYK L
;YYL M
}ZZ 	
}[[ 
}\\ ¯.
tC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\AbstractReferenceCounted.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

abstract 
class $
AbstractReferenceCounted 2
:3 4
IReferenceCounted5 F
{		 
int

 
referenceCount

 
=

 
$num

 
;

 
public 
int 
ReferenceCount !
=>" $
this% )
.) *
referenceCount* 8
;8 9
public 
IReferenceCounted  
Retain! '
(' (
)( )
=>* ,
this- 1
.1 2

RetainCore2 <
(< =
$num= >
)> ?
;? @
public 
IReferenceCounted  
Retain! '
(' (
int( +
	increment, 5
)5 6
{ 	
Contract 
. 
Requires 
( 
	increment '
>( )
$num* +
)+ ,
;, -
return 
this 
. 

RetainCore "
(" #
	increment# ,
), -
;- .
} 	
	protected 
virtual 
IReferenceCounted +

RetainCore, 6
(6 7
int7 :
	increment; D
)D E
{ 	
while 
( 
true 
) 
{ 
int 
count 
= 
this  
.  !
referenceCount! /
;/ 0
int 
	nextCount 
= 
count  %
+& '
	increment( 1
;1 2
if 
( 
	nextCount 
<=  
	increment! *
)* +
{   /
#ThrowIllegalReferenceCountException!! 7
(!!7 8
count!!8 =
,!!= >
	increment!!? H
)!!H I
;!!I J
}"" 
if$$ 
($$ 
Interlocked$$ 
.$$  
CompareExchange$$  /
($$/ 0
ref$$0 3
this$$4 8
.$$8 9
referenceCount$$9 G
,$$G H
	nextCount$$I R
,$$R S
count$$T Y
)$$Y Z
==$$[ ]
count$$^ c
)$$c d
{%% 
break&& 
;&& 
}'' 
}(( 
return** 
this** 
;** 
}++ 	
public-- 
IReferenceCounted--  
Touch--! &
(--& '
)--' (
=>--) +
this--, 0
.--0 1
Touch--1 6
(--6 7
null--7 ;
)--; <
;--< =
public// 
abstract// 
IReferenceCounted// )
Touch//* /
(/// 0
object//0 6
hint//7 ;
)//; <
;//< =
public11 
bool11 
Release11 
(11 
)11 
=>11  
this11! %
.11% &
ReleaseCore11& 1
(111 2
$num112 3
)113 4
;114 5
public33 
bool33 
Release33 
(33 
int33 
	decrement33  )
)33) *
{44 	
Contract55 
.55 
Requires55 
(55 
	decrement55 '
>55( )
$num55* +
)55+ ,
;55, -
return77 
this77 
.77 
ReleaseCore77 #
(77# $
	decrement77$ -
)77- .
;77. /
}88 	
bool:: 
ReleaseCore:: 
(:: 
int:: 
	decrement:: &
)::& '
{;; 	
while<< 
(<< 
true<< 
)<< 
{== 
int>> 
count>> 
=>> 
this>>  
.>>  !
referenceCount>>! /
;>>/ 0
if?? 
(?? 
count?? 
<?? 
	decrement?? %
)??% &
{@@ /
#ThrowIllegalReferenceCountExceptionAA 7
(AA7 8
countAA8 =
,AA= >
	decrementAA? H
)AAH I
;AAI J
}BB 
ifDD 
(DD 
InterlockedDD 
.DD  
CompareExchangeDD  /
(DD/ 0
refDD0 3
thisDD4 8
.DD8 9
referenceCountDD9 G
,DDG H
countDDI N
-DDO P
	decrementDDQ Z
,DDZ [
countDD\ a
)DDa b
==DDc e
	decrementDDf o
)DDo p
{EE 
thisFF 
.FF 

DeallocateFF #
(FF# $
)FF$ %
;FF% &
returnGG 
trueGG  
;GG  !
}HH 
returnJJ 
falseJJ 
;JJ 
}KK 
}LL 	
[NN 	

MethodImplNN	 
(NN 
MethodImplOptionsNN %
.NN% &

NoInliningNN& 0
)NN0 1
]NN1 2
staticOO 
voidOO /
#ThrowIllegalReferenceCountExceptionOO 7
(OO7 8
intOO8 ;
countOO< A
,OOA B
intOOC F
	incrementOOG P
)OOP Q
{PP 	
throwQQ -
!GetIllegalReferenceCountExceptionQQ 3
(QQ3 4
)QQ4 5
;QQ5 6*
IllegalReferenceCountExceptionSS *-
!GetIllegalReferenceCountExceptionSS+ L
(SSL M
)SSM N
{TT 
returnUU 
newUU *
IllegalReferenceCountExceptionUU 9
(UU9 :
countUU: ?
,UU? @
	incrementUUA J
)UUJ K
;UUK L
}VV 
}WW 	
	protectedYY 
abstractYY 
voidYY 

DeallocateYY  *
(YY* +
)YY+ ,
;YY, -
}ZZ 
}[[ Æ
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ActionTimerTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

class 
ActionTimerTask  
:! "

ITimerTask# -
{		 
readonly

 
Action

 
<

 
ITimeout

  
>

  !
action

" (
;

( )
public 
ActionTimerTask 
( 
Action %
<% &
ITimeout& .
>. /
action0 6
)6 7
=>8 :
this; ?
.? @
action@ F
=G H
actionI O
;O P
public 
void 
Run 
( 
ITimeout  
timeout! (
)( )
=>* ,
this- 1
.1 2
action2 8
(8 9
timeout9 @
)@ A
;A B
} 
} ‡N
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ArrayExtensions.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
ArrayExtensions '
{ 
public 
static 
readonly 
byte #
[# $
]$ %
	ZeroBytes& /
=0 1
new2 5
byte6 :
[: ;
$num; <
]< =
;= >
public 
static 
T 
[ 
] 
Slice 
<  
T  !
>! "
(" #
this# '
T( )
[) *
]* +
array, 1
,1 2
int3 6
length7 =
)= >
{ 	
Contract 
. 
Requires 
( 
array #
!=$ &
null' +
)+ ,
;, -
if 
( 
length 
> 
array 
. 
Length %
)% &
{ 
throw 
new '
ArgumentOutOfRangeException 5
(5 6
nameof6 <
(< =
length= C
)C D
,D E
$"F H
$strH O
{O P
lengthP V
}V W
$strW |
{| }
array	} Ç
.
Ç É
Length
É â
}
â ä
$str
ä ã
"
ã å
)
å ç
;
ç é
} 
return 
Slice 
( 
array 
, 
$num  !
,! "
length# )
)) *
;* +
} 	
public 
static 
T 
[ 
] 
Slice 
<  
T  !
>! "
(" #
this# '
T( )
[) *
]* +
array, 1
,1 2
int3 6
index7 <
,< =
int> A
lengthB H
)H I
{ 	
Contract 
. 
Requires 
( 
array #
!=$ &
null' +
)+ ,
;, -
if 
( 
index 
+ 
length 
>  
array! &
.& '
Length' -
)- .
{   
throw!! 
new!! '
ArgumentOutOfRangeException!! 5
(!!5 6
nameof!!6 <
(!!< =
length!!= C
)!!C D
,!!D E
$"!!F H
$str!!H P
{!!P Q
index!!Q V
}!!V W
$str!!W a
{!!a b
length!!b h
}!!h i
$str	!!i ù
{
!!ù û
array
!!û £
.
!!£ §
Length
!!§ ™
}
!!™ ´
$str
!!´ ¨
"
!!¨ ≠
)
!!≠ Æ
;
!!Æ Ø
}"" 
var## 
result## 
=## 
new## 
T## 
[## 
length## %
]##% &
;##& '
Array$$ 
.$$ 
Copy$$ 
($$ 
array$$ 
,$$ 
index$$ #
,$$# $
result$$% +
,$$+ ,
$num$$- .
,$$. /
length$$0 6
)$$6 7
;$$7 8
return%% 
result%% 
;%% 
}&& 	
public(( 
static(( 
void(( 
SetRange(( #
<((# $
T(($ %
>((% &
(((& '
this((' +
T((, -
[((- .
]((. /
array((0 5
,((5 6
int((7 :
index((; @
,((@ A
T((B C
[((C D
]((D E
src((F I
)((I J
=>((K M
SetRange((N V
(((V W
array((W \
,((\ ]
index((^ c
,((c d
src((e h
,((h i
$num((j k
,((k l
src((m p
.((p q
Length((q w
)((w x
;((x y
public** 
static** 
void** 
SetRange** #
<**# $
T**$ %
>**% &
(**& '
this**' +
T**, -
[**- .
]**. /
array**0 5
,**5 6
int**7 :
index**; @
,**@ A
T**B C
[**C D
]**D E
src**F I
,**I J
int**K N
srcIndex**O W
,**W X
int**Y \
	srcLength**] f
)**f g
{++ 	
Contract,, 
.,, 
Requires,, 
(,, 
array,, #
!=,,$ &
null,,' +
),,+ ,
;,,, -
Contract-- 
.-- 
Requires-- 
(-- 
src-- !
!=--" $
null--% )
)--) *
;--* +
if.. 
(.. 
index.. 
+.. 
	srcLength.. !
>.." #
array..$ )
...) *
Length..* 0
)..0 1
{// 
throw00 
new00 '
ArgumentOutOfRangeException00 5
(005 6
nameof006 <
(00< =
	srcLength00= F
)00F G
,00G H
$"00I K
$str00K S
{00S T
index00T Y
}00Y Z
$str00Z g
{00g h
	srcLength00h q
}00q r
$str	00r ¶
{
00¶ ß
array
00ß ¨
.
00¨ ≠
Length
00≠ ≥
}
00≥ ¥
$str
00¥ µ
"
00µ ∂
)
00∂ ∑
;
00∑ ∏
}11 
if22 
(22 
srcIndex22 
+22 
	srcLength22 $
>22% &
src22' *
.22* +
Length22+ 1
)221 2
{33 
throw44 
new44 '
ArgumentOutOfRangeException44 5
(445 6
nameof446 <
(44< =
	srcLength44= F
)44F G
,44G H
$"44I K
$str44K S
{44S T
srcIndex44T \
}44\ ]
$str44] j
{44j k
	srcLength44k t
}44t u
$str	44u ß
{
44ß ®
src
44® ´
.
44´ ¨
Length
44¨ ≤
}
44≤ ≥
$str
44≥ ¥
"
44¥ µ
)
44µ ∂
;
44∂ ∑
}55 
Array77 
.77 
Copy77 
(77 
src77 
,77 
srcIndex77 $
,77$ %
array77& +
,77+ ,
index77- 2
,772 3
	srcLength774 =
)77= >
;77> ?
}88 	
public:: 
static:: 
void:: 
Fill:: 
<::  
T::  !
>::! "
(::" #
this::# '
T::( )
[::) *
]::* +
array::, 1
,::1 2
T::3 4
value::5 :
)::: ;
{;; 	
for<< 
(<< 
int<< 
i<< 
=<< 
$num<< 
;<< 
i<< 
<<< 
array<<  %
.<<% &
Length<<& ,
;<<, -
i<<. /
++<</ 1
)<<1 2
{== 
array>> 
[>> 
i>> 
]>> 
=>> 
value>>  
;>>  !
}?? 
}@@ 	
publicBB 
staticBB 
voidBB 
FillBB 
<BB  
TBB  !
>BB! "
(BB" #
thisBB# '
TBB( )
[BB) *
]BB* +
arrayBB, 1
,BB1 2
intBB3 6
offsetBB7 =
,BB= >
intBB? B
countBBC H
,BBH I
TBBJ K
valueBBL Q
)BBQ R
{CC 	
ContractDD 
.DD 
RequiresDD 
(DD 
countDD #
+DD$ %
offsetDD& ,
<=DD- /
arrayDD0 5
.DD5 6
LengthDD6 <
)DD< =
;DD= >
forFF 
(FF 
intFF 
iFF 
=FF 
offsetFF 
;FF  
iFF! "
<FF# $
countFF% *
+FF+ ,
offsetFF- 3
;FF3 4
iFF5 6
++FF6 8
)FF8 9
{GG 
arrayHH 
[HH 
iHH 
]HH 
=HH 
valueHH  
;HH  !
}II 
}JJ 	
publicOO 
staticOO 
byteOO 
[OO 
]OO 
CombineBytesOO )
(OO) *
thisOO* .
byteOO/ 3
[OO3 4
]OO4 5
[OO5 6
]OO6 7
arraysOO8 >
)OO> ?
{PP 	
longQQ 
	newlengthQQ 
=QQ 
$numQQ 
;QQ 
foreachRR 
(RR 
byteRR 
[RR 
]RR 
arrayRR !
inRR" $
arraysRR% +
)RR+ ,
{SS 
	newlengthTT 
+=TT 
arrayTT "
.TT" #
LengthTT# )
;TT) *
}UU 
varWW 
mergedArrayWW 
=WW 
newWW !
byteWW" &
[WW& '
	newlengthWW' 0
]WW0 1
;WW1 2
intXX 
offsetXX 
=XX 
$numXX 
;XX 
foreachYY 
(YY 
byteYY 
[YY 
]YY 
arrayYY !
inYY" $
arraysYY% +
)YY+ ,
{ZZ 
Buffer[[ 
.[[ 
	BlockCopy[[  
([[  !
array[[! &
,[[& '
$num[[( )
,[[) *
mergedArray[[+ 6
,[[6 7
offset[[8 >
,[[> ?
array[[@ E
.[[E F
Length[[F L
)[[L M
;[[M N
offset\\ 
+=\\ 
array\\ 
.\\  
Length\\  &
;\\& '
}]] 
return__ 
mergedArray__ 
;__ 
}`` 	
}aa 
}bb ∏œ	
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\AsciiString.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class 
AsciiString #
:$ %
ICharSequence& 3
,3 4

IEquatable5 ?
<? @
AsciiString@ K
>K L
,L M
IComparableN Y
<Y Z
AsciiStringZ e
>e f
,f g
IComparableh s
{ 
public 
static 
readonly 
AsciiString *
Empty+ 0
=1 2
Cached3 9
(9 :
string: @
.@ A
EmptyA F
)F G
;G H
const 
int 
MaxCharValue 
=  
$num! $
;$ %
const 
byte 
Replacement 
=  
(! "
byte" &
)& '
$char' *
;* +
public 
static 
readonly 
int "
IndexNotFound# 0
=1 2
-3 4
$num4 5
;5 6
public 
static 
readonly 
IHashingStrategy /
</ 0
ICharSequence0 =
>= >!
CaseInsensitiveHasher? T
=U V
newW Z*
CaseInsensitiveHashingStrategy[ y
(y z
)z {
;{ |
public 
static 
readonly 
IHashingStrategy /
</ 0
ICharSequence0 =
>= >
CaseSensitiveHasher? R
=S T
newU X(
CaseSensitiveHashingStrategyY u
(u v
)v w
;w x
static 
readonly #
ICharEqualityComparator /!
DefaultCharComparator0 E
=F G
newH K)
DefaultCharEqualityComparatorL i
(i j
)j k
;k l
static 
readonly #
ICharEqualityComparator /,
 GeneralCaseInsensitiveComparator0 P
=Q R
newS V9
,GeneralCaseInsensitiveCharEqualityComparator	W É
(
É Ñ
)
Ñ Ö
;
Ö Ü
static 
readonly #
ICharEqualityComparator /.
"AsciiCaseInsensitiveCharComparator0 R
=S T
newU X7
*AsciiCaseInsensitiveCharEqualityComparator	Y É
(
É Ñ
)
Ñ Ö
;
Ö Ü
sealed 
class *
CaseInsensitiveHashingStrategy 3
:4 5
IHashingStrategy6 F
<F G
ICharSequenceG T
>T U
{   	
public!! 
int!! 
HashCode!! 
(!!  
ICharSequence!!  -
obj!!. 1
)!!1 2
=>!!3 5
AsciiString!!6 A
.!!A B
GetHashCode!!B M
(!!M N
obj!!N Q
)!!Q R
;!!R S
int## 
IEqualityComparer## !
<##! "
ICharSequence##" /
>##/ 0
.##0 1
GetHashCode##1 <
(##< =
ICharSequence##= J
obj##K N
)##N O
=>##P R
this##S W
.##W X
HashCode##X `
(##` a
obj##a d
)##d e
;##e f
public%% 
bool%% 
Equals%% 
(%% 
ICharSequence%% ,
a%%- .
,%%. /
ICharSequence%%0 =
b%%> ?
)%%? @
=>%%A C#
ContentEqualsIgnoreCase%%D [
(%%[ \
a%%\ ]
,%%] ^
b%%_ `
)%%` a
;%%a b
}&& 	
sealed(( 
class(( (
CaseSensitiveHashingStrategy(( 1
:((2 3
IHashingStrategy((4 D
<((D E
ICharSequence((E R
>((R S
{)) 	
public** 
int** 
HashCode** 
(**  
ICharSequence**  -
obj**. 1
)**1 2
=>**3 5
AsciiString**6 A
.**A B
GetHashCode**B M
(**M N
obj**N Q
)**Q R
;**R S
int,, 
IEqualityComparer,, !
<,,! "
ICharSequence,," /
>,,/ 0
.,,0 1
GetHashCode,,1 <
(,,< =
ICharSequence,,= J
obj,,K N
),,N O
=>,,P R
this,,S W
.,,W X
HashCode,,X `
(,,` a
obj,,a d
),,d e
;,,e f
public.. 
bool.. 
Equals.. 
(.. 
ICharSequence.. ,
a..- .
,... /
ICharSequence..0 =
b..> ?
)..? @
=>..A C
ContentEquals..D Q
(..Q R
a..R S
,..S T
b..U V
)..V W
;..W X
}// 	
readonly11 
byte11 
[11 
]11 
value11 
;11 
readonly22 
int22 
offset22 
;22 
readonly33 
int33 
length33 
;33 
int55 
hash55 
;55 
string88 
stringValue88 
;88 
internal;; 
AsciiString;; 
(;; 
byte;; !
[;;! "
];;" #
value;;$ )
);;) *
{<< 	
this== 
.== 
value== 
=== 
value== 
;== 
this>> 
.>> 
offset>> 
=>> 
$num>> 
;>> 
this?? 
.?? 
length?? 
=?? 
value?? 
.??  
Length??  &
;??& '
}@@ 	
publicBB 
AsciiStringBB 
(BB 
byteBB 
[BB  
]BB  !
valueBB" '
,BB' (
boolBB) -
copyBB. 2
)BB2 3
:BB4 5
thisBB6 :
(BB: ;
valueBB; @
,BB@ A
$numBBB C
,BBC D
valueBBE J
.BBJ K
LengthBBK Q
,BBQ R
copyBBS W
)BBW X
{CC 	
}DD 	
publicFF 
AsciiStringFF 
(FF 
byteFF 
[FF  
]FF  !
valueFF" '
,FF' (
intFF) ,
startFF- 2
,FF2 3
intFF4 7
lengthFF8 >
,FF> ?
boolFF@ D
copyFFE I
)FFI J
{GG 	
ifHH 
(HH 
copyHH 
)HH 
{II 
thisJJ 
.JJ 
valueJJ 
=JJ 
newJJ  
byteJJ! %
[JJ% &
lengthJJ& ,
]JJ, -
;JJ- .
PlatformDependentKK !
.KK! "

CopyMemoryKK" ,
(KK, -
valueKK- 2
,KK2 3
startKK4 9
,KK9 :
thisKK; ?
.KK? @
valueKK@ E
,KKE F
$numKKG H
,KKH I
lengthKKJ P
)KKP Q
;KKQ R
thisLL 
.LL 
offsetLL 
=LL 
$numLL 
;LL  
}MM 
elseNN 
{OO 
ifPP 
(PP 
MathUtilPP 
.PP 
IsOutOfBoundsPP *
(PP* +
startPP+ 0
,PP0 1
lengthPP2 8
,PP8 9
valuePP: ?
.PP? @
LengthPP@ F
)PPF G
)PPG H
{QQ /
#ThrowIndexOutOfRangeException_StartRR 7
(RR7 8
startRR8 =
,RR= >
lengthRR? E
,RRE F
valueRRG L
.RRL M
LengthRRM S
)RRS T
;RRT U
}SS 
thisUU 
.UU 
valueUU 
=UU 
valueUU "
;UU" #
thisVV 
.VV 
offsetVV 
=VV 
startVV #
;VV# $
}WW 
thisYY 
.YY 
lengthYY 
=YY 
lengthYY  
;YY  !
}ZZ 	
public\\ 
AsciiString\\ 
(\\ 
char\\ 
[\\  
]\\  !
value\\" '
)\\' (
:\\) *
this\\+ /
(\\/ 0
value\\0 5
,\\5 6
$num\\7 8
,\\8 9
value\\: ?
.\\? @
Length\\@ F
)\\F G
{]] 	
}^^ 	
public`` 
unsafe`` 
AsciiString`` !
(``! "
char``" &
[``& '
]``' (
value``) .
,``. /
int``0 3
start``4 9
,``9 :
int``; >
length``? E
)``E F
{aa 	
ifbb 
(bb 
MathUtilbb 
.bb 
IsOutOfBoundsbb &
(bb& '
startbb' ,
,bb, -
lengthbb. 4
,bb4 5
valuebb6 ;
.bb; <
Lengthbb< B
)bbB C
)bbC D
{cc /
#ThrowIndexOutOfRangeException_Startdd 3
(dd3 4
startdd4 9
,dd9 :
lengthdd; A
,ddA B
valueddC H
.ddH I
LengthddI O
)ddO P
;ddP Q
}ee 
thisgg 
.gg 
valuegg 
=gg 
newgg 
bytegg !
[gg! "
lengthgg" (
]gg( )
;gg) *
fixedhh 
(hh 
charhh 
*hh 
charshh 
=hh  
valuehh! &
)hh& '
fixedii 
(ii 
byteii 
*ii 
bytesii "
=ii# $
thisii% )
.ii) *
valueii* /
)ii/ 0
GetBytesjj 
(jj 
charsjj "
+jj# $
startjj% *
,jj* +
lengthjj, 2
,jj2 3
bytesjj4 9
)jj9 :
;jj: ;
thisll 
.ll 
offsetll 
=ll 
$numll 
;ll 
thismm 
.mm 
lengthmm 
=mm 
lengthmm  
;mm  !
}nn 	
publicpp 
AsciiStringpp 
(pp 
charpp 
[pp  
]pp  !
valuepp" '
,pp' (
Encodingpp) 1
encodingpp2 :
)pp: ;
:pp< =
thispp> B
(ppB C
valueppC H
,ppH I
encodingppJ R
,ppR S
$numppT U
,ppU V
valueppW \
.pp\ ]
Lengthpp] c
)ppc d
{qq 	
}rr 	
publictt 
AsciiStringtt 
(tt 
chartt 
[tt  
]tt  !
valuett" '
,tt' (
Encodingtt) 1
encodingtt2 :
,tt: ;
inttt< ?
starttt@ E
,ttE F
intttG J
lengthttK Q
)ttQ R
{uu 	
thisvv 
.vv 
valuevv 
=vv 
encodingvv !
.vv! "
GetBytesvv" *
(vv* +
valuevv+ 0
,vv0 1
startvv2 7
,vv7 8
lengthvv9 ?
)vv? @
;vv@ A
thisww 
.ww 
offsetww 
=ww 
$numww 
;ww 
thisxx 
.xx 
lengthxx 
=xx 
thisxx 
.xx 
valuexx $
.xx$ %
Lengthxx% +
;xx+ ,
}yy 	
public{{ 
AsciiString{{ 
({{ 
ICharSequence{{ (
value{{) .
){{. /
:{{0 1
this{{2 6
({{6 7
value{{7 <
,{{< =
$num{{> ?
,{{? @
value{{A F
.{{F G
Count{{G L
){{L M
{|| 	
}}} 	
public 
AsciiString 
( 
ICharSequence (
value) .
,. /
int0 3
start4 9
,9 :
int; >
length? E
)E F
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
MathUtil
ÅÅ 
.
ÅÅ 
IsOutOfBounds
ÅÅ &
(
ÅÅ& '
start
ÅÅ' ,
,
ÅÅ, -
length
ÅÅ. 4
,
ÅÅ4 5
value
ÅÅ6 ;
.
ÅÅ; <
Count
ÅÅ< A
)
ÅÅA B
)
ÅÅB C
{
ÇÇ 1
#ThrowIndexOutOfRangeException_Start
ÉÉ 3
(
ÉÉ3 4
start
ÉÉ4 9
,
ÉÉ9 :
length
ÉÉ; A
,
ÉÉA B
value
ÉÉC H
.
ÉÉH I
Count
ÉÉI N
)
ÉÉN O
;
ÉÉO P
}
ÑÑ 
this
ÜÜ 
.
ÜÜ 
value
ÜÜ 
=
ÜÜ 
new
ÜÜ 
byte
ÜÜ !
[
ÜÜ! "
length
ÜÜ" (
]
ÜÜ( )
;
ÜÜ) *
for
áá 
(
áá 
int
áá 
i
áá 
=
áá 
$num
áá 
,
áá 
j
áá 
=
áá 
start
áá  %
;
áá% &
i
áá' (
<
áá) *
length
áá+ 1
;
áá1 2
i
áá3 4
++
áá4 6
,
áá6 7
j
áá8 9
++
áá9 ;
)
áá; <
{
àà 
this
ââ 
.
ââ 
value
ââ 
[
ââ 
i
ââ 
]
ââ 
=
ââ 

CharToByte
ââ  *
(
ââ* +
value
ââ+ 0
[
ââ0 1
j
ââ1 2
]
ââ2 3
)
ââ3 4
;
ââ4 5
}
ää 
this
åå 
.
åå 
offset
åå 
=
åå 
$num
åå 
;
åå 
this
çç 
.
çç 
length
çç 
=
çç 
length
çç  
;
çç  !
}
éé 	
public
êê 
AsciiString
êê 
(
êê 
string
êê !
value
êê" '
,
êê' (
Encoding
êê) 1
encoding
êê2 :
)
êê: ;
:
êê< =
this
êê> B
(
êêB C
value
êêC H
,
êêH I
encoding
êêJ R
,
êêR S
$num
êêT U
,
êêU V
value
êêW \
.
êê\ ]
Length
êê] c
)
êêc d
{
ëë 	
}
íí 	
public
îî 
AsciiString
îî 
(
îî 
string
îî !
value
îî" '
,
îî' (
Encoding
îî) 1
encoding
îî2 :
,
îî: ;
int
îî< ?
start
îî@ E
,
îîE F
int
îîG J
length
îîK Q
)
îîQ R
{
ïï 	
int
ññ 
count
ññ 
=
ññ 
encoding
ññ  
.
ññ  !
GetMaxByteCount
ññ! 0
(
ññ0 1
length
ññ1 7
)
ññ7 8
;
ññ8 9
var
óó 
bytes
óó 
=
óó 
new
óó 
byte
óó  
[
óó  !
count
óó! &
]
óó& '
;
óó' (
count
òò 
=
òò 
encoding
òò 
.
òò 
GetBytes
òò %
(
òò% &
value
òò& +
,
òò+ ,
start
òò- 2
,
òò2 3
length
òò4 :
,
òò: ;
bytes
òò< A
,
òòA B
$num
òòC D
)
òòD E
;
òòE F
this
öö 
.
öö 
value
öö 
=
öö 
new
öö 
byte
öö !
[
öö! "
count
öö" '
]
öö' (
;
öö( )
PlatformDependent
õõ 
.
õõ 

CopyMemory
õõ (
(
õõ( )
bytes
õõ) .
,
õõ. /
$num
õõ0 1
,
õõ1 2
this
õõ3 7
.
õõ7 8
value
õõ8 =
,
õõ= >
$num
õõ? @
,
õõ@ A
count
õõB G
)
õõG H
;
õõH I
this
ùù 
.
ùù 
offset
ùù 
=
ùù 
$num
ùù 
;
ùù 
this
ûû 
.
ûû 
length
ûû 
=
ûû 
this
ûû 
.
ûû 
value
ûû $
.
ûû$ %
Length
ûû% +
;
ûû+ ,
}
üü 	
public
°° 
AsciiString
°° 
(
°° 
string
°° !
value
°°" '
)
°°' (
:
°°) *
this
°°+ /
(
°°/ 0
value
°°0 5
,
°°5 6
$num
°°7 8
,
°°8 9
value
°°: ?
.
°°? @
Length
°°@ F
)
°°F G
{
¢¢ 	
}
££ 	
public
•• 
AsciiString
•• 
(
•• 
string
•• !
value
••" '
,
••' (
int
••) ,
start
••- 2
,
••2 3
int
••4 7
length
••8 >
)
••> ?
{
¶¶ 	
if
ßß 
(
ßß 
MathUtil
ßß 
.
ßß 
IsOutOfBounds
ßß &
(
ßß& '
start
ßß' ,
,
ßß, -
length
ßß. 4
,
ßß4 5
value
ßß6 ;
.
ßß; <
Length
ßß< B
)
ßßB C
)
ßßC D
{
®® 1
#ThrowIndexOutOfRangeException_Start
©© 3
(
©©3 4
start
©©4 9
,
©©9 :
length
©©; A
,
©©A B
value
©©C H
.
©©H I
Length
©©I O
)
©©O P
;
©©P Q
}
™™ 
this
¨¨ 
.
¨¨ 
value
¨¨ 
=
¨¨ 
new
¨¨ 
byte
¨¨ !
[
¨¨! "
value
¨¨" '
.
¨¨' (
Length
¨¨( .
]
¨¨. /
;
¨¨/ 0
for
≠≠ 
(
≠≠ 
int
≠≠ 
i
≠≠ 
=
≠≠ 
$num
≠≠ 
;
≠≠ 
i
≠≠ 
<
≠≠ 
value
≠≠  %
.
≠≠% &
Length
≠≠& ,
;
≠≠, -
i
≠≠. /
++
≠≠/ 1
)
≠≠1 2
{
ÆÆ 
this
ØØ 
.
ØØ 
value
ØØ 
[
ØØ 
i
ØØ 
]
ØØ 
=
ØØ 

CharToByte
ØØ  *
(
ØØ* +
value
ØØ+ 0
[
ØØ0 1
i
ØØ1 2
]
ØØ2 3
)
ØØ3 4
;
ØØ4 5
}
∞∞ 
this
≤≤ 
.
≤≤ 
offset
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
this
≥≥ 
.
≥≥ 
length
≥≥ 
=
≥≥ 
value
≥≥ 
.
≥≥  
Length
≥≥  &
;
≥≥& '
}
¥¥ 	
public
∂∂ 
int
∂∂ 
ForEachByte
∂∂ 
(
∂∂ 
IByteProcessor
∂∂ -
visitor
∂∂. 5
)
∂∂5 6
=>
∂∂7 9
this
∂∂: >
.
∂∂> ?
ForEachByte0
∂∂? K
(
∂∂K L
$num
∂∂L M
,
∂∂M N
this
∂∂O S
.
∂∂S T
length
∂∂T Z
,
∂∂Z [
visitor
∂∂\ c
)
∂∂c d
;
∂∂d e
public
∏∏ 
int
∏∏ 
ForEachByte
∏∏ 
(
∏∏ 
int
∏∏ "
index
∏∏# (
,
∏∏( )
int
∏∏* -
count
∏∏. 3
,
∏∏3 4
IByteProcessor
∏∏5 C
visitor
∏∏D K
)
∏∏K L
{
ππ 	
if
∫∫ 
(
∫∫ 
MathUtil
∫∫ 
.
∫∫ 
IsOutOfBounds
∫∫ &
(
∫∫& '
index
∫∫' ,
,
∫∫, -
count
∫∫. 3
,
∫∫3 4
this
∫∫5 9
.
∫∫9 :
length
∫∫: @
)
∫∫@ A
)
∫∫A B
{
ªª 1
#ThrowIndexOutOfRangeException_Index
ºº 3
(
ºº3 4
index
ºº4 9
,
ºº9 :
count
ºº; @
,
ºº@ A
this
ººB F
.
ººF G
length
ººG M
)
ººM N
;
ººN O
}
ΩΩ 
return
ææ 
this
ææ 
.
ææ 
ForEachByte0
ææ $
(
ææ$ %
index
ææ% *
,
ææ* +
count
ææ, 1
,
ææ1 2
visitor
ææ3 :
)
ææ: ;
;
ææ; <
}
øø 	
int
¡¡ 
ForEachByte0
¡¡ 
(
¡¡ 
int
¡¡ 
index
¡¡ "
,
¡¡" #
int
¡¡$ '
count
¡¡( -
,
¡¡- .
IByteProcessor
¡¡/ =
visitor
¡¡> E
)
¡¡E F
{
¬¬ 	
int
√√ 
len
√√ 
=
√√ 
this
√√ 
.
√√ 
offset
√√ !
+
√√" #
index
√√$ )
+
√√* +
count
√√, 1
;
√√1 2
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
this
ƒƒ 
.
ƒƒ 
offset
ƒƒ $
+
ƒƒ% &
index
ƒƒ' ,
;
ƒƒ, -
i
ƒƒ. /
<
ƒƒ0 1
len
ƒƒ2 5
;
ƒƒ5 6
++
ƒƒ7 9
i
ƒƒ9 :
)
ƒƒ: ;
{
≈≈ 
if
∆∆ 
(
∆∆ 
!
∆∆ 
visitor
∆∆ 
.
∆∆ 
Process
∆∆ $
(
∆∆$ %
this
∆∆% )
.
∆∆) *
value
∆∆* /
[
∆∆/ 0
i
∆∆0 1
]
∆∆1 2
)
∆∆2 3
)
∆∆3 4
{
«« 
return
»» 
i
»» 
-
»» 
this
»» #
.
»»# $
offset
»»$ *
;
»»* +
}
…… 
}
   
return
ÃÃ 
-
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
œœ 
int
œœ 
ForEachByteDesc
œœ "
(
œœ" #
IByteProcessor
œœ# 1
visitor
œœ2 9
)
œœ9 :
=>
œœ; =
this
œœ> B
.
œœB C
ForEachByteDesc0
œœC S
(
œœS T
$num
œœT U
,
œœU V
this
œœW [
.
œœ[ \
length
œœ\ b
,
œœb c
visitor
œœd k
)
œœk l
;
œœl m
public
—— 
int
—— 
ForEachByteDesc
—— "
(
——" #
int
——# &
index
——' ,
,
——, -
int
——. 1
count
——2 7
,
——7 8
IByteProcessor
——9 G
visitor
——H O
)
——O P
{
““ 	
if
”” 
(
”” 
MathUtil
”” 
.
”” 
IsOutOfBounds
”” &
(
””& '
index
””' ,
,
””, -
count
””. 3
,
””3 4
this
””5 9
.
””9 :
length
””: @
)
””@ A
)
””A B
{
‘‘ 1
#ThrowIndexOutOfRangeException_Index
’’ 3
(
’’3 4
index
’’4 9
,
’’9 :
count
’’; @
,
’’@ A
this
’’B F
.
’’F G
length
’’G M
)
’’M N
;
’’N O
}
÷÷ 
return
ÿÿ 
this
ÿÿ 
.
ÿÿ 
ForEachByteDesc0
ÿÿ (
(
ÿÿ( )
index
ÿÿ) .
,
ÿÿ. /
count
ÿÿ0 5
,
ÿÿ5 6
visitor
ÿÿ7 >
)
ÿÿ> ?
;
ÿÿ? @
}
ŸŸ 	
int
€€ 
ForEachByteDesc0
€€ 
(
€€ 
int
€€  
index
€€! &
,
€€& '
int
€€( +
count
€€, 1
,
€€1 2
IByteProcessor
€€3 A
visitor
€€B I
)
€€I J
{
‹‹ 	
int
›› 
end
›› 
=
›› 
this
›› 
.
›› 
offset
›› !
+
››" #
index
››$ )
;
››) *
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
i
ﬁﬁ 
=
ﬁﬁ 
this
ﬁﬁ 
.
ﬁﬁ 
offset
ﬁﬁ $
+
ﬁﬁ% &
index
ﬁﬁ' ,
+
ﬁﬁ- .
count
ﬁﬁ/ 4
-
ﬁﬁ5 6
$num
ﬁﬁ7 8
;
ﬁﬁ8 9
i
ﬁﬁ: ;
>=
ﬁﬁ< >
end
ﬁﬁ? B
;
ﬁﬁB C
--
ﬁﬁD F
i
ﬁﬁF G
)
ﬁﬁG H
{
ﬂﬂ 
if
‡‡ 
(
‡‡ 
!
‡‡ 
visitor
‡‡ 
.
‡‡ 
Process
‡‡ $
(
‡‡$ %
this
‡‡% )
.
‡‡) *
value
‡‡* /
[
‡‡/ 0
i
‡‡0 1
]
‡‡1 2
)
‡‡2 3
)
‡‡3 4
{
·· 
return
‚‚ 
i
‚‚ 
-
‚‚ 
this
‚‚ #
.
‚‚# $
offset
‚‚$ *
;
‚‚* +
}
„„ 
}
‰‰ 
return
ÊÊ 
-
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
public
ÈÈ 
byte
ÈÈ 
ByteAt
ÈÈ 
(
ÈÈ 
int
ÈÈ 
index
ÈÈ $
)
ÈÈ$ %
{
ÍÍ 	
if
ÌÌ 
(
ÌÌ 
index
ÌÌ 
<
ÌÌ 
$num
ÌÌ 
||
ÌÌ 
index
ÌÌ "
>=
ÌÌ# %
this
ÌÌ& *
.
ÌÌ* +
length
ÌÌ+ 1
)
ÌÌ1 2
{
ÓÓ 1
#ThrowIndexOutOfRangeException_Index
ÔÔ 3
(
ÔÔ3 4
index
ÔÔ4 9
,
ÔÔ9 :
this
ÔÔ; ?
.
ÔÔ? @
length
ÔÔ@ F
)
ÔÔF G
;
ÔÔG H
}
 
return
ÚÚ 
this
ÚÚ 
.
ÚÚ 
value
ÚÚ 
[
ÚÚ 
index
ÚÚ #
+
ÚÚ$ %
this
ÚÚ& *
.
ÚÚ* +
offset
ÚÚ+ 1
]
ÚÚ1 2
;
ÚÚ2 3
}
ÛÛ 	
public
ıı 
bool
ıı 
IsEmpty
ıı 
=>
ıı 
this
ıı #
.
ıı# $
length
ıı$ *
==
ıı+ -
$num
ıı. /
;
ıı/ 0
public
˜˜ 
int
˜˜ 
Count
˜˜ 
=>
˜˜ 
this
˜˜  
.
˜˜  !
length
˜˜! '
;
˜˜' (
public
˝˝ 
void
˝˝ 
ArrayChanged
˝˝  
(
˝˝  !
)
˝˝! "
{
˛˛ 	
this
ˇˇ 
.
ˇˇ 
stringValue
ˇˇ 
=
ˇˇ 
null
ˇˇ #
;
ˇˇ# $
this
ÄÄ 
.
ÄÄ 
hash
ÄÄ 
=
ÄÄ 
$num
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
byte
ÉÉ 
[
ÉÉ 
]
ÉÉ 
Array
ÉÉ 
=>
ÉÉ 
this
ÉÉ #
.
ÉÉ# $
value
ÉÉ$ )
;
ÉÉ) *
public
ÖÖ 
int
ÖÖ 
Offset
ÖÖ 
=>
ÖÖ 
this
ÖÖ !
.
ÖÖ! "
offset
ÖÖ" (
;
ÖÖ( )
public
áá 
bool
áá 
IsEntireArrayUsed
áá %
=>
áá& (
this
áá) -
.
áá- .
offset
áá. 4
==
áá5 7
$num
áá8 9
&&
áá: <
this
áá= A
.
ááA B
length
ááB H
==
ááI K
this
ááL P
.
ááP Q
value
ááQ V
.
ááV W
Length
ááW ]
;
áá] ^
public
ââ 
byte
ââ 
[
ââ 
]
ââ 
ToByteArray
ââ !
(
ââ! "
)
ââ" #
=>
ââ$ &
this
ââ' +
.
ââ+ ,
ToByteArray
ââ, 7
(
ââ7 8
$num
ââ8 9
,
ââ9 :
this
ââ; ?
.
ââ? @
length
ââ@ F
)
ââF G
;
ââG H
public
ãã 
byte
ãã 
[
ãã 
]
ãã 
ToByteArray
ãã !
(
ãã! "
int
ãã" %
start
ãã& +
,
ãã+ ,
int
ãã- 0
end
ãã1 4
)
ãã4 5
{
åå 	
int
çç 
count
çç 
=
çç 
end
çç 
-
çç 
start
çç #
;
çç# $
var
éé 
bytes
éé 
=
éé 
new
éé 
byte
éé  
[
éé  !
count
éé! &
]
éé& '
;
éé' (
PlatformDependent
èè 
.
èè 

CopyMemory
èè (
(
èè( )
this
èè) -
.
èè- .
value
èè. 3
,
èè3 4
this
èè5 9
.
èè9 :
offset
èè: @
+
èèA B
start
èèC H
,
èèH I
bytes
èèJ O
,
èèO P
$num
èèQ R
,
èèR S
count
èèT Y
)
èèY Z
;
èèZ [
return
ëë 
bytes
ëë 
;
ëë 
}
íí 	
public
îî 
void
îî 
Copy
îî 
(
îî 
int
îî 
srcIdx
îî #
,
îî# $
byte
îî% )
[
îî) *
]
îî* +
dst
îî, /
,
îî/ 0
int
îî1 4
dstIdx
îî5 ;
,
îî; <
int
îî= @
count
îîA F
)
îîF G
{
ïï 	
Contract
ññ 
.
ññ 
Requires
ññ 
(
ññ 
dst
ññ !
!=
ññ" $
null
ññ% )
&&
ññ* ,
dst
ññ- 0
.
ññ0 1
Length
ññ1 7
>=
ññ8 :
count
ññ; @
)
ññ@ A
;
ññA B
if
òò 
(
òò 
MathUtil
òò 
.
òò 
IsOutOfBounds
òò &
(
òò& '
srcIdx
òò' -
,
òò- .
count
òò/ 4
,
òò4 5
this
òò6 :
.
òò: ;
length
òò; A
)
òòA B
)
òòB C
{
ôô 4
&ThrowIndexOutOfRangeException_SrcIndex
öö 6
(
öö6 7
srcIdx
öö7 =
,
öö= >
count
öö? D
,
ööD E
this
ööF J
.
ööJ K
length
ööK Q
)
ööQ R
;
ööR S
}
õõ 
if
úú 
(
úú 
count
úú 
==
úú 
$num
úú 
)
úú 
{
ùù 
return
ûû 
;
ûû 
}
üü 
PlatformDependent
°° 
.
°° 

CopyMemory
°° (
(
°°( )
this
°°) -
.
°°- .
value
°°. 3
,
°°3 4
srcIdx
°°5 ;
+
°°< =
this
°°> B
.
°°B C
offset
°°C I
,
°°I J
dst
°°K N
,
°°N O
dstIdx
°°P V
,
°°V W
count
°°X ]
)
°°] ^
;
°°^ _
}
¢¢ 	
public
§§ 
char
§§ 
this
§§ 
[
§§ 
int
§§ 
index
§§ "
]
§§" #
=>
§§$ &

ByteToChar
§§' 1
(
§§1 2
this
§§2 6
.
§§6 7
ByteAt
§§7 =
(
§§= >
index
§§> C
)
§§C D
)
§§D E
;
§§E F
public
¶¶ 
bool
¶¶ 
Contains
¶¶ 
(
¶¶ 
ICharSequence
¶¶ *
sequence
¶¶+ 3
)
¶¶3 4
=>
¶¶5 7
this
¶¶8 <
.
¶¶< =
IndexOf
¶¶= D
(
¶¶D E
sequence
¶¶E M
)
¶¶M N
>=
¶¶O Q
$num
¶¶R S
;
¶¶S T
public
®® 
int
®® 
	CompareTo
®® 
(
®® 
ICharSequence
®® *
other
®®+ 0
)
®®0 1
{
©© 	
if
™™ 
(
™™ 
ReferenceEquals
™™ 
(
™™  
this
™™  $
,
™™$ %
other
™™& +
)
™™+ ,
)
™™, -
{
´´ 
return
¨¨ 
$num
¨¨ 
;
¨¨ 
}
≠≠ 
int
ØØ 
length1
ØØ 
=
ØØ 
this
ØØ 
.
ØØ 
length
ØØ %
;
ØØ% &
int
∞∞ 
length2
∞∞ 
=
∞∞ 
other
∞∞ 
.
∞∞  
Count
∞∞  %
;
∞∞% &
int
±± 
	minLength
±± 
=
±± 
Math
±±  
.
±±  !
Min
±±! $
(
±±$ %
length1
±±% ,
,
±±, -
length2
±±. 5
)
±±5 6
;
±±6 7
for
≤≤ 
(
≤≤ 
int
≤≤ 
i
≤≤ 
=
≤≤ 
$num
≤≤ 
,
≤≤ 
j
≤≤ 
=
≤≤ 
this
≤≤  $
.
≤≤$ %
offset
≤≤% +
;
≤≤+ ,
i
≤≤- .
<
≤≤/ 0
	minLength
≤≤1 :
;
≤≤: ;
i
≤≤< =
++
≤≤= ?
,
≤≤? @
j
≤≤A B
++
≤≤B D
)
≤≤D E
{
≥≥ 
int
¥¥ 
result
¥¥ 
=
¥¥ 

ByteToChar
¥¥ '
(
¥¥' (
this
¥¥( ,
.
¥¥, -
value
¥¥- 2
[
¥¥2 3
j
¥¥3 4
]
¥¥4 5
)
¥¥5 6
-
¥¥7 8
other
¥¥9 >
[
¥¥> ?
i
¥¥? @
]
¥¥@ A
;
¥¥A B
if
µµ 
(
µµ 
result
µµ 
!=
µµ 
$num
µµ 
)
µµ  
{
∂∂ 
return
∑∑ 
result
∑∑ !
;
∑∑! "
}
∏∏ 
}
ππ 
return
ªª 
length1
ªª 
-
ªª 
length2
ªª $
;
ªª$ %
}
ºº 	
public
ææ 
AsciiString
ææ 
Concat
ææ !
(
ææ! "
ICharSequence
ææ" /
charSequence
ææ0 <
)
ææ< =
{
øø 	
int
¿¿ 
thisLen
¿¿ 
=
¿¿ 
this
¿¿ 
.
¿¿ 
length
¿¿ %
;
¿¿% &
int
¡¡ 
thatLen
¡¡ 
=
¡¡ 
charSequence
¡¡ &
.
¡¡& '
Count
¡¡' ,
;
¡¡, -
if
¬¬ 
(
¬¬ 
thatLen
¬¬ 
==
¬¬ 
$num
¬¬ 
)
¬¬ 
{
√√ 
return
ƒƒ 
this
ƒƒ 
;
ƒƒ 
}
≈≈ 
byte
«« 
[
«« 
]
«« 
newValue
«« 
;
«« 
if
»» 
(
»» 
charSequence
»» 
is
»» 
AsciiString
»»  +
that
»», 0
)
»»0 1
{
…… 
if
   
(
   
this
   
.
   
IsEmpty
    
)
    !
{
ÀÀ 
return
ÃÃ 
that
ÃÃ 
;
ÃÃ  
}
ÕÕ 
newValue
œœ 
=
œœ 
new
œœ 
byte
œœ #
[
œœ# $
thisLen
œœ$ +
+
œœ, -
thatLen
œœ. 5
]
œœ5 6
;
œœ6 7
PlatformDependent
–– !
.
––! "

CopyMemory
––" ,
(
––, -
this
––- 1
.
––1 2
value
––2 7
,
––7 8
this
––9 =
.
––= >
offset
––> D
,
––D E
newValue
––F N
,
––N O
$num
––P Q
,
––Q R
thisLen
––S Z
)
––Z [
;
––[ \
PlatformDependent
—— !
.
——! "

CopyMemory
——" ,
(
——, -
that
——- 1
.
——1 2
value
——2 7
,
——7 8
that
——9 =
.
——= >
offset
——> D
,
——D E
newValue
——F N
,
——N O
thisLen
——P W
,
——W X
thatLen
——Y `
)
——` a
;
——a b
return
”” 
new
”” 
AsciiString
”” &
(
””& '
newValue
””' /
,
””/ 0
false
””1 6
)
””6 7
;
””7 8
}
‘‘ 
if
÷÷ 
(
÷÷ 
this
÷÷ 
.
÷÷ 
IsEmpty
÷÷ 
)
÷÷ 
{
◊◊ 
return
ÿÿ 
new
ÿÿ 
AsciiString
ÿÿ &
(
ÿÿ& '
charSequence
ÿÿ' 3
)
ÿÿ3 4
;
ÿÿ4 5
}
ŸŸ 
newValue
€€ 
=
€€ 
new
€€ 
byte
€€ 
[
€€  
thisLen
€€  '
+
€€( )
thatLen
€€* 1
]
€€1 2
;
€€2 3
PlatformDependent
‹‹ 
.
‹‹ 

CopyMemory
‹‹ (
(
‹‹( )
this
‹‹) -
.
‹‹- .
value
‹‹. 3
,
‹‹3 4
this
‹‹5 9
.
‹‹9 :
offset
‹‹: @
,
‹‹@ A
newValue
‹‹B J
,
‹‹J K
$num
‹‹L M
,
‹‹M N
thisLen
‹‹O V
)
‹‹V W
;
‹‹W X
for
›› 
(
›› 
int
›› 
i
›› 
=
›› 
thisLen
››  
,
››  !
j
››" #
=
››$ %
$num
››& '
;
››' (
i
››) *
<
››+ ,
newValue
››- 5
.
››5 6
Length
››6 <
;
››< =
i
››> ?
++
››? A
,
››A B
j
››C D
++
››D F
)
››F G
{
ﬁﬁ 
newValue
ﬂﬂ 
[
ﬂﬂ 
i
ﬂﬂ 
]
ﬂﬂ 
=
ﬂﬂ 

CharToByte
ﬂﬂ (
(
ﬂﬂ( )
charSequence
ﬂﬂ) 5
[
ﬂﬂ5 6
j
ﬂﬂ6 7
]
ﬂﬂ7 8
)
ﬂﬂ8 9
;
ﬂﬂ9 :
}
‡‡ 
return
‚‚ 
new
‚‚ 
AsciiString
‚‚ "
(
‚‚" #
newValue
‚‚# +
,
‚‚+ ,
false
‚‚- 2
)
‚‚2 3
;
‚‚3 4
}
„„ 	
public
ÂÂ 
bool
ÂÂ 
EndsWith
ÂÂ 
(
ÂÂ 
ICharSequence
ÂÂ *
suffix
ÂÂ+ 1
)
ÂÂ1 2
{
ÊÊ 	
int
ÁÁ 
	suffixLen
ÁÁ 
=
ÁÁ 
suffix
ÁÁ "
.
ÁÁ" #
Count
ÁÁ# (
;
ÁÁ( )
return
ËË 
this
ËË 
.
ËË 
RegionMatches
ËË %
(
ËË% &
this
ËË& *
.
ËË* +
length
ËË+ 1
-
ËË2 3
	suffixLen
ËË4 =
,
ËË= >
suffix
ËË? E
,
ËËE F
$num
ËËG H
,
ËËH I
	suffixLen
ËËJ S
)
ËËS T
;
ËËT U
}
ÈÈ 	
public
ÎÎ 
bool
ÎÎ %
ContentEqualsIgnoreCase
ÎÎ +
(
ÎÎ+ ,
ICharSequence
ÎÎ, 9
other
ÎÎ: ?
)
ÎÎ? @
{
ÏÏ 	
if
ÌÌ 
(
ÌÌ 
other
ÌÌ 
==
ÌÌ 
null
ÌÌ 
||
ÌÌ  
other
ÌÌ! &
.
ÌÌ& '
Count
ÌÌ' ,
!=
ÌÌ- /
this
ÌÌ0 4
.
ÌÌ4 5
length
ÌÌ5 ;
)
ÌÌ; <
{
ÓÓ 
return
ÔÔ 
false
ÔÔ 
;
ÔÔ 
}
 
if
ÚÚ 
(
ÚÚ 
other
ÚÚ 
is
ÚÚ 
AsciiString
ÚÚ $
rhs
ÚÚ% (
)
ÚÚ( )
{
ÛÛ 
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
this
ÙÙ !
.
ÙÙ! "
offset
ÙÙ" (
,
ÙÙ( )
j
ÙÙ* +
=
ÙÙ, -
rhs
ÙÙ. 1
.
ÙÙ1 2
offset
ÙÙ2 8
;
ÙÙ8 9
i
ÙÙ: ;
<
ÙÙ< =
this
ÙÙ> B
.
ÙÙB C
length
ÙÙC I
;
ÙÙI J
++
ÙÙK M
i
ÙÙM N
,
ÙÙN O
++
ÙÙP R
j
ÙÙR S
)
ÙÙS T
{
ıı 
if
ˆˆ 
(
ˆˆ 
!
ˆˆ 
EqualsIgnoreCase
ˆˆ )
(
ˆˆ) *
this
ˆˆ* .
.
ˆˆ. /
value
ˆˆ/ 4
[
ˆˆ4 5
i
ˆˆ5 6
]
ˆˆ6 7
,
ˆˆ7 8
rhs
ˆˆ9 <
.
ˆˆ< =
value
ˆˆ= B
[
ˆˆB C
j
ˆˆC D
]
ˆˆD E
)
ˆˆE F
)
ˆˆF G
{
˜˜ 
return
¯¯ 
false
¯¯ $
;
¯¯$ %
}
˘˘ 
}
˙˙ 
return
˚˚ 
true
˚˚ 
;
˚˚ 
}
¸¸ 
for
˛˛ 
(
˛˛ 
int
˛˛ 
i
˛˛ 
=
˛˛ 
this
˛˛ 
.
˛˛ 
offset
˛˛ $
,
˛˛$ %
j
˛˛& '
=
˛˛( )
$num
˛˛* +
;
˛˛+ ,
i
˛˛- .
<
˛˛/ 0
this
˛˛1 5
.
˛˛5 6
length
˛˛6 <
;
˛˛< =
++
˛˛> @
i
˛˛@ A
,
˛˛A B
++
˛˛C E
j
˛˛E F
)
˛˛F G
{
ˇˇ 
if
ÄÄ 
(
ÄÄ 
!
ÄÄ 
EqualsIgnoreCase
ÄÄ %
(
ÄÄ% &

ByteToChar
ÄÄ& 0
(
ÄÄ0 1
this
ÄÄ1 5
.
ÄÄ5 6
value
ÄÄ6 ;
[
ÄÄ; <
i
ÄÄ< =
]
ÄÄ= >
)
ÄÄ> ?
,
ÄÄ? @
other
ÄÄA F
[
ÄÄF G
j
ÄÄG H
]
ÄÄH I
)
ÄÄI J
)
ÄÄJ K
{
ÅÅ 
return
ÇÇ 
false
ÇÇ  
;
ÇÇ  !
}
ÉÉ 
}
ÑÑ 
return
ÜÜ 
true
ÜÜ 
;
ÜÜ 
}
áá 	
public
ââ 
char
ââ 
[
ââ 
]
ââ 
ToCharArray
ââ !
(
ââ! "
)
ââ" #
=>
ââ$ &
this
ââ' +
.
ââ+ ,
ToCharArray
ââ, 7
(
ââ7 8
$num
ââ8 9
,
ââ9 :
this
ââ; ?
.
ââ? @
length
ââ@ F
)
ââF G
;
ââG H
public
ãã 
char
ãã 
[
ãã 
]
ãã 
ToCharArray
ãã !
(
ãã! "
int
ãã" %
start
ãã& +
,
ãã+ ,
int
ãã- 0
end
ãã1 4
)
ãã4 5
{
åå 	
int
çç 
count
çç 
=
çç 
end
çç 
-
çç 
start
çç #
;
çç# $
if
éé 
(
éé 
count
éé 
==
éé 
$num
éé 
)
éé 
{
èè 
return
êê 
EmptyArrays
êê #
.
êê# $

EmptyChars
êê$ .
;
êê. /
}
ëë 
if
ìì 
(
ìì 
MathUtil
ìì 
.
ìì 
IsOutOfBounds
ìì &
(
ìì& '
start
ìì' ,
,
ìì, -
count
ìì. 3
,
ìì3 4
this
ìì5 9
.
ìì9 :
length
ìì: @
)
ìì@ A
)
ììA B
{
îî 4
&ThrowIndexOutOfRangeException_SrcIndex
ïï 6
(
ïï6 7
start
ïï7 <
,
ïï< =
count
ïï> C
,
ïïC D
this
ïïE I
.
ïïI J
length
ïïJ P
)
ïïP Q
;
ïïQ R
}
ññ 
var
òò 
buffer
òò 
=
òò 
new
òò 
char
òò !
[
òò! "
count
òò" '
]
òò' (
;
òò( )
for
ôô 
(
ôô 
int
ôô 
i
ôô 
=
ôô 
$num
ôô 
,
ôô 
j
ôô 
=
ôô 
start
ôô  %
+
ôô& '
this
ôô( ,
.
ôô, -
offset
ôô- 3
;
ôô3 4
i
ôô5 6
<
ôô7 8
count
ôô9 >
;
ôô> ?
i
ôô@ A
++
ôôA C
,
ôôC D
j
ôôE F
++
ôôF H
)
ôôH I
{
öö 
buffer
õõ 
[
õõ 
i
õõ 
]
õõ 
=
õõ 

ByteToChar
õõ &
(
õõ& '
this
õõ' +
.
õõ+ ,
value
õõ, 1
[
õõ1 2
j
õõ2 3
]
õõ3 4
)
õõ4 5
;
õõ5 6
}
úú 
return
ûû 
buffer
ûû 
;
ûû 
}
üü 	
public
°° 
void
°° 
Copy
°° 
(
°° 
int
°° 
srcIdx
°° #
,
°°# $
char
°°% )
[
°°) *
]
°°* +
dst
°°, /
,
°°/ 0
int
°°1 4
dstIdx
°°5 ;
,
°°; <
int
°°= @
count
°°A F
)
°°F G
{
¢¢ 	
Contract
££ 
.
££ 
Requires
££ 
(
££ 
dst
££ !
!=
££" $
null
££% )
)
££) *
;
££* +
if
•• 
(
•• 
MathUtil
•• 
.
•• 
IsOutOfBounds
•• &
(
••& '
srcIdx
••' -
,
••- .
count
••/ 4
,
••4 5
this
••6 :
.
••: ;
length
••; A
)
••A B
)
••B C
{
¶¶ 4
&ThrowIndexOutOfRangeException_SrcIndex
ßß 6
(
ßß6 7
srcIdx
ßß7 =
,
ßß= >
count
ßß? D
,
ßßD E
this
ßßF J
.
ßßJ K
length
ßßK Q
)
ßßQ R
;
ßßR S
}
®® 
int
™™ 
dstEnd
™™ 
=
™™ 
dstIdx
™™ 
+
™™  !
count
™™" '
;
™™' (
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
dstIdx
´´ 
,
´´  
j
´´! "
=
´´# $
srcIdx
´´% +
+
´´, -
this
´´. 2
.
´´2 3
offset
´´3 9
;
´´9 :
i
´´; <
<
´´= >
dstEnd
´´? E
;
´´E F
i
´´G H
++
´´H J
,
´´J K
j
´´L M
++
´´M O
)
´´O P
{
¨¨ 
dst
≠≠ 
[
≠≠ 
i
≠≠ 
]
≠≠ 
=
≠≠ 

ByteToChar
≠≠ #
(
≠≠# $
this
≠≠$ (
.
≠≠( )
value
≠≠) .
[
≠≠. /
j
≠≠/ 0
]
≠≠0 1
)
≠≠1 2
;
≠≠2 3
}
ÆÆ 
}
ØØ 	
public
±± 
ICharSequence
±± 
SubSequence
±± (
(
±±( )
int
±±) ,
start
±±- 2
)
±±2 3
=>
±±4 6
(
±±7 8
AsciiString
±±8 C
)
±±C D
this
±±D H
.
±±H I
SubSequence
±±I T
(
±±T U
start
±±U Z
,
±±Z [
this
±±\ `
.
±±` a
length
±±a g
)
±±g h
;
±±h i
public
≥≥ 
ICharSequence
≥≥ 
SubSequence
≥≥ (
(
≥≥( )
int
≥≥) ,
start
≥≥- 2
,
≥≥2 3
int
≥≥4 7
end
≥≥8 ;
)
≥≥; <
=>
≥≥= ?
this
≥≥@ D
.
≥≥D E
SubSequence
≥≥E P
(
≥≥P Q
start
≥≥Q V
,
≥≥V W
end
≥≥X [
,
≥≥[ \
true
≥≥] a
)
≥≥a b
;
≥≥b c
public
µµ 
AsciiString
µµ 
SubSequence
µµ &
(
µµ& '
int
µµ' *
start
µµ+ 0
,
µµ0 1
int
µµ2 5
end
µµ6 9
,
µµ9 :
bool
µµ; ?
copy
µµ@ D
)
µµD E
{
∂∂ 	
if
∑∑ 
(
∑∑ 
MathUtil
∑∑ 
.
∑∑ 
IsOutOfBounds
∑∑ &
(
∑∑& '
start
∑∑' ,
,
∑∑, -
end
∑∑. 1
-
∑∑2 3
start
∑∑4 9
,
∑∑9 :
this
∑∑; ?
.
∑∑? @
length
∑∑@ F
)
∑∑F G
)
∑∑G H
{
∏∏ 4
&ThrowIndexOutOfRangeException_StartEnd
ππ 6
(
ππ6 7
start
ππ7 <
,
ππ< =
end
ππ> A
,
ππA B
this
ππC G
.
ππG H
length
ππH N
)
ππN O
;
ππO P
}
∫∫ 
if
ºº 
(
ºº 
start
ºº 
==
ºº 
$num
ºº 
&&
ºº 
end
ºº !
==
ºº" $
this
ºº% )
.
ºº) *
length
ºº* 0
)
ºº0 1
{
ΩΩ 
return
ææ 
this
ææ 
;
ææ 
}
øø 
return
¡¡ 
end
¡¡ 
==
¡¡ 
start
¡¡ 
?
¡¡  !
Empty
¡¡" '
:
¡¡( )
new
¡¡* -
AsciiString
¡¡. 9
(
¡¡9 :
this
¡¡: >
.
¡¡> ?
value
¡¡? D
,
¡¡D E
start
¡¡F K
+
¡¡L M
this
¡¡N R
.
¡¡R S
offset
¡¡S Y
,
¡¡Y Z
end
¡¡[ ^
-
¡¡_ `
start
¡¡a f
,
¡¡f g
copy
¡¡h l
)
¡¡l m
;
¡¡m n
}
¬¬ 	
public
ƒƒ 
int
ƒƒ 
IndexOf
ƒƒ 
(
ƒƒ 
ICharSequence
ƒƒ (
sequence
ƒƒ) 1
)
ƒƒ1 2
=>
ƒƒ3 5
this
ƒƒ6 :
.
ƒƒ: ;
IndexOf
ƒƒ; B
(
ƒƒB C
sequence
ƒƒC K
,
ƒƒK L
$num
ƒƒM N
)
ƒƒN O
;
ƒƒO P
public
∆∆ 
int
∆∆ 
IndexOf
∆∆ 
(
∆∆ 
ICharSequence
∆∆ (
	subString
∆∆) 2
,
∆∆2 3
int
∆∆4 7
start
∆∆8 =
)
∆∆= >
{
«« 	
if
»» 
(
»» 
start
»» 
<
»» 
$num
»» 
)
»» 
{
…… 
start
   
=
   
$num
   
;
   
}
ÀÀ 
int
ÕÕ 
thisLen
ÕÕ 
=
ÕÕ 
this
ÕÕ 
.
ÕÕ 
length
ÕÕ %
;
ÕÕ% &
int
œœ 
subCount
œœ 
=
œœ 
	subString
œœ $
.
œœ$ %
Count
œœ% *
;
œœ* +
if
–– 
(
–– 
subCount
–– 
<=
–– 
$num
–– 
)
–– 
{
—— 
return
““ 
start
““ 
<
““ 
thisLen
““ &
?
““' (
start
““) .
:
““/ 0
thisLen
““1 8
;
““8 9
}
”” 
if
‘‘ 
(
‘‘ 
subCount
‘‘ 
>
‘‘ 
thisLen
‘‘ "
-
‘‘# $
start
‘‘% *
)
‘‘* +
{
’’ 
return
÷÷ 
-
÷÷ 
$num
÷÷ 
;
÷÷ 
}
◊◊ 
char
ŸŸ 
	firstChar
ŸŸ 
=
ŸŸ 
	subString
ŸŸ &
[
ŸŸ& '
$num
ŸŸ' (
]
ŸŸ( )
;
ŸŸ) *
if
⁄⁄ 
(
⁄⁄ 
	firstChar
⁄⁄ 
>
⁄⁄ 
MaxCharValue
⁄⁄ (
)
⁄⁄( )
{
€€ 
return
‹‹ 
-
‹‹ 
$num
‹‹ 
;
‹‹ 
}
›› 
var
ﬂﬂ 
indexOfVisitor
ﬂﬂ 
=
ﬂﬂ  
new
ﬂﬂ! $
IndexOfProcessor
ﬂﬂ% 5
(
ﬂﬂ5 6
(
ﬂﬂ6 7
byte
ﬂﬂ7 ;
)
ﬂﬂ; <
	firstChar
ﬂﬂ< E
)
ﬂﬂE F
;
ﬂﬂF G
for
‡‡ 
(
‡‡ 
;
‡‡ 
;
‡‡ 
)
‡‡ 
{
·· 
int
‚‚ 
i
‚‚ 
=
‚‚ 
this
‚‚ 
.
‚‚ 
ForEachByte
‚‚ (
(
‚‚( )
start
‚‚) .
,
‚‚. /
thisLen
‚‚0 7
-
‚‚8 9
start
‚‚: ?
,
‚‚? @
indexOfVisitor
‚‚A O
)
‚‚O P
;
‚‚P Q
if
„„ 
(
„„ 
i
„„ 
==
„„ 
-
„„ 
$num
„„ 
||
„„ 
subCount
„„ '
+
„„( )
i
„„* +
>
„„, -
thisLen
„„. 5
)
„„5 6
{
‰‰ 
return
ÂÂ 
-
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
}
ÊÊ 
int
ÁÁ 
o1
ÁÁ 
=
ÁÁ 
i
ÁÁ 
,
ÁÁ 
o2
ÁÁ 
=
ÁÁ  
$num
ÁÁ! "
;
ÁÁ" #
while
ËË 
(
ËË 
++
ËË 
o2
ËË 
<
ËË 
subCount
ËË &
&&
ËË' )

ByteToChar
ËË* 4
(
ËË4 5
this
ËË5 9
.
ËË9 :
value
ËË: ?
[
ËË? @
++
ËË@ B
o1
ËËB D
+
ËËE F
this
ËËG K
.
ËËK L
offset
ËËL R
]
ËËR S
)
ËËS T
==
ËËU W
	subString
ËËX a
[
ËËa b
o2
ËËb d
]
ËËd e
)
ËËe f
{
ÈÈ 
}
ÎÎ 
if
ÏÏ 
(
ÏÏ 
o2
ÏÏ 
==
ÏÏ 
subCount
ÏÏ "
)
ÏÏ" #
{
ÌÌ 
return
ÓÓ 
i
ÓÓ 
;
ÓÓ 
}
ÔÔ 
start
 
=
 
i
 
+
 
$num
 
;
 
}
ÒÒ 
}
ÚÚ 	
public
ÙÙ 
int
ÙÙ 
IndexOf
ÙÙ 
(
ÙÙ 
char
ÙÙ 
ch
ÙÙ  "
,
ÙÙ" #
int
ÙÙ$ '
start
ÙÙ( -
)
ÙÙ- .
{
ıı 	
if
ˆˆ 
(
ˆˆ 
start
ˆˆ 
<
ˆˆ 
$num
ˆˆ 
)
ˆˆ 
{
˜˜ 
start
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
}
˘˘ 
int
˚˚ 
thisLen
˚˚ 
=
˚˚ 
this
˚˚ 
.
˚˚ 
length
˚˚ %
;
˚˚% &
if
¸¸ 
(
¸¸ 
ch
¸¸ 
>
¸¸ 
MaxCharValue
¸¸ !
)
¸¸! "
{
˝˝ 
return
˛˛ 
-
˛˛ 
$num
˛˛ 
;
˛˛ 
}
ˇˇ 
return
ÅÅ 
this
ÅÅ 
.
ÅÅ 
ForEachByte
ÅÅ #
(
ÅÅ# $
start
ÅÅ$ )
,
ÅÅ) *
thisLen
ÅÅ+ 2
-
ÅÅ3 4
start
ÅÅ5 :
,
ÅÅ: ;
new
ÅÅ< ?
IndexOfProcessor
ÅÅ@ P
(
ÅÅP Q
(
ÅÅQ R
byte
ÅÅR V
)
ÅÅV W
ch
ÅÅW Y
)
ÅÅY Z
)
ÅÅZ [
;
ÅÅ[ \
}
ÇÇ 	
public
ÖÖ 
int
ÖÖ 
LastIndexOf
ÖÖ 
(
ÖÖ 
ICharSequence
ÖÖ ,
charSequence
ÖÖ- 9
)
ÖÖ9 :
=>
ÖÖ; =
this
ÖÖ> B
.
ÖÖB C
LastIndexOf
ÖÖC N
(
ÖÖN O
charSequence
ÖÖO [
,
ÖÖ[ \
this
ÖÖ] a
.
ÖÖa b
length
ÖÖb h
)
ÖÖh i
;
ÖÖi j
public
áá 
int
áá 
LastIndexOf
áá 
(
áá 
ICharSequence
áá ,
	subString
áá- 6
,
áá6 7
int
áá8 ;
start
áá< A
)
ááA B
{
àà 	
int
ââ 
thisLen
ââ 
=
ââ 
this
ââ 
.
ââ 
length
ââ %
;
ââ% &
int
ää 
subCount
ää 
=
ää 
	subString
ää $
.
ää$ %
Count
ää% *
;
ää* +
if
åå 
(
åå 
subCount
åå 
>
åå 
thisLen
åå "
||
åå# %
start
åå& +
<
åå, -
$num
åå. /
)
åå/ 0
{
çç 
return
éé 
-
éé 
$num
éé 
;
éé 
}
èè 
if
ëë 
(
ëë 
subCount
ëë 
<=
ëë 
$num
ëë 
)
ëë 
{
íí 
return
ìì 
start
ìì 
<
ìì 
thisLen
ìì &
?
ìì' (
start
ìì) .
:
ìì/ 0
thisLen
ìì1 8
;
ìì8 9
}
îî 
start
ññ 
=
ññ 
Math
ññ 
.
ññ 
Min
ññ 
(
ññ 
start
ññ "
,
ññ" #
thisLen
ññ$ +
-
ññ, -
subCount
ññ. 6
)
ññ6 7
;
ññ7 8
char
ôô 
	firstChar
ôô 
=
ôô 
	subString
ôô &
[
ôô& '
$num
ôô' (
]
ôô( )
;
ôô) *
if
öö 
(
öö 
	firstChar
öö 
>
öö 
MaxCharValue
öö (
)
öö( )
{
õõ 
return
úú 
-
úú 
$num
úú 
;
úú 
}
ùù 
var
ûû 
indexOfVisitor
ûû 
=
ûû  
new
ûû! $
IndexOfProcessor
ûû% 5
(
ûû5 6
(
ûû6 7
byte
ûû7 ;
)
ûû; <
	firstChar
ûû< E
)
ûûE F
;
ûûF G
for
üü 
(
üü 
;
üü 
;
üü 
)
üü 
{
†† 
int
°° 
i
°° 
=
°° 
this
°° 
.
°° 
ForEachByteDesc
°° ,
(
°°, -
start
°°- 2
,
°°2 3
thisLen
°°4 ;
-
°°< =
start
°°> C
,
°°C D
indexOfVisitor
°°E S
)
°°S T
;
°°T U
if
¢¢ 
(
¢¢ 
i
¢¢ 
==
¢¢ 
-
¢¢ 
$num
¢¢ 
)
¢¢ 
{
££ 
return
§§ 
-
§§ 
$num
§§ 
;
§§ 
}
•• 
int
¶¶ 
o1
¶¶ 
=
¶¶ 
i
¶¶ 
,
¶¶ 
o2
¶¶ 
=
¶¶  
$num
¶¶! "
;
¶¶" #
while
ßß 
(
ßß 
++
ßß 
o2
ßß 
<
ßß 
subCount
ßß &
&&
ßß' )

ByteToChar
ßß* 4
(
ßß4 5
this
ßß5 9
.
ßß9 :
value
ßß: ?
[
ßß? @
++
ßß@ B
o1
ßßB D
+
ßßE F
this
ßßG K
.
ßßK L
offset
ßßL R
]
ßßR S
)
ßßS T
==
ßßU W
	subString
ßßX a
[
ßßa b
o2
ßßb d
]
ßßd e
)
ßße f
{
®® 
}
™™ 
if
´´ 
(
´´ 
o2
´´ 
==
´´ 
subCount
´´ "
)
´´" #
{
¨¨ 
return
≠≠ 
i
≠≠ 
;
≠≠ 
}
ÆÆ 
start
ØØ 
=
ØØ 
i
ØØ 
-
ØØ 
$num
ØØ 
;
ØØ 
}
∞∞ 
}
±± 	
public
≥≥ 
bool
≥≥ 
RegionMatches
≥≥ !
(
≥≥! "
int
≥≥" %
	thisStart
≥≥& /
,
≥≥/ 0
ICharSequence
≥≥1 >
seq
≥≥? B
,
≥≥B C
int
≥≥D G
start
≥≥H M
,
≥≥M N
int
≥≥O R
count
≥≥S X
)
≥≥X Y
{
¥¥ 	
Contract
µµ 
.
µµ 
Requires
µµ 
(
µµ 
seq
µµ !
!=
µµ" $
null
µµ% )
)
µµ) *
;
µµ* +
if
∑∑ 
(
∑∑ 
start
∑∑ 
<
∑∑ 
$num
∑∑ 
||
∑∑ 
seq
∑∑  
.
∑∑  !
Count
∑∑! &
-
∑∑' (
start
∑∑) .
<
∑∑/ 0
count
∑∑1 6
)
∑∑6 7
{
∏∏ 
return
ππ 
false
ππ 
;
ππ 
}
∫∫ 
int
ºº 
thisLen
ºº 
=
ºº 
this
ºº 
.
ºº 
length
ºº %
;
ºº% &
if
ΩΩ 
(
ΩΩ 
	thisStart
ΩΩ 
<
ΩΩ 
$num
ΩΩ 
||
ΩΩ  
thisLen
ΩΩ! (
-
ΩΩ) *
	thisStart
ΩΩ+ 4
<
ΩΩ5 6
count
ΩΩ7 <
)
ΩΩ< =
{
ææ 
return
øø 
false
øø 
;
øø 
}
¿¿ 
if
¬¬ 
(
¬¬ 
count
¬¬ 
<=
¬¬ 
$num
¬¬ 
)
¬¬ 
{
√√ 
return
ƒƒ 
true
ƒƒ 
;
ƒƒ 
}
≈≈ 
int
«« 
thatEnd
«« 
=
«« 
start
«« 
+
««  !
count
««" '
;
««' (
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
start
»» 
,
»» 
j
»»  !
=
»»" #
	thisStart
»»$ -
+
»». /
this
»»0 4
.
»»4 5
offset
»»5 ;
;
»»; <
i
»»= >
<
»»? @
thatEnd
»»A H
;
»»H I
i
»»J K
++
»»K M
,
»»M N
j
»»O P
++
»»P R
)
»»R S
{
…… 
if
   
(
   

ByteToChar
   
(
   
this
   #
.
  # $
value
  $ )
[
  ) *
j
  * +
]
  + ,
)
  , -
!=
  . 0
seq
  1 4
[
  4 5
i
  5 6
]
  6 7
)
  7 8
{
ÀÀ 
return
ÃÃ 
false
ÃÃ  
;
ÃÃ  !
}
ÕÕ 
}
ŒŒ 
return
–– 
true
–– 
;
–– 
}
—— 	
public
”” 
bool
”” %
RegionMatchesIgnoreCase
”” +
(
””+ ,
int
””, /
	thisStart
””0 9
,
””9 :
ICharSequence
””; H
seq
””I L
,
””L M
int
””N Q
start
””R W
,
””W X
int
””Y \
count
””] b
)
””b c
{
‘‘ 	
Contract
’’ 
.
’’ 
Requires
’’ 
(
’’ 
seq
’’ !
!=
’’" $
null
’’% )
)
’’) *
;
’’* +
int
◊◊ 
thisLen
◊◊ 
=
◊◊ 
this
◊◊ 
.
◊◊ 
length
◊◊ %
;
◊◊% &
if
ÿÿ 
(
ÿÿ 
	thisStart
ÿÿ 
<
ÿÿ 
$num
ÿÿ 
||
ÿÿ  
count
ÿÿ! &
>
ÿÿ' (
thisLen
ÿÿ) 0
-
ÿÿ1 2
	thisStart
ÿÿ3 <
)
ÿÿ< =
{
ŸŸ 
return
⁄⁄ 
false
⁄⁄ 
;
⁄⁄ 
}
€€ 
if
‹‹ 
(
‹‹ 
start
‹‹ 
<
‹‹ 
$num
‹‹ 
||
‹‹ 
count
‹‹ "
>
‹‹# $
seq
‹‹% (
.
‹‹( )
Count
‹‹) .
-
‹‹/ 0
start
‹‹1 6
)
‹‹6 7
{
›› 
return
ﬁﬁ 
false
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
	thisStart
·· 
+=
·· 
this
·· 
.
·· 
offset
·· $
;
··$ %
int
‚‚ 
thisEnd
‚‚ 
=
‚‚ 
	thisStart
‚‚ #
+
‚‚$ %
count
‚‚& +
;
‚‚+ ,
while
„„ 
(
„„ 
	thisStart
„„ 
<
„„ 
thisEnd
„„ &
)
„„& '
{
‰‰ 
if
ÂÂ 
(
ÂÂ 
!
ÂÂ 
EqualsIgnoreCase
ÂÂ %
(
ÂÂ% &

ByteToChar
ÂÂ& 0
(
ÂÂ0 1
this
ÂÂ1 5
.
ÂÂ5 6
value
ÂÂ6 ;
[
ÂÂ; <
	thisStart
ÂÂ< E
++
ÂÂE G
]
ÂÂG H
)
ÂÂH I
,
ÂÂI J
seq
ÂÂK N
[
ÂÂN O
start
ÂÂO T
++
ÂÂT V
]
ÂÂV W
)
ÂÂW X
)
ÂÂX Y
{
ÊÊ 
return
ÁÁ 
false
ÁÁ  
;
ÁÁ  !
}
ËË 
}
ÈÈ 
return
ÎÎ 
true
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÓÓ 
AsciiString
ÓÓ 
Replace
ÓÓ "
(
ÓÓ" #
char
ÓÓ# '
oldChar
ÓÓ( /
,
ÓÓ/ 0
char
ÓÓ1 5
newChar
ÓÓ6 =
)
ÓÓ= >
{
ÔÔ 	
if
 
(
 
oldChar
 
>
 
MaxCharValue
 &
)
& '
{
ÒÒ 
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 
byte
ıı 
oldCharByte
ıı 
=
ıı 

CharToByte
ıı )
(
ıı) *
oldChar
ıı* 1
)
ıı1 2
;
ıı2 3
int
ˆˆ 
index
ˆˆ 
=
ˆˆ 
this
ˆˆ 
.
ˆˆ 
ForEachByte
ˆˆ (
(
ˆˆ( )
new
ˆˆ) ,
IndexOfProcessor
ˆˆ- =
(
ˆˆ= >
oldCharByte
ˆˆ> I
)
ˆˆI J
)
ˆˆJ K
;
ˆˆK L
if
˜˜ 
(
˜˜ 
index
˜˜ 
==
˜˜ 
-
˜˜ 
$num
˜˜ 
)
˜˜ 
{
¯¯ 
return
˘˘ 
this
˘˘ 
;
˘˘ 
}
˙˙ 
byte
¸¸ 
newCharByte
¸¸ 
=
¸¸ 

CharToByte
¸¸ )
(
¸¸) *
newChar
¸¸* 1
)
¸¸1 2
;
¸¸2 3
var
˝˝ 
buffer
˝˝ 
=
˝˝ 
new
˝˝ 
byte
˝˝ !
[
˝˝! "
this
˝˝" &
.
˝˝& '
length
˝˝' -
]
˝˝- .
;
˝˝. /
for
˛˛ 
(
˛˛ 
int
˛˛ 
i
˛˛ 
=
˛˛ 
$num
˛˛ 
,
˛˛ 
j
˛˛ 
=
˛˛ 
this
˛˛  $
.
˛˛$ %
offset
˛˛% +
;
˛˛+ ,
i
˛˛- .
<
˛˛/ 0
buffer
˛˛1 7
.
˛˛7 8
Length
˛˛8 >
;
˛˛> ?
i
˛˛@ A
++
˛˛A C
,
˛˛C D
j
˛˛E F
++
˛˛F H
)
˛˛H I
{
ˇˇ 
byte
ÄÄ 
b
ÄÄ 
=
ÄÄ 
this
ÄÄ 
.
ÄÄ 
value
ÄÄ #
[
ÄÄ# $
j
ÄÄ$ %
]
ÄÄ% &
;
ÄÄ& '
if
ÅÅ 
(
ÅÅ 
b
ÅÅ 
==
ÅÅ 
oldCharByte
ÅÅ $
)
ÅÅ$ %
{
ÇÇ 
b
ÉÉ 
=
ÉÉ 
newCharByte
ÉÉ #
;
ÉÉ# $
}
ÑÑ 
buffer
ÖÖ 
[
ÖÖ 
i
ÖÖ 
]
ÖÖ 
=
ÖÖ 
b
ÖÖ 
;
ÖÖ 
}
ÜÜ 
return
àà 
new
àà 
AsciiString
àà "
(
àà" #
buffer
àà# )
,
àà) *
false
àà+ 0
)
àà0 1
;
àà1 2
}
ââ 	
public
ãã 
bool
ãã 

StartsWith
ãã 
(
ãã 
ICharSequence
ãã ,
prefix
ãã- 3
)
ãã3 4
=>
ãã5 7
this
ãã8 <
.
ãã< =

StartsWith
ãã= G
(
ããG H
prefix
ããH N
,
ããN O
$num
ããP Q
)
ããQ R
;
ããR S
public
çç 
bool
çç 

StartsWith
çç 
(
çç 
ICharSequence
çç ,
prefix
çç- 3
,
çç3 4
int
çç5 8
start
çç9 >
)
çç> ?
=>
çç@ B
this
ççC G
.
ççG H
RegionMatches
ççH U
(
ççU V
start
ççV [
,
çç[ \
prefix
çç] c
,
ççc d
$num
ççe f
,
ççf g
prefix
ççh n
.
ççn o
Count
çço t
)
ççt u
;
ççu v
public
èè 
AsciiString
èè 
ToLowerCase
èè &
(
èè& '
)
èè' (
{
êê 	
bool
ëë 

lowercased
ëë 
=
ëë 
true
ëë "
;
ëë" #
int
íí 
i
íí 
,
íí 
j
íí 
;
íí 
int
ìì 
len
ìì 
=
ìì 
this
ìì 
.
ìì 
length
ìì !
+
ìì" #
this
ìì$ (
.
ìì( )
offset
ìì) /
;
ìì/ 0
for
îî 
(
îî 
i
îî 
=
îî 
this
îî 
.
îî 
offset
îî  
;
îî  !
i
îî" #
<
îî$ %
len
îî& )
;
îî) *
++
îî+ -
i
îî- .
)
îî. /
{
ïï 
byte
ññ 
b
ññ 
=
ññ 
this
ññ 
.
ññ 
value
ññ #
[
ññ# $
i
ññ$ %
]
ññ% &
;
ññ& '
if
óó 
(
óó 
b
óó 
>=
óó 
$char
óó 
&&
óó 
b
óó  !
<=
óó" $
$char
óó% (
)
óó( )
{
òò 

lowercased
ôô 
=
ôô  
false
ôô! &
;
ôô& '
break
öö 
;
öö 
}
õõ 
}
úú 
if
üü 
(
üü 

lowercased
üü 
)
üü 
{
†† 
return
°° 
this
°° 
;
°° 
}
¢¢ 
var
§§ 
newValue
§§ 
=
§§ 
new
§§ 
byte
§§ #
[
§§# $
this
§§$ (
.
§§( )
length
§§) /
]
§§/ 0
;
§§0 1
for
•• 
(
•• 
i
•• 
=
•• 
$num
•• 
,
•• 
j
•• 
=
•• 
this
••  
.
••  !
offset
••! '
;
••' (
i
••) *
<
••+ ,
newValue
••- 5
.
••5 6
Length
••6 <
;
••< =
++
••> @
i
••@ A
,
••A B
++
••C E
j
••E F
)
••F G
{
¶¶ 
newValue
ßß 
[
ßß 
i
ßß 
]
ßß 
=
ßß 
ToLowerCase
ßß )
(
ßß) *
this
ßß* .
.
ßß. /
value
ßß/ 4
[
ßß4 5
j
ßß5 6
]
ßß6 7
)
ßß7 8
;
ßß8 9
}
®® 
return
™™ 
new
™™ 
AsciiString
™™ "
(
™™" #
newValue
™™# +
,
™™+ ,
false
™™- 2
)
™™2 3
;
™™3 4
}
´´ 	
public
≠≠ 
AsciiString
≠≠ 
ToUpperCase
≠≠ &
(
≠≠& '
)
≠≠' (
{
ÆÆ 	
bool
ØØ 

uppercased
ØØ 
=
ØØ 
true
ØØ "
;
ØØ" #
int
∞∞ 
i
∞∞ 
,
∞∞ 
j
∞∞ 
;
∞∞ 
int
±± 
len
±± 
=
±± 
this
±± 
.
±± 
length
±± !
+
±±" #
this
±±$ (
.
±±( )
offset
±±) /
;
±±/ 0
for
≤≤ 
(
≤≤ 
i
≤≤ 
=
≤≤ 
this
≤≤ 
.
≤≤ 
offset
≤≤  
;
≤≤  !
i
≤≤" #
<
≤≤$ %
len
≤≤& )
;
≤≤) *
++
≤≤+ -
i
≤≤- .
)
≤≤. /
{
≥≥ 
byte
¥¥ 
b
¥¥ 
=
¥¥ 
this
¥¥ 
.
¥¥ 
value
¥¥ #
[
¥¥# $
i
¥¥$ %
]
¥¥% &
;
¥¥& '
if
µµ 
(
µµ 
b
µµ 
>=
µµ 
$char
µµ 
&&
µµ 
b
µµ  !
<=
µµ" $
$char
µµ% (
)
µµ( )
{
∂∂ 

uppercased
∑∑ 
=
∑∑  
false
∑∑! &
;
∑∑& '
break
∏∏ 
;
∏∏ 
}
ππ 
}
∫∫ 
if
ΩΩ 
(
ΩΩ 

uppercased
ΩΩ 
)
ΩΩ 
{
ææ 
return
øø 
this
øø 
;
øø 
}
¿¿ 
var
¬¬ 
newValue
¬¬ 
=
¬¬ 
new
¬¬ 
byte
¬¬ #
[
¬¬# $
this
¬¬$ (
.
¬¬( )
length
¬¬) /
]
¬¬/ 0
;
¬¬0 1
for
√√ 
(
√√ 
i
√√ 
=
√√ 
$num
√√ 
,
√√ 
j
√√ 
=
√√ 
this
√√  
.
√√  !
offset
√√! '
;
√√' (
i
√√) *
<
√√+ ,
newValue
√√- 5
.
√√5 6
Length
√√6 <
;
√√< =
++
√√> @
i
√√@ A
,
√√A B
++
√√C E
j
√√E F
)
√√F G
{
ƒƒ 
newValue
≈≈ 
[
≈≈ 
i
≈≈ 
]
≈≈ 
=
≈≈ 
ToUpperCase
≈≈ )
(
≈≈) *
this
≈≈* .
.
≈≈. /
value
≈≈/ 4
[
≈≈4 5
j
≈≈5 6
]
≈≈6 7
)
≈≈7 8
;
≈≈8 9
}
∆∆ 
return
»» 
new
»» 
AsciiString
»» "
(
»»" #
newValue
»»# +
,
»»+ ,
false
»»- 2
)
»»2 3
;
»»3 4
}
…… 	
public
ÀÀ 
static
ÀÀ 
ICharSequence
ÀÀ #
Trim
ÀÀ$ (
(
ÀÀ( )
ICharSequence
ÀÀ) 6
c
ÀÀ7 8
)
ÀÀ8 9
{
ÃÃ 	
if
ÕÕ 
(
ÕÕ 
c
ÕÕ 
is
ÕÕ 
AsciiString
ÕÕ  
asciiString
ÕÕ! ,
)
ÕÕ, -
{
ŒŒ 
return
œœ 
asciiString
œœ "
.
œœ" #
Trim
œœ# '
(
œœ' (
)
œœ( )
;
œœ) *
}
–– 
int
—— 
start
—— 
=
—— 
$num
—— 
;
—— 
int
““ 
last
““ 
=
““ 
c
““ 
.
““ 
Count
““ 
-
““  
$num
““! "
;
““" #
int
”” 
end
”” 
=
”” 
last
”” 
;
”” 
while
‘‘ 
(
‘‘ 
start
‘‘ 
<=
‘‘ 
end
‘‘ 
&&
‘‘  "
c
‘‘# $
[
‘‘$ %
start
‘‘% *
]
‘‘* +
<=
‘‘, .
$char
‘‘/ 2
)
‘‘2 3
{
’’ 
start
÷÷ 
++
÷÷ 
;
÷÷ 
}
◊◊ 
while
ÿÿ 
(
ÿÿ 
end
ÿÿ 
>=
ÿÿ 
start
ÿÿ 
&&
ÿÿ  "
c
ÿÿ# $
[
ÿÿ$ %
end
ÿÿ% (
]
ÿÿ( )
<=
ÿÿ* ,
$char
ÿÿ- 0
)
ÿÿ0 1
{
ŸŸ 
end
⁄⁄ 
--
⁄⁄ 
;
⁄⁄ 
}
€€ 
if
‹‹ 
(
‹‹ 
start
‹‹ 
==
‹‹ 
$num
‹‹ 
&&
‹‹ 
end
‹‹ !
==
‹‹" $
last
‹‹% )
)
‹‹) *
{
›› 
return
ﬁﬁ 
c
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
return
‡‡ 
c
‡‡ 
.
‡‡ 
SubSequence
‡‡  
(
‡‡  !
start
‡‡! &
,
‡‡& '
end
‡‡( +
+
‡‡, -
$num
‡‡. /
)
‡‡/ 0
;
‡‡0 1
}
·· 	
public
„„ 
AsciiString
„„ 
Trim
„„ 
(
„„  
)
„„  !
{
‰‰ 	
int
ÂÂ 
start
ÂÂ 
=
ÂÂ 
this
ÂÂ 
.
ÂÂ 
offset
ÂÂ #
;
ÂÂ# $
int
ÊÊ 
last
ÊÊ 
=
ÊÊ 
this
ÊÊ 
.
ÊÊ 
offset
ÊÊ "
+
ÊÊ# $
this
ÊÊ% )
.
ÊÊ) *
length
ÊÊ* 0
-
ÊÊ1 2
$num
ÊÊ3 4
;
ÊÊ4 5
int
ÁÁ 
end
ÁÁ 
=
ÁÁ 
last
ÁÁ 
;
ÁÁ 
while
ËË 
(
ËË 
start
ËË 
<=
ËË 
end
ËË 
&&
ËË  "
this
ËË# '
.
ËË' (
value
ËË( -
[
ËË- .
start
ËË. 3
]
ËË3 4
<=
ËË5 7
$char
ËË8 ;
)
ËË; <
{
ÈÈ 
start
ÍÍ 
++
ÍÍ 
;
ÍÍ 
}
ÎÎ 
while
ÏÏ 
(
ÏÏ 
end
ÏÏ 
>=
ÏÏ 
start
ÏÏ 
&&
ÏÏ  "
this
ÏÏ# '
.
ÏÏ' (
value
ÏÏ( -
[
ÏÏ- .
end
ÏÏ. 1
]
ÏÏ1 2
<=
ÏÏ3 5
$char
ÏÏ6 9
)
ÏÏ9 :
{
ÌÌ 
end
ÓÓ 
--
ÓÓ 
;
ÓÓ 
}
ÔÔ 
if
 
(
 
start
 
==
 
$num
 
&&
 
end
 !
==
" $
last
% )
)
) *
{
ÒÒ 
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 
return
ıı 
new
ıı 
AsciiString
ıı "
(
ıı" #
this
ıı# '
.
ıı' (
value
ıı( -
,
ıı- .
start
ıı/ 4
,
ıı4 5
end
ıı6 9
-
ıı: ;
start
ıı< A
+
ııB C
$num
ııD E
,
ııE F
false
ııG L
)
ııL M
;
ııM N
}
ˆˆ 	
public
¯¯ 
unsafe
¯¯ 
bool
¯¯ 
ContentEquals
¯¯ (
(
¯¯( )
string
¯¯) /
a
¯¯0 1
)
¯¯1 2
{
˘˘ 	
if
˙˙ 
(
˙˙ 
a
˙˙ 
==
˙˙ 
null
˙˙ 
)
˙˙ 
{
˚˚ 
return
¸¸ 
false
¸¸ 
;
¸¸ 
}
˝˝ 
if
˛˛ 
(
˛˛ 
this
˛˛ 
.
˛˛ 
stringValue
˛˛  
!=
˛˛! #
null
˛˛$ (
)
˛˛( )
{
ˇˇ 
return
ÄÄ 
this
ÄÄ 
.
ÄÄ 
stringValue
ÄÄ '
.
ÄÄ' (
Equals
ÄÄ( .
(
ÄÄ. /
a
ÄÄ/ 0
)
ÄÄ0 1
;
ÄÄ1 2
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
this
ÇÇ 
.
ÇÇ 
length
ÇÇ 
!=
ÇÇ 
a
ÇÇ  
.
ÇÇ  !
Length
ÇÇ! '
)
ÇÇ' (
{
ÉÉ 
return
ÑÑ 
false
ÑÑ 
;
ÑÑ 
}
ÖÖ 
if
áá 
(
áá 
this
áá 
.
áá 
length
áá 
>
áá 
$num
áá 
)
áá  
{
àà 
fixed
ââ 
(
ââ 
char
ââ 
*
ââ 
p
ââ 
=
ââ  
a
ââ! "
)
ââ" #
fixed
ää 
(
ää 
byte
ää 
*
ää  
b
ää! "
=
ää# $
&
ää% &
this
ää& *
.
ää* +
value
ää+ 0
[
ää0 1
this
ää1 5
.
ää5 6
offset
ää6 <
]
ää< =
)
ää= >
for
ãã 
(
ãã 
int
ãã  
i
ãã! "
=
ãã# $
$num
ãã% &
;
ãã& '
i
ãã( )
<
ãã* +
this
ãã, 0
.
ãã0 1
length
ãã1 7
;
ãã7 8
++
ãã9 ;
i
ãã; <
)
ãã< =
{
åå 
if
çç 
(
çç  

CharToByte
çç  *
(
çç* +
*
çç+ ,
(
çç, -
p
çç- .
+
çç/ 0
i
çç1 2
)
çç2 3
)
çç3 4
!=
çç5 7
*
çç8 9
(
çç9 :
b
çç: ;
+
çç< =
i
çç> ?
)
çç? @
)
ççA B
{
éé 
return
èè  &
false
èè' ,
;
èè, -
}
êê 
}
ëë 
}
íí 
return
îî 
true
îî 
;
îî 
}
ïï 	
public
óó 
bool
óó 
ContentEquals
óó !
(
óó! "
ICharSequence
óó" /
a
óó0 1
)
óó1 2
{
òò 	
if
ôô 
(
ôô 
a
ôô 
==
ôô 
null
ôô 
||
ôô 
a
ôô 
.
ôô 
Count
ôô $
!=
ôô% '
this
ôô( ,
.
ôô, -
length
ôô- 3
)
ôô3 4
{
öö 
return
õõ 
false
õõ 
;
õõ 
}
úú 
if
ûû 
(
ûû 
a
ûû 
is
ûû 
AsciiString
ûû  
asciiString
ûû! ,
)
ûû, -
{
üü 
return
†† 
this
†† 
.
†† 
Equals
†† "
(
††" #
asciiString
††# .
)
††. /
;
††/ 0
}
°° 
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
this
££ 
.
££ 
offset
££ $
,
££$ %
j
££& '
=
££( )
$num
££* +
;
££+ ,
j
££- .
<
££/ 0
a
££1 2
.
££2 3
Count
££3 8
;
££8 9
++
££: <
i
££< =
,
££= >
++
££? A
j
££A B
)
££B C
{
§§ 
if
•• 
(
•• 

ByteToChar
•• 
(
•• 
this
•• #
.
••# $
value
••$ )
[
••) *
i
••* +
]
••+ ,
)
••, -
!=
••. 0
a
••1 2
[
••2 3
j
••3 4
]
••4 5
)
••5 6
{
¶¶ 
return
ßß 
false
ßß  
;
ßß  !
}
®® 
}
©© 
return
´´ 
true
´´ 
;
´´ 
}
¨¨ 	
public
ÆÆ 
AsciiString
ÆÆ 
[
ÆÆ 
]
ÆÆ 
Split
ÆÆ "
(
ÆÆ" #
char
ÆÆ# '
delim
ÆÆ( -
)
ÆÆ- .
{
ØØ 	
List
∞∞ 
<
∞∞ 
AsciiString
∞∞ 
>
∞∞ 
res
∞∞ !
=
∞∞" #$
InternalThreadLocalMap
∞∞$ :
.
∞∞: ;
Get
∞∞; >
(
∞∞> ?
)
∞∞? @
.
∞∞@ A
AsciiStringList
∞∞A P
(
∞∞P Q
)
∞∞Q R
;
∞∞R S
int
≤≤ 
start
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
int
≥≥ 
count
≥≥ 
=
≥≥ 
this
≥≥ 
.
≥≥ 
length
≥≥ #
;
≥≥# $
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
start
¥¥ 
;
¥¥ 
i
¥¥  !
<
¥¥" #
count
¥¥$ )
;
¥¥) *
i
¥¥+ ,
++
¥¥, .
)
¥¥. /
{
µµ 
if
∂∂ 
(
∂∂ 
this
∂∂ 
[
∂∂ 
i
∂∂ 
]
∂∂ 
==
∂∂ 
delim
∂∂ $
)
∂∂$ %
{
∑∑ 
if
∏∏ 
(
∏∏ 
start
∏∏ 
==
∏∏  
i
∏∏! "
)
∏∏" #
{
ππ 
res
∫∫ 
.
∫∫ 
Add
∫∫ 
(
∫∫  
Empty
∫∫  %
)
∫∫% &
;
∫∫& '
}
ªª 
else
ºº 
{
ΩΩ 
res
ææ 
.
ææ 
Add
ææ 
(
ææ  
new
ææ  #
AsciiString
ææ$ /
(
ææ/ 0
this
ææ0 4
.
ææ4 5
value
ææ5 :
,
ææ: ;
start
ææ< A
+
ææB C
this
ææD H
.
ææH I
offset
ææI O
,
ææO P
i
ææQ R
-
ææS T
start
ææU Z
,
ææZ [
false
ææ\ a
)
ææa b
)
ææb c
;
ææc d
}
øø 
start
¿¿ 
=
¿¿ 
i
¿¿ 
+
¿¿ 
$num
¿¿  !
;
¿¿! "
}
¡¡ 
}
¬¬ 
if
ƒƒ 
(
ƒƒ 
start
ƒƒ 
==
ƒƒ 
$num
ƒƒ 
)
ƒƒ 
{
≈≈ 
res
«« 
.
«« 
Add
«« 
(
«« 
this
«« 
)
«« 
;
«« 
}
»» 
else
…… 
{
   
if
ÀÀ 
(
ÀÀ 
start
ÀÀ 
!=
ÀÀ 
count
ÀÀ "
)
ÀÀ" #
{
ÃÃ 
res
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
new
ŒŒ 
AsciiString
ŒŒ  +
(
ŒŒ+ ,
this
ŒŒ, 0
.
ŒŒ0 1
value
ŒŒ1 6
,
ŒŒ6 7
start
ŒŒ8 =
+
ŒŒ> ?
this
ŒŒ@ D
.
ŒŒD E
offset
ŒŒE K
,
ŒŒK L
count
ŒŒM R
-
ŒŒS T
start
ŒŒU Z
,
ŒŒZ [
false
ŒŒ\ a
)
ŒŒa b
)
ŒŒb c
;
ŒŒc d
}
œœ 
else
–– 
{
—— 
while
”” 
(
”” 
res
”” 
.
”” 
Count
”” $
>
””% &
$num
””' (
)
””( )
{
‘‘ 
int
’’ 
i
’’ 
=
’’ 
res
’’  #
.
’’# $
Count
’’$ )
-
’’* +
$num
’’, -
;
’’- .
if
÷÷ 
(
÷÷ 
!
÷÷ 
res
÷÷  
[
÷÷  !
i
÷÷! "
]
÷÷" #
.
÷÷# $
IsEmpty
÷÷$ +
)
÷÷+ ,
{
◊◊ 
res
ÿÿ 
.
ÿÿ  
RemoveAt
ÿÿ  (
(
ÿÿ( )
i
ÿÿ) *
)
ÿÿ* +
;
ÿÿ+ ,
}
ŸŸ 
else
⁄⁄ 
{
€€ 
break
‹‹ !
;
‹‹! "
}
›› 
}
ﬁﬁ 
}
ﬂﬂ 
}
‡‡ 
var
‚‚ 
strings
‚‚ 
=
‚‚ 
new
‚‚ 
AsciiString
‚‚ )
[
‚‚) *
res
‚‚* -
.
‚‚- .
Count
‚‚. 3
]
‚‚3 4
;
‚‚4 5
res
„„ 
.
„„ 
CopyTo
„„ 
(
„„ 
strings
„„ 
)
„„ 
;
„„  
return
‰‰ 
strings
‰‰ 
;
‰‰ 
}
ÂÂ 	
public
ËË 
override
ËË 
int
ËË 
GetHashCode
ËË '
(
ËË' (
)
ËË( )
{
ÈÈ 	
int
ÍÍ 
h
ÍÍ 
=
ÍÍ 
this
ÍÍ 
.
ÍÍ 
hash
ÍÍ 
;
ÍÍ 
if
ÎÎ 
(
ÎÎ 
h
ÎÎ 
==
ÎÎ 
$num
ÎÎ 
)
ÎÎ 
{
ÏÏ 
h
ÌÌ 
=
ÌÌ 
PlatformDependent
ÌÌ %
.
ÌÌ% &
HashCodeAscii
ÌÌ& 3
(
ÌÌ3 4
this
ÌÌ4 8
.
ÌÌ8 9
value
ÌÌ9 >
,
ÌÌ> ?
this
ÌÌ@ D
.
ÌÌD E
offset
ÌÌE K
,
ÌÌK L
this
ÌÌM Q
.
ÌÌQ R
length
ÌÌR X
)
ÌÌX Y
;
ÌÌY Z
this
ÓÓ 
.
ÓÓ 
hash
ÓÓ 
=
ÓÓ 
h
ÓÓ 
;
ÓÓ 
}
ÔÔ 
return
ÒÒ 
h
ÒÒ 
;
ÒÒ 
}
ÚÚ 	
public
ıı 
bool
ıı 
Equals
ıı 
(
ıı 
AsciiString
ıı &
other
ıı' ,
)
ıı, -
{
ˆˆ 	
if
˜˜ 
(
˜˜ 
other
˜˜ 
==
˜˜ 
null
˜˜ 
)
˜˜ 
{
¯¯ 
return
˘˘ 
false
˘˘ 
;
˘˘ 
}
˙˙ 
if
˚˚ 
(
˚˚ 
ReferenceEquals
˚˚ 
(
˚˚  
this
˚˚  $
,
˚˚$ %
other
˚˚& +
)
˚˚+ ,
)
˚˚, -
{
¸¸ 
return
˝˝ 
true
˝˝ 
;
˝˝ 
}
˛˛ 
return
ÄÄ 
this
ÄÄ 
.
ÄÄ 
length
ÄÄ 
==
ÄÄ !
other
ÄÄ" '
.
ÄÄ' (
length
ÄÄ( .
&&
ÅÅ 
this
ÅÅ 
.
ÅÅ 
GetHashCode
ÅÅ #
(
ÅÅ# $
)
ÅÅ$ %
==
ÅÅ& (
other
ÅÅ) .
.
ÅÅ. /
GetHashCode
ÅÅ/ :
(
ÅÅ: ;
)
ÅÅ; <
&&
ÇÇ 
PlatformDependent
ÇÇ $
.
ÇÇ$ %
ByteArrayEquals
ÇÇ% 4
(
ÇÇ4 5
this
ÇÇ5 9
.
ÇÇ9 :
value
ÇÇ: ?
,
ÇÇ? @
this
ÇÇA E
.
ÇÇE F
offset
ÇÇF L
,
ÇÇL M
other
ÇÇN S
.
ÇÇS T
value
ÇÇT Y
,
ÇÇY Z
other
ÇÇ[ `
.
ÇÇ` a
offset
ÇÇa g
,
ÇÇg h
this
ÇÇi m
.
ÇÇm n
length
ÇÇn t
)
ÇÇt u
;
ÇÇu v
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
bool
ÖÖ 
Equals
ÖÖ #
(
ÖÖ# $
object
ÖÖ$ *
obj
ÖÖ+ .
)
ÖÖ. /
{
ÜÜ 	
if
áá 
(
áá 
obj
áá 
==
áá 
null
áá 
)
áá 
{
àà 
return
ââ 
false
ââ 
;
ââ 
}
ää 
if
ãã 
(
ãã 
ReferenceEquals
ãã 
(
ãã  
this
ãã  $
,
ãã$ %
obj
ãã& )
)
ãã) *
)
ãã* +
{
åå 
return
çç 
true
çç 
;
çç 
}
éé 
if
êê 
(
êê 
obj
êê 
is
êê 
AsciiString
êê "
ascii
êê# (
)
êê( )
{
ëë 
return
íí 
this
íí 
.
íí 
Equals
íí "
(
íí" #
ascii
íí# (
)
íí( )
;
íí) *
}
ìì 
if
îî 
(
îî 
obj
îî 
is
îî 
ICharSequence
îî $
seq
îî% (
)
îî( )
{
ïï 
return
ññ 
this
ññ 
.
ññ 
ContentEquals
ññ )
(
ññ) *
seq
ññ* -
)
ññ- .
;
ññ. /
}
óó 
return
ôô 
false
ôô 
;
ôô 
}
öö 	
public
úú 
override
úú 
string
úú 
ToString
úú '
(
úú' (
)
úú( )
{
ùù 	
if
ûû 
(
ûû 
this
ûû 
.
ûû 
stringValue
ûû  
!=
ûû! #
null
ûû$ (
)
ûû( )
{
üü 
return
†† 
this
†† 
.
†† 
stringValue
†† '
;
††' (
}
°° 
this
££ 
.
££ 
stringValue
££ 
=
££ 
this
££ #
.
££# $
ToString
££$ ,
(
££, -
$num
££- .
)
££. /
;
££/ 0
return
§§ 
this
§§ 
.
§§ 
stringValue
§§ #
;
§§# $
}
•• 	
public
ßß 
string
ßß 
ToString
ßß 
(
ßß 
int
ßß "
start
ßß# (
)
ßß( )
=>
ßß* ,
this
ßß- 1
.
ßß1 2
ToString
ßß2 :
(
ßß: ;
start
ßß; @
,
ßß@ A
this
ßßB F
.
ßßF G
length
ßßG M
)
ßßM N
;
ßßN O
[
©© 	

MethodImpl
©©	 
(
©© 
MethodImplOptions
©© %
.
©©% & 
AggressiveInlining
©©& 8
)
©©8 9
]
©©9 :
public
™™ 
unsafe
™™ 
string
™™ 
ToString
™™ %
(
™™% &
int
™™& )
start
™™* /
,
™™/ 0
int
™™1 4
end
™™5 8
)
™™8 9
{
´´ 	
int
¨¨ 
count
¨¨ 
=
¨¨ 
end
¨¨ 
-
¨¨ 
start
¨¨ #
;
¨¨# $
if
≠≠ 
(
≠≠ 
MathUtil
≠≠ 
.
≠≠ 
IsOutOfBounds
≠≠ &
(
≠≠& '
start
≠≠' ,
,
≠≠, -
count
≠≠. 3
,
≠≠3 4
this
≠≠5 9
.
≠≠9 :
length
≠≠: @
)
≠≠@ A
)
≠≠A B
{
ÆÆ 4
&ThrowIndexOutOfRangeException_SrcIndex
ØØ 6
(
ØØ6 7
start
ØØ7 <
,
ØØ< =
count
ØØ> C
,
ØØC D
this
ØØE I
.
ØØI J
length
ØØJ P
)
ØØP Q
;
ØØQ R
}
∞∞ 
if
±± 
(
±± 
count
±± 
==
±± 
$num
±± 
)
±± 
{
≤≤ 
return
≥≥ 
string
≥≥ 
.
≥≥ 
Empty
≥≥ #
;
≥≥# $
}
¥¥ 
fixed
∂∂ 
(
∂∂ 
byte
∂∂ 
*
∂∂ 
p
∂∂ 
=
∂∂ 
&
∂∂ 
this
∂∂ "
.
∂∂" #
value
∂∂# (
[
∂∂( )
this
∂∂) -
.
∂∂- .
offset
∂∂. 4
+
∂∂5 6
start
∂∂7 <
]
∂∂< =
)
∂∂= >
{
∑∑ 
return
∏∏ 
Marshal
∏∏ 
.
∏∏ 
PtrToStringAnsi
∏∏ .
(
∏∏. /
(
∏∏/ 0
IntPtr
∏∏0 6
)
∏∏6 7
p
∏∏7 8
,
∏∏8 9
count
∏∏: ?
)
∏∏? @
;
∏∏@ A
}
ππ 
}
∫∫ 	
public
ºº 
bool
ºº 
ParseBoolean
ºº  
(
ºº  !
)
ºº! "
=>
ºº# %
this
ºº& *
.
ºº* +
length
ºº+ 1
>=
ºº2 4
$num
ºº5 6
&&
ºº7 9
this
ºº: >
.
ºº> ?
value
ºº? D
[
ººD E
this
ººE I
.
ººI J
offset
ººJ P
]
ººP Q
!=
ººR T
$num
ººU V
;
ººV W
public
ææ 
char
ææ 
	ParseChar
ææ 
(
ææ 
)
ææ 
=>
ææ  "
this
ææ# '
.
ææ' (
	ParseChar
ææ( 1
(
ææ1 2
$num
ææ2 3
)
ææ3 4
;
ææ4 5
public
¿¿ 
char
¿¿ 
	ParseChar
¿¿ 
(
¿¿ 
int
¿¿ !
start
¿¿" '
)
¿¿' (
{
¡¡ 	
if
¬¬ 
(
¬¬ 
start
¬¬ 
+
¬¬ 
$num
¬¬ 
>=
¬¬ 
this
¬¬ !
.
¬¬! "
length
¬¬" (
)
¬¬( )
{
√√ 
throw
ƒƒ 
new
ƒƒ &
IndexOutOfRangeException
ƒƒ 2
(
ƒƒ2 3
$"
ƒƒ3 5
$str
ƒƒ5 e
{
ƒƒe f
start
ƒƒf k
}
ƒƒk l
$strƒƒl Ñ
"ƒƒÑ Ö
)ƒƒÖ Ü
;ƒƒÜ á
}
≈≈ 
int
«« 
startWithOffset
«« 
=
««  !
start
««" '
+
««( )
this
««* .
.
««. /
offset
««/ 5
;
««5 6
return
…… 
(
…… 
char
…… 
)
…… 
(
…… 
(
…… 

ByteToChar
…… %
(
……% &
this
……& *
.
……* +
value
……+ 0
[
……0 1
startWithOffset
……1 @
]
……@ A
)
……A B
<<
……C E
$num
……F G
)
……G H
|
   

ByteToChar
   
(
   
this
   !
.
  ! "
value
  " '
[
  ' (
startWithOffset
  ( 7
+
  8 9
$num
  : ;
]
  ; <
)
  < =
)
  = >
;
  > ?
}
ÀÀ 	
public
ÕÕ 
short
ÕÕ 

ParseShort
ÕÕ 
(
ÕÕ  
)
ÕÕ  !
=>
ÕÕ" $
this
ÕÕ% )
.
ÕÕ) *

ParseShort
ÕÕ* 4
(
ÕÕ4 5
$num
ÕÕ5 6
,
ÕÕ6 7
this
ÕÕ8 <
.
ÕÕ< =
length
ÕÕ= C
,
ÕÕC D
$num
ÕÕE G
)
ÕÕG H
;
ÕÕH I
public
œœ 
short
œœ 

ParseShort
œœ 
(
œœ  
int
œœ  #
radix
œœ$ )
)
œœ) *
=>
œœ+ -
this
œœ. 2
.
œœ2 3

ParseShort
œœ3 =
(
œœ= >
$num
œœ> ?
,
œœ? @
this
œœA E
.
œœE F
length
œœF L
,
œœL M
radix
œœN S
)
œœS T
;
œœT U
public
—— 
short
—— 

ParseShort
—— 
(
——  
int
——  #
start
——$ )
,
——) *
int
——+ .
end
——/ 2
)
——2 3
=>
——4 6
this
——7 ;
.
——; <

ParseShort
——< F
(
——F G
start
——G L
,
——L M
end
——N Q
,
——Q R
$num
——S U
)
——U V
;
——V W
public
”” 
short
”” 

ParseShort
”” 
(
””  
int
””  #
start
””$ )
,
””) *
int
””+ .
end
””/ 2
,
””2 3
int
””4 7
radix
””8 =
)
””= >
{
‘‘ 	
int
’’ 
intValue
’’ 
=
’’ 
this
’’ 
.
’’  
ParseInt
’’  (
(
’’( )
start
’’) .
,
’’. /
end
’’0 3
,
’’3 4
radix
’’5 :
)
’’: ;
;
’’; <
short
÷÷ 
result
÷÷ 
=
÷÷ 
(
÷÷ 
short
÷÷ !
)
÷÷! "
intValue
÷÷" *
;
÷÷* +
if
◊◊ 
(
◊◊ 
result
◊◊ 
!=
◊◊ 
intValue
◊◊ "
)
◊◊" #
{
ÿÿ 
throw
ŸŸ 
new
ŸŸ 
FormatException
ŸŸ )
(
ŸŸ) *
this
ŸŸ* .
.
ŸŸ. /
SubSequence
ŸŸ/ :
(
ŸŸ: ;
start
ŸŸ; @
,
ŸŸ@ A
end
ŸŸB E
)
ŸŸE F
.
ŸŸF G
ToString
ŸŸG O
(
ŸŸO P
)
ŸŸP Q
)
ŸŸQ R
;
ŸŸR S
}
⁄⁄ 
return
‹‹ 
result
‹‹ 
;
‹‹ 
}
›› 	
public
ﬂﬂ 
int
ﬂﬂ 
ParseInt
ﬂﬂ 
(
ﬂﬂ 
)
ﬂﬂ 
=>
ﬂﬂ  
this
ﬂﬂ! %
.
ﬂﬂ% &
ParseInt
ﬂﬂ& .
(
ﬂﬂ. /
$num
ﬂﬂ/ 0
,
ﬂﬂ0 1
this
ﬂﬂ2 6
.
ﬂﬂ6 7
length
ﬂﬂ7 =
,
ﬂﬂ= >
$num
ﬂﬂ? A
)
ﬂﬂA B
;
ﬂﬂB C
public
·· 
int
·· 
ParseInt
·· 
(
·· 
int
·· 
radix
··  %
)
··% &
=>
··' )
this
··* .
.
··. /
ParseInt
··/ 7
(
··7 8
$num
··8 9
,
··9 :
this
··; ?
.
··? @
length
··@ F
,
··F G
radix
··H M
)
··M N
;
··N O
public
„„ 
int
„„ 
ParseInt
„„ 
(
„„ 
int
„„ 
start
„„  %
,
„„% &
int
„„' *
end
„„+ .
)
„„. /
=>
„„0 2
this
„„3 7
.
„„7 8
ParseInt
„„8 @
(
„„@ A
start
„„A F
,
„„F G
end
„„H K
,
„„K L
$num
„„M O
)
„„O P
;
„„P Q
public
ÂÂ 
int
ÂÂ 
ParseInt
ÂÂ 
(
ÂÂ 
int
ÂÂ 
start
ÂÂ  %
,
ÂÂ% &
int
ÂÂ' *
end
ÂÂ+ .
,
ÂÂ. /
int
ÂÂ0 3
radix
ÂÂ4 9
)
ÂÂ9 :
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
radix
ÁÁ 
<
ÁÁ 
CharUtil
ÁÁ  
.
ÁÁ  !
MinRadix
ÁÁ! )
||
ÁÁ* ,
radix
ÁÁ- 2
>
ÁÁ3 4
CharUtil
ÁÁ5 =
.
ÁÁ= >
MaxRadix
ÁÁ> F
)
ÁÁF G
{
ËË 
throw
ÈÈ 
new
ÈÈ 
FormatException
ÈÈ )
(
ÈÈ) *
$"
ÈÈ* ,
$str
ÈÈ, ?
{
ÈÈ? @
CharUtil
ÈÈ@ H
.
ÈÈH I
MinRadix
ÈÈI Q
}
ÈÈQ R
$str
ÈÈR V
{
ÈÈV W
CharUtil
ÈÈW _
.
ÈÈ_ `
MaxRadix
ÈÈ` h
}
ÈÈh i
"
ÈÈi j
)
ÈÈj k
;
ÈÈk l
}
ÍÍ 
if
ÎÎ 
(
ÎÎ 
start
ÎÎ 
==
ÎÎ 
end
ÎÎ 
)
ÎÎ 
{
ÏÏ 
throw
ÌÌ 
new
ÌÌ 
FormatException
ÌÌ )
(
ÌÌ) *
$"
ÌÌ* ,
$str
ÌÌ, E
{
ÌÌE F
start
ÌÌF K
}
ÌÌK L
$str
ÌÌL Q
{
ÌÌQ R
end
ÌÌR U
}
ÌÌU V
$str
ÌÌV d
"
ÌÌd e
)
ÌÌe f
;
ÌÌf g
}
ÓÓ 
int
 
i
 
=
 
start
 
;
 
bool
ÒÒ 
negative
ÒÒ 
=
ÒÒ 
this
ÒÒ  
.
ÒÒ  !
ByteAt
ÒÒ! '
(
ÒÒ' (
i
ÒÒ( )
)
ÒÒ) *
==
ÒÒ+ -
$char
ÒÒ. 1
;
ÒÒ1 2
if
ÚÚ 
(
ÚÚ 
negative
ÚÚ 
&&
ÚÚ 
++
ÚÚ 
i
ÚÚ 
==
ÚÚ  "
end
ÚÚ# &
)
ÚÚ& '
{
ÛÛ 
throw
ÙÙ 
new
ÙÙ 
FormatException
ÙÙ )
(
ÙÙ) *
this
ÙÙ* .
.
ÙÙ. /
SubSequence
ÙÙ/ :
(
ÙÙ: ;
start
ÙÙ; @
,
ÙÙ@ A
end
ÙÙB E
)
ÙÙE F
.
ÙÙF G
ToString
ÙÙG O
(
ÙÙO P
)
ÙÙP Q
)
ÙÙQ R
;
ÙÙR S
}
ıı 
return
˜˜ 
this
˜˜ 
.
˜˜ 
ParseInt
˜˜  
(
˜˜  !
i
˜˜! "
,
˜˜" #
end
˜˜$ '
,
˜˜' (
radix
˜˜) .
,
˜˜. /
negative
˜˜0 8
)
˜˜8 9
;
˜˜9 :
}
¯¯ 	
int
˙˙ 
ParseInt
˙˙ 
(
˙˙ 
int
˙˙ 
start
˙˙ 
,
˙˙ 
int
˙˙  #
end
˙˙$ '
,
˙˙' (
int
˙˙) ,
radix
˙˙- 2
,
˙˙2 3
bool
˙˙4 8
negative
˙˙9 A
)
˙˙A B
{
˚˚ 	
int
¸¸ 
max
¸¸ 
=
¸¸ 
int
¸¸ 
.
¸¸ 
MinValue
¸¸ "
/
¸¸# $
radix
¸¸% *
;
¸¸* +
int
˝˝ 
result
˝˝ 
=
˝˝ 
$num
˝˝ 
;
˝˝ 
int
˛˛ 

currOffset
˛˛ 
=
˛˛ 
start
˛˛ "
;
˛˛" #
while
ˇˇ 
(
ˇˇ 

currOffset
ˇˇ 
<
ˇˇ 
end
ˇˇ  #
)
ˇˇ# $
{
ÄÄ 
int
ÅÅ 
digit
ÅÅ 
=
ÅÅ 
CharUtil
ÅÅ $
.
ÅÅ$ %
Digit
ÅÅ% *
(
ÅÅ* +
(
ÅÅ+ ,
char
ÅÅ, 0
)
ÅÅ0 1
(
ÅÅ1 2
this
ÅÅ2 6
.
ÅÅ6 7
value
ÅÅ7 <
[
ÅÅ< =

currOffset
ÅÅ= G
++
ÅÅG I
+
ÅÅJ K
this
ÅÅL P
.
ÅÅP Q
offset
ÅÅQ W
]
ÅÅW X
)
ÅÅX Y
,
ÅÅY Z
radix
ÅÅ[ `
)
ÅÅ` a
;
ÅÅa b
if
ÇÇ 
(
ÇÇ 
digit
ÇÇ 
==
ÇÇ 
-
ÇÇ 
$num
ÇÇ 
)
ÇÇ  
{
ÉÉ 
throw
ÑÑ 
new
ÑÑ 
FormatException
ÑÑ -
(
ÑÑ- .
this
ÑÑ. 2
.
ÑÑ2 3
SubSequence
ÑÑ3 >
(
ÑÑ> ?
start
ÑÑ? D
,
ÑÑD E
end
ÑÑF I
)
ÑÑI J
.
ÑÑJ K
ToString
ÑÑK S
(
ÑÑS T
)
ÑÑT U
)
ÑÑU V
;
ÑÑV W
}
ÖÖ 
if
ÜÜ 
(
ÜÜ 
max
ÜÜ 
>
ÜÜ 
result
ÜÜ  
)
ÜÜ  !
{
áá 
throw
àà 
new
àà 
FormatException
àà -
(
àà- .
this
àà. 2
.
àà2 3
SubSequence
àà3 >
(
àà> ?
start
àà? D
,
ààD E
end
ààF I
)
ààI J
.
ààJ K
ToString
ààK S
(
ààS T
)
ààT U
)
ààU V
;
ààV W
}
ââ 
int
ää 
next
ää 
=
ää 
result
ää !
*
ää" #
radix
ää$ )
-
ää* +
digit
ää, 1
;
ää1 2
if
ãã 
(
ãã 
next
ãã 
>
ãã 
result
ãã !
)
ãã! "
{
åå 
throw
çç 
new
çç 
FormatException
çç -
(
çç- .
this
çç. 2
.
çç2 3
SubSequence
çç3 >
(
çç> ?
start
çç? D
,
ççD E
end
ççF I
)
ççI J
.
ççJ K
ToString
ççK S
(
ççS T
)
ççT U
)
ççU V
;
ççV W
}
éé 
result
èè 
=
èè 
next
èè 
;
èè 
}
êê 
if
íí 
(
íí 
!
íí 
negative
íí 
)
íí 
{
ìì 
result
îî 
=
îî 
-
îî 
result
îî  
;
îî  !
if
ïï 
(
ïï 
result
ïï 
<
ïï 
$num
ïï 
)
ïï 
{
ññ 
throw
óó 
new
óó 
FormatException
óó -
(
óó- .
this
óó. 2
.
óó2 3
SubSequence
óó3 >
(
óó> ?
start
óó? D
,
óóD E
end
óóF I
)
óóI J
.
óóJ K
ToString
óóK S
(
óóS T
)
óóT U
)
óóU V
;
óóV W
}
òò 
}
ôô 
return
õõ 
result
õõ 
;
õõ 
}
úú 	
public
ûû 
long
ûû 
	ParseLong
ûû 
(
ûû 
)
ûû 
=>
ûû  "
this
ûû# '
.
ûû' (
	ParseLong
ûû( 1
(
ûû1 2
$num
ûû2 3
,
ûû3 4
this
ûû5 9
.
ûû9 :
length
ûû: @
,
ûû@ A
$num
ûûB D
)
ûûD E
;
ûûE F
public
†† 
long
†† 
	ParseLong
†† 
(
†† 
int
†† !
radix
††" '
)
††' (
=>
††) +
this
††, 0
.
††0 1
	ParseLong
††1 :
(
††: ;
$num
††; <
,
††< =
this
††> B
.
††B C
length
††C I
,
††I J
radix
††K P
)
††P Q
;
††Q R
public
¢¢ 
long
¢¢ 
	ParseLong
¢¢ 
(
¢¢ 
int
¢¢ !
start
¢¢" '
,
¢¢' (
int
¢¢) ,
end
¢¢- 0
)
¢¢0 1
=>
¢¢2 4
this
¢¢5 9
.
¢¢9 :
	ParseLong
¢¢: C
(
¢¢C D
start
¢¢D I
,
¢¢I J
end
¢¢K N
,
¢¢N O
$num
¢¢P R
)
¢¢R S
;
¢¢S T
public
§§ 
long
§§ 
	ParseLong
§§ 
(
§§ 
int
§§ !
start
§§" '
,
§§' (
int
§§) ,
end
§§- 0
,
§§0 1
int
§§2 5
radix
§§6 ;
)
§§; <
{
•• 	
if
¶¶ 
(
¶¶ 
radix
¶¶ 
<
¶¶ 
CharUtil
¶¶  
.
¶¶  !
MinRadix
¶¶! )
||
¶¶* ,
radix
¶¶- 2
>
¶¶3 4
CharUtil
¶¶5 =
.
¶¶= >
MaxRadix
¶¶> F
)
¶¶F G
{
ßß 
throw
®® 
new
®® 
FormatException
®® )
(
®®) *
$"
®®* ,
$str
®®, ?
{
®®? @
CharUtil
®®@ H
.
®®H I
MinRadix
®®I Q
}
®®Q R
$str
®®R V
{
®®V W
CharUtil
®®W _
.
®®_ `
MaxRadix
®®` h
}
®®h i
"
®®i j
)
®®j k
;
®®k l
}
©© 
if
´´ 
(
´´ 
start
´´ 
==
´´ 
end
´´ 
)
´´ 
{
¨¨ 
throw
≠≠ 
new
≠≠ 
FormatException
≠≠ )
(
≠≠) *
$"
≠≠* ,
$str
≠≠, E
{
≠≠E F
start
≠≠F K
}
≠≠K L
$str
≠≠L Q
{
≠≠Q R
end
≠≠R U
}
≠≠U V
$str
≠≠V d
"
≠≠d e
)
≠≠e f
;
≠≠f g
}
ÆÆ 
int
∞∞ 
i
∞∞ 
=
∞∞ 
start
∞∞ 
;
∞∞ 
bool
±± 
negative
±± 
=
±± 
this
±±  
.
±±  !
ByteAt
±±! '
(
±±' (
i
±±( )
)
±±) *
==
±±+ -
$char
±±. 1
;
±±1 2
if
≤≤ 
(
≤≤ 
negative
≤≤ 
&&
≤≤ 
++
≤≤ 
i
≤≤ 
==
≤≤  "
end
≤≤# &
)
≤≤& '
{
≥≥ 
throw
¥¥ 
new
¥¥ 
FormatException
¥¥ )
(
¥¥) *
this
¥¥* .
.
¥¥. /
SubSequence
¥¥/ :
(
¥¥: ;
start
¥¥; @
,
¥¥@ A
end
¥¥B E
)
¥¥E F
.
¥¥F G
ToString
¥¥G O
(
¥¥O P
)
¥¥P Q
)
¥¥Q R
;
¥¥R S
}
µµ 
return
∑∑ 
this
∑∑ 
.
∑∑ 
	ParseLong
∑∑ !
(
∑∑! "
i
∑∑" #
,
∑∑# $
end
∑∑% (
,
∑∑( )
radix
∑∑* /
,
∑∑/ 0
negative
∑∑1 9
)
∑∑9 :
;
∑∑: ;
}
∏∏ 	
long
∫∫ 
	ParseLong
∫∫ 
(
∫∫ 
int
∫∫ 
start
∫∫  
,
∫∫  !
int
∫∫" %
end
∫∫& )
,
∫∫) *
int
∫∫+ .
radix
∫∫/ 4
,
∫∫4 5
bool
∫∫6 :
negative
∫∫; C
)
∫∫C D
{
ªª 	
long
ºº 
max
ºº 
=
ºº 
long
ºº 
.
ºº 
MinValue
ºº $
/
ºº% &
radix
ºº' ,
;
ºº, -
long
ΩΩ 
result
ΩΩ 
=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
int
ææ 

currOffset
ææ 
=
ææ 
start
ææ "
;
ææ" #
while
øø 
(
øø 

currOffset
øø 
<
øø 
end
øø  #
)
øø# $
{
¿¿ 
int
¡¡ 
digit
¡¡ 
=
¡¡ 
CharUtil
¡¡ $
.
¡¡$ %
Digit
¡¡% *
(
¡¡* +
(
¡¡+ ,
char
¡¡, 0
)
¡¡0 1
(
¡¡1 2
this
¡¡2 6
.
¡¡6 7
value
¡¡7 <
[
¡¡< =

currOffset
¡¡= G
++
¡¡G I
+
¡¡J K
this
¡¡L P
.
¡¡P Q
offset
¡¡Q W
]
¡¡W X
)
¡¡X Y
,
¡¡Y Z
radix
¡¡[ `
)
¡¡` a
;
¡¡a b
if
¬¬ 
(
¬¬ 
digit
¬¬ 
==
¬¬ 
-
¬¬ 
$num
¬¬ 
)
¬¬  
{
√√ 
throw
ƒƒ 
new
ƒƒ 
FormatException
ƒƒ -
(
ƒƒ- .
this
ƒƒ. 2
.
ƒƒ2 3
SubSequence
ƒƒ3 >
(
ƒƒ> ?
start
ƒƒ? D
,
ƒƒD E
end
ƒƒF I
)
ƒƒI J
.
ƒƒJ K
ToString
ƒƒK S
(
ƒƒS T
)
ƒƒT U
)
ƒƒU V
;
ƒƒV W
}
≈≈ 
if
∆∆ 
(
∆∆ 
max
∆∆ 
>
∆∆ 
result
∆∆  
)
∆∆  !
{
«« 
throw
»» 
new
»» 
FormatException
»» -
(
»»- .
this
»». 2
.
»»2 3
SubSequence
»»3 >
(
»»> ?
start
»»? D
,
»»D E
end
»»F I
)
»»I J
.
»»J K
ToString
»»K S
(
»»S T
)
»»T U
)
»»U V
;
»»V W
}
…… 
long
   
next
   
=
   
result
   "
*
  # $
radix
  % *
-
  + ,
digit
  - 2
;
  2 3
if
ÀÀ 
(
ÀÀ 
next
ÀÀ 
>
ÀÀ 
result
ÀÀ !
)
ÀÀ! "
{
ÃÃ 
throw
ÕÕ 
new
ÕÕ 
FormatException
ÕÕ -
(
ÕÕ- .
this
ÕÕ. 2
.
ÕÕ2 3
SubSequence
ÕÕ3 >
(
ÕÕ> ?
start
ÕÕ? D
,
ÕÕD E
end
ÕÕF I
)
ÕÕI J
.
ÕÕJ K
ToString
ÕÕK S
(
ÕÕS T
)
ÕÕT U
)
ÕÕU V
;
ÕÕV W
}
ŒŒ 
result
œœ 
=
œœ 
next
œœ 
;
œœ 
}
–– 
if
““ 
(
““ 
!
““ 
negative
““ 
)
““ 
{
”” 
result
‘‘ 
=
‘‘ 
-
‘‘ 
result
‘‘  
;
‘‘  !
if
’’ 
(
’’ 
result
’’ 
<
’’ 
$num
’’ 
)
’’ 
{
÷÷ 
throw
◊◊ 
new
◊◊ 
FormatException
◊◊ -
(
◊◊- .
this
◊◊. 2
.
◊◊2 3
SubSequence
◊◊3 >
(
◊◊> ?
start
◊◊? D
,
◊◊D E
end
◊◊F I
)
◊◊I J
.
◊◊J K
ToString
◊◊K S
(
◊◊S T
)
◊◊T U
)
◊◊U V
;
◊◊V W
}
ÿÿ 
}
ŸŸ 
return
€€ 
result
€€ 
;
€€ 
}
‹‹ 	
public
ﬁﬁ 
float
ﬁﬁ 

ParseFloat
ﬁﬁ 
(
ﬁﬁ  
)
ﬁﬁ  !
=>
ﬁﬁ" $
this
ﬁﬁ% )
.
ﬁﬁ) *

ParseFloat
ﬁﬁ* 4
(
ﬁﬁ4 5
$num
ﬁﬁ5 6
,
ﬁﬁ6 7
this
ﬁﬁ8 <
.
ﬁﬁ< =
length
ﬁﬁ= C
)
ﬁﬁC D
;
ﬁﬁD E
public
‡‡ 
float
‡‡ 

ParseFloat
‡‡ 
(
‡‡  
int
‡‡  #
start
‡‡$ )
,
‡‡) *
int
‡‡+ .
end
‡‡/ 2
)
‡‡2 3
=>
‡‡4 6
Convert
‡‡7 >
.
‡‡> ?
ToSingle
‡‡? G
(
‡‡G H
this
‡‡H L
.
‡‡L M
ToString
‡‡M U
(
‡‡U V
start
‡‡V [
,
‡‡[ \
end
‡‡] `
)
‡‡` a
)
‡‡a b
;
‡‡b c
public
‚‚ 
double
‚‚ 
ParseDouble
‚‚ !
(
‚‚! "
)
‚‚" #
=>
‚‚$ &
this
‚‚' +
.
‚‚+ ,
ParseDouble
‚‚, 7
(
‚‚7 8
$num
‚‚8 9
,
‚‚9 :
this
‚‚; ?
.
‚‚? @
length
‚‚@ F
)
‚‚F G
;
‚‚G H
public
‰‰ 
double
‰‰ 
ParseDouble
‰‰ !
(
‰‰! "
int
‰‰" %
start
‰‰& +
,
‰‰+ ,
int
‰‰- 0
end
‰‰1 4
)
‰‰4 5
=>
‰‰6 8
Convert
‰‰9 @
.
‰‰@ A
ToDouble
‰‰A I
(
‰‰I J
this
‰‰J N
.
‰‰N O
ToString
‰‰O W
(
‰‰W X
start
‰‰X ]
,
‰‰] ^
end
‰‰_ b
)
‰‰b c
)
‰‰c d
;
‰‰d e
public
ÊÊ 
static
ÊÊ 
AsciiString
ÊÊ !
Of
ÊÊ" $
(
ÊÊ$ %
string
ÊÊ% +
value
ÊÊ, 1
)
ÊÊ1 2
=>
ÊÊ3 5
new
ÊÊ6 9
AsciiString
ÊÊ: E
(
ÊÊE F
value
ÊÊF K
)
ÊÊK L
;
ÊÊL M
public
ËË 
static
ËË 
AsciiString
ËË !
Of
ËË" $
(
ËË$ %
ICharSequence
ËË% 2
charSequence
ËË3 ?
)
ËË? @
=>
ËËA C
charSequence
ËËD P
is
ËËQ S
AsciiString
ËËT _
s
ËË` a
?
ËËb c
s
ËËd e
:
ËËf g
new
ËËh k
AsciiString
ËËl w
(
ËËw x
charSequenceËËx Ñ
)ËËÑ Ö
;ËËÖ Ü
public
ÍÍ 
static
ÍÍ 
AsciiString
ÍÍ !
Cached
ÍÍ" (
(
ÍÍ( )
string
ÍÍ) /
value
ÍÍ0 5
)
ÍÍ5 6
{
ÎÎ 	
var
ÏÏ 
asciiString
ÏÏ 
=
ÏÏ 
new
ÏÏ !
AsciiString
ÏÏ" -
(
ÏÏ- .
value
ÏÏ. 3
)
ÏÏ3 4
;
ÏÏ4 5
asciiString
ÌÌ 
.
ÌÌ 
stringValue
ÌÌ #
=
ÌÌ$ %
value
ÌÌ& +
;
ÌÌ+ ,
return
ÓÓ 
asciiString
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
public
ÒÒ 
static
ÒÒ 
int
ÒÒ 
GetHashCode
ÒÒ %
(
ÒÒ% &
ICharSequence
ÒÒ& 3
value
ÒÒ4 9
)
ÒÒ9 :
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
value
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
{
ÙÙ 
return
ıı 
$num
ıı 
;
ıı 
}
ˆˆ 
if
˜˜ 
(
˜˜ 
value
˜˜ 
is
˜˜ 
AsciiString
˜˜ $
)
˜˜$ %
{
¯¯ 
return
˘˘ 
value
˘˘ 
.
˘˘ 
GetHashCode
˘˘ (
(
˘˘( )
)
˘˘) *
;
˘˘* +
}
˙˙ 
return
¸¸ 
PlatformDependent
¸¸ %
.
¸¸% &
HashCodeAscii
¸¸& 3
(
¸¸3 4
value
¸¸4 9
)
¸¸9 :
;
¸¸: ;
}
˝˝ 	
public
ˇˇ 
static
ˇˇ 
bool
ˇˇ 
Contains
ˇˇ #
(
ˇˇ# $
ICharSequence
ˇˇ$ 1
a
ˇˇ2 3
,
ˇˇ3 4
ICharSequence
ˇˇ5 B
b
ˇˇC D
)
ˇˇD E
=>
ˇˇF H
Contains
ˇˇI Q
(
ˇˇQ R
a
ˇˇR S
,
ˇˇS T
b
ˇˇU V
,
ˇˇV W#
DefaultCharComparator
ˇˇX m
)
ˇˇm n
;
ˇˇn o
public
Å	Å	 
static
Å	Å	 
bool
Å	Å	  
ContainsIgnoreCase
Å	Å	 -
(
Å	Å	- .
ICharSequence
Å	Å	. ;
a
Å	Å	< =
,
Å	Å	= >
ICharSequence
Å	Å	? L
b
Å	Å	M N
)
Å	Å	N O
=>
Å	Å	P R
Contains
Å	Å	S [
(
Å	Å	[ \
a
Å	Å	\ ]
,
Å	Å	] ^
b
Å	Å	_ `
,
Å	Å	` a1
"AsciiCaseInsensitiveCharComparatorÅ	Å	b Ñ
)Å	Å	Ñ Ö
;Å	Å	Ö Ü
public
É	É	 
static
É	É	 
bool
É	É	 %
ContentEqualsIgnoreCase
É	É	 2
(
É	É	2 3
ICharSequence
É	É	3 @
a
É	É	A B
,
É	É	B C
ICharSequence
É	É	D Q
b
É	É	R S
)
É	É	S T
{
Ñ	Ñ	 	
if
Ö	Ö	 
(
Ö	Ö	 
a
Ö	Ö	 
==
Ö	Ö	 
null
Ö	Ö	 
||
Ö	Ö	 
b
Ö	Ö	 
==
Ö	Ö	 !
null
Ö	Ö	" &
)
Ö	Ö	& '
{
Ü	Ü	 
return
á	á	 
ReferenceEquals
á	á	 &
(
á	á	& '
a
á	á	' (
,
á	á	( )
b
á	á	* +
)
á	á	+ ,
;
á	á	, -
}
à	à	 
if
ä	ä	 
(
ä	ä	 
a
ä	ä	 
is
ä	ä	 
AsciiString
ä	ä	  
stringA
ä	ä	! (
)
ä	ä	( )
{
ã	ã	 
return
å	å	 
stringA
å	å	 
.
å	å	 %
ContentEqualsIgnoreCase
å	å	 6
(
å	å	6 7
b
å	å	7 8
)
å	å	8 9
;
å	å	9 :
}
ç	ç	 
if
é	é	 
(
é	é	 
b
é	é	 
is
é	é	 
AsciiString
é	é	  
stringB
é	é	! (
)
é	é	( )
{
è	è	 
return
ê	ê	 
stringB
ê	ê	 
.
ê	ê	 %
ContentEqualsIgnoreCase
ê	ê	 6
(
ê	ê	6 7
a
ê	ê	7 8
)
ê	ê	8 9
;
ê	ê	9 :
}
ë	ë	 
if
ì	ì	 
(
ì	ì	 
a
ì	ì	 
.
ì	ì	 
Count
ì	ì	 
!=
ì	ì	 
b
ì	ì	 
.
ì	ì	 
Count
ì	ì	 "
)
ì	ì	" #
{
î	î	 
return
ï	ï	 
false
ï	ï	 
;
ï	ï	 
}
ñ	ñ	 
for
ó	ó	 
(
ó	ó	 
int
ó	ó	 
i
ó	ó	 
=
ó	ó	 
$num
ó	ó	 
,
ó	ó	 
j
ó	ó	 
=
ó	ó	 
$num
ó	ó	  !
;
ó	ó	! "
i
ó	ó	# $
<
ó	ó	% &
a
ó	ó	' (
.
ó	ó	( )
Count
ó	ó	) .
;
ó	ó	. /
++
ó	ó	0 2
i
ó	ó	2 3
,
ó	ó	3 4
++
ó	ó	5 7
j
ó	ó	7 8
)
ó	ó	8 9
{
ò	ò	 
if
ô	ô	 
(
ô	ô	 
!
ô	ô	 
EqualsIgnoreCase
ô	ô	 %
(
ô	ô	% &
a
ô	ô	& '
[
ô	ô	' (
i
ô	ô	( )
]
ô	ô	) *
,
ô	ô	* +
b
ô	ô	, -
[
ô	ô	- .
j
ô	ô	. /
]
ô	ô	/ 0
)
ô	ô	0 1
)
ô	ô	1 2
{
ö	ö	 
return
õ	õ	 
false
õ	õ	  
;
õ	õ	  !
}
ú	ú	 
}
ù	ù	 
return
ü	ü	 
true
ü	ü	 
;
ü	ü	 
}
†	†	 	
public
¢	¢	 
static
¢	¢	 
bool
¢	¢	 -
ContainsContentEqualsIgnoreCase
¢	¢	 :
(
¢	¢	: ;
ICollection
¢	¢	; F
<
¢	¢	F G
ICharSequence
¢	¢	G T
>
¢	¢	T U

collection
¢	¢	V `
,
¢	¢	` a
ICharSequence
¢	¢	b o
value
¢	¢	p u
)
¢	¢	u v
{
£	£	 	
foreach
§	§	 
(
§	§	 
ICharSequence
§	§	 "
v
§	§	# $
in
§	§	% '

collection
§	§	( 2
)
§	§	2 3
{
•	•	 
if
¶	¶	 
(
¶	¶	 %
ContentEqualsIgnoreCase
¶	¶	 +
(
¶	¶	+ ,
value
¶	¶	, 1
,
¶	¶	1 2
v
¶	¶	3 4
)
¶	¶	4 5
)
¶	¶	5 6
{
ß	ß	 
return
®	®	 
true
®	®	 
;
®	®	  
}
©	©	 
}
™	™	 
return
¨	¨	 
false
¨	¨	 
;
¨	¨	 
}
≠	≠	 	
public
Ø	Ø	 
static
Ø	Ø	 
bool
Ø	Ø	 0
"ContainsAllContentEqualsIgnoreCase
Ø	Ø	 =
(
Ø	Ø	= >
ICollection
Ø	Ø	> I
<
Ø	Ø	I J
ICharSequence
Ø	Ø	J W
>
Ø	Ø	W X
a
Ø	Ø	Y Z
,
Ø	Ø	Z [
ICollection
Ø	Ø	\ g
<
Ø	Ø	g h
AsciiString
Ø	Ø	h s
>
Ø	Ø	s t
b
Ø	Ø	u v
)
Ø	Ø	v w
{
∞	∞	 	
foreach
±	±	 
(
±	±	 
AsciiString
±	±	  
v
±	±	! "
in
±	±	# %
b
±	±	& '
)
±	±	' (
{
≤	≤	 
if
≥	≥	 
(
≥	≥	 
!
≥	≥	 -
ContainsContentEqualsIgnoreCase
≥	≥	 4
(
≥	≥	4 5
a
≥	≥	5 6
,
≥	≥	6 7
v
≥	≥	8 9
)
≥	≥	9 :
)
≥	≥	: ;
{
¥	¥	 
return
µ	µ	 
false
µ	µ	  
;
µ	µ	  !
}
∂	∂	 
}
∑	∑	 
return
π	π	 
true
π	π	 
;
π	π	 
}
∫	∫	 	
public
º	º	 
static
º	º	 
bool
º	º	 
ContentEquals
º	º	 (
(
º	º	( )
ICharSequence
º	º	) 6
a
º	º	7 8
,
º	º	8 9
ICharSequence
º	º	: G
b
º	º	H I
)
º	º	I J
{
Ω	Ω	 	
if
æ	æ	 
(
æ	æ	 
a
æ	æ	 
==
æ	æ	 
null
æ	æ	 
||
æ	æ	 
b
æ	æ	 
==
æ	æ	 !
null
æ	æ	" &
)
æ	æ	& '
{
ø	ø	 
return
¿	¿	 
ReferenceEquals
¿	¿	 &
(
¿	¿	& '
a
¿	¿	' (
,
¿	¿	( )
b
¿	¿	* +
)
¿	¿	+ ,
;
¿	¿	, -
}
¡	¡	 
if
√	√	 
(
√	√	 
a
√	√	 
is
√	√	 
AsciiString
√	√	  
stringA
√	√	! (
)
√	√	( )
{
ƒ	ƒ	 
return
≈	≈	 
stringA
≈	≈	 
.
≈	≈	 
ContentEquals
≈	≈	 ,
(
≈	≈	, -
b
≈	≈	- .
)
≈	≈	. /
;
≈	≈	/ 0
}
∆	∆	 
if
«	«	 
(
«	«	 
b
«	«	 
is
«	«	 
AsciiString
«	«	  
stringB
«	«	! (
)
«	«	( )
{
»	»	 
return
…	…	 
stringB
…	…	 
.
…	…	 
ContentEquals
…	…	 ,
(
…	…	, -
a
…	…	- .
)
…	…	. /
;
…	…	/ 0
}
 	 	 
if
Ã	Ã	 
(
Ã	Ã	 
a
Ã	Ã	 
.
Ã	Ã	 
Count
Ã	Ã	 
!=
Ã	Ã	 
b
Ã	Ã	 
.
Ã	Ã	 
Count
Ã	Ã	 "
)
Ã	Ã	" #
{
Õ	Õ	 
return
Œ	Œ	 
false
Œ	Œ	 
;
Œ	Œ	 
}
œ	œ	 
for
—	—	 
(
—	—	 
int
—	—	 
i
—	—	 
=
—	—	 
$num
—	—	 
;
—	—	 
i
—	—	 
<
—	—	 
a
—	—	  !
.
—	—	! "
Count
—	—	" '
;
—	—	' (
++
—	—	) +
i
—	—	+ ,
)
—	—	, -
{
“	“	 
if
”	”	 
(
”	”	 
a
”	”	 
[
”	”	 
i
”	”	 
]
”	”	 
!=
”	”	 
b
”	”	 
[
”	”	 
i
”	”	 
]
”	”	  
)
”	”	  !
{
‘	‘	 
return
’	’	 
false
’	’	  
;
’	’	  !
}
÷	÷	 
}
◊	◊	 
return
Ÿ	Ÿ	 
true
Ÿ	Ÿ	 
;
Ÿ	Ÿ	 
}
⁄	⁄	 	
static
‹	‹	 
bool
‹	‹	 
Contains
‹	‹	 
(
‹	‹	 
ICharSequence
‹	‹	 *
a
‹	‹	+ ,
,
‹	‹	, -
ICharSequence
‹	‹	. ;
b
‹	‹	< =
,
‹	‹	= >%
ICharEqualityComparator
‹	‹	? V

comparator
‹	‹	W a
)
‹	‹	a b
{
›	›	 	
if
ﬁ	ﬁ	 
(
ﬁ	ﬁ	 
a
ﬁ	ﬁ	 
==
ﬁ	ﬁ	 
null
ﬁ	ﬁ	 
||
ﬁ	ﬁ	 
b
ﬁ	ﬁ	 
==
ﬁ	ﬁ	 !
null
ﬁ	ﬁ	" &
||
ﬁ	ﬁ	' )
a
ﬁ	ﬁ	* +
.
ﬁ	ﬁ	+ ,
Count
ﬁ	ﬁ	, 1
<
ﬁ	ﬁ	2 3
b
ﬁ	ﬁ	4 5
.
ﬁ	ﬁ	5 6
Count
ﬁ	ﬁ	6 ;
)
ﬁ	ﬁ	; <
{
ﬂ	ﬂ	 
return
‡	‡	 
false
‡	‡	 
;
‡	‡	 
}
·	·	 
if
‚	‚	 
(
‚	‚	 
b
‚	‚	 
.
‚	‚	 
Count
‚	‚	 
==
‚	‚	 
$num
‚	‚	 
)
‚	‚	 
{
„	„	 
return
‰	‰	 
true
‰	‰	 
;
‰	‰	 
}
Â	Â	 
int
Á	Á	 
bStart
Á	Á	 
=
Á	Á	 
$num
Á	Á	 
;
Á	Á	 
for
Ë	Ë	 
(
Ë	Ë	 
int
Ë	Ë	 
i
Ë	Ë	 
=
Ë	Ë	 
$num
Ë	Ë	 
;
Ë	Ë	 
i
Ë	Ë	 
<
Ë	Ë	 
a
Ë	Ë	  !
.
Ë	Ë	! "
Count
Ë	Ë	" '
;
Ë	Ë	' (
++
Ë	Ë	) +
i
Ë	Ë	+ ,
)
Ë	Ë	, -
{
È	È	 
if
Í	Í	 
(
Í	Í	 

comparator
Í	Í	 
.
Í	Í	 

CharEquals
Í	Í	 )
(
Í	Í	) *
b
Í	Í	* +
[
Í	Í	+ ,
bStart
Í	Í	, 2
]
Í	Í	2 3
,
Í	Í	3 4
a
Í	Í	5 6
[
Í	Í	6 7
i
Í	Í	7 8
]
Í	Í	8 9
)
Í	Í	9 :
)
Í	Í	: ;
{
Î	Î	 
if
Ì	Ì	 
(
Ì	Ì	 
++
Ì	Ì	 
bStart
Ì	Ì	  
==
Ì	Ì	! #
b
Ì	Ì	$ %
.
Ì	Ì	% &
Count
Ì	Ì	& +
)
Ì	Ì	+ ,
{
Ó	Ó	 
return
Ô	Ô	 
true
Ô	Ô	 #
;
Ô	Ô	# $
}
		 
}
Ò	Ò	 
else
Ú	Ú	 
if
Ú	Ú	 
(
Ú	Ú	 
a
Ú	Ú	 
.
Ú	Ú	 
Count
Ú	Ú	  
-
Ú	Ú	! "
i
Ú	Ú	# $
<
Ú	Ú	% &
b
Ú	Ú	' (
.
Ú	Ú	( )
Count
Ú	Ú	) .
)
Ú	Ú	. /
{
Û	Û	 
return
ı	ı	 
false
ı	ı	  
;
ı	ı	  !
}
ˆ	ˆ	 
else
˜	˜	 
{
¯	¯	 
bStart
˘	˘	 
=
˘	˘	 
$num
˘	˘	 
;
˘	˘	 
}
˙	˙	 
}
˚	˚	 
return
˝	˝	 
false
˝	˝	 
;
˝	˝	 
}
˛	˛	 	
static
Ä
Ä
 
bool
Ä
Ä
 (
RegionMatchesCharSequences
Ä
Ä
 .
(
Ä
Ä
. /
ICharSequence
Ä
Ä
/ <
cs
Ä
Ä
= ?
,
Ä
Ä
? @
int
Ä
Ä
A D
csStart
Ä
Ä
E L
,
Ä
Ä
L M
ICharSequence
Å
Å
 
seq
Å
Å
 
,
Å
Å
 
int
Å
Å
 "
start
Å
Å
# (
,
Å
Å
( )
int
Å
Å
* -
length
Å
Å
. 4
,
Å
Å
4 5%
ICharEqualityComparator
Å
Å
6 M$
charEqualityComparator
Å
Å
N d
)
Å
Å
d e
{
Ç
Ç
 	
if
Ñ
Ñ
 
(
Ñ
Ñ
 
csStart
Ñ
Ñ
 
<
Ñ
Ñ
 
$num
Ñ
Ñ
 
||
Ñ
Ñ
 
length
Ñ
Ñ
 %
>
Ñ
Ñ
& '
cs
Ñ
Ñ
( *
.
Ñ
Ñ
* +
Count
Ñ
Ñ
+ 0
-
Ñ
Ñ
1 2
csStart
Ñ
Ñ
3 :
)
Ñ
Ñ
: ;
{
Ö
Ö
 
return
Ü
Ü
 
false
Ü
Ü
 
;
Ü
Ü
 
}
á
á
 
if
à
à
 
(
à
à
 
start
à
à
 
<
à
à
 
$num
à
à
 
||
à
à
 
length
à
à
 #
>
à
à
$ %
seq
à
à
& )
.
à
à
) *
Count
à
à
* /
-
à
à
0 1
start
à
à
2 7
)
à
à
7 8
{
â
â
 
return
ä
ä
 
false
ä
ä
 
;
ä
ä
 
}
ã
ã
 
int
ç
ç
 
csIndex
ç
ç
 
=
ç
ç
 
csStart
ç
ç
 !
;
ç
ç
! "
int
é
é
 
csEnd
é
é
 
=
é
é
 
csIndex
é
é
 
+
é
é
  !
length
é
é
" (
;
é
é
( )
int
è
è
 
stringIndex
è
è
 
=
è
è
 
start
è
è
 #
;
è
è
# $
while
ë
ë
 
(
ë
ë
 
csIndex
ë
ë
 
<
ë
ë
 
csEnd
ë
ë
 "
)
ë
ë
" #
{
í
í
 
char
ì
ì
 
c1
ì
ì
 
=
ì
ì
 
cs
ì
ì
 
[
ì
ì
 
csIndex
ì
ì
 $
++
ì
ì
$ &
]
ì
ì
& '
;
ì
ì
' (
char
î
î
 
c2
î
î
 
=
î
î
 
seq
î
î
 
[
î
î
 
stringIndex
î
î
 )
++
î
î
) +
]
î
î
+ ,
;
î
î
, -
if
ñ
ñ
 
(
ñ
ñ
 
!
ñ
ñ
 $
charEqualityComparator
ñ
ñ
 +
.
ñ
ñ
+ ,

CharEquals
ñ
ñ
, 6
(
ñ
ñ
6 7
c1
ñ
ñ
7 9
,
ñ
ñ
9 :
c2
ñ
ñ
; =
)
ñ
ñ
= >
)
ñ
ñ
> ?
{
ó
ó
 
return
ò
ò
 
false
ò
ò
  
;
ò
ò
  !
}
ô
ô
 
}
ö
ö
 
return
ú
ú
 
true
ú
ú
 
;
ú
ú
 
}
ù
ù
 	
public
ü
ü
 
static
ü
ü
 
bool
ü
ü
 
RegionMatches
ü
ü
 (
(
ü
ü
( )
ICharSequence
ü
ü
) 6
cs
ü
ü
7 9
,
ü
ü
9 :
bool
ü
ü
; ?

ignoreCase
ü
ü
@ J
,
ü
ü
J K
int
ü
ü
L O
csStart
ü
ü
P W
,
ü
ü
W X
ICharSequence
ü
ü
Y f
seq
ü
ü
g j
,
ü
ü
j k
int
ü
ü
l o
start
ü
ü
p u
,
ü
ü
u v
int
ü
ü
w z
lengthü
ü
{ Å
)ü
ü
Å Ç
{
†
†
 	
if
°
°
 
(
°
°
 
cs
°
°
 
==
°
°
 
null
°
°
 
||
°
°
 
seq
°
°
 !
==
°
°
" $
null
°
°
% )
)
°
°
) *
{
¢
¢
 
return
£
£
 
false
£
£
 
;
£
£
 
}
§
§
 
if
•
•
 
(
•
•
 
cs
•
•
 
is
•
•
  
StringCharSequence
•
•
 ( 
stringCharSequence
•
•
) ;
&&
•
•
< >
seq
•
•
? B
is
•
•
C E 
StringCharSequence
•
•
F X
)
•
•
X Y
{
¶
¶
 
return
ß
ß
 

ignoreCase
ß
ß
 !
?
®
®
  
stringCharSequence
®
®
 (
.
®
®
( )%
RegionMatchesIgnoreCase
®
®
) @
(
®
®
@ A
csStart
®
®
A H
,
®
®
H I
seq
®
®
J M
,
®
®
M N
start
®
®
O T
,
®
®
T U
length
®
®
V \
)
®
®
\ ]
:
©
©
  
stringCharSequence
©
©
 (
.
©
©
( )
RegionMatches
©
©
) 6
(
©
©
7 8
csStart
©
©
8 ?
,
©
©
? @
seq
©
©
A D
,
©
©
D E
start
©
©
F K
,
©
©
K L
length
©
©
M S
)
©
©
S T
;
©
©
T U
}
™
™
 
if
´
´
 
(
´
´
 
cs
´
´
 
is
´
´
 
AsciiString
´
´
 !
asciiString
´
´
" -
)
´
´
- .
{
¨
¨
 
return
≠
≠
 

ignoreCase
≠
≠
 !
?
Æ
Æ
 
asciiString
Æ
Æ
 !
.
Æ
Æ
! "%
RegionMatchesIgnoreCase
Æ
Æ
" 9
(
Æ
Æ
9 :
csStart
Æ
Æ
: A
,
Æ
Æ
A B
seq
Æ
Æ
C F
,
Æ
Æ
F G
start
Æ
Æ
H M
,
Æ
Æ
M N
length
Æ
Æ
O U
)
Æ
Æ
U V
:
Ø
Ø
 
asciiString
Ø
Ø
 !
.
Ø
Ø
! "
RegionMatches
Ø
Ø
" /
(
Ø
Ø
/ 0
csStart
Ø
Ø
0 7
,
Ø
Ø
7 8
seq
Ø
Ø
9 <
,
Ø
Ø
< =
start
Ø
Ø
> C
,
Ø
Ø
C D
length
Ø
Ø
E K
)
Ø
Ø
K L
;
Ø
Ø
L M
}
∞
∞
 
return
≤
≤
 (
RegionMatchesCharSequences
≤
≤
 -
(
≤
≤
- .
cs
≤
≤
. 0
,
≤
≤
0 1
csStart
≤
≤
2 9
,
≤
≤
9 :
seq
≤
≤
; >
,
≤
≤
> ?
start
≤
≤
@ E
,
≤
≤
E F
length
≤
≤
G M
,
≤
≤
M N

ignoreCase
≥
≥
 
?
≥
≥
 .
 GeneralCaseInsensitiveComparator
≥
≥
 =
:
≥
≥
> ?#
DefaultCharComparator
≥
≥
@ U
)
≥
≥
U V
;
≥
≥
V W
}
¥
¥
 	
public
∂
∂
 
static
∂
∂
 
bool
∂
∂
  
RegionMatchesAscii
∂
∂
 -
(
∂
∂
- .
ICharSequence
∂
∂
. ;
cs
∂
∂
< >
,
∂
∂
> ?
bool
∂
∂
@ D

ignoreCase
∂
∂
E O
,
∂
∂
O P
int
∂
∂
Q T
csStart
∂
∂
U \
,
∂
∂
\ ]
ICharSequence
∂
∂
^ k
seq
∂
∂
l o
,
∂
∂
o p
int
∂
∂
q t
start
∂
∂
u z
,
∂
∂
z {
int
∂
∂
| 
length∂
∂
Ä Ü
)∂
∂
Ü á
{
∑
∑
 	
if
∏
∏
 
(
∏
∏
 
cs
∏
∏
 
==
∏
∏
 
null
∏
∏
 
||
∏
∏
 
seq
∏
∏
 !
==
∏
∏
" $
null
∏
∏
% )
)
∏
∏
) *
{
π
π
 
return
∫
∫
 
false
∫
∫
 
;
∫
∫
 
}
ª
ª
 
if
Ω
Ω
 
(
Ω
Ω
 
!
Ω
Ω
 

ignoreCase
Ω
Ω
 
&&
Ω
Ω
 
cs
Ω
Ω
 !
is
Ω
Ω
" $ 
StringCharSequence
Ω
Ω
% 7
&&
Ω
Ω
8 :
seq
Ω
Ω
; >
is
Ω
Ω
? A 
StringCharSequence
Ω
Ω
B T
)
Ω
Ω
T U
{
æ
æ
 
return
¬
¬
 
cs
¬
¬
 
.
¬
¬
 
RegionMatches
¬
¬
 '
(
¬
¬
' (
csStart
¬
¬
( /
,
¬
¬
/ 0
seq
¬
¬
1 4
,
¬
¬
4 5
start
¬
¬
6 ;
,
¬
¬
; <
length
¬
¬
= C
)
¬
¬
C D
;
¬
¬
D E
}
√
√
 
if
≈
≈
 
(
≈
≈
 
cs
≈
≈
 
is
≈
≈
 
AsciiString
≈
≈
 !
asciiString
≈
≈
" -
)
≈
≈
- .
{
∆
∆
 
return
«
«
 

ignoreCase
«
«
 !
?
»
»
 
asciiString
»
»
 !
.
»
»
! "%
RegionMatchesIgnoreCase
»
»
" 9
(
»
»
9 :
csStart
»
»
: A
,
»
»
A B
seq
»
»
C F
,
»
»
F G
start
»
»
H M
,
»
»
M N
length
»
»
O U
)
»
»
U V
:
…
…
 
asciiString
…
…
 !
.
…
…
! "
RegionMatches
…
…
" /
(
…
…
/ 0
csStart
…
…
0 7
,
…
…
7 8
seq
…
…
9 <
,
…
…
< =
start
…
…
> C
,
…
…
C D
length
…
…
E K
)
…
…
K L
;
…
…
L M
}
 
 
 
return
Ã
Ã
 (
RegionMatchesCharSequences
Ã
Ã
 -
(
Ã
Ã
- .
cs
Ã
Ã
. 0
,
Ã
Ã
0 1
csStart
Ã
Ã
2 9
,
Ã
Ã
9 :
seq
Ã
Ã
; >
,
Ã
Ã
> ?
start
Ã
Ã
@ E
,
Ã
Ã
E F
length
Ã
Ã
G M
,
Ã
Ã
M N

ignoreCase
Õ
Õ
 
?
Õ
Õ
 0
"AsciiCaseInsensitiveCharComparator
Õ
Õ
 ?
:
Õ
Õ
@ A#
DefaultCharComparator
Õ
Õ
B W
)
Õ
Õ
W X
;
Õ
Õ
X Y
}
Œ
Œ
 	
public
–
–
 
static
–
–
 
int
–
–
 
IndexOfIgnoreCase
–
–
 +
(
–
–
+ ,
ICharSequence
–
–
, 9
str
–
–
: =
,
–
–
= >
ICharSequence
–
–
? L
	searchStr
–
–
M V
,
–
–
V W
int
–
–
X [
startPos
–
–
\ d
)
–
–
d e
{
—
—
 	
if
“
“
 
(
“
“
 
str
“
“
 
==
“
“
 
null
“
“
 
||
“
“
 
	searchStr
“
“
 (
==
“
“
) +
null
“
“
, 0
)
“
“
0 1
{
”
”
 
return
‘
‘
 
IndexNotFound
‘
‘
 $
;
‘
‘
$ %
}
’
’
 
if
◊
◊
 
(
◊
◊
 
startPos
◊
◊
 
<
◊
◊
 
$num
◊
◊
 
)
◊
◊
 
{
ÿ
ÿ
 
startPos
Ÿ
Ÿ
 
=
Ÿ
Ÿ
 
$num
Ÿ
Ÿ
 
;
Ÿ
Ÿ
 
}
⁄
⁄
 
int
€
€
 
searchStrLen
€
€
 
=
€
€
 
	searchStr
€
€
 (
.
€
€
( )
Count
€
€
) .
;
€
€
. /
int
‹
‹
 
endLimit
‹
‹
 
=
‹
‹
 
str
‹
‹
 
.
‹
‹
 
Count
‹
‹
 $
-
‹
‹
% &
searchStrLen
‹
‹
' 3
+
‹
‹
4 5
$num
‹
‹
6 7
;
‹
‹
7 8
if
›
›
 
(
›
›
 
startPos
›
›
 
>
›
›
 
endLimit
›
›
 #
)
›
›
# $
{
ﬁ
ﬁ
 
return
ﬂ
ﬂ
 
IndexNotFound
ﬂ
ﬂ
 $
;
ﬂ
ﬂ
$ %
}
‡
‡
 
if
·
·
 
(
·
·
 
searchStrLen
·
·
 
==
·
·
 
$num
·
·
  !
)
·
·
! "
{
‚
‚
 
return
„
„
 
startPos
„
„
 
;
„
„
  
}
‰
‰
 
for
Â
Â
 
(
Â
Â
 
int
Â
Â
 
i
Â
Â
 
=
Â
Â
 
startPos
Â
Â
 !
;
Â
Â
! "
i
Â
Â
# $
<
Â
Â
% &
endLimit
Â
Â
' /
;
Â
Â
/ 0
i
Â
Â
1 2
++
Â
Â
2 4
)
Â
Â
4 5
{
Ê
Ê
 
if
Á
Á
 
(
Á
Á
 
RegionMatches
Á
Á
 !
(
Á
Á
! "
str
Á
Á
" %
,
Á
Á
% &
true
Á
Á
' +
,
Á
Á
+ ,
i
Á
Á
- .
,
Á
Á
. /
	searchStr
Á
Á
0 9
,
Á
Á
9 :
$num
Á
Á
; <
,
Á
Á
< =
searchStrLen
Á
Á
> J
)
Á
Á
J K
)
Á
Á
K L
{
Ë
Ë
 
return
È
È
 
i
È
È
 
;
È
È
 
}
Í
Í
 
}
Î
Î
 
return
Ì
Ì
 
IndexNotFound
Ì
Ì
  
;
Ì
Ì
  !
}
Ó
Ó
 	
public


 
static


 
int


 $
IndexOfIgnoreCaseAscii


 0
(


0 1
ICharSequence


1 >
str


? B
,


B C
ICharSequence


D Q
	searchStr


R [
,


[ \
int


] `
startPos


a i
)


i j
{
Ò
Ò
 	
if
Ú
Ú
 
(
Ú
Ú
 
str
Ú
Ú
 
==
Ú
Ú
 
null
Ú
Ú
 
||
Ú
Ú
 
	searchStr
Ú
Ú
 (
==
Ú
Ú
) +
null
Ú
Ú
, 0
)
Ú
Ú
0 1
{
Û
Û
 
return
Ù
Ù
 
IndexNotFound
Ù
Ù
 $
;
Ù
Ù
$ %
}
ı
ı
 
if
˜
˜
 
(
˜
˜
 
startPos
˜
˜
 
<
˜
˜
 
$num
˜
˜
 
)
˜
˜
 
{
¯
¯
 
startPos
˘
˘
 
=
˘
˘
 
$num
˘
˘
 
;
˘
˘
 
}
˙
˙
 
int
˚
˚
 
searchStrLen
˚
˚
 
=
˚
˚
 
	searchStr
˚
˚
 (
.
˚
˚
( )
Count
˚
˚
) .
;
˚
˚
. /
int
¸
¸
 
endLimit
¸
¸
 
=
¸
¸
 
str
¸
¸
 
.
¸
¸
 
Count
¸
¸
 $
-
¸
¸
% &
searchStrLen
¸
¸
' 3
+
¸
¸
4 5
$num
¸
¸
6 7
;
¸
¸
7 8
if
˝
˝
 
(
˝
˝
 
startPos
˝
˝
 
>
˝
˝
 
endLimit
˝
˝
 #
)
˝
˝
# $
{
˛
˛
 
return
ˇ
ˇ
 
IndexNotFound
ˇ
ˇ
 $
;
ˇ
ˇ
$ %
}
ÄÄ 
if
ÅÅ 
(
ÅÅ 
searchStrLen
ÅÅ 
==
ÅÅ 
$num
ÅÅ  !
)
ÅÅ! "
{
ÇÇ 
return
ÉÉ 
startPos
ÉÉ 
;
ÉÉ  
}
ÑÑ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
startPos
ÖÖ !
;
ÖÖ! "
i
ÖÖ# $
<
ÖÖ% &
endLimit
ÖÖ' /
;
ÖÖ/ 0
i
ÖÖ1 2
++
ÖÖ2 4
)
ÖÖ4 5
{
ÜÜ 
if
áá 
(
áá  
RegionMatchesAscii
áá &
(
áá& '
str
áá' *
,
áá* +
true
áá, 0
,
áá0 1
i
áá2 3
,
áá3 4
	searchStr
áá5 >
,
áá> ?
$num
áá@ A
,
ááA B
searchStrLen
ááC O
)
ááO P
)
ááP Q
{
àà 
return
ââ 
i
ââ 
;
ââ 
}
ää 
}
ãã 
return
çç 
IndexNotFound
çç  
;
çç  !
}
éé 	
public
êê 
static
êê 
int
êê 
IndexOf
êê !
(
êê! "
ICharSequence
êê" /
cs
êê0 2
,
êê2 3
char
êê4 8

searchChar
êê9 C
,
êêC D
int
êêE H
start
êêI N
)
êêN O
{
ëë 	
if
íí 
(
íí 
cs
íí 
is
íí  
StringCharSequence
íí ( 
stringCharSequence
íí) ;
)
íí; <
{
ìì 
return
îî  
stringCharSequence
îî )
.
îî) *
IndexOf
îî* 1
(
îî1 2

searchChar
îî2 <
,
îî< =
start
îî> C
)
îîC D
;
îîD E
}
ïï 
else
ññ 
if
ññ 
(
ññ 
cs
ññ 
is
ññ 
AsciiString
ññ &
asciiString
ññ' 2
)
ññ2 3
{
óó 
return
òò 
asciiString
òò "
.
òò" #
IndexOf
òò# *
(
òò* +

searchChar
òò+ 5
,
òò5 6
start
òò7 <
)
òò< =
;
òò= >
}
ôô 
if
öö 
(
öö 
cs
öö 
==
öö 
null
öö 
)
öö 
{
õõ 
return
úú 
IndexNotFound
úú $
;
úú$ %
}
ùù 
int
ûû 
sz
ûû 
=
ûû 
cs
ûû 
.
ûû 
Count
ûû 
;
ûû 
if
üü 
(
üü 
start
üü 
<
üü 
$num
üü 
)
üü 
{
†† 
start
°° 
=
°° 
$num
°° 
;
°° 
}
¢¢ 
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
start
££ 
;
££ 
i
££  !
<
££" #
sz
££$ &
;
££& '
i
££( )
++
££) +
)
££+ ,
{
§§ 
if
•• 
(
•• 
cs
•• 
[
•• 
i
•• 
]
•• 
==
•• 

searchChar
•• '
)
••' (
{
¶¶ 
return
ßß 
i
ßß 
;
ßß 
}
®® 
}
©© 
return
´´ 
IndexNotFound
´´  
;
´´  !
}
¨¨ 	
[
ÆÆ 	

MethodImpl
ÆÆ	 
(
ÆÆ 
MethodImplOptions
ÆÆ %
.
ÆÆ% & 
AggressiveInlining
ÆÆ& 8
)
ÆÆ8 9
]
ÆÆ9 :
static
ØØ 
bool
ØØ 
EqualsIgnoreCase
ØØ $
(
ØØ$ %
byte
ØØ% )
a
ØØ* +
,
ØØ+ ,
byte
ØØ- 1
b
ØØ2 3
)
ØØ3 4
=>
ØØ5 7
a
ØØ8 9
==
ØØ: <
b
ØØ= >
||
ØØ? A
ToLowerCase
ØØB M
(
ØØM N
a
ØØN O
)
ØØO P
==
ØØQ S
ToLowerCase
ØØT _
(
ØØ_ `
b
ØØ` a
)
ØØa b
;
ØØb c
[
±± 	

MethodImpl
±±	 
(
±± 
MethodImplOptions
±± %
.
±±% & 
AggressiveInlining
±±& 8
)
±±8 9
]
±±9 :
static
≤≤ 
bool
≤≤ 
EqualsIgnoreCase
≤≤ $
(
≤≤$ %
char
≤≤% )
a
≤≤* +
,
≤≤+ ,
char
≤≤- 1
b
≤≤2 3
)
≤≤3 4
=>
≤≤5 7
a
≤≤8 9
==
≤≤: <
b
≤≤= >
||
≤≤? A
ToLowerCase
≤≤B M
(
≤≤M N
a
≤≤N O
)
≤≤O P
==
≤≤Q S
ToLowerCase
≤≤T _
(
≤≤_ `
b
≤≤` a
)
≤≤a b
;
≤≤b c
[
¥¥ 	

MethodImpl
¥¥	 
(
¥¥ 
MethodImplOptions
¥¥ %
.
¥¥% & 
AggressiveInlining
¥¥& 8
)
¥¥8 9
]
¥¥9 :
static
µµ 
byte
µµ 
ToLowerCase
µµ 
(
µµ  
byte
µµ  $
b
µµ% &
)
µµ& '
=>
µµ( *
IsUpperCase
µµ+ 6
(
µµ6 7
b
µµ7 8
)
µµ8 9
?
µµ: ;
(
µµ< =
byte
µµ= A
)
µµA B
(
µµB C
b
µµC D
+
µµE F
$num
µµG I
)
µµI J
:
µµK L
b
µµM N
;
µµN O
[
∑∑ 	

MethodImpl
∑∑	 
(
∑∑ 
MethodImplOptions
∑∑ %
.
∑∑% & 
AggressiveInlining
∑∑& 8
)
∑∑8 9
]
∑∑9 :
static
∏∏ 
char
∏∏ 
ToLowerCase
∏∏ 
(
∏∏  
char
∏∏  $
c
∏∏% &
)
∏∏& '
=>
∏∏( *
IsUpperCase
∏∏+ 6
(
∏∏6 7
c
∏∏7 8
)
∏∏8 9
?
∏∏: ;
(
∏∏< =
char
∏∏= A
)
∏∏A B
(
∏∏B C
c
∏∏C D
+
∏∏E F
$num
∏∏G I
)
∏∏I J
:
∏∏K L
c
∏∏M N
;
∏∏N O
[
∫∫ 	

MethodImpl
∫∫	 
(
∫∫ 
MethodImplOptions
∫∫ %
.
∫∫% & 
AggressiveInlining
∫∫& 8
)
∫∫8 9
]
∫∫9 :
static
ªª 
byte
ªª 
ToUpperCase
ªª 
(
ªª  
byte
ªª  $
b
ªª% &
)
ªª& '
=>
ªª( *
IsLowerCase
ªª+ 6
(
ªª6 7
b
ªª7 8
)
ªª8 9
?
ªª: ;
(
ªª< =
byte
ªª= A
)
ªªA B
(
ªªB C
b
ªªC D
-
ªªE F
$num
ªªG I
)
ªªI J
:
ªªK L
b
ªªM N
;
ªªN O
[
ΩΩ 	

MethodImpl
ΩΩ	 
(
ΩΩ 
MethodImplOptions
ΩΩ %
.
ΩΩ% & 
AggressiveInlining
ΩΩ& 8
)
ΩΩ8 9
]
ΩΩ9 :
static
ææ 
bool
ææ 
IsLowerCase
ææ 
(
ææ  
byte
ææ  $
value
ææ% *
)
ææ* +
=>
ææ, .
value
ææ/ 4
>=
ææ5 7
$char
ææ8 ;
&&
ææ< >
value
ææ? D
<=
ææE G
$char
ææH K
;
ææK L
[
¿¿ 	

MethodImpl
¿¿	 
(
¿¿ 
MethodImplOptions
¿¿ %
.
¿¿% & 
AggressiveInlining
¿¿& 8
)
¿¿8 9
]
¿¿9 :
public
¡¡ 
static
¡¡ 
bool
¡¡ 
IsUpperCase
¡¡ &
(
¡¡& '
byte
¡¡' +
value
¡¡, 1
)
¡¡1 2
=>
¡¡3 5
value
¡¡6 ;
>=
¡¡< >
$char
¡¡? B
&&
¡¡C E
value
¡¡F K
<=
¡¡L N
$char
¡¡O R
;
¡¡R S
[
√√ 	

MethodImpl
√√	 
(
√√ 
MethodImplOptions
√√ %
.
√√% & 
AggressiveInlining
√√& 8
)
√√8 9
]
√√9 :
public
ƒƒ 
static
ƒƒ 
bool
ƒƒ 
IsUpperCase
ƒƒ &
(
ƒƒ& '
char
ƒƒ' +
value
ƒƒ, 1
)
ƒƒ1 2
=>
ƒƒ3 5
value
ƒƒ6 ;
>=
ƒƒ< >
$char
ƒƒ? B
&&
ƒƒC E
value
ƒƒF K
<=
ƒƒL N
$char
ƒƒO R
;
ƒƒR S
[
∆∆ 	

MethodImpl
∆∆	 
(
∆∆ 
MethodImplOptions
∆∆ %
.
∆∆% & 
AggressiveInlining
∆∆& 8
)
∆∆8 9
]
∆∆9 :
public
«« 
static
«« 
byte
«« 

CharToByte
«« %
(
««% &
char
««& *
c
««+ ,
)
««, -
=>
««. 0
c
««1 2
>
««3 4
MaxCharValue
««5 A
?
««B C
Replacement
««D O
:
««P Q
	unchecked
««R [
(
««[ \
(
««\ ]
byte
««] a
)
««a b
c
««b c
)
««c d
;
««d e
[
…… 	

MethodImpl
……	 
(
…… 
MethodImplOptions
…… %
.
……% & 
AggressiveInlining
……& 8
)
……8 9
]
……9 :
public
   
static
   
char
   

ByteToChar
   %
(
  % &
byte
  & *
b
  + ,
)
  , -
=>
  . 0
(
  1 2
char
  2 6
)
  6 7
(
  7 8
b
  8 9
)
  9 :
;
  : ;
public
ÃÃ 
static
ÃÃ 
explicit
ÃÃ 
operator
ÃÃ '
string
ÃÃ( .
(
ÃÃ. /
AsciiString
ÃÃ/ :
value
ÃÃ; @
)
ÃÃ@ A
=>
ÃÃB D
value
ÃÃE J
?
ÃÃJ K
.
ÃÃK L
ToString
ÃÃL T
(
ÃÃT U
)
ÃÃU V
??
ÃÃW Y
string
ÃÃZ `
.
ÃÃ` a
Empty
ÃÃa f
;
ÃÃf g
public
ŒŒ 
static
ŒŒ 
explicit
ŒŒ 
operator
ŒŒ '
AsciiString
ŒŒ( 3
(
ŒŒ3 4
string
ŒŒ4 :
value
ŒŒ; @
)
ŒŒ@ A
=>
ŒŒB D
value
ŒŒE J
!=
ŒŒK M
null
ŒŒN R
?
ŒŒS T
new
ŒŒU X
AsciiString
ŒŒY d
(
ŒŒd e
value
ŒŒe j
)
ŒŒj k
:
ŒŒl m
Empty
ŒŒn s
;
ŒŒs t
static
–– 
unsafe
–– 
void
–– 
GetBytes
–– #
(
––# $
char
––$ (
*
––( )
chars
––* /
,
––/ 0
int
––1 4
length
––5 ;
,
––; <
byte
––= A
*
––A B
bytes
––C H
)
––H I
{
—— 	
char
““ 
*
““ 
charEnd
““ 
=
““ 
chars
““ !
+
““" #
length
““$ *
;
““* +
while
”” 
(
”” 
chars
”” 
<
”” 
charEnd
”” "
)
””" #
{
‘‘ 
char
’’ 
ch
’’ 
=
’’ 
*
’’ 
(
’’ 
chars
’’ !
++
’’! #
)
’’# $
;
’’$ %
if
◊◊ 
(
◊◊ 
ch
◊◊ 
>
◊◊ 
MaxCharValue
◊◊ %
)
◊◊% &
{
ÿÿ 
*
ŸŸ 
(
ŸŸ 
bytes
ŸŸ 
++
ŸŸ 
)
ŸŸ 
=
ŸŸ  
Replacement
ŸŸ! ,
;
ŸŸ, -
}
⁄⁄ 
else
€€ 
{
‹‹ 
*
›› 
(
›› 
bytes
›› 
++
›› 
)
›› 
=
››  
	unchecked
››! *
(
››* +
(
››+ ,
byte
››, 0
)
››0 1
ch
››1 3
)
››3 4
;
››4 5
}
ﬁﬁ 
}
ﬂﬂ 
}
‡‡ 	
public
‚‚ 
int
‚‚ 
HashCode
‚‚ 
(
‚‚ 
bool
‚‚  

ignoreCase
‚‚! +
)
‚‚+ ,
=>
‚‚- /
!
‚‚1 2

ignoreCase
‚‚2 <
?
‚‚= >
this
‚‚? C
.
‚‚C D
GetHashCode
‚‚D O
(
‚‚O P
)
‚‚P Q
:
‚‚R S#
CaseInsensitiveHasher
‚‚T i
.
‚‚i j
GetHashCode
‚‚j u
(
‚‚u v
this
‚‚v z
)
‚‚z {
;
‚‚{ |
public
ÏÏ 
int
ÏÏ 
	CompareTo
ÏÏ 
(
ÏÏ 
AsciiString
ÏÏ (
other
ÏÏ) .
)
ÏÏ. /
{
ÌÌ 	
if
ÓÓ 
(
ÓÓ 
ReferenceEquals
ÓÓ 
(
ÓÓ  
this
ÓÓ  $
,
ÓÓ$ %
other
ÓÓ& +
)
ÓÓ+ ,
)
ÓÓ, -
{
ÔÔ 
return
 
$num
 
;
 
}
ÒÒ 
int
ÛÛ 
length1
ÛÛ 
=
ÛÛ 
this
ÛÛ 
.
ÛÛ 
length
ÛÛ %
;
ÛÛ% &
int
ÙÙ 
length2
ÙÙ 
=
ÙÙ 
other
ÙÙ 
.
ÙÙ  
length
ÙÙ  &
;
ÙÙ& '
int
ıı 
	minLength
ıı 
=
ıı 
Math
ıı  
.
ıı  !
Min
ıı! $
(
ıı$ %
length1
ıı% ,
,
ıı, -
length2
ıı. 5
)
ıı5 6
;
ıı6 7
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
j
ˆˆ 
=
ˆˆ 
this
ˆˆ  $
.
ˆˆ$ %
offset
ˆˆ% +
;
ˆˆ+ ,
i
ˆˆ- .
<
ˆˆ/ 0
	minLength
ˆˆ1 :
;
ˆˆ: ;
i
ˆˆ< =
++
ˆˆ= ?
,
ˆˆ? @
j
ˆˆA B
++
ˆˆB D
)
ˆˆD E
{
˜˜ 
int
¯¯ 
result
¯¯ 
=
¯¯ 

ByteToChar
¯¯ '
(
¯¯' (
this
¯¯( ,
.
¯¯, -
value
¯¯- 2
[
¯¯2 3
j
¯¯3 4
]
¯¯4 5
)
¯¯5 6
-
¯¯7 8
other
¯¯9 >
[
¯¯> ?
i
¯¯? @
]
¯¯@ A
;
¯¯A B
if
˘˘ 
(
˘˘ 
result
˘˘ 
!=
˘˘ 
$num
˘˘ 
)
˘˘  
{
˙˙ 
return
˚˚ 
result
˚˚ !
;
˚˚! "
}
¸¸ 
}
˝˝ 
return
ˇˇ 
length1
ˇˇ 
-
ˇˇ 
length2
ˇˇ $
;
ˇˇ$ %
}
ÄÄ 	
public
ÇÇ 
int
ÇÇ 
	CompareTo
ÇÇ 
(
ÇÇ 
object
ÇÇ #
obj
ÇÇ$ '
)
ÇÇ' (
=>
ÇÇ) +
this
ÇÇ, 0
.
ÇÇ0 1
	CompareTo
ÇÇ1 :
(
ÇÇ: ;
obj
ÇÇ; >
as
ÇÇ? A
AsciiString
ÇÇB M
)
ÇÇM N
;
ÇÇN O
public
ÑÑ 
IEnumerator
ÑÑ 
<
ÑÑ 
char
ÑÑ 
>
ÑÑ  
GetEnumerator
ÑÑ! .
(
ÑÑ. /
)
ÑÑ/ 0
=>
ÑÑ1 3
new
ÑÑ4 7$
CharSequenceEnumerator
ÑÑ8 N
(
ÑÑN O
this
ÑÑO S
)
ÑÑS T
;
ÑÑT U
IEnumerator
ÜÜ 
IEnumerable
ÜÜ 
.
ÜÜ  
GetEnumerator
ÜÜ  -
(
ÜÜ- .
)
ÜÜ. /
=>
ÜÜ0 2
this
ÜÜ3 7
.
ÜÜ7 8
GetEnumerator
ÜÜ8 E
(
ÜÜE F
)
ÜÜF G
;
ÜÜG H
static
àà 
void
àà 1
#ThrowIndexOutOfRangeException_Start
àà 7
(
àà7 8
int
àà8 ;
start
àà< A
,
ààA B
int
ààC F
length
ààG M
,
ààM N
int
ààO R
count
ààS X
)
ààX Y
{
ââ 	
throw
ää )
GetIndexOutOfRangeException
ää -
(
ää- .
)
ää. /
;
ää/ 0&
IndexOutOfRangeException
åå $)
GetIndexOutOfRangeException
åå% @
(
åå@ A
)
ååA B
{
çç 
return
éé 
new
éé &
IndexOutOfRangeException
éé 3
(
éé3 4
string
éé4 :
.
éé: ;
Format
éé; A
(
ééA B
$strééB â
,ééâ ä
startééã ê
,ééê ë
lengthééí ò
,ééò ô
countééö ü
)ééü †
)éé† °
;éé° ¢
}
èè 
}
êê 	
static
íí 
void
íí 4
&ThrowIndexOutOfRangeException_StartEnd
íí :
(
íí: ;
int
íí; >
start
íí? D
,
ííD E
int
ííF I
end
ííJ M
,
ííM N
int
ííO R
length
ííS Y
)
ííY Z
{
ìì 	
throw
îî )
GetIndexOutOfRangeException
îî -
(
îî- .
)
îî. /
;
îî/ 0&
IndexOutOfRangeException
ññ $)
GetIndexOutOfRangeException
ññ% @
(
ññ@ A
)
ññA B
{
óó 
return
òò 
new
òò &
IndexOutOfRangeException
òò 3
(
òò3 4
string
òò4 :
.
òò: ;
Format
òò; A
(
òòA B
$str
òòB y
,
òòy z
startòò{ Ä
,òòÄ Å
endòòÇ Ö
,òòÖ Ü
lengthòòá ç
)òòç é
)òòé è
;òòè ê
}
ôô 
}
öö 	
static
úú 
void
úú 4
&ThrowIndexOutOfRangeException_SrcIndex
úú :
(
úú: ;
int
úú; >
start
úú? D
,
úúD E
int
úúF I
count
úúJ O
,
úúO P
int
úúQ T
length
úúU [
)
úú[ \
{
ùù 	
throw
ûû )
GetIndexOutOfRangeException
ûû -
(
ûû- .
)
ûû. /
;
ûû/ 0&
IndexOutOfRangeException
†† $)
GetIndexOutOfRangeException
††% @
(
††@ A
)
††A B
{
°° 
return
¢¢ 
new
¢¢ &
IndexOutOfRangeException
¢¢ 3
(
¢¢3 4
string
¢¢4 :
.
¢¢: ;
Format
¢¢; A
(
¢¢A B
$str¢¢B Ñ
,¢¢Ñ Ö
start¢¢Ü ã
,¢¢ã å
count¢¢ç í
,¢¢í ì
length¢¢î ö
)¢¢ö õ
)¢¢õ ú
;¢¢ú ù
}
££ 
}
§§ 	
static
¶¶ 
void
¶¶ 1
#ThrowIndexOutOfRangeException_Index
¶¶ 7
(
¶¶7 8
int
¶¶8 ;
index
¶¶< A
,
¶¶A B
int
¶¶C F
length
¶¶G M
,
¶¶M N
int
¶¶O R
count
¶¶S X
)
¶¶X Y
{
ßß 	
throw
®® )
GetIndexOutOfRangeException
®® -
(
®®- .
)
®®. /
;
®®/ 0&
IndexOutOfRangeException
™™ $)
GetIndexOutOfRangeException
™™% @
(
™™@ A
)
™™A B
{
´´ 
return
¨¨ 
new
¨¨ &
IndexOutOfRangeException
¨¨ 3
(
¨¨3 4
string
¨¨4 :
.
¨¨: ;
Format
¨¨; A
(
¨¨A B
$str¨¨B Ç
,¨¨Ç É
index¨¨Ñ â
,¨¨â ä
length¨¨ã ë
,¨¨ë í
count¨¨ì ò
)¨¨ò ô
)¨¨ô ö
;¨¨ö õ
}
≠≠ 
}
ÆÆ 	
static
∞∞ 
void
∞∞ 1
#ThrowIndexOutOfRangeException_Index
∞∞ 7
(
∞∞7 8
int
∞∞8 ;
index
∞∞< A
,
∞∞A B
int
∞∞C F
length
∞∞G M
)
∞∞M N
{
±± 	
throw
≤≤ )
GetIndexOutOfRangeException
≤≤ -
(
≤≤- .
)
≤≤. /
;
≤≤/ 0&
IndexOutOfRangeException
¥¥ $)
GetIndexOutOfRangeException
¥¥% @
(
¥¥@ A
)
¥¥A B
{
µµ 
return
∂∂ 
new
∂∂ &
IndexOutOfRangeException
∂∂ 3
(
∂∂3 4
string
∂∂4 :
.
∂∂: ;
Format
∂∂; A
(
∂∂A B
$str
∂∂B k
,
∂∂k l
index
∂∂m r
,
∂∂r s
length
∂∂t z
)
∂∂z {
)
∂∂{ |
;
∂∂| }
}
∑∑ 
}
∏∏ 	
	interface
∫∫ %
ICharEqualityComparator
∫∫ )
{
ªª 	
bool
ºº 

CharEquals
ºº 
(
ºº 
char
ºº  
a
ºº! "
,
ºº" #
char
ºº$ (
b
ºº) *
)
ºº* +
;
ºº+ ,
}
ΩΩ 	
sealed
øø 
class
øø +
DefaultCharEqualityComparator
øø 2
:
øø3 4%
ICharEqualityComparator
øø5 L
{
¿¿ 	
public
¡¡ 
bool
¡¡ 

CharEquals
¡¡ "
(
¡¡" #
char
¡¡# '
a
¡¡( )
,
¡¡) *
char
¡¡+ /
b
¡¡0 1
)
¡¡1 2
=>
¡¡3 5
a
¡¡6 7
==
¡¡8 :
b
¡¡; <
;
¡¡< =
}
¬¬ 	
sealed
ƒƒ 
class
ƒƒ :
,GeneralCaseInsensitiveCharEqualityComparator
ƒƒ A
:
ƒƒB C%
ICharEqualityComparator
ƒƒD [
{
≈≈ 	
public
∆∆ 
bool
∆∆ 

CharEquals
∆∆ "
(
∆∆" #
char
∆∆# '
a
∆∆( )
,
∆∆) *
char
∆∆+ /
b
∆∆0 1
)
∆∆1 2
=>
∆∆3 5
char
«« 
.
«« 
ToUpper
«« 
(
«« 
a
«« 
)
«« 
==
««  "
char
««# '
.
««' (
ToUpper
««( /
(
««/ 0
b
««0 1
)
««1 2
||
««3 5
char
««6 :
.
««: ;
ToLower
««; B
(
««B C
a
««C D
)
««D E
==
««F H
char
««I M
.
««M N
ToLower
««N U
(
««U V
b
««V W
)
««W X
;
««X Y
}
»» 	
sealed
   
class
   8
*AsciiCaseInsensitiveCharEqualityComparator
   ?
:
  @ A%
ICharEqualityComparator
  B Y
{
ÀÀ 	
public
ÃÃ 
bool
ÃÃ 

CharEquals
ÃÃ "
(
ÃÃ" #
char
ÃÃ# '
a
ÃÃ( )
,
ÃÃ) *
char
ÃÃ+ /
b
ÃÃ0 1
)
ÃÃ1 2
=>
ÃÃ3 5
EqualsIgnoreCase
ÃÃ6 F
(
ÃÃF G
a
ÃÃG H
,
ÃÃH I
b
ÃÃJ K
)
ÃÃK L
;
ÃÃL M
}
ÕÕ 	
}
ŒŒ 
}œœ ˛
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\AtomicReference.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class 
AtomicReference '
<' (
T( )
>) *
where 
T 
: 
class 
{ 
T 	
atomicValue
 
; 
public 
AtomicReference 
( 
T  
originalValue! .
). /
{ 	
this 
. 
atomicValue 
= 
originalValue ,
;, -
} 	
public 
AtomicReference 
( 
)  
{ 	
this 
. 
atomicValue 
= 
default &
(& '
T' (
)( )
;) *
} 	
public## 
T## 
Value## 
{$$ 	
get%% 
=>%% 
Volatile%% 
.%% 
Read%%  
(%%  !
ref%%! $
this%%% )
.%%) *
atomicValue%%* 5
)%%5 6
;%%6 7
set&& 
=>&& 
Volatile&& 
.&& 
Write&& !
(&&! "
ref&&" %
this&&& *
.&&* +
atomicValue&&+ 6
,&&6 7
value&&8 =
)&&= >
;&&> ?
}'' 	
public.. 
bool.. 
CompareAndSet.. !
(..! "
T.." #
expected..$ ,
,.., -
T... /
newValue..0 8
)..8 9
=>..: <
Interlocked..= H
...H I
CompareExchange..I X
(..X Y
ref..Y \
this..] a
...a b
atomicValue..b m
,..m n
newValue..o w
,..w x
expected	..y Å
)
..Å Ç
==
..É Ö
expected
..Ü é
;
..é è
public66 
static66 
implicit66 
operator66 '
T66( )
(66) *
AtomicReference66* 9
<669 :
T66: ;
>66; <
aRef66= A
)66A B
=>66C E
aRef66F J
.66J K
Value66K P
;66P Q
public>> 
static>> 
implicit>> 
operator>> '
AtomicReference>>( 7
<>>7 8
T>>8 9
>>>9 :
(>>: ;
T>>; <
newValue>>= E
)>>E F
=>>>G I
new>>J M
AtomicReference>>N ]
<>>] ^
T>>^ _
>>>_ `
(>>` a
newValue>>a i
)>>i j
;>>j k
}AA 
}BB •
hC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\AttributeKey.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
internal 
static 
class 
AttributeKey &
{		 
public 
static 
readonly 
ConstantPool +
Pool, 0
=1 2
new3 6!
AttributeConstantPool7 L
(L M
)M N
;N O
sealed 
class !
AttributeConstantPool *
:+ ,
ConstantPool- 9
{ 	
	protected 
override 
	IConstant (
NewConstant) 4
<4 5
TValue5 ;
>; <
(< =
int= @
idA C
,C D
stringE K
nameL P
)P Q
=>R T
newU X
AttributeKeyY e
<e f
TValuef l
>l m
(m n
idn p
,p q
namer v
)v w
;w x
} 	
;	 

} 
public 

sealed 
class 
AttributeKey $
<$ %
T% &
>& '
:( )
AbstractConstant* :
<: ;
AttributeKey; G
<G H
TH I
>I J
>J K
{ 
public 
static 
readonly 
ConstantPool +
Pool, 0
=1 2
AttributeKey3 ?
.? @
Pool@ D
;D E
public   
static   
AttributeKey   "
<  " #
T  # $
>  $ %
ValueOf  & -
(  - .
string  . 4
name  5 9
)  9 :
=>  ; =
(  > ?
AttributeKey  ? K
<  K L
T  L M
>  M N
)  N O
Pool  O S
.  S T
ValueOf  T [
<  [ \
T  \ ]
>  ] ^
(  ^ _
name  _ c
)  c d
;  d e
public## 
static## 
bool## 
Exists## !
(##! "
string##" (
name##) -
)##- .
=>##/ 1
Pool##2 6
.##6 7
Exists##7 =
(##= >
name##> B
)##B C
;##C D
public)) 
static)) 
AttributeKey)) "
<))" #
T))# $
>))$ %
NewInstance))& 1
())1 2
string))2 8
name))9 =
)))= >
=>))? A
())B C
AttributeKey))C O
<))O P
T))P Q
>))Q R
)))R S
Pool))S W
.))W X
NewInstance))X c
<))c d
T))d e
>))e f
())f g
name))g k
)))k l
;))l m
public++ 
static++ 
AttributeKey++ "
<++" #
T++# $
>++$ %
ValueOf++& -
(++- .
Type++. 2
firstNameComponent++3 E
,++E F
string++G M
secondNameComponent++N a
)++a b
=>,, 
(,, 
AttributeKey,, 
<,, 
T,, 
>,, 
),,  
Pool,,  $
.,,$ %
ValueOf,,% ,
<,,, -
T,,- .
>,,. /
(,,/ 0
firstNameComponent,,0 B
,,,B C
secondNameComponent,,D W
),,W X
;,,X Y
internal.. 
AttributeKey.. 
(.. 
int.. !
id.." $
,..$ %
string..& ,
name..- 1
)..1 2
:// 
base// 
(// 
id// 
,// 
name// 
)// 
{00 	
}11 	
}22 
}33 „
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\BitOps.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
BitOps 
{		 
[

 	

MethodImpl

	 
(

 
MethodImplOptions

 %
.

% &
AggressiveInlining

& 8
)

8 9
]

9 :
public 
static 
int 
RightUShift %
(% &
this& *
int+ .
value/ 4
,4 5
int6 9
bits: >
)> ?
=>@ B
	uncheckedC L
(L M
(M N
intN Q
)Q R
(R S
(S T
uintT X
)X Y
valueY ^
>>_ a
bitsb f
)f g
)g h
;h i
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
public 
static 
long 
RightUShift &
(& '
this' +
long, 0
value1 6
,6 7
int8 ;
bits< @
)@ A
=>B D
	uncheckedE N
(N O
(O P
longP T
)T U
(U V
(V W
ulongW \
)\ ]
value] b
>>c e
bitsf j
)j k
)k l
;l m
} 
} å9
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ByteProcessor.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 
IByteProcessor #
{ 
bool 
Process 
( 
byte 
value 
)  
;  !
} 
public 

sealed 
class 
IndexOfProcessor (
:) *
IByteProcessor+ 9
{ 
readonly 
byte 

byteToFind  
;  !
public 
IndexOfProcessor 
(  
byte  $

byteToFind% /
)/ 0
{ 	
this 
. 

byteToFind 
= 

byteToFind (
;( )
} 	
public 
bool 
Process 
( 
byte  
value! &
)& '
=>( *
value+ 0
!=1 3
this4 8
.8 9

byteToFind9 C
;C D
} 
public 

sealed 
class 
IndexNotOfProcessor +
:, -
IByteProcessor. <
{   
readonly!! 
byte!! 
byteToNotFind!! #
;!!# $
public## 
IndexNotOfProcessor## "
(##" #
byte### '
byteToNotFind##( 5
)##5 6
{$$ 	
this%% 
.%% 
byteToNotFind%% 
=%%  
byteToNotFind%%! .
;%%. /
}&& 	
public(( 
bool(( 
Process(( 
((( 
byte((  
value((! &
)((& '
=>((( *
value((+ 0
==((1 3
this((4 8
.((8 9
byteToNotFind((9 F
;((F G
})) 
public++ 

sealed++ 
class++ 
ByteProcessor++ %
:++& '
IByteProcessor++( 6
{,, 
readonly-- 
Func-- 
<-- 
byte-- 
,-- 
bool--  
>--  !
customHandler--" /
;--/ 0
public// 
ByteProcessor// 
(// 
Func// !
<//! "
byte//" &
,//& '
bool//( ,
>//, -
customHandler//. ;
)//; <
{00 	
Contract11 
.11 
Assert11 
(11 
customHandler11 )
!=11* ,
null11- 1
,111 2
$str113 [
)11[ \
;11\ ]
this22 
.22 
customHandler22 
=22  
customHandler22! .
;22. /
}33 	
public55 
bool55 
Process55 
(55 
byte55  
value55! &
)55& '
=>55( *
this55+ /
.55/ 0
customHandler550 =
(55= >
value55> C
)55C D
;55D E
public;; 
static;; 
IByteProcessor;; $
FindNul;;% ,
=;;- .
new;;/ 2
IndexOfProcessor;;3 C
(;;C D
$num;;D E
);;E F
;;;F G
public@@ 
static@@ 
IByteProcessor@@ $

FindNonNul@@% /
=@@0 1
new@@2 5
IndexNotOfProcessor@@6 I
(@@I J
$num@@J K
)@@K L
;@@L M
publicEE 
staticEE 
IByteProcessorEE $
FindCREE% +
=EE, -
newEE. 1
IndexOfProcessorEE2 B
(EEB C
CarriageReturnEEC Q
)EEQ R
;EER S
publicJJ 
staticJJ 
IByteProcessorJJ $
	FindNonCRJJ% .
=JJ/ 0
newJJ1 4
IndexNotOfProcessorJJ5 H
(JJH I
CarriageReturnJJI W
)JJW X
;JJX Y
publicOO 
staticOO 
IByteProcessorOO $
FindLFOO% +
=OO, -
newOO. 1
IndexOfProcessorOO2 B
(OOB C
LineFeedOOC K
)OOK L
;OOL M
publicTT 
staticTT 
IByteProcessorTT $
	FindNonLFTT% .
=TT/ 0
newTT1 4
IndexNotOfProcessorTT5 H
(TTH I
LineFeedTTI Q
)TTQ R
;TTR S
publicYY 
staticYY 
IByteProcessorYY $
FindSemicolonYY% 2
=YY3 4
newYY5 8
IndexOfProcessorYY9 I
(YYI J
(YYJ K
byteYYK O
)YYO P
$charYYP S
)YYS T
;YYT U
public^^ 
static^^ 
IByteProcessor^^ $
	FindComma^^% .
=^^/ 0
new^^1 4
IndexOfProcessor^^5 E
(^^E F
(^^F G
byte^^G K
)^^K L
$char^^L O
)^^O P
;^^P Q
publiccc 
staticcc 
IByteProcessorcc $
FindAsciiSpacecc% 3
=cc4 5
newcc6 9
IndexOfProcessorcc: J
(ccJ K
SpaceccK P
)ccP Q
;ccQ R
publichh 
statichh 
IByteProcessorhh $
FindCrlfhh% -
=hh. /
newhh0 3
ByteProcessorhh4 A
(hhA B
newhhB E
FunchhF J
<hhJ K
bytehhK O
,hhO P
boolhhQ U
>hhU V
(hhV W
valuehhW \
=>hh] _
valuehh` e
!=hhf h
CarriageReturnhhi w
&&hhx z
value	hh{ Ä
!=
hhÅ É
LineFeed
hhÑ å
)
hhå ç
)
hhç é
;
hhé è
publicmm 
staticmm 
IByteProcessormm $
FindNonCrlfmm% 0
=mm1 2
newmm3 6
ByteProcessormm7 D
(mmD E
newmmE H
FuncmmI M
<mmM N
bytemmN R
,mmR S
boolmmT X
>mmX Y
(mmY Z
valuemmZ _
=>mm` b
valuemmc h
==mmi k
CarriageReturnmml z
||mm{ }
value	mm~ É
==
mmÑ Ü
LineFeed
mmá è
)
mmè ê
)
mmê ë
;
mmë í
publicrr 
staticrr 
IByteProcessorrr $ 
FindLinearWhitespacerr% 9
=rr: ;
newrr< ?
ByteProcessorrr@ M
(rrM N
newrrN Q
FuncrrR V
<rrV W
byterrW [
,rr[ \
boolrr] a
>rra b
(rrb c
valuerrc h
=>rri k
valuerrl q
!=rrr t
Spacerru z
&&rr{ }
value	rr~ É
!=
rrÑ Ü
HTab
rrá ã
)
rrã å
)
rrå ç
;
rrç é
publicww 
staticww 
IByteProcessorww $#
FindNonLinearWhitespaceww% <
=ww= >
newww? B
ByteProcessorwwC P
(wwP Q
newwwQ T
FuncwwU Y
<wwY Z
bytewwZ ^
,ww^ _
boolww` d
>wwd e
(wwe f
valuewwf k
=>wwl n
valuewwo t
==wwu w
Spacewwx }
||	ww~ Ä
value
wwÅ Ü
==
wwá â
HTab
wwä é
)
wwé è
)
wwè ê
;
wwê ë
}xx 
}yy Ü	
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ByteProcessorUtils.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
static 

class 
ByteProcessorUtils #
{ 
internal 
static 
readonly  
byte! %
Space& +
=, -
(. /
byte/ 3
)3 4
$char4 7
;7 8
internal		 
static		 
readonly		  
byte		! %
HTab		& *
=		+ ,
(		- .
byte		. 2
)		2 3
$char		3 7
;		7 8
internal

 
static

 
readonly

  
byte

! %
CarriageReturn

& 4
=

5 6
(

7 8
byte

8 <
)

< =
$char

= A
;

A B
internal 
static 
readonly  
byte! %
LineFeed& .
=/ 0
(1 2
byte2 6
)6 7
$char7 ;
;; <
} 
} ô(
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\CharSequenceEnumerator.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
struct 
"
CharSequenceEnumerator !
:" #
IEnumerator$ /
</ 0
char0 4
>4 5
{ 
ICharSequence 
charSequence "
;" #
int 
index 
; 
char 
currentElement 
; 
internal "
CharSequenceEnumerator '
(' (
ICharSequence( 5
charSequence6 B
)B C
{ 	
Contract 
. 
Requires 
( 
charSequence *
!=+ -
null. 2
)2 3
;3 4
this 
. 
charSequence 
= 
charSequence  ,
;, -
this 
. 
index 
= 
- 
$num 
; 
this 
. 
currentElement 
=  !
(" #
char# '
)' (
$num( )
;) *
} 	
public 
bool 
MoveNext 
( 
) 
{ 	
if 
( 
this 
. 
index 
< 
this !
.! "
charSequence" .
.. /
Count/ 4
-5 6
$num7 8
)8 9
{ 
this 
. 
index 
++ 
; 
this 
. 
currentElement #
=$ %
this& *
.* +
charSequence+ 7
[7 8
this8 <
.< =
index= B
]B C
;C D
return   
true   
;   
}!! 
this## 
.## 
index## 
=## 
this## 
.## 
charSequence## *
.##* +
Count##+ 0
;##0 1
return$$ 
false$$ 
;$$ 
}%% 	
object'' 
IEnumerator'' 
.'' 
Current'' "
{(( 	
get)) 
{** 
if++ 
(++ 
this++ 
.++ 
index++ 
==++ !
-++" #
$num++# $
)++$ %
{,, 
throw-- 
new-- %
InvalidOperationException-- 7
(--7 8
$str--8 U
)--U V
;--V W
}.. 
if// 
(// 
this// 
.// 
index// 
>=// !
this//" &
.//& '
charSequence//' 3
.//3 4
Count//4 9
)//9 :
{00 
throw11 
new11 %
InvalidOperationException11 7
(117 8
$str118 V
)11V W
;11W X
}22 
return33 
this33 
.33 
currentElement33 *
;33* +
}44 
}55 	
public77 
char77 
Current77 
{88 	
get99 
{:: 
if;; 
(;; 
this;; 
.;; 
index;; 
==;; !
-;;" #
$num;;# $
);;$ %
{<< 
throw== 
new== %
InvalidOperationException== 7
(==7 8
$str==8 U
)==U V
;==V W
}>> 
if?? 
(?? 
this?? 
.?? 
index?? 
>=?? !
this??" &
.??& '
charSequence??' 3
.??3 4
Count??4 9
)??9 :
{@@ 
throwAA 
newAA %
InvalidOperationExceptionAA 7
(AA7 8
$strAA8 V
)AAV W
;AAW X
}BB 
returnCC 
thisCC 
.CC 
currentElementCC *
;CC* +
}DD 
}EE 	
publicGG 
voidGG 
ResetGG 
(GG 
)GG 
{HH 	
thisII 
.II 
indexII 
=II 
-II 
$numII 
;II 
thisJJ 
.JJ 
currentElementJJ 
=JJ  !
(JJ" #
charJJ# '
)JJ' (
$numJJ( )
;JJ) *
}KK 	
publicMM 
voidMM 
DisposeMM 
(MM 
)MM 
{NN 	
ifOO 
(OO 
thisOO 
.OO 
charSequenceOO !
!=OO" $
nullOO% )
)OO) *
{PP 
thisQQ 
.QQ 
indexQQ 
=QQ 
thisQQ !
.QQ! "
charSequenceQQ" .
.QQ. /
CountQQ/ 4
;QQ4 5
}RR 
thisSS 
.SS 
charSequenceSS 
=SS 
nullSS  $
;SS$ %
}TT 	
}UU 
}VV ˆ∂
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\CharUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
CharUtil  
{ 
public 
static 
readonly 
string %
Digits& ,
=- .
$str/ A
;A B
public 
static 
readonly 
int "
MinRadix# +
=, -
$num. /
;/ 0
public 
static 
readonly 
int "
MaxRadix# +
=, -
$num. 0
;0 1
const 
string 
	DigitKeys 
=  
$str	! §
;
§ •
static 
readonly 
char 
[ 
] 
DigitValues *
=+ ,
$str	- ±
.
± ≤
ToCharArray
≤ Ω
(
Ω æ
)
æ ø
;
ø ¿
public 
static 
int 
BinarySearchRange +
(+ ,
string, 2
data3 7
,7 8
char9 =
c> ?
)? @
{ 	
char 
value 
= 
$char !
;! "
int 
low 
= 
$num 
, 
mid 
= 
-  
$num  !
,! "
high# '
=( )
data* .
.. /
Length/ 5
-6 7
$num8 9
;9 :
while 
( 
low 
<= 
high 
) 
{ 
mid 
= 
( 
low 
+ 
high !
)! "
>># %
$num& '
;' (
value 
= 
data 
[ 
mid  
]  !
;! "
if 
( 
c 
> 
value 
) 
low 
= 
mid 
+ 
$num  !
;! "
else 
if 
( 
c 
== 
value #
)# $
return   
mid   
;   
else!! 
high"" 
="" 
mid"" 
-""  
$num""! "
;""" #
}## 
return%% 
mid%% 
-%% 
(%% 
c%% 
<%% 
value%% #
?%%$ %
$num%%& '
:%%( )
$num%%* +
)%%+ ,
;%%, -
}&& 	
public(( 
static(( 
int(( 
ParseInt(( "
(((" #
ICharSequence((# 0
seq((1 4
,((4 5
int((6 9
start((: ?
,((? @
int((A D
end((E H
,((H I
int((J M
radix((N S
)((S T
{)) 	
Contract** 
.** 
Requires** 
(** 
seq** !
!=**" $
null**% )
)**) *
;*** +
Contract++ 
.++ 
Requires++ 
(++ 
radix++ #
>=++$ &
MinRadix++' /
&&++0 2
radix++3 8
<=++9 ;
MaxRadix++< D
)++D E
;++E F
if-- 
(-- 
start-- 
==-- 
end-- 
)-- 
{.. 
throw// 
new// 
FormatException// )
(//) *
)//* +
;//+ ,
}00 
int22 
i22 
=22 
start22 
;22 
bool33 
negative33 
=33 
seq33 
[33  
i33  !
]33! "
==33# %
$char33& )
;33) *
if44 
(44 
negative44 
&&44 
++44 
i44 
==44  "
end44# &
)44& '
{55 
throw66 
new66 
FormatException66 )
(66) *
seq66* -
.66- .
SubSequence66. 9
(669 :
start66: ?
,66? @
end66A D
)66D E
.66E F
ToString66F N
(66N O
)66O P
)66P Q
;66Q R
}77 
return99 
ParseInt99 
(99 
seq99 
,99  
i99! "
,99" #
end99$ '
,99' (
radix99) .
,99. /
negative990 8
)998 9
;999 :
}:: 	
public<< 
static<< 
int<< 
ParseInt<< "
(<<" #
ICharSequence<<# 0
seq<<1 4
)<<4 5
=><<6 8
ParseInt<<9 A
(<<A B
seq<<B E
,<<E F
$num<<G H
,<<H I
seq<<J M
.<<M N
Count<<N S
,<<S T
$num<<U W
,<<W X
false<<Y ^
)<<^ _
;<<_ `
public>> 
static>> 
int>> 
ParseInt>> "
(>>" #
ICharSequence>># 0
seq>>1 4
,>>4 5
int>>6 9
start>>: ?
,>>? @
int>>A D
end>>E H
,>>H I
int>>J M
radix>>N S
,>>S T
bool>>U Y
negative>>Z b
)>>b c
{?? 	
Contract@@ 
.@@ 
Requires@@ 
(@@ 
seq@@ !
!=@@" $
null@@% )
)@@) *
;@@* +
ContractAA 
.AA 
RequiresAA 
(AA 
radixAA #
>=AA$ &
MinRadixAA' /
&&AA0 2
radixAA3 8
<=AA9 ;
MaxRadixAA< D
)AAD E
;AAE F
intCC 
maxCC 
=CC 
intCC 
.CC 
MinValueCC "
/CC# $
radixCC% *
;CC* +
intDD 
resultDD 
=DD 
$numDD 
;DD 
intEE 

currOffsetEE 
=EE 
startEE "
;EE" #
whileFF 
(FF 

currOffsetFF 
<FF 
endFF  #
)FF# $
{GG 
intHH 
digitHH 
=HH 
DigitHH !
(HH! "
(HH" #
charHH# '
)HH' (
(HH( )
seqHH) ,
[HH, -

currOffsetHH- 7
++HH7 9
]HH9 :
&HH; <
$numHH= A
)HHA B
,HHB C
radixHHD I
)HHI J
;HHJ K
ifII 
(II 
digitII 
==II 
-II 
$numII 
)II  
{JJ 
throwKK 
newKK 
FormatExceptionKK -
(KK- .
seqKK. 1
.KK1 2
SubSequenceKK2 =
(KK= >
startKK> C
,KKC D
endKKE H
)KKH I
.KKI J
ToStringKKJ R
(KKR S
)KKS T
)KKT U
;KKU V
}LL 
ifMM 
(MM 
maxMM 
>MM 
resultMM  
)MM  !
{NN 
throwOO 
newOO 
FormatExceptionOO -
(OO- .
seqOO. 1
.OO1 2
SubSequenceOO2 =
(OO= >
startOO> C
,OOC D
endOOE H
)OOH I
.OOI J
ToStringOOJ R
(OOR S
)OOS T
)OOT U
;OOU V
}PP 
intQQ 
nextQQ 
=QQ 
resultQQ !
*QQ" #
radixQQ$ )
-QQ* +
digitQQ, 1
;QQ1 2
ifRR 
(RR 
nextRR 
>RR 
resultRR !
)RR! "
{SS 
throwTT 
newTT 
FormatExceptionTT -
(TT- .
seqTT. 1
.TT1 2
SubSequenceTT2 =
(TT= >
startTT> C
,TTC D
endTTE H
)TTH I
.TTI J
ToStringTTJ R
(TTR S
)TTS T
)TTT U
;TTU V
}UU 
resultVV 
=VV 
nextVV 
;VV 
}WW 
ifYY 
(YY 
!YY 
negativeYY 
)YY 
{ZZ 
result[[ 
=[[ 
-[[ 
result[[  
;[[  !
if\\ 
(\\ 
result\\ 
<\\ 
$num\\ 
)\\ 
{]] 
throw^^ 
new^^ 
FormatException^^ -
(^^- .
seq^^. 1
.^^1 2
SubSequence^^2 =
(^^= >
start^^> C
,^^C D
end^^E H
)^^H I
.^^I J
ToString^^J R
(^^R S
)^^S T
)^^T U
;^^U V
}__ 
}`` 
returnbb 
resultbb 
;bb 
}cc 	
[ee 	

MethodImplee	 
(ee 
MethodImplOptionsee %
.ee% &
AggressiveInliningee& 8
)ee8 9
]ee9 :
publicff 
staticff 
longff 
	ParseLongff $
(ff$ %
ICharSequenceff% 2
strff3 6
,ff6 7
intff8 ;
radixff< A
=ffB C
$numffD F
)ffF G
{gg 	
ifhh 
(hh 
strhh 
ishh 
AsciiStringhh "
asciiStringhh# .
)hh. /
{ii 
returnjj 
asciiStringjj "
.jj" #
	ParseLongjj# ,
(jj, -
radixjj- 2
)jj2 3
;jj3 4
}kk 
ifmm 
(mm 
strmm 
==mm 
nullmm 
||nn 
radixnn 
<nn 
MinRadixnn #
||oo 
radixoo 
>oo 
MaxRadixoo #
)oo# $
{pp  
ThrowFormatExceptionqq $
(qq$ %
strqq% (
)qq( )
;qq) *
}rr 
intuu 
lengthuu 
=uu 
struu 
.uu 
Countuu "
;uu" #
intvv 
ivv 
=vv 
$numvv 
;vv 
ifww 
(ww 
lengthww 
==ww 
$numww 
)ww 
{xx  
ThrowFormatExceptionyy $
(yy$ %
stryy% (
)yy( )
;yy) *
}zz 
bool{{ 
negative{{ 
={{ 
str{{ 
[{{  
i{{  !
]{{! "
=={{# %
$char{{& )
;{{) *
if|| 
(|| 
negative|| 
&&|| 
++|| 
i|| 
==||  "
length||# )
)||) *
{}}  
ThrowFormatException~~ $
(~~$ %
str~~% (
)~~( )
;~~) *
} 
return
ÅÅ 
	ParseLong
ÅÅ 
(
ÅÅ 
str
ÅÅ  
,
ÅÅ  !
i
ÅÅ" #
,
ÅÅ# $
radix
ÅÅ% *
,
ÅÅ* +
negative
ÅÅ, 4
)
ÅÅ4 5
;
ÅÅ5 6
}
ÇÇ 	
[
ÑÑ 	

MethodImpl
ÑÑ	 
(
ÑÑ 
MethodImplOptions
ÑÑ %
.
ÑÑ% & 
AggressiveInlining
ÑÑ& 8
)
ÑÑ8 9
]
ÑÑ9 :
static
ÖÖ 
long
ÖÖ 
	ParseLong
ÖÖ 
(
ÖÖ 
ICharSequence
ÖÖ +
str
ÖÖ, /
,
ÖÖ/ 0
int
ÖÖ1 4
offset
ÖÖ5 ;
,
ÖÖ; <
int
ÖÖ= @
radix
ÖÖA F
,
ÖÖF G
bool
ÖÖH L
negative
ÖÖM U
)
ÖÖU V
{
ÜÜ 	
long
áá 
max
áá 
=
áá 
long
áá 
.
áá 
MinValue
áá $
/
áá% &
radix
áá' ,
;
áá, -
long
àà 
result
àà 
=
àà 
$num
àà 
,
àà 
length
àà #
=
àà$ %
str
àà& )
.
àà) *
Count
àà* /
;
àà/ 0
while
ââ 
(
ââ 
offset
ââ 
<
ââ 
length
ââ "
)
ââ" #
{
ää 
int
ãã 
digit
ãã 
=
ãã 
Digit
ãã !
(
ãã! "
str
ãã" %
[
ãã% &
offset
ãã& ,
++
ãã, .
]
ãã. /
,
ãã/ 0
radix
ãã1 6
)
ãã6 7
;
ãã7 8
if
åå 
(
åå 
digit
åå 
==
åå 
-
åå 
$num
åå 
)
åå  
{
çç "
ThrowFormatException
éé (
(
éé( )
str
éé) ,
)
éé, -
;
éé- .
}
èè 
if
êê 
(
êê 
max
êê 
>
êê 
result
êê  
)
êê  !
{
ëë "
ThrowFormatException
íí (
(
íí( )
str
íí) ,
)
íí, -
;
íí- .
}
ìì 
long
îî 
next
îî 
=
îî 
result
îî "
*
îî# $
radix
îî% *
-
îî+ ,
digit
îî- 2
;
îî2 3
if
ïï 
(
ïï 
next
ïï 
>
ïï 
result
ïï !
)
ïï! "
{
ññ "
ThrowFormatException
óó (
(
óó( )
str
óó) ,
)
óó, -
;
óó- .
}
òò 
result
ôô 
=
ôô 
next
ôô 
;
ôô 
}
öö 
if
úú 
(
úú 
!
úú 
negative
úú 
)
úú 
{
ùù 
result
ûû 
=
ûû 
-
ûû 
result
ûû  
;
ûû  !
if
üü 
(
üü 
result
üü 
<
üü 
$num
üü 
)
üü 
{
†† "
ThrowFormatException
°° (
(
°°( )
str
°°) ,
)
°°, -
;
°°- .
}
¢¢ 
}
££ 
return
•• 
result
•• 
;
•• 
}
¶¶ 	
static
®® 
void
®® "
ThrowFormatException
®® (
(
®®( )
ICharSequence
®®) 6
str
®®7 :
)
®®: ;
=>
®®= ?
throw
®®@ E
new
®®F I
FormatException
®®J Y
(
®®Y Z
str
®®Z ]
.
®®] ^
ToString
®®^ f
(
®®f g
)
®®g h
)
®®h i
;
®®i j
public
™™ 
static
™™ 
bool
™™ 
IsNullOrEmpty
™™ (
(
™™( )
ICharSequence
™™) 6
sequence
™™7 ?
)
™™? @
=>
™™A C
sequence
™™D L
==
™™M O
null
™™P T
||
™™U W
sequence
™™X `
.
™™` a
Count
™™a f
==
™™g i
$num
™™j k
;
™™k l
public
¨¨ 
static
¨¨ 
ICharSequence
¨¨ #
[
¨¨# $
]
¨¨$ %
Split
¨¨& +
(
¨¨+ ,
ICharSequence
¨¨, 9
sequence
¨¨: B
,
¨¨B C
params
¨¨D J
char
¨¨K O
[
¨¨O P
]
¨¨P Q

delimiters
¨¨R \
)
¨¨\ ]
=>
¨¨^ `
Split
¨¨a f
(
¨¨f g
sequence
¨¨g o
,
¨¨o p
$num
¨¨q r
,
¨¨r s

delimiters
¨¨t ~
)
¨¨~ 
;¨¨ Ä
public
ÆÆ 
static
ÆÆ 
ICharSequence
ÆÆ #
[
ÆÆ# $
]
ÆÆ$ %
Split
ÆÆ& +
(
ÆÆ+ ,
ICharSequence
ÆÆ, 9
sequence
ÆÆ: B
,
ÆÆB C
int
ÆÆD G

startIndex
ÆÆH R
,
ÆÆR S
params
ÆÆT Z
char
ÆÆ[ _
[
ÆÆ_ `
]
ÆÆ` a

delimiters
ÆÆb l
)
ÆÆl m
{
ØØ 	
Contract
∞∞ 
.
∞∞ 
Requires
∞∞ 
(
∞∞ 
sequence
∞∞ &
!=
∞∞' )
null
∞∞* .
)
∞∞. /
;
∞∞/ 0
Contract
±± 
.
±± 
Requires
±± 
(
±± 

delimiters
±± (
!=
±±) +
null
±±, 0
)
±±0 1
;
±±1 2
Contract
≤≤ 
.
≤≤ 
Requires
≤≤ 
(
≤≤ 

startIndex
≤≤ (
>=
≤≤) +
$num
≤≤, -
&&
≤≤. 0

startIndex
≤≤1 ;
<
≤≤< =
sequence
≤≤> F
.
≤≤F G
Count
≤≤G L
)
≤≤L M
;
≤≤M N
List
¥¥ 
<
¥¥ 
ICharSequence
¥¥ 
>
¥¥ 
result
¥¥  &
=
¥¥' ($
InternalThreadLocalMap
¥¥) ?
.
¥¥? @
Get
¥¥@ C
(
¥¥C D
)
¥¥D E
.
¥¥E F
CharSequenceList
¥¥F V
(
¥¥V W
)
¥¥W X
;
¥¥X Y
int
∂∂ 
i
∂∂ 
=
∂∂ 

startIndex
∂∂ 
;
∂∂ 
int
∑∑ 
length
∑∑ 
=
∑∑ 
sequence
∑∑ !
.
∑∑! "
Count
∑∑" '
;
∑∑' (
while
ππ 
(
ππ 
i
ππ 
<
ππ 
length
ππ 
)
ππ 
{
∫∫ 
while
ªª 
(
ªª 
i
ªª 
<
ªª 
length
ªª !
&&
ªª" $
IndexOf
ªª% ,
(
ªª, -

delimiters
ªª- 7
,
ªª7 8
sequence
ªª9 A
[
ªªA B
i
ªªB C
]
ªªC D
)
ªªD E
>=
ªªF H
$num
ªªI J
)
ªªJ K
{
ºº 
i
ΩΩ 
++
ΩΩ 
;
ΩΩ 
}
ææ 
int
¿¿ 
position
¿¿ 
=
¿¿ 
i
¿¿  
;
¿¿  !
if
¡¡ 
(
¡¡ 
i
¡¡ 
<
¡¡ 
length
¡¡ 
)
¡¡ 
{
¬¬ 
if
√√ 
(
√√ 
IndexOf
√√ 
(
√√  

delimiters
√√  *
,
√√* +
sequence
√√, 4
[
√√4 5
position
√√5 =
]
√√= >
)
√√> ?
>=
√√@ B
$num
√√C D
)
√√D E
{
ƒƒ 
result
≈≈ 
.
≈≈ 
Add
≈≈ "
(
≈≈" #
sequence
≈≈# +
.
≈≈+ ,
SubSequence
≈≈, 7
(
≈≈7 8
position
≈≈8 @
++
≈≈@ B
,
≈≈B C
i
≈≈D E
+
≈≈F G
$num
≈≈H I
)
≈≈I J
)
≈≈J K
;
≈≈K L
}
∆∆ 
else
«« 
{
»» 
ICharSequence
…… %
seq
……& )
=
……* +
null
……, 0
;
……0 1
for
   
(
   
position
   %
++
  % '
;
  ' (
position
  ) 1
<
  2 3
length
  4 :
;
  : ;
position
  < D
++
  D F
)
  F G
{
ÀÀ 
if
ÃÃ 
(
ÃÃ  
IndexOf
ÃÃ  '
(
ÃÃ' (

delimiters
ÃÃ( 2
,
ÃÃ2 3
sequence
ÃÃ4 <
[
ÃÃ< =
position
ÃÃ= E
]
ÃÃE F
)
ÃÃF G
>=
ÃÃH J
$num
ÃÃK L
)
ÃÃL M
{
ÕÕ 
seq
ŒŒ  #
=
ŒŒ$ %
sequence
ŒŒ& .
.
ŒŒ. /
SubSequence
ŒŒ/ :
(
ŒŒ: ;
i
ŒŒ; <
,
ŒŒ< =
position
ŒŒ> F
)
ŒŒF G
;
ŒŒG H
break
œœ  %
;
œœ% &
}
–– 
}
—— 
result
““ 
.
““ 
Add
““ "
(
““" #
seq
““# &
??
““' )
sequence
““* 2
.
““2 3
SubSequence
““3 >
(
““> ?
i
““? @
)
““@ A
)
““A B
;
““B C
}
”” 
i
‘‘ 
=
‘‘ 
position
‘‘  
;
‘‘  !
}
’’ 
}
÷÷ 
return
ÿÿ 
result
ÿÿ 
.
ÿÿ 
Count
ÿÿ 
==
ÿÿ  "
$num
ÿÿ# $
?
ÿÿ% &
new
ÿÿ' *
[
ÿÿ* +
]
ÿÿ+ ,
{
ÿÿ- .
sequence
ÿÿ/ 7
}
ÿÿ8 9
:
ÿÿ: ;
result
ÿÿ< B
.
ÿÿB C
ToArray
ÿÿC J
(
ÿÿJ K
)
ÿÿK L
;
ÿÿL M
}
ŸŸ 	
internal
€€ 
static
€€ 
bool
€€ 
ContentEquals
€€ *
(
€€* +
ICharSequence
€€+ 8
left
€€9 =
,
€€= >
ICharSequence
€€? L
right
€€M R
)
€€R S
{
‹‹ 	
if
›› 
(
›› 
left
›› 
==
›› 
null
›› 
||
›› 
right
››  %
==
››& (
null
››) -
)
››- .
{
ﬁﬁ 
return
ﬂﬂ 
ReferenceEquals
ﬂﬂ &
(
ﬂﬂ& '
left
ﬂﬂ' +
,
ﬂﬂ+ ,
right
ﬂﬂ- 2
)
ﬂﬂ2 3
;
ﬂﬂ3 4
}
‡‡ 
if
‚‚ 
(
‚‚ 
ReferenceEquals
‚‚ 
(
‚‚  
left
‚‚  $
,
‚‚$ %
right
‚‚& +
)
‚‚+ ,
)
‚‚, -
{
„„ 
return
‰‰ 
true
‰‰ 
;
‰‰ 
}
ÂÂ 
if
ÊÊ 
(
ÊÊ 
left
ÊÊ 
.
ÊÊ 
Count
ÊÊ 
!=
ÊÊ 
right
ÊÊ #
.
ÊÊ# $
Count
ÊÊ$ )
)
ÊÊ) *
{
ÁÁ 
return
ËË 
false
ËË 
;
ËË 
}
ÈÈ 
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ 
left
ÎÎ  $
.
ÎÎ$ %
Count
ÎÎ% *
;
ÎÎ* +
i
ÎÎ, -
++
ÎÎ- /
)
ÎÎ/ 0
{
ÏÏ 
char
ÌÌ 
c1
ÌÌ 
=
ÌÌ 
left
ÌÌ 
[
ÌÌ 
i
ÌÌ  
]
ÌÌ  !
;
ÌÌ! "
char
ÓÓ 
c2
ÓÓ 
=
ÓÓ 
right
ÓÓ 
[
ÓÓ  
i
ÓÓ  !
]
ÓÓ! "
;
ÓÓ" #
if
ÔÔ 
(
ÔÔ 
c1
ÔÔ 
!=
ÔÔ 
c2
ÔÔ 
&&
 
char
 
.
 
ToUpper
 #
(
# $
c1
$ &
)
& '
.
' (
	CompareTo
( 1
(
1 2
char
2 6
.
6 7
ToUpper
7 >
(
> ?
c2
? A
)
A B
)
B C
!=
D F
$num
G H
&&
ÒÒ 
char
ÒÒ 
.
ÒÒ 
ToLower
ÒÒ #
(
ÒÒ# $
c1
ÒÒ$ &
)
ÒÒ& '
.
ÒÒ' (
	CompareTo
ÒÒ( 1
(
ÒÒ1 2
char
ÒÒ2 6
.
ÒÒ6 7
ToLower
ÒÒ7 >
(
ÒÒ> ?
c2
ÒÒ? A
)
ÒÒA B
)
ÒÒB C
!=
ÒÒD F
$num
ÒÒG H
)
ÒÒH I
{
ÚÚ 
return
ÛÛ 
false
ÛÛ  
;
ÛÛ  !
}
ÙÙ 
}
ıı 
return
˜˜ 
true
˜˜ 
;
˜˜ 
}
¯¯ 	
internal
˙˙ 
static
˙˙ 
bool
˙˙ %
ContentEqualsIgnoreCase
˙˙ 4
(
˙˙4 5
ICharSequence
˙˙5 B
left
˙˙C G
,
˙˙G H
ICharSequence
˙˙I V
right
˙˙W \
)
˙˙\ ]
{
˚˚ 	
if
¸¸ 
(
¸¸ 
left
¸¸ 
==
¸¸ 
null
¸¸ 
||
¸¸ 
right
¸¸  %
==
¸¸& (
null
¸¸) -
)
¸¸- .
{
˝˝ 
return
˛˛ 
ReferenceEquals
˛˛ &
(
˛˛& '
left
˛˛' +
,
˛˛+ ,
right
˛˛- 2
)
˛˛2 3
;
˛˛3 4
}
ˇˇ 
if
ÅÅ 
(
ÅÅ 
ReferenceEquals
ÅÅ 
(
ÅÅ  
left
ÅÅ  $
,
ÅÅ$ %
right
ÅÅ& +
)
ÅÅ+ ,
)
ÅÅ, -
{
ÇÇ 
return
ÉÉ 
true
ÉÉ 
;
ÉÉ 
}
ÑÑ 
if
ÖÖ 
(
ÖÖ 
left
ÖÖ 
.
ÖÖ 
Count
ÖÖ 
!=
ÖÖ 
right
ÖÖ #
.
ÖÖ# $
Count
ÖÖ$ )
)
ÖÖ) *
{
ÜÜ 
return
áá 
false
áá 
;
áá 
}
àà 
for
ää 
(
ää 
int
ää 
i
ää 
=
ää 
$num
ää 
;
ää 
i
ää 
<
ää 
left
ää  $
.
ää$ %
Count
ää% *
;
ää* +
i
ää, -
++
ää- /
)
ää/ 0
{
ãã 
char
åå 
c1
åå 
=
åå 
left
åå 
[
åå 
i
åå  
]
åå  !
;
åå! "
char
çç 
c2
çç 
=
çç 
right
çç 
[
çç  
i
çç  !
]
çç! "
;
çç" #
if
éé 
(
éé 
char
éé 
.
éé 
ToLower
éé  
(
éé  !
c1
éé! #
)
éé# $
.
éé$ %
	CompareTo
éé% .
(
éé. /
char
éé/ 3
.
éé3 4
ToLower
éé4 ;
(
éé; <
c2
éé< >
)
éé> ?
)
éé? @
!=
ééA C
$num
ééD E
)
ééE F
{
èè 
return
êê 
false
êê  
;
êê  !
}
ëë 
}
íí 
return
îî 
true
îî 
;
îî 
}
ïï 	
public
óó 
static
óó 
bool
óó 
RegionMatches
óó (
(
óó( )
string
óó) /
value
óó0 5
,
óó5 6
int
óó7 :
	thisStart
óó; D
,
óóD E
ICharSequence
óóF S
other
óóT Y
,
óóY Z
int
óó[ ^
start
óó_ d
,
óód e
int
óóf i
length
óój p
)
óóp q
{
òò 	
Contract
ôô 
.
ôô 
Requires
ôô 
(
ôô 
value
ôô #
!=
ôô$ &
null
ôô' +
&&
ôô, .
other
ôô/ 4
!=
ôô5 7
null
ôô8 <
)
ôô< =
;
ôô= >
if
õõ 
(
õõ 
start
õõ 
<
õõ 
$num
õõ 
||
úú 
other
úú 
.
úú 
Count
úú 
-
úú  
start
úú! &
<
úú' (
length
úú) /
)
úú/ 0
{
ùù 
return
ûû 
false
ûû 
;
ûû 
}
üü 
if
°° 
(
°° 
	thisStart
°° 
<
°° 
$num
°° 
||
¢¢ 
value
¢¢ 
.
¢¢ 
Length
¢¢ 
-
¢¢  !
	thisStart
¢¢" +
<
¢¢, -
length
¢¢. 4
)
¢¢4 5
{
££ 
return
§§ 
false
§§ 
;
§§ 
}
•• 
if
ßß 
(
ßß 
length
ßß 
<=
ßß 
$num
ßß 
)
ßß 
{
®® 
return
©© 
true
©© 
;
©© 
}
™™ 
int
¨¨ 
o1
¨¨ 
=
¨¨ 
	thisStart
¨¨ 
;
¨¨ 
int
≠≠ 
o2
≠≠ 
=
≠≠ 
start
≠≠ 
;
≠≠ 
for
ÆÆ 
(
ÆÆ 
int
ÆÆ 
i
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
i
ÆÆ 
<
ÆÆ 
length
ÆÆ  &
;
ÆÆ& '
++
ÆÆ( *
i
ÆÆ* +
)
ÆÆ+ ,
{
ØØ 
if
∞∞ 
(
∞∞ 
value
∞∞ 
[
∞∞ 
o1
∞∞ 
+
∞∞ 
i
∞∞  
]
∞∞  !
!=
∞∞" $
other
∞∞% *
[
∞∞* +
o2
∞∞+ -
+
∞∞. /
i
∞∞0 1
]
∞∞1 2
)
∞∞2 3
{
±± 
return
≤≤ 
false
≤≤  
;
≤≤  !
}
≥≥ 
}
¥¥ 
return
∂∂ 
true
∂∂ 
;
∂∂ 
}
∑∑ 	
public
ππ 
static
ππ 
bool
ππ %
RegionMatchesIgnoreCase
ππ 2
(
ππ2 3
string
ππ3 9
value
ππ: ?
,
ππ? @
int
ππA D
	thisStart
ππE N
,
ππN O
ICharSequence
ππP ]
other
ππ^ c
,
ππc d
int
ππe h
start
ππi n
,
ππn o
int
ππp s
length
ππt z
)
ππz {
{
∫∫ 	
Contract
ªª 
.
ªª 
Requires
ªª 
(
ªª 
value
ªª #
!=
ªª$ &
null
ªª' +
&&
ªª, .
other
ªª/ 4
!=
ªª5 7
null
ªª8 <
)
ªª< =
;
ªª= >
if
ΩΩ 
(
ΩΩ 
	thisStart
ΩΩ 
<
ΩΩ 
$num
ΩΩ 
||
ææ 
length
ææ 
>
ææ 
value
ææ !
.
ææ! "
Length
ææ" (
-
ææ) *
	thisStart
ææ+ 4
)
ææ4 5
{
øø 
return
¿¿ 
false
¿¿ 
;
¿¿ 
}
¡¡ 
if
√√ 
(
√√ 
start
√√ 
<
√√ 
$num
√√ 
||
√√ 
length
√√ #
>
√√$ %
other
√√& +
.
√√+ ,
Count
√√, 1
-
√√2 3
start
√√4 9
)
√√9 :
{
ƒƒ 
return
≈≈ 
false
≈≈ 
;
≈≈ 
}
∆∆ 
int
»» 
end
»» 
=
»» 
	thisStart
»» 
+
»»  !
length
»»" (
;
»»( )
while
…… 
(
…… 
	thisStart
…… 
<
…… 
end
…… "
)
……" #
{
   
char
ÀÀ 
c1
ÀÀ 
=
ÀÀ 
value
ÀÀ 
[
ÀÀ  
	thisStart
ÀÀ  )
++
ÀÀ) +
]
ÀÀ+ ,
;
ÀÀ, -
char
ÃÃ 
c2
ÃÃ 
=
ÃÃ 
other
ÃÃ 
[
ÃÃ  
start
ÃÃ  %
++
ÃÃ% '
]
ÃÃ' (
;
ÃÃ( )
if
ÕÕ 
(
ÕÕ 
c1
ÕÕ 
!=
ÕÕ 
c2
ÕÕ 
&&
ŒŒ 
char
ŒŒ 
.
ŒŒ 
ToUpper
ŒŒ #
(
ŒŒ# $
c1
ŒŒ$ &
)
ŒŒ& '
.
ŒŒ' (
	CompareTo
ŒŒ( 1
(
ŒŒ1 2
char
ŒŒ2 6
.
ŒŒ6 7
ToUpper
ŒŒ7 >
(
ŒŒ> ?
c2
ŒŒ? A
)
ŒŒA B
)
ŒŒB C
!=
ŒŒD F
$num
ŒŒG H
&&
œœ 
char
œœ 
.
œœ 
ToLower
œœ #
(
œœ# $
c1
œœ$ &
)
œœ& '
.
œœ' (
	CompareTo
œœ( 1
(
œœ1 2
char
œœ2 6
.
œœ6 7
ToLower
œœ7 >
(
œœ> ?
c2
œœ? A
)
œœA B
)
œœB C
!=
œœD F
$num
œœG H
)
œœH I
{
–– 
return
—— 
false
——  
;
——  !
}
““ 
}
”” 
return
’’ 
true
’’ 
;
’’ 
}
÷÷ 	
public
ÿÿ 
static
ÿÿ 
bool
ÿÿ 
RegionMatches
ÿÿ (
(
ÿÿ( )
IReadOnlyList
ÿÿ) 6
<
ÿÿ6 7
char
ÿÿ7 ;
>
ÿÿ; <
value
ÿÿ= B
,
ÿÿB C
int
ÿÿD G
	thisStart
ÿÿH Q
,
ÿÿQ R
ICharSequence
ÿÿS `
other
ÿÿa f
,
ÿÿf g
int
ÿÿh k
start
ÿÿl q
,
ÿÿq r
int
ÿÿs v
length
ÿÿw }
)
ÿÿ} ~
{
ŸŸ 	
Contract
⁄⁄ 
.
⁄⁄ 
Requires
⁄⁄ 
(
⁄⁄ 
value
⁄⁄ #
!=
⁄⁄$ &
null
⁄⁄' +
&&
⁄⁄, .
other
⁄⁄/ 4
!=
⁄⁄5 7
null
⁄⁄8 <
)
⁄⁄< =
;
⁄⁄= >
if
‹‹ 
(
‹‹ 
start
‹‹ 
<
‹‹ 
$num
‹‹ 
||
‹‹ 
other
‹‹ "
.
‹‹" #
Count
‹‹# (
-
‹‹) *
start
‹‹+ 0
<
‹‹1 2
length
‹‹3 9
)
‹‹9 :
{
›› 
return
ﬁﬁ 
false
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
if
·· 
(
·· 
	thisStart
·· 
<
·· 
$num
·· 
||
··  
value
··! &
.
··& '
Count
··' ,
-
··- .
	thisStart
··/ 8
<
··9 :
length
··; A
)
··A B
{
‚‚ 
return
„„ 
false
„„ 
;
„„ 
}
‰‰ 
if
ÊÊ 
(
ÊÊ 
length
ÊÊ 
<=
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
{
ÁÁ 
return
ËË 
true
ËË 
;
ËË 
}
ÈÈ 
int
ÎÎ 
o1
ÎÎ 
=
ÎÎ 
	thisStart
ÎÎ 
;
ÎÎ 
int
ÏÏ 
o2
ÏÏ 
=
ÏÏ 
start
ÏÏ 
;
ÏÏ 
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
i
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
i
ÌÌ 
<
ÌÌ 
length
ÌÌ  &
;
ÌÌ& '
++
ÌÌ( *
i
ÌÌ* +
)
ÌÌ+ ,
{
ÓÓ 
if
ÔÔ 
(
ÔÔ 
value
ÔÔ 
[
ÔÔ 
o1
ÔÔ 
+
ÔÔ 
i
ÔÔ  
]
ÔÔ  !
!=
ÔÔ" $
other
ÔÔ% *
[
ÔÔ* +
o2
ÔÔ+ -
+
ÔÔ. /
i
ÔÔ0 1
]
ÔÔ1 2
)
ÔÔ2 3
{
 
return
ÒÒ 
false
ÒÒ  
;
ÒÒ  !
}
ÚÚ 
}
ÛÛ 
return
ıı 
true
ıı 
;
ıı 
}
ˆˆ 	
public
¯¯ 
static
¯¯ 
bool
¯¯ %
RegionMatchesIgnoreCase
¯¯ 2
(
¯¯2 3
IReadOnlyList
¯¯3 @
<
¯¯@ A
char
¯¯A E
>
¯¯E F
value
¯¯G L
,
¯¯L M
int
¯¯N Q
	thisStart
¯¯R [
,
¯¯[ \
ICharSequence
¯¯] j
other
¯¯k p
,
¯¯p q
int
¯¯r u
start
¯¯v {
,
¯¯{ |
int¯¯} Ä
length¯¯Å á
)¯¯á à
{
˘˘ 	
Contract
˙˙ 
.
˙˙ 
Requires
˙˙ 
(
˙˙ 
value
˙˙ #
!=
˙˙$ &
null
˙˙' +
&&
˙˙, .
other
˙˙/ 4
!=
˙˙5 7
null
˙˙8 <
)
˙˙< =
;
˙˙= >
if
¸¸ 
(
¸¸ 
	thisStart
¸¸ 
<
¸¸ 
$num
¸¸ 
||
¸¸  
length
¸¸! '
>
¸¸( )
value
¸¸* /
.
¸¸/ 0
Count
¸¸0 5
-
¸¸6 7
	thisStart
¸¸8 A
)
¸¸A B
{
˝˝ 
return
˛˛ 
false
˛˛ 
;
˛˛ 
}
ˇˇ 
if
ÅÅ 
(
ÅÅ 
start
ÅÅ 
<
ÅÅ 
$num
ÅÅ 
||
ÅÅ 
length
ÅÅ #
>
ÅÅ$ %
other
ÅÅ& +
.
ÅÅ+ ,
Count
ÅÅ, 1
-
ÅÅ2 3
start
ÅÅ4 9
)
ÅÅ9 :
{
ÇÇ 
return
ÉÉ 
false
ÉÉ 
;
ÉÉ 
}
ÑÑ 
int
ÜÜ 
end
ÜÜ 
=
ÜÜ 
	thisStart
ÜÜ 
+
ÜÜ  !
length
ÜÜ" (
;
ÜÜ( )
while
áá 
(
áá 
	thisStart
áá 
<
áá 
end
áá "
)
áá" #
{
àà 
char
ââ 
c1
ââ 
=
ââ 
value
ââ 
[
ââ  
	thisStart
ââ  )
++
ââ) +
]
ââ+ ,
;
ââ, -
char
ää 
c2
ää 
=
ää 
other
ää 
[
ää  
start
ää  %
++
ää% '
]
ää' (
;
ää( )
if
ãã 
(
ãã 
c1
ãã 
!=
ãã 
c2
ãã 
&&
åå 
char
åå 
.
åå 
ToUpper
åå #
(
åå# $
c1
åå$ &
)
åå& '
.
åå' (
	CompareTo
åå( 1
(
åå1 2
char
åå2 6
.
åå6 7
ToUpper
åå7 >
(
åå> ?
c2
åå? A
)
ååA B
)
ååB C
!=
ååD F
$num
ååG H
&&
çç 
char
çç 
.
çç 
ToLower
çç #
(
çç# $
c1
çç$ &
)
çç& '
.
çç' (
	CompareTo
çç( 1
(
çç1 2
char
çç2 6
.
çç6 7
ToLower
çç7 >
(
çç> ?
c2
çç? A
)
ççA B
)
ççB C
!=
ççD F
$num
ççG H
)
ççH I
{
éé 
return
èè 
false
èè  
;
èè  !
}
êê 
}
ëë 
return
ìì 
true
ìì 
;
ìì 
}
îî 	
public
ññ 
static
ññ 
ICharSequence
ññ #
SubstringAfter
ññ$ 2
(
ññ2 3
this
ññ3 7
ICharSequence
ññ8 E
value
ññF K
,
ññK L
char
ññM Q
delim
ññR W
)
ññW X
{
óó 	
int
òò 
pos
òò 
=
òò 
value
òò 
.
òò 
IndexOf
òò #
(
òò# $
delim
òò$ )
)
òò) *
;
òò* +
return
ôô 
pos
ôô 
>=
ôô 
$num
ôô 
?
ôô 
value
ôô #
.
ôô# $
SubSequence
ôô$ /
(
ôô/ 0
pos
ôô0 3
+
ôô4 5
$num
ôô6 7
,
ôô7 8
value
ôô9 >
.
ôô> ?
Count
ôô? D
)
ôôD E
:
ôôF G
null
ôôH L
;
ôôL M
}
öö 	
public
úú 
static
úú 
ICharSequence
úú #
Trim
úú$ (
(
úú( )
ICharSequence
úú) 6
sequence
úú7 ?
)
úú? @
{
ùù 	
Contract
ûû 
.
ûû 
Requires
ûû 
(
ûû 
sequence
ûû &
!=
ûû' )
null
ûû* .
)
ûû. /
;
ûû/ 0
int
†† 
length
†† 
=
†† 
sequence
†† !
.
††! "
Count
††" '
;
††' (
int
°° 
start
°° 
=
°° '
IndexOfFirstNonWhiteSpace
°° 1
(
°°1 2
sequence
°°2 :
)
°°: ;
;
°°; <
if
¢¢ 
(
¢¢ 
start
¢¢ 
==
¢¢ 
length
¢¢ 
)
¢¢  
{
££ 
return
§§  
StringCharSequence
§§ )
.
§§) *
Empty
§§* /
;
§§/ 0
}
•• 
int
ßß 
last
ßß 
=
ßß *
IndexOfLastNonWhiteSpaceChar
ßß 3
(
ßß3 4
sequence
ßß4 <
,
ßß< =
start
ßß> C
)
ßßC D
;
ßßD E
length
©© 
=
©© 
last
©© 
-
©© 
start
©© !
+
©©" #
$num
©©$ %
;
©©% &
return
™™ 
length
™™ 
==
™™ 
sequence
™™ %
.
™™% &
Count
™™& +
?
´´ 
sequence
´´ 
:
¨¨ 
sequence
¨¨ 
.
¨¨ 
SubSequence
¨¨ &
(
¨¨& '
start
¨¨' ,
,
¨¨, -
last
¨¨. 2
+
¨¨3 4
$num
¨¨5 6
)
¨¨6 7
;
¨¨7 8
}
≠≠ 	
static
ØØ 
int
ØØ '
IndexOfFirstNonWhiteSpace
ØØ ,
(
ØØ, -
IReadOnlyList
ØØ- :
<
ØØ: ;
char
ØØ; ?
>
ØØ? @
value
ØØA F
)
ØØF G
{
∞∞ 	
Contract
±± 
.
±± 
Requires
±± 
(
±± 
value
±± #
!=
±±$ &
null
±±' +
)
±±+ ,
;
±±, -
int
≥≥ 
i
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 
while
¥¥ 
(
¥¥ 
i
¥¥ 
<
¥¥ 
value
¥¥ 
.
¥¥ 
Count
¥¥ "
&&
¥¥# %
char
¥¥& *
.
¥¥* +
IsWhiteSpace
¥¥+ 7
(
¥¥7 8
value
¥¥8 =
[
¥¥= >
i
¥¥> ?
]
¥¥? @
)
¥¥@ A
)
¥¥A B
{
µµ 
i
∂∂ 
++
∂∂ 
;
∂∂ 
}
∑∑ 
return
ππ 
i
ππ 
;
ππ 
}
∫∫ 	
static
ºº 
int
ºº *
IndexOfLastNonWhiteSpaceChar
ºº /
(
ºº/ 0
IReadOnlyList
ºº0 =
<
ºº= >
char
ºº> B
>
ººB C
value
ººD I
,
ººI J
int
ººK N
start
ººO T
)
ººT U
{
ΩΩ 	
int
ææ 
i
ææ 
=
ææ 
value
ææ 
.
ææ 
Count
ææ 
-
ææ  !
$num
ææ" #
;
ææ# $
while
øø 
(
øø 
i
øø 
>
øø 
start
øø 
&&
øø 
char
øø  $
.
øø$ %
IsWhiteSpace
øø% 1
(
øø1 2
value
øø2 7
[
øø7 8
i
øø8 9
]
øø9 :
)
øø: ;
)
øø; <
{
¿¿ 
i
¡¡ 
--
¡¡ 
;
¡¡ 
}
¬¬ 
return
ƒƒ 
i
ƒƒ 
;
ƒƒ 
}
≈≈ 	
public
«« 
static
«« 
bool
«« 
Contains
«« #
(
««# $
IReadOnlyList
««$ 1
<
««1 2
char
««2 6
>
««6 7
value
««8 =
,
««= >
char
««? C
c
««D E
)
««E F
{
»» 	
if
…… 
(
…… 
value
…… 
!=
…… 
null
…… 
)
…… 
{
   
int
ÀÀ 
length
ÀÀ 
=
ÀÀ 
value
ÀÀ "
.
ÀÀ" #
Count
ÀÀ# (
;
ÀÀ( )
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ  !
<
ÃÃ" #
length
ÃÃ$ *
;
ÃÃ* +
i
ÃÃ, -
++
ÃÃ- /
)
ÃÃ/ 0
{
ÕÕ 
if
ŒŒ 
(
ŒŒ 
value
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ  
==
ŒŒ! #
c
ŒŒ$ %
)
ŒŒ% &
{
œœ 
return
–– 
true
–– #
;
––# $
}
—— 
}
““ 
}
”” 
return
‘‘ 
false
‘‘ 
;
‘‘ 
}
’’ 	
[
◊◊ 	

MethodImpl
◊◊	 
(
◊◊ 
MethodImplOptions
◊◊ %
.
◊◊% & 
AggressiveInlining
◊◊& 8
)
◊◊8 9
]
◊◊9 :
public
ÿÿ 
static
ÿÿ 
int
ÿÿ 
Digit
ÿÿ 
(
ÿÿ  
byte
ÿÿ  $
b
ÿÿ% &
)
ÿÿ& '
{
ŸŸ 	
const
⁄⁄ 
byte
⁄⁄ 
First
⁄⁄ 
=
⁄⁄ 
(
⁄⁄  
byte
⁄⁄  $
)
⁄⁄$ %
$char
⁄⁄% (
;
⁄⁄( )
const
€€ 
byte
€€ 
Last
€€ 
=
€€ 
(
€€ 
byte
€€ #
)
€€# $
$char
€€$ '
;
€€' (
if
›› 
(
›› 
b
›› 
<
›› 
First
›› 
||
›› 
b
›› 
>
››  
Last
››! %
)
››% &
{
ﬁﬁ 
return
ﬂﬂ 
-
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
return
‚‚ 
b
‚‚ 
-
‚‚ 
First
‚‚ 
;
‚‚ 
}
„„ 	
[
ÂÂ 	

MethodImpl
ÂÂ	 
(
ÂÂ 
MethodImplOptions
ÂÂ %
.
ÂÂ% & 
AggressiveInlining
ÂÂ& 8
)
ÂÂ8 9
]
ÂÂ9 :
public
ÊÊ 
static
ÊÊ 
int
ÊÊ 
Digit
ÊÊ 
(
ÊÊ  
char
ÊÊ  $
c
ÊÊ% &
,
ÊÊ& '
int
ÊÊ( +
radix
ÊÊ, 1
)
ÊÊ1 2
{
ÁÁ 	
if
ËË 
(
ËË 
radix
ËË 
>=
ËË 
MinRadix
ËË !
&&
ËË" $
radix
ËË% *
<=
ËË+ -
MaxRadix
ËË. 6
)
ËË6 7
{
ÈÈ 
if
ÍÍ 
(
ÍÍ 
c
ÍÍ 
<
ÍÍ 
$num
ÍÍ 
)
ÍÍ 
{
ÎÎ 
int
ÏÏ 
result
ÏÏ 
=
ÏÏ  
-
ÏÏ! "
$num
ÏÏ" #
;
ÏÏ# $
if
ÌÌ 
(
ÌÌ 
$char
ÌÌ 
<=
ÌÌ 
c
ÌÌ  
&&
ÌÌ! #
c
ÌÌ$ %
<=
ÌÌ& (
$char
ÌÌ) ,
)
ÌÌ, -
{
ÓÓ 
result
ÔÔ 
=
ÔÔ  
c
ÔÔ! "
-
ÔÔ# $
$char
ÔÔ% (
;
ÔÔ( )
}
 
else
ÒÒ 
if
ÒÒ 
(
ÒÒ 
$char
ÒÒ  
<=
ÒÒ! #
c
ÒÒ$ %
&&
ÒÒ& (
c
ÒÒ) *
<=
ÒÒ+ -
$char
ÒÒ. 1
)
ÒÒ1 2
{
ÚÚ 
result
ÛÛ 
=
ÛÛ  
c
ÛÛ! "
-
ÛÛ# $
(
ÛÛ% &
$char
ÛÛ& )
-
ÛÛ* +
$num
ÛÛ, .
)
ÛÛ. /
;
ÛÛ/ 0
}
ÙÙ 
else
ıı 
if
ıı 
(
ıı 
$char
ıı  
<=
ıı! #
c
ıı$ %
&&
ıı& (
c
ıı) *
<=
ıı+ -
$char
ıı. 1
)
ıı1 2
{
ˆˆ 
result
˜˜ 
=
˜˜  
c
˜˜! "
-
˜˜# $
(
˜˜% &
$char
˜˜& )
-
˜˜* +
$num
˜˜, .
)
˜˜. /
;
˜˜/ 0
}
¯¯ 
return
˙˙ 
result
˙˙ !
<
˙˙" #
radix
˙˙$ )
?
˙˙* +
result
˙˙, 2
:
˙˙3 4
-
˙˙5 6
$num
˙˙6 7
;
˙˙7 8
}
˚˚ 
int
˝˝ 
result1
˝˝ 
=
˝˝ 
BinarySearchRange
˝˝ /
(
˝˝/ 0
	DigitKeys
˝˝0 9
,
˝˝9 :
c
˝˝; <
)
˝˝< =
;
˝˝= >
if
˛˛ 
(
˛˛ 
result1
˛˛ 
>=
˛˛ 
$num
˛˛  
&&
˛˛! #
c
˛˛$ %
<=
˛˛& (
DigitValues
˛˛) 4
[
˛˛4 5
result1
˛˛5 <
*
˛˛= >
$num
˛˛? @
]
˛˛@ A
)
˛˛A B
{
ˇˇ 
int
ÄÄ 
value
ÄÄ 
=
ÄÄ 
(
ÄÄ  !
char
ÄÄ! %
)
ÄÄ% &
(
ÄÄ& '
c
ÄÄ' (
-
ÄÄ) *
DigitValues
ÄÄ+ 6
[
ÄÄ6 7
result1
ÄÄ7 >
*
ÄÄ? @
$num
ÄÄA B
+
ÄÄC D
$num
ÄÄE F
]
ÄÄF G
)
ÄÄG H
;
ÄÄH I
if
ÅÅ 
(
ÅÅ 
value
ÅÅ 
>=
ÅÅ  
radix
ÅÅ! &
)
ÅÅ& '
{
ÇÇ 
return
ÉÉ 
-
ÉÉ  
$num
ÉÉ  !
;
ÉÉ! "
}
ÑÑ 
return
ÖÖ 
value
ÖÖ  
;
ÖÖ  !
}
ÜÜ 
}
áá 
return
ââ 
-
ââ 
$num
ââ 
;
ââ 
}
ää 	
[
åå 	

MethodImpl
åå	 
(
åå 
MethodImplOptions
åå %
.
åå% & 
AggressiveInlining
åå& 8
)
åå8 9
]
åå9 :
public
çç 
static
çç 
bool
çç 
IsISOControl
çç '
(
çç' (
int
çç( +
c
çç, -
)
çç- .
=>
çç/ 1
(
çç2 3
c
çç3 4
>=
çç5 7
$num
çç8 9
&&
çç: <
c
çç= >
<=
çç? A
$num
ççB F
)
ççF G
||
ççH J
(
ççK L
c
ççL M
>=
ççN P
$num
ççQ U
&&
ççV X
c
ççY Z
<=
çç[ ]
$num
çç^ b
)
ççb c
;
ççc d
public
èè 
static
èè 
int
èè 
IndexOf
èè !
(
èè! "
this
èè" &
ICharSequence
èè' 4
cs
èè5 7
,
èè7 8
char
èè9 =

searchChar
èè> H
,
èèH I
int
èèJ M
start
èèN S
)
èèS T
{
êê 	
if
ëë 
(
ëë 
cs
ëë 
==
ëë 
null
ëë 
)
ëë 
{
íí 
return
ìì 
AsciiString
ìì "
.
ìì" #
IndexNotFound
ìì# 0
;
ìì0 1
}
îî 
if
ññ 
(
ññ 
cs
ññ 
is
ññ  
StringCharSequence
ññ (
sequence
ññ) 1
)
ññ1 2
{
óó 
return
òò 
sequence
òò 
.
òò  
IndexOf
òò  '
(
òò' (

searchChar
òò( 2
,
òò2 3
start
òò4 9
)
òò9 :
;
òò: ;
}
ôô 
if
õõ 
(
õõ 
cs
õõ 
is
õõ 
AsciiString
õõ !
s
õõ" #
)
õõ# $
{
úú 
return
ùù 
s
ùù 
.
ùù 
IndexOf
ùù  
(
ùù  !

searchChar
ùù! +
,
ùù+ ,
start
ùù- 2
)
ùù2 3
;
ùù3 4
}
ûû 
int
†† 
sz
†† 
=
†† 
cs
†† 
.
†† 
Count
†† 
;
†† 
if
°° 
(
°° 
start
°° 
<
°° 
$num
°° 
)
°° 
{
¢¢ 
start
££ 
=
££ 
$num
££ 
;
££ 
}
§§ 
for
•• 
(
•• 
int
•• 
i
•• 
=
•• 
start
•• 
;
•• 
i
••  !
<
••" #
sz
••$ &
;
••& '
i
••( )
++
••) +
)
••+ ,
{
¶¶ 
if
ßß 
(
ßß 
cs
ßß 
[
ßß 
i
ßß 
]
ßß 
==
ßß 

searchChar
ßß '
)
ßß' (
{
®® 
return
©© 
i
©© 
;
©© 
}
™™ 
}
´´ 
return
≠≠ 
-
≠≠ 
$num
≠≠ 
;
≠≠ 
}
ÆÆ 	
static
∞∞ 
int
∞∞ 
IndexOf
∞∞ 
(
∞∞ 
char
∞∞ 
[
∞∞  
]
∞∞  !
tokens
∞∞" (
,
∞∞( )
char
∞∞* .
value
∞∞/ 4
)
∞∞4 5
{
±± 	
for
≤≤ 
(
≤≤ 
int
≤≤ 
i
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
i
≤≤ 
<
≤≤ 
tokens
≤≤  &
.
≤≤& '
Length
≤≤' -
;
≤≤- .
i
≤≤/ 0
++
≤≤0 2
)
≤≤2 3
{
≥≥ 
if
¥¥ 
(
¥¥ 
tokens
¥¥ 
[
¥¥ 
i
¥¥ 
]
¥¥ 
==
¥¥  
value
¥¥! &
)
¥¥& '
{
µµ 
return
∂∂ 
i
∂∂ 
;
∂∂ 
}
∑∑ 
}
∏∏ 
return
∫∫ 
-
∫∫ 
$num
∫∫ 
;
∫∫ 
}
ªª 	
public
ΩΩ 
static
ΩΩ 
int
ΩΩ 
CodePointAt
ΩΩ %
(
ΩΩ% &
IReadOnlyList
ΩΩ& 3
<
ΩΩ3 4
char
ΩΩ4 8
>
ΩΩ8 9
seq
ΩΩ: =
,
ΩΩ= >
int
ΩΩ? B
index
ΩΩC H
)
ΩΩH I
{
ææ 	
Contract
øø 
.
øø 
Requires
øø 
(
øø 
seq
øø !
!=
øø" $
null
øø% )
)
øø) *
;
øø* +
Contract
¿¿ 
.
¿¿ 
Requires
¿¿ 
(
¿¿ 
index
¿¿ #
>=
¿¿$ &
$num
¿¿' (
&&
¿¿) +
index
¿¿, 1
<
¿¿2 3
seq
¿¿4 7
.
¿¿7 8
Count
¿¿8 =
)
¿¿= >
;
¿¿> ?
char
¬¬ 
high
¬¬ 
=
¬¬ 
seq
¬¬ 
[
¬¬ 
index
¬¬ !
++
¬¬! #
]
¬¬# $
;
¬¬$ %
if
√√ 
(
√√ 
index
√√ 
>=
√√ 
seq
√√ 
.
√√ 
Count
√√ #
)
√√# $
{
ƒƒ 
return
≈≈ 
high
≈≈ 
;
≈≈ 
}
∆∆ 
char
»» 
low
»» 
=
»» 
seq
»» 
[
»» 
index
»»  
]
»»  !
;
»»! "
return
   
IsSurrogatePair
   "
(
  " #
high
  # '
,
  ' (
low
  ) ,
)
  , -
?
  . /
ToCodePoint
  0 ;
(
  ; <
high
  < @
,
  @ A
low
  B E
)
  E F
:
  G H
high
  I M
;
  M N
}
ÀÀ 	
[
ÕÕ 	

MethodImpl
ÕÕ	 
(
ÕÕ 
MethodImplOptions
ÕÕ %
.
ÕÕ% & 
AggressiveInlining
ÕÕ& 8
)
ÕÕ8 9
]
ÕÕ9 :
public
ŒŒ 
static
ŒŒ 
int
ŒŒ 
ToCodePoint
ŒŒ %
(
ŒŒ% &
char
ŒŒ& *
high
ŒŒ+ /
,
ŒŒ/ 0
char
ŒŒ1 5
low
ŒŒ6 9
)
ŒŒ9 :
{
œœ 	
int
““ 
h
““ 
=
““ 
(
““ 
high
““ 
&
““ 
$num
““ !
)
““! "
<<
““# %
$num
““& (
;
““( )
int
”” 
l
”” 
=
”” 
low
”” 
&
”” 
$num
”” 
;
””  
return
‘‘ 
(
‘‘ 
h
‘‘ 
|
‘‘ 
l
‘‘ 
)
‘‘ 
+
‘‘ 
$num
‘‘ $
;
‘‘$ %
}
’’ 	
[
◊◊ 	

MethodImpl
◊◊	 
(
◊◊ 
MethodImplOptions
◊◊ %
.
◊◊% & 
AggressiveInlining
◊◊& 8
)
◊◊8 9
]
◊◊9 :
static
ÿÿ 
bool
ÿÿ 
IsSurrogatePair
ÿÿ #
(
ÿÿ# $
char
ÿÿ$ (
high
ÿÿ) -
,
ÿÿ- .
char
ÿÿ/ 3
low
ÿÿ4 7
)
ÿÿ7 8
=>
ÿÿ9 ;
char
ÿÿ< @
.
ÿÿ@ A
IsHighSurrogate
ÿÿA P
(
ÿÿP Q
high
ÿÿQ U
)
ÿÿU V
&&
ÿÿW Y
char
ÿÿZ ^
.
ÿÿ^ _
IsLowSurrogate
ÿÿ_ m
(
ÿÿm n
low
ÿÿn q
)
ÿÿq r
;
ÿÿr s
internal
⁄⁄ 
static
⁄⁄ 
int
⁄⁄ 
IndexOf
⁄⁄ #
(
⁄⁄# $
IReadOnlyList
⁄⁄$ 1
<
⁄⁄1 2
char
⁄⁄2 6
>
⁄⁄6 7
value
⁄⁄8 =
,
⁄⁄= >
char
⁄⁄? C
ch
⁄⁄D F
,
⁄⁄F G
int
⁄⁄H K
start
⁄⁄L Q
)
⁄⁄Q R
{
€€ 	
char
‹‹ 
upper
‹‹ 
=
‹‹ 
char
‹‹ 
.
‹‹ 
ToUpper
‹‹ %
(
‹‹% &
ch
‹‹& (
)
‹‹( )
;
‹‹) *
char
›› 
lower
›› 
=
›› 
char
›› 
.
›› 
ToLower
›› %
(
››% &
ch
››& (
)
››( )
;
››) *
int
ﬁﬁ 
i
ﬁﬁ 
=
ﬁﬁ 
start
ﬁﬁ 
;
ﬁﬁ 
while
ﬂﬂ 
(
ﬂﬂ 
i
ﬂﬂ 
<
ﬂﬂ 
value
ﬂﬂ 
.
ﬂﬂ 
Count
ﬂﬂ "
)
ﬂﬂ" #
{
‡‡ 
char
·· 
c1
·· 
=
·· 
value
·· 
[
··  
i
··  !
]
··! "
;
··" #
if
‚‚ 
(
‚‚ 
c1
‚‚ 
==
‚‚ 
ch
‚‚ 
&&
„„ 
char
„„ 
.
„„ 
ToUpper
„„ #
(
„„# $
c1
„„$ &
)
„„& '
.
„„' (
	CompareTo
„„( 1
(
„„1 2
upper
„„2 7
)
„„7 8
!=
„„9 ;
$num
„„< =
&&
‰‰ 
char
‰‰ 
.
‰‰ 
ToLower
‰‰ #
(
‰‰# $
c1
‰‰$ &
)
‰‰& '
.
‰‰' (
	CompareTo
‰‰( 1
(
‰‰1 2
lower
‰‰2 7
)
‰‰7 8
!=
‰‰9 ;
$num
‰‰< =
)
‰‰= >
{
ÂÂ 
return
ÊÊ 
i
ÊÊ 
;
ÊÊ 
}
ÁÁ 
i
ÈÈ 
++
ÈÈ 
;
ÈÈ 
}
ÍÍ 
return
ÏÏ 
-
ÏÏ 
$num
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
}
ÓÓ 
}ÔÔ û1
hC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ConstantPool.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

abstract 
class 
ConstantPool &
{ 
readonly 

Dictionary 
< 
string "
," #
	IConstant$ -
>- .
	constants/ 8
=9 :
new; >

Dictionary? I
<I J
stringJ P
,P Q
	IConstantR [
>[ \
(\ ]
)] ^
;^ _
int 
nextId 
= 
$num 
; 
public 
	IConstant 
ValueOf  
<  !
T! "
>" #
(# $
Type$ (
firstNameComponent) ;
,; <
string= C
secondNameComponentD W
)W X
{ 	
Contract 
. 
Requires 
( 
firstNameComponent 0
!=1 3
null4 8
)8 9
;9 :
Contract 
. 
Requires 
( 
secondNameComponent 1
!=2 4
null5 9
)9 :
;: ;
return 
this 
. 
ValueOf 
<  
T  !
>! "
(" #
firstNameComponent# 5
.5 6
Name6 :
+; <
$char= @
+A B
secondNameComponentC V
)V W
;W X
} 	
public## 
	IConstant## 
ValueOf##  
<##  !
T##! "
>##" #
(### $
string##$ *
name##+ /
)##/ 0
{$$ 	
	IConstant%% 
c%% 
;%% 
lock'' 
('' 
this'' 
.'' 
	constants''  
)''  !
{(( 
if)) 
()) 
this)) 
.)) 
	constants)) "
.))" #
TryGetValue))# .
()). /
name))/ 3
,))3 4
out))5 8
c))9 :
))): ;
))); <
{** 
return++ 
c++ 
;++ 
},, 
else-- 
{.. 
c// 
=// 
this// 
.// 
NewInstance0// )
<//) *
T//* +
>//+ ,
(//, -
name//- 1
)//1 2
;//2 3
}00 
}11 
return33 
c33 
;33 
}44 	
public77 
bool77 
Exists77 
(77 
string77 !
name77" &
)77& '
{88 	#
CheckNotNullAndNotEmpty99 #
(99# $
name99$ (
)99( )
;99) *
lock:: 
(:: 
this:: 
.:: 
	constants::  
)::  !
{;; 
return<< 
this<< 
.<< 
	constants<< %
.<<% &
ContainsKey<<& 1
(<<1 2
name<<2 6
)<<6 7
;<<7 8
}== 
}>> 	
publicDD 
	IConstantDD 
NewInstanceDD $
<DD$ %
TDD% &
>DD& '
(DD' (
stringDD( .
nameDD/ 3
)DD3 4
{EE 	
ifFF 
(FF 
thisFF 
.FF 
ExistsFF 
(FF 
nameFF  
)FF  !
)FF! "
{GG 
throwHH 
newHH 
ArgumentExceptionHH +
(HH+ ,
$"HH, .
$strHH. /
{HH/ 0
nameHH0 4
}HH4 5
$strHH5 H
"HHH I
)HHI J
;HHJ K
}II 
	IConstantKK 
cKK 
=KK 
thisKK 
.KK 
NewInstance0KK +
<KK+ ,
TKK, -
>KK- .
(KK. /
nameKK/ 3
)KK3 4
;KK4 5
returnMM 
cMM 
;MM 
}NN 	
	IConstantQQ 
NewInstance0QQ 
<QQ 
TQQ  
>QQ  !
(QQ! "
stringQQ" (
nameQQ) -
)QQ- .
{RR 	
lockSS 
(SS 
thisSS 
.SS 
	constantsSS  
)SS  !
{TT 
	IConstantUU 
cUU 
=UU 
thisUU "
.UU" #
NewConstantUU# .
<UU. /
TUU/ 0
>UU0 1
(UU1 2
thisUU2 6
.UU6 7
nextIdUU7 =
,UU= >
nameUU? C
)UUC D
;UUD E
thisVV 
.VV 
	constantsVV 
[VV 
nameVV #
]VV# $
=VV% &
cVV' (
;VV( )
thisWW 
.WW 
nextIdWW 
++WW 
;WW 
returnXX 
cXX 
;XX 
}YY 
}ZZ 	
static\\ 
void\\ #
CheckNotNullAndNotEmpty\\ +
(\\+ ,
string\\, 2
name\\3 7
)\\7 8
=>\\9 ;
Contract\\< D
.\\D E
Requires\\E M
(\\M N
!\\N O
string\\O U
.\\U V
IsNullOrEmpty\\V c
(\\c d
name\\d h
)\\h i
)\\i j
;\\j k
	protected^^ 
abstract^^ 
	IConstant^^ $
NewConstant^^% 0
<^^0 1
T^^1 2
>^^2 3
(^^3 4
int^^4 7
id^^8 :
,^^: ;
string^^< B
name^^C G
)^^G H
;^^H I
[`` 	
Obsolete``	 
]`` 
publicaa 
intaa 
NextIdaa 
(aa 
)aa 
{bb 	
lockcc 
(cc 
thiscc 
.cc 
	constantscc  
)cc  !
{dd 
intee 
idee 
=ee 
thisee 
.ee 
nextIdee $
;ee$ %
thisff 
.ff 
nextIdff 
++ff 
;ff 
returngg 
idgg 
;gg 
}hh 
}ii 	
}jj 
}kk ∆
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\DebugExtensions.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public		 

static		 
class		 
DebugExtensions		 '
{

 
public 
static 
string 
ToDebugString *
<* +
TKey+ /
,/ 0
TValue1 7
>7 8
(8 9
this9 =
IDictionary> I
<I J
TKeyJ N
,N O
TValueP V
>V W

dictionaryX b
)b c
{ 	
var 
sb 
= 
new 
StringBuilder &
(& '
)' (
;( )
bool 
first 
= 
true 
; 
foreach 
( 
KeyValuePair !
<! "
TKey" &
,& '
TValue( .
>. /
pair0 4
in5 7

dictionary8 B
)B C
{ 
if 
( 
first 
) 
{ 
first 
= 
false !
;! "
sb 
. 
Append 
( 
$char !
)! "
;" #
} 
else 
{ 
sb 
. 
Append 
( 
$str "
)" #
;# $
} 
sb 
. 
Append 
( 
$str 
) 
.  
Append  &
(& '
pair' +
.+ ,
Key, /
)/ 0
.0 1
Append1 7
(7 8
$str8 =
)= >
.> ?
Append? E
(E F
pairF J
.J K
ValueK P
)P Q
.Q R
AppendR X
(X Y
$charY \
)\ ]
;] ^
} 
return 
sb 
. 
Append 
( 
$char  
)  !
.! "
ToString" *
(* +
)+ ,
;, -
} 	
} 
}   ø{
oC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\DefaultAttributeMap.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

class 
DefaultAttributeMap $
:% &
IAttributeMap' 4
{ 
const 
int 

BucketSize 
= 
$num  
;  !
const 
int 
Mask 
= 

BucketSize #
-$ %
$num& '
;' (
volatile 
DefaultAttribute !
[! "
]" #

attributes$ .
;. /
public 

IAttribute 
< 
T 
> 
GetAttribute )
<) *
T* +
>+ ,
(, -
AttributeKey- 9
<9 :
T: ;
>; <
key= @
)@ A
where 
T 
: 
class 
{ 	
Contract 
. 
Requires 
( 
key !
!=" $
null% )
)) *
;* +
DefaultAttribute 
[ 
] 
attrs $
=% &
this' +
.+ ,

attributes, 6
;6 7
if 
( 
attrs 
== 
null 
) 
{ 
attrs 
= 
new 
DefaultAttribute ,
[, -

BucketSize- 7
]7 8
;8 9
attrs   
=   
Interlocked   #
.  # $
CompareExchange  $ 3
(  3 4
ref  4 7
this  8 <
.  < =

attributes  = G
,  G H
attrs  I N
,  N O
null  P T
)  T U
??  V X
attrs  Y ^
;  ^ _
}!! 
int## 
i## 
=## 
Index## 
(## 
key## 
)## 
;## 
DefaultAttribute$$ 
head$$ !
=$$" #
Volatile$$$ ,
.$$, -
Read$$- 1
($$1 2
ref$$2 5
attrs$$6 ;
[$$; <
i$$< =
]$$= >
)$$> ?
;$$? @
if%% 
(%% 
head%% 
==%% 
null%% 
)%% 
{&& 
head)) 
=)) 
new)) 
DefaultAttribute)) +
<))+ ,
T)), -
>))- .
()). /
key))/ 2
)))2 3
;))3 4
if++ 
(++ 
Interlocked++ 
.++  
CompareExchange++  /
(++/ 0
ref++0 3
this++4 8
.++8 9

attributes++9 C
[++C D
i++D E
]++E F
,++F G
head++H L
,++L M
null++N R
)++R S
==++T V
null++W [
)++[ \
{,, 
return.. 
(.. 

IAttribute.. &
<..& '
T..' (
>..( )
)..) *
head..* .
;... /
}// 
head11 
=11 
Volatile11 
.11  
Read11  $
(11$ %
ref11% (
attrs11) .
[11. /
i11/ 0
]110 1
)111 2
;112 3
}22 
lock44 
(44 
head44 
)44 
{55 
DefaultAttribute66  
curr66! %
=66& '
head66( ,
;66, -
while77 
(77 
true77 
)77 
{88 
if99 
(99 
!99 
curr99 
.99 
Removed99 %
&&99& (
curr99) -
.99- .
GetKey99. 4
(994 5
)995 6
==997 9
key99: =
)99= >
{:: 
return;; 
(;;  

IAttribute;;  *
<;;* +
T;;+ ,
>;;, -
);;- .
curr;;. 2
;;;2 3
}<< 
DefaultAttribute>> $
next>>% )
=>>* +
curr>>, 0
.>>0 1
Next>>1 5
;>>5 6
if?? 
(?? 
next?? 
==?? 
null??  $
)??$ %
{@@ 
varAA 
attrAA  
=AA! "
newAA# &
DefaultAttributeAA' 7
<AA7 8
TAA8 9
>AA9 :
(AA: ;
headAA; ?
,AA? @
keyAAA D
)AAD E
;AAE F
currBB 
.BB 
NextBB !
=BB" #
attrBB$ (
;BB( )
attrCC 
.CC 
PrevCC !
=CC" #
currCC$ (
;CC( )
returnDD 
attrDD #
;DD# $
}EE 
elseFF 
{GG 
currHH 
=HH 
nextHH #
;HH# $
}II 
}JJ 
}KK 
}LL 	
publicNN 
boolNN 
HasAttributeNN  
<NN  !
TNN! "
>NN" #
(NN# $
AttributeKeyNN$ 0
<NN0 1
TNN1 2
>NN2 3
keyNN4 7
)NN7 8
whereOO 
TOO 
:OO 
classOO 
{PP 	
ContractQQ 
.QQ 
RequiresQQ 
(QQ 
keyQQ !
!=QQ" $
nullQQ% )
)QQ) *
;QQ* +
DefaultAttributeSS 
[SS 
]SS 
attrsSS $
=SS% &
thisSS' +
.SS+ ,

attributesSS, 6
;SS6 7
ifTT 
(TT 
attrsTT 
==TT 
nullTT 
)TT 
{UU 
returnWW 
falseWW 
;WW 
}XX 
intZZ 
iZZ 
=ZZ 
IndexZZ 
(ZZ 
keyZZ 
)ZZ 
;ZZ 
DefaultAttribute[[ 
head[[ !
=[[" #
Volatile[[$ ,
.[[, -
Read[[- 1
([[1 2
ref[[2 5
attrs[[6 ;
[[[; <
i[[< =
][[= >
)[[> ?
;[[? @
if\\ 
(\\ 
head\\ 
==\\ 
null\\ 
)\\ 
{]] 
return__ 
false__ 
;__ 
}`` 
ifcc 
(cc 
headcc 
.cc 
GetKeycc 
(cc 
)cc 
==cc  
keycc! $
&&cc% '
!cc( )
headcc) -
.cc- .
Removedcc. 5
)cc5 6
{dd 
returnee 
trueee 
;ee 
}ff 
lockhh 
(hh 
headhh 
)hh 
{ii 
DefaultAttributekk  
currkk! %
=kk& '
headkk( ,
.kk, -
Nextkk- 1
;kk1 2
whilell 
(ll 
currll 
!=ll 
nullll #
)ll# $
{mm 
ifnn 
(nn 
!nn 
currnn 
.nn 
Removednn %
&&nn& (
currnn) -
.nn- .
GetKeynn. 4
(nn4 5
)nn5 6
==nn7 9
keynn: =
)nn= >
{oo 
returnpp 
truepp #
;pp# $
}qq 
currrr 
=rr 
currrr 
.rr  
Nextrr  $
;rr$ %
}ss 
returntt 
falsett 
;tt 
}uu 
}vv 	
staticxx 
intxx 
Indexxx 
<xx 
Txx 
>xx 
(xx 
AttributeKeyxx (
<xx( )
Txx) *
>xx* +
keyxx, /
)xx/ 0
=>xx1 3
keyxx4 7
.xx7 8
Idxx8 :
&xx; <
Maskxx= A
;xxA B
abstractzz 
classzz 
DefaultAttributezz '
{{{ 	
	protected}} 
readonly}} 
DefaultAttribute}} /
Head}}0 4
;}}4 5
public
ÄÄ 
DefaultAttribute
ÄÄ #
Prev
ÄÄ$ (
;
ÄÄ( )
public
ÅÅ 
DefaultAttribute
ÅÅ #
Next
ÅÅ$ (
;
ÅÅ( )
public
ÑÑ 
volatile
ÑÑ 
bool
ÑÑ  
Removed
ÑÑ! (
;
ÑÑ( )
public
ÜÜ 
abstract
ÜÜ 
	IConstant
ÜÜ %
GetKey
ÜÜ& ,
(
ÜÜ, -
)
ÜÜ- .
;
ÜÜ. /
	protected
àà 
DefaultAttribute
àà &
(
àà& '
)
àà' (
{
ââ 
this
ää 
.
ää 
Head
ää 
=
ää 
this
ää  
;
ää  !
}
ãã 
	protected
çç 
DefaultAttribute
çç &
(
çç& '
DefaultAttribute
çç' 7
head
çç8 <
)
çç< =
{
éé 
this
èè 
.
èè 
Head
èè 
=
èè 
head
èè  
;
èè  !
}
êê 
}
ëë 	
sealed
ìì 
class
ìì 
DefaultAttribute
ìì %
<
ìì% &
T
ìì& '
>
ìì' (
:
ìì) *
DefaultAttribute
ìì+ ;
,
ìì; <

IAttribute
ìì= G
<
ììG H
T
ììH I
>
ììI J
where
îî 
T
îî 
:
îî 
class
îî 
{
ïï 	
readonly
ññ 
AttributeKey
ññ !
<
ññ! "
T
ññ" #
>
ññ# $
key
ññ% (
;
ññ( )
T
óó 
value
óó 
;
óó 
public
ôô 
DefaultAttribute
ôô #
(
ôô# $
DefaultAttribute
ôô$ 4
head
ôô5 9
,
ôô9 :
AttributeKey
ôô; G
<
ôôG H
T
ôôH I
>
ôôI J
key
ôôK N
)
ôôN O
:
öö 
base
öö 
(
öö 
head
öö 
)
öö 
{
õõ 
this
úú 
.
úú 
key
úú 
=
úú 
key
úú 
;
úú 
}
ùù 
public
üü 
DefaultAttribute
üü #
(
üü# $
AttributeKey
üü$ 0
<
üü0 1
T
üü1 2
>
üü2 3
key
üü4 7
)
üü7 8
{
†† 
this
°° 
.
°° 
key
°° 
=
°° 
key
°° 
;
°° 
}
¢¢ 
public
§§ 
AttributeKey
§§ 
<
§§  
T
§§  !
>
§§! "
Key
§§# &
=>
§§' )
this
§§* .
.
§§. /
key
§§/ 2
;
§§2 3
public
¶¶ 
T
¶¶ 
Get
¶¶ 
(
¶¶ 
)
¶¶ 
=>
¶¶ 
Volatile
¶¶ &
.
¶¶& '
Read
¶¶' +
(
¶¶+ ,
ref
¶¶, /
this
¶¶0 4
.
¶¶4 5
value
¶¶5 :
)
¶¶: ;
;
¶¶; <
public
®® 
void
®® 
Set
®® 
(
®® 
T
®® 
value
®® #
)
®®# $
=>
®®% '
Volatile
®®( 0
.
®®0 1
Write
®®1 6
(
®®6 7
ref
®®7 :
this
®®; ?
.
®®? @
value
®®@ E
,
®®E F
value
®®G L
)
®®L M
;
®®M N
public
™™ 
T
™™ 
	GetAndSet
™™ 
(
™™ 
T
™™  
value
™™! &
)
™™& '
=>
™™( *
Interlocked
™™+ 6
.
™™6 7
Exchange
™™7 ?
(
™™? @
ref
™™@ C
this
™™D H
.
™™H I
value
™™I N
,
™™N O
value
™™P U
)
™™U V
;
™™V W
public
¨¨ 
T
¨¨ 
SetIfAbsent
¨¨  
(
¨¨  !
T
¨¨! "
value
¨¨# (
)
¨¨( )
{
≠≠ 
while
ÆÆ 
(
ÆÆ 
!
ÆÆ 
this
ÆÆ 
.
ÆÆ 
CompareAndSet
ÆÆ *
(
ÆÆ* +
null
ÆÆ+ /
,
ÆÆ/ 0
value
ÆÆ1 6
)
ÆÆ6 7
)
ÆÆ7 8
{
ØØ 
T
∞∞ 
old
∞∞ 
=
∞∞ 
this
∞∞  
.
∞∞  !
Get
∞∞! $
(
∞∞$ %
)
∞∞% &
;
∞∞& '
if
±± 
(
±± 
old
±± 
!=
±± 
null
±± #
)
±±# $
{
≤≤ 
return
≥≥ 
old
≥≥ "
;
≥≥" #
}
¥¥ 
}
µµ 
return
∂∂ 
default
∂∂ 
(
∂∂ 
T
∂∂  
)
∂∂  !
;
∂∂! "
}
∑∑ 
public
ππ 
T
ππ 
GetAndRemove
ππ !
(
ππ! "
)
ππ" #
{
∫∫ 
this
ªª 
.
ªª 
Removed
ªª 
=
ªª 
true
ªª #
;
ªª# $
T
ºº 
oldValue
ºº 
=
ºº 
this
ºº !
.
ºº! "
	GetAndSet
ºº" +
(
ºº+ ,
null
ºº, 0
)
ºº0 1
;
ºº1 2
this
ΩΩ 
.
ΩΩ 
Remove0
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ 
return
ææ 
oldValue
ææ 
;
ææ  
}
øø 
public
¡¡ 
bool
¡¡ 
CompareAndSet
¡¡ %
(
¡¡% &
T
¡¡& '
oldValue
¡¡( 0
,
¡¡0 1
T
¡¡2 3
newValue
¡¡4 <
)
¡¡< =
=>
¡¡> @
Interlocked
¡¡A L
.
¡¡L M
CompareExchange
¡¡M \
(
¡¡\ ]
ref
¡¡] `
this
¡¡a e
.
¡¡e f
value
¡¡f k
,
¡¡k l
newValue
¡¡m u
,
¡¡u v
oldValue
¡¡w 
)¡¡ Ä
==¡¡Å É
oldValue¡¡Ñ å
;¡¡å ç
public
√√ 
void
√√ 
Remove
√√ 
(
√√ 
)
√√  
{
ƒƒ 
this
≈≈ 
.
≈≈ 
Removed
≈≈ 
=
≈≈ 
true
≈≈ #
;
≈≈# $
this
∆∆ 
.
∆∆ 
Set
∆∆ 
(
∆∆ 
null
∆∆ 
)
∆∆ 
;
∆∆ 
this
«« 
.
«« 
Remove0
«« 
(
«« 
)
«« 
;
«« 
}
»» 
void
   
Remove0
   
(
   
)
   
{
ÀÀ 
lock
ÃÃ 
(
ÃÃ 
this
ÃÃ 
.
ÃÃ 
Head
ÃÃ 
)
ÃÃ  
{
ÕÕ 
if
”” 
(
”” 
this
”” 
.
”” 
Prev
”” !
!=
””" $
null
””% )
)
””) *
{
‘‘ 
this
’’ 
.
’’ 
Prev
’’ !
.
’’! "
Next
’’" &
=
’’' (
this
’’) -
.
’’- .
Next
’’. 2
;
’’2 3
if
◊◊ 
(
◊◊ 
this
◊◊  
.
◊◊  !
Next
◊◊! %
!=
◊◊& (
null
◊◊) -
)
◊◊- .
{
ÿÿ 
this
ŸŸ  
.
ŸŸ  !
Next
ŸŸ! %
.
ŸŸ% &
Prev
ŸŸ& *
=
ŸŸ+ ,
this
ŸŸ- 1
.
ŸŸ1 2
Prev
ŸŸ2 6
;
ŸŸ6 7
}
⁄⁄ 
this
ﬁﬁ 
.
ﬁﬁ 
Prev
ﬁﬁ !
=
ﬁﬁ" #
null
ﬁﬁ$ (
;
ﬁﬁ( )
this
ﬂﬂ 
.
ﬂﬂ 
Next
ﬂﬂ !
=
ﬂﬂ" #
null
ﬂﬂ$ (
;
ﬂﬂ( )
}
‡‡ 
}
·· 
}
‚‚ 
public
‰‰ 
override
‰‰ 
	IConstant
‰‰ %
GetKey
‰‰& ,
(
‰‰, -
)
‰‰- .
=>
‰‰/ 1
this
‰‰2 6
.
‰‰6 7
key
‰‰7 :
;
‰‰: ;
}
ÂÂ 	
}
ÊÊ 
}ÁÁ ç¥
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\HashedWheelTimer.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class 
HashedWheelTimer (
:) *
ITimer+ 1
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory !
.! "
GetInstance" -
<- .
HashedWheelTimer. >
>> ?
(? @
)@ A
;A B
static 
int 
instanceCounter "
;" #
static 
int "
warnedTooManyInstances )
;) *
const 
int 
InstanceCountLimit $
=% &
$num' )
;) *
readonly 
Worker 
worker 
; 
readonly 
Thread 
workerThread $
;$ %
readonly   #
CancellationTokenSource   (#
cancellationTokenSource  ) @
=  A B
new  C F#
CancellationTokenSource  G ^
(  ^ _
)  _ `
;  ` a
const"" 
int"" 
WorkerStateInit"" !
=""" #
$num""$ %
;""% &
const## 
int## 
WorkerStateStarted## $
=##% &
$num##' (
;##( )
const$$ 
int$$ 
WorkerStateShutdown$$ %
=$$& '
$num$$( )
;$$) *
int%% 
workerStateVolatile%% 
=%%  !
WorkerStateInit%%" 1
;%%1 2
readonly'' 
long'' 
tickDuration'' "
;''" #
readonly(( 
HashedWheelBucket(( "
[((" #
]((# $
wheel((% *
;((* +
readonly)) 
int)) 
mask)) 
;)) 
readonly** 
CountdownEvent**  
startTimeInitialized**  4
=**5 6
new**7 :
CountdownEvent**; I
(**I J
$num**J K
)**K L
;**L M
readonly++ 
IQueue++ 
<++ 
HashedWheelTimeout++ *
>++* +
timeouts++, 4
=++5 6
PlatformDependent++7 H
.++H I
NewMpscQueue++I U
<++U V
HashedWheelTimeout++V h
>++h i
(++i j
)++j k
;++k l
readonly,, 
IQueue,, 
<,, 
HashedWheelTimeout,, *
>,,* +
cancelledTimeouts,,, =
=,,> ?
PlatformDependent,,@ Q
.,,Q R
NewMpscQueue,,R ^
<,,^ _
HashedWheelTimeout,,_ q
>,,q r
(,,r s
),,s t
;,,t u
internal-- 
long-- 
PendingTimeouts-- %
;--% &
readonly.. 
long.. 
maxPendingTimeouts.. (
;..( )
long// 
startTimeVolatile// 
;// 
public11 
HashedWheelTimer11 
(11  
)11  !
:22 
this22 
(22 
TimeSpan22 
.22 
FromMilliseconds22 ,
(22, -
$num22- 0
)220 1
,221 2
$num223 6
,226 7
-228 9
$num229 :
)22: ;
{33 	
}44 	
public?? 
HashedWheelTimer?? 
(??  
TimeSpan@@ 
tickInterval@@ !
,@@! "
intAA 
ticksPerWheelAA 
,AA 
longBB 
maxPendingTimeoutsBB #
)BB# $
{CC 	
ifDD 
(DD 
tickIntervalDD 
<=DD 
TimeSpanDD  (
.DD( )
ZeroDD) -
)DD- .
{EE 
throwFF 
newFF 
ArgumentExceptionFF +
(FF+ ,
$"FF, .
{FF. /
nameofFF/ 5
(FF5 6
tickIntervalFF6 B
)FFB C
}FFC D
$strFFD ]
{FF] ^
tickIntervalFF^ j
}FFj k
"FFk l
)FFl m
;FFm n
}GG 
ifHH 
(HH 
MathHH 
.HH 
CeilingHH 
(HH 
tickIntervalHH )
.HH) *
TotalMillisecondsHH* ;
)HH; <
>HH= >
intHH? B
.HHB C
MaxValueHHC K
)HHK L
{II 
throwJJ 
newJJ 
ArgumentExceptionJJ +
(JJ+ ,
$"JJ, .
{JJ. /
nameofJJ/ 5
(JJ5 6
tickIntervalJJ6 B
)JJB C
}JJC D
$strJJD d
{JJd e
intJJe h
.JJh i
MaxValueJJi q
}JJq r
$strJJr v
"JJv w
)JJw x
;JJx y
}KK 
ifLL 
(LL 
ticksPerWheelLL 
<=LL  
$numLL! "
)LL" #
{MM 
throwNN 
newNN 
ArgumentExceptionNN +
(NN+ ,
$"NN, .
{NN. /
nameofNN/ 5
(NN5 6
ticksPerWheelNN6 C
)NNC D
}NND E
$strNNE ^
{NN^ _
ticksPerWheelNN_ l
}NNl m
"NNm n
)NNn o
;NNo p
}OO 
ifPP 
(PP 
ticksPerWheelPP 
>PP 
intPP  #
.PP# $
MaxValuePP$ ,
/PP- .
$numPP/ 0
+PP1 2
$numPP3 4
)PP4 5
{QQ 
throwRR 
newRR '
ArgumentOutOfRangeExceptionRR 5
(RR5 6
$"SS 
{SS 
nameofSS 
(SS 
ticksPerWheelSS +
)SS+ ,
}SS, -
$strSS- L
{SSL M
ticksPerWheelSSM Z
}SSZ [
"SS[ \
)SS\ ]
;SS] ^
}TT 
thisWW 
.WW 
wheelWW 
=WW 
CreateWheelWW $
(WW$ %
ticksPerWheelWW% 2
)WW2 3
;WW3 4
thisXX 
.XX 
workerXX 
=XX 
newXX 
WorkerXX $
(XX$ %
thisXX% )
)XX) *
;XX* +
thisYY 
.YY 
maskYY 
=YY 
thisYY 
.YY 
wheelYY "
.YY" #
LengthYY# )
-YY* +
$numYY, -
;YY- .
this[[ 
.[[ 
tickDuration[[ 
=[[ 
tickInterval[[  ,
.[[, -
Ticks[[- 2
;[[2 3
if^^ 
(^^ 
this^^ 
.^^ 
tickDuration^^ !
>=^^" $
long^^% )
.^^) *
MaxValue^^* 2
/^^3 4
this^^5 9
.^^9 :
wheel^^: ?
.^^? @
Length^^@ F
)^^F G
{__ 
throw`` 
new`` 
ArgumentException`` +
(``+ ,
stringaa 
.aa 
Formataa !
(aa! "
$strbb V
,bbV W
tickIntervalcc $
,cc$ %
longdd 
.dd 
MaxValuedd %
/dd& '
thisdd( ,
.dd, -
wheeldd- 2
.dd2 3
Lengthdd3 9
)dd9 :
)dd: ;
;dd; <
}ee 
thisgg 
.gg 
workerThreadgg 
=gg 
newgg  #
Threadgg$ *
(gg* +
stgg+ -
=>gg. 0
thisgg1 5
.gg5 6
workergg6 <
.gg< =
Rungg= @
(gg@ A
)ggA B
)ggB C
;ggC D
thishh 
.hh 
workerThreadhh 
.hh 
IsBackgroundhh *
=hh+ ,
truehh- 1
;hh1 2
thisjj 
.jj 
maxPendingTimeoutsjj #
=jj$ %
maxPendingTimeoutsjj& 8
;jj8 9
ifll 
(ll 
Interlockedll 
.ll 
	Incrementll %
(ll% &
refll& )
instanceCounterll* 9
)ll9 :
>ll; <
InstanceCountLimitll= O
&&llP R
Interlockedmm 
.mm 
CompareExchangemm +
(mm+ ,
refmm, /"
warnedTooManyInstancesmm0 F
,mmF G
$nummmH I
,mmI J
$nummmK L
)mmL M
==mmN P
$nummmQ R
)mmR S
{nn "
ReportTooManyInstancesoo &
(oo& '
)oo' (
;oo( )
}pp 
}qq 	
~ss 	
HashedWheelTimerss	 
(ss 
)ss 
{tt 	
ifww 
(ww 
Interlockedww 
.ww 
Exchangeww $
(ww$ %
refww% (
thisww) -
.ww- .
workerStateVolatileww. A
,wwA B
WorkerStateShutdownwwC V
)wwV W
!=wwX Z
WorkerStateShutdownww[ n
)wwn o
{xx 
Interlockedyy 
.yy 
	Decrementyy %
(yy% &
refyy& )
instanceCounteryy* 9
)yy9 :
;yy: ;
}zz 
}{{ 	
internal}} 
CancellationToken}} "
CancellationToken}}# 4
=>}}5 7
this}}8 <
.}}< =#
cancellationTokenSource}}= T
.}}T U
Token}}U Z
;}}Z [
bool 
ShouldLimitTimeouts  
=>! #
this$ (
.( )
maxPendingTimeouts) ;
>< =
$num> ?
;? @
PreciseTimeSpan
ÅÅ 
	StartTime
ÅÅ !
{
ÇÇ 	
get
ÉÉ 
=>
ÉÉ 
PreciseTimeSpan
ÉÉ "
.
ÉÉ" #
	FromTicks
ÉÉ# ,
(
ÉÉ, -
Volatile
ÉÉ- 5
.
ÉÉ5 6
Read
ÉÉ6 :
(
ÉÉ: ;
ref
ÉÉ; >
this
ÉÉ? C
.
ÉÉC D
startTimeVolatile
ÉÉD U
)
ÉÉU V
)
ÉÉV W
;
ÉÉW X
set
ÑÑ 
=>
ÑÑ 
Volatile
ÑÑ 
.
ÑÑ 
Write
ÑÑ !
(
ÑÑ! "
ref
ÑÑ" %
this
ÑÑ& *
.
ÑÑ* +
startTimeVolatile
ÑÑ+ <
,
ÑÑ< =
value
ÑÑ> C
.
ÑÑC D
Ticks
ÑÑD I
)
ÑÑI J
;
ÑÑJ K
}
ÖÖ 	
int
áá 
WorkerState
áá 
=>
áá 
Volatile
áá #
.
áá# $
Read
áá$ (
(
áá( )
ref
áá) ,
this
áá- 1
.
áá1 2!
workerStateVolatile
áá2 E
)
ááE F
;
ááF G
static
ââ 
HashedWheelBucket
ââ  
[
ââ  !
]
ââ! "
CreateWheel
ââ# .
(
ââ. /
int
ââ/ 2
ticksPerWheel
ââ3 @
)
ââ@ A
{
ää 	
ticksPerWheel
ãã 
=
ãã $
NormalizeTicksPerWheel
ãã 2
(
ãã2 3
ticksPerWheel
ãã3 @
)
ãã@ A
;
ããA B
var
åå 
wheel
åå 
=
åå 
new
åå 
HashedWheelBucket
åå -
[
åå- .
ticksPerWheel
åå. ;
]
åå; <
;
åå< =
for
çç 
(
çç 
int
çç 
i
çç 
=
çç 
$num
çç 
;
çç 
i
çç 
<
çç 
wheel
çç  %
.
çç% &
Length
çç& ,
;
çç, -
i
çç. /
++
çç/ 1
)
çç1 2
{
éé 
wheel
èè 
[
èè 
i
èè 
]
èè 
=
èè 
new
èè 
HashedWheelBucket
èè 0
(
èè0 1
)
èè1 2
;
èè2 3
}
êê 
return
ëë 
wheel
ëë 
;
ëë 
}
íí 	
static
îî 
int
îî $
NormalizeTicksPerWheel
îî )
(
îî) *
int
îî* -
ticksPerWheel
îî. ;
)
îî; <
{
ïï 	
int
ññ %
normalizedTicksPerWheel
ññ '
=
ññ( )
$num
ññ* +
;
ññ+ ,
while
óó 
(
óó %
normalizedTicksPerWheel
óó *
<
óó+ ,
ticksPerWheel
óó- :
)
óó: ;
{
òò %
normalizedTicksPerWheel
ôô '
<<=
ôô( +
$num
ôô, -
;
ôô- .
}
öö 
return
õõ %
normalizedTicksPerWheel
õõ *
;
õõ* +
}
úú 	
public
§§ 
void
§§ 
Start
§§ 
(
§§ 
)
§§ 
{
•• 	
switch
¶¶ 
(
¶¶ 
this
¶¶ 
.
¶¶ 
WorkerState
¶¶ $
)
¶¶$ %
{
ßß 
case
®® 
WorkerStateInit
®® $
:
®®$ %
if
©© 
(
©© 
Interlocked
©© #
.
©©# $
CompareExchange
©©$ 3
(
©©3 4
ref
©©4 7
this
©©8 <
.
©©< =!
workerStateVolatile
©©= P
,
©©P Q 
WorkerStateStarted
©©R d
,
©©d e
WorkerStateInit
©©f u
)
©©u v
==
©©w y
WorkerStateInit©©z â
)©©â ä
{
™™ 
this
´´ 
.
´´ 
workerThread
´´ )
.
´´) *
Start
´´* /
(
´´/ 0
)
´´0 1
;
´´1 2
}
¨¨ 
break
≠≠ 
;
≠≠ 
case
ÆÆ  
WorkerStateStarted
ÆÆ '
:
ÆÆ' (
break
ØØ 
;
ØØ 
case
∞∞ !
WorkerStateShutdown
∞∞ (
:
∞∞( )
throw
±± 
new
±± '
InvalidOperationException
±± 7
(
±±7 8
$str
±±8 X
)
±±X Y
;
±±Y Z
default
≤≤ 
:
≤≤ 
throw
≥≥ 
new
≥≥ '
InvalidOperationException
≥≥ 7
(
≥≥7 8
$str
≥≥8 M
)
≥≥M N
;
≥≥N O
}
¥¥ 
if
∑∑ 
(
∑∑ 
this
∑∑ 
.
∑∑ 
	StartTime
∑∑ 
==
∑∑ !
PreciseTimeSpan
∑∑" 1
.
∑∑1 2
Zero
∑∑2 6
)
∑∑6 7
{
∏∏ 
this
ππ 
.
ππ "
startTimeInitialized
ππ )
.
ππ) *
Wait
ππ* .
(
ππ. /
this
ππ/ 3
.
ππ3 4
CancellationToken
ππ4 E
)
ππE F
;
ππF G
}
∫∫ 
}
ªª 	
public
ΩΩ 
async
ΩΩ 
Task
ΩΩ 
<
ΩΩ 
ISet
ΩΩ 
<
ΩΩ 
ITimeout
ΩΩ '
>
ΩΩ' (
>
ΩΩ( )
	StopAsync
ΩΩ* 3
(
ΩΩ3 4
)
ΩΩ4 5
{
ææ 	
GC
øø 
.
øø 
SuppressFinalize
øø 
(
øø  
this
øø  $
)
øø$ %
;
øø% &
if
¡¡ 
(
¡¡ 
Thread
¡¡ 
.
¡¡ 
CurrentThread
¡¡ $
==
¡¡% '
this
¡¡( ,
.
¡¡, -
workerThread
¡¡- 9
)
¡¡9 :
{
¬¬ 
throw
√√ 
new
√√ '
InvalidOperationException
√√ 3
(
√√3 4
$"
√√4 6
{
√√6 7
nameof
√√7 =
(
√√= >
HashedWheelTimer
√√> N
)
√√N O
}
√√O P
$str
√√P y
"
√√y z
)
√√z {
;
√√{ |
}
ƒƒ 
if
∆∆ 
(
∆∆ 
Interlocked
∆∆ 
.
∆∆ 
CompareExchange
∆∆ +
(
∆∆+ ,
ref
∆∆, /
this
∆∆0 4
.
∆∆4 5!
workerStateVolatile
∆∆5 H
,
∆∆H I!
WorkerStateShutdown
∆∆J ]
,
∆∆] ^ 
WorkerStateStarted
∆∆_ q
)
∆∆q r
!=
∆∆s u!
WorkerStateStarted∆∆v à
)∆∆à â
{
«« 
if
…… 
(
…… 
Interlocked
…… 
.
……  
Exchange
……  (
(
……( )
ref
……) ,
this
……- 1
.
……1 2!
workerStateVolatile
……2 E
,
……E F!
WorkerStateShutdown
……G Z
)
……Z [
!=
……\ ^!
WorkerStateShutdown
……_ r
)
……r s
{
   
this
ÀÀ 
.
ÀÀ %
cancellationTokenSource
ÀÀ 0
.
ÀÀ0 1
Cancel
ÀÀ1 7
(
ÀÀ7 8
)
ÀÀ8 9
;
ÀÀ9 :
Interlocked
ÃÃ 
.
ÃÃ  
	Decrement
ÃÃ  )
(
ÃÃ) *
ref
ÃÃ* -
instanceCounter
ÃÃ. =
)
ÃÃ= >
;
ÃÃ> ?
}
ÕÕ 
return
œœ 
new
œœ 
HashSet
œœ "
<
œœ" #
ITimeout
œœ# +
>
œœ+ ,
(
œœ, -
)
œœ- .
;
œœ. /
}
–– 
try
““ 
{
”” 
this
‘‘ 
.
‘‘ %
cancellationTokenSource
‘‘ ,
.
‘‘, -
Cancel
‘‘- 3
(
‘‘3 4
)
‘‘4 5
;
‘‘5 6
}
’’ 
finally
÷÷ 
{
◊◊ 
Interlocked
ÿÿ 
.
ÿÿ 
	Decrement
ÿÿ %
(
ÿÿ% &
ref
ÿÿ& )
instanceCounter
ÿÿ* 9
)
ÿÿ9 :
;
ÿÿ: ;
}
ŸŸ 
await
⁄⁄ 
this
⁄⁄ 
.
⁄⁄ 
worker
⁄⁄ 
.
⁄⁄ 
ClosedFuture
⁄⁄ *
;
⁄⁄* +
return
€€ 
this
€€ 
.
€€ 
worker
€€ 
.
€€ !
UnprocessedTimeouts
€€ 2
;
€€2 3
}
‹‹ 	
public
ﬁﬁ 
ITimeout
ﬁﬁ 

NewTimeout
ﬁﬁ "
(
ﬁﬁ" #

ITimerTask
ﬁﬁ# -
task
ﬁﬁ. 2
,
ﬁﬁ2 3
TimeSpan
ﬁﬁ4 <
delay
ﬁﬁ= B
)
ﬁﬁB C
{
ﬂﬂ 	
if
‡‡ 
(
‡‡ 
task
‡‡ 
==
‡‡ 
null
‡‡ 
)
‡‡ 
{
·· 
throw
‚‚ 
new
‚‚ #
ArgumentNullException
‚‚ /
(
‚‚/ 0
nameof
‚‚0 6
(
‚‚6 7
task
‚‚7 ;
)
‚‚; <
)
‚‚< =
;
‚‚= >
}
„„ 
if
‰‰ 
(
‰‰ 
this
‰‰ 
.
‰‰ 
WorkerState
‰‰  
==
‰‰! #!
WorkerStateShutdown
‰‰$ 7
)
‰‰7 8
{
ÂÂ 
throw
ÊÊ 
new
ÊÊ (
RejectedExecutionException
ÊÊ 4
(
ÊÊ4 5
$str
ÊÊ5 p
)
ÊÊp q
;
ÊÊq r
}
ÁÁ 
if
ËË 
(
ËË 
this
ËË 
.
ËË !
ShouldLimitTimeouts
ËË (
)
ËË( )
{
ÈÈ 
long
ÍÍ "
pendingTimeoutsCount
ÍÍ )
=
ÍÍ* +
Interlocked
ÍÍ, 7
.
ÍÍ7 8
	Increment
ÍÍ8 A
(
ÍÍA B
ref
ÍÍB E
this
ÍÍF J
.
ÍÍJ K
PendingTimeouts
ÍÍK Z
)
ÍÍZ [
;
ÍÍ[ \
if
ÎÎ 
(
ÎÎ "
pendingTimeoutsCount
ÎÎ (
>
ÎÎ) *
this
ÎÎ+ /
.
ÎÎ/ 0 
maxPendingTimeouts
ÎÎ0 B
)
ÎÎB C
{
ÏÏ 
Interlocked
ÌÌ 
.
ÌÌ  
	Decrement
ÌÌ  )
(
ÌÌ) *
ref
ÌÌ* -
this
ÌÌ. 2
.
ÌÌ2 3
PendingTimeouts
ÌÌ3 B
)
ÌÌB C
;
ÌÌC D
throw
ÓÓ 
new
ÓÓ (
RejectedExecutionException
ÓÓ 8
(
ÓÓ8 9
$"
ÓÓ9 ;
$str
ÓÓ; W
{
ÓÓW X"
pendingTimeoutsCount
ÓÓX l
}
ÓÓl m
$strÓÓm ≠
{ÓÓ≠ Æ
thisÓÓÆ ≤
.ÓÓ≤ ≥"
maxPendingTimeoutsÓÓ≥ ≈
}ÓÓ≈ ∆
$strÓÓ∆ «
"ÓÓ« »
)ÓÓ» …
;ÓÓ…  
}
ÔÔ 
}
 
this
ÚÚ 
.
ÚÚ 
Start
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ 
TimeSpan
ˆˆ 
deadline
ˆˆ 
=
ˆˆ (
CeilTimeSpanToMilliseconds
ˆˆ  :
(
ˆˆ: ;
(
ˆˆ; <
PreciseTimeSpan
ˆˆ< K
.
ˆˆK L
Deadline
ˆˆL T
(
ˆˆT U
delay
ˆˆU Z
)
ˆˆZ [
-
ˆˆ\ ]
this
ˆˆ^ b
.
ˆˆb c
	StartTime
ˆˆc l
)
ˆˆl m
.
ˆˆm n

ToTimeSpan
ˆˆn x
(
ˆˆx y
)
ˆˆy z
)
ˆˆz {
;
ˆˆ{ |
var
˜˜ 
timeout
˜˜ 
=
˜˜ 
new
˜˜  
HashedWheelTimeout
˜˜ 0
(
˜˜0 1
this
˜˜1 5
,
˜˜5 6
task
˜˜7 ;
,
˜˜; <
deadline
˜˜= E
)
˜˜E F
;
˜˜F G
this
¯¯ 
.
¯¯ 
timeouts
¯¯ 
.
¯¯ 

TryEnqueue
¯¯ $
(
¯¯$ %
timeout
¯¯% ,
)
¯¯, -
;
¯¯- .
return
˘˘ 
timeout
˘˘ 
;
˘˘ 
}
˙˙ 	
void
¸¸ "
ScheduleCancellation
¸¸ !
(
¸¸! " 
HashedWheelTimeout
¸¸" 4
timeout
¸¸5 <
)
¸¸< =
{
˝˝ 	
if
˛˛ 
(
˛˛ 
this
˛˛ 
.
˛˛ 
WorkerState
˛˛  
!=
˛˛! #!
WorkerStateShutdown
˛˛$ 7
)
˛˛7 8
{
ˇˇ 
this
ÄÄ 
.
ÄÄ 
cancelledTimeouts
ÄÄ &
.
ÄÄ& '

TryEnqueue
ÄÄ' 1
(
ÄÄ1 2
timeout
ÄÄ2 9
)
ÄÄ9 :
;
ÄÄ: ;
}
ÅÅ 
}
ÇÇ 	
static
ÑÑ 
void
ÑÑ $
ReportTooManyInstances
ÑÑ *
(
ÑÑ* +
)
ÑÑ+ ,
=>
ÑÑ- /
Logger
ÖÖ 
.
ÖÖ 
Error
ÖÖ 
(
ÖÖ 
$"
ÖÖ 
$str
ÖÖ 5
{
ÖÖ5 6
nameof
ÖÖ6 <
(
ÖÖ< =
HashedWheelTimer
ÖÖ= M
)
ÖÖM N
}
ÖÖN O
$str
ÖÖO [
{
ÖÖ[ \
nameof
ÖÖ\ b
(
ÖÖb c
HashedWheelTimer
ÖÖc s
)
ÖÖs t
}
ÖÖt u
$strÖÖu €
"ÖÖ€ ‹
)ÖÖ‹ ›
;ÖÖ› ﬁ
static
áá 
TimeSpan
áá (
CeilTimeSpanToMilliseconds
áá 2
(
áá2 3
TimeSpan
áá3 ;
time
áá< @
)
áá@ A
{
àà 	
long
ââ 
	remainder
ââ 
=
ââ 
time
ââ !
.
ââ! "
Ticks
ââ" '
%
ââ( )
TimeSpan
ââ* 2
.
ââ2 3!
TicksPerMillisecond
ââ3 F
;
ââF G
return
ää 
	remainder
ää 
==
ää 
$num
ää  !
?
ää" #
time
ää$ (
:
ää) *
new
ää+ .
TimeSpan
ää/ 7
(
ää7 8
time
ää8 <
.
ää< =
Ticks
ää= B
-
ääC D
	remainder
ääE N
+
ääO P
TimeSpan
ääQ Y
.
ääY Z!
TicksPerMillisecond
ääZ m
)
ääm n
;
ään o
}
ãã 	
sealed
çç 
class
çç 
Worker
çç 
:
çç 
	IRunnable
çç '
{
éé 	
readonly
èè 
HashedWheelTimer
èè %
owner
èè& +
;
èè+ ,
long
ëë 
tick
ëë 
;
ëë 
readonly
íí "
TaskCompletionSource
íí )
closedPromise
íí* 7
;
íí7 8
public
îî 
Worker
îî 
(
îî 
HashedWheelTimer
îî *
owner
îî+ 0
)
îî0 1
{
ïï 
this
ññ 
.
ññ 
owner
ññ 
=
ññ 
owner
ññ "
;
ññ" #
this
óó 
.
óó 
closedPromise
óó "
=
óó# $
new
óó% ("
TaskCompletionSource
óó) =
(
óó= >
)
óó> ?
;
óó? @
}
òò 
public
öö 
Task
öö 
ClosedFuture
öö $
=>
öö% '
this
öö( ,
.
öö, -
closedPromise
öö- :
.
öö: ;
Task
öö; ?
;
öö? @
public
úú 
void
úú 
Run
úú 
(
úú 
)
úú 
{
ùù 
try
ûû 
{
üü 
this
°° 
.
°° 
owner
°° 
.
°° 
	StartTime
°° (
=
°°) *
PreciseTimeSpan
°°+ :
.
°°: ;
	FromStart
°°; D
;
°°D E
if
¢¢ 
(
¢¢ 
this
¢¢ 
.
¢¢ 
owner
¢¢ "
.
¢¢" #
	StartTime
¢¢# ,
==
¢¢- /
PreciseTimeSpan
¢¢0 ?
.
¢¢? @
Zero
¢¢@ D
)
¢¢D E
{
££ 
this
•• 
.
•• 
owner
•• "
.
••" #
	StartTime
••# ,
=
••- .
PreciseTimeSpan
••/ >
.
••> ?
	FromTicks
••? H
(
••H I
$num
••I J
)
••J K
;
••K L
}
¶¶ 
this
©© 
.
©© 
owner
©© 
.
©© "
startTimeInitialized
©© 3
.
©©3 4
Signal
©©4 :
(
©©: ;
)
©©; <
;
©©< =
while
´´ 
(
´´ 
true
´´ 
)
´´  
{
¨¨ 
TimeSpan
≠≠  
deadline
≠≠! )
=
≠≠* +
this
≠≠, 0
.
≠≠0 1
WaitForNextTick
≠≠1 @
(
≠≠@ A
)
≠≠A B
;
≠≠B C
if
ÆÆ 
(
ÆÆ 
Volatile
ÆÆ $
.
ÆÆ$ %
Read
ÆÆ% )
(
ÆÆ) *
ref
ÆÆ* -
this
ÆÆ. 2
.
ÆÆ2 3
owner
ÆÆ3 8
.
ÆÆ8 9!
workerStateVolatile
ÆÆ9 L
)
ÆÆL M
!=
ÆÆN P 
WorkerStateStarted
ÆÆQ c
)
ÆÆc d
{
ØØ 
break
∞∞ !
;
∞∞! "
}
±± 
if
≤≤ 
(
≤≤ 
deadline
≤≤ $
>
≤≤% &
TimeSpan
≤≤' /
.
≤≤/ 0
Zero
≤≤0 4
)
≤≤4 5
{
≥≥ 
int
¥¥ 
idx
¥¥  #
=
¥¥$ %
(
¥¥& '
int
¥¥' *
)
¥¥* +
(
¥¥+ ,
this
¥¥, 0
.
¥¥0 1
tick
¥¥1 5
&
¥¥6 7
this
¥¥8 <
.
¥¥< =
owner
¥¥= B
.
¥¥B C
mask
¥¥C G
)
¥¥G H
;
¥¥H I
this
µµ  
.
µµ  !#
ProcessCancelledTasks
µµ! 6
(
µµ6 7
)
µµ7 8
;
µµ8 9
HashedWheelBucket
∂∂ -
bucket
∂∂. 4
=
∂∂5 6
this
∂∂7 ;
.
∂∂; <
owner
∂∂< A
.
∂∂A B
wheel
∂∂B G
[
∂∂G H
idx
∂∂H K
]
∂∂K L
;
∂∂L M
this
∑∑  
.
∑∑  !'
TransferTimeoutsToBuckets
∑∑! :
(
∑∑: ;
)
∑∑; <
;
∑∑< =
bucket
∏∏ "
.
∏∏" #
ExpireTimeouts
∏∏# 1
(
∏∏1 2
deadline
∏∏2 :
)
∏∏: ;
;
∏∏; <
this
ππ  
.
ππ  !
tick
ππ! %
++
ππ% '
;
ππ' (
}
∫∫ 
}
ªª 
foreach
ææ 
(
ææ 
HashedWheelBucket
ææ .
bucket
ææ/ 5
in
ææ6 8
this
ææ9 =
.
ææ= >
owner
ææ> C
.
ææC D
wheel
ææD I
)
ææI J
{
øø 
bucket
¿¿ 
.
¿¿ 
ClearTimeouts
¿¿ ,
(
¿¿, -
this
¿¿- 1
.
¿¿1 2!
UnprocessedTimeouts
¿¿2 E
)
¿¿E F
;
¿¿F G
}
¡¡ 
while
¬¬ 
(
¬¬ 
this
¬¬ 
.
¬¬  
owner
¬¬  %
.
¬¬% &
timeouts
¬¬& .
.
¬¬. /

TryDequeue
¬¬/ 9
(
¬¬9 :
out
¬¬: =
var
¬¬> A
timeout
¬¬B I
)
¬¬I J
)
¬¬J K
{
√√ 
if
ƒƒ 
(
ƒƒ 
!
ƒƒ 
timeout
ƒƒ $
.
ƒƒ$ %
Canceled
ƒƒ% -
)
ƒƒ- .
{
≈≈ 
this
∆∆  
.
∆∆  !!
UnprocessedTimeouts
∆∆! 4
.
∆∆4 5
Add
∆∆5 8
(
∆∆8 9
timeout
∆∆9 @
)
∆∆@ A
;
∆∆A B
}
«« 
}
»» 
this
…… 
.
…… #
ProcessCancelledTasks
…… .
(
……. /
)
……/ 0
;
……0 1
}
   
catch
ÀÀ 
(
ÀÀ 
	Exception
ÀÀ  
ex
ÀÀ! #
)
ÀÀ# $
{
ÃÃ 
Logger
ÕÕ 
.
ÕÕ 
Error
ÕÕ  
(
ÕÕ  !
$str
ÕÕ! =
,
ÕÕ= >
ex
ÕÕ? A
)
ÕÕA B
;
ÕÕB C
}
ŒŒ 
finally
œœ 
{
–– 
this
—— 
.
—— 
closedPromise
—— &
.
——& '
TryComplete
——' 2
(
——2 3
)
——3 4
;
——4 5
}
““ 
}
”” 
void
’’ '
TransferTimeoutsToBuckets
’’ *
(
’’* +
)
’’+ ,
{
÷÷ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ  !
<
ŸŸ" #
$num
ŸŸ$ *
;
ŸŸ* +
i
ŸŸ, -
++
ŸŸ- /
)
ŸŸ/ 0
{
⁄⁄  
HashedWheelTimeout
€€ &
timeout
€€' .
;
€€. /
if
‹‹ 
(
‹‹ 
!
‹‹ 
this
‹‹ 
.
‹‹ 
owner
‹‹ #
.
‹‹# $
timeouts
‹‹$ ,
.
‹‹, -

TryDequeue
‹‹- 7
(
‹‹7 8
out
‹‹8 ;
timeout
‹‹< C
)
‹‹C D
)
‹‹D E
{
›› 
break
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
if
·· 
(
·· 
timeout
·· 
.
··  
State
··  %
==
··& ( 
HashedWheelTimeout
··) ;
.
··; <

StCanceled
··< F
)
··F G
{
‚‚ 
continue
‰‰  
;
‰‰  !
}
ÂÂ 
long
ÁÁ 

calculated
ÁÁ #
=
ÁÁ$ %
timeout
ÁÁ& -
.
ÁÁ- .
Deadline
ÁÁ. 6
.
ÁÁ6 7
Ticks
ÁÁ7 <
/
ÁÁ= >
this
ÁÁ? C
.
ÁÁC D
owner
ÁÁD I
.
ÁÁI J
tickDuration
ÁÁJ V
;
ÁÁV W
timeout
ËË 
.
ËË 
RemainingRounds
ËË +
=
ËË, -
(
ËË. /

calculated
ËË/ 9
-
ËË: ;
this
ËË< @
.
ËË@ A
tick
ËËA E
)
ËËE F
/
ËËG H
this
ËËI M
.
ËËM N
owner
ËËN S
.
ËËS T
wheel
ËËT Y
.
ËËY Z
Length
ËËZ `
;
ËË` a
long
ÍÍ 
ticks
ÍÍ 
=
ÍÍ  
Math
ÍÍ! %
.
ÍÍ% &
Max
ÍÍ& )
(
ÍÍ) *

calculated
ÍÍ* 4
,
ÍÍ4 5
this
ÍÍ6 :
.
ÍÍ: ;
tick
ÍÍ; ?
)
ÍÍ? @
;
ÍÍ@ A
int
ÎÎ 
	stopIndex
ÎÎ !
=
ÎÎ" #
(
ÎÎ$ %
int
ÎÎ% (
)
ÎÎ( )
(
ÎÎ) *
ticks
ÎÎ* /
&
ÎÎ0 1
this
ÎÎ2 6
.
ÎÎ6 7
owner
ÎÎ7 <
.
ÎÎ< =
mask
ÎÎ= A
)
ÎÎA B
;
ÎÎB C
HashedWheelBucket
ÌÌ %
bucket
ÌÌ& ,
=
ÌÌ- .
this
ÌÌ/ 3
.
ÌÌ3 4
owner
ÌÌ4 9
.
ÌÌ9 :
wheel
ÌÌ: ?
[
ÌÌ? @
	stopIndex
ÌÌ@ I
]
ÌÌI J
;
ÌÌJ K
bucket
ÓÓ 
.
ÓÓ 

AddTimeout
ÓÓ %
(
ÓÓ% &
timeout
ÓÓ& -
)
ÓÓ- .
;
ÓÓ. /
}
ÔÔ 
}
 
void
ÚÚ #
ProcessCancelledTasks
ÚÚ &
(
ÚÚ& '
)
ÚÚ' (
{
ÛÛ 
while
ÙÙ 
(
ÙÙ 
true
ÙÙ 
)
ÙÙ 
{
ıı  
HashedWheelTimeout
ˆˆ &
timeout
ˆˆ' .
;
ˆˆ. /
if
˜˜ 
(
˜˜ 
!
˜˜ 
this
˜˜ 
.
˜˜ 
owner
˜˜ #
.
˜˜# $
cancelledTimeouts
˜˜$ 5
.
˜˜5 6

TryDequeue
˜˜6 @
(
˜˜@ A
out
˜˜A D
timeout
˜˜E L
)
˜˜L M
)
˜˜M N
{
¯¯ 
break
˙˙ 
;
˙˙ 
}
˚˚ 
try
¸¸ 
{
˝˝ 
timeout
˛˛ 
.
˛˛  
Remove
˛˛  &
(
˛˛& '
)
˛˛' (
;
˛˛( )
}
ˇˇ 
catch
ÄÄ 
(
ÄÄ 
	Exception
ÄÄ $
ex
ÄÄ% '
)
ÄÄ' (
{
ÅÅ 
if
ÇÇ 
(
ÇÇ 
Logger
ÇÇ "
.
ÇÇ" #
WarnEnabled
ÇÇ# .
)
ÇÇ. /
{
ÉÉ 
Logger
ÑÑ "
.
ÑÑ" #
Warn
ÑÑ# '
(
ÑÑ' (
$str
ÑÑ( f
,
ÑÑf g
ex
ÑÑh j
)
ÑÑj k
;
ÑÑk l
}
ÖÖ 
}
ÜÜ 
}
áá 
}
àà 
TimeSpan
ëë 
WaitForNextTick
ëë $
(
ëë$ %
)
ëë% &
{
íí 
long
ìì 
deadline
ìì 
=
ìì 
this
ìì  $
.
ìì$ %
owner
ìì% *
.
ìì* +
tickDuration
ìì+ 7
*
ìì8 9
(
ìì: ;
this
ìì; ?
.
ìì? @
tick
ìì@ D
+
ììE F
$num
ììG H
)
ììH I
;
ììI J
while
ïï 
(
ïï 
true
ïï 
)
ïï 
{
ññ 
TimeSpan
óó 
currentTime
óó (
=
óó) *
(
óó+ ,
PreciseTimeSpan
óó, ;
.
óó; <
	FromStart
óó< E
-
óóF G
this
óóH L
.
óóL M
owner
óóM R
.
óóR S
	StartTime
óóS \
)
óó\ ]
.
óó] ^

ToTimeSpan
óó^ h
(
óóh i
)
óói j
;
óój k
TimeSpan
òò 
	sleepTime
òò &
=
òò' ((
CeilTimeSpanToMilliseconds
òò) C
(
òòC D
TimeSpan
òòD L
.
òòL M
	FromTicks
òòM V
(
òòV W
deadline
òòW _
-
òò` a
currentTime
òòb m
.
òòm n
Ticks
òòn s
)
òòs t
)
òòt u
;
òòu v
if
öö 
(
öö 
	sleepTime
öö !
<=
öö" $
TimeSpan
öö% -
.
öö- .
Zero
öö. 2
)
öö2 3
{
õõ 
return
úú 
currentTime
úú *
.
úú* +
Ticks
úú+ 0
==
úú1 3
long
úú4 8
.
úú8 9
MinValue
úú9 A
?
ùù 
TimeSpan
ùù &
.
ùù& '
	FromTicks
ùù' 0
(
ùù0 1
-
ùù1 2
long
ùù2 6
.
ùù6 7
MaxValue
ùù7 ?
)
ùù? @
:
ûû 
currentTime
ûû )
;
ûû) *
}
üü 
Task
°° 
delay
°° 
=
°°  
null
°°! %
;
°°% &
try
¢¢ 
{
££ 
long
§§ 
sleepTimeMs
§§ (
=
§§) *
	sleepTime
§§+ 4
.
§§4 5
Ticks
§§5 :
/
§§; <
TimeSpan
§§= E
.
§§E F!
TicksPerMillisecond
§§F Y
;
§§Y Z
Contract
••  
.
••  !
Assert
••! '
(
••' (
sleepTimeMs
••( 3
<=
••4 6
int
••7 :
.
••: ;
MaxValue
••; C
)
••C D
;
••D E
delay
¶¶ 
=
¶¶ 
Task
¶¶  $
.
¶¶$ %
Delay
¶¶% *
(
¶¶* +
(
¶¶+ ,
int
¶¶, /
)
¶¶/ 0
sleepTimeMs
¶¶0 ;
,
¶¶; <
this
¶¶= A
.
¶¶A B
owner
¶¶B G
.
¶¶G H
CancellationToken
¶¶H Y
)
¶¶Y Z
;
¶¶Z [
delay
ßß 
.
ßß 
Wait
ßß "
(
ßß" #
)
ßß# $
;
ßß$ %
}
®® 
catch
©© 
(
©©  
AggregateException
©© -
)
©©- .
when
©©/ 3
(
©©4 5
delay
©©5 :
!=
©©; =
null
©©> B
&&
©©C E
delay
©©F K
.
©©K L

IsCanceled
©©L V
)
©©V W
{
™™ 
if
´´ 
(
´´ 
Volatile
´´ $
.
´´$ %
Read
´´% )
(
´´) *
ref
´´* -
this
´´. 2
.
´´2 3
owner
´´3 8
.
´´8 9!
workerStateVolatile
´´9 L
)
´´L M
==
´´N P!
WorkerStateShutdown
´´Q d
)
´´d e
{
¨¨ 
return
≠≠ "
TimeSpan
≠≠# +
.
≠≠+ ,
	FromTicks
≠≠, 5
(
≠≠5 6
long
≠≠6 :
.
≠≠: ;
MinValue
≠≠; C
)
≠≠C D
;
≠≠D E
}
ÆÆ 
}
ØØ 
}
∞∞ 
}
±± 
internal
≥≥ 
ISet
≥≥ 
<
≥≥ 
ITimeout
≥≥ "
>
≥≥" #!
UnprocessedTimeouts
≥≥$ 7
{
≥≥8 9
get
≥≥: =
;
≥≥= >
}
≥≥? @
=
≥≥A B
new
≥≥C F
HashSet
≥≥G N
<
≥≥N O
ITimeout
≥≥O W
>
≥≥W X
(
≥≥X Y
)
≥≥Y Z
;
≥≥Z [
}
¥¥ 	
sealed
∂∂ 
class
∂∂  
HashedWheelTimeout
∂∂ '
:
∂∂( )
ITimeout
∂∂* 2
{
∑∑ 	
const
∏∏ 
int
∏∏ 
StInit
∏∏ 
=
∏∏ 
$num
∏∏  
;
∏∏  !
internal
ππ 
const
ππ 
int
ππ 

StCanceled
ππ )
=
ππ* +
$num
ππ, -
;
ππ- .
const
∫∫ 
int
∫∫ 
	StExpired
∫∫ 
=
∫∫  !
$num
∫∫" #
;
∫∫# $
internal
ºº 
readonly
ºº 
HashedWheelTimer
ºº .
timer
ºº/ 4
;
ºº4 5
internal
ΩΩ 
readonly
ΩΩ 
TimeSpan
ΩΩ &
Deadline
ΩΩ' /
;
ΩΩ/ 0
volatile
øø 
int
øø 
state
øø 
=
øø  
StInit
øø! '
;
øø' (
internal
√√ 
long
√√ 
RemainingRounds
√√ )
;
√√) *
internal
««  
HashedWheelTimeout
«« '
Next
««( ,
;
««, -
internal
……  
HashedWheelTimeout
…… '
Prev
……( ,
;
……, -
internal
ÃÃ 
HashedWheelBucket
ÃÃ &
Bucket
ÃÃ' -
;
ÃÃ- .
internal
ŒŒ  
HashedWheelTimeout
ŒŒ '
(
ŒŒ' (
HashedWheelTimer
ŒŒ( 8
timer
ŒŒ9 >
,
ŒŒ> ?

ITimerTask
ŒŒ@ J
task
ŒŒK O
,
ŒŒO P
TimeSpan
ŒŒQ Y
deadline
ŒŒZ b
)
ŒŒb c
{
œœ 
this
–– 
.
–– 
timer
–– 
=
–– 
timer
–– "
;
––" #
this
—— 
.
—— 
Task
—— 
=
—— 
task
——  
;
——  !
this
““ 
.
““ 
Deadline
““ 
=
““ 
deadline
““  (
;
““( )
}
”” 
public
’’ 
ITimer
’’ 
Timer
’’ 
=>
’’  "
this
’’# '
.
’’' (
timer
’’( -
;
’’- .
public
◊◊ 

ITimerTask
◊◊ 
Task
◊◊ "
{
◊◊# $
get
◊◊% (
;
◊◊( )
}
◊◊* +
public
ŸŸ 
bool
ŸŸ 
Cancel
ŸŸ 
(
ŸŸ 
)
ŸŸ  
{
⁄⁄ 
if
‹‹ 
(
‹‹ 
!
‹‹ 
this
‹‹ 
.
‹‹  
CompareAndSetState
‹‹ ,
(
‹‹, -
StInit
‹‹- 3
,
‹‹3 4

StCanceled
‹‹5 ?
)
‹‹? @
)
‹‹@ A
{
›› 
return
ﬁﬁ 
false
ﬁﬁ  
;
ﬁﬁ  !
}
ﬂﬂ 
this
„„ 
.
„„ 
timer
„„ 
.
„„ "
ScheduleCancellation
„„ /
(
„„/ 0
this
„„0 4
)
„„4 5
;
„„5 6
return
‰‰ 
true
‰‰ 
;
‰‰ 
}
ÂÂ 
internal
ÁÁ 
void
ÁÁ 
Remove
ÁÁ  
(
ÁÁ  !
)
ÁÁ! "
{
ËË 
HashedWheelBucket
ÈÈ !
bucket
ÈÈ" (
=
ÈÈ) *
this
ÈÈ+ /
.
ÈÈ/ 0
Bucket
ÈÈ0 6
;
ÈÈ6 7
if
ÍÍ 
(
ÍÍ 
bucket
ÍÍ 
!=
ÍÍ 
null
ÍÍ "
)
ÍÍ" #
{
ÎÎ 
bucket
ÌÌ 
.
ÌÌ 
Remove
ÌÌ !
(
ÌÌ! "
this
ÌÌ" &
)
ÌÌ& '
;
ÌÌ' (
}
ÓÓ 
else
ÔÔ 
if
ÔÔ 
(
ÔÔ 
this
ÔÔ 
.
ÔÔ 
timer
ÔÔ #
.
ÔÔ# $!
ShouldLimitTimeouts
ÔÔ$ 7
)
ÔÔ7 8
{
 
Interlocked
ÒÒ 
.
ÒÒ  
	Decrement
ÒÒ  )
(
ÒÒ) *
ref
ÒÒ* -
this
ÒÒ. 2
.
ÒÒ2 3
timer
ÒÒ3 8
.
ÒÒ8 9
PendingTimeouts
ÒÒ9 H
)
ÒÒH I
;
ÒÒI J
}
ÚÚ 
}
ÛÛ 
bool
ıı  
CompareAndSetState
ıı #
(
ıı# $
int
ıı$ '
expected
ıı( 0
,
ıı0 1
int
ıı2 5
state
ıı6 ;
)
ıı; <
{
ˆˆ 
return
˜˜ 
Interlocked
˜˜ "
.
˜˜" #
CompareExchange
˜˜# 2
(
˜˜2 3
ref
˜˜3 6
this
˜˜7 ;
.
˜˜; <
state
˜˜< A
,
˜˜A B
state
˜˜C H
,
˜˜H I
expected
˜˜J R
)
˜˜R S
==
˜˜T V
expected
˜˜W _
;
˜˜_ `
}
¯¯ 
internal
˙˙ 
int
˙˙ 
State
˙˙ 
=>
˙˙ !
this
˙˙" &
.
˙˙& '
state
˙˙' ,
;
˙˙, -
public
¸¸ 
bool
¸¸ 
Canceled
¸¸  
=>
¸¸! #
this
¸¸$ (
.
¸¸( )
State
¸¸) .
==
¸¸/ 1

StCanceled
¸¸2 <
;
¸¸< =
public
˛˛ 
bool
˛˛ 
Expired
˛˛ 
=>
˛˛  "
this
˛˛# '
.
˛˛' (
State
˛˛( -
==
˛˛. 0
	StExpired
˛˛1 :
;
˛˛: ;
internal
ÄÄ 
void
ÄÄ 
Expire
ÄÄ  
(
ÄÄ  !
)
ÄÄ! "
{
ÅÅ 
if
ÇÇ 
(
ÇÇ 
!
ÇÇ 
this
ÇÇ 
.
ÇÇ  
CompareAndSetState
ÇÇ ,
(
ÇÇ, -
StInit
ÇÇ- 3
,
ÇÇ3 4
	StExpired
ÇÇ5 >
)
ÇÇ> ?
)
ÇÇ? @
{
ÉÉ 
return
ÑÑ 
;
ÑÑ 
}
ÖÖ 
try
áá 
{
àà 
this
ââ 
.
ââ 
Task
ââ 
.
ââ 
Run
ââ !
(
ââ! "
this
ââ" &
)
ââ& '
;
ââ' (
}
ää 
catch
ãã 
(
ãã 
	Exception
ãã  
t
ãã! "
)
ãã" #
{
åå 
if
çç 
(
çç 
Logger
çç 
.
çç 
WarnEnabled
çç *
)
çç* +
{
éé 
Logger
èè 
.
èè 
Warn
èè #
(
èè# $
$"
èè$ &
$str
èè& A
{
èèA B
this
èèB F
.
èèF G
Task
èèG K
.
èèK L
GetType
èèL S
(
èèS T
)
èèT U
.
èèU V
Name
èèV Z
}
èèZ [
$str
èè[ \
"
èè\ ]
,
èè] ^
t
èè_ `
)
èè` a
;
èèa b
}
êê 
}
ëë 
}
íí 
public
îî 
override
îî 
string
îî "
ToString
îî# +
(
îî+ ,
)
îî, -
{
ïï 
PreciseTimeSpan
ññ 
currentTime
ññ  +
=
ññ, -
PreciseTimeSpan
ññ. =
.
ññ= >
	FromStart
ññ> G
-
ññH I
this
ññJ N
.
ññN O
timer
ññO T
.
ññT U
	StartTime
ññU ^
;
ññ^ _
TimeSpan
óó 
	remaining
óó "
=
óó# $
this
óó% )
.
óó) *
Deadline
óó* 2
-
óó3 4
currentTime
óó5 @
.
óó@ A

ToTimeSpan
óóA K
(
óóK L
)
óóL M
;
óóM N
StringBuilder
ôô 
buf
ôô !
=
ôô" #
new
ôô$ '
StringBuilder
ôô( 5
(
ôô5 6
$num
ôô6 9
)
ôô9 :
.
öö 
Append
öö 
(
öö 
this
öö  
.
öö  !
GetType
öö! (
(
öö( )
)
öö) *
.
öö* +
Name
öö+ /
)
öö/ 0
.
õõ 
Append
õõ 
(
õõ 
$char
õõ 
)
õõ  
.
úú 
Append
úú 
(
úú 
$str
úú (
)
úú( )
;
úú) *
if
ùù 
(
ùù 
	remaining
ùù 
>
ùù 
TimeSpan
ùù  (
.
ùù( )
Zero
ùù) -
)
ùù- .
{
ûû 
buf
üü 
.
üü 
Append
üü 
(
üü 
	remaining
üü (
)
üü( )
.
†† 
Append
†† 
(
††  
$str
††  (
)
††( )
;
††) *
}
°° 
else
¢¢ 
if
¢¢ 
(
¢¢ 
	remaining
¢¢ "
<
¢¢# $
TimeSpan
¢¢% -
.
¢¢- .
Zero
¢¢. 2
)
¢¢2 3
{
££ 
buf
§§ 
.
§§ 
Append
§§ 
(
§§ 
-
§§  
	remaining
§§  )
)
§§) *
.
•• 
Append
•• 
(
••  
$str
••  &
)
••& '
;
••' (
}
¶¶ 
else
ßß 
{
®® 
buf
©© 
.
©© 
Append
©© 
(
©© 
$str
©© $
)
©©$ %
;
©©% &
}
™™ 
if
¨¨ 
(
¨¨ 
this
¨¨ 
.
¨¨ 
Canceled
¨¨ !
)
¨¨! "
{
≠≠ 
buf
ÆÆ 
.
ÆÆ 
Append
ÆÆ 
(
ÆÆ 
$str
ÆÆ ,
)
ÆÆ, -
;
ÆÆ- .
}
ØØ 
return
±± 
buf
±± 
.
±± 
Append
±± !
(
±±! "
$str
±±" ,
)
±±, -
.
≤≤ 
Append
≤≤ 
(
≤≤ 
this
≤≤  
.
≤≤  !
Task
≤≤! %
)
≤≤% &
.
≥≥ 
Append
≥≥ 
(
≥≥ 
$char
≥≥ 
)
≥≥  
.
¥¥ 
ToString
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥  
}
µµ 
}
∂∂ 	
sealed
ΩΩ 
class
ΩΩ 
HashedWheelBucket
ΩΩ &
{
ææ 	 
HashedWheelTimeout
¿¿ 
head
¿¿ #
;
¿¿# $ 
HashedWheelTimeout
¡¡ 
tail
¡¡ #
;
¡¡# $
public
∆∆ 
void
∆∆ 

AddTimeout
∆∆ "
(
∆∆" # 
HashedWheelTimeout
∆∆# 5
timeout
∆∆6 =
)
∆∆= >
{
«« 
Contract
»» 
.
»» 
Assert
»» 
(
»»  
timeout
»»  '
.
»»' (
Bucket
»»( .
==
»»/ 1
null
»»2 6
)
»»6 7
;
»»7 8
timeout
…… 
.
…… 
Bucket
…… 
=
……  
this
……! %
;
……% &
if
   
(
   
this
   
.
   
head
   
==
    
null
  ! %
)
  % &
{
ÀÀ 
this
ÃÃ 
.
ÃÃ 
head
ÃÃ 
=
ÃÃ 
this
ÃÃ  $
.
ÃÃ$ %
tail
ÃÃ% )
=
ÃÃ* +
timeout
ÃÃ, 3
;
ÃÃ3 4
}
ÕÕ 
else
ŒŒ 
{
œœ 
this
–– 
.
–– 
tail
–– 
.
–– 
Next
–– "
=
––# $
timeout
––% ,
;
––, -
timeout
—— 
.
—— 
Prev
——  
=
——! "
this
——# '
.
——' (
tail
——( ,
;
——, -
this
““ 
.
““ 
tail
““ 
=
““ 
timeout
““  '
;
““' (
}
”” 
}
‘‘ 
public
ŸŸ 
void
ŸŸ 
ExpireTimeouts
ŸŸ &
(
ŸŸ& '
TimeSpan
ŸŸ' /
deadline
ŸŸ0 8
)
ŸŸ8 9
{
⁄⁄  
HashedWheelTimeout
€€ "
timeout
€€# *
=
€€+ ,
this
€€- 1
.
€€1 2
head
€€2 6
;
€€6 7
while
ﬁﬁ 
(
ﬁﬁ 
timeout
ﬁﬁ 
!=
ﬁﬁ !
null
ﬁﬁ" &
)
ﬁﬁ& '
{
ﬂﬂ  
HashedWheelTimeout
‡‡ &
next
‡‡' +
=
‡‡, -
timeout
‡‡. 5
.
‡‡5 6
Next
‡‡6 :
;
‡‡: ;
if
·· 
(
·· 
timeout
·· 
.
··  
RemainingRounds
··  /
<=
··0 2
$num
··3 4
)
··4 5
{
‚‚ 
next
„„ 
=
„„ 
this
„„ #
.
„„# $
Remove
„„$ *
(
„„* +
timeout
„„+ 2
)
„„2 3
;
„„3 4
if
‰‰ 
(
‰‰ 
timeout
‰‰ #
.
‰‰# $
Deadline
‰‰$ ,
<=
‰‰- /
deadline
‰‰0 8
)
‰‰8 9
{
ÂÂ 
timeout
ÊÊ #
.
ÊÊ# $
Expire
ÊÊ$ *
(
ÊÊ* +
)
ÊÊ+ ,
;
ÊÊ, -
}
ÁÁ 
else
ËË 
{
ÈÈ 
throw
ÎÎ !
new
ÎÎ" %'
InvalidOperationException
ÎÎ& ?
(
ÎÎ? @
string
ÏÏ  &
.
ÏÏ& '
Format
ÏÏ' -
(
ÏÏ- .
$str
ÌÌ$ I
,
ÌÌI J
timeout
ÓÓ$ +
.
ÓÓ+ ,
Deadline
ÓÓ, 4
,
ÓÓ4 5
deadline
ÔÔ$ ,
)
ÔÔ, -
)
ÔÔ- .
;
ÔÔ. /
}
 
}
ÒÒ 
else
ÚÚ 
{
ÛÛ 
timeout
ÙÙ 
.
ÙÙ  
RemainingRounds
ÙÙ  /
--
ÙÙ/ 1
;
ÙÙ1 2
}
ıı 
timeout
ˆˆ 
=
ˆˆ 
next
ˆˆ "
;
ˆˆ" #
}
˜˜ 
}
¯¯ 
public
˙˙  
HashedWheelTimeout
˙˙ %
Remove
˙˙& ,
(
˙˙, - 
HashedWheelTimeout
˙˙- ?
timeout
˙˙@ G
)
˙˙G H
{
˚˚  
HashedWheelTimeout
¸¸ "
next
¸¸# '
=
¸¸( )
timeout
¸¸* 1
.
¸¸1 2
Next
¸¸2 6
;
¸¸6 7
if
˛˛ 
(
˛˛ 
timeout
˛˛ 
.
˛˛ 
Prev
˛˛  
!=
˛˛! #
null
˛˛$ (
)
˛˛( )
{
ˇˇ 
timeout
ÄÄ 
.
ÄÄ 
Prev
ÄÄ  
.
ÄÄ  !
Next
ÄÄ! %
=
ÄÄ& '
next
ÄÄ( ,
;
ÄÄ, -
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
timeout
ÇÇ 
.
ÇÇ 
Next
ÇÇ  
!=
ÇÇ! #
null
ÇÇ$ (
)
ÇÇ( )
{
ÉÉ 
timeout
ÑÑ 
.
ÑÑ 
Next
ÑÑ  
.
ÑÑ  !
Prev
ÑÑ! %
=
ÑÑ& '
timeout
ÑÑ( /
.
ÑÑ/ 0
Prev
ÑÑ0 4
;
ÑÑ4 5
}
ÖÖ 
if
áá 
(
áá 
timeout
áá 
==
áá 
this
áá #
.
áá# $
head
áá$ (
)
áá( )
{
àà 
if
ää 
(
ää 
timeout
ää 
==
ää  "
this
ää# '
.
ää' (
tail
ää( ,
)
ää, -
{
ãã 
this
åå 
.
åå 
tail
åå !
=
åå" #
null
åå$ (
;
åå( )
this
çç 
.
çç 
head
çç !
=
çç" #
null
çç$ (
;
çç( )
}
éé 
else
èè 
{
êê 
this
ëë 
.
ëë 
head
ëë !
=
ëë" #
next
ëë$ (
;
ëë( )
}
íí 
}
ìì 
else
îî 
if
îî 
(
îî 
timeout
îî  
==
îî! #
this
îî$ (
.
îî( )
tail
îî) -
)
îî- .
{
ïï 
this
óó 
.
óó 
tail
óó 
=
óó 
timeout
óó  '
.
óó' (
Prev
óó( ,
;
óó, -
}
òò 
timeout
öö 
.
öö 
Prev
öö 
=
öö 
null
öö #
;
öö# $
timeout
õõ 
.
õõ 
Next
õõ 
=
õõ 
null
õõ #
;
õõ# $
timeout
úú 
.
úú 
Bucket
úú 
=
úú  
null
úú! %
;
úú% &
if
ùù 
(
ùù 
timeout
ùù 
.
ùù 
timer
ùù !
.
ùù! "!
ShouldLimitTimeouts
ùù" 5
)
ùù5 6
{
ûû 
Interlocked
üü 
.
üü  
	Decrement
üü  )
(
üü) *
ref
üü* -
timeout
üü. 5
.
üü5 6
timer
üü6 ;
.
üü; <
PendingTimeouts
üü< K
)
üüK L
;
üüL M
}
†† 
return
°° 
next
°° 
;
°° 
}
¢¢ 
public
ßß 
void
ßß 
ClearTimeouts
ßß %
(
ßß% &
ISet
ßß& *
<
ßß* +
ITimeout
ßß+ 3
>
ßß3 4
set
ßß5 8
)
ßß8 9
{
®® 
while
©© 
(
©© 
true
©© 
)
©© 
{
™™  
HashedWheelTimeout
´´ &
timeout
´´' .
=
´´/ 0
this
´´1 5
.
´´5 6
PollTimeout
´´6 A
(
´´A B
)
´´B C
;
´´C D
if
¨¨ 
(
¨¨ 
timeout
¨¨ 
==
¨¨  "
null
¨¨# '
)
¨¨' (
{
≠≠ 
return
ÆÆ 
;
ÆÆ 
}
ØØ 
if
∞∞ 
(
∞∞ 
timeout
∞∞ 
.
∞∞  
Expired
∞∞  '
||
∞∞( *
timeout
∞∞+ 2
.
∞∞2 3
Canceled
∞∞3 ;
)
∞∞; <
{
±± 
continue
≤≤  
;
≤≤  !
}
≥≥ 
set
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥ 
timeout
¥¥ #
)
¥¥# $
;
¥¥$ %
}
µµ 
}
∂∂  
HashedWheelTimeout
∏∏ 
PollTimeout
∏∏ *
(
∏∏* +
)
∏∏+ ,
{
ππ  
HashedWheelTimeout
∫∫ "
head
∫∫# '
=
∫∫( )
this
∫∫* .
.
∫∫. /
head
∫∫/ 3
;
∫∫3 4
if
ªª 
(
ªª 
head
ªª 
==
ªª 
null
ªª  
)
ªª  !
{
ºº 
return
ΩΩ 
null
ΩΩ 
;
ΩΩ  
}
ææ  
HashedWheelTimeout
øø "
next
øø# '
=
øø( )
head
øø* .
.
øø. /
Next
øø/ 3
;
øø3 4
if
¿¿ 
(
¿¿ 
next
¿¿ 
==
¿¿ 
null
¿¿  
)
¿¿  !
{
¡¡ 
this
¬¬ 
.
¬¬ 
tail
¬¬ 
=
¬¬ 
this
¬¬  $
.
¬¬$ %
head
¬¬% )
=
¬¬* +
null
¬¬, 0
;
¬¬0 1
}
√√ 
else
ƒƒ 
{
≈≈ 
this
∆∆ 
.
∆∆ 
head
∆∆ 
=
∆∆ 
next
∆∆  $
;
∆∆$ %
next
«« 
.
«« 
Prev
«« 
=
«« 
null
««  $
;
««$ %
}
»» 
head
ÀÀ 
.
ÀÀ 
Next
ÀÀ 
=
ÀÀ 
null
ÀÀ  
;
ÀÀ  !
head
ÃÃ 
.
ÃÃ 
Prev
ÃÃ 
=
ÃÃ 
null
ÃÃ  
;
ÃÃ  !
head
ÕÕ 
.
ÕÕ 
Bucket
ÕÕ 
=
ÕÕ 
null
ÕÕ "
;
ÕÕ" #
return
ŒŒ 
head
ŒŒ 
;
ŒŒ 
}
œœ 
}
–– 	
}
—— 
}““ °

fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IAttribute.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 

IAttribute 
<  
T  !
>! "
{		 
AttributeKey 
< 
T 
> 
Key 
{ 
get !
;! "
}# $
T 	
Get
 
( 
) 
; 
void 
Set 
( 
T 
value 
) 
; 
T 	
	GetAndSet
 
( 
T 
value 
) 
; 
T"" 	
SetIfAbsent""
 
("" 
T"" 
value"" 
)"" 
;"" 
T++ 	
GetAndRemove++
 
(++ 
)++ 
;++ 
bool11 
CompareAndSet11 
(11 
T11 
oldValue11 %
,11% &
T11' (
newValue11) 1
)111 2
;112 3
void99 
Remove99 
(99 
)99 
;99 
}:: 
};; ‘
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IAttributeMap.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 
IAttributeMap "
{		 

IAttribute 
< 
T 
> 
GetAttribute "
<" #
T# $
>$ %
(% &
AttributeKey& 2
<2 3
T3 4
>4 5
key6 9
)9 :
where 
T 
: 
class 
; 
bool 
HasAttribute 
< 
T 
> 
( 
AttributeKey )
<) *
T* +
>+ ,
key- 0
)0 1
where 
T 
: 
class 
; 
} 
} ˜
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ICharSequence.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 
ICharSequence "
:# $
IReadOnlyList% 2
<2 3
char3 7
>7 8
{		 
ICharSequence 
SubSequence !
(! "
int" %
start& +
,+ ,
int- 0
end1 4
)4 5
;5 6
ICharSequence 
SubSequence !
(! "
int" %
start& +
)+ ,
;, -
int 
IndexOf 
( 
char 
ch 
, 
int  
start! &
=' (
$num) *
)* +
;+ ,
bool 
RegionMatches 
( 
int 
	thisStart (
,( )
ICharSequence* 7
seq8 ;
,; <
int= @
startA F
,F G
intH K
lengthL R
)R S
;S T
bool #
RegionMatchesIgnoreCase $
($ %
int% (
	thisStart) 2
,2 3
ICharSequence4 A
seqB E
,E F
intG J
startK P
,P Q
intR U
lengthV \
)\ ]
;] ^
bool 
ContentEquals 
( 
ICharSequence (
other) .
). /
;/ 0
bool #
ContentEqualsIgnoreCase $
($ %
ICharSequence% 2
other3 8
)8 9
;9 :
int 
HashCode 
( 
bool 

ignoreCase $
)$ %
;% &
string 
ToString 
( 
int 
start !
)! "
;" #
string 
ToString 
( 
) 
; 
} 
}   ò
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IConstant.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

	interface

 
	IConstant

 
{ 
int 
Id 
{ 
get 
; 
} 
string 
Name 
{ 
get 
; 
} 
} 
} ä
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IHashingStrategy.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 
IHashingStrategy %
<% &
in& (
T) *
>* +
:, -
IEqualityComparer. ?
<? @
T@ A
>A B
{		 
int

 
HashCode

 
(

 
T

 
obj

 
)

 
;

 
} 
public 

sealed 
class "
DefaultHashingStrategy .
<. /
T/ 0
>0 1
:2 3
IHashingStrategy4 D
<D E
TE F
>F G
{ 
public 
int 
GetHashCode 
( 
T  
obj! $
)$ %
=>& (
obj) ,
., -
GetHashCode- 8
(8 9
)9 :
;: ;
public 
int 
HashCode 
( 
T 
obj !
)! "
=># %
obj& )
!=* ,
null- 1
?2 3
this4 8
.8 9
GetHashCode9 D
(D E
objE H
)H I
:J K
$numL M
;M N
public 
bool 
Equals 
( 
T 
a 
, 
T  !
b" #
)# $
=>% '
ReferenceEquals( 7
(7 8
a8 9
,9 :
b; <
)< =
||> @
(A B
!B C
ReferenceEqualsC R
(R S
aS T
,T U
nullV Z
)Z [
&&\ ^
a_ `
.` a
Equalsa g
(g h
bh i
)i j
)j k
;k l
} 
} Û

zC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IllegalReferenceCountException.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

class *
IllegalReferenceCountException /
:0 1%
InvalidOperationException2 K
{ 
public *
IllegalReferenceCountException -
(- .
int. 1
count2 7
)7 8
: 
base 
( 
$" 
$str 0
{0 1
count1 6
}6 7
$str7 G
"G H
)H I
{ 	
} 	
public *
IllegalReferenceCountException -
(- .
int. 1
refCnt2 8
,8 9
int: =
	increment> G
)G H
: 
base 
( 
$str 
+ 
refCnt  &
+' (
$str) -
+. /
(0 1
	increment1 :
>; <
$num= >
?? @
$strA N
+O P
	incrementQ Z
:[ \
$str] j
+k l
-m n
	incrementn w
)w x
)x y
{ 	
} 	
} 
} ∆
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\IntegerExtensions.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
IntegerExtensions )
{ 
static 
readonly 
int 
[ 
] '
MultiplyDeBruijnBitPosition 9
=: ;
{		 	
$num

 
,

 
$num

 
,

 
$num

 
,

 
$num

 
,

 
$num

 
,

 
$num

 
,

  
$num

! "
,

" #
$num

$ &
,

& '
$num

( *
,

* +
$num

, .
,

. /
$num

0 2
,

2 3
$num

4 6
,

6 7
$num

8 :
,

: ;
$num

< >
,

> ?
$num

@ A
,

A B
$num

C E
,

E F
$num 
, 
$num 
, 
$num 
, 
$num 
, 
$num 
, 
$num !
,! "
$num# %
,% &
$num' (
,( )
$num* ,
,, -
$num. 0
,0 1
$num2 4
,4 5
$num6 7
,7 8
$num9 ;
,; <
$num= >
,> ?
$num@ A
,A B
$numC E
} 	
;	 

public 
const 
int 

SizeInBits #
=$ %
sizeof& ,
(, -
int- 0
)0 1
*2 3
$num4 5
;5 6
public 
static 
int 
RoundUpToPowerOfTwo -
(- .
int. 1
res2 5
)5 6
{ 	
if 
( 
res 
<= 
$num 
) 
{ 
return 
$num 
; 
} 
res 
-- 
; 
res 
|= 
res 
>> 
$num 
; 
res 
|= 
res 
>> 
$num 
; 
res 
|= 
res 
>> 
$num 
; 
res 
|= 
res 
>> 
$num 
; 
res 
|= 
res 
>> 
$num 
; 
res 
++ 
; 
return 
res 
; 
} 	
public   
static   
int   
Log2   
(   
int   "
v  # $
)  $ %
{!! 	
v"" 
|="" 
v"" 
>>"" 
$num"" 
;"" 
v## 
|=## 
v## 
>>## 
$num## 
;## 
v$$ 
|=$$ 
v$$ 
>>$$ 
$num$$ 
;$$ 
v%% 
|=%% 
v%% 
>>%% 
$num%% 
;%% 
v&& 
|=&& 
v&& 
>>&& 
$num&& 
;&& 
return(( '
MultiplyDeBruijnBitPosition(( .
[((. /
	unchecked((/ 8
(((8 9
(((9 :
uint((: >
)((> ?
(((? @
v((@ A
*((B C
$num((D O
)((O P
>>((Q S
$num((T V
)((V W
]((W X
;((X Y
})) 	
}** 
}++ æ
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ITimeout.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

	interface

 
ITimeout

 
{ 
ITimer 
Timer 
{ 
get 
; 
} 

ITimerTask 
Task 
{ 
get 
; 
}  
bool 
Expired 
{ 
get 
; 
} 
bool   
Canceled   
{   
get   
;   
}   
bool(( 
Cancel(( 
((( 
)(( 
;(( 
})) 
}** ∆
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ITimer.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

	interface 
ITimer 
{ 
ITimeout 

NewTimeout 
( 

ITimerTask &
task' +
,+ ,
TimeSpan- 5
delay6 ;
); <
;< =
Task   
<   
ISet   
<   
ITimeout   
>   
>   
	StopAsync   &
(  & '
)  ' (
;  ( )
}!! 
}"" “
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ITimerTask.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

	interface

 

ITimerTask

 
{ 
void 
Run 
( 
ITimeout 
timeout !
)! "
;" #
} 
} È
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\MediumUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 

MediumUtil "
{		 
const 
uint 
MediumBitMask  
=! "
$num# -
;- .
public 
static 
int 
ToMediumInt %
(% &
this& *
int+ .
value/ 4
)4 5
{ 	
if 
( 
( 
value 
& 
$num #
)# $
>% &
$num' (
)( )
{ 
value 
|= 
	unchecked "
(" #
(# $
int$ '
)' (
MediumBitMask( 5
)5 6
;6 7
} 
else 
{ 
value 
&= 
~ 
	unchecked #
(# $
($ %
int% (
)( )
MediumBitMask) 6
)6 7
;7 8
} 
return 
value 
; 
} 	
public 
static 
int 
ToUnsignedMediumInt -
(- .
this. 2
int3 6
value7 <
)< =
{ 	
return   
(   
int   
)   
(   
(   
uint   
)   
value   $
&  % &
~  ' (
MediumBitMask  ( 5
)  5 6
;  6 7
}!! 	
}"" 
}## êô
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\NetUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

static

 
class

 
NetUtil

 
{ 
public 
static 
string !
ToSocketAddressString 2
(2 3
string3 9
host: >
,> ?
int@ C
portD H
)H I
{ 	
string 
portStr 
= 
Convert $
.$ %
ToString% -
(- .
port. 2
)2 3
;3 4
return )
NewSocketAddressStringBuilder 0
(0 1
host1 5
,5 6
portStr7 >
,> ?
! 
IsValidIpV6Address #
(# $
host$ (
)( )
)) *
.* +
Append+ 1
(1 2
$char2 5
)5 6
.6 7
Append7 =
(= >
portStr> E
)E F
.F G
ToStringG O
(O P
)P Q
;Q R
} 	
static 
StringBuilder )
NewSocketAddressStringBuilder :
(: ;
string; A
hostB F
,F G
stringH N
portO S
,S T
boolU Y
ipv4Z ^
)^ _
{ 	
int 
hostLen 
= 
host 
. 
Length %
;% &
if 
( 
ipv4 
) 
{ 
return 
new 
StringBuilder (
(( )
hostLen) 0
+1 2
$num3 4
+5 6
port7 ;
.; <
Length< B
)B C
.C D
AppendD J
(J K
hostK O
)O P
;P Q
} 
var 
stringBuilder 
= 
new  #
StringBuilder$ 1
(1 2
hostLen2 9
+: ;
$num< =
+> ?
port@ D
.D E
LengthE K
)K L
;L M
if 
( 
hostLen 
> 
$num 
&& 
host #
[# $
$num$ %
]% &
==' )
$char* -
&&. 0
host1 5
[5 6
hostLen6 =
-> ?
$num@ A
]A B
==C E
$charF I
)I J
{ 
return   
stringBuilder   $
.  $ %
Append  % +
(  + ,
host  , 0
)  0 1
;  1 2
}!! 
return## 
stringBuilder##  
.##  !
Append##! '
(##' (
$char##( +
)##+ ,
.##, -
Append##- 3
(##3 4
host##4 8
)##8 9
.##9 :
Append##: @
(##@ A
$char##A D
)##D E
;##E F
}$$ 	
public&& 
static&& 
bool&& 
IsValidIpV6Address&& -
(&&- .
string&&. 4
ip&&5 7
)&&7 8
{'' 	
int(( 
end(( 
=(( 
ip(( 
.(( 
Length(( 
;((  
if)) 
()) 
end)) 
<)) 
$num)) 
))) 
{** 
return++ 
false++ 
;++ 
},, 
int// 
start// 
;// 
char00 
c00 
=00 
ip00 
[00 
$num00 
]00 
;00 
if11 
(11 
c11 
==11 
$char11 
)11 
{22 
end33 
--33 
;33 
if44 
(44 
ip44 
[44 
end44 
]44 
!=44 
$char44 "
)44" #
{55 
return77 
false77  
;77  !
}88 
start:: 
=:: 
$num:: 
;:: 
c;; 
=;; 
ip;; 
[;; 
$num;; 
];; 
;;; 
}<< 
else== 
{>> 
start?? 
=?? 
$num?? 
;?? 
}@@ 
intBB 
colonsBB 
;BB 
intCC 
compressBeginCC 
;CC 
ifDD 
(DD 
cDD 
==DD 
$charDD 
)DD 
{EE 
ifGG 
(GG 
ipGG 
[GG 
startGG 
+GG 
$numGG  
]GG  !
!=GG" $
$charGG% (
)GG( )
{HH 
returnII 
falseII  
;II  !
}JJ 
colonsLL 
=LL 
$numLL 
;LL 
compressBeginMM 
=MM 
startMM  %
;MM% &
startNN 
+=NN 
$numNN 
;NN 
}OO 
elsePP 
{QQ 
colonsRR 
=RR 
$numRR 
;RR 
compressBeginSS 
=SS 
-SS  !
$numSS! "
;SS" #
}TT 
intVV 
wordLenVV 
=VV 
$numVV 
;VV 
forWW 
(WW 
intWW 
iWW 
=WW 
startWW 
;WW 
iWW  !
<WW" #
endWW$ '
;WW' (
iWW) *
++WW* ,
)WW, -
{XX 
cYY 
=YY 
ipYY 
[YY 
iYY 
]YY 
;YY 
ifZZ 
(ZZ 
IsValidHexCharZZ "
(ZZ" #
cZZ# $
)ZZ$ %
)ZZ% &
{[[ 
if\\ 
(\\ 
wordLen\\ 
<\\  !
$num\\" #
)\\# $
{]] 
wordLen^^ 
++^^ !
;^^! "
continue__  
;__  !
}`` 
returnbb 
falsebb  
;bb  !
}cc 
switchee 
(ee 
cee 
)ee 
{ff 
casegg 
$chargg 
:gg 
ifhh 
(hh 
colonshh "
>hh# $
$numhh% &
)hh& '
{ii 
returnjj "
falsejj# (
;jj( )
}kk 
ifmm 
(mm 
ipmm 
[mm 
imm  
-mm! "
$nummm# $
]mm$ %
==mm& (
$charmm) ,
)mm, -
{nn 
ifoo 
(oo  
compressBeginoo  -
>=oo. 0
$numoo1 2
)oo2 3
{pp 
returnqq  &
falseqq' ,
;qq, -
}rr 
compressBegintt )
=tt* +
itt, -
-tt. /
$numtt0 1
;tt1 2
}uu 
elsevv 
{ww 
wordLenxx #
=xx$ %
$numxx& '
;xx' (
}yy 
colons{{ 
++{{  
;{{  !
break|| 
;|| 
case}} 
$char}} 
:}} 
if
ÅÅ 
(
ÅÅ 
compressBegin
ÅÅ )
<
ÅÅ* +
$num
ÅÅ, -
&&
ÅÅ. 0
colons
ÅÅ1 7
!=
ÅÅ8 :
$num
ÅÅ; <
||
ÅÅ= ?
(
ÑÑ 
colons
ÑÑ #
==
ÑÑ$ &
$num
ÑÑ' (
&&
ÑÑ) +
compressBegin
ÑÑ, 9
>=
ÑÑ: <
start
ÑÑ= B
||
ÑÑC E
colons
ÑÑF L
>
ÑÑM N
$num
ÑÑO P
)
ÑÑP Q
)
ÑÑQ R
{
ÖÖ 
return
ÜÜ "
false
ÜÜ# (
;
ÜÜ( )
}
áá 
int
åå 
	ipv4Start
åå %
=
åå& '
i
åå( )
-
åå* +
wordLen
åå, 3
;
åå3 4
int
çç 
j
çç 
=
çç 
	ipv4Start
çç  )
-
çç* +
$num
çç, -
;
çç- .
if
éé 
(
éé #
IsValidIPv4MappedChar
éé 1
(
éé1 2
ip
éé2 4
[
éé4 5
j
éé5 6
]
éé6 7
)
éé7 8
)
éé8 9
{
èè 
if
êê 
(
êê  
!
êê  !#
IsValidIPv4MappedChar
êê! 6
(
êê6 7
ip
êê7 9
[
êê9 :
j
êê: ;
-
êê< =
$num
êê> ?
]
êê? @
)
êê@ A
||
êêB D
!
ëë  !#
IsValidIPv4MappedChar
ëë! 6
(
ëë6 7
ip
ëë7 9
[
ëë9 :
j
ëë: ;
-
ëë< =
$num
ëë> ?
]
ëë? @
)
ëë@ A
||
ëëB D
!
íí  !#
IsValidIPv4MappedChar
íí! 6
(
íí6 7
ip
íí7 9
[
íí9 :
j
íí: ;
-
íí< =
$num
íí> ?
]
íí? @
)
íí@ A
)
ííA B
{
ìì 
return
îî  &
false
îî' ,
;
îî, -
}
ïï 
j
óó 
-=
óó  
$num
óó! "
;
óó" #
}
òò 
for
öö 
(
öö 
;
öö 
j
öö  
>=
öö! #
start
öö$ )
;
öö) *
--
öö+ -
j
öö- .
)
öö. /
{
õõ 
char
úú  
tmpChar
úú! (
=
úú) *
ip
úú+ -
[
úú- .
j
úú. /
]
úú/ 0
;
úú0 1
if
ùù 
(
ùù  
tmpChar
ùù  '
!=
ùù( *
$char
ùù+ .
&&
ùù/ 1
tmpChar
ùù2 9
!=
ùù: <
$char
ùù= @
)
ùù@ A
{
ûû 
return
üü  &
false
üü' ,
;
üü, -
}
†† 
}
°° 
int
§§ 
ipv4End
§§ #
=
§§$ %
ip
§§& (
.
§§( )
IndexOf
§§) 0
(
§§0 1
$char
§§1 4
,
§§4 5
	ipv4Start
§§6 ?
+
§§@ A
$num
§§B C
)
§§C D
;
§§D E
if
•• 
(
•• 
ipv4End
•• #
<
••$ %
$num
••& '
)
••' (
{
¶¶ 
ipv4End
ßß #
=
ßß$ %
end
ßß& )
;
ßß) *
}
®® 
return
™™  
IsValidIpV4Address
™™ 1
(
™™1 2
ip
™™2 4
,
™™4 5
	ipv4Start
™™6 ?
,
™™? @
ipv4End
™™A H
)
™™H I
;
™™I J
case
´´ 
$char
´´ 
:
´´ 
end
≠≠ 
=
≠≠ 
i
≠≠ 
;
≠≠  
goto
ÆÆ 
loop
ÆÆ !
;
ÆÆ! "
default
ØØ 
:
ØØ 
return
∞∞ 
false
∞∞ $
;
∞∞$ %
}
±± 
loop
≥≥ 
:
≥≥ 
if
µµ 
(
µµ 
compressBegin
µµ !
<
µµ" #
$num
µµ$ %
)
µµ% &
{
∂∂ 
return
∑∑ 
colons
∑∑ !
==
∑∑" $
$num
∑∑% &
&&
∑∑' )
wordLen
∑∑* 1
>
∑∑2 3
$num
∑∑4 5
;
∑∑5 6
}
∏∏ 
return
∫∫ 
compressBegin
∫∫ $
+
∫∫% &
$num
∫∫' (
==
∫∫) +
end
∫∫, /
||
∫∫0 2
wordLen
ºº 
>
ºº 
$num
ºº 
&&
ºº  "
(
ºº# $
colons
ºº$ *
<
ºº+ ,
$num
ºº- .
||
ºº/ 1
compressBegin
ºº2 ?
<=
ºº@ B
start
ººC H
)
ººH I
;
ººI J
}
ΩΩ 
if
¿¿ 
(
¿¿ 
compressBegin
¿¿ 
<
¿¿ 
$num
¿¿  !
)
¿¿! "
{
¡¡ 
return
¬¬ 
colons
¬¬ 
==
¬¬  
$num
¬¬! "
&&
¬¬# %
wordLen
¬¬& -
>
¬¬. /
$num
¬¬0 1
;
¬¬1 2
}
√√ 
return
≈≈ 
compressBegin
≈≈  
+
≈≈! "
$num
≈≈# $
==
≈≈% '
end
≈≈( +
||
≈≈, .
wordLen
«« 
>
«« 
$num
«« 
&&
«« 
(
««  
colons
««  &
<
««' (
$num
««) *
||
««+ -
compressBegin
««. ;
<=
««< >
start
««? D
)
««D E
;
««E F
}
»» 	
static
   
bool
    
IsValidIpV4Address
   &
(
  & '
string
  ' -
ip
  . 0
,
  0 1
int
  2 5
from
  6 :
,
  : ;
int
  < ?

toExcluded
  @ J
)
  J K
{
ÀÀ 	
int
ÃÃ 
len
ÃÃ 
=
ÃÃ 

toExcluded
ÃÃ  
-
ÃÃ! "
from
ÃÃ# '
;
ÃÃ' (
int
ÕÕ 
i
ÕÕ 
;
ÕÕ 
return
ŒŒ 
len
ŒŒ 
<=
ŒŒ 
$num
ŒŒ 
&&
ŒŒ 
len
ŒŒ  #
>=
ŒŒ$ &
$num
ŒŒ' (
&&
ŒŒ) +
(
œœ 
i
œœ 
=
œœ 
ip
œœ 
.
œœ 
IndexOf
œœ 
(
œœ  
$char
œœ  #
,
œœ# $
from
œœ% )
+
œœ* +
$num
œœ, -
)
œœ- .
)
œœ. /
>
œœ0 1
$num
œœ2 3
&&
œœ4 6
IsValidIpV4Word
œœ7 F
(
œœF G
ip
œœG I
,
œœI J
from
œœK O
,
œœO P
i
œœQ R
)
œœR S
&&
œœT V
(
–– 
i
–– 
=
–– 
ip
–– 
.
–– 
IndexOf
–– 
(
––  
$char
––  #
,
––# $
from
––% )
=
––* +
i
––, -
+
––. /
$num
––0 1
)
––1 2
)
––2 3
>
––4 5
$num
––6 7
&&
––8 :
IsValidIpV4Word
––; J
(
––J K
ip
––K M
,
––M N
from
––O S
-
––T U
$num
––V W
,
––W X
i
––Y Z
)
––Z [
&&
––\ ^
(
—— 
i
—— 
=
—— 
ip
—— 
.
—— 
IndexOf
—— 
(
——  
$char
——  #
,
——# $
from
——% )
=
——* +
i
——, -
+
——. /
$num
——0 1
)
——1 2
)
——2 3
>
——4 5
$num
——6 7
&&
——8 :
IsValidIpV4Word
——; J
(
——J K
ip
——K M
,
——M N
from
——O S
-
——T U
$num
——V W
,
——W X
i
——Y Z
)
——Z [
&&
——\ ^
IsValidIpV4Word
““ 
(
““  
ip
““  "
,
““" #
i
““$ %
+
““& '
$num
““( )
,
““) *

toExcluded
““+ 5
)
““5 6
;
““6 7
}
”” 	
static
’’ 
bool
’’ 
IsValidIpV4Word
’’ #
(
’’# $
string
’’$ *
word
’’+ /
,
’’/ 0
int
’’1 4
from
’’5 9
,
’’9 :
int
’’; >
toExclusive
’’? J
)
’’J K
{
÷÷ 	
int
◊◊ 
len
◊◊ 
=
◊◊ 
toExclusive
◊◊ !
-
◊◊" #
from
◊◊$ (
;
◊◊( )
char
ÿÿ 
c0
ÿÿ 
,
ÿÿ 
c1
ÿÿ 
,
ÿÿ 
c2
ÿÿ 
;
ÿÿ 
if
ŸŸ 
(
ŸŸ 
len
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
||
ŸŸ 
len
ŸŸ 
>
ŸŸ  
$num
ŸŸ! "
||
ŸŸ# %
(
ŸŸ& '
c0
ŸŸ' )
=
ŸŸ* +
word
ŸŸ, 0
[
ŸŸ0 1
from
ŸŸ1 5
]
ŸŸ5 6
)
ŸŸ6 7
<
ŸŸ8 9
$char
ŸŸ: =
)
ŸŸ= >
{
⁄⁄ 
return
€€ 
false
€€ 
;
€€ 
}
‹‹ 
if
ﬁﬁ 
(
ﬁﬁ 
len
ﬁﬁ 
==
ﬁﬁ 
$num
ﬁﬁ 
)
ﬁﬁ 
{
ﬂﬂ 
return
‡‡ 
(
‡‡ 
c1
‡‡ 
=
‡‡ 
word
‡‡ !
[
‡‡! "
from
‡‡" &
+
‡‡' (
$num
‡‡) *
]
‡‡* +
)
‡‡+ ,
>=
‡‡- /
$char
‡‡0 3
&&
·· 
(
·· 
c2
·· 
=
·· 
word
·· !
[
··! "
from
··" &
+
··' (
$num
··) *
]
··* +
)
··+ ,
>=
··- /
$char
··0 3
&&
‚‚ 
(
‚‚ 
c0
‚‚ 
<=
‚‚ 
$char
‚‚ !
&&
‚‚" $
c1
‚‚% '
<=
‚‚( *
$char
‚‚+ .
&&
‚‚/ 1
c2
‚‚2 4
<=
‚‚5 7
$char
‚‚8 ;
||
„„ 
c0
„„ 
==
„„  
$char
„„! $
&&
„„% '
c1
„„( *
<=
„„+ -
$char
„„. 1
&&
„„2 4
(
„„5 6
c2
„„6 8
<=
„„9 ;
$char
„„< ?
||
„„@ B
c1
„„C E
<
„„F G
$char
„„H K
&&
„„L N
c2
„„O Q
<=
„„R T
$char
„„U X
)
„„X Y
)
„„Y Z
;
„„Z [
}
‰‰ 
return
ÊÊ 
c0
ÊÊ 
<=
ÊÊ 
$char
ÊÊ 
&&
ÊÊ 
(
ÊÊ  !
len
ÊÊ! $
==
ÊÊ% '
$num
ÊÊ( )
||
ÊÊ* , 
IsValidNumericChar
ÊÊ- ?
(
ÊÊ? @
word
ÊÊ@ D
[
ÊÊD E
from
ÊÊE I
+
ÊÊJ K
$num
ÊÊL M
]
ÊÊM N
)
ÊÊN O
)
ÊÊO P
;
ÊÊP Q
}
ÁÁ 	
[
ÈÈ 	

MethodImpl
ÈÈ	 
(
ÈÈ 
MethodImplOptions
ÈÈ %
.
ÈÈ% & 
AggressiveInlining
ÈÈ& 8
)
ÈÈ8 9
]
ÈÈ9 :
static
ÍÍ 
bool
ÍÍ 
IsValidHexChar
ÍÍ "
(
ÍÍ" #
char
ÍÍ# '
c
ÍÍ( )
)
ÍÍ) *
{
ÎÎ 	
return
ÏÏ 
c
ÏÏ 
>=
ÏÏ 
$char
ÏÏ 
&&
ÏÏ 
c
ÏÏ  
<=
ÏÏ! #
$char
ÏÏ$ '
||
ÏÏ( *
c
ÏÏ+ ,
>=
ÏÏ- /
$char
ÏÏ0 3
&&
ÏÏ4 6
c
ÏÏ7 8
<=
ÏÏ9 ;
$char
ÏÏ< ?
||
ÏÏ@ B
c
ÏÏC D
>=
ÏÏE G
$char
ÏÏH K
&&
ÏÏL N
c
ÏÏO P
<=
ÏÏQ S
$char
ÏÏT W
;
ÏÏW X
}
ÌÌ 	
[
ÔÔ 	

MethodImpl
ÔÔ	 
(
ÔÔ 
MethodImplOptions
ÔÔ %
.
ÔÔ% & 
AggressiveInlining
ÔÔ& 8
)
ÔÔ8 9
]
ÔÔ9 :
static
 
bool
  
IsValidNumericChar
 &
(
& '
char
' +
c
, -
)
- .
{
ÒÒ 	
return
ÚÚ 
c
ÚÚ 
>=
ÚÚ 
$char
ÚÚ 
&&
ÚÚ 
c
ÚÚ  
<=
ÚÚ! #
$char
ÚÚ$ '
;
ÚÚ' (
}
ÛÛ 	
[
ıı 	

MethodImpl
ıı	 
(
ıı 
MethodImplOptions
ıı %
.
ıı% & 
AggressiveInlining
ıı& 8
)
ıı8 9
]
ıı9 :
static
ˆˆ 
bool
ˆˆ #
IsValidIPv4MappedChar
ˆˆ )
(
ˆˆ) *
char
ˆˆ* .
c
ˆˆ/ 0
)
ˆˆ0 1
{
˜˜ 	
return
¯¯ 
c
¯¯ 
==
¯¯ 
$char
¯¯ 
||
¯¯ 
c
¯¯  
==
¯¯! #
$char
¯¯$ '
;
¯¯' (
}
˘˘ 	
}
˙˙ 
}˚˚ ¡g
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\PriorityQueue.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

class 
PriorityQueue 
< 
T  
>  !
:" #
IEnumerable$ /
</ 0
T0 1
>1 2
where 
T 
: 
class 
{ 
readonly 
	IComparer 
< 
T 
> 
comparer &
;& '
int 
count 
; 
int 
capacity 
; 
T 	
[	 

]
 
items 
; 
public 
PriorityQueue 
( 
	IComparer &
<& '
T' (
>( )
comparer* 2
)2 3
{ 	
Contract 
. 
Requires 
( 
comparer &
!=' )
null* .
). /
;/ 0
this 
. 
comparer 
= 
comparer $
;$ %
this 
. 
capacity 
= 
$num 
; 
this 
. 
items 
= 
new 
T 
[ 
this #
.# $
capacity$ ,
], -
;- .
} 	
public 
PriorityQueue 
( 
) 
: 
this 
( 
Comparer 
< 
T 
> 
. 
Default &
)& '
{ 	
} 	
public!! 
int!! 
Count!! 
=>!! 
this!!  
.!!  !
count!!! &
;!!& '
public## 
T## 
Dequeue## 
(## 
)## 
{$$ 	
T%% 
result%% 
=%% 
this%% 
.%% 
Peek%%  
(%%  !
)%%! "
;%%" #
if&& 
(&& 
result&& 
==&& 
null&& 
)&& 
{'' 
return(( 
null(( 
;(( 
})) 
int++ 
newCount++ 
=++ 
--++ 
this++ !
.++! "
count++" '
;++' (
T,, 
lastItem,, 
=,, 
this,, 
.,, 
items,, #
[,,# $
newCount,,$ ,
],,, -
;,,- .
this-- 
.-- 
items-- 
[-- 
newCount-- 
]--  
=--! "
null--# '
;--' (
if.. 
(.. 
newCount.. 
>.. 
$num.. 
).. 
{// 
this00 
.00 
TrickleDown00  
(00  !
$num00! "
,00" #
lastItem00$ ,
)00, -
;00- .
}11 
return33 
result33 
;33 
}44 	
public66 
T66 
Peek66 
(66 
)66 
=>66 
this66 
.66  
count66  %
==66& (
$num66) *
?66+ ,
null66- 1
:662 3
this664 8
.668 9
items669 >
[66> ?
$num66? @
]66@ A
;66A B
public88 
void88 
Enqueue88 
(88 
T88 
item88 "
)88" #
{99 	
Contract:: 
.:: 
Requires:: 
(:: 
item:: "
!=::# %
null::& *
)::* +
;::+ ,
int<< 
oldCount<< 
=<< 
this<< 
.<<  
count<<  %
;<<% &
if== 
(== 
oldCount== 
==== 
this==  
.==  !
capacity==! )
)==) *
{>> 
this?? 
.?? 
GrowHeap?? 
(?? 
)?? 
;??  
}@@ 
thisAA 
.AA 
countAA 
=AA 
oldCountAA !
+AA" #
$numAA$ %
;AA% &
thisBB 
.BB 
BubbleUpBB 
(BB 
oldCountBB "
,BB" #
itemBB$ (
)BB( )
;BB) *
}CC 	
publicEE 
voidEE 
RemoveEE 
(EE 
TEE 
itemEE !
)EE! "
{FF 	
intGG 
indexGG 
=GG 
ArrayGG 
.GG 
IndexOfGG %
(GG% &
thisGG& *
.GG* +
itemsGG+ 0
,GG0 1
itemGG2 6
)GG6 7
;GG7 8
ifHH 
(HH 
indexHH 
==HH 
-HH 
$numHH 
)HH 
{II 
returnJJ 
;JJ 
}KK 
thisMM 
.MM 
countMM 
--MM 
;MM 
ifNN 
(NN 
indexNN 
==NN 
thisNN 
.NN 
countNN #
)NN# $
{OO 
thisPP 
.PP 
itemsPP 
[PP 
indexPP  
]PP  !
=PP" #
defaultPP$ +
(PP+ ,
TPP, -
)PP- .
;PP. /
}QQ 
elseRR 
{SS 
TTT 
lastTT 
=TT 
thisTT 
.TT 
itemsTT #
[TT# $
thisTT$ (
.TT( )
countTT) .
]TT. /
;TT/ 0
thisUU 
.UU 
itemsUU 
[UU 
thisUU 
.UU  
countUU  %
]UU% &
=UU' (
defaultUU) 0
(UU0 1
TUU1 2
)UU2 3
;UU3 4
thisVV 
.VV 
TrickleDownVV  
(VV  !
indexVV! &
,VV& '
lastVV( ,
)VV, -
;VV- .
ifWW 
(WW 
thisWW 
.WW 
itemsWW 
[WW 
indexWW $
]WW$ %
==WW& (
lastWW) -
)WW- .
{XX 
thisYY 
.YY 
BubbleUpYY !
(YY! "
indexYY" '
,YY' (
lastYY) -
)YY- .
;YY. /
}ZZ 
}[[ 
}\\ 	
void^^ 
BubbleUp^^ 
(^^ 
int^^ 
index^^ 
,^^  
T^^! "
item^^# '
)^^' (
{__ 	
whileaa 
(aa 
indexaa 
>aa 
$numaa 
)aa 
{bb 
intcc 
parentIndexcc 
=cc  !
(cc" #
indexcc# (
-cc) *
$numcc+ ,
)cc, -
>>cc. 0
$numcc1 2
;cc2 3
Tdd 

parentItemdd 
=dd 
thisdd #
.dd# $
itemsdd$ )
[dd) *
parentIndexdd* 5
]dd5 6
;dd6 7
ifee 
(ee 
thisee 
.ee 
compareree !
.ee! "
Compareee" )
(ee) *
itemee* .
,ee. /

parentItemee0 :
)ee: ;
>=ee< >
$numee? @
)ee@ A
{ff 
breakgg 
;gg 
}hh 
thisii 
.ii 
itemsii 
[ii 
indexii  
]ii  !
=ii" #

parentItemii$ .
;ii. /
indexjj 
=jj 
parentIndexjj #
;jj# $
}kk 
thisll 
.ll 
itemsll 
[ll 
indexll 
]ll 
=ll 
itemll  $
;ll$ %
}mm 	
voidoo 
GrowHeapoo 
(oo 
)oo 
{pp 	
intqq 
oldCapacityqq 
=qq 
thisqq "
.qq" #
capacityqq# +
;qq+ ,
thisrr 
.rr 
capacityrr 
=rr 
oldCapacityrr '
+rr( )
(rr* +
oldCapacityrr+ 6
<=rr7 9
$numrr: <
?rr= >
oldCapacityrr? J
+rrK L
$numrrM N
:rrO P
(rrQ R
oldCapacityrrR ]
>>rr^ `
$numrra b
)rrb c
)rrc d
;rrd e
varss 
newHeapss 
=ss 
newss 
Tss 
[ss  
thisss  $
.ss$ %
capacityss% -
]ss- .
;ss. /
Arraytt 
.tt 
Copytt 
(tt 
thistt 
.tt 
itemstt !
,tt! "
$numtt# $
,tt$ %
newHeaptt& -
,tt- .
$numtt/ 0
,tt0 1
thistt2 6
.tt6 7
counttt7 <
)tt< =
;tt= >
thisuu 
.uu 
itemsuu 
=uu 
newHeapuu  
;uu  !
}vv 	
voidxx 
TrickleDownxx 
(xx 
intxx 
indexxx "
,xx" #
Txx$ %
itemxx& *
)xx* +
{yy 	
intzz 
middleIndexzz 
=zz 
thiszz "
.zz" #
countzz# (
>>zz) +
$numzz, -
;zz- .
while{{ 
({{ 
index{{ 
<{{ 
middleIndex{{ &
){{& '
{|| 
int}} 

childIndex}} 
=}}  
(}}! "
index}}" '
<<}}( *
$num}}+ ,
)}}, -
+}}. /
$num}}0 1
;}}1 2
T~~ 
	childItem~~ 
=~~ 
this~~ "
.~~" #
items~~# (
[~~( )

childIndex~~) 3
]~~3 4
;~~4 5
int 
rightChildIndex #
=$ %

childIndex& 0
+1 2
$num3 4
;4 5
if
ÄÄ 
(
ÄÄ 
rightChildIndex
ÄÄ #
<
ÄÄ$ %
this
ÄÄ& *
.
ÄÄ* +
count
ÄÄ+ 0
&&
ÅÅ 
this
ÅÅ 
.
ÅÅ 
comparer
ÅÅ $
.
ÅÅ$ %
Compare
ÅÅ% ,
(
ÅÅ, -
	childItem
ÅÅ- 6
,
ÅÅ6 7
this
ÅÅ8 <
.
ÅÅ< =
items
ÅÅ= B
[
ÅÅB C
rightChildIndex
ÅÅC R
]
ÅÅR S
)
ÅÅS T
>
ÅÅU V
$num
ÅÅW X
)
ÅÅX Y
{
ÇÇ 

childIndex
ÉÉ 
=
ÉÉ  
rightChildIndex
ÉÉ! 0
;
ÉÉ0 1
	childItem
ÑÑ 
=
ÑÑ 
this
ÑÑ  $
.
ÑÑ$ %
items
ÑÑ% *
[
ÑÑ* +
rightChildIndex
ÑÑ+ :
]
ÑÑ: ;
;
ÑÑ; <
}
ÖÖ 
if
ÜÜ 
(
ÜÜ 
this
ÜÜ 
.
ÜÜ 
comparer
ÜÜ !
.
ÜÜ! "
Compare
ÜÜ" )
(
ÜÜ) *
item
ÜÜ* .
,
ÜÜ. /
	childItem
ÜÜ0 9
)
ÜÜ9 :
<=
ÜÜ; =
$num
ÜÜ> ?
)
ÜÜ? @
{
áá 
break
àà 
;
àà 
}
ââ 
this
ää 
.
ää 
items
ää 
[
ää 
index
ää  
]
ää  !
=
ää" #
	childItem
ää$ -
;
ää- .
index
ãã 
=
ãã 

childIndex
ãã "
;
ãã" #
}
åå 
this
çç 
.
çç 
items
çç 
[
çç 
index
çç 
]
çç 
=
çç 
item
çç  $
;
çç$ %
}
éé 	
public
êê 
IEnumerator
êê 
<
êê 
T
êê 
>
êê 
GetEnumerator
êê +
(
êê+ ,
)
êê, -
{
ëë 	
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí 
this
íí  $
.
íí$ %
count
íí% *
;
íí* +
i
íí, -
++
íí- /
)
íí/ 0
{
ìì 
yield
îî 
return
îî 
this
îî !
.
îî! "
items
îî" '
[
îî' (
i
îî( )
]
îî) *
;
îî* +
}
ïï 
}
ññ 	
IEnumerator
òò 
IEnumerable
òò 
.
òò  
GetEnumerator
òò  -
(
òò- .
)
òò. /
=>
òò0 2
this
òò3 7
.
òò7 8
GetEnumerator
òò8 E
(
òòE F
)
òòF G
;
òòG H
public
öö 
void
öö 
Clear
öö 
(
öö 
)
öö 
{
õõ 	
this
úú 
.
úú 
count
úú 
=
úú 
$num
úú 
;
úú 
Array
ùù 
.
ùù 
Clear
ùù 
(
ùù 
this
ùù 
.
ùù 
items
ùù "
,
ùù" #
$num
ùù$ %
,
ùù% &
$num
ùù' (
)
ùù( )
;
ùù) *
}
ûû 	
}
üü 
}†† ˆ
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\RandomExtensions.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
RandomExtensions (
{		 
public

 
static

 
long

 
NextLong

 #
(

# $
this

$ (
Random

) /
random

0 6
)

6 7
=>

8 :
random

; A
.

A B
Next

B F
(

F G
)

G H
<<

I K
$num

L N
&

O P
	unchecked

Q Z
(

Z [
(

[ \
uint

\ `
)

` a
random

a g
.

g h
Next

h l
(

l m
)

m n
)

n o
;

o p
} 
} ´Z
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ReferenceCountUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

static

 
class

 
ReferenceCountUtil

 *
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
ReferenceCountUtilZ l
)l m
)m n
;n o
public 
static 
T 
Retain 
< 
T  
>  !
(! "
T" #
msg$ '
)' (
{ 	
var 
counted 
= 
msg 
as  
IReferenceCounted! 2
;2 3
if 
( 
counted 
!= 
null 
)  
{ 
return 
( 
T 
) 
counted !
.! "
Retain" (
(( )
)) *
;* +
} 
return 
msg 
; 
} 	
public"" 
static"" 
T"" 
Retain"" 
<"" 
T""  
>""  !
(""! "
T""" #
msg""$ '
,""' (
int"") ,
	increment""- 6
)""6 7
{## 	
var$$ 
counted$$ 
=$$ 
msg$$ 
as$$  
IReferenceCounted$$! 2
;$$2 3
if%% 
(%% 
counted%% 
!=%% 
null%% 
)%%  
{&& 
return'' 
('' 
T'' 
)'' 
counted'' !
.''! "
Retain''" (
(''( )
	increment'') 2
)''2 3
;''3 4
}(( 
return)) 
msg)) 
;)) 
}** 	
public11 
static11 
T11 
Touch11 
<11 
T11 
>11  
(11  !
T11! "
msg11# &
)11& '
{22 	
var33 
refCnt33 
=33 
msg33 
as33 
IReferenceCounted33  1
;331 2
if44 
(44 
refCnt44 
!=44 
null44 
)44 
{55 
return66 
(66 
T66 
)66 
refCnt66  
.66  !
Touch66! &
(66& '
)66' (
;66( )
}77 
return88 
msg88 
;88 
}99 	
public@@ 
static@@ 
T@@ 
Touch@@ 
<@@ 
T@@ 
>@@  
(@@  !
T@@! "
msg@@# &
,@@& '
object@@( .
hint@@/ 3
)@@3 4
{AA 	
varBB 
refCntBB 
=BB 
msgBB 
asBB 
IReferenceCountedBB  1
;BB1 2
ifCC 
(CC 
refCntCC 
!=CC 
nullCC 
)CC 
{DD 
returnEE 
(EE 
TEE 
)EE 
refCntEE  
.EE  !
TouchEE! &
(EE& '
hintEE' +
)EE+ ,
;EE, -
}FF 
returnGG 
msgGG 
;GG 
}HH 	
publicOO 
staticOO 
boolOO 
ReleaseOO "
(OO" #
objectOO# )
msgOO* -
)OO- .
{PP 	
varQQ 
countedQQ 
=QQ 
msgQQ 
asQQ  
IReferenceCountedQQ! 2
;QQ2 3
ifRR 
(RR 
countedRR 
!=RR 
nullRR 
)RR  
{SS 
returnTT 
countedTT 
.TT 
ReleaseTT &
(TT& '
)TT' (
;TT( )
}UU 
returnVV 
falseVV 
;VV 
}WW 	
public^^ 
static^^ 
bool^^ 
Release^^ "
(^^" #
object^^# )
msg^^* -
,^^- .
int^^/ 2
	decrement^^3 <
)^^< =
{__ 	
var`` 
counted`` 
=`` 
msg`` 
as``  
IReferenceCounted``! 2
;``2 3
ifaa 
(aa 
countedaa 
!=aa 
nullaa 
)aa  
{bb 
returncc 
countedcc 
.cc 
Releasecc &
(cc& '
	decrementcc' 0
)cc0 1
;cc1 2
}dd 
returnee 
falseee 
;ee 
}ff 	
publicpp 
staticpp 
voidpp 
SafeReleasepp &
(pp& '
objectpp' -
msgpp. 1
)pp1 2
{qq 	
tryrr 
{ss 
Releasett 
(tt 
msgtt 
)tt 
;tt 
}uu 
catchvv 
(vv 
	Exceptionvv 
exvv 
)vv  
{ww 
Loggerxx 
.xx 
Warnxx 
(xx 
$strxx =
,xx= >
msgxx? B
,xxB C
exxxD F
)xxF G
;xxG H
}yy 
}zz 	
public
ÑÑ 
static
ÑÑ 
void
ÑÑ 
SafeRelease
ÑÑ &
(
ÑÑ& '
object
ÑÑ' -
msg
ÑÑ. 1
,
ÑÑ1 2
int
ÑÑ3 6
	decrement
ÑÑ7 @
)
ÑÑ@ A
{
ÖÖ 	
try
ÜÜ 
{
áá 
Release
àà 
(
àà 
msg
àà 
,
àà 
	decrement
àà &
)
àà& '
;
àà' (
}
ââ 
catch
ää 
(
ää 
	Exception
ää 
ex
ää 
)
ää  
{
ãã 
if
åå 
(
åå 
Logger
åå 
.
åå 
WarnEnabled
åå &
)
åå& '
{
çç 
Logger
éé 
.
éé 
Warn
éé 
(
éé  
$str
éé  Q
,
ééQ R
msg
ééS V
,
ééV W
	decrement
ééX a
,
ééa b
ex
ééc e
)
éée f
;
ééf g
}
èè 
}
êê 
}
ëë 	
public
ìì 
static
ìì 
void
ìì 
SafeRelease
ìì &
(
ìì& '
this
ìì' +
IReferenceCounted
ìì, =
msg
ìì> A
)
ììA B
{
îî 	
try
ïï 
{
ññ 
msg
óó 
?
óó 
.
óó 
Release
óó 
(
óó 
)
óó 
;
óó 
}
òò 
catch
ôô 
(
ôô 
	Exception
ôô 
ex
ôô 
)
ôô  
{
öö 
Logger
õõ 
.
õõ 
Warn
õõ 
(
õõ 
$str
õõ =
,
õõ= >
msg
õõ? B
,
õõB C
ex
õõD F
)
õõF G
;
õõG H
}
úú 
}
ùù 	
public
üü 
static
üü 
void
üü 
SafeRelease
üü &
(
üü& '
this
üü' +
IReferenceCounted
üü, =
msg
üü> A
,
üüA B
int
üüC F
	decrement
üüG P
)
üüP Q
{
†† 	
try
°° 
{
¢¢ 
msg
££ 
?
££ 
.
££ 
Release
££ 
(
££ 
	decrement
££ &
)
££& '
;
££' (
}
§§ 
catch
•• 
(
•• 
	Exception
•• 
ex
•• 
)
••  
{
¶¶ 
Logger
ßß 
.
ßß 
Warn
ßß 
(
ßß 
$str
ßß M
,
ßßM N
msg
ßßO R
,
ßßR S
	decrement
ßßT ]
,
ßß] ^
ex
ßß_ a
)
ßßa b
;
ßßb c
}
®® 
}
©© 	
public
∞∞ 
static
∞∞ 
T
∞∞ 
ReleaseLater
∞∞ $
<
∞∞$ %
T
∞∞% &
>
∞∞& '
(
∞∞' (
T
∞∞( )
msg
∞∞* -
)
∞∞- .
=>
∞∞/ 1
ReleaseLater
∞∞2 >
(
∞∞> ?
msg
∞∞? B
,
∞∞B C
$num
∞∞D E
)
∞∞E F
;
∞∞F G
public
∑∑ 
static
∑∑ 
T
∑∑ 
ReleaseLater
∑∑ $
<
∑∑$ %
T
∑∑% &
>
∑∑& '
(
∑∑' (
T
∑∑( )
msg
∑∑* -
,
∑∑- .
int
∑∑/ 2
	decrement
∑∑3 <
)
∑∑< =
{
∏∏ 	
var
ππ 
referenceCounted
ππ  
=
ππ! "
msg
ππ# &
as
ππ' )
IReferenceCounted
ππ* ;
;
ππ; <
if
∫∫ 
(
∫∫ 
referenceCounted
∫∫  
!=
∫∫! #
null
∫∫$ (
)
∫∫( )
{
ªª  
ThreadDeathWatcher
ºº "
.
ºº" #
Watch
ºº# (
(
ºº( )
Thread
ºº) /
.
ºº/ 0
CurrentThread
ºº0 =
,
ºº= >
(
ºº? @
)
ºº@ A
=>
ººB D
{
ΩΩ 
try
ææ 
{
øø 
if
¿¿ 
(
¿¿ 
!
¿¿ 
referenceCounted
¿¿ -
.
¿¿- .
Release
¿¿. 5
(
¿¿5 6
	decrement
¿¿6 ?
)
¿¿? @
)
¿¿@ A
{
¡¡ 
Logger
¬¬ "
.
¬¬" #
Warn
¬¬# '
(
¬¬' (
$str
¬¬( =
,
¬¬= >!
FormatReleaseString
¬¬? R
(
¬¬R S
referenceCounted
¬¬S c
,
¬¬c d
	decrement
¬¬e n
)
¬¬n o
)
¬¬o p
;
¬¬p q
}
√√ 
else
ƒƒ 
{
≈≈ 
Logger
∆∆ "
.
∆∆" #
Debug
∆∆# (
(
∆∆( )
$str
∆∆) 7
,
∆∆7 8!
FormatReleaseString
∆∆9 L
(
∆∆L M
referenceCounted
∆∆M ]
,
∆∆] ^
	decrement
∆∆_ h
)
∆∆h i
)
∆∆i j
;
∆∆j k
}
«« 
}
»» 
catch
…… 
(
…… 
	Exception
…… $
ex
……% '
)
……' (
{
   
Logger
ÀÀ 
.
ÀÀ 
Warn
ÀÀ #
(
ÀÀ# $
$str
ÀÀ$ E
,
ÀÀE F
referenceCounted
ÀÀG W
,
ÀÀW X
ex
ÀÀY [
)
ÀÀ[ \
;
ÀÀ\ ]
}
ÃÃ 
}
ÕÕ 
)
ÕÕ 
;
ÕÕ 
}
ŒŒ 
return
œœ 
msg
œœ 
;
œœ 
}
–– 	
static
““ 
string
““ !
FormatReleaseString
““ )
(
““) *
IReferenceCounted
““* ;
referenceCounted
““< L
,
““L M
int
““N Q
	decrement
““R [
)
““[ \
=>
”” 
$"
”” 
{
”” 
referenceCounted
”” "
.
””" #
GetType
””# *
(
””* +
)
””+ ,
.
””, -
Name
””- 1
}
””1 2
$str
””2 ;
{
””; <
	decrement
””< E
.
””E F
ToString
””F N
(
””N O
)
””O P
}
””P Q
$str
””Q [
{
””[ \
referenceCounted
””\ l
.
””l m
ReferenceCount
””m {
.
””{ |
ToString””| Ñ
(””Ñ Ö
)””Ö Ü
}””Ü á
"””á à
;””à â
}
‘‘ 
}’’ º
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ReferenceEqualityComparer.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

sealed

 
class

 %
ReferenceEqualityComparer

 1
: 	
IEqualityComparer
 
, 
IEqualityComparer .
<. /
object/ 5
>5 6
{ 
public 
static 
readonly %
ReferenceEqualityComparer 8
Default9 @
=A B
newC F%
ReferenceEqualityComparerG `
(` a
)a b
;b c%
ReferenceEqualityComparer !
(! "
)" #
{ 	
} 	
public 
new 
bool 
Equals 
( 
object %
x& '
,' (
object) /
y0 1
)1 2
=>3 5
ReferenceEquals6 E
(E F
xF G
,G H
yI J
)J K
;K L
public 
int 
GetHashCode 
( 
object %
obj& )
)) *
=>+ -
RuntimeHelpers. <
.< =
GetHashCode= H
(H I
objI L
)L M
;M N
} 
} ˆ1
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\Signal.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class 
Signal 
:  
	Exception! *
,* +
	IConstant, 5
,5 6
IComparable7 B
,B C
IComparableD O
<O P
SignalP V
>V W
{		 
static

 
readonly

 
SignalConstantPool

 *
Pool

+ /
=

0 1
new

2 5
SignalConstantPool

6 H
(

H I
)

I J
;

J K
sealed 
class 
SignalConstantPool '
:( )
ConstantPool* 6
{ 	
	protected 
override 
	IConstant (
NewConstant) 4
<4 5
T5 6
>6 7
(7 8
int8 ;
id< >
,> ?
string@ F
nameG K
)K L
=>M O
newP S
SignalT Z
(Z [
id[ ]
,] ^
name_ c
)c d
;d e
} 	
;	 

public 
static 
Signal 
ValueOf $
($ %
string% +
name, 0
)0 1
=>2 4
(5 6
Signal6 <
)< =
Pool= A
.A B
ValueOfB I
<I J
SignalJ P
>P Q
(Q R
nameR V
)V W
;W X
public 
static 
Signal 
ValueOf $
($ %
Type% )
firstNameComponent* <
,< =
string> D
secondNameComponentE X
)X Y
=>Z \
(] ^
Signal^ d
)d e
Poole i
.i j
ValueOfj q
<q r
Signalr x
>x y
(y z
firstNameComponent	z å
,
å ç!
secondNameComponent
é °
)
° ¢
;
¢ £
readonly 
SignalConstant 
constant  (
;( )
Signal 
( 
int 
id 
, 
string 
name "
)" #
{ 	
this 
. 
constant 
= 
new 
SignalConstant  .
(. /
id/ 1
,1 2
name3 7
)7 8
;8 9
} 	
public 
void 
Expect 
( 
Signal !
signal" (
)( )
{ 	
if 
( 
! 
ReferenceEquals  
(  !
this! %
,% &
signal' -
)- .
). /
{ 
throw   
new   %
InvalidOperationException   3
(  3 4
$"  4 6
$str  6 I
{  I J
signal  J P
}  P Q
"  Q R
)  R S
;  S T
}!! 
}"" 	
public$$ 
int$$ 
Id$$ 
=>$$ 
this$$ 
.$$ 
constant$$ &
.$$& '
Id$$' )
;$$) *
public&& 
string&& 
Name&& 
=>&& 
this&& "
.&&" #
constant&&# +
.&&+ ,
Name&&, 0
;&&0 1
public(( 
override(( 
bool(( 
Equals(( #
(((# $
object(($ *
obj((+ .
)((. /
=>((0 2
ReferenceEquals((3 B
(((B C
this((C G
,((G H
obj((I L
)((L M
;((M N
public** 
override** 
int** 
GetHashCode** '
(**' (
)**( )
=>*** ,
this**- 1
.**1 2
Id**2 4
;**4 5
public,, 
int,, 
	CompareTo,, 
(,, 
object,, #
obj,,$ '
),,' (
{-- 	
if.. 
(.. 
ReferenceEquals.. 
(..  
this..  $
,..$ %
obj..& )
)..) *
)..* +
{// 
return00 
$num00 
;00 
}11 
if22 
(22 
!22 
ReferenceEquals22  
(22  !
obj22! $
,22$ %
null22& *
)22* +
&&22, .
obj22/ 2
is223 5
Signal226 <
)22< =
{33 
return44 
this44 
.44 
	CompareTo44 %
(44% &
(44& '
Signal44' -
)44- .
obj44. 1
)441 2
;442 3
}55 
throw77 
new77 
	Exception77 
(77  
$str77  R
)77R S
;77S T
}88 	
public:: 
int:: 
	CompareTo:: 
(:: 
Signal:: #
other::$ )
)::) *
{;; 	
if<< 
(<< 
ReferenceEquals<< 
(<<  
this<<  $
,<<$ %
other<<& +
)<<+ ,
)<<, -
{== 
return>> 
$num>> 
;>> 
}?? 
returnAA 
thisAA 
.AA 
constantAA  
.AA  !
	CompareToAA! *
(AA* +
otherAA+ 0
.AA0 1
constantAA1 9
)AA9 :
;AA: ;
}BB 	
publicDD 
overrideDD 
stringDD 
ToStringDD '
(DD' (
)DD( )
=>DD* ,
thisDD- 1
.DD1 2
NameDD2 6
;DD6 7
sealedFF 
classFF 
SignalConstantFF #
:FF$ %
AbstractConstantFF& 6
<FF6 7
SignalConstantFF7 E
>FFE F
{GG 	
publicHH 
SignalConstantHH !
(HH! "
intHH" %
idHH& (
,HH( )
stringHH* 0
nameHH1 5
)HH5 6
:HH7 8
baseHH9 =
(HH= >
idHH> @
,HH@ A
nameHHB F
)HHF G
{II 
}JJ 
}KK 	
}LL 
}MM ≠Ü
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\StringBuilderCharSequence.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class %
StringBuilderCharSequence 1
:2 3
ICharSequence4 A
,A B

IEquatableC M
<M N%
StringBuilderCharSequenceN g
>g h
{ 
readonly 
StringBuilder 
builder &
;& '
readonly 
int 
offset 
; 
public %
StringBuilderCharSequence (
(( )
int) ,
capacity- 5
=6 7
$num8 9
)9 :
{ 	
Contract 
. 
Requires 
( 
capacity &
>=' )
$num* +
)+ ,
;, -
this 
. 
builder 
= 
new 
StringBuilder ,
(, -
capacity- 5
)5 6
;6 7
this 
. 
offset 
= 
$num 
; 
this 
. 
Count 
= 
$num 
; 
} 	
public %
StringBuilderCharSequence (
(( )
StringBuilder) 6
builder7 >
)> ?
:@ A
thisB F
(F G
builderG N
,N O
$numP Q
,Q R
builderS Z
.Z [
Length[ a
)a b
{ 	
} 	
public %
StringBuilderCharSequence (
(( )
StringBuilder) 6
builder7 >
,> ?
int@ C
offsetD J
,J K
intL O
countP U
)U V
{ 	
Contract   
.   
Requires   
(   
builder   %
!=  & (
null  ) -
)  - .
;  . /
Contract!! 
.!! 
Requires!! 
(!! 
offset!! $
>=!!% '
$num!!( )
&&!!* ,
count!!- 2
>=!!3 5
$num!!6 7
)!!7 8
;!!8 9
Contract"" 
."" 
Requires"" 
("" 
offset"" $
<=""% '
builder""( /
.""/ 0
Length""0 6
-""7 8
count""9 >
)""> ?
;""? @
this$$ 
.$$ 
builder$$ 
=$$ 
builder$$ "
;$$" #
this%% 
.%% 
offset%% 
=%% 
offset%%  
;%%  !
this&& 
.&& 
Count&& 
=&& 
count&& 
;&& 
}'' 	
public)) 
ICharSequence)) 
SubSequence)) (
())( )
int))) ,
start))- 2
)))2 3
=>))4 6
this))7 ;
.)); <
SubSequence))< G
())G H
start))H M
,))M N
this))O S
.))S T
Count))T Y
)))Y Z
;))Z [
public++ 
ICharSequence++ 
SubSequence++ (
(++( )
int++) ,
start++- 2
,++2 3
int++4 7
end++8 ;
)++; <
{,, 	
Contract-- 
.-- 
Requires-- 
(-- 
start-- #
>=--$ &
$num--' (
&&--) +
end--, /
>=--0 2
start--3 8
)--8 9
;--9 :
Contract.. 
... 
Requires.. 
(.. 
end.. !
<=.." $
this..% )
...) *
Count..* /
)../ 0
;..0 1
return00 
end00 
==00 
start00 
?11 
new11 %
StringBuilderCharSequence11 0
(110 1
)111 2
:22 
new22 %
StringBuilderCharSequence22 0
(220 1
this221 5
.225 6
builder226 =
,22= >
this22? C
.22C D
offset22D J
+22K L
start22M R
,22R S
end22T W
-22X Y
start22Z _
)22_ `
;22` a
}33 	
public55 
int55 
Count55 
{55 
get55 
;55 
private55  '
set55( +
;55+ ,
}55- .
public77 
char77 
this77 
[77 
int77 
index77 "
]77" #
{88 	
get99 
{:: 
Contract;; 
.;; 
Requires;; !
(;;! "
index;;" '
>=;;( *
$num;;+ ,
&&;;- /
index;;0 5
<;;6 7
this;;8 <
.;;< =
Count;;= B
);;B C
;;;C D
return<< 
this<< 
.<< 
builder<< #
[<<# $
this<<$ (
.<<( )
offset<<) /
+<<0 1
index<<2 7
]<<7 8
;<<8 9
}== 
}>> 	
public@@ 
void@@ 
Append@@ 
(@@ 
string@@ !
value@@" '
)@@' (
{AA 	
thisBB 
.BB 
builderBB 
.BB 
AppendBB 
(BB  
valueBB  %
)BB% &
;BB& '
thisCC 
.CC 
CountCC 
+=CC 
valueCC 
.CC  
LengthCC  &
;CC& '
}DD 	
publicFF 
voidFF 
AppendFF 
(FF 
stringFF !
valueFF" '
,FF' (
intFF) ,
indexFF- 2
,FF2 3
intFF4 7
countFF8 =
)FF= >
{GG 	
thisHH 
.HH 
builderHH 
.HH 
AppendHH 
(HH  
valueHH  %
,HH% &
indexHH' ,
,HH, -
countHH. 3
)HH3 4
;HH4 5
thisII 
.II 
CountII 
+=II 
countII 
;II  
}JJ 	
publicLL 
voidLL 
AppendLL 
(LL 
ICharSequenceLL (
valueLL) .
)LL. /
{MM 	
ifNN 
(NN 
valueNN 
==NN 
nullNN 
||NN  
valueNN! &
.NN& '
CountNN' ,
==NN- /
$numNN0 1
)NN1 2
{OO 
returnPP 
;PP 
}QQ 
thisSS 
.SS 
builderSS 
.SS 
AppendSS 
(SS  
valueSS  %
)SS% &
;SS& '
thisTT 
.TT 
CountTT 
+=TT 
valueTT 
.TT  
CountTT  %
;TT% &
}UU 	
publicWW 
voidWW 
AppendWW 
(WW 
ICharSequenceWW (
valueWW) .
,WW. /
intWW0 3
indexWW4 9
,WW9 :
intWW; >
countWW? D
)WWD E
{XX 	
ifYY 
(YY 
valueYY 
==YY 
nullYY 
||YY  
countYY! &
==YY' )
$numYY* +
)YY+ ,
{ZZ 
return[[ 
;[[ 
}\\ 
this^^ 
.^^ 
Append^^ 
(^^ 
value^^ 
.^^ 
SubSequence^^ )
(^^) *
index^^* /
,^^/ 0
index^^1 6
+^^7 8
count^^9 >
)^^> ?
)^^? @
;^^@ A
}__ 	
publicaa 
voidaa 
Appendaa 
(aa 
charaa 
valueaa  %
)aa% &
{bb 	
thiscc 
.cc 
buildercc 
.cc 
Appendcc 
(cc  
valuecc  %
)cc% &
;cc& '
thisdd 
.dd 
Countdd 
++dd 
;dd 
}ee 	
publicgg 
voidgg 
Insertgg 
(gg 
intgg 
startgg $
,gg$ %
chargg& *
valuegg+ 0
)gg0 1
{hh 	
Contractii 
.ii 
Requiresii 
(ii 
startii #
>=ii$ &
$numii' (
&&ii) +
startii, 1
<ii2 3
thisii4 8
.ii8 9
Countii9 >
)ii> ?
;ii? @
thiskk 
.kk 
builderkk 
.kk 
Insertkk 
(kk  
thiskk  $
.kk$ %
offsetkk% +
+kk, -
startkk. 3
,kk3 4
valuekk5 :
)kk: ;
;kk; <
thisll 
.ll 
Countll 
++ll 
;ll 
}mm 	
publicoo 
booloo 
RegionMatchesoo !
(oo! "
intoo" %
	thisStartoo& /
,oo/ 0
ICharSequenceoo1 >
seqoo? B
,ooB C
intooD G
startooH M
,ooM N
intooO R
lengthooS Y
)ooY Z
=>oo[ ]
CharUtilpp 
.pp 
RegionMatchespp "
(pp" #
thispp# '
,pp' (
thispp) -
.pp- .
offsetpp. 4
+pp5 6
	thisStartpp7 @
,pp@ A
seqppB E
,ppE F
startppG L
,ppL M
lengthppN T
)ppT U
;ppU V
publicrr 
boolrr #
RegionMatchesIgnoreCaserr +
(rr+ ,
intrr, /
	thisStartrr0 9
,rr9 :
ICharSequencerr; H
seqrrI L
,rrL M
intrrN Q
startrrR W
,rrW X
intrrY \
lengthrr] c
)rrc d
=>rre g
CharUtilss 
.ss #
RegionMatchesIgnoreCasess ,
(ss, -
thisss- 1
,ss1 2
thisss3 7
.ss7 8
offsetss8 >
+ss? @
	thisStartssA J
,ssJ K
seqssL O
,ssO P
startssQ V
,ssV W
lengthssX ^
)ss^ _
;ss_ `
publicuu 
intuu 
IndexOfuu 
(uu 
charuu 
chuu  "
,uu" #
intuu$ '
startuu( -
=uu. /
$numuu0 1
)uu1 2
=>uu3 5
CharUtiluu6 >
.uu> ?
IndexOfuu? F
(uuF G
thisuuG K
,uuK L
chuuM O
,uuO P
startuuQ V
)uuV W
;uuW X
publicww 
stringww 
ToStringww 
(ww 
intww "
startww# (
)ww( )
{xx 	
Contractyy 
.yy 
Requiresyy 
(yy 
startyy #
>=yy$ &
$numyy' (
&&yy) +
startyy, 1
<yy2 3
thisyy4 8
.yy8 9
Countyy9 >
)yy> ?
;yy? @
return{{ 
this{{ 
.{{ 
builder{{ 
.{{  
ToString{{  (
({{( )
this{{) -
.{{- .
offset{{. 4
+{{5 6
start{{7 <
,{{< =
this{{> B
.{{B C
Count{{C H
){{H I
;{{I J
}|| 	
public~~ 
override~~ 
string~~ 
ToString~~ '
(~~' (
)~~( )
=>~~* ,
this~~- 1
.~~1 2
Count~~2 7
==~~8 :
$num~~; <
?~~= >
string~~? E
.~~E F
Empty~~F K
:~~L M
this~~N R
.~~R S
ToString~~S [
(~~[ \
$num~~\ ]
)~~] ^
;~~^ _
public
ÄÄ 
bool
ÄÄ 
Equals
ÄÄ 
(
ÄÄ '
StringBuilderCharSequence
ÄÄ 4
other
ÄÄ5 :
)
ÄÄ: ;
{
ÅÅ 	
if
ÇÇ 
(
ÇÇ 
other
ÇÇ 
==
ÇÇ 
null
ÇÇ 
)
ÇÇ 
{
ÉÉ 
return
ÑÑ 
false
ÑÑ 
;
ÑÑ 
}
ÖÖ 
if
ÜÜ 
(
ÜÜ 
ReferenceEquals
ÜÜ 
(
ÜÜ  
this
ÜÜ  $
,
ÜÜ$ %
other
ÜÜ& +
)
ÜÜ+ ,
)
ÜÜ, -
{
áá 
return
àà 
true
àà 
;
àà 
}
ââ 
if
ää 
(
ää 
this
ää 
.
ää 
Count
ää 
!=
ää 
other
ää #
.
ää# $
Count
ää$ )
)
ää) *
{
ãã 
return
åå 
false
åå 
;
åå 
}
çç 
return
èè 
this
èè 
.
èè 
builder
èè 
.
èè  
ToString
èè  (
(
èè( )
this
èè) -
.
èè- .
offset
èè. 4
,
èè4 5
this
èè6 :
.
èè: ;
Count
èè; @
)
èè@ A
.
êê 
Equals
êê 
(
êê 
other
êê 
.
êê 
builder
êê %
.
êê% &
ToString
êê& .
(
êê. /
other
êê/ 4
.
êê4 5
offset
êê5 ;
,
êê; <
this
êê= A
.
êêA B
Count
êêB G
)
êêG H
)
êêH I
;
êêI J
}
ëë 	
public
ìì 
override
ìì 
bool
ìì 
Equals
ìì #
(
ìì# $
object
ìì$ *
obj
ìì+ .
)
ìì. /
{
îî 	
if
ïï 
(
ïï 
obj
ïï 
==
ïï 
null
ïï 
)
ïï 
{
ññ 
return
óó 
false
óó 
;
óó 
}
òò 
if
ôô 
(
ôô 
ReferenceEquals
ôô 
(
ôô  
this
ôô  $
,
ôô$ %
obj
ôô& )
)
ôô) *
)
ôô* +
{
öö 
return
õõ 
true
õõ 
;
õõ 
}
úú 
if
ûû 
(
ûû 
obj
ûû 
is
ûû '
StringBuilderCharSequence
ûû 0
other
ûû1 6
)
ûû6 7
{
üü 
return
†† 
this
†† 
.
†† 
Equals
†† "
(
††" #
other
††# (
)
††( )
;
††) *
}
°° 
if
¢¢ 
(
¢¢ 
obj
¢¢ 
is
¢¢ 
ICharSequence
¢¢ $
seq
¢¢% (
)
¢¢( )
{
££ 
return
§§ 
this
§§ 
.
§§ 
ContentEquals
§§ )
(
§§) *
seq
§§* -
)
§§- .
;
§§. /
}
•• 
return
ßß 
false
ßß 
;
ßß 
}
®® 	
public
™™ 
int
™™ 
HashCode
™™ 
(
™™ 
bool
™™  

ignoreCase
™™! +
)
™™+ ,
=>
™™- /

ignoreCase
™™0 :
?
´´ 
StringComparer
´´ 
.
´´ 
OrdinalIgnoreCase
´´ .
.
´´. /
GetHashCode
´´/ :
(
´´: ;
this
´´; ?
.
´´? @
ToString
´´@ H
(
´´H I
)
´´I J
)
´´J K
:
¨¨ 
StringComparer
¨¨ 
.
¨¨ 
Ordinal
¨¨ $
.
¨¨$ %
GetHashCode
¨¨% 0
(
¨¨0 1
this
¨¨1 5
.
¨¨5 6
ToString
¨¨6 >
(
¨¨> ?
)
¨¨? @
)
¨¨@ A
;
¨¨A B
public
ÆÆ 
override
ÆÆ 
int
ÆÆ 
GetHashCode
ÆÆ '
(
ÆÆ' (
)
ÆÆ( )
=>
ÆÆ* ,
this
ÆÆ- 1
.
ÆÆ1 2
HashCode
ÆÆ2 :
(
ÆÆ: ;
true
ÆÆ; ?
)
ÆÆ? @
;
ÆÆ@ A
public
∞∞ 
bool
∞∞ 
ContentEquals
∞∞ !
(
∞∞! "
ICharSequence
∞∞" /
other
∞∞0 5
)
∞∞5 6
=>
∞∞7 9
CharUtil
∞∞: B
.
∞∞B C
ContentEquals
∞∞C P
(
∞∞P Q
this
∞∞Q U
,
∞∞U V
other
∞∞W \
)
∞∞\ ]
;
∞∞] ^
public
≤≤ 
bool
≤≤ %
ContentEqualsIgnoreCase
≤≤ +
(
≤≤+ ,
ICharSequence
≤≤, 9
other
≤≤: ?
)
≤≤? @
=>
≤≤A C
CharUtil
≤≤D L
.
≤≤L M%
ContentEqualsIgnoreCase
≤≤M d
(
≤≤d e
this
≤≤e i
,
≤≤i j
other
≤≤k p
)
≤≤p q
;
≤≤q r
public
¥¥ 
IEnumerator
¥¥ 
<
¥¥ 
char
¥¥ 
>
¥¥  
GetEnumerator
¥¥! .
(
¥¥. /
)
¥¥/ 0
=>
¥¥1 3
new
¥¥4 7$
CharSequenceEnumerator
¥¥8 N
(
¥¥N O
this
¥¥O S
)
¥¥S T
;
¥¥T U
IEnumerator
∂∂ 
IEnumerable
∂∂ 
.
∂∂  
GetEnumerator
∂∂  -
(
∂∂- .
)
∂∂. /
=>
∂∂0 2
this
∂∂3 7
.
∂∂7 8
GetEnumerator
∂∂8 E
(
∂∂E F
)
∂∂F G
;
∂∂G H
}
∑∑ 
}∏∏ ´v
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\StringCharSequence.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

sealed 
class 
StringCharSequence *
:+ ,
ICharSequence- :
,: ;

IEquatable< F
<F G
StringCharSequenceG Y
>Y Z
{ 
public 
static 
readonly 
StringCharSequence 1
Empty2 7
=8 9
new: =
StringCharSequence> P
(P Q
stringQ W
.W X
EmptyX ]
)] ^
;^ _
readonly 
string 
value 
; 
readonly 
int 
offset 
; 
readonly 
int 
count 
; 
public 
StringCharSequence !
(! "
string" (
value) .
). /
{ 	
Contract 
. 
Requires 
( 
value #
!=$ &
null' +
)+ ,
;, -
this 
. 
value 
= 
value 
; 
this 
. 
offset 
= 
$num 
; 
this 
. 
count 
= 
this 
. 
value #
.# $
Length$ *
;* +
} 	
public 
StringCharSequence !
(! "
string" (
value) .
,. /
int0 3
offset4 :
,: ;
int< ?
count@ E
)E F
{ 	
Contract   
.   
Requires   
(   
value   #
!=  $ &
null  ' +
)  + ,
;  , -
Contract!! 
.!! 
Requires!! 
(!! 
offset!! $
>=!!% '
$num!!( )
&&!!* ,
count!!- 2
>=!!3 5
$num!!6 7
)!!7 8
;!!8 9
Contract"" 
."" 
Requires"" 
("" 
offset"" $
<=""% '
value""( -
.""- .
Length"". 4
-""5 6
count""7 <
)""< =
;""= >
this$$ 
.$$ 
value$$ 
=$$ 
value$$ 
;$$ 
this%% 
.%% 
offset%% 
=%% 
offset%%  
;%%  !
this&& 
.&& 
count&& 
=&& 
count&& 
;&& 
}'' 	
public)) 
int)) 
Count)) 
=>)) 
this))  
.))  !
count))! &
;))& '
public++ 
static++ 
explicit++ 
operator++ '
string++( .
(++. /
StringCharSequence++/ A
charSequence++B N
)++N O
{,, 	
Contract-- 
.-- 
Requires-- 
(-- 
charSequence-- *
!=--+ -
null--. 2
)--2 3
;--3 4
return.. 
charSequence.. 
...  
ToString..  (
(..( )
)..) *
;..* +
}// 	
public11 
static11 
explicit11 
operator11 '
StringCharSequence11( :
(11: ;
string11; A
value11B G
)11G H
{22 	
Contract33 
.33 
Requires33 
(33 
value33 #
!=33$ &
null33' +
)33+ ,
;33, -
return55 
value55 
.55 
Length55 
>55  !
$num55" #
?55$ %
new55& )
StringCharSequence55* <
(55< =
value55= B
)55B C
:55D E
Empty55F K
;55K L
}66 	
public88 
ICharSequence88 
SubSequence88 (
(88( )
int88) ,
start88- 2
)882 3
=>884 6
this887 ;
.88; <
SubSequence88< G
(88G H
start88H M
,88M N
this88O S
.88S T
count88T Y
)88Y Z
;88Z [
public:: 
ICharSequence:: 
SubSequence:: (
(::( )
int::) ,
start::- 2
,::2 3
int::4 7
end::8 ;
)::; <
{;; 	
Contract<< 
.<< 
Requires<< 
(<< 
start<< #
>=<<$ &
$num<<' (
&&<<) +
end<<, /
>=<<0 2
start<<3 8
)<<8 9
;<<9 :
Contract== 
.== 
Requires== 
(== 
end== !
<===" $
this==% )
.==) *
count==* /
)==/ 0
;==0 1
return?? 
end?? 
==?? 
start?? 
?@@ 
Empty@@ 
:AA 
newAA 
StringCharSequenceAA (
(AA( )
thisAA) -
.AA- .
valueAA. 3
,AA3 4
thisAA5 9
.AA9 :
offsetAA: @
+AAA B
startAAC H
,AAH I
endAAJ M
-AAN O
startAAP U
)AAU V
;AAV W
}BB 	
publicDD 
charDD 
thisDD 
[DD 
intDD 
indexDD "
]DD" #
{EE 	
getFF 
{GG 
ContractHH 
.HH 
RequiresHH !
(HH! "
indexHH" '
>=HH( *
$numHH+ ,
&&HH- /
indexHH0 5
<HH6 7
thisHH8 <
.HH< =
countHH= B
)HHB C
;HHC D
returnII 
thisII 
.II 
valueII !
[II! "
thisII" &
.II& '
offsetII' -
+II. /
indexII0 5
]II5 6
;II6 7
}JJ 
}KK 	
publicMM 
boolMM 
RegionMatchesMM !
(MM! "
intMM" %
	thisStartMM& /
,MM/ 0
ICharSequenceMM1 >
seqMM? B
,MMB C
intMMD G
startMMH M
,MMM N
intMMO R
lengthMMS Y
)MMY Z
=>MM[ ]
CharUtilNN 
.NN 
RegionMatchesNN "
(NN" #
thisNN# '
,NN' (
	thisStartNN) 2
,NN2 3
seqNN4 7
,NN7 8
startNN9 >
,NN> ?
lengthNN@ F
)NNF G
;NNG H
publicPP 
boolPP #
RegionMatchesIgnoreCasePP +
(PP+ ,
intPP, /
	thisStartPP0 9
,PP9 :
ICharSequencePP; H
seqPPI L
,PPL M
intPPN Q
startPPR W
,PPW X
intPPY \
lengthPP] c
)PPc d
=>PPe g
CharUtilQQ 
.QQ #
RegionMatchesIgnoreCaseQQ ,
(QQ, -
thisQQ- 1
,QQ1 2
	thisStartQQ3 <
,QQ< =
seqQQ> A
,QQA B
startQQC H
,QQH I
lengthQQJ P
)QQP Q
;QQQ R
publicSS 
intSS 
IndexOfSS 
(SS 
charSS 
chSS  "
,SS" #
intSS$ '
startSS( -
=SS. /
$numSS0 1
)SS1 2
{TT 	
ContractUU 
.UU 
RequiresUU 
(UU 
startUU #
>=UU$ &
$numUU' (
&&UU) +
startUU, 1
<UU2 3
thisUU4 8
.UU8 9
countUU9 >
)UU> ?
;UU? @
intWW 
indexWW 
=WW 
thisWW 
.WW 
valueWW "
.WW" #
IndexOfWW# *
(WW* +
chWW+ -
,WW- .
thisWW/ 3
.WW3 4
offsetWW4 :
+WW; <
startWW= B
)WWB C
;WWC D
returnXX 
indexXX 
<XX 
$numXX 
?XX 
indexXX $
:XX% &
indexXX' ,
-XX- .
thisXX/ 3
.XX3 4
offsetXX4 :
;XX: ;
}YY 	
public[[ 
int[[ 
IndexOf[[ 
([[ 
string[[ !
target[[" (
,[[( )
int[[* -
start[[. 3
=[[4 5
$num[[6 7
)[[7 8
=>[[9 ;
this[[< @
.[[@ A
value[[A F
.[[F G
IndexOf[[G N
([[N O
target[[O U
,[[U V
StringComparison[[W g
.[[g h
Ordinal[[h o
)[[o p
;[[p q
public]] 
string]] 
ToString]] 
(]] 
int]] "
start]]# (
)]]( )
{^^ 	
Contract__ 
.__ 
Requires__ 
(__ 
start__ #
>=__$ &
$num__' (
&&__) +
start__, 1
<__2 3
this__4 8
.__8 9
count__9 >
)__> ?
;__? @
returnaa 
thisaa 
.aa 
valueaa 
.aa 
	Substringaa '
(aa' (
thisaa( ,
.aa, -
offsetaa- 3
+aa4 5
startaa6 ;
,aa; <
thisaa= A
.aaA B
countaaB G
)aaG H
;aaH I
}bb 	
publicdd 
overridedd 
stringdd 
ToStringdd '
(dd' (
)dd( )
=>dd* ,
thisdd- 1
.dd1 2
countdd2 7
==dd8 :
$numdd; <
?dd= >
stringdd? E
.ddE F
EmptyddF K
:ddL M
thisddN R
.ddR S
ToStringddS [
(dd[ \
$numdd\ ]
)dd] ^
;dd^ _
publicff 
boolff 
Equalsff 
(ff 
StringCharSequenceff -
otherff. 3
)ff3 4
{gg 	
ifhh 
(hh 
otherhh 
==hh 
nullhh 
)hh 
{ii 
returnjj 
falsejj 
;jj 
}kk 
ifll 
(ll 
ReferenceEqualsll 
(ll  
thisll  $
,ll$ %
otherll& +
)ll+ ,
)ll, -
{mm 
returnnn 
truenn 
;nn 
}oo 
ifpp 
(pp 
thispp 
.pp 
countpp 
!=pp 
otherpp #
.pp# $
countpp$ )
)pp) *
{qq 
returnrr 
falserr 
;rr 
}ss 
returnuu 
stringuu 
.uu 
Compareuu !
(uu! "
thisuu" &
.uu& '
valueuu' ,
,uu, -
thisuu. 2
.uu2 3
offsetuu3 9
,uu9 :
otheruu; @
.uu@ A
valueuuA F
,uuF G
otheruuH M
.uuM N
offsetuuN T
,uuT U
thisuuV Z
.uuZ [
countuu[ `
,uu` a
StringComparisonvv  
.vv  !
Ordinalvv! (
)vv( )
==vv* ,
$numvv- .
;vv. /
}ww 	
publicyy 
overrideyy 
boolyy 
Equalsyy #
(yy# $
objectyy$ *
objyy+ .
)yy. /
{zz 	
if{{ 
({{ 
ReferenceEquals{{ 
({{  
obj{{  #
,{{# $
null{{% )
){{) *
){{* +
{|| 
return}} 
false}} 
;}} 
}~~ 
if 
( 
ReferenceEquals 
(  
this  $
,$ %
obj& )
)) *
)* +
{
ÄÄ 
return
ÅÅ 
true
ÅÅ 
;
ÅÅ 
}
ÇÇ 
if
ÑÑ 
(
ÑÑ 
obj
ÑÑ 
is
ÑÑ  
StringCharSequence
ÑÑ )
other
ÑÑ* /
)
ÑÑ/ 0
{
ÖÖ 
return
ÜÜ 
this
ÜÜ 
.
ÜÜ 
Equals
ÜÜ "
(
ÜÜ" #
other
ÜÜ# (
)
ÜÜ( )
;
ÜÜ) *
}
áá 
if
àà 
(
àà 
obj
àà 
is
àà 
ICharSequence
àà $
seq
àà% (
)
àà( )
{
ââ 
return
ää 
this
ää 
.
ää 
ContentEquals
ää )
(
ää) *
seq
ää* -
)
ää- .
;
ää. /
}
ãã 
return
çç 
false
çç 
;
çç 
}
éé 	
public
êê 
int
êê 
HashCode
êê 
(
êê 
bool
êê  

ignoreCase
êê! +
)
êê+ ,
=>
êê- /

ignoreCase
êê0 :
?
ëë 
StringComparer
ëë 
.
ëë 
OrdinalIgnoreCase
ëë .
.
ëë. /
GetHashCode
ëë/ :
(
ëë: ;
this
ëë; ?
.
ëë? @
ToString
ëë@ H
(
ëëH I
)
ëëI J
)
ëëJ K
:
íí 
StringComparer
íí 
.
íí 
Ordinal
íí $
.
íí$ %
GetHashCode
íí% 0
(
íí0 1
this
íí1 5
.
íí5 6
ToString
íí6 >
(
íí> ?
)
íí? @
)
íí@ A
;
ííA B
public
îî 
override
îî 
int
îî 
GetHashCode
îî '
(
îî' (
)
îî( )
=>
îî* ,
this
îî- 1
.
îî1 2
HashCode
îî2 :
(
îî: ;
false
îî; @
)
îî@ A
;
îîA B
public
ññ 
bool
ññ 
ContentEquals
ññ !
(
ññ! "
ICharSequence
ññ" /
other
ññ0 5
)
ññ5 6
=>
ññ7 9
CharUtil
ññ: B
.
ññB C
ContentEquals
ññC P
(
ññP Q
this
ññQ U
,
ññU V
other
ññW \
)
ññ\ ]
;
ññ] ^
public
òò 
bool
òò %
ContentEqualsIgnoreCase
òò +
(
òò+ ,
ICharSequence
òò, 9
other
òò: ?
)
òò? @
=>
òòA C
CharUtil
òòD L
.
òòL M%
ContentEqualsIgnoreCase
òòM d
(
òòd e
this
òòe i
,
òòi j
other
òòk p
)
òòp q
;
òòq r
public
öö 
IEnumerator
öö 
<
öö 
char
öö 
>
öö  
GetEnumerator
öö! .
(
öö. /
)
öö/ 0
=>
öö1 3
new
öö4 7$
CharSequenceEnumerator
öö8 N
(
ööN O
this
ööO S
)
ööS T
;
ööT U
IEnumerator
úú 
IEnumerable
úú 
.
úú  
GetEnumerator
úú  -
(
úú- .
)
úú. /
=>
úú0 2
this
úú3 7
.
úú7 8
GetEnumerator
úú8 E
(
úúE F
)
úúF G
;
úúG H
}
ùù 
}ûû Ùô
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\StringUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 

StringUtil "
{ 
public 
static 
readonly 
string %
EmptyString& 1
=2 3
$str4 6
;6 7
public 
static 
readonly 
string %
Newline& -
=. /
SystemPropertyUtil0 B
.B C
GetC F
(F G
$strG W
,W X
EnvironmentY d
.d e
NewLinee l
)l m
;m n
public 
const 
char 
DoubleQuote %
=& '
$char( ,
;, -
public 
const 
char 
Comma 
=  !
$char" %
;% &
public 
const 
char 
LineFeed "
=# $
$char% )
;) *
public 
const 
char 
CarriageReturn (
=) *
$char+ /
;/ 0
public 
const 
char 
Tab 
= 
$char  $
;$ %
public 
static 
readonly 
char #
Space$ )
=* +
$char, 2
;2 3
public 
const 
byte +
UpperCaseToLowerCaseAsciiOffset 9
=: ;
$char< ?
-@ A
$charB E
;E F
static 
readonly 
string 
[ 
]  
Byte2HexPad! ,
=- .
new/ 2
string3 9
[9 :
$num: =
]= >
;> ?
static 
readonly 
string 
[ 
]  
Byte2HexNopad! .
=/ 0
new1 4
string5 ;
[; <
$num< ?
]? @
;@ A
const"" 
int"" %
CsvNumberEscapeCharacters"" +
="", -
$num"". /
+""0 1
$num""2 3
;""3 4
static$$ 

StringUtil$$ 
($$ 
)$$ 
{%% 	
int'' 
i'' 
;'' 
for(( 
((( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
$num(( 
;(( 
i((  !
++((! #
)((# $
{)) 
var** 
buf** 
=** 
new** 
StringBuilder** +
(**+ ,
$num**, -
)**- .
;**. /
buf++ 
.++ 
Append++ 
(++ 
$char++ 
)++ 
;++  
buf,, 
.,, 
Append,, 
(,, 
i,, 
),, 
;,, 
Byte2HexPad-- 
[-- 
i-- 
]-- 
=--  
buf--! $
.--$ %
ToString--% -
(--- .
)--. /
;--/ 0
Byte2HexNopad.. 
[.. 
i.. 
]..  
=..! "
(..# $
i..$ %
)..% &
...& '
ToString..' /
(../ 0
)..0 1
;..1 2
}// 
for00 
(00 
;00 
i00 
<00 
$num00 
;00 
i00 
++00 
)00 
{11 
var22 
buf22 
=22 
new22 
StringBuilder22 +
(22+ ,
$num22, -
)22- .
;22. /
char33 
c33 
=33 
(33 
char33 
)33 
(33  
$char33  #
+33$ %
i33& '
-33( )
$num33* ,
)33, -
;33- .
buf44 
.44 
Append44 
(44 
$char44 
)44 
;44  
buf55 
.55 
Append55 
(55 
c55 
)55 
;55 
Byte2HexPad66 
[66 
i66 
]66 
=66  
buf66! $
.66$ %
ToString66% -
(66- .
)66. /
;66/ 0
Byte2HexNopad77 
[77 
i77 
]77  
=77! "
c77# $
.77$ %
ToString77% -
(77- .
)77. /
;77/ 0
}88 
for99 
(99 
;99 
i99 
<99 
Byte2HexPad99 "
.99" #
Length99# )
;99) *
i99+ ,
++99, .
)99. /
{:: 
var;; 
buf;; 
=;; 
new;; 
StringBuilder;; +
(;;+ ,
$num;;, -
);;- .
;;;. /
buf<< 
.<< 
Append<< 
(<< 
i<< 
.<< 
ToString<< %
(<<% &
$str<<& )
)<<) *
)<<E F
;<<F G
string== 
str== 
=== 
buf==  
.==  !
ToString==! )
(==) *
)==* +
;==+ ,
Byte2HexPad>> 
[>> 
i>> 
]>> 
=>>  
str>>! $
;>>$ %
Byte2HexNopad?? 
[?? 
i?? 
]??  
=??! "
str??# &
;??& '
}@@ 
}AA 	
publicCC 
staticCC 
stringCC 
SubstringAfterCC +
(CC+ ,
stringCC, 2
valueCC3 8
,CC8 9
charCC: >
delimCC? D
)CCD E
{DD 	
intEE 
posEE 
=EE 
valueEE 
.EE 
IndexOfEE #
(EE# $
delimEE$ )
)EE) *
;EE* +
returnFF 
posFF 
>=FF 
$numFF 
?FF 
valueFF #
.FF# $
	SubstringFF$ -
(FF- .
posFF. 1
+FF2 3
$numFF4 5
)FF5 6
:FF7 8
nullFF9 =
;FF= >
}GG 	
publicII 
staticII 
boolII  
CommonSuffixOfLengthII /
(II/ 0
stringII0 6
sII7 8
,II8 9
stringII: @
pIIA B
,IIB C
intIID G
lenIIH K
)IIK L
=>IIM O
sIIP Q
!=IIR T
nullIIU Y
&&IIZ \
pII] ^
!=II_ a
nullIIb f
&&IIg i
lenIIj m
>=IIn p
$numIIq r
&&IIs u
RegionMatches	IIv É
(
IIÉ Ñ
s
IIÑ Ö
,
IIÖ Ü
s
IIá à
.
IIà â
Length
IIâ è
-
IIê ë
len
IIí ï
,
IIï ñ
p
IIó ò
,
IIò ô
p
IIö õ
.
IIõ ú
Length
IIú ¢
-
II£ §
len
II• ®
,
II® ©
len
II™ ≠
)
II≠ Æ
;
IIÆ Ø
staticKK 
boolKK 
RegionMatchesKK !
(KK! "
stringKK" (
valueKK) .
,KK. /
intKK0 3
	thisStartKK4 =
,KK= >
stringKK? E
otherKKF K
,KKK L
intKKM P
startKKQ V
,KKV W
intKKX [
lengthKK\ b
)KKb c
{LL 	
ifMM 
(MM 
startMM 
<MM 
$numMM 
||MM 
otherMM "
.MM" #
LengthMM# )
-MM* +
startMM, 1
<MM2 3
lengthMM4 :
)MM: ;
{NN 
returnOO 
falseOO 
;OO 
}PP 
ifRR 
(RR 
	thisStartRR 
<RR 
$numRR 
||RR  
valueRR! &
.RR& '
LengthRR' -
-RR. /
	thisStartRR0 9
<RR: ;
lengthRR< B
)RRB C
{SS 
returnTT 
falseTT 
;TT 
}UU 
ifWW 
(WW 
lengthWW 
<=WW 
$numWW 
)WW 
{XX 
returnYY 
trueYY 
;YY 
}ZZ 
int\\ 
o1\\ 
=\\ 
	thisStart\\ 
;\\ 
int]] 
o2]] 
=]] 
start]] 
;]] 
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^ 
<^^ 
length^^  &
;^^& '
++^^( *
i^^* +
)^^+ ,
{__ 
if`` 
(`` 
value`` 
[`` 
o1`` 
+`` 
i``  
]``  !
!=``" $
other``% *
[``* +
o2``+ -
+``. /
i``0 1
]``1 2
)``2 3
{aa 
returnbb 
falsebb  
;bb  !
}cc 
}dd 
returnff 
trueff 
;ff 
}gg 	
publicll 
staticll 
stringll !
ByteToHexStringPaddedll 2
(ll2 3
intll3 6
valuell7 <
)ll< =
=>ll> @
Byte2HexPadllA L
[llL M
valuellM R
&llS T
$numllU Y
]llY Z
;llZ [
publicqq 
staticqq 
Tqq !
ByteToHexStringPaddedqq -
<qq- .
Tqq. /
>qq/ 0
(qq0 1
Tqq1 2
bufqq3 6
,qq6 7
intqq8 ;
valueqq< A
)qqA B
whereqqC H
TqqI J
:qqK L
IAppendableqqM X
{rr 	
bufss 
.ss 
Appendss 
(ss 
newss 
StringCharSequencess -
(ss- .!
ByteToHexStringPaddedss. C
(ssC D
valuessD I
)ssI J
)ssJ K
)ssK L
;ssL M
returntt 
buftt 
;tt 
}uu 	
publiczz 
staticzz 
stringzz 
ToHexStringPaddedzz .
(zz. /
bytezz/ 3
[zz3 4
]zz4 5
srczz6 9
)zz9 :
=>zz; =
ToHexStringPaddedzz> O
(zzO P
srczzP S
,zzS T
$numzzU V
,zzV W
srczzX [
.zz[ \
Lengthzz\ b
)zzb c
;zzc d
public 
static 
string 
ToHexStringPadded .
(. /
byte/ 3
[3 4
]4 5
src6 9
,9 :
int; >
offset? E
,E F
intG J
lengthK Q
)Q R
{
ÄÄ 	
int
ÅÅ 
end
ÅÅ 
=
ÅÅ 
offset
ÅÅ 
+
ÅÅ 
length
ÅÅ %
;
ÅÅ% &
var
ÇÇ 
sb
ÇÇ 
=
ÇÇ 
new
ÇÇ 
StringBuilder
ÇÇ &
(
ÇÇ& '
length
ÇÇ' -
<<
ÇÇ. 0
$num
ÇÇ1 2
)
ÇÇ2 3
;
ÇÇ3 4
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
offset
ÉÉ 
;
ÉÉ  
i
ÉÉ! "
<
ÉÉ# $
end
ÉÉ% (
;
ÉÉ( )
i
ÉÉ* +
++
ÉÉ+ -
)
ÉÉ- .
{
ÑÑ 
sb
ÖÖ 
.
ÖÖ 
Append
ÖÖ 
(
ÖÖ #
ByteToHexStringPadded
ÖÖ /
(
ÖÖ/ 0
src
ÖÖ0 3
[
ÖÖ3 4
i
ÖÖ4 5
]
ÖÖ5 6
)
ÖÖ6 7
)
ÖÖ7 8
;
ÖÖ8 9
}
ÜÜ 
return
áá 
sb
áá 
.
áá 
ToString
áá 
(
áá 
)
áá  
;
áá  !
}
àà 	
public
ää 
static
ää 
T
ää 
ToHexStringPadded
ää )
<
ää) *
T
ää* +
>
ää+ ,
(
ää, -
T
ää- .
dst
ää/ 2
,
ää2 3
byte
ää4 8
[
ää8 9
]
ää9 :
src
ää; >
)
ää> ?
where
ää@ E
T
ääF G
:
ääH I
IAppendable
ääJ U
=>
ääV X
ToHexStringPadded
ääY j
(
ääj k
dst
ääk n
,
ään o
src
ääp s
,
ääs t
$num
ääu v
,
ääv w
src
ääx {
.
ää{ |
Lengthää| Ç
)ääÇ É
;ääÉ Ñ
public
åå 
static
åå 
T
åå 
ToHexStringPadded
åå )
<
åå) *
T
åå* +
>
åå+ ,
(
åå, -
T
åå- .
dst
åå/ 2
,
åå2 3
byte
åå4 8
[
åå8 9
]
åå9 :
src
åå; >
,
åå> ?
int
åå@ C
offset
ååD J
,
ååJ K
int
ååL O
length
ååP V
)
ååV W
where
ååX ]
T
åå^ _
:
åå` a
IAppendable
ååb m
{
çç 	
int
éé 
end
éé 
=
éé 
offset
éé 
+
éé 
length
éé %
;
éé% &
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
offset
èè 
;
èè  
i
èè! "
<
èè# $
end
èè% (
;
èè( )
i
èè* +
++
èè+ -
)
èè- .
{
êê #
ByteToHexStringPadded
ëë %
(
ëë% &
dst
ëë& )
,
ëë) *
src
ëë+ .
[
ëë. /
i
ëë/ 0
]
ëë0 1
)
ëë1 2
;
ëë2 3
}
íí 
return
ìì 
dst
ìì 
;
ìì 
}
îî 	
public
ôô 
static
ôô 
string
ôô 
ByteToHexString
ôô ,
(
ôô, -
byte
ôô- 1
value
ôô2 7
)
ôô7 8
=>
ôô9 ;
Byte2HexNopad
ôô< I
[
ôôI J
value
ôôJ O
&
ôôP Q
$num
ôôR V
]
ôôV W
;
ôôW X
public
õõ 
static
õõ 
T
õõ 
ByteToHexString
õõ '
<
õõ' (
T
õõ( )
>
õõ) *
(
õõ* +
T
õõ+ ,
buf
õõ- 0
,
õõ0 1
byte
õõ2 6
value
õõ7 <
)
õõ< =
where
õõ> C
T
õõD E
:
õõF G
IAppendable
õõH S
{
úú 	
buf
ùù 
.
ùù 
Append
ùù 
(
ùù 
new
ùù  
StringCharSequence
ùù -
(
ùù- .
ByteToHexString
ùù. =
(
ùù= >
value
ùù> C
)
ùùC D
)
ùùD E
)
ùùE F
;
ùùF G
return
ûû 
buf
ûû 
;
ûû 
}
üü 	
public
°° 
static
°° 
string
°° 
ToHexString
°° (
(
°°( )
byte
°°) -
[
°°- .
]
°°. /
src
°°0 3
)
°°3 4
=>
°°5 7
ToHexString
°°8 C
(
°°C D
src
°°D G
,
°°G H
$num
°°I J
,
°°J K
src
°°L O
.
°°O P
Length
°°P V
)
°°V W
;
°°W X
public
££ 
static
££ 
string
££ 
ToHexString
££ (
(
££( )
byte
££) -
[
££- .
]
££. /
src
££0 3
,
££3 4
int
££5 8
offset
££9 ?
,
££? @
int
££A D
length
££E K
)
££K L
=>
££M O
ToHexString
££P [
(
££[ \
new
££\ _$
AppendableCharSequence
££` v
(
££v w
length
££w }
<<££~ Ä
$num££Å Ç
)££Ç É
,££É Ñ
src££Ö à
,££à â
offset££ä ê
,££ê ë
length££í ò
)££ò ô
.££ô ö
ToString££ö ¢
(££¢ £
)£££ §
;££§ •
public
•• 
static
•• 
T
•• 
ToHexString
•• #
<
••# $
T
••$ %
>
••% &
(
••& '
T
••' (
dst
••) ,
,
••, -
byte
••. 2
[
••2 3
]
••3 4
src
••5 8
)
••8 9
where
••: ?
T
••@ A
:
••B C
IAppendable
••D O
=>
••P R
ToHexString
••S ^
(
••^ _
dst
••_ b
,
••b c
src
••d g
,
••g h
$num
••i j
,
••j k
src
••l o
.
••o p
Length
••p v
)
••v w
;
••w x
public
ßß 
static
ßß 
T
ßß 
ToHexString
ßß #
<
ßß# $
T
ßß$ %
>
ßß% &
(
ßß& '
T
ßß' (
dst
ßß) ,
,
ßß, -
byte
ßß. 2
[
ßß2 3
]
ßß3 4
src
ßß5 8
,
ßß8 9
int
ßß: =
offset
ßß> D
,
ßßD E
int
ßßF I
length
ßßJ P
)
ßßP Q
where
ßßR W
T
ßßX Y
:
ßßZ [
IAppendable
ßß\ g
{
®® 	
Contract
©© 
.
©© 
Requires
©© 
(
©© 
length
©© $
>=
©©% '
$num
©©( )
)
©©) *
;
©©* +
if
´´ 
(
´´ 
length
´´ 
==
´´ 
$num
´´ 
)
´´ 
{
¨¨ 
return
≠≠ 
dst
≠≠ 
;
≠≠ 
}
ÆÆ 
int
∞∞ 
end
∞∞ 
=
∞∞ 
offset
∞∞ 
+
∞∞ 
length
∞∞ %
;
∞∞% &
int
±± 
endMinusOne
±± 
=
±± 
end
±± !
-
±±" #
$num
±±$ %
;
±±% &
int
≤≤ 
i
≤≤ 
;
≤≤ 
for
µµ 
(
µµ 
i
µµ 
=
µµ 
offset
µµ 
;
µµ 
i
µµ 
<
µµ  
endMinusOne
µµ! ,
;
µµ, -
i
µµ. /
++
µµ/ 1
)
µµ1 2
{
∂∂ 
if
∑∑ 
(
∑∑ 
src
∑∑ 
[
∑∑ 
i
∑∑ 
]
∑∑ 
!=
∑∑ 
$num
∑∑ 
)
∑∑  
{
∏∏ 
break
ππ 
;
ππ 
}
∫∫ 
}
ªª 
ByteToHexString
ΩΩ 
(
ΩΩ 
dst
ΩΩ 
,
ΩΩ  
src
ΩΩ! $
[
ΩΩ$ %
i
ΩΩ% &
++
ΩΩ& (
]
ΩΩ( )
)
ΩΩ) *
;
ΩΩ* +
int
ææ 
	remaining
ææ 
=
ææ 
end
ææ 
-
ææ  !
i
ææ" #
;
ææ# $
ToHexStringPadded
øø 
(
øø 
dst
øø !
,
øø! "
src
øø# &
,
øø& '
i
øø( )
,
øø) *
	remaining
øø+ 4
)
øø4 5
;
øø5 6
return
¡¡ 
dst
¡¡ 
;
¡¡ 
}
¬¬ 	
public
ƒƒ 
static
ƒƒ 
int
ƒƒ 
DecodeHexNibble
ƒƒ )
(
ƒƒ) *
char
ƒƒ* .
c
ƒƒ/ 0
)
ƒƒ0 1
{
≈≈ 	
if
»» 
(
»» 
c
»» 
>=
»» 
$char
»» 
&&
»» 
c
»» 
<=
»»  
$char
»»! $
)
»»$ %
{
…… 
return
   
c
   
-
   
$char
   
;
   
}
ÀÀ 
if
ÃÃ 
(
ÃÃ 
c
ÃÃ 
>=
ÃÃ 
$char
ÃÃ 
&&
ÃÃ 
c
ÃÃ 
<=
ÃÃ  
$char
ÃÃ! $
)
ÃÃ$ %
{
ÕÕ 
return
ŒŒ 
c
ŒŒ 
-
ŒŒ 
$char
ŒŒ 
+
ŒŒ  
$num
ŒŒ! $
;
ŒŒ$ %
}
œœ 
if
–– 
(
–– 
c
–– 
>=
–– 
$char
–– 
&&
–– 
c
–– 
<=
––  
$char
––! $
)
––$ %
{
—— 
return
““ 
c
““ 
-
““ 
$char
““ 
+
““  
$num
““! $
;
““$ %
}
”” 
return
‘‘ 
-
‘‘ 
$num
‘‘ 
;
‘‘ 
}
’’ 	
public
ÿÿ 
static
ÿÿ 
byte
ÿÿ 
DecodeHexByte
ÿÿ (
(
ÿÿ( )
string
ÿÿ) /
s
ÿÿ0 1
,
ÿÿ1 2
int
ÿÿ3 6
pos
ÿÿ7 :
)
ÿÿ: ;
{
ŸŸ 	
int
⁄⁄ 
hi
⁄⁄ 
=
⁄⁄ 
DecodeHexNibble
⁄⁄ $
(
⁄⁄$ %
s
⁄⁄% &
[
⁄⁄& '
pos
⁄⁄' *
]
⁄⁄* +
)
⁄⁄+ ,
;
⁄⁄, -
int
€€ 
lo
€€ 
=
€€ 
DecodeHexNibble
€€ $
(
€€$ %
s
€€% &
[
€€& '
pos
€€' *
+
€€+ ,
$num
€€- .
]
€€. /
)
€€/ 0
;
€€0 1
if
‹‹ 
(
‹‹ 
hi
‹‹ 
==
‹‹ 
-
‹‹ 
$num
‹‹ 
||
‹‹ 
lo
‹‹ 
==
‹‹ !
-
‹‹" #
$num
‹‹# $
)
‹‹$ %
{
›› 
throw
ﬁﬁ 
new
ﬁﬁ 
ArgumentException
ﬁﬁ +
(
ﬁﬁ+ ,
$"
ﬁﬁ, .
$str
ﬁﬁ. @
{
ﬁﬁ@ A
s
ﬁﬁA B
.
ﬁﬁB C
	Substring
ﬁﬁC L
(
ﬁﬁL M
pos
ﬁﬁM P
,
ﬁﬁP Q
$num
ﬁﬁR S
)
ﬁﬁS T
}
ﬁﬁT U
$str
ﬁﬁU `
{
ﬁﬁ` a
pos
ﬁﬁa d
}
ﬁﬁd e
$str
ﬁﬁe j
{
ﬁﬁj k
s
ﬁﬁk l
}
ﬁﬁl m
$str
ﬁﬁm n
"
ﬁﬁn o
)
ﬁﬁo p
;
ﬁﬁp q
}
ﬂﬂ 
return
·· 
(
·· 
byte
·· 
)
·· 
(
·· 
(
·· 
hi
·· 
<<
··  
$num
··! "
)
··" #
+
··$ %
lo
··& (
)
··( )
;
··) *
}
‚‚ 	
public
ÂÂ 
static
ÂÂ 
byte
ÂÂ 
[
ÂÂ 
]
ÂÂ 
DecodeHexDump
ÂÂ *
(
ÂÂ* +
string
ÂÂ+ 1
hexDump
ÂÂ2 9
,
ÂÂ9 :
int
ÂÂ; >
	fromIndex
ÂÂ? H
,
ÂÂH I
int
ÂÂJ M
length
ÂÂN T
)
ÂÂT U
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
length
ÁÁ 
<
ÁÁ 
$num
ÁÁ 
||
ÁÁ 
(
ÁÁ 
length
ÁÁ %
&
ÁÁ& '
$num
ÁÁ( )
)
ÁÁ) *
!=
ÁÁ+ -
$num
ÁÁ. /
)
ÁÁ/ 0
{
ËË 
throw
ÈÈ 
new
ÈÈ 
ArgumentException
ÈÈ +
(
ÈÈ+ ,
$"
ÈÈ, .
$str
ÈÈ. 6
{
ÈÈ6 7
length
ÈÈ7 =
}
ÈÈ= >
"
ÈÈ> ?
)
ÈÈ? @
;
ÈÈ@ A
}
ÍÍ 
if
ÎÎ 
(
ÎÎ 
length
ÎÎ 
==
ÎÎ 
$num
ÎÎ 
)
ÎÎ 
{
ÏÏ 
return
ÌÌ 
EmptyArrays
ÌÌ "
.
ÌÌ" #

EmptyBytes
ÌÌ# -
;
ÌÌ- .
}
ÓÓ 
var
ÔÔ 
bytes
ÔÔ 
=
ÔÔ 
new
ÔÔ 
byte
ÔÔ  
[
ÔÔ  !
length
ÔÔ! '
.
ÔÔ' (
RightUShift
ÔÔ( 3
(
ÔÔ3 4
$num
ÔÔ4 5
)
ÔÔ5 6
]
ÔÔ6 7
;
ÔÔ7 8
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 
length
  &
;
& '
i
( )
+=
* ,
$num
- .
)
. /
{
ÒÒ 
bytes
ÚÚ 
[
ÚÚ 
i
ÚÚ 
.
ÚÚ 
RightUShift
ÚÚ #
(
ÚÚ# $
$num
ÚÚ$ %
)
ÚÚ% &
]
ÚÚ& '
=
ÚÚ( )
DecodeHexByte
ÚÚ* 7
(
ÚÚ7 8
hexDump
ÚÚ8 ?
,
ÚÚ? @
	fromIndex
ÚÚA J
+
ÚÚK L
i
ÚÚM N
)
ÚÚN O
;
ÚÚO P
}
ÛÛ 
return
ÙÙ 
bytes
ÙÙ 
;
ÙÙ 
}
ıı 	
public
¯¯ 
static
¯¯ 
byte
¯¯ 
[
¯¯ 
]
¯¯ 
DecodeHexDump
¯¯ *
(
¯¯* +
string
¯¯+ 1
hexDump
¯¯2 9
)
¯¯9 :
=>
¯¯; =
DecodeHexDump
¯¯> K
(
¯¯K L
hexDump
¯¯L S
,
¯¯S T
$num
¯¯U V
,
¯¯V W
hexDump
¯¯X _
.
¯¯_ `
Length
¯¯` f
)
¯¯f g
;
¯¯g h
public
˝˝ 
static
˝˝ 
string
˝˝ 
SimpleClassName
˝˝ ,
(
˝˝, -
object
˝˝- 3
o
˝˝4 5
)
˝˝5 6
=>
˝˝7 9
o
˝˝: ;
?
˝˝; <
.
˝˝< =
GetType
˝˝= D
(
˝˝D E
)
˝˝E F
.
˝˝F G
Name
˝˝G K
??
˝˝L N
$str
˝˝O \
;
˝˝\ ]
public
ÇÇ 
static
ÇÇ 
string
ÇÇ 
SimpleClassName
ÇÇ ,
<
ÇÇ, -
T
ÇÇ- .
>
ÇÇ. /
(
ÇÇ/ 0
)
ÇÇ0 1
=>
ÇÇ2 4
typeof
ÇÇ5 ;
(
ÇÇ; <
T
ÇÇ< =
)
ÇÇ= >
.
ÇÇ> ?
Name
ÇÇ? C
;
ÇÇC D
public
ââ 
static
ââ 
string
ââ 
SimpleClassName
ââ ,
(
ââ, -
Type
ââ- 1
type
ââ2 6
)
ââ6 7
=>
ââ8 :
type
ââ; ?
.
ââ? @
Name
ââ@ D
;
ââD E
public
òò 
static
òò 
ICharSequence
òò #
	EscapeCsv
òò$ -
(
òò- .
ICharSequence
òò. ;
value
òò< A
,
òòA B
bool
òòC G
trimWhiteSpace
òòH V
=
òòW X
false
òòY ^
)
òò^ _
{
ôô 	
Contract
öö 
.
öö 
Requires
öö 
(
öö 
value
öö #
!=
öö$ &
null
öö' +
)
öö+ ,
;
öö, -
int
úú 
length
úú 
=
úú 
value
úú 
.
úú 
Count
úú $
;
úú$ %
if
ùù 
(
ùù 
length
ùù 
==
ùù 
$num
ùù 
)
ùù 
{
ûû 
return
üü 
value
üü 
;
üü 
}
†† 
int
¢¢ 
start
¢¢ 
;
¢¢ 
int
££ 
last
££ 
;
££ 
if
§§ 
(
§§ 
trimWhiteSpace
§§ 
)
§§ 
{
•• 
start
¶¶ 
=
¶¶ $
IndexOfFirstNonOwsChar
¶¶ .
(
¶¶. /
value
¶¶/ 4
,
¶¶4 5
length
¶¶6 <
)
¶¶< =
;
¶¶= >
last
ßß 
=
ßß #
IndexOfLastNonOwsChar
ßß ,
(
ßß, -
value
ßß- 2
,
ßß2 3
start
ßß4 9
,
ßß9 :
length
ßß; A
)
ßßA B
;
ßßB C
}
®® 
else
©© 
{
™™ 
start
´´ 
=
´´ 
$num
´´ 
;
´´ 
last
¨¨ 
=
¨¨ 
length
¨¨ 
-
¨¨ 
$num
¨¨  !
;
¨¨! "
}
≠≠ 
if
ÆÆ 
(
ÆÆ 
start
ÆÆ 
>
ÆÆ 
last
ÆÆ 
)
ÆÆ 
{
ØØ 
return
∞∞  
StringCharSequence
∞∞ )
.
∞∞) *
Empty
∞∞* /
;
∞∞/ 0
}
±± 
int
≥≥ #
firstUnescapedSpecial
≥≥ %
=
≥≥& '
-
≥≥( )
$num
≥≥) *
;
≥≥* +
bool
¥¥ 
quoted
¥¥ 
=
¥¥ 
false
¥¥ 
;
¥¥  
if
µµ 
(
µµ 
IsDoubleQuote
µµ 
(
µµ 
value
µµ #
[
µµ# $
start
µµ$ )
]
µµ) *
)
µµ* +
)
µµ+ ,
{
∂∂ 
quoted
∑∑ 
=
∑∑ 
IsDoubleQuote
∑∑ &
(
∑∑& '
value
∑∑' ,
[
∑∑, -
last
∑∑- 1
]
∑∑1 2
)
∑∑2 3
&&
∑∑4 6
last
∑∑7 ;
>
∑∑< =
start
∑∑> C
;
∑∑C D
if
∏∏ 
(
∏∏ 
quoted
∏∏ 
)
∏∏ 
{
ππ 
start
∫∫ 
++
∫∫ 
;
∫∫ 
last
ªª 
--
ªª 
;
ªª 
}
ºº 
else
ΩΩ 
{
ææ #
firstUnescapedSpecial
øø )
=
øø* +
start
øø, 1
;
øø1 2
}
¿¿ 
}
¡¡ 
if
√√ 
(
√√ #
firstUnescapedSpecial
√√ %
<
√√& '
$num
√√( )
)
√√) *
{
ƒƒ 
if
≈≈ 
(
≈≈ 
quoted
≈≈ 
)
≈≈ 
{
∆∆ 
for
«« 
(
«« 
int
«« 
i
«« 
=
««  
start
««! &
;
««& '
i
««( )
<=
««* ,
last
««- 1
;
««1 2
i
««3 4
++
««4 6
)
««6 7
{
»» 
if
…… 
(
…… 
IsDoubleQuote
…… )
(
……) *
value
……* /
[
……/ 0
i
……0 1
]
……1 2
)
……2 3
)
……3 4
{
   
if
ÀÀ 
(
ÀÀ  
i
ÀÀ  !
==
ÀÀ" $
last
ÀÀ% )
||
ÀÀ* ,
!
ÀÀ- .
IsDoubleQuote
ÀÀ. ;
(
ÀÀ; <
value
ÀÀ< A
[
ÀÀA B
i
ÀÀB C
+
ÀÀD E
$num
ÀÀF G
]
ÀÀG H
)
ÀÀH I
)
ÀÀI J
{
ÃÃ #
firstUnescapedSpecial
ÕÕ  5
=
ÕÕ6 7
i
ÕÕ8 9
;
ÕÕ9 :
break
ŒŒ  %
;
ŒŒ% &
}
œœ 
i
–– 
++
–– 
;
––  
}
—— 
}
““ 
}
”” 
else
‘‘ 
{
’’ 
for
÷÷ 
(
÷÷ 
int
÷÷ 
i
÷÷ 
=
÷÷  
start
÷÷! &
;
÷÷& '
i
÷÷( )
<=
÷÷* ,
last
÷÷- 1
;
÷÷1 2
i
÷÷3 4
++
÷÷4 6
)
÷÷6 7
{
◊◊ 
char
ÿÿ 
c
ÿÿ 
=
ÿÿ  
value
ÿÿ! &
[
ÿÿ& '
i
ÿÿ' (
]
ÿÿ( )
;
ÿÿ) *
if
ŸŸ 
(
ŸŸ 
c
ŸŸ 
==
ŸŸ  
LineFeed
ŸŸ! )
||
ŸŸ* ,
c
ŸŸ- .
==
ŸŸ/ 1
CarriageReturn
ŸŸ2 @
||
ŸŸA C
c
ŸŸD E
==
ŸŸF H
Comma
ŸŸI N
)
ŸŸN O
{
⁄⁄ #
firstUnescapedSpecial
€€ 1
=
€€2 3
i
€€4 5
;
€€5 6
break
‹‹ !
;
‹‹! "
}
›› 
if
ﬁﬁ 
(
ﬁﬁ 
IsDoubleQuote
ﬁﬁ )
(
ﬁﬁ) *
c
ﬁﬁ* +
)
ﬁﬁ+ ,
)
ﬁﬁ, -
{
ﬂﬂ 
if
‡‡ 
(
‡‡  
i
‡‡  !
==
‡‡" $
last
‡‡% )
||
‡‡* ,
!
‡‡- .
IsDoubleQuote
‡‡. ;
(
‡‡; <
value
‡‡< A
[
‡‡A B
i
‡‡B C
+
‡‡D E
$num
‡‡F G
]
‡‡G H
)
‡‡H I
)
‡‡I J
{
·· #
firstUnescapedSpecial
‚‚  5
=
‚‚6 7
i
‚‚8 9
;
‚‚9 :
break
„„  %
;
„„% &
}
‰‰ 
i
ÂÂ 
++
ÂÂ 
;
ÂÂ  
}
ÊÊ 
}
ÁÁ 
}
ËË 
if
ÈÈ 
(
ÈÈ #
firstUnescapedSpecial
ÈÈ )
<
ÈÈ* +
$num
ÈÈ, -
)
ÈÈ- .
{
ÍÍ 
return
ÓÓ 
quoted
ÓÓ !
?
ÓÓ" #
value
ÓÓ$ )
.
ÓÓ) *
SubSequence
ÓÓ* 5
(
ÓÓ5 6
start
ÓÓ6 ;
-
ÓÓ< =
$num
ÓÓ> ?
,
ÓÓ? @
last
ÓÓA E
+
ÓÓF G
$num
ÓÓH I
)
ÓÓI J
:
ÓÓK L
value
ÓÓM R
.
ÓÓR S
SubSequence
ÓÓS ^
(
ÓÓ^ _
start
ÓÓ_ d
,
ÓÓd e
last
ÓÓf j
+
ÓÓk l
$num
ÓÓm n
)
ÓÓn o
;
ÓÓo p
}
ÔÔ 
}
 
var
ÚÚ 
result
ÚÚ 
=
ÚÚ 
new
ÚÚ '
StringBuilderCharSequence
ÚÚ 6
(
ÚÚ6 7
last
ÚÚ7 ;
-
ÚÚ< =
start
ÚÚ> C
+
ÚÚD E
$num
ÚÚF G
+
ÚÚH I'
CsvNumberEscapeCharacters
ÚÚJ c
)
ÚÚc d
;
ÚÚd e
result
ÛÛ 
.
ÛÛ 
Append
ÛÛ 
(
ÛÛ 
DoubleQuote
ÛÛ %
)
ÛÛ% &
;
ÛÛ& '
result
ÙÙ 
.
ÙÙ 
Append
ÙÙ 
(
ÙÙ 
value
ÙÙ 
,
ÙÙ  
start
ÙÙ! &
,
ÙÙ& '#
firstUnescapedSpecial
ÙÙ( =
-
ÙÙ> ?
start
ÙÙ@ E
)
ÙÙE F
;
ÙÙF G
for
ıı 
(
ıı 
int
ıı 
i
ıı 
=
ıı #
firstUnescapedSpecial
ıı .
;
ıı. /
i
ıı0 1
<=
ıı2 4
last
ıı5 9
;
ıı9 :
i
ıı; <
++
ıı< >
)
ıı> ?
{
ˆˆ 
char
˜˜ 
c
˜˜ 
=
˜˜ 
value
˜˜ 
[
˜˜ 
i
˜˜  
]
˜˜  !
;
˜˜! "
if
¯¯ 
(
¯¯ 
IsDoubleQuote
¯¯ !
(
¯¯! "
c
¯¯" #
)
¯¯# $
)
¯¯$ %
{
˘˘ 
result
˙˙ 
.
˙˙ 
Append
˙˙ !
(
˙˙! "
DoubleQuote
˙˙" -
)
˙˙- .
;
˙˙. /
if
˚˚ 
(
˚˚ 
i
˚˚ 
<
˚˚ 
last
˚˚  
&&
˚˚! #
IsDoubleQuote
˚˚$ 1
(
˚˚1 2
value
˚˚2 7
[
˚˚7 8
i
˚˚8 9
+
˚˚: ;
$num
˚˚< =
]
˚˚= >
)
˚˚> ?
)
˚˚? @
{
¸¸ 
i
˝˝ 
++
˝˝ 
;
˝˝ 
}
˛˛ 
}
ˇˇ 
result
ÄÄ 
.
ÄÄ 
Append
ÄÄ 
(
ÄÄ 
c
ÄÄ 
)
ÄÄ  
;
ÄÄ  !
}
ÅÅ 
result
ÉÉ 
.
ÉÉ 
Append
ÉÉ 
(
ÉÉ 
DoubleQuote
ÉÉ %
)
ÉÉ% &
;
ÉÉ& '
return
ÑÑ 
result
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
áá 
static
áá 
ICharSequence
áá #
UnescapeCsv
áá$ /
(
áá/ 0
ICharSequence
áá0 =
value
áá> C
)
ááC D
{
àà 	
Contract
ââ 
.
ââ 
Requires
ââ 
(
ââ 
value
ââ #
!=
ââ$ &
null
ââ' +
)
ââ+ ,
;
ââ, -
int
ää 
length
ää 
=
ää 
value
ää 
.
ää 
Count
ää $
;
ää$ %
if
ãã 
(
ãã 
length
ãã 
==
ãã 
$num
ãã 
)
ãã 
{
åå 
return
çç 
value
çç 
;
çç 
}
éé 
int
èè 
last
èè 
=
èè 
length
èè 
-
èè 
$num
èè  !
;
èè! "
bool
êê 
quoted
êê 
=
êê 
IsDoubleQuote
êê '
(
êê' (
value
êê( -
[
êê- .
$num
êê. /
]
êê/ 0
)
êê0 1
&&
êê2 4
IsDoubleQuote
êê5 B
(
êêB C
value
êêC H
[
êêH I
last
êêI M
]
êêM N
)
êêN O
&&
êêP R
length
êêS Y
!=
êêZ \
$num
êê] ^
;
êê^ _
if
ëë 
(
ëë 
!
ëë 
quoted
ëë 
)
ëë 
{
íí 
ValidateCsvFormat
ìì !
(
ìì! "
value
ìì" '
)
ìì' (
;
ìì( )
return
îî 
value
îî 
;
îî 
}
ïï 
StringBuilder
ññ 
	unescaped
ññ #
=
ññ$ %$
InternalThreadLocalMap
ññ& <
.
ññ< =
Get
ññ= @
(
ññ@ A
)
ññA B
.
ññB C
StringBuilder
ññC P
;
ññP Q
for
óó 
(
óó 
int
óó 
i
óó 
=
óó 
$num
óó 
;
óó 
i
óó 
<
óó 
last
óó  $
;
óó$ %
i
óó& '
++
óó' )
)
óó) *
{
òò 
char
ôô 
current
ôô 
=
ôô 
value
ôô $
[
ôô$ %
i
ôô% &
]
ôô& '
;
ôô' (
if
öö 
(
öö 
current
öö 
==
öö 
DoubleQuote
öö *
)
öö* +
{
õõ 
if
úú 
(
úú 
IsDoubleQuote
úú %
(
úú% &
value
úú& +
[
úú+ ,
i
úú, -
+
úú. /
$num
úú0 1
]
úú1 2
)
úú2 3
&&
úú4 6
(
úú7 8
i
úú8 9
+
úú: ;
$num
úú< =
)
úú= >
!=
úú? A
last
úúB F
)
úúF G
{
ùù 
i
†† 
++
†† 
;
†† 
}
°° 
else
¢¢ 
{
££ 
throw
•• 0
"NewInvalidEscapedCsvFieldException
•• @
(
••@ A
value
••A F
,
••F G
i
••H I
)
••I J
;
••J K
}
¶¶ 
}
ßß 
	unescaped
®® 
.
®® 
Append
®®  
(
®®  !
current
®®! (
)
®®( )
;
®®) *
}
©© 
return
´´ 
new
´´  
StringCharSequence
´´ )
(
´´) *
	unescaped
´´* 3
.
´´3 4
ToString
´´4 <
(
´´< =
)
´´= >
)
´´> ?
;
´´? @
}
¨¨ 	
public
ÆÆ 
static
ÆÆ 
IList
ÆÆ 
<
ÆÆ 
ICharSequence
ÆÆ )
>
ÆÆ) *
UnescapeCsvFields
ÆÆ+ <
(
ÆÆ< =
ICharSequence
ÆÆ= J
value
ÆÆK P
)
ÆÆP Q
{
ØØ 	
var
∞∞ 
	unescaped
∞∞ 
=
∞∞ 
new
∞∞ 
List
∞∞  $
<
∞∞$ %
ICharSequence
∞∞% 2
>
∞∞2 3
(
∞∞3 4
$num
∞∞4 5
)
∞∞5 6
;
∞∞6 7
StringBuilder
±± 
current
±± !
=
±±" #$
InternalThreadLocalMap
±±$ :
.
±±: ;
Get
±±; >
(
±±> ?
)
±±? @
.
±±@ A
StringBuilder
±±A N
;
±±N O
bool
≤≤ 
quoted
≤≤ 
=
≤≤ 
false
≤≤ 
;
≤≤  
int
≥≥ 
last
≥≥ 
=
≥≥ 
value
≥≥ 
.
≥≥ 
Count
≥≥ "
-
≥≥# $
$num
≥≥% &
;
≥≥& '
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥ 
<=
¥¥  
last
¥¥! %
;
¥¥% &
i
¥¥' (
++
¥¥( *
)
¥¥* +
{
µµ 
char
∂∂ 
c
∂∂ 
=
∂∂ 
value
∂∂ 
[
∂∂ 
i
∂∂  
]
∂∂  !
;
∂∂! "
if
∑∑ 
(
∑∑ 
quoted
∑∑ 
)
∑∑ 
{
∏∏ 
switch
ππ 
(
ππ 
c
ππ 
)
ππ 
{
∫∫ 
case
ªª 
DoubleQuote
ªª (
:
ªª( )
if
ºº 
(
ºº  
i
ºº  !
==
ºº" $
last
ºº% )
)
ºº) *
{
ΩΩ 
	unescaped
øø  )
.
øø) *
Add
øø* -
(
øø- .
(
øø. / 
StringCharSequence
øø/ A
)
øøA B
current
øøB I
.
øøI J
ToString
øøJ R
(
øøR S
)
øøS T
)
øøT U
;
øøU V
return
¿¿  &
	unescaped
¿¿' 0
;
¿¿0 1
}
¡¡ 
char
¬¬  
next
¬¬! %
=
¬¬& '
value
¬¬( -
[
¬¬- .
++
¬¬. 0
i
¬¬0 1
]
¬¬1 2
;
¬¬2 3
if
√√ 
(
√√  
next
√√  $
==
√√% '
DoubleQuote
√√( 3
)
√√3 4
{
ƒƒ 
current
∆∆  '
.
∆∆' (
Append
∆∆( .
(
∆∆. /
DoubleQuote
∆∆/ :
)
∆∆: ;
;
∆∆; <
}
«« 
else
»»  
if
»»! #
(
»»$ %
next
»»% )
==
»»* ,
Comma
»»- 2
)
»»2 3
{
…… 
quoted
ÀÀ  &
=
ÀÀ' (
false
ÀÀ) .
;
ÀÀ. /
	unescaped
ÃÃ  )
.
ÃÃ) *
Add
ÃÃ* -
(
ÃÃ- .
(
ÃÃ. / 
StringCharSequence
ÃÃ/ A
)
ÃÃA B
current
ÃÃB I
.
ÃÃI J
ToString
ÃÃJ R
(
ÃÃR S
)
ÃÃS T
)
ÃÃT U
;
ÃÃU V
current
ÕÕ  '
.
ÕÕ' (
Length
ÕÕ( .
=
ÕÕ/ 0
$num
ÕÕ1 2
;
ÕÕ2 3
}
ŒŒ 
else
œœ  
{
–– 
throw
““  %
new
““& )
ArgumentException
““* ;
(
““; <
$"
““< >
$str
““> Y
{
““Y Z
value
““Z _
}
““_ `
$str
““` h
{
““h i
i
““i j
-
““k l
$num
““m n
}
““n o
"
““o p
)
““p q
;
““q r
}
”” 
break
‘‘ !
;
‘‘! "
default
’’ 
:
’’  
current
÷÷ #
.
÷÷# $
Append
÷÷$ *
(
÷÷* +
c
÷÷+ ,
)
÷÷, -
;
÷÷- .
break
◊◊ !
;
◊◊! "
}
ÿÿ 
}
ŸŸ 
else
⁄⁄ 
{
€€ 
switch
‹‹ 
(
‹‹ 
c
‹‹ 
)
‹‹ 
{
›› 
case
ﬁﬁ 
Comma
ﬁﬁ "
:
ﬁﬁ" #
	unescaped
‡‡ %
.
‡‡% &
Add
‡‡& )
(
‡‡) *
(
‡‡* + 
StringCharSequence
‡‡+ =
)
‡‡= >
current
‡‡> E
.
‡‡E F
ToString
‡‡F N
(
‡‡N O
)
‡‡O P
)
‡‡P Q
;
‡‡Q R
current
·· #
.
··# $
Length
··$ *
=
··+ ,
$num
··- .
;
··. /
break
‚‚ !
;
‚‚! "
case
„„ 
DoubleQuote
„„ (
:
„„( )
if
‰‰ 
(
‰‰  
current
‰‰  '
.
‰‰' (
Length
‰‰( .
==
‰‰/ 1
$num
‰‰2 3
)
‰‰3 4
{
ÂÂ 
quoted
ÊÊ  &
=
ÊÊ' (
true
ÊÊ) -
;
ÊÊ- .
}
ÁÁ 
else
ËË  
{
ÈÈ 
current
ÎÎ  '
.
ÎÎ' (
Append
ÎÎ( .
(
ÎÎ. /
c
ÎÎ/ 0
)
ÎÎ0 1
;
ÎÎ1 2
}
ÏÏ 
break
ÌÌ !
;
ÌÌ! "
case
ÓÓ 
LineFeed
ÓÓ %
:
ÓÓ% &
case
ÔÔ 
CarriageReturn
ÔÔ +
:
ÔÔ+ ,
throw
ÒÒ !
new
ÒÒ" %
ArgumentException
ÒÒ& 7
(
ÒÒ7 8
$"
ÒÒ8 :
$str
ÒÒ: U
{
ÒÒU V
value
ÒÒV [
}
ÒÒ[ \
$str
ÒÒ\ d
{
ÒÒd e
i
ÒÒe f
}
ÒÒf g
"
ÒÒg h
)
ÒÒh i
;
ÒÒi j
default
ÚÚ 
:
ÚÚ  
current
ÛÛ #
.
ÛÛ# $
Append
ÛÛ$ *
(
ÛÛ* +
c
ÛÛ+ ,
)
ÛÛ, -
;
ÛÛ- .
break
ÙÙ !
;
ÙÙ! "
}
ıı 
}
ˆˆ 
}
˜˜ 
if
¯¯ 
(
¯¯ 
quoted
¯¯ 
)
¯¯ 
{
˘˘ 
throw
˙˙ 
new
˙˙ 
ArgumentException
˙˙ +
(
˙˙+ ,
$"
˙˙, .
$str
˙˙. I
{
˙˙I J
value
˙˙J O
}
˙˙O P
$str
˙˙P X
{
˙˙X Y
last
˙˙Y ]
}
˙˙] ^
"
˙˙^ _
)
˙˙_ `
;
˙˙` a
}
˚˚ 
	unescaped
˝˝ 
.
˝˝ 
Add
˝˝ 
(
˝˝ 
(
˝˝  
StringCharSequence
˝˝ -
)
˝˝- .
current
˝˝. 5
.
˝˝5 6
ToString
˝˝6 >
(
˝˝> ?
)
˝˝? @
)
˝˝@ A
;
˝˝A B
return
˛˛ 
	unescaped
˛˛ 
;
˛˛ 
}
ˇˇ 	
static
ÅÅ 
void
ÅÅ 
ValidateCsvFormat
ÅÅ %
(
ÅÅ% &
ICharSequence
ÅÅ& 3
value
ÅÅ4 9
)
ÅÅ9 :
{
ÇÇ 	
int
ÉÉ 
length
ÉÉ 
=
ÉÉ 
value
ÉÉ 
.
ÉÉ 
Count
ÉÉ $
;
ÉÉ$ %
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
i
ÑÑ 
<
ÑÑ 
length
ÑÑ  &
;
ÑÑ& '
i
ÑÑ( )
++
ÑÑ) +
)
ÑÑ+ ,
{
ÖÖ 
switch
ÜÜ 
(
ÜÜ 
value
ÜÜ 
[
ÜÜ 
i
ÜÜ 
]
ÜÜ  
)
ÜÜ  !
{
áá 
case
àà 
DoubleQuote
àà $
:
àà$ %
case
ââ 
LineFeed
ââ !
:
ââ! "
case
ää 
CarriageReturn
ää '
:
ää' (
case
ãã 
Comma
ãã 
:
ãã 
throw
çç 0
"NewInvalidEscapedCsvFieldException
çç @
(
çç@ A
value
ççA F
,
ççF G
i
ççH I
)
ççI J
;
ççJ K
}
éé 
}
èè 
}
êê 	
static
íí 
ArgumentException
íí  0
"NewInvalidEscapedCsvFieldException
íí! C
(
ííC D
ICharSequence
ííD Q
value
ííR W
,
ííW X
int
ííY \
index
íí] b
)
ííb c
=>
ííd f
new
ííg j
ArgumentException
íík |
(
íí| }
$"
íí} 
$stríí ö
{ííö õ
valueííõ †
}íí† °
$stríí° ©
{íí© ™
indexíí™ Ø
}ííØ ∞
"íí∞ ±
)íí± ≤
;íí≤ ≥
public
îî 
static
îî 
int
îî 
Length
îî  
(
îî  !
string
îî! '
s
îî( )
)
îî) *
=>
îî+ -
s
îî. /
?
îî/ 0
.
îî0 1
Length
îî1 7
??
îî8 :
$num
îî; <
;
îî< =
public
ññ 
static
ññ 
int
ññ "
IndexOfNonWhiteSpace
ññ .
(
ññ. /
IReadOnlyList
ññ/ <
<
ññ< =
char
ññ= A
>
ññA B
seq
ññC F
,
ññF G
int
ññH K
offset
ññL R
)
ññR S
{
óó 	
for
òò 
(
òò 
;
òò 
offset
òò 
<
òò 
seq
òò 
.
òò  
Count
òò  %
;
òò% &
++
òò' )
offset
òò) /
)
òò/ 0
{
ôô 
if
öö 
(
öö 
!
öö 
char
öö 
.
öö 
IsWhiteSpace
öö &
(
öö& '
seq
öö' *
[
öö* +
offset
öö+ 1
]
öö1 2
)
öö2 3
)
öö3 4
{
õõ 
return
úú 
offset
úú !
;
úú! "
}
ùù 
}
ûû 
return
†† 
-
†† 
$num
†† 
;
†† 
}
°° 	
public
££ 
static
££ 
bool
££ 
IsSurrogate
££ &
(
££& '
char
££' +
c
££, -
)
££- .
=>
££/ 1
c
££2 3
>=
££4 6
$char
££7 ?
&&
££@ B
c
££C D
<=
££E G
$char
££H P
;
££P Q
static
•• 
bool
•• 
IsDoubleQuote
•• !
(
••! "
char
••" &
c
••' (
)
••( )
=>
••* ,
c
••- .
==
••/ 1
DoubleQuote
••2 =
;
••= >
public
ßß 
static
ßß 
bool
ßß 
EndsWith
ßß #
(
ßß# $
IReadOnlyList
ßß$ 1
<
ßß1 2
char
ßß2 6
>
ßß6 7
s
ßß8 9
,
ßß9 :
char
ßß; ?
c
ßß@ A
)
ßßA B
{
®® 	
int
©© 
len
©© 
=
©© 
s
©© 
.
©© 
Count
©© 
;
©© 
return
™™ 
len
™™ 
>
™™ 
$num
™™ 
&&
™™ 
s
™™ 
[
™™  
len
™™  #
-
™™$ %
$num
™™& '
]
™™' (
==
™™) +
c
™™, -
;
™™- .
}
´´ 	
public
≠≠ 
static
≠≠ 
ICharSequence
≠≠ #
TrimOws
≠≠$ +
(
≠≠+ ,
ICharSequence
≠≠, 9
value
≠≠: ?
)
≠≠? @
{
ÆÆ 	
int
ØØ 
length
ØØ 
=
ØØ 
value
ØØ 
.
ØØ 
Count
ØØ $
;
ØØ$ %
if
∞∞ 
(
∞∞ 
length
∞∞ 
==
∞∞ 
$num
∞∞ 
)
∞∞ 
{
±± 
return
≤≤ 
value
≤≤ 
;
≤≤ 
}
≥≥ 
int
µµ 
start
µµ 
=
µµ $
IndexOfFirstNonOwsChar
µµ .
(
µµ. /
value
µµ/ 4
,
µµ4 5
length
µµ6 <
)
µµ< =
;
µµ= >
int
∂∂ 
end
∂∂ 
=
∂∂ #
IndexOfLastNonOwsChar
∂∂ +
(
∂∂+ ,
value
∂∂, 1
,
∂∂1 2
start
∂∂3 8
,
∂∂8 9
length
∂∂: @
)
∂∂@ A
;
∂∂A B
return
∑∑ 
start
∑∑ 
==
∑∑ 
$num
∑∑ 
&&
∑∑  
end
∑∑! $
==
∑∑% '
length
∑∑( .
-
∑∑/ 0
$num
∑∑1 2
?
∑∑3 4
value
∑∑5 :
:
∑∑; <
value
∑∑= B
.
∑∑B C
SubSequence
∑∑C N
(
∑∑N O
start
∑∑O T
,
∑∑T U
end
∑∑V Y
+
∑∑Z [
$num
∑∑\ ]
)
∑∑] ^
;
∑∑^ _
}
∏∏ 	
static
∫∫ 
int
∫∫ $
IndexOfFirstNonOwsChar
∫∫ )
(
∫∫) *
IReadOnlyList
∫∫* 7
<
∫∫7 8
char
∫∫8 <
>
∫∫< =
value
∫∫> C
,
∫∫C D
int
∫∫E H
length
∫∫I O
)
∫∫O P
{
ªª 	
int
ºº 
i
ºº 
=
ºº 
$num
ºº 
;
ºº 
while
ΩΩ 
(
ΩΩ 
i
ΩΩ 
<
ΩΩ 
length
ΩΩ 
&&
ΩΩ  
IsOws
ΩΩ! &
(
ΩΩ& '
value
ΩΩ' ,
[
ΩΩ, -
i
ΩΩ- .
]
ΩΩ. /
)
ΩΩ/ 0
)
ΩΩ0 1
{
ææ 
i
øø 
++
øø 
;
øø 
}
¿¿ 
return
¬¬ 
i
¬¬ 
;
¬¬ 
}
√√ 	
static
≈≈ 
int
≈≈ #
IndexOfLastNonOwsChar
≈≈ (
(
≈≈( )
IReadOnlyList
≈≈) 6
<
≈≈6 7
char
≈≈7 ;
>
≈≈; <
value
≈≈= B
,
≈≈B C
int
≈≈D G
start
≈≈H M
,
≈≈M N
int
≈≈O R
length
≈≈S Y
)
≈≈Y Z
{
∆∆ 	
int
«« 
i
«« 
=
«« 
length
«« 
-
«« 
$num
«« 
;
«« 
while
»» 
(
»» 
i
»» 
>
»» 
start
»» 
&&
»» 
IsOws
»»  %
(
»»% &
value
»»& +
[
»»+ ,
i
»», -
]
»»- .
)
»». /
)
»»/ 0
{
…… 
i
   
--
   
;
   
}
ÀÀ 
return
ÕÕ 
i
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
[
–– 	

MethodImpl
––	 
(
–– 
MethodImplOptions
–– %
.
––% & 
AggressiveInlining
––& 8
)
––8 9
]
––9 :
static
—— 
bool
—— 
IsOws
—— 
(
—— 
char
—— 
c
——  
)
——  !
=>
——" $
c
——% &
==
——' )
Space
——* /
||
——0 2
c
——3 4
==
——5 7
Tab
——8 ;
;
——; <
}
““ 
}”” ˝^
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\TaskEx.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
TaskEx 
{ 
public 
static 
readonly 
Task #
<# $
int$ '
>' (
Zero) -
=. /
Task0 4
.4 5

FromResult5 ?
(? @
$num@ A
)A B
;B C
public 
static 
readonly 
Task #
<# $
int$ '
>' (
	Completed) 2
=3 4
Zero5 9
;9 :
public 
static 
readonly 
Task #
<# $
int$ '
>' (
	Cancelled) 2
=3 4
CreateCancelledTask5 H
(H I
)I J
;J K
public 
static 
readonly 
Task #
<# $
bool$ (
>( )
True* .
=/ 0
Task1 5
.5 6

FromResult6 @
(@ A
trueA E
)E F
;F G
public 
static 
readonly 
Task #
<# $
bool$ (
>( )
False* /
=0 1
Task2 6
.6 7

FromResult7 A
(A B
falseB G
)G H
;H I
static 
Task 
< 
int 
> 
CreateCancelledTask ,
(, -
)- .
{ 	
var 
tcs 
= 
new  
TaskCompletionSource .
<. /
int/ 2
>2 3
(3 4
)4 5
;5 6
tcs 
. 
SetCanceled 
( 
) 
; 
return 
tcs 
. 
Task 
; 
} 	
public 
static 
Task 
FromException (
(( )
	Exception) 2
	exception3 <
)< =
{ 	
var   
tcs   
=   
new    
TaskCompletionSource   .
(  . /
)  / 0
;  0 1
tcs!! 
.!! 
TrySetException!! 
(!!  
	exception!!  )
)!!) *
;!!* +
return"" 
tcs"" 
."" 
Task"" 
;"" 
}## 	
public%% 
static%% 
Task%% 
<%% 
T%% 
>%% 
FromException%% +
<%%+ ,
T%%, -
>%%- .
(%%. /
	Exception%%/ 8
	exception%%9 B
)%%B C
{&& 	
var'' 
tcs'' 
='' 
new''  
TaskCompletionSource'' .
<''. /
T''/ 0
>''0 1
(''1 2
)''2 3
;''3 4
tcs(( 
.(( 
TrySetException(( 
(((  
	exception((  )
)(() *
;((* +
return)) 
tcs)) 
.)) 
Task)) 
;)) 
}** 	
static,, 
readonly,, 
Action,, 
<,, 
Task,, #
,,,# $
object,,% +
>,,+ ,)
LinkOutcomeContinuationAction,,- J
=,,K L
(,,M N
t,,N O
,,,O P
tcs,,Q T
),,T U
=>,,V X
{-- 	
switch.. 
(.. 
t.. 
... 
Status.. 
).. 
{// 
case00 

TaskStatus00 
.00  
RanToCompletion00  /
:00/ 0
(11 
(11  
TaskCompletionSource11 *
)11* +
tcs11+ .
)11. /
.11/ 0
TryComplete110 ;
(11; <
)11< =
;11= >
break22 
;22 
case33 

TaskStatus33 
.33  
Canceled33  (
:33( )
(44 
(44  
TaskCompletionSource44 *
)44* +
tcs44+ .
)44. /
.44/ 0
TrySetCanceled440 >
(44> ?
)44? @
;44@ A
break55 
;55 
case66 

TaskStatus66 
.66  
Faulted66  '
:66' (
(77 
(77  
TaskCompletionSource77 *
)77* +
tcs77+ .
)77. /
.77/ 0
	TryUnwrap770 9
(779 :
t77: ;
.77; <
	Exception77< E
)77E F
;77F G
break88 
;88 
default99 
:99 
throw:: 
new:: '
ArgumentOutOfRangeException:: 9
(::9 :
)::: ;
;::; <
};; 
}<< 	
;<<	 

public>> 
static>> 
void>> 
LinkOutcome>> &
(>>& '
this>>' +
Task>>, 0
task>>1 5
,>>5 6 
TaskCompletionSource>>7 K 
taskCompletionSource>>L `
)>>` a
{?? 	
switch@@ 
(@@ 
task@@ 
.@@ 
Status@@ 
)@@  
{AA 
caseBB 

TaskStatusBB 
.BB  
RanToCompletionBB  /
:BB/ 0 
taskCompletionSourceCC (
.CC( )
TryCompleteCC) 4
(CC4 5
)CC5 6
;CC6 7
breakDD 
;DD 
caseEE 

TaskStatusEE 
.EE  
CanceledEE  (
:EE( ) 
taskCompletionSourceFF (
.FF( )
TrySetCanceledFF) 7
(FF7 8
)FF8 9
;FF9 :
breakGG 
;GG 
caseHH 

TaskStatusHH 
.HH  
FaultedHH  '
:HH' ( 
taskCompletionSourceII (
.II( )
	TryUnwrapII) 2
(II2 3
taskII3 7
.II7 8
	ExceptionII8 A
)IIA B
;IIB C
breakJJ 
;JJ 
defaultKK 
:KK 
taskLL 
.LL 
ContinueWithLL %
(LL% &)
LinkOutcomeContinuationActionMM 5
,MM5 6 
taskCompletionSourceNN ,
,NN, -#
TaskContinuationOptionsOO /
.OO/ 0 
ExecuteSynchronouslyOO0 D
)OOD E
;OOE F
breakPP 
;PP 
}QQ 
}RR 	
staticTT 
classTT !
LinkOutcomeActionHostTT *
<TT* +
TTT+ ,
>TT, -
{UU 	
publicVV 
staticVV 
readonlyVV "
ActionVV# )
<VV) *
TaskVV* .
<VV. /
TVV/ 0
>VV0 1
,VV1 2
objectVV3 9
>VV9 :
ActionVV; A
=VVB C
(WW 
tWW 
,WW 
tcsWW 
)WW 
=>WW 
{XX 
switchYY 
(YY 
tYY 
.YY 
StatusYY $
)YY$ %
{ZZ 
case[[ 

TaskStatus[[ '
.[[' (
RanToCompletion[[( 7
:[[7 8
(\\ 
(\\  
TaskCompletionSource\\ 2
<\\2 3
T\\3 4
>\\4 5
)\\5 6
tcs\\6 9
)\\9 :
.\\: ;
TrySetResult\\; G
(\\G H
t\\H I
.\\I J
Result\\J P
)\\P Q
;\\Q R
break]] !
;]]! "
case^^ 

TaskStatus^^ '
.^^' (
Canceled^^( 0
:^^0 1
(__ 
(__  
TaskCompletionSource__ 2
<__2 3
T__3 4
>__4 5
)__5 6
tcs__6 9
)__9 :
.__: ;
TrySetCanceled__; I
(__I J
)__J K
;__K L
break`` !
;``! "
caseaa 

TaskStatusaa '
.aa' (
Faultedaa( /
:aa/ 0
(bb 
(bb  
TaskCompletionSourcebb 2
<bb2 3
Tbb3 4
>bb4 5
)bb5 6
tcsbb6 9
)bb9 :
.bb: ;
	TryUnwrapbb; D
(bbD E
tbbE F
.bbF G
	ExceptionbbG P
)bbP Q
;bbQ R
breakcc !
;cc! "
defaultdd 
:dd  
throwee !
newee" %'
ArgumentOutOfRangeExceptionee& A
(eeA B
)eeB C
;eeC D
}ff 
}gg 
;gg 
}hh 	
publicjj 
staticjj 
voidjj 
LinkOutcomejj &
<jj& '
Tjj' (
>jj( )
(jj) *
thisjj* .
Taskjj/ 3
<jj3 4
Tjj4 5
>jj5 6
taskjj7 ;
,jj; < 
TaskCompletionSourcejj= Q
<jjQ R
TjjR S
>jjS T 
taskCompletionSourcejjU i
)jji j
{kk 	
switchll 
(ll 
taskll 
.ll 
Statusll 
)ll  
{mm 
casenn 

TaskStatusnn 
.nn  
RanToCompletionnn  /
:nn/ 0 
taskCompletionSourceoo (
.oo( )
TrySetResultoo) 5
(oo5 6
taskoo6 :
.oo: ;
Resultoo; A
)ooA B
;ooB C
breakpp 
;pp 
caseqq 

TaskStatusqq 
.qq  
Canceledqq  (
:qq( ) 
taskCompletionSourcerr (
.rr( )
TrySetCanceledrr) 7
(rr7 8
)rr8 9
;rr9 :
breakss 
;ss 
casett 

TaskStatustt 
.tt  
Faultedtt  '
:tt' ( 
taskCompletionSourceuu (
.uu( )
	TryUnwrapuu) 2
(uu2 3
taskuu3 7
.uu7 8
	Exceptionuu8 A
)uuA B
;uuB C
breakvv 
;vv 
defaultww 
:ww 
taskxx 
.xx 
ContinueWithxx %
(xx% &!
LinkOutcomeActionHostxx& ;
<xx; <
Txx< =
>xx= >
.xx> ?
Actionxx? E
,xxE F 
taskCompletionSourcexxG [
,xx[ \#
TaskContinuationOptionsxx] t
.xxt u!
ExecuteSynchronously	xxu â
)
xxâ ä
;
xxä ã
breakyy 
;yy 
}zz 
}{{ 	
public}} 
static}} 
void}} 
	TryUnwrap}} $
<}}$ %
T}}% &
>}}& '
(}}' (
this}}( , 
TaskCompletionSource}}- A
<}}A B
T}}B C
>}}C D
completionSource}}E U
,}}U V
	Exception}}W `
	exception}}a j
)}}j k
{~~ 	
if 
( 
	exception 
is 
AggregateException /
aggregateException0 B
)B C
{
ÄÄ 
completionSource
ÅÅ  
.
ÅÅ  !
TrySetException
ÅÅ! 0
(
ÅÅ0 1 
aggregateException
ÅÅ1 C
.
ÅÅC D
InnerExceptions
ÅÅD S
)
ÅÅS T
;
ÅÅT U
}
ÇÇ 
else
ÉÉ 
{
ÑÑ 
completionSource
ÖÖ  
.
ÖÖ  !
TrySetException
ÖÖ! 0
(
ÖÖ0 1
	exception
ÖÖ1 :
)
ÖÖ: ;
;
ÖÖ; <
}
ÜÜ 
}
áá 	
public
ââ 
static
ââ 
	Exception
ââ 
Unwrap
ââ  &
(
ââ& '
this
ââ' +
	Exception
ââ, 5
	exception
ââ6 ?
)
ââ? @
{
ää 	
if
ãã 
(
ãã 
	exception
ãã 
is
ãã  
AggregateException
ãã / 
aggregateException
ãã0 B
)
ããB C
{
åå 
return
çç  
aggregateException
çç )
.
çç) *
InnerException
çç* 8
;
çç8 9
}
éé 
return
êê 
	exception
êê 
;
êê 
}
ëë 	
}
íí 
}ìì ◊	
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\ThreadExtensions.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public

 

static

 
class

 
ThreadExtensions

 (
{ 
public 
static 
bool 
Join 
(  
this  $
Thread% +
thread, 2
,2 3
TimeSpan4 <
timeout= D
)D E
{ 	
long 
tm 
= 
( 
long 
) 
timeout #
.# $
TotalMilliseconds$ 5
;5 6
Contract 
. 
Requires 
( 
tm  
>=! #
$num$ %
&&& (
tm) +
<=, .
int/ 2
.2 3
MaxValue3 ;
); <
;< =
return 
thread 
. 
Join 
( 
(  
int  #
)# $
tm$ &
)& '
;' (
} 	
} 
} ó	
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Common\Utilities\TimeUtil.cs
	namespace 	
DotNetty
 
. 
Common 
. 
	Utilities #
{ 
public 

static 
class 
TimeUtil  
{ 
static 
TimeUtil 
( 
) 
{ 	
} 	
public 
static 
TimeSpan 
Max "
(" #
TimeSpan# +
t1, .
,. /
TimeSpan0 8
t29 ;
); <
{ 	
return 
t1 
> 
t2 
? 
t1 
:  !
t2" $
;$ %
} 	
public 
static 
TimeSpan 
GetSystemTime ,
(, -
)- .
{   	
return!! 
TimeSpan!! 
.!! 
FromMilliseconds!! ,
(!!, -
Environment!!- 8
.!!8 9
	TickCount!!9 B
)!!B C
;!!C D
}"" 	
}$$ 
}%% 