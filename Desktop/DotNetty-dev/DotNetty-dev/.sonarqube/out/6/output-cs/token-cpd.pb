¾ˆ	
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class 
AbstractByteBuffer ,
:- .
IByteBuffer/ :
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S
AbstractByteBufferS e
>e f
(f g
)g h
;h i
const 
string 
PropMode 
= 
$str  I
;I J
static 
readonly 
bool 
CheckAccessible ,
;, -
internal 
static 
readonly   
ResourceLeakDetector! 5
LeakDetector6 B
=C D 
ResourceLeakDetectorE Y
.Y Z
CreateZ `
<` a
IByteBuffera l
>l m
(m n
)n o
;o p
int 
readerIndex 
; 
int   
writerIndex   
;   
int"" 
markedReaderIndex"" 
;"" 
int## 
markedWriterIndex## 
;## 
int$$ 
maxCapacity$$ 
;$$ 
static&& 
AbstractByteBuffer&& !
(&&! "
)&&" #
{'' 	
CheckAccessible(( 
=(( 
SystemPropertyUtil(( 0
.((0 1

GetBoolean((1 ;
(((; <
PropMode((< D
,((D E
true((F J
)((J K
;((K L
if)) 
()) 
Logger)) 
.)) 
DebugEnabled)) #
)))# $
{** 
Logger++ 
.++ 
Debug++ 
(++ 
$str++ '
,++' (
PropMode++) 1
,++1 2
CheckAccessible++3 B
)++B C
;++C D
},, 
}-- 	
	protected// 
AbstractByteBuffer// $
(//$ %
int//% (
maxCapacity//) 4
)//4 5
{00 	
Contract11 
.11 
Requires11 
(11 
maxCapacity11 )
>=11* ,
$num11- .
)11. /
;11/ 0
this33 
.33 
maxCapacity33 
=33 
maxCapacity33 *
;33* +
}44 	
public66 
abstract66 
int66 
Capacity66 $
{66% &
get66' *
;66* +
}66, -
public88 
abstract88 
IByteBuffer88 #
AdjustCapacity88$ 2
(882 3
int883 6
newCapacity887 B
)88B C
;88C D
public:: 
virtual:: 
int:: 
MaxCapacity:: &
=>::' )
this::* .
.::. /
maxCapacity::/ :
;::: ;
	protected<< 
void<< 
SetMaxCapacity<< %
(<<% &
int<<& )
newMaxCapacity<<* 8
)<<8 9
{== 	
Contract>> 
.>> 
Requires>> 
(>> 
newMaxCapacity>> ,
>=>>- /
$num>>0 1
)>>1 2
;>>2 3
this@@ 
.@@ 
maxCapacity@@ 
=@@ 
newMaxCapacity@@ -
;@@- .
}AA 	
publicCC 
abstractCC  
IByteBufferAllocatorCC ,
	AllocatorCC- 6
{CC7 8
getCC9 <
;CC< =
}CC> ?
publicEE 
virtualEE 
intEE 
ReaderIndexEE &
=>EE' )
thisEE* .
.EE. /
readerIndexEE/ :
;EE: ;
publicGG 
virtualGG 
IByteBufferGG "
SetReaderIndexGG# 1
(GG1 2
intGG2 5
indexGG6 ;
)GG; <
{HH 	
ifII 
(II 
indexII 
<II 
$numII 
||II 
indexII "
>II# $
thisII% )
.II) *
writerIndexII* 5
)II5 6
{JJ 
ThrowHelperKK 
.KK 5
)ThrowIndexOutOfRangeException_ReaderIndexKK E
(KKE F
indexKKF K
,KKK L
thisKKM Q
.KKQ R
WriterIndexKKR ]
)KK] ^
;KK^ _
}LL 
thisNN 
.NN 
readerIndexNN 
=NN 
indexNN $
;NN$ %
returnOO 
thisOO 
;OO 
}PP 	
publicRR 
virtualRR 
intRR 
WriterIndexRR &
=>RR' )
thisRR* .
.RR. /
writerIndexRR/ :
;RR: ;
publicTT 
virtualTT 
IByteBufferTT "
SetWriterIndexTT# 1
(TT1 2
intTT2 5
indexTT6 ;
)TT; <
{UU 	
ifVV 
(VV 
indexVV 
<VV 
thisVV 
.VV 
readerIndexVV (
||VV) +
indexVV, 1
>VV2 3
thisVV4 8
.VV8 9
CapacityVV9 A
)VVA B
{WW 
ThrowHelperXX 
.XX 5
)ThrowIndexOutOfRangeException_WriterIndexXX E
(XXE F
indexXXF K
,XXK L
thisXXM Q
.XXQ R
readerIndexXXR ]
,XX] ^
thisXX_ c
.XXc d
CapacityXXd l
)XXl m
;XXm n
}YY 
this[[ 
.[[ 
SetWriterIndex0[[  
([[  !
index[[! &
)[[& '
;[[' (
return\\ 
this\\ 
;\\ 
}]] 	
	protected__ 
void__ 
SetWriterIndex0__ &
(__& '
int__' *
index__+ 0
)__0 1
{`` 	
thisaa 
.aa 
writerIndexaa 
=aa 
indexaa $
;aa$ %
}bb 	
publicdd 
virtualdd 
IByteBufferdd "
SetIndexdd# +
(dd+ ,
intdd, /
	readerIdxdd0 9
,dd9 :
intdd; >
	writerIdxdd? H
)ddH I
{ee 	
ifff 
(ff 
	readerIdxff 
<ff 
$numff 
||ff  
	readerIdxff! *
>ff+ ,
	writerIdxff- 6
||ff7 9
	writerIdxff: C
>ffD E
thisffF J
.ffJ K
CapacityffK S
)ffS T
{gg 
ThrowHelperhh 
.hh ;
/ThrowIndexOutOfRangeException_ReaderWriterIndexhh K
(hhK L
	readerIdxhhL U
,hhU V
	writerIdxhhW `
,hh` a
thishhb f
.hhf g
Capacityhhg o
)hho p
;hhp q
}ii 
thiskk 
.kk 
	SetIndex0kk 
(kk 
	readerIdxkk $
,kk$ %
	writerIdxkk& /
)kk/ 0
;kk0 1
returnll 
thisll 
;ll 
}mm 	
publicoo 
virtualoo 
IByteBufferoo "
Clearoo# (
(oo( )
)oo) *
{pp 	
thisqq 
.qq 
readerIndexqq 
=qq 
thisqq #
.qq# $
writerIndexqq$ /
=qq0 1
$numqq2 3
;qq3 4
returnrr 
thisrr 
;rr 
}ss 	
publicuu 
virtualuu 
booluu 

IsReadableuu &
(uu& '
)uu' (
=>uu) +
thisuu, 0
.uu0 1
writerIndexuu1 <
>uu= >
thisuu? C
.uuC D
readerIndexuuD O
;uuO P
publicww 
virtualww 
boolww 

IsReadableww &
(ww& '
intww' *
sizeww+ /
)ww/ 0
=>ww1 3
thisww4 8
.ww8 9
writerIndexww9 D
-wwE F
thiswwG K
.wwK L
readerIndexwwL W
>=wwX Z
sizeww[ _
;ww_ `
publicyy 
virtualyy 
boolyy 

IsWritableyy &
(yy& '
)yy' (
=>yy) +
thisyy, 0
.yy0 1
Capacityyy1 9
>yy: ;
thisyy< @
.yy@ A
writerIndexyyA L
;yyL M
public{{ 
virtual{{ 
bool{{ 

IsWritable{{ &
({{& '
int{{' *
size{{+ /
){{/ 0
=>{{1 3
this{{4 8
.{{8 9
Capacity{{9 A
-{{B C
this{{D H
.{{H I
writerIndex{{I T
>={{U W
size{{X \
;{{\ ]
public}} 
virtual}} 
int}} 
ReadableBytes}} (
=>}}) +
this}}, 0
.}}0 1
writerIndex}}1 <
-}}= >
this}}? C
.}}C D
readerIndex}}D O
;}}O P
public 
virtual 
int 
WritableBytes (
=>) +
this, 0
.0 1
Capacity1 9
-: ;
this< @
.@ A
writerIndexA L
;L M
public
 
virtual
 
int
 
MaxWritableBytes
 +
=>
, .
this
/ 3
.
3 4
MaxCapacity
4 ?
-
@ A
this
B F
.
F G
writerIndex
G R
;
R S
public
ƒƒ 
virtual
ƒƒ 
IByteBuffer
ƒƒ "
MarkReaderIndex
ƒƒ# 2
(
ƒƒ2 3
)
ƒƒ3 4
{
„„ 	
this
…… 
.
…… 
markedReaderIndex
…… "
=
……# $
this
……% )
.
……) *
readerIndex
……* 5
;
……5 6
return
†† 
this
†† 
;
†† 
}
‡‡ 	
public
‰‰ 
virtual
‰‰ 
IByteBuffer
‰‰ "
ResetReaderIndex
‰‰# 3
(
‰‰3 4
)
‰‰4 5
{
ŠŠ 	
this
‹‹ 
.
‹‹ 
SetReaderIndex
‹‹ 
(
‹‹  
this
‹‹  $
.
‹‹$ %
markedReaderIndex
‹‹% 6
)
‹‹6 7
;
‹‹7 8
return
ŒŒ 
this
ŒŒ 
;
ŒŒ 
}
 	
public
 
virtual
 
IByteBuffer
 "
MarkWriterIndex
# 2
(
2 3
)
3 4
{
 	
this
‘‘ 
.
‘‘ 
markedWriterIndex
‘‘ "
=
‘‘# $
this
‘‘% )
.
‘‘) *
writerIndex
‘‘* 5
;
‘‘5 6
return
’’ 
this
’’ 
;
’’ 
}
““ 	
public
•• 
virtual
•• 
IByteBuffer
•• "
ResetWriterIndex
••# 3
(
••3 4
)
••4 5
{
–– 	
this
—— 
.
—— 
SetWriterIndex
—— 
(
——  
this
——  $
.
——$ %
markedWriterIndex
——% 6
)
——6 7
;
——7 8
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
™™ 	
	protected
›› 
void
›› 
	MarkIndex
››  
(
››  !
)
››! "
{
œœ 	
this
 
.
 
markedReaderIndex
 "
=
# $
this
% )
.
) *
readerIndex
* 5
;
5 6
this
 
.
 
markedWriterIndex
 "
=
# $
this
% )
.
) *
writerIndex
* 5
;
5 6
}
ŸŸ 	
public
¡¡ 
virtual
¡¡ 
IByteBuffer
¡¡ "
DiscardReadBytes
¡¡# 3
(
¡¡3 4
)
¡¡4 5
{
¢¢ 	
this
££ 
.
££ 
EnsureAccessible
££ !
(
££! "
)
££" #
;
££# $
if
¤¤ 
(
¤¤ 
this
¤¤ 
.
¤¤ 
readerIndex
¤¤  
==
¤¤! #
$num
¤¤$ %
)
¤¤% &
{
¥¥ 
return
¦¦ 
this
¦¦ 
;
¦¦ 
}
§§ 
if
©© 
(
©© 
this
©© 
.
©© 
readerIndex
©©  
!=
©©! #
this
©©$ (
.
©©( )
writerIndex
©©) 4
)
©©4 5
{
ªª 
this
«« 
.
«« 
SetBytes
«« 
(
«« 
$num
«« 
,
««  
this
««! %
,
««% &
this
««' +
.
««+ ,
readerIndex
««, 7
,
««7 8
this
««9 =
.
««= >
writerIndex
««> I
-
««J K
this
««L P
.
««P Q
readerIndex
««Q \
)
««\ ]
;
««] ^
this
¬¬ 
.
¬¬ 
writerIndex
¬¬  
-=
¬¬! #
this
¬¬$ (
.
¬¬( )
readerIndex
¬¬) 4
;
¬¬4 5
this
­­ 
.
­­ 
AdjustMarkers
­­ "
(
­­" #
this
­­# '
.
­­' (
readerIndex
­­( 3
)
­­3 4
;
­­4 5
this
®® 
.
®® 
readerIndex
®®  
=
®®! "
$num
®®# $
;
®®$ %
}
¯¯ 
else
°° 
{
±± 
this
²² 
.
²² 
AdjustMarkers
²² "
(
²²" #
this
²²# '
.
²²' (
readerIndex
²²( 3
)
²²3 4
;
²²4 5
this
³³ 
.
³³ 
writerIndex
³³  
=
³³! "
this
³³# '
.
³³' (
readerIndex
³³( 3
=
³³4 5
$num
³³6 7
;
³³7 8
}
´´ 
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
·· 	
public
¹¹ 
virtual
¹¹ 
IByteBuffer
¹¹ ""
DiscardSomeReadBytes
¹¹# 7
(
¹¹7 8
)
¹¹8 9
{
ºº 	
this
»» 
.
»» 
EnsureAccessible
»» !
(
»»! "
)
»»" #
;
»»# $
if
¼¼ 
(
¼¼ 
this
¼¼ 
.
¼¼ 
readerIndex
¼¼  
==
¼¼! #
$num
¼¼$ %
)
¼¼% &
{
½½ 
return
¾¾ 
this
¾¾ 
;
¾¾ 
}
¿¿ 
if
ÁÁ 
(
ÁÁ 
this
ÁÁ 
.
ÁÁ 
readerIndex
ÁÁ  
==
ÁÁ! #
this
ÁÁ$ (
.
ÁÁ( )
writerIndex
ÁÁ) 4
)
ÁÁ4 5
{
ÂÂ 
this
ÃÃ 
.
ÃÃ 
AdjustMarkers
ÃÃ "
(
ÃÃ" #
this
ÃÃ# '
.
ÃÃ' (
readerIndex
ÃÃ( 3
)
ÃÃ3 4
;
ÃÃ4 5
this
ÄÄ 
.
ÄÄ 
writerIndex
ÄÄ  
=
ÄÄ! "
this
ÄÄ# '
.
ÄÄ' (
readerIndex
ÄÄ( 3
=
ÄÄ4 5
$num
ÄÄ6 7
;
ÄÄ7 8
return
ÅÅ 
this
ÅÅ 
;
ÅÅ 
}
ÆÆ 
if
ÈÈ 
(
ÈÈ 
this
ÈÈ 
.
ÈÈ 
readerIndex
ÈÈ  
>=
ÈÈ! #
this
ÈÈ$ (
.
ÈÈ( )
Capacity
ÈÈ) 1
.
ÈÈ1 2
RightUShift
ÈÈ2 =
(
ÈÈ= >
$num
ÈÈ> ?
)
ÈÈ? @
)
ÈÈ@ A
{
ÉÉ 
this
ÊÊ 
.
ÊÊ 
SetBytes
ÊÊ 
(
ÊÊ 
$num
ÊÊ 
,
ÊÊ  
this
ÊÊ! %
,
ÊÊ% &
this
ÊÊ' +
.
ÊÊ+ ,
readerIndex
ÊÊ, 7
,
ÊÊ7 8
this
ÊÊ9 =
.
ÊÊ= >
writerIndex
ÊÊ> I
-
ÊÊJ K
this
ÊÊL P
.
ÊÊP Q
readerIndex
ÊÊQ \
)
ÊÊ\ ]
;
ÊÊ] ^
this
ËË 
.
ËË 
writerIndex
ËË  
-=
ËË! #
this
ËË$ (
.
ËË( )
readerIndex
ËË) 4
;
ËË4 5
this
ÌÌ 
.
ÌÌ 
AdjustMarkers
ÌÌ "
(
ÌÌ" #
this
ÌÌ# '
.
ÌÌ' (
readerIndex
ÌÌ( 3
)
ÌÌ3 4
;
ÌÌ4 5
this
ÍÍ 
.
ÍÍ 
readerIndex
ÍÍ  
=
ÍÍ! "
$num
ÍÍ# $
;
ÍÍ$ %
}
ÎÎ 
return
ĞĞ 
this
ĞĞ 
;
ĞĞ 
}
ÑÑ 	
	protected
ÓÓ 
void
ÓÓ 
AdjustMarkers
ÓÓ $
(
ÓÓ$ %
int
ÓÓ% (
	decrement
ÓÓ) 2
)
ÓÓ2 3
{
ÔÔ 	
int
ÕÕ 
markedReaderIdx
ÕÕ 
=
ÕÕ  !
this
ÕÕ" &
.
ÕÕ& '
markedReaderIndex
ÕÕ' 8
;
ÕÕ8 9
if
ÖÖ 
(
ÖÖ 
markedReaderIdx
ÖÖ 
<=
ÖÖ  "
	decrement
ÖÖ# ,
)
ÖÖ, -
{
×× 
this
ØØ 
.
ØØ 
markedReaderIndex
ØØ &
=
ØØ' (
$num
ØØ) *
;
ØØ* +
int
ÙÙ 
markedWriterIdx
ÙÙ #
=
ÙÙ$ %
this
ÙÙ& *
.
ÙÙ* +
markedWriterIndex
ÙÙ+ <
;
ÙÙ< =
if
ÚÚ 
(
ÚÚ 
markedWriterIdx
ÚÚ #
<=
ÚÚ$ &
	decrement
ÚÚ' 0
)
ÚÚ0 1
{
ÛÛ 
this
ÜÜ 
.
ÜÜ 
markedWriterIndex
ÜÜ *
=
ÜÜ+ ,
$num
ÜÜ- .
;
ÜÜ. /
}
İİ 
else
ŞŞ 
{
ßß 
this
àà 
.
àà 
markedWriterIndex
àà *
=
àà+ ,
markedWriterIdx
àà- <
-
àà= >
	decrement
àà? H
;
ààH I
}
áá 
}
ââ 
else
ãã 
{
ää 
this
åå 
.
åå 
markedReaderIndex
åå &
=
åå' (
markedReaderIdx
åå) 8
-
åå9 :
	decrement
åå; D
;
ååD E
this
ææ 
.
ææ 
markedWriterIndex
ææ &
-=
ææ' )
	decrement
ææ* 3
;
ææ3 4
}
çç 
}
èè 	
public
êê 
virtual
êê 
IByteBuffer
êê "
EnsureWritable
êê# 1
(
êê1 2
int
êê2 5
minWritableBytes
êê6 F
)
êêF G
{
ëë 	
if
ìì 
(
ìì 
minWritableBytes
ìì  
<
ìì! "
$num
ìì# $
)
ìì$ %
{
íí 
ThrowHelper
îî 
.
îî ?
1ThrowArgumentOutOfRangeException_MinWritableBytes
îî M
(
îîM N
)
îîN O
;
îîO P
}
ïï 
this
ññ 
.
ññ 
EnsureWritable0
ññ  
(
ññ  !
minWritableBytes
ññ! 1
)
ññ1 2
;
ññ2 3
return
òò 
this
òò 
;
òò 
}
óó 	
[
õõ 	

MethodImpl
õõ	 
(
õõ 
MethodImplOptions
õõ %
.
õõ% & 
AggressiveInlining
õõ& 8
)
õõ8 9
]
õõ9 :
	protected
öö 
internal
öö 
void
öö 
EnsureWritable0
öö  /
(
öö/ 0
int
öö0 3
minWritableBytes
öö4 D
)
ööD E
{
÷÷ 	
this
øø 
.
øø 
EnsureAccessible
øø !
(
øø! "
)
øø" #
;
øø# $
if
ùù 
(
ùù 
minWritableBytes
ùù  
<=
ùù! #
this
ùù$ (
.
ùù( )
WritableBytes
ùù) 6
)
ùù6 7
{
úú 
return
ûû 
;
ûû 
}
üü 
if
şş 
(
şş 
minWritableBytes
şş  
>
şş! "
this
şş# '
.
şş' (
MaxCapacity
şş( 3
-
şş4 5
this
şş6 :
.
şş: ;
writerIndex
şş; F
)
şşF G
{
ÿÿ 
ThrowHelper
€€ 
.
€€ 7
)ThrowIndexOutOfRangeException_WriterIndex
€€ E
(
€€E F
minWritableBytes
€€F V
,
€€V W
this
€€X \
.
€€\ ]
writerIndex
€€] h
,
€€h i
this
€€j n
.
€€n o
MaxCapacity
€€o z
,
€€z {
this€€| €
)€€€ 
;€€ ‚
}
 
int
„„ 
newCapacity
„„ 
=
„„ 
this
„„ "
.
„„" #
	Allocator
„„# ,
.
„„, -"
CalculateNewCapacity
„„- A
(
„„A B
this
„„B F
.
„„F G
writerIndex
„„G R
+
„„S T
minWritableBytes
„„U e
,
„„e f
this
„„g k
.
„„k l
MaxCapacity
„„l w
)
„„w x
;
„„x y
this
‡‡ 
.
‡‡ 
AdjustCapacity
‡‡ 
(
‡‡  
newCapacity
‡‡  +
)
‡‡+ ,
;
‡‡, -
}
ˆˆ 	
public
ŠŠ 
virtual
ŠŠ 
int
ŠŠ 
EnsureWritable
ŠŠ )
(
ŠŠ) *
int
ŠŠ* -
minWritableBytes
ŠŠ. >
,
ŠŠ> ?
bool
ŠŠ@ D
force
ŠŠE J
)
ŠŠJ K
{
‹‹ 	
Contract
ŒŒ 
.
ŒŒ 
Ensures
ŒŒ 
(
ŒŒ 
minWritableBytes
ŒŒ -
>=
ŒŒ. 0
$num
ŒŒ1 2
)
ŒŒ2 3
;
ŒŒ3 4
this
 
.
 
EnsureAccessible
 !
(
! "
)
" #
;
# $
if
 
(
 
minWritableBytes
  
<=
! #
this
$ (
.
( )
WritableBytes
) 6
)
6 7
{
 
return
‘‘ 
$num
‘‘ 
;
‘‘ 
}
’’ 
if
”” 
(
”” 
minWritableBytes
””  
>
””! "
this
””# '
.
””' (
MaxCapacity
””( 3
-
””4 5
this
””6 :
.
””: ;
writerIndex
””; F
)
””F G
{
•• 
if
–– 
(
–– 
!
–– 
force
–– 
||
–– 
this
–– "
.
––" #
Capacity
––# +
==
––, .
this
––/ 3
.
––3 4
MaxCapacity
––4 ?
)
––? @
{
—— 
return
˜˜ 
$num
˜˜  
;
˜˜  !
}
™™ 
this
›› 
.
›› 
AdjustCapacity
›› #
(
››# $
this
››$ (
.
››( )
MaxCapacity
››) 4
)
››4 5
;
››5 6
return
œœ 
$num
œœ 
;
œœ 
}
 
int
   
newCapacity
   
=
   
this
   "
.
  " #
	Allocator
  # ,
.
  , -"
CalculateNewCapacity
  - A
(
  A B
this
  B F
.
  F G
writerIndex
  G R
+
  S T
minWritableBytes
  U e
,
  e f
this
  g k
.
  k l
MaxCapacity
  l w
)
  w x
;
  x y
this
££ 
.
££ 
AdjustCapacity
££ 
(
££  
newCapacity
££  +
)
££+ ,
;
££, -
return
¤¤ 
$num
¤¤ 
;
¤¤ 
}
¥¥ 	
public
§§ 
virtual
§§ 
byte
§§ 
GetByte
§§ #
(
§§# $
int
§§$ '
index
§§( -
)
§§- .
{
¨¨ 	
this
©© 
.
©© 

CheckIndex
©© 
(
©© 
index
©© !
)
©©! "
;
©©" #
return
ªª 
this
ªª 
.
ªª 
_GetByte
ªª  
(
ªª  !
index
ªª! &
)
ªª& '
;
ªª' (
}
«« 	
	protected
­­ 
internal
­­ 
abstract
­­ #
byte
­­$ (
_GetByte
­­) 1
(
­­1 2
int
­­2 5
index
­­6 ;
)
­­; <
;
­­< =
public
¯¯ 
bool
¯¯ 

GetBoolean
¯¯ 
(
¯¯ 
int
¯¯ "
index
¯¯# (
)
¯¯( )
=>
¯¯* ,
this
¯¯- 1
.
¯¯1 2
GetByte
¯¯2 9
(
¯¯9 :
index
¯¯: ?
)
¯¯? @
!=
¯¯A C
$num
¯¯D E
;
¯¯E F
public
±± 
virtual
±± 
short
±± 
GetShort
±± %
(
±±% &
int
±±& )
index
±±* /
)
±±/ 0
{
²² 	
this
³³ 
.
³³ 

CheckIndex
³³ 
(
³³ 
index
³³ !
,
³³! "
$num
³³# $
)
³³$ %
;
³³% &
return
´´ 
this
´´ 
.
´´ 
	_GetShort
´´ !
(
´´! "
index
´´" '
)
´´' (
;
´´( )
}
µµ 	
	protected
·· 
internal
·· 
abstract
·· #
short
··$ )
	_GetShort
··* 3
(
··3 4
int
··4 7
index
··8 =
)
··= >
;
··> ?
public
¹¹ 
virtual
¹¹ 
short
¹¹ 

GetShortLE
¹¹ '
(
¹¹' (
int
¹¹( +
index
¹¹, 1
)
¹¹1 2
{
ºº 	
this
»» 
.
»» 

CheckIndex
»» 
(
»» 
index
»» !
,
»»! "
$num
»»# $
)
»»$ %
;
»»% &
return
¼¼ 
this
¼¼ 
.
¼¼ 
_GetShortLE
¼¼ #
(
¼¼# $
index
¼¼$ )
)
¼¼) *
;
¼¼* +
}
½½ 	
	protected
¿¿ 
internal
¿¿ 
abstract
¿¿ #
short
¿¿$ )
_GetShortLE
¿¿* 5
(
¿¿5 6
int
¿¿6 9
index
¿¿: ?
)
¿¿? @
;
¿¿@ A
public
ÁÁ 
ushort
ÁÁ 
GetUnsignedShort
ÁÁ &
(
ÁÁ& '
int
ÁÁ' *
index
ÁÁ+ 0
)
ÁÁ0 1
{
ÂÂ 	
	unchecked
ÃÃ 
{
ÄÄ 
return
ÅÅ 
(
ÅÅ 
ushort
ÅÅ 
)
ÅÅ 
this
ÅÅ #
.
ÅÅ# $
GetShort
ÅÅ$ ,
(
ÅÅ, -
index
ÅÅ- 2
)
ÅÅ2 3
;
ÅÅ3 4
}
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
ushort
ÉÉ  
GetUnsignedShortLE
ÉÉ (
(
ÉÉ( )
int
ÉÉ) ,
index
ÉÉ- 2
)
ÉÉ2 3
{
ÊÊ 	
	unchecked
ËË 
{
ÌÌ 
return
ÍÍ 
(
ÍÍ 
ushort
ÍÍ 
)
ÍÍ 
this
ÍÍ #
.
ÍÍ# $

GetShortLE
ÍÍ$ .
(
ÍÍ. /
index
ÍÍ/ 4
)
ÍÍ4 5
;
ÍÍ5 6
}
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
virtual
ÑÑ 
int
ÑÑ 
GetUnsignedMedium
ÑÑ ,
(
ÑÑ, -
int
ÑÑ- 0
index
ÑÑ1 6
)
ÑÑ6 7
{
ÒÒ 	
this
ÓÓ 
.
ÓÓ 

CheckIndex
ÓÓ 
(
ÓÓ 
index
ÓÓ !
,
ÓÓ! "
$num
ÓÓ# $
)
ÓÓ$ %
;
ÓÓ% &
return
ÔÔ 
this
ÔÔ 
.
ÔÔ  
_GetUnsignedMedium
ÔÔ *
(
ÔÔ* +
index
ÔÔ+ 0
)
ÔÔ0 1
;
ÔÔ1 2
}
ÕÕ 	
	protected
×× 
internal
×× 
abstract
×× #
int
××$ ' 
_GetUnsignedMedium
××( :
(
××: ;
int
××; >
index
××? D
)
××D E
;
××E F
public
ÙÙ 
virtual
ÙÙ 
int
ÙÙ !
GetUnsignedMediumLE
ÙÙ .
(
ÙÙ. /
int
ÙÙ/ 2
index
ÙÙ3 8
)
ÙÙ8 9
{
ÚÚ 	
this
ÛÛ 
.
ÛÛ 

CheckIndex
ÛÛ 
(
ÛÛ 
index
ÛÛ !
,
ÛÛ! "
$num
ÛÛ# $
)
ÛÛ$ %
;
ÛÛ% &
return
ÜÜ 
this
ÜÜ 
.
ÜÜ "
_GetUnsignedMediumLE
ÜÜ ,
(
ÜÜ, -
index
ÜÜ- 2
)
ÜÜ2 3
;
ÜÜ3 4
}
İİ 	
	protected
ßß 
internal
ßß 
abstract
ßß #
int
ßß$ '"
_GetUnsignedMediumLE
ßß( <
(
ßß< =
int
ßß= @
index
ßßA F
)
ßßF G
;
ßßG H
public
áá 
int
áá 
	GetMedium
áá 
(
áá 
int
áá  
index
áá! &
)
áá& '
{
ââ 	
uint
ãã 
value
ãã 
=
ãã 
(
ãã 
uint
ãã 
)
ãã 
this
ãã #
.
ãã# $
GetUnsignedMedium
ãã$ 5
(
ãã5 6
index
ãã6 ;
)
ãã; <
;
ãã< =
if
ää 
(
ää 
(
ää 
value
ää 
&
ää 
$num
ää !
)
ää! "
!=
ää# %
$num
ää& '
)
ää' (
{
åå 
value
ææ 
|=
ææ 
$num
ææ #
;
ææ# $
}
çç 
return
éé 
(
éé 
int
éé 
)
éé 
value
éé 
;
éé 
}
êê 	
public
ìì 
int
ìì 
GetMediumLE
ìì 
(
ìì 
int
ìì "
index
ìì# (
)
ìì( )
{
íí 	
uint
îî 
value
îî 
=
îî 
(
îî 
uint
îî 
)
îî 
this
îî #
.
îî# $!
GetUnsignedMediumLE
îî$ 7
(
îî7 8
index
îî8 =
)
îî= >
;
îî> ?
if
ïï 
(
ïï 
(
ïï 
value
ïï 
&
ïï 
$num
ïï !
)
ïï! "
!=
ïï# %
$num
ïï& '
)
ïï' (
{
ğğ 
value
ññ 
|=
ññ 
$num
ññ #
;
ññ# $
}
òò 
return
ôô 
(
ôô 
int
ôô 
)
ôô 
value
ôô 
;
ôô 
}
õõ 	
public
÷÷ 
virtual
÷÷ 
int
÷÷ 
GetInt
÷÷ !
(
÷÷! "
int
÷÷" %
index
÷÷& +
)
÷÷+ ,
{
øø 	
this
ùù 
.
ùù 

CheckIndex
ùù 
(
ùù 
index
ùù !
,
ùù! "
$num
ùù# $
)
ùù$ %
;
ùù% &
return
úú 
this
úú 
.
úú 
_GetInt
úú 
(
úú  
index
úú  %
)
úú% &
;
úú& '
}
ûû 	
	protected
ıı 
internal
ıı 
abstract
ıı #
int
ıı$ '
_GetInt
ıı( /
(
ıı/ 0
int
ıı0 3
index
ıı4 9
)
ıı9 :
;
ıı: ;
public
ÿÿ 
virtual
ÿÿ 
int
ÿÿ 
GetIntLE
ÿÿ #
(
ÿÿ# $
int
ÿÿ$ '
index
ÿÿ( -
)
ÿÿ- .
{
€€ 	
this
 
.
 

CheckIndex
 
(
 
index
 !
,
! "
$num
# $
)
$ %
;
% &
return
‚‚ 
this
‚‚ 
.
‚‚ 
	_GetIntLE
‚‚ !
(
‚‚! "
index
‚‚" '
)
‚‚' (
;
‚‚( )
}
ƒƒ 	
	protected
…… 
internal
…… 
abstract
…… #
int
……$ '
	_GetIntLE
……( 1
(
……1 2
int
……2 5
index
……6 ;
)
……; <
;
……< =
public
‡‡ 
uint
‡‡ 
GetUnsignedInt
‡‡ "
(
‡‡" #
int
‡‡# &
index
‡‡' ,
)
‡‡, -
{
ˆˆ 	
	unchecked
‰‰ 
{
ŠŠ 
return
‹‹ 
(
‹‹ 
uint
‹‹ 
)
‹‹ 
(
‹‹ 
this
‹‹ "
.
‹‹" #
GetInt
‹‹# )
(
‹‹) *
index
‹‹* /
)
‹‹/ 0
)
‹‹0 1
;
‹‹1 2
}
ŒŒ 
}
 	
public
 
uint
 
GetUnsignedIntLE
 $
(
$ %
int
% (
index
) .
)
. /
{
 	
	unchecked
‘‘ 
{
’’ 
return
““ 
(
““ 
uint
““ 
)
““ 
this
““ !
.
““! "
GetIntLE
““" *
(
““* +
index
““+ 0
)
““0 1
;
““1 2
}
”” 
}
•• 	
public
—— 
virtual
—— 
long
—— 
GetLong
—— #
(
——# $
int
——$ '
index
——( -
)
——- .
{
˜˜ 	
this
™™ 
.
™™ 

CheckIndex
™™ 
(
™™ 
index
™™ !
,
™™! "
$num
™™# $
)
™™$ %
;
™™% &
return
šš 
this
šš 
.
šš 
_GetLong
šš  
(
šš  !
index
šš! &
)
šš& '
;
šš' (
}
›› 	
	protected
 
internal
 
abstract
 #
long
$ (
_GetLong
) 1
(
1 2
int
2 5
index
6 ;
)
; <
;
< =
public
ŸŸ 
virtual
ŸŸ 
long
ŸŸ 
	GetLongLE
ŸŸ %
(
ŸŸ% &
int
ŸŸ& )
index
ŸŸ* /
)
ŸŸ/ 0
{
   	
this
¡¡ 
.
¡¡ 

CheckIndex
¡¡ 
(
¡¡ 
index
¡¡ !
,
¡¡! "
$num
¡¡# $
)
¡¡$ %
;
¡¡% &
return
¢¢ 
this
¢¢ 
.
¢¢ 

_GetLongLE
¢¢ "
(
¢¢" #
index
¢¢# (
)
¢¢( )
;
¢¢) *
}
££ 	
	protected
¥¥ 
internal
¥¥ 
abstract
¥¥ #
long
¥¥$ (

_GetLongLE
¥¥) 3
(
¥¥3 4
int
¥¥4 7
index
¥¥8 =
)
¥¥= >
;
¥¥> ?
public
§§ 
virtual
§§ 
char
§§ 
GetChar
§§ #
(
§§# $
int
§§$ '
index
§§( -
)
§§- .
=>
§§/ 1
Convert
§§2 9
.
§§9 :
ToChar
§§: @
(
§§@ A
this
§§A E
.
§§E F
GetShort
§§F N
(
§§N O
index
§§O T
)
§§T U
)
§§U V
;
§§V W
public
©© 
float
©© 
GetFloat
©© 
(
©© 
int
©© !
index
©©" '
)
©©' (
=>
©©) +
ByteBufferUtil
©©, :
.
©©: ;
Int32BitsToSingle
©©; L
(
©©L M
this
©©M Q
.
©©Q R
GetInt
©©R X
(
©©X Y
index
©©Y ^
)
©©^ _
)
©©_ `
;
©©` a
public
«« 
float
«« 

GetFloatLE
«« 
(
««  
int
««  #
index
««$ )
)
««) *
=>
««+ -
ByteBufferUtil
««. <
.
««< =
Int32BitsToSingle
««= N
(
««N O
this
««O S
.
««S T
GetIntLE
««T \
(
««\ ]
index
««] b
)
««b c
)
««c d
;
««d e
public
­­ 
double
­­ 
	GetDouble
­­ 
(
­­  
int
­­  #
index
­­$ )
)
­­) *
=>
­­+ -
BitConverter
­­. :
.
­­: ;
Int64BitsToDouble
­­; L
(
­­L M
this
­­M Q
.
­­Q R
GetLong
­­R Y
(
­­Y Z
index
­­Z _
)
­­_ `
)
­­` a
;
­­a b
public
¯¯ 
double
¯¯ 
GetDoubleLE
¯¯ !
(
¯¯! "
int
¯¯" %
index
¯¯& +
)
¯¯+ ,
=>
¯¯- /
BitConverter
¯¯0 <
.
¯¯< =
Int64BitsToDouble
¯¯= N
(
¯¯N O
this
¯¯O S
.
¯¯S T
	GetLongLE
¯¯T ]
(
¯¯] ^
index
¯¯^ c
)
¯¯c d
)
¯¯d e
;
¯¯e f
public
±± 
virtual
±± 
IByteBuffer
±± "
GetBytes
±±# +
(
±±+ ,
int
±±, /
index
±±0 5
,
±±5 6
byte
±±7 ;
[
±±; <
]
±±< =
destination
±±> I
)
±±I J
{
²² 	
this
³³ 
.
³³ 
GetBytes
³³ 
(
³³ 
index
³³ 
,
³³  
destination
³³! ,
,
³³, -
$num
³³. /
,
³³/ 0
destination
³³1 <
.
³³< =
Length
³³= C
)
³³C D
;
³³D E
return
´´ 
this
´´ 
;
´´ 
}
µµ 	
public
·· 
abstract
·· 
IByteBuffer
·· #
GetBytes
··$ ,
(
··, -
int
··- 0
index
··1 6
,
··6 7
byte
··8 <
[
··< =
]
··= >
destination
··? J
,
··J K
int
··L O
dstIndex
··P X
,
··X Y
int
··Z ]
length
··^ d
)
··d e
;
··e f
public
¹¹ 
virtual
¹¹ 
IByteBuffer
¹¹ "
GetBytes
¹¹# +
(
¹¹+ ,
int
¹¹, /
index
¹¹0 5
,
¹¹5 6
IByteBuffer
¹¹7 B
destination
¹¹C N
)
¹¹N O
{
ºº 	
this
»» 
.
»» 
GetBytes
»» 
(
»» 
index
»» 
,
»»  
destination
»»! ,
,
»», -
destination
»». 9
.
»»9 :
WritableBytes
»»: G
)
»»G H
;
»»H I
return
¼¼ 
this
¼¼ 
;
¼¼ 
}
½½ 	
public
¿¿ 
virtual
¿¿ 
IByteBuffer
¿¿ "
GetBytes
¿¿# +
(
¿¿+ ,
int
¿¿, /
index
¿¿0 5
,
¿¿5 6
IByteBuffer
¿¿7 B
destination
¿¿C N
,
¿¿N O
int
¿¿P S
length
¿¿T Z
)
¿¿Z [
{
ÀÀ 	
this
ÁÁ 
.
ÁÁ 
GetBytes
ÁÁ 
(
ÁÁ 
index
ÁÁ 
,
ÁÁ  
destination
ÁÁ! ,
,
ÁÁ, -
destination
ÁÁ. 9
.
ÁÁ9 :
WriterIndex
ÁÁ: E
,
ÁÁE F
length
ÁÁG M
)
ÁÁM N
;
ÁÁN O
destination
ÂÂ 
.
ÂÂ 
SetWriterIndex
ÂÂ &
(
ÂÂ& '
destination
ÂÂ' 2
.
ÂÂ2 3
WriterIndex
ÂÂ3 >
+
ÂÂ? @
length
ÂÂA G
)
ÂÂG H
;
ÂÂH I
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
public
ÆÆ 
abstract
ÆÆ 
IByteBuffer
ÆÆ #
GetBytes
ÆÆ$ ,
(
ÆÆ, -
int
ÆÆ- 0
index
ÆÆ1 6
,
ÆÆ6 7
IByteBuffer
ÆÆ8 C
destination
ÆÆD O
,
ÆÆO P
int
ÆÆQ T
dstIndex
ÆÆU ]
,
ÆÆ] ^
int
ÆÆ_ b
length
ÆÆc i
)
ÆÆi j
;
ÆÆj k
public
ÈÈ 
abstract
ÈÈ 
IByteBuffer
ÈÈ #
GetBytes
ÈÈ$ ,
(
ÈÈ, -
int
ÈÈ- 0
index
ÈÈ1 6
,
ÈÈ6 7
Stream
ÈÈ8 >
destination
ÈÈ? J
,
ÈÈJ K
int
ÈÈL O
length
ÈÈP V
)
ÈÈV W
;
ÈÈW X
public
ÊÊ 
virtual
ÊÊ 
unsafe
ÊÊ 
string
ÊÊ $
	GetString
ÊÊ% .
(
ÊÊ. /
int
ÊÊ/ 2
index
ÊÊ3 8
,
ÊÊ8 9
int
ÊÊ: =
length
ÊÊ> D
,
ÊÊD E
Encoding
ÊÊF N
encoding
ÊÊO W
)
ÊÊW X
{
ËË 	
this
ÌÌ 
.
ÌÌ 
CheckIndex0
ÌÌ 
(
ÌÌ 
index
ÌÌ "
,
ÌÌ" #
length
ÌÌ$ *
)
ÌÌ* +
;
ÌÌ+ ,
if
ÍÍ 
(
ÍÍ 
length
ÍÍ 
==
ÍÍ 
$num
ÍÍ 
)
ÍÍ 
{
ÎÎ 
return
ÏÏ 
string
ÏÏ 
.
ÏÏ 
Empty
ÏÏ #
;
ÏÏ# $
}
ĞĞ 
if
ÒÒ 
(
ÒÒ 
this
ÒÒ 
.
ÒÒ 
HasMemoryAddress
ÒÒ %
)
ÒÒ% &
{
ÓÓ 
IntPtr
ÔÔ 
ptr
ÔÔ 
=
ÔÔ 
this
ÔÔ !
.
ÔÔ! "#
AddressOfPinnedMemory
ÔÔ" 7
(
ÔÔ7 8
)
ÔÔ8 9
;
ÔÔ9 :
if
ÕÕ 
(
ÕÕ 
ptr
ÕÕ 
!=
ÕÕ 
IntPtr
ÕÕ !
.
ÕÕ! "
Zero
ÕÕ" &
)
ÕÕ& '
{
ÖÖ 
return
×× "
UnsafeByteBufferUtil
×× /
.
××/ 0
	GetString
××0 9
(
××9 :
(
××: ;
byte
××; ?
*
××? @
)
××@ A
(
××A B
ptr
××B E
+
××F G
index
××H M
)
××M N
,
××N O
length
××P V
,
××V W
encoding
××X `
)
××` a
;
××a b
}
ØØ 
else
ÙÙ 
{
ÚÚ 
fixed
ÛÛ 
(
ÛÛ 
byte
ÛÛ 
*
ÛÛ  
p
ÛÛ! "
=
ÛÛ# $
&
ÛÛ% &
this
ÛÛ& *
.
ÛÛ* +&
GetPinnableMemoryAddress
ÛÛ+ C
(
ÛÛC D
)
ÛÛD E
)
ÛÛE F
return
ÜÜ "
UnsafeByteBufferUtil
ÜÜ 3
.
ÜÜ3 4
	GetString
ÜÜ4 =
(
ÜÜ= >
p
ÜÜ> ?
+
ÜÜ@ A
index
ÜÜB G
,
ÜÜG H
length
ÜÜI O
,
ÜÜO P
encoding
ÜÜQ Y
)
ÜÜY Z
;
ÜÜZ [
}
İİ 
}
ŞŞ 
if
ßß 
(
ßß 
this
ßß 
.
ßß 
HasArray
ßß 
)
ßß 
{
àà 
return
áá 
encoding
áá 
.
áá  
	GetString
áá  )
(
áá) *
this
áá* .
.
áá. /
Array
áá/ 4
,
áá4 5
this
áá6 :
.
áá: ;
ArrayOffset
áá; F
+
ááG H
index
ááI N
,
ááN O
length
ááP V
)
ááV W
;
ááW X
}
ââ 
return
ää 
this
ää 
.
ää 
ToString
ää  
(
ää  !
index
ää! &
,
ää& '
length
ää( .
,
ää. /
encoding
ää0 8
)
ää8 9
;
ää9 :
}
åå 	
public
çç 
virtual
çç 
string
çç 

ReadString
çç (
(
çç( )
int
çç) ,
length
çç- 3
,
çç3 4
Encoding
çç5 =
encoding
çç> F
)
ççF G
{
èè 	
string
éé 
value
éé 
=
éé 
this
éé 
.
éé  
	GetString
éé  )
(
éé) *
this
éé* .
.
éé. /
readerIndex
éé/ :
,
éé: ;
length
éé< B
,
ééB C
encoding
ééD L
)
ééL M
;
ééM N
this
êê 
.
êê 
readerIndex
êê 
+=
êê 
length
êê  &
;
êê& '
return
ëë 
value
ëë 
;
ëë 
}
ìì 	
public
îî 
virtual
îî 
unsafe
îî 
ICharSequence
îî +
GetCharSequence
îî, ;
(
îî; <
int
îî< ?
index
îî@ E
,
îîE F
int
îîG J
length
îîK Q
,
îîQ R
Encoding
îîS [
encoding
îî\ d
)
îîd e
{
ïï 	
this
ğğ 
.
ğğ 
CheckIndex0
ğğ 
(
ğğ 
index
ğğ "
,
ğğ" #
length
ğğ$ *
)
ğğ* +
;
ğğ+ ,
if
ññ 
(
ññ 
length
ññ 
==
ññ 
$num
ññ 
)
ññ 
{
òò 
return
óó  
StringCharSequence
óó )
.
óó) *
Empty
óó* /
;
óó/ 0
}
ôô 
if
öö 
(
öö 
this
öö 
.
öö 
HasMemoryAddress
öö %
)
öö% &
{
÷÷ 
IntPtr
øø 
ptr
øø 
=
øø 
this
øø !
.
øø! "#
AddressOfPinnedMemory
øø" 7
(
øø7 8
)
øø8 9
;
øø9 :
if
ùù 
(
ùù 
ptr
ùù 
!=
ùù 
IntPtr
ùù !
.
ùù! "
Zero
ùù" &
)
ùù& '
{
úú 
return
ûû 
new
ûû  
StringCharSequence
ûû 1
(
ûû1 2"
UnsafeByteBufferUtil
ûû2 F
.
ûûF G
	GetString
ûûG P
(
ûûP Q
(
ûûQ R
byte
ûûR V
*
ûûV W
)
ûûW X
(
ûûX Y
ptr
ûûY \
+
ûû] ^
index
ûû_ d
)
ûûd e
,
ûûe f
length
ûûg m
,
ûûm n
encoding
ûûo w
)
ûûw x
)
ûûx y
;
ûûy z
}
üü 
else
ıı 
{
şş 
fixed
ÿÿ 
(
ÿÿ 
byte
ÿÿ 
*
ÿÿ  
p
ÿÿ! "
=
ÿÿ# $
&
ÿÿ% &
this
ÿÿ& *
.
ÿÿ* +&
GetPinnableMemoryAddress
ÿÿ+ C
(
ÿÿC D
)
ÿÿD E
)
ÿÿE F
return
€€ 
new
€€ " 
StringCharSequence
€€# 5
(
€€5 6"
UnsafeByteBufferUtil
€€6 J
.
€€J K
	GetString
€€K T
(
€€T U
p
€€U V
+
€€W X
index
€€Y ^
,
€€^ _
length
€€` f
,
€€f g
encoding
€€h p
)
€€p q
)
€€q r
;
€€r s
}
 
}
‚‚ 
if
ƒƒ 
(
ƒƒ 
this
ƒƒ 
.
ƒƒ 
HasArray
ƒƒ 
)
ƒƒ 
{
„„ 
return
…… 
new
……  
StringCharSequence
…… -
(
……- .
encoding
……. 6
.
……6 7
	GetString
……7 @
(
……@ A
this
……A E
.
……E F
Array
……F K
,
……K L
this
……M Q
.
……Q R
ArrayOffset
……R ]
+
……^ _
index
……` e
,
……e f
length
……g m
)
……m n
)
……n o
;
……o p
}
†† 
return
ˆˆ 
new
ˆˆ  
StringCharSequence
ˆˆ )
(
ˆˆ) *
this
ˆˆ* .
.
ˆˆ. /
ToString
ˆˆ/ 7
(
ˆˆ7 8
index
ˆˆ8 =
,
ˆˆ= >
length
ˆˆ? E
,
ˆˆE F
encoding
ˆˆG O
)
ˆˆO P
)
ˆˆP Q
;
ˆˆQ R
}
‰‰ 	
public
‹‹ 
virtual
‹‹ 
ICharSequence
‹‹ $
ReadCharSequence
‹‹% 5
(
‹‹5 6
int
‹‹6 9
length
‹‹: @
,
‹‹@ A
Encoding
‹‹B J
encoding
‹‹K S
)
‹‹S T
{
ŒŒ 	
ICharSequence
 
sequence
 "
=
# $
this
% )
.
) *
GetCharSequence
* 9
(
9 :
this
: >
.
> ?
readerIndex
? J
,
J K
length
L R
,
R S
encoding
T \
)
\ ]
;
] ^
this
 
.
 
readerIndex
 
+=
 
length
  &
;
& '
return
 
sequence
 
;
 
}
 	
public
’’ 
virtual
’’ 
IByteBuffer
’’ "
SetByte
’’# *
(
’’* +
int
’’+ .
index
’’/ 4
,
’’4 5
int
’’6 9
value
’’: ?
)
’’? @
{
““ 	
this
”” 
.
”” 

CheckIndex
”” 
(
”” 
index
”” !
)
””! "
;
””" #
this
•• 
.
•• 
_SetByte
•• 
(
•• 
index
•• 
,
••  
value
••! &
)
••& '
;
••' (
return
–– 
this
–– 
;
–– 
}
—— 	
	protected
™™ 
internal
™™ 
abstract
™™ #
void
™™$ (
_SetByte
™™) 1
(
™™1 2
int
™™2 5
index
™™6 ;
,
™™; <
int
™™= @
value
™™A F
)
™™F G
;
™™G H
public
›› 
virtual
›› 
IByteBuffer
›› "

SetBoolean
››# -
(
››- .
int
››. 1
index
››2 7
,
››7 8
bool
››9 =
value
››> C
)
››C D
{
œœ 	
this
 
.
 
SetByte
 
(
 
index
 
,
 
value
  %
?
& '
$num
( )
:
* +
$num
, -
)
- .
;
. /
return
 
this
 
;
 
}
ŸŸ 	
public
¡¡ 
virtual
¡¡ 
IByteBuffer
¡¡ "
SetShort
¡¡# +
(
¡¡+ ,
int
¡¡, /
index
¡¡0 5
,
¡¡5 6
int
¡¡7 :
value
¡¡; @
)
¡¡@ A
{
¢¢ 	
this
££ 
.
££ 

CheckIndex
££ 
(
££ 
index
££ !
,
££! "
$num
££# $
)
££$ %
;
££% &
this
¤¤ 
.
¤¤ 
	_SetShort
¤¤ 
(
¤¤ 
index
¤¤  
,
¤¤  !
value
¤¤" '
)
¤¤' (
;
¤¤( )
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
¦¦ 	
	protected
¨¨ 
internal
¨¨ 
abstract
¨¨ #
void
¨¨$ (
	_SetShort
¨¨) 2
(
¨¨2 3
int
¨¨3 6
index
¨¨7 <
,
¨¨< =
int
¨¨> A
value
¨¨B G
)
¨¨G H
;
¨¨H I
public
ªª 
virtual
ªª 
IByteBuffer
ªª "

SetShortLE
ªª# -
(
ªª- .
int
ªª. 1
index
ªª2 7
,
ªª7 8
int
ªª9 <
value
ªª= B
)
ªªB C
{
«« 	
this
¬¬ 
.
¬¬ 

CheckIndex
¬¬ 
(
¬¬ 
index
¬¬ !
,
¬¬! "
$num
¬¬# $
)
¬¬$ %
;
¬¬% &
this
­­ 
.
­­ 
_SetShortLE
­­ 
(
­­ 
index
­­ "
,
­­" #
value
­­$ )
)
­­) *
;
­­* +
return
®® 
this
®® 
;
®® 
}
¯¯ 	
	protected
±± 
internal
±± 
abstract
±± #
void
±±$ (
_SetShortLE
±±) 4
(
±±4 5
int
±±5 8
index
±±9 >
,
±±> ?
int
±±@ C
value
±±D I
)
±±I J
;
±±J K
public
³³ 
IByteBuffer
³³ 
SetUnsignedShort
³³ +
(
³³+ ,
int
³³, /
index
³³0 5
,
³³5 6
ushort
³³7 =
value
³³> C
)
³³C D
{
´´ 	
	unchecked
µµ 
{
¶¶ 
return
·· 
this
·· 
.
·· 
SetShort
·· $
(
··$ %
index
··% *
,
··* +
(
··, -
short
··- 2
)
··2 3
value
··3 8
)
··8 9
;
··9 :
}
¸¸ 
}
¹¹ 	
public
»» 
IByteBuffer
»»  
SetUnsignedShortLE
»» -
(
»»- .
int
»». 1
index
»»2 7
,
»»7 8
ushort
»»9 ?
value
»»@ E
)
»»E F
{
¼¼ 	
	unchecked
½½ 
{
¾¾ 
return
¿¿ 
this
¿¿ 
.
¿¿ 

SetShortLE
¿¿ &
(
¿¿& '
index
¿¿' ,
,
¿¿, -
(
¿¿. /
short
¿¿/ 4
)
¿¿4 5
value
¿¿5 :
)
¿¿: ;
;
¿¿; <
}
ÀÀ 
}
ÁÁ 	
public
ÃÃ 
virtual
ÃÃ 
IByteBuffer
ÃÃ "
SetChar
ÃÃ# *
(
ÃÃ* +
int
ÃÃ+ .
index
ÃÃ/ 4
,
ÃÃ4 5
char
ÃÃ6 :
value
ÃÃ; @
)
ÃÃ@ A
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
SetShort
ÅÅ 
(
ÅÅ 
index
ÅÅ 
,
ÅÅ  
value
ÅÅ! &
)
ÅÅ& '
;
ÅÅ' (
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
virtual
ÉÉ 
IByteBuffer
ÉÉ "
	SetMedium
ÉÉ# ,
(
ÉÉ, -
int
ÉÉ- 0
index
ÉÉ1 6
,
ÉÉ6 7
int
ÉÉ8 ;
value
ÉÉ< A
)
ÉÉA B
{
ÊÊ 	
this
ËË 
.
ËË 

CheckIndex
ËË 
(
ËË 
index
ËË !
,
ËË! "
$num
ËË# $
)
ËË$ %
;
ËË% &
this
ÌÌ 
.
ÌÌ 

_SetMedium
ÌÌ 
(
ÌÌ 
index
ÌÌ !
,
ÌÌ! "
value
ÌÌ# (
)
ÌÌ( )
;
ÌÌ) *
return
ÍÍ 
this
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
	protected
ĞĞ 
internal
ĞĞ 
abstract
ĞĞ #
void
ĞĞ$ (

_SetMedium
ĞĞ) 3
(
ĞĞ3 4
int
ĞĞ4 7
index
ĞĞ8 =
,
ĞĞ= >
int
ĞĞ? B
value
ĞĞC H
)
ĞĞH I
;
ĞĞI J
public
ÒÒ 
virtual
ÒÒ 
IByteBuffer
ÒÒ "
SetMediumLE
ÒÒ# .
(
ÒÒ. /
int
ÒÒ/ 2
index
ÒÒ3 8
,
ÒÒ8 9
int
ÒÒ: =
value
ÒÒ> C
)
ÒÒC D
{
ÓÓ 	
this
ÔÔ 
.
ÔÔ 

CheckIndex
ÔÔ 
(
ÔÔ 
index
ÔÔ !
,
ÔÔ! "
$num
ÔÔ# $
)
ÔÔ$ %
;
ÔÔ% &
this
ÕÕ 
.
ÕÕ 
_SetMediumLE
ÕÕ 
(
ÕÕ 
index
ÕÕ #
,
ÕÕ# $
value
ÕÕ% *
)
ÕÕ* +
;
ÕÕ+ ,
return
ÖÖ 
this
ÖÖ 
;
ÖÖ 
}
×× 	
	protected
ÙÙ 
internal
ÙÙ 
abstract
ÙÙ #
void
ÙÙ$ (
_SetMediumLE
ÙÙ) 5
(
ÙÙ5 6
int
ÙÙ6 9
index
ÙÙ: ?
,
ÙÙ? @
int
ÙÙA D
value
ÙÙE J
)
ÙÙJ K
;
ÙÙK L
public
ÛÛ 
virtual
ÛÛ 
IByteBuffer
ÛÛ "
SetInt
ÛÛ# )
(
ÛÛ) *
int
ÛÛ* -
index
ÛÛ. 3
,
ÛÛ3 4
int
ÛÛ5 8
value
ÛÛ9 >
)
ÛÛ> ?
{
ÜÜ 	
this
İİ 
.
İİ 

CheckIndex
İİ 
(
İİ 
index
İİ !
,
İİ! "
$num
İİ# $
)
İİ$ %
;
İİ% &
this
ŞŞ 
.
ŞŞ 
_SetInt
ŞŞ 
(
ŞŞ 
index
ŞŞ 
,
ŞŞ 
value
ŞŞ  %
)
ŞŞ% &
;
ŞŞ& '
return
ßß 
this
ßß 
;
ßß 
}
àà 	
public
ââ 
IByteBuffer
ââ 
SetUnsignedInt
ââ )
(
ââ) *
int
ââ* -
index
ââ. 3
,
ââ3 4
uint
ââ5 9
value
ââ: ?
)
ââ? @
{
ãã 	
	unchecked
ää 
{
åå 
return
ææ 
this
ææ 
.
ææ 
SetInt
ææ "
(
ææ" #
index
ææ# (
,
ææ( )
(
ææ* +
int
ææ+ .
)
ææ. /
value
ææ/ 4
)
ææ4 5
;
ææ5 6
}
çç 
}
èè 	
public
êê 
IByteBuffer
êê 
SetUnsignedIntLE
êê +
(
êê+ ,
int
êê, /
index
êê0 5
,
êê5 6
uint
êê7 ;
value
êê< A
)
êêA B
{
ëë 	
	unchecked
ìì 
{
íí 
return
îî 
this
îî 
.
îî 
SetIntLE
îî $
(
îî$ %
index
îî% *
,
îî* +
(
îî, -
int
îî- 0
)
îî0 1
value
îî1 6
)
îî6 7
;
îî7 8
}
ïï 
}
ğğ 	
	protected
òò 
internal
òò 
abstract
òò #
void
òò$ (
_SetInt
òò) 0
(
òò0 1
int
òò1 4
index
òò5 :
,
òò: ;
int
òò< ?
value
òò@ E
)
òòE F
;
òòF G
public
ôô 
virtual
ôô 
IByteBuffer
ôô "
SetIntLE
ôô# +
(
ôô+ ,
int
ôô, /
index
ôô0 5
,
ôô5 6
int
ôô7 :
value
ôô; @
)
ôô@ A
{
õõ 	
this
öö 
.
öö 

CheckIndex
öö 
(
öö 
index
öö !
,
öö! "
$num
öö# $
)
öö$ %
;
öö% &
this
÷÷ 
.
÷÷ 
	_SetIntLE
÷÷ 
(
÷÷ 
index
÷÷  
,
÷÷  !
value
÷÷" '
)
÷÷' (
;
÷÷( )
return
øø 
this
øø 
;
øø 
}
ùù 	
	protected
ûû 
internal
ûû 
abstract
ûû #
void
ûû$ (
	_SetIntLE
ûû) 2
(
ûû2 3
int
ûû3 6
index
ûû7 <
,
ûû< =
int
ûû> A
value
ûûB G
)
ûûG H
;
ûûH I
public
ıı 
virtual
ıı 
IByteBuffer
ıı "
SetFloat
ıı# +
(
ıı+ ,
int
ıı, /
index
ıı0 5
,
ıı5 6
float
ıı7 <
value
ıı= B
)
ııB C
{
şş 	
this
ÿÿ 
.
ÿÿ 
SetInt
ÿÿ 
(
ÿÿ 
index
ÿÿ 
,
ÿÿ 
ByteBufferUtil
ÿÿ -
.
ÿÿ- .
SingleToInt32Bits
ÿÿ. ?
(
ÿÿ? @
value
ÿÿ@ E
)
ÿÿE F
)
ÿÿF G
;
ÿÿG H
return
€€ 
this
€€ 
;
€€ 
}
 	
public
ƒƒ 
IByteBuffer
ƒƒ 

SetFloatLE
ƒƒ %
(
ƒƒ% &
int
ƒƒ& )
index
ƒƒ* /
,
ƒƒ/ 0
float
ƒƒ1 6
value
ƒƒ7 <
)
ƒƒ< =
=>
ƒƒ> @
this
ƒƒA E
.
ƒƒE F
SetIntLE
ƒƒF N
(
ƒƒN O
index
ƒƒO T
,
ƒƒT U
ByteBufferUtil
ƒƒV d
.
ƒƒd e
SingleToInt32Bits
ƒƒe v
(
ƒƒv w
value
ƒƒw |
)
ƒƒ| }
)
ƒƒ} ~
;
ƒƒ~ 
public
…… 
virtual
…… 
IByteBuffer
…… "
SetLong
……# *
(
……* +
int
……+ .
index
……/ 4
,
……4 5
long
……6 :
value
……; @
)
……@ A
{
†† 	
this
‡‡ 
.
‡‡ 

CheckIndex
‡‡ 
(
‡‡ 
index
‡‡ !
,
‡‡! "
$num
‡‡# $
)
‡‡$ %
;
‡‡% &
this
ˆˆ 
.
ˆˆ 
_SetLong
ˆˆ 
(
ˆˆ 
index
ˆˆ 
,
ˆˆ  
value
ˆˆ! &
)
ˆˆ& '
;
ˆˆ' (
return
‰‰ 
this
‰‰ 
;
‰‰ 
}
ŠŠ 	
	protected
ŒŒ 
internal
ŒŒ 
abstract
ŒŒ #
void
ŒŒ$ (
_SetLong
ŒŒ) 1
(
ŒŒ1 2
int
ŒŒ2 5
index
ŒŒ6 ;
,
ŒŒ; <
long
ŒŒ= A
value
ŒŒB G
)
ŒŒG H
;
ŒŒH I
public
 
virtual
 
IByteBuffer
 "
	SetLongLE
# ,
(
, -
int
- 0
index
1 6
,
6 7
long
8 <
value
= B
)
B C
{
 	
this
 
.
 

CheckIndex
 
(
 
index
 !
,
! "
$num
# $
)
$ %
;
% &
this
‘‘ 
.
‘‘ 

_SetLongLE
‘‘ 
(
‘‘ 
index
‘‘ !
,
‘‘! "
value
‘‘# (
)
‘‘( )
;
‘‘) *
return
’’ 
this
’’ 
;
’’ 
}
““ 	
	protected
•• 
internal
•• 
abstract
•• #
void
••$ (

_SetLongLE
••) 3
(
••3 4
int
••4 7
index
••8 =
,
••= >
long
••? C
value
••D I
)
••I J
;
••J K
public
—— 
virtual
—— 
IByteBuffer
—— "
	SetDouble
——# ,
(
——, -
int
——- 0
index
——1 6
,
——6 7
double
——8 >
value
——? D
)
——D E
{
˜˜ 	
this
™™ 
.
™™ 
SetLong
™™ 
(
™™ 
index
™™ 
,
™™ 
BitConverter
™™  ,
.
™™, -
DoubleToInt64Bits
™™- >
(
™™> ?
value
™™? D
)
™™D E
)
™™E F
;
™™F G
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
IByteBuffer
 
SetDoubleLE
 &
(
& '
int
' *
index
+ 0
,
0 1
double
2 8
value
9 >
)
> ?
=>
@ B
this
C G
.
G H
	SetLongLE
H Q
(
Q R
index
R W
,
W X
BitConverter
Y e
.
e f
DoubleToInt64Bits
f w
(
w x
value
x }
)
} ~
)
~ 
; €
public
ŸŸ 
virtual
ŸŸ 
IByteBuffer
ŸŸ "
SetBytes
ŸŸ# +
(
ŸŸ+ ,
int
ŸŸ, /
index
ŸŸ0 5
,
ŸŸ5 6
byte
ŸŸ7 ;
[
ŸŸ; <
]
ŸŸ< =
src
ŸŸ> A
)
ŸŸA B
{
   	
this
¡¡ 
.
¡¡ 
SetBytes
¡¡ 
(
¡¡ 
index
¡¡ 
,
¡¡  
src
¡¡! $
,
¡¡$ %
$num
¡¡& '
,
¡¡' (
src
¡¡) ,
.
¡¡, -
Length
¡¡- 3
)
¡¡3 4
;
¡¡4 5
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
¥¥ 
abstract
¥¥ 
IByteBuffer
¥¥ #
SetBytes
¥¥$ ,
(
¥¥, -
int
¥¥- 0
index
¥¥1 6
,
¥¥6 7
byte
¥¥8 <
[
¥¥< =
]
¥¥= >
src
¥¥? B
,
¥¥B C
int
¥¥D G
srcIndex
¥¥H P
,
¥¥P Q
int
¥¥R U
length
¥¥V \
)
¥¥\ ]
;
¥¥] ^
public
§§ 
virtual
§§ 
IByteBuffer
§§ "
SetBytes
§§# +
(
§§+ ,
int
§§, /
index
§§0 5
,
§§5 6
IByteBuffer
§§7 B
src
§§C F
)
§§F G
{
¨¨ 	
this
©© 
.
©© 
SetBytes
©© 
(
©© 
index
©© 
,
©©  
src
©©! $
,
©©$ %
src
©©& )
.
©©) *
ReadableBytes
©©* 7
)
©©7 8
;
©©8 9
return
ªª 
this
ªª 
;
ªª 
}
«« 	
public
­­ 
virtual
­­ 
IByteBuffer
­­ "
SetBytes
­­# +
(
­­+ ,
int
­­, /
index
­­0 5
,
­­5 6
IByteBuffer
­­7 B
src
­­C F
,
­­F G
int
­­H K
length
­­L R
)
­­R S
{
®® 	
Contract
¯¯ 
.
¯¯ 
Requires
¯¯ 
(
¯¯ 
src
¯¯ !
!=
¯¯" $
null
¯¯% )
)
¯¯) *
;
¯¯* +
this
±± 
.
±± 

CheckIndex
±± 
(
±± 
index
±± !
,
±±! "
length
±±# )
)
±±) *
;
±±* +
if
²² 
(
²² 
length
²² 
>
²² 
src
²² 
.
²² 
ReadableBytes
²² *
)
²²* +
{
³³ 
ThrowHelper
´´ 
.
´´ 9
+ThrowIndexOutOfRangeException_ReadableBytes
´´ G
(
´´G H
length
´´H N
,
´´N O
src
´´P S
)
´´S T
;
´´T U
}
µµ 
this
¶¶ 
.
¶¶ 
SetBytes
¶¶ 
(
¶¶ 
index
¶¶ 
,
¶¶  
src
¶¶! $
,
¶¶$ %
src
¶¶& )
.
¶¶) *
ReaderIndex
¶¶* 5
,
¶¶5 6
length
¶¶7 =
)
¶¶= >
;
¶¶> ?
src
·· 
.
·· 
SetReaderIndex
·· 
(
·· 
src
·· "
.
··" #
ReaderIndex
··# .
+
··/ 0
length
··1 7
)
··7 8
;
··8 9
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
public
»» 
abstract
»» 
IByteBuffer
»» #
SetBytes
»»$ ,
(
»», -
int
»»- 0
index
»»1 6
,
»»6 7
IByteBuffer
»»8 C
src
»»D G
,
»»G H
int
»»I L
srcIndex
»»M U
,
»»U V
int
»»W Z
length
»»[ a
)
»»a b
;
»»b c
public
½½ 
abstract
½½ 
Task
½½ 
<
½½ 
int
½½  
>
½½  !
SetBytesAsync
½½" /
(
½½/ 0
int
½½0 3
index
½½4 9
,
½½9 :
Stream
½½; A
src
½½B E
,
½½E F
int
½½G J
length
½½K Q
,
½½Q R
CancellationToken
½½S d
cancellationToken
½½e v
)
½½v w
;
½½w x
public
¿¿ 
virtual
¿¿ 
IByteBuffer
¿¿ "
SetZero
¿¿# *
(
¿¿* +
int
¿¿+ .
index
¿¿/ 4
,
¿¿4 5
int
¿¿6 9
length
¿¿: @
)
¿¿@ A
{
ÀÀ 	
if
ÁÁ 
(
ÁÁ 
length
ÁÁ 
==
ÁÁ 
$num
ÁÁ 
)
ÁÁ 
{
ÂÂ 
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÄÄ 
this
ÆÆ 
.
ÆÆ 

CheckIndex
ÆÆ 
(
ÆÆ 
index
ÆÆ !
,
ÆÆ! "
length
ÆÆ# )
)
ÆÆ) *
;
ÆÆ* +
int
ÈÈ 
nLong
ÈÈ 
=
ÈÈ 
length
ÈÈ 
.
ÈÈ 
RightUShift
ÈÈ *
(
ÈÈ* +
$num
ÈÈ+ ,
)
ÈÈ, -
;
ÈÈ- .
int
ÉÉ 
nBytes
ÉÉ 
=
ÉÉ 
length
ÉÉ 
&
ÉÉ  !
$num
ÉÉ" #
;
ÉÉ# $
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
nLong
ÊÊ 
;
ÊÊ 
i
ÊÊ  !
>
ÊÊ" #
$num
ÊÊ$ %
;
ÊÊ% &
i
ÊÊ' (
--
ÊÊ( *
)
ÊÊ* +
{
ËË 
this
ÌÌ 
.
ÌÌ 
_SetLong
ÌÌ 
(
ÌÌ 
index
ÌÌ #
,
ÌÌ# $
$num
ÌÌ% &
)
ÌÌ& '
;
ÌÌ' (
index
ÍÍ 
+=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
}
ÎÎ 
if
ÏÏ 
(
ÏÏ 
nBytes
ÏÏ 
==
ÏÏ 
$num
ÏÏ 
)
ÏÏ 
{
ĞĞ 
this
ÑÑ 
.
ÑÑ 
_SetInt
ÑÑ 
(
ÑÑ 
index
ÑÑ "
,
ÑÑ" #
$num
ÑÑ$ %
)
ÑÑ% &
;
ÑÑ& '
}
ÓÓ 
else
ÔÔ 
if
ÔÔ 
(
ÔÔ 
nBytes
ÔÔ 
<
ÔÔ 
$num
ÔÔ 
)
ÔÔ  
{
ÕÕ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
nBytes
ÖÖ #
;
ÖÖ# $
i
ÖÖ% &
>
ÖÖ' (
$num
ÖÖ) *
;
ÖÖ* +
i
ÖÖ, -
--
ÖÖ- /
)
ÖÖ/ 0
{
×× 
this
ØØ 
.
ØØ 
_SetByte
ØØ !
(
ØØ! "
index
ØØ" '
,
ØØ' (
$num
ØØ) *
)
ØØ* +
;
ØØ+ ,
index
ÙÙ 
++
ÙÙ 
;
ÙÙ 
}
ÚÚ 
}
ÛÛ 
else
ÜÜ 
{
İİ 
this
ŞŞ 
.
ŞŞ 
_SetInt
ŞŞ 
(
ŞŞ 
index
ŞŞ "
,
ŞŞ" #
$num
ŞŞ$ %
)
ŞŞ% &
;
ŞŞ& '
index
ßß 
+=
ßß 
$num
ßß 
;
ßß 
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
nBytes
àà #
-
àà$ %
$num
àà& '
;
àà' (
i
àà) *
>
àà+ ,
$num
àà- .
;
àà. /
i
àà0 1
--
àà1 3
)
àà3 4
{
áá 
this
ââ 
.
ââ 
_SetByte
ââ !
(
ââ! "
index
ââ" '
,
ââ' (
$num
ââ) *
)
ââ* +
;
ââ+ ,
index
ãã 
++
ãã 
;
ãã 
}
ää 
}
åå 
return
çç 
this
çç 
;
çç 
}
èè 	
public
êê 
virtual
êê 
int
êê 
	SetString
êê $
(
êê$ %
int
êê% (
index
êê) .
,
êê. /
string
êê0 6
value
êê7 <
,
êê< =
Encoding
êê> F
encoding
êêG O
)
êêO P
=>
êêQ S
this
êêT X
.
êêX Y

SetString0
êêY c
(
êêc d
index
êêd i
,
êêi j
value
êêk p
,
êêp q
encoding
êêr z
,
êêz {
falseêê| 
)êê ‚
;êê‚ ƒ
int
ìì 

SetString0
ìì 
(
ìì 
int
ìì 
index
ìì  
,
ìì  !
string
ìì" (
value
ìì) .
,
ìì. /
Encoding
ìì0 8
encoding
ìì9 A
,
ììA B
bool
ììC G
expand
ììH N
)
ììN O
{
íí 	
if
îî 
(
îî 
ReferenceEquals
îî 
(
îî  
encoding
îî  (
,
îî( )
Encoding
îî* 2
.
îî2 3
UTF8
îî3 7
)
îî7 8
)
îî8 9
{
ïï 
int
ğğ 
length
ğğ 
=
ğğ 
ByteBufferUtil
ğğ +
.
ğğ+ ,
Utf8MaxBytes
ğğ, 8
(
ğğ8 9
value
ğğ9 >
)
ğğ> ?
;
ğğ? @
if
ññ 
(
ññ 
expand
ññ 
)
ññ 
{
òò 
this
óó 
.
óó 
EnsureWritable0
óó (
(
óó( )
length
óó) /
)
óó/ 0
;
óó0 1
this
ôô 
.
ôô 
CheckIndex0
ôô $
(
ôô$ %
index
ôô% *
,
ôô* +
length
ôô, 2
)
ôô2 3
;
ôô3 4
}
õõ 
else
öö 
{
÷÷ 
this
øø 
.
øø 

CheckIndex
øø #
(
øø# $
index
øø$ )
,
øø) *
length
øø+ 1
)
øø1 2
;
øø2 3
}
ùù 
return
úú 
ByteBufferUtil
úú %
.
úú% &
	WriteUtf8
úú& /
(
úú/ 0
this
úú0 4
,
úú4 5
index
úú6 ;
,
úú; <
value
úú= B
,
úúB C
value
úúD I
.
úúI J
Length
úúJ P
)
úúP Q
;
úúQ R
}
ûû 
if
üü 
(
üü 
ReferenceEquals
üü 
(
üü  
encoding
üü  (
,
üü( )
Encoding
üü* 2
.
üü2 3
ASCII
üü3 8
)
üü8 9
)
üü9 :
{
ıı 
int
şş 
length
şş 
=
şş 
value
şş "
.
şş" #
Length
şş# )
;
şş) *
if
ÿÿ 
(
ÿÿ 
expand
ÿÿ 
)
ÿÿ 
{
€€ 
this
 
.
 
EnsureWritable0
 (
(
( )
length
) /
)
/ 0
;
0 1
this
‚‚ 
.
‚‚ 
CheckIndex0
‚‚ $
(
‚‚$ %
index
‚‚% *
,
‚‚* +
length
‚‚, 2
)
‚‚2 3
;
‚‚3 4
}
ƒƒ 
else
„„ 
{
…… 
this
†† 
.
†† 

CheckIndex
†† #
(
††# $
index
††$ )
,
††) *
length
††+ 1
)
††1 2
;
††2 3
}
‡‡ 
return
ˆˆ 
ByteBufferUtil
ˆˆ %
.
ˆˆ% &

WriteAscii
ˆˆ& 0
(
ˆˆ0 1
this
ˆˆ1 5
,
ˆˆ5 6
index
ˆˆ7 <
,
ˆˆ< =
value
ˆˆ> C
,
ˆˆC D
length
ˆˆE K
)
ˆˆK L
;
ˆˆL M
}
‰‰ 
byte
ŠŠ 
[
ŠŠ 
]
ŠŠ 
bytes
ŠŠ 
=
ŠŠ 
encoding
ŠŠ #
.
ŠŠ# $
GetBytes
ŠŠ$ ,
(
ŠŠ, -
value
ŠŠ- 2
)
ŠŠ2 3
;
ŠŠ3 4
if
‹‹ 
(
‹‹ 
expand
‹‹ 
)
‹‹ 
{
ŒŒ 
this
 
.
 
EnsureWritable0
 $
(
$ %
bytes
% *
.
* +
Length
+ 1
)
1 2
;
2 3
}
 
this
 
.
 
SetBytes
 
(
 
index
 
,
  
bytes
! &
)
& '
;
' (
return
‘‘ 
bytes
‘‘ 
.
‘‘ 
Length
‘‘ 
;
‘‘  
}
’’ 	
public
”” 
virtual
”” 
int
”” 
SetCharSequence
”” *
(
””* +
int
””+ .
index
””/ 4
,
””4 5
ICharSequence
””6 C
sequence
””D L
,
””L M
Encoding
””N V
encoding
””W _
)
””_ `
=>
””a c
this
””d h
.
””h i
SetCharSequence0
””i y
(
””y z
index
””z 
,”” €
sequence”” ‰
,””‰ Š
encoding””‹ “
,””“ ”
false””• š
)””š ›
;””› œ
int
–– 
SetCharSequence0
–– 
(
–– 
int
––  
index
––! &
,
––& '
ICharSequence
––( 5
sequence
––6 >
,
––> ?
Encoding
––@ H
encoding
––I Q
,
––Q R
bool
––S W
expand
––X ^
)
––^ _
{
—— 	
if
˜˜ 
(
˜˜ 
ReferenceEquals
˜˜ 
(
˜˜  
encoding
˜˜  (
,
˜˜( )
Encoding
˜˜* 2
.
˜˜2 3
UTF8
˜˜3 7
)
˜˜7 8
)
˜˜8 9
{
™™ 
int
šš 
length
šš 
=
šš 
ByteBufferUtil
šš +
.
šš+ ,
Utf8MaxBytes
šš, 8
(
šš8 9
sequence
šš9 A
)
ššA B
;
ššB C
if
›› 
(
›› 
expand
›› 
)
›› 
{
œœ 
this
 
.
 
EnsureWritable0
 (
(
( )
length
) /
)
/ 0
;
0 1
this
 
.
 
CheckIndex0
 $
(
$ %
index
% *
,
* +
length
, 2
)
2 3
;
3 4
}
ŸŸ 
else
   
{
¡¡ 
this
¢¢ 
.
¢¢ 

CheckIndex
¢¢ #
(
¢¢# $
index
¢¢$ )
,
¢¢) *
length
¢¢+ 1
)
¢¢1 2
;
¢¢2 3
}
££ 
return
¤¤ 
ByteBufferUtil
¤¤ %
.
¤¤% &
	WriteUtf8
¤¤& /
(
¤¤/ 0
this
¤¤0 4
,
¤¤4 5
index
¤¤6 ;
,
¤¤; <
sequence
¤¤= E
,
¤¤E F
sequence
¤¤G O
.
¤¤O P
Count
¤¤P U
)
¤¤U V
;
¤¤V W
}
¥¥ 
if
¦¦ 
(
¦¦ 
ReferenceEquals
¦¦ 
(
¦¦  
encoding
¦¦  (
,
¦¦( )
Encoding
¦¦* 2
.
¦¦2 3
ASCII
¦¦3 8
)
¦¦8 9
)
¦¦9 :
{
§§ 
int
¨¨ 
length
¨¨ 
=
¨¨ 
sequence
¨¨ %
.
¨¨% &
Count
¨¨& +
;
¨¨+ ,
if
©© 
(
©© 
expand
©© 
)
©© 
{
ªª 
this
«« 
.
«« 
EnsureWritable0
«« (
(
««( )
length
««) /
)
««/ 0
;
««0 1
this
¬¬ 
.
¬¬ 
CheckIndex0
¬¬ $
(
¬¬$ %
index
¬¬% *
,
¬¬* +
length
¬¬, 2
)
¬¬2 3
;
¬¬3 4
}
­­ 
else
®® 
{
¯¯ 
this
°° 
.
°° 

CheckIndex
°° #
(
°°# $
index
°°$ )
,
°°) *
length
°°+ 1
)
°°1 2
;
°°2 3
}
±± 
return
²² 
ByteBufferUtil
²² %
.
²²% &

WriteAscii
²²& 0
(
²²0 1
this
²²1 5
,
²²5 6
index
²²7 <
,
²²< =
sequence
²²> F
,
²²F G
length
²²H N
)
²²N O
;
²²O P
}
³³ 
byte
´´ 
[
´´ 
]
´´ 
bytes
´´ 
=
´´ 
encoding
´´ #
.
´´# $
GetBytes
´´$ ,
(
´´, -
sequence
´´- 5
.
´´5 6
ToString
´´6 >
(
´´> ?
)
´´? @
)
´´@ A
;
´´A B
if
µµ 
(
µµ 
expand
µµ 
)
µµ 
{
¶¶ 
this
·· 
.
·· 
EnsureWritable0
·· $
(
··$ %
bytes
··% *
.
··* +
Length
··+ 1
)
··1 2
;
··2 3
}
¹¹ 
this
ºº 
.
ºº 
SetBytes
ºº 
(
ºº 
index
ºº 
,
ºº  
bytes
ºº! &
)
ºº& '
;
ºº' (
return
»» 
bytes
»» 
.
»» 
Length
»» 
;
»»  
}
¼¼ 	
public
¾¾ 
virtual
¾¾ 
byte
¾¾ 
ReadByte
¾¾ $
(
¾¾$ %
)
¾¾% &
{
¿¿ 	
this
ÀÀ 
.
ÀÀ !
CheckReadableBytes0
ÀÀ $
(
ÀÀ$ %
$num
ÀÀ% &
)
ÀÀ& '
;
ÀÀ' (
int
ÁÁ 
i
ÁÁ 
=
ÁÁ 
this
ÁÁ 
.
ÁÁ 
readerIndex
ÁÁ $
;
ÁÁ$ %
byte
ÂÂ 
b
ÂÂ 
=
ÂÂ 
this
ÂÂ 
.
ÂÂ 
_GetByte
ÂÂ "
(
ÂÂ" #
i
ÂÂ# $
)
ÂÂ$ %
;
ÂÂ% &
this
ÃÃ 
.
ÃÃ 
readerIndex
ÃÃ 
=
ÃÃ 
i
ÃÃ  
+
ÃÃ! "
$num
ÃÃ# $
;
ÃÃ$ %
return
ÄÄ 
b
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÇÇ 
bool
ÇÇ 
ReadBoolean
ÇÇ 
(
ÇÇ  
)
ÇÇ  !
=>
ÇÇ" $
this
ÇÇ% )
.
ÇÇ) *
ReadByte
ÇÇ* 2
(
ÇÇ2 3
)
ÇÇ3 4
!=
ÇÇ5 7
$num
ÇÇ8 9
;
ÇÇ9 :
public
ÉÉ 
virtual
ÉÉ 
short
ÉÉ 
	ReadShort
ÉÉ &
(
ÉÉ& '
)
ÉÉ' (
{
ÊÊ 	
this
ËË 
.
ËË !
CheckReadableBytes0
ËË $
(
ËË$ %
$num
ËË% &
)
ËË& '
;
ËË' (
short
ÌÌ 
v
ÌÌ 
=
ÌÌ 
this
ÌÌ 
.
ÌÌ 
	_GetShort
ÌÌ $
(
ÌÌ$ %
this
ÌÌ% )
.
ÌÌ) *
readerIndex
ÌÌ* 5
)
ÌÌ5 6
;
ÌÌ6 7
this
ÍÍ 
.
ÍÍ 
readerIndex
ÍÍ 
+=
ÍÍ 
$num
ÍÍ  !
;
ÍÍ! "
return
ÎÎ 
v
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
virtual
ÑÑ 
short
ÑÑ 
ReadShortLE
ÑÑ (
(
ÑÑ( )
)
ÑÑ) *
{
ÒÒ 	
this
ÓÓ 
.
ÓÓ !
CheckReadableBytes0
ÓÓ $
(
ÓÓ$ %
$num
ÓÓ% &
)
ÓÓ& '
;
ÓÓ' (
short
ÔÔ 
v
ÔÔ 
=
ÔÔ 
this
ÔÔ 
.
ÔÔ 
_GetShortLE
ÔÔ &
(
ÔÔ& '
this
ÔÔ' +
.
ÔÔ+ ,
readerIndex
ÔÔ, 7
)
ÔÔ7 8
;
ÔÔ8 9
this
ÕÕ 
.
ÕÕ 
readerIndex
ÕÕ 
+=
ÕÕ 
$num
ÕÕ  !
;
ÕÕ! "
return
ÖÖ 
v
ÖÖ 
;
ÖÖ 
}
×× 	
public
ÙÙ 
ushort
ÙÙ 
ReadUnsignedShort
ÙÙ '
(
ÙÙ' (
)
ÙÙ( )
{
ÚÚ 	
	unchecked
ÛÛ 
{
ÜÜ 
return
İİ 
(
İİ 
ushort
İİ 
)
İİ 
(
İİ  
this
İİ  $
.
İİ$ %
	ReadShort
İİ% .
(
İİ. /
)
İİ/ 0
)
İİ0 1
;
İİ1 2
}
ŞŞ 
}
ßß 	
public
áá 
ushort
áá !
ReadUnsignedShortLE
áá )
(
áá) *
)
áá* +
{
ââ 	
	unchecked
ãã 
{
ää 
return
åå 
(
åå 
ushort
åå 
)
åå 
this
åå #
.
åå# $
ReadShortLE
åå$ /
(
åå/ 0
)
åå0 1
;
åå1 2
}
ææ 
}
çç 	
public
éé 
int
éé 

ReadMedium
éé 
(
éé 
)
éé 
{
êê 	
uint
ëë 
value
ëë 
=
ëë 
(
ëë 
uint
ëë 
)
ëë 
this
ëë #
.
ëë# $ 
ReadUnsignedMedium
ëë$ 6
(
ëë6 7
)
ëë7 8
;
ëë8 9
if
ìì 
(
ìì 
(
ìì 
value
ìì 
&
ìì 
$num
ìì !
)
ìì! "
!=
ìì# %
$num
ìì& '
)
ìì' (
{
íí 
value
îî 
|=
îî 
$num
îî #
;
îî# $
}
ïï 
return
ññ 
(
ññ 
int
ññ 
)
ññ 
value
ññ 
;
ññ 
}
òò 	
public
ôô 
int
ôô 
ReadMediumLE
ôô 
(
ôô  
)
ôô  !
{
õõ 	
uint
öö 
value
öö 
=
öö 
(
öö 
uint
öö 
)
öö 
this
öö #
.
öö# $"
ReadUnsignedMediumLE
öö$ 8
(
öö8 9
)
öö9 :
;
öö: ;
if
÷÷ 
(
÷÷ 
(
÷÷ 
value
÷÷ 
&
÷÷ 
$num
÷÷ !
)
÷÷! "
!=
÷÷# %
$num
÷÷& '
)
÷÷' (
{
øø 
value
ùù 
|=
ùù 
$num
ùù #
;
ùù# $
}
úú 
return
üü 
(
üü 
int
üü 
)
üü 
value
üü 
;
üü 
}
ıı 	
public
ÿÿ 
virtual
ÿÿ 
int
ÿÿ  
ReadUnsignedMedium
ÿÿ -
(
ÿÿ- .
)
ÿÿ. /
{
€€ 	
this
 
.
 !
CheckReadableBytes0
 $
(
$ %
$num
% &
)
& '
;
' (
int
‚‚ 
v
‚‚ 
=
‚‚ 
this
‚‚ 
.
‚‚  
_GetUnsignedMedium
‚‚ +
(
‚‚+ ,
this
‚‚, 0
.
‚‚0 1
readerIndex
‚‚1 <
)
‚‚< =
;
‚‚= >
this
ƒƒ 
.
ƒƒ 
readerIndex
ƒƒ 
+=
ƒƒ 
$num
ƒƒ  !
;
ƒƒ! "
return
„„ 
v
„„ 
;
„„ 
}
…… 	
public
‡‡ 
virtual
‡‡ 
int
‡‡ "
ReadUnsignedMediumLE
‡‡ /
(
‡‡/ 0
)
‡‡0 1
{
ˆˆ 	
this
‰‰ 
.
‰‰ !
CheckReadableBytes0
‰‰ $
(
‰‰$ %
$num
‰‰% &
)
‰‰& '
;
‰‰' (
int
ŠŠ 
v
ŠŠ 
=
ŠŠ 
this
ŠŠ 
.
ŠŠ "
_GetUnsignedMediumLE
ŠŠ -
(
ŠŠ- .
this
ŠŠ. 2
.
ŠŠ2 3
readerIndex
ŠŠ3 >
)
ŠŠ> ?
;
ŠŠ? @
this
‹‹ 
.
‹‹ 
readerIndex
‹‹ 
+=
‹‹ 
$num
‹‹  !
;
‹‹! "
return
ŒŒ 
v
ŒŒ 
;
ŒŒ 
}
 	
public
 
virtual
 
int
 
ReadInt
 "
(
" #
)
# $
{
 	
this
‘‘ 
.
‘‘ !
CheckReadableBytes0
‘‘ $
(
‘‘$ %
$num
‘‘% &
)
‘‘& '
;
‘‘' (
int
’’ 
v
’’ 
=
’’ 
this
’’ 
.
’’ 
_GetInt
’’  
(
’’  !
this
’’! %
.
’’% &
readerIndex
’’& 1
)
’’1 2
;
’’2 3
this
““ 
.
““ 
readerIndex
““ 
+=
““ 
$num
““  !
;
““! "
return
”” 
v
”” 
;
”” 
}
•• 	
public
—— 
virtual
—— 
int
—— 
	ReadIntLE
—— $
(
——$ %
)
——% &
{
˜˜ 	
this
™™ 
.
™™ !
CheckReadableBytes0
™™ $
(
™™$ %
$num
™™% &
)
™™& '
;
™™' (
int
šš 
v
šš 
=
šš 
this
šš 
.
šš 
	_GetIntLE
šš "
(
šš" #
this
šš# '
.
šš' (
readerIndex
šš( 3
)
šš3 4
;
šš4 5
this
›› 
.
›› 
readerIndex
›› 
+=
›› 
$num
››  !
;
››! "
return
œœ 
v
œœ 
;
œœ 
}
 	
public
ŸŸ 
uint
ŸŸ 
ReadUnsignedInt
ŸŸ #
(
ŸŸ# $
)
ŸŸ$ %
{
   	
	unchecked
¡¡ 
{
¢¢ 
return
££ 
(
££ 
uint
££ 
)
££ 
(
££ 
this
££ "
.
££" #
ReadInt
££# *
(
££* +
)
££+ ,
)
££, -
;
££- .
}
¤¤ 
}
¥¥ 	
public
§§ 
uint
§§ 
ReadUnsignedIntLE
§§ %
(
§§% &
)
§§& '
{
¨¨ 	
	unchecked
©© 
{
ªª 
return
«« 
(
«« 
uint
«« 
)
«« 
this
«« !
.
««! "
	ReadIntLE
««" +
(
««+ ,
)
««, -
;
««- .
}
¬¬ 
}
­­ 	
public
¯¯ 
virtual
¯¯ 
long
¯¯ 
ReadLong
¯¯ $
(
¯¯$ %
)
¯¯% &
{
°° 	
this
±± 
.
±± !
CheckReadableBytes0
±± $
(
±±$ %
$num
±±% &
)
±±& '
;
±±' (
long
²² 
v
²² 
=
²² 
this
²² 
.
²² 
_GetLong
²² "
(
²²" #
this
²²# '
.
²²' (
readerIndex
²²( 3
)
²²3 4
;
²²4 5
this
³³ 
.
³³ 
readerIndex
³³ 
+=
³³ 
$num
³³  !
;
³³! "
return
´´ 
v
´´ 
;
´´ 
}
µµ 	
public
·· 
virtual
·· 
long
·· 

ReadLongLE
·· &
(
··& '
)
··' (
{
¸¸ 	
this
¹¹ 
.
¹¹ !
CheckReadableBytes0
¹¹ $
(
¹¹$ %
$num
¹¹% &
)
¹¹& '
;
¹¹' (
long
ºº 
v
ºº 
=
ºº 
this
ºº 
.
ºº 

_GetLongLE
ºº $
(
ºº$ %
this
ºº% )
.
ºº) *
readerIndex
ºº* 5
)
ºº5 6
;
ºº6 7
this
»» 
.
»» 
readerIndex
»» 
+=
»» 
$num
»»  !
;
»»! "
return
¼¼ 
v
¼¼ 
;
¼¼ 
}
½½ 	
public
¿¿ 
char
¿¿ 
ReadChar
¿¿ 
(
¿¿ 
)
¿¿ 
=>
¿¿ !
(
¿¿" #
char
¿¿# '
)
¿¿' (
this
¿¿( ,
.
¿¿, -
	ReadShort
¿¿- 6
(
¿¿6 7
)
¿¿7 8
;
¿¿8 9
public
ÁÁ 
float
ÁÁ 
	ReadFloat
ÁÁ 
(
ÁÁ 
)
ÁÁ  
=>
ÁÁ! #
ByteBufferUtil
ÁÁ$ 2
.
ÁÁ2 3
Int32BitsToSingle
ÁÁ3 D
(
ÁÁD E
this
ÁÁE I
.
ÁÁI J
ReadInt
ÁÁJ Q
(
ÁÁQ R
)
ÁÁR S
)
ÁÁS T
;
ÁÁT U
public
ÃÃ 
float
ÃÃ 
ReadFloatLE
ÃÃ  
(
ÃÃ  !
)
ÃÃ! "
=>
ÃÃ# %
ByteBufferUtil
ÃÃ& 4
.
ÃÃ4 5
Int32BitsToSingle
ÃÃ5 F
(
ÃÃF G
this
ÃÃG K
.
ÃÃK L
	ReadIntLE
ÃÃL U
(
ÃÃU V
)
ÃÃV W
)
ÃÃW X
;
ÃÃX Y
public
ÅÅ 
double
ÅÅ 

ReadDouble
ÅÅ  
(
ÅÅ  !
)
ÅÅ! "
=>
ÅÅ# %
BitConverter
ÅÅ& 2
.
ÅÅ2 3
Int64BitsToDouble
ÅÅ3 D
(
ÅÅD E
this
ÅÅE I
.
ÅÅI J
ReadLong
ÅÅJ R
(
ÅÅR S
)
ÅÅS T
)
ÅÅT U
;
ÅÅU V
public
ÇÇ 
double
ÇÇ 
ReadDoubleLE
ÇÇ "
(
ÇÇ" #
)
ÇÇ# $
=>
ÇÇ% '
BitConverter
ÇÇ( 4
.
ÇÇ4 5
Int64BitsToDouble
ÇÇ5 F
(
ÇÇF G
this
ÇÇG K
.
ÇÇK L

ReadLongLE
ÇÇL V
(
ÇÇV W
)
ÇÇW X
)
ÇÇX Y
;
ÇÇY Z
public
ÉÉ 
virtual
ÉÉ 
IByteBuffer
ÉÉ "
	ReadBytes
ÉÉ# ,
(
ÉÉ, -
int
ÉÉ- 0
length
ÉÉ1 7
)
ÉÉ7 8
{
ÊÊ 	
this
ËË 
.
ËË  
CheckReadableBytes
ËË #
(
ËË# $
length
ËË$ *
)
ËË* +
;
ËË+ ,
if
ÌÌ 
(
ÌÌ 
length
ÌÌ 
==
ÌÌ 
$num
ÌÌ 
)
ÌÌ 
{
ÍÍ 
return
ÎÎ 
Unpooled
ÎÎ 
.
ÎÎ  
Empty
ÎÎ  %
;
ÎÎ% &
}
ÏÏ 
IByteBuffer
ÑÑ 
buf
ÑÑ 
=
ÑÑ 
this
ÑÑ "
.
ÑÑ" #
	Allocator
ÑÑ# ,
.
ÑÑ, -
Buffer
ÑÑ- 3
(
ÑÑ3 4
length
ÑÑ4 :
,
ÑÑ: ;
this
ÑÑ< @
.
ÑÑ@ A
MaxCapacity
ÑÑA L
)
ÑÑL M
;
ÑÑM N
buf
ÒÒ 
.
ÒÒ 

WriteBytes
ÒÒ 
(
ÒÒ 
this
ÒÒ 
,
ÒÒ  
this
ÒÒ! %
.
ÒÒ% &
readerIndex
ÒÒ& 1
,
ÒÒ1 2
length
ÒÒ3 9
)
ÒÒ9 :
;
ÒÒ: ;
this
ÓÓ 
.
ÓÓ 
readerIndex
ÓÓ 
+=
ÓÓ 
length
ÓÓ  &
;
ÓÓ& '
return
ÔÔ 
buf
ÔÔ 
;
ÔÔ 
}
ÕÕ 	
public
×× 
virtual
×× 
IByteBuffer
×× "
	ReadSlice
××# ,
(
××, -
int
××- 0
length
××1 7
)
××7 8
{
ØØ 	
this
ÙÙ 
.
ÙÙ  
CheckReadableBytes
ÙÙ #
(
ÙÙ# $
length
ÙÙ$ *
)
ÙÙ* +
;
ÙÙ+ ,
IByteBuffer
ÚÚ 
slice
ÚÚ 
=
ÚÚ 
this
ÚÚ  $
.
ÚÚ$ %
Slice
ÚÚ% *
(
ÚÚ* +
this
ÚÚ+ /
.
ÚÚ/ 0
readerIndex
ÚÚ0 ;
,
ÚÚ; <
length
ÚÚ= C
)
ÚÚC D
;
ÚÚD E
this
ÛÛ 
.
ÛÛ 
readerIndex
ÛÛ 
+=
ÛÛ 
length
ÛÛ  &
;
ÛÛ& '
return
ÜÜ 
slice
ÜÜ 
;
ÜÜ 
}
İİ 	
public
ßß 
virtual
ßß 
IByteBuffer
ßß "
ReadRetainedSlice
ßß# 4
(
ßß4 5
int
ßß5 8
length
ßß9 ?
)
ßß? @
{
àà 	
this
áá 
.
áá  
CheckReadableBytes
áá #
(
áá# $
length
áá$ *
)
áá* +
;
áá+ ,
IByteBuffer
ââ 
slice
ââ 
=
ââ 
this
ââ  $
.
ââ$ %
RetainedSlice
ââ% 2
(
ââ2 3
this
ââ3 7
.
ââ7 8
readerIndex
ââ8 C
,
ââC D
length
ââE K
)
ââK L
;
ââL M
this
ãã 
.
ãã 
readerIndex
ãã 
+=
ãã 
length
ãã  &
;
ãã& '
return
ää 
slice
ää 
;
ää 
}
åå 	
public
çç 
virtual
çç 
IByteBuffer
çç "
	ReadBytes
çç# ,
(
çç, -
byte
çç- 1
[
çç1 2
]
çç2 3
destination
çç4 ?
,
çç? @
int
ççA D
dstIndex
ççE M
,
ççM N
int
ççO R
length
ççS Y
)
ççY Z
{
èè 	
this
éé 
.
éé  
CheckReadableBytes
éé #
(
éé# $
length
éé$ *
)
éé* +
;
éé+ ,
this
êê 
.
êê 
GetBytes
êê 
(
êê 
this
êê 
.
êê 
readerIndex
êê *
,
êê* +
destination
êê, 7
,
êê7 8
dstIndex
êê9 A
,
êêA B
length
êêC I
)
êêI J
;
êêJ K
this
ëë 
.
ëë 
readerIndex
ëë 
+=
ëë 
length
ëë  &
;
ëë& '
return
ìì 
this
ìì 
;
ìì 
}
íí 	
public
ïï 
virtual
ïï 
IByteBuffer
ïï "
	ReadBytes
ïï# ,
(
ïï, -
byte
ïï- 1
[
ïï1 2
]
ïï2 3
dst
ïï4 7
)
ïï7 8
{
ğğ 	
this
ññ 
.
ññ 
	ReadBytes
ññ 
(
ññ 
dst
ññ 
,
ññ 
$num
ññ  !
,
ññ! "
dst
ññ# &
.
ññ& '
Length
ññ' -
)
ññ- .
;
ññ. /
return
òò 
this
òò 
;
òò 
}
óó 	
public
õõ 
virtual
õõ 
IByteBuffer
õõ "
	ReadBytes
õõ# ,
(
õõ, -
IByteBuffer
õõ- 8
dst
õõ9 <
)
õõ< =
{
öö 	
this
÷÷ 
.
÷÷ 
	ReadBytes
÷÷ 
(
÷÷ 
dst
÷÷ 
,
÷÷ 
dst
÷÷  #
.
÷÷# $
WritableBytes
÷÷$ 1
)
÷÷1 2
;
÷÷2 3
return
øø 
this
øø 
;
øø 
}
ùù 	
public
ûû 
virtual
ûû 
IByteBuffer
ûû "
	ReadBytes
ûû# ,
(
ûû, -
IByteBuffer
ûû- 8
dst
ûû9 <
,
ûû< =
int
ûû> A
length
ûûB H
)
ûûH I
{
üü 	
if
ıı 
(
ıı 
length
ıı 
>
ıı 
dst
ıı 
.
ıı 
WritableBytes
ıı *
)
ıı* +
{
şş 
ThrowHelper
ÿÿ 
.
ÿÿ 9
+ThrowIndexOutOfRangeException_WritableBytes
ÿÿ G
(
ÿÿG H
length
ÿÿH N
,
ÿÿN O
dst
ÿÿP S
)
ÿÿS T
;
ÿÿT U
}
€€ 
this
 
.
 
	ReadBytes
 
(
 
dst
 
,
 
dst
  #
.
# $
WriterIndex
$ /
,
/ 0
length
1 7
)
7 8
;
8 9
dst
‚‚ 
.
‚‚ 
SetWriterIndex
‚‚ 
(
‚‚ 
dst
‚‚ "
.
‚‚" #
WriterIndex
‚‚# .
+
‚‚/ 0
length
‚‚1 7
)
‚‚7 8
;
‚‚8 9
return
ƒƒ 
this
ƒƒ 
;
ƒƒ 
}
„„ 	
public
†† 
virtual
†† 
IByteBuffer
†† "
	ReadBytes
††# ,
(
††, -
IByteBuffer
††- 8
dst
††9 <
,
††< =
int
††> A
dstIndex
††B J
,
††J K
int
††L O
length
††P V
)
††V W
{
‡‡ 	
this
ˆˆ 
.
ˆˆ  
CheckReadableBytes
ˆˆ #
(
ˆˆ# $
length
ˆˆ$ *
)
ˆˆ* +
;
ˆˆ+ ,
this
‰‰ 
.
‰‰ 
GetBytes
‰‰ 
(
‰‰ 
this
‰‰ 
.
‰‰ 
readerIndex
‰‰ *
,
‰‰* +
dst
‰‰, /
,
‰‰/ 0
dstIndex
‰‰1 9
,
‰‰9 :
length
‰‰; A
)
‰‰A B
;
‰‰B C
this
ŠŠ 
.
ŠŠ 
readerIndex
ŠŠ 
+=
ŠŠ 
length
ŠŠ  &
;
ŠŠ& '
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
ŒŒ 	
public
 
virtual
 
IByteBuffer
 "
	ReadBytes
# ,
(
, -
Stream
- 3
destination
4 ?
,
? @
int
A D
length
E K
)
K L
{
 	
this
 
.
  
CheckReadableBytes
 #
(
# $
length
$ *
)
* +
;
+ ,
this
‘‘ 
.
‘‘ 
GetBytes
‘‘ 
(
‘‘ 
this
‘‘ 
.
‘‘ 
readerIndex
‘‘ *
,
‘‘* +
destination
‘‘, 7
,
‘‘7 8
length
‘‘9 ?
)
‘‘? @
;
‘‘@ A
this
’’ 
.
’’ 
readerIndex
’’ 
+=
’’ 
length
’’  &
;
’’& '
return
““ 
this
““ 
;
““ 
}
”” 	
public
–– 
virtual
–– 
IByteBuffer
–– "
	SkipBytes
––# ,
(
––, -
int
––- 0
length
––1 7
)
––7 8
{
—— 	
this
˜˜ 
.
˜˜  
CheckReadableBytes
˜˜ #
(
˜˜# $
length
˜˜$ *
)
˜˜* +
;
˜˜+ ,
this
™™ 
.
™™ 
readerIndex
™™ 
+=
™™ 
length
™™  &
;
™™& '
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
virtual
 
IByteBuffer
 "
WriteBoolean
# /
(
/ 0
bool
0 4
value
5 :
)
: ;
{
 	
this
ŸŸ 
.
ŸŸ 
	WriteByte
ŸŸ 
(
ŸŸ 
value
ŸŸ  
?
ŸŸ! "
$num
ŸŸ# $
:
ŸŸ% &
$num
ŸŸ' (
)
ŸŸ( )
;
ŸŸ) *
return
   
this
   
;
   
}
¡¡ 	
public
££ 
virtual
££ 
IByteBuffer
££ "
	WriteByte
££# ,
(
££, -
int
££- 0
value
££1 6
)
££6 7
{
¤¤ 	
this
¥¥ 
.
¥¥ 
EnsureWritable0
¥¥  
(
¥¥  !
$num
¥¥! "
)
¥¥" #
;
¥¥# $
this
¦¦ 
.
¦¦ 
_SetByte
¦¦ 
(
¦¦ 
this
¦¦ 
.
¦¦ 
writerIndex
¦¦ *
++
¦¦* ,
,
¦¦, -
value
¦¦. 3
)
¦¦3 4
;
¦¦4 5
return
§§ 
this
§§ 
;
§§ 
}
¨¨ 	
public
ªª 
virtual
ªª 
IByteBuffer
ªª "

WriteShort
ªª# -
(
ªª- .
int
ªª. 1
value
ªª2 7
)
ªª7 8
{
«« 	
this
¬¬ 
.
¬¬ 
EnsureWritable0
¬¬  
(
¬¬  !
$num
¬¬! "
)
¬¬" #
;
¬¬# $
this
­­ 
.
­­ 
	_SetShort
­­ 
(
­­ 
this
­­ 
.
­­  
writerIndex
­­  +
,
­­+ ,
value
­­- 2
)
­­2 3
;
­­3 4
this
®® 
.
®® 
writerIndex
®® 
+=
®® 
$num
®®  !
;
®®! "
return
¯¯ 
this
¯¯ 
;
¯¯ 
}
°° 	
public
²² 
virtual
²² 
IByteBuffer
²² "
WriteShortLE
²²# /
(
²²/ 0
int
²²0 3
value
²²4 9
)
²²9 :
{
³³ 	
this
´´ 
.
´´ 
EnsureWritable0
´´  
(
´´  !
$num
´´! "
)
´´" #
;
´´# $
this
µµ 
.
µµ 
_SetShortLE
µµ 
(
µµ 
this
µµ !
.
µµ! "
writerIndex
µµ" -
,
µµ- .
value
µµ/ 4
)
µµ4 5
;
µµ5 6
this
¶¶ 
.
¶¶ 
writerIndex
¶¶ 
+=
¶¶ 
$num
¶¶  !
;
¶¶! "
return
·· 
this
·· 
;
·· 
}
¸¸ 	
public
ºº 
IByteBuffer
ºº  
WriteUnsignedShort
ºº -
(
ºº- .
ushort
ºº. 4
value
ºº5 :
)
ºº: ;
{
»» 	
	unchecked
¼¼ 
{
½½ 
return
¾¾ 
this
¾¾ 
.
¾¾ 

WriteShort
¾¾ &
(
¾¾& '
(
¾¾' (
short
¾¾( -
)
¾¾- .
value
¾¾. 3
)
¾¾3 4
;
¾¾4 5
}
¿¿ 
}
ÀÀ 	
public
ÂÂ 
IByteBuffer
ÂÂ "
WriteUnsignedShortLE
ÂÂ /
(
ÂÂ/ 0
ushort
ÂÂ0 6
value
ÂÂ7 <
)
ÂÂ< =
{
ÃÃ 	
	unchecked
ÄÄ 
{
ÅÅ 
return
ÆÆ 
this
ÆÆ 
.
ÆÆ 
WriteShortLE
ÆÆ (
(
ÆÆ( )
(
ÆÆ) *
short
ÆÆ* /
)
ÆÆ/ 0
value
ÆÆ0 5
)
ÆÆ5 6
;
ÆÆ6 7
}
ÇÇ 
}
ÈÈ 	
public
ÊÊ 
virtual
ÊÊ 
IByteBuffer
ÊÊ "
WriteMedium
ÊÊ# .
(
ÊÊ. /
int
ÊÊ/ 2
value
ÊÊ3 8
)
ÊÊ8 9
{
ËË 	
this
ÌÌ 
.
ÌÌ 
EnsureWritable0
ÌÌ  
(
ÌÌ  !
$num
ÌÌ! "
)
ÌÌ" #
;
ÌÌ# $
this
ÍÍ 
.
ÍÍ 

_SetMedium
ÍÍ 
(
ÍÍ 
this
ÍÍ  
.
ÍÍ  !
writerIndex
ÍÍ! ,
,
ÍÍ, -
value
ÍÍ. 3
)
ÍÍ3 4
;
ÍÍ4 5
this
ÎÎ 
.
ÎÎ 
writerIndex
ÎÎ 
+=
ÎÎ 
$num
ÎÎ  !
;
ÎÎ! "
return
ÏÏ 
this
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
public
ÒÒ 
virtual
ÒÒ 
IByteBuffer
ÒÒ "
WriteMediumLE
ÒÒ# 0
(
ÒÒ0 1
int
ÒÒ1 4
value
ÒÒ5 :
)
ÒÒ: ;
{
ÓÓ 	
this
ÔÔ 
.
ÔÔ 
EnsureWritable0
ÔÔ  
(
ÔÔ  !
$num
ÔÔ! "
)
ÔÔ" #
;
ÔÔ# $
this
ÕÕ 
.
ÕÕ 
_SetMediumLE
ÕÕ 
(
ÕÕ 
this
ÕÕ "
.
ÕÕ" #
writerIndex
ÕÕ# .
,
ÕÕ. /
value
ÕÕ0 5
)
ÕÕ5 6
;
ÕÕ6 7
this
ÖÖ 
.
ÖÖ 
writerIndex
ÖÖ 
+=
ÖÖ 
$num
ÖÖ  !
;
ÖÖ! "
return
×× 
this
×× 
;
×× 
}
ØØ 	
public
ÚÚ 
virtual
ÚÚ 
IByteBuffer
ÚÚ "
WriteInt
ÚÚ# +
(
ÚÚ+ ,
int
ÚÚ, /
value
ÚÚ0 5
)
ÚÚ5 6
{
ÛÛ 	
this
ÜÜ 
.
ÜÜ 
EnsureWritable0
ÜÜ  
(
ÜÜ  !
$num
ÜÜ! "
)
ÜÜ" #
;
ÜÜ# $
this
İİ 
.
İİ 
_SetInt
İİ 
(
İİ 
this
İİ 
.
İİ 
writerIndex
İİ )
,
İİ) *
value
İİ+ 0
)
İİ0 1
;
İİ1 2
this
ŞŞ 
.
ŞŞ 
writerIndex
ŞŞ 
+=
ŞŞ 
$num
ŞŞ  !
;
ŞŞ! "
return
ßß 
this
ßß 
;
ßß 
}
àà 	
public
ââ 
virtual
ââ 
IByteBuffer
ââ "

WriteIntLE
ââ# -
(
ââ- .
int
ââ. 1
value
ââ2 7
)
ââ7 8
{
ãã 	
this
ää 
.
ää 
EnsureWritable0
ää  
(
ää  !
$num
ää! "
)
ää" #
;
ää# $
this
åå 
.
åå 
	_SetIntLE
åå 
(
åå 
this
åå 
.
åå  
writerIndex
åå  +
,
åå+ ,
value
åå- 2
)
åå2 3
;
åå3 4
this
ææ 
.
ææ 
writerIndex
ææ 
+=
ææ 
$num
ææ  !
;
ææ! "
return
çç 
this
çç 
;
çç 
}
èè 	
public
êê 
virtual
êê 
IByteBuffer
êê "
	WriteLong
êê# ,
(
êê, -
long
êê- 1
value
êê2 7
)
êê7 8
{
ëë 	
this
ìì 
.
ìì 
EnsureWritable0
ìì  
(
ìì  !
$num
ìì! "
)
ìì" #
;
ìì# $
this
íí 
.
íí 
_SetLong
íí 
(
íí 
this
íí 
.
íí 
writerIndex
íí *
,
íí* +
value
íí, 1
)
íí1 2
;
íí2 3
this
îî 
.
îî 
writerIndex
îî 
+=
îî 
$num
îî  !
;
îî! "
return
ïï 
this
ïï 
;
ïï 
}
ğğ 	
public
òò 
virtual
òò 
IByteBuffer
òò "
WriteLongLE
òò# .
(
òò. /
long
òò/ 3
value
òò4 9
)
òò9 :
{
óó 	
this
ôô 
.
ôô 
EnsureWritable0
ôô  
(
ôô  !
$num
ôô! "
)
ôô" #
;
ôô# $
this
õõ 
.
õõ 

_SetLongLE
õõ 
(
õõ 
this
õõ  
.
õõ  !
writerIndex
õõ! ,
,
õõ, -
value
õõ. 3
)
õõ3 4
;
õõ4 5
this
öö 
.
öö 
writerIndex
öö 
+=
öö 
$num
öö  !
;
öö! "
return
÷÷ 
this
÷÷ 
;
÷÷ 
}
øø 	
public
úú 
virtual
úú 
IByteBuffer
úú "
	WriteChar
úú# ,
(
úú, -
char
úú- 1
value
úú2 7
)
úú7 8
{
ûû 	
this
üü 
.
üü 

WriteShort
üü 
(
üü 
value
üü !
)
üü! "
;
üü" #
return
ıı 
this
ıı 
;
ıı 
}
şş 	
public
€	€	 
virtual
€	€	 
IByteBuffer
€	€	 "

WriteFloat
€	€	# -
(
€	€	- .
float
€	€	. 3
value
€	€	4 9
)
€	€	9 :
{
		 	
this
‚	‚	 
.
‚	‚	 
WriteInt
‚	‚	 
(
‚	‚	 
ByteBufferUtil
‚	‚	 (
.
‚	‚	( )
SingleToInt32Bits
‚	‚	) :
(
‚	‚	: ;
value
‚	‚	; @
)
‚	‚	@ A
)
‚	‚	A B
;
‚	‚	B C
return
ƒ	ƒ	 
this
ƒ	ƒ	 
;
ƒ	ƒ	 
}
„	„	 	
public
†	†	 
IByteBuffer
†	†	 
WriteFloatLE
†	†	 '
(
†	†	' (
float
†	†	( -
value
†	†	. 3
)
†	†	3 4
=>
†	†	5 7
this
†	†	8 <
.
†	†	< =

WriteIntLE
†	†	= G
(
†	†	G H
ByteBufferUtil
†	†	H V
.
†	†	V W
SingleToInt32Bits
†	†	W h
(
†	†	h i
value
†	†	i n
)
†	†	n o
)
†	†	o p
;
†	†	p q
public
ˆ	ˆ	 
virtual
ˆ	ˆ	 
IByteBuffer
ˆ	ˆ	 "
WriteDouble
ˆ	ˆ	# .
(
ˆ	ˆ	. /
double
ˆ	ˆ	/ 5
value
ˆ	ˆ	6 ;
)
ˆ	ˆ	; <
{
‰	‰	 	
this
Š	Š	 
.
Š	Š	 
	WriteLong
Š	Š	 
(
Š	Š	 
BitConverter
Š	Š	 '
.
Š	Š	' (
DoubleToInt64Bits
Š	Š	( 9
(
Š	Š	9 :
value
Š	Š	: ?
)
Š	Š	? @
)
Š	Š	@ A
;
Š	Š	A B
return
‹	‹	 
this
‹	‹	 
;
‹	‹	 
}
Œ	Œ	 	
public
		 
IByteBuffer
		 
WriteDoubleLE
		 (
(
		( )
double
		) /
value
		0 5
)
		5 6
=>
		7 9
this
		: >
.
		> ?
WriteLongLE
		? J
(
		J K
BitConverter
		K W
.
		W X
DoubleToInt64Bits
		X i
(
		i j
value
		j o
)
		o p
)
		p q
;
		q r
public
		 
virtual
		 
IByteBuffer
		 "

WriteBytes
		# -
(
		- .
byte
		. 2
[
		2 3
]
		3 4
src
		5 8
,
		8 9
int
		: =
srcIndex
		> F
,
		F G
int
		H K
length
		L R
)
		R S
{
‘	‘	 	
this
’	’	 
.
’	’	 
EnsureWritable
’	’	 
(
’	’	  
length
’	’	  &
)
’	’	& '
;
’	’	' (
this
“	“	 
.
“	“	 
SetBytes
“	“	 
(
“	“	 
this
“	“	 
.
“	“	 
writerIndex
“	“	 *
,
“	“	* +
src
“	“	, /
,
“	“	/ 0
srcIndex
“	“	1 9
,
“	“	9 :
length
“	“	; A
)
“	“	A B
;
“	“	B C
this
”	”	 
.
”	”	 
writerIndex
”	”	 
+=
”	”	 
length
”	”	  &
;
”	”	& '
return
•	•	 
this
•	•	 
;
•	•	 
}
–	–	 	
public
˜	˜	 
virtual
˜	˜	 
IByteBuffer
˜	˜	 "

WriteBytes
˜	˜	# -
(
˜	˜	- .
byte
˜	˜	. 2
[
˜	˜	2 3
]
˜	˜	3 4
src
˜	˜	5 8
)
˜	˜	8 9
{
™	™	 	
this
š	š	 
.
š	š	 

WriteBytes
š	š	 
(
š	š	 
src
š	š	 
,
š	š	  
$num
š	š	! "
,
š	š	" #
src
š	š	$ '
.
š	š	' (
Length
š	š	( .
)
š	š	. /
;
š	š	/ 0
return
›	›	 
this
›	›	 
;
›	›	 
}
œ	œ	 	
public
		 
virtual
		 
IByteBuffer
		 "

WriteBytes
		# -
(
		- .
IByteBuffer
		. 9
src
		: =
)
		= >
{
Ÿ	Ÿ	 	
this
 	 	 
.
 	 	 

WriteBytes
 	 	 
(
 	 	 
src
 	 	 
,
 	 	  
src
 	 	! $
.
 	 	$ %
ReadableBytes
 	 	% 2
)
 	 	2 3
;
 	 	3 4
return
¡	¡	 
this
¡	¡	 
;
¡	¡	 
}
¢	¢	 	
public
¤	¤	 
virtual
¤	¤	 
IByteBuffer
¤	¤	 "

WriteBytes
¤	¤	# -
(
¤	¤	- .
IByteBuffer
¤	¤	. 9
src
¤	¤	: =
,
¤	¤	= >
int
¤	¤	? B
length
¤	¤	C I
)
¤	¤	I J
{
¥	¥	 	
if
¦	¦	 
(
¦	¦	 
length
¦	¦	 
>
¦	¦	 
src
¦	¦	 
.
¦	¦	 
ReadableBytes
¦	¦	 *
)
¦	¦	* +
{
§	§	 
ThrowHelper
¨	¨	 
.
¨	¨	 9
+ThrowIndexOutOfRangeException_ReadableBytes
¨	¨	 G
(
¨	¨	G H
length
¨	¨	H N
,
¨	¨	N O
src
¨	¨	P S
)
¨	¨	S T
;
¨	¨	T U
}
©	©	 
this
ª	ª	 
.
ª	ª	 

WriteBytes
ª	ª	 
(
ª	ª	 
src
ª	ª	 
,
ª	ª	  
src
ª	ª	! $
.
ª	ª	$ %
ReaderIndex
ª	ª	% 0
,
ª	ª	0 1
length
ª	ª	2 8
)
ª	ª	8 9
;
ª	ª	9 :
src
«	«	 
.
«	«	 
SetReaderIndex
«	«	 
(
«	«	 
src
«	«	 "
.
«	«	" #
ReaderIndex
«	«	# .
+
«	«	/ 0
length
«	«	1 7
)
«	«	7 8
;
«	«	8 9
return
¬	¬	 
this
¬	¬	 
;
¬	¬	 
}
­	­	 	
public
¯	¯	 
virtual
¯	¯	 
IByteBuffer
¯	¯	 "

WriteBytes
¯	¯	# -
(
¯	¯	- .
IByteBuffer
¯	¯	. 9
src
¯	¯	: =
,
¯	¯	= >
int
¯	¯	? B
srcIndex
¯	¯	C K
,
¯	¯	K L
int
¯	¯	M P
length
¯	¯	Q W
)
¯	¯	W X
{
°	°	 	
this
±	±	 
.
±	±	 
EnsureWritable
±	±	 
(
±	±	  
length
±	±	  &
)
±	±	& '
;
±	±	' (
this
²	²	 
.
²	²	 
SetBytes
²	²	 
(
²	²	 
this
²	²	 
.
²	²	 
writerIndex
²	²	 *
,
²	²	* +
src
²	²	, /
,
²	²	/ 0
srcIndex
²	²	1 9
,
²	²	9 :
length
²	²	; A
)
²	²	A B
;
²	²	B C
this
³	³	 
.
³	³	 
writerIndex
³	³	 
+=
³	³	 
length
³	³	  &
;
³	³	& '
return
´	´	 
this
´	´	 
;
´	´	 
}
µ	µ	 	
public
·	·	 
virtual
·	·	 
async
·	·	 
Task
·	·	 !
WriteBytesAsync
·	·	" 1
(
·	·	1 2
Stream
·	·	2 8
stream
·	·	9 ?
,
·	·	? @
int
·	·	A D
length
·	·	E K
,
·	·	K L
CancellationToken
·	·	M ^
cancellationToken
·	·	_ p
)
·	·	p q
{
¸	¸	 	
this
¹	¹	 
.
¹	¹	 
EnsureWritable
¹	¹	 
(
¹	¹	  
length
¹	¹	  &
)
¹	¹	& '
;
¹	¹	' (
if
º	º	 
(
º	º	 
this
º	º	 
.
º	º	 
WritableBytes
º	º	 "
<
º	º	# $
length
º	º	% +
)
º	º	+ ,
{
»	»	 
throw
¼	¼	 
new
¼	¼	 )
ArgumentOutOfRangeException
¼	¼	 5
(
¼	¼	5 6
nameof
¼	¼	6 <
(
¼	¼	< =
length
¼	¼	= C
)
¼	¼	C D
)
¼	¼	D E
;
¼	¼	E F
}
½	½	 
int
¿	¿	 
	writerIdx
¿	¿	 
=
¿	¿	 
this
¿	¿	  
.
¿	¿	  !
writerIndex
¿	¿	! ,
;
¿	¿	, -
int
À	À	 
wrote
À	À	 
=
À	À	 
await
À	À	 
this
À	À	 "
.
À	À	" #
SetBytesAsync
À	À	# 0
(
À	À	0 1
	writerIdx
À	À	1 :
,
À	À	: ;
stream
À	À	< B
,
À	À	B C
length
À	À	D J
,
À	À	J K
cancellationToken
À	À	L ]
)
À	À	] ^
;
À	À	^ _
Contract
Â	Â	 
.
Â	Â	 
Assert
Â	Â	 
(
Â	Â	 
	writerIdx
Â	Â	 %
==
Â	Â	& (
this
Â	Â	) -
.
Â	Â	- .
writerIndex
Â	Â	. 9
)
Â	Â	9 :
;
Â	Â	: ;
this
Ã	Ã	 
.
Ã	Ã	 
writerIndex
Ã	Ã	 
=
Ã	Ã	 
	writerIdx
Ã	Ã	 (
+
Ã	Ã	) *
wrote
Ã	Ã	+ 0
;
Ã	Ã	0 1
}
Ä	Ä	 	
public
Æ	Æ	 
Task
Æ	Æ	 
WriteBytesAsync
Æ	Æ	 #
(
Æ	Æ	# $
Stream
Æ	Æ	$ *
stream
Æ	Æ	+ 1
,
Æ	Æ	1 2
int
Æ	Æ	3 6
length
Æ	Æ	7 =
)
Æ	Æ	= >
=>
Æ	Æ	? A
this
Æ	Æ	B F
.
Æ	Æ	F G
WriteBytesAsync
Æ	Æ	G V
(
Æ	Æ	V W
stream
Æ	Æ	W ]
,
Æ	Æ	] ^
length
Æ	Æ	_ e
,
Æ	Æ	e f
CancellationToken
Æ	Æ	g x
.
Æ	Æ	x y
None
Æ	Æ	y }
)
Æ	Æ	} ~
;
Æ	Æ	~ 
public
È	È	 
virtual
È	È	 
IByteBuffer
È	È	 "
	WriteZero
È	È	# ,
(
È	È	, -
int
È	È	- 0
length
È	È	1 7
)
È	È	7 8
{
É	É	 	
if
Ê	Ê	 
(
Ê	Ê	 
length
Ê	Ê	 
==
Ê	Ê	 
$num
Ê	Ê	 
)
Ê	Ê	 
{
Ë	Ë	 
return
Ì	Ì	 
this
Ì	Ì	 
;
Ì	Ì	 
}
Í	Í	 
this
Ï	Ï	 
.
Ï	Ï	 
EnsureWritable
Ï	Ï	 
(
Ï	Ï	  
length
Ï	Ï	  &
)
Ï	Ï	& '
;
Ï	Ï	' (
int
Ğ	Ğ	 
wIndex
Ğ	Ğ	 
=
Ğ	Ğ	 
this
Ğ	Ğ	 
.
Ğ	Ğ	 
writerIndex
Ğ	Ğ	 )
;
Ğ	Ğ	) *
this
Ñ	Ñ	 
.
Ñ	Ñ	 
CheckIndex0
Ñ	Ñ	 
(
Ñ	Ñ	 
wIndex
Ñ	Ñ	 #
,
Ñ	Ñ	# $
length
Ñ	Ñ	% +
)
Ñ	Ñ	+ ,
;
Ñ	Ñ	, -
int
Ó	Ó	 
nLong
Ó	Ó	 
=
Ó	Ó	 
length
Ó	Ó	 
.
Ó	Ó	 
RightUShift
Ó	Ó	 *
(
Ó	Ó	* +
$num
Ó	Ó	+ ,
)
Ó	Ó	, -
;
Ó	Ó	- .
int
Ô	Ô	 
nBytes
Ô	Ô	 
=
Ô	Ô	 
length
Ô	Ô	 
&
Ô	Ô	  !
$num
Ô	Ô	" #
;
Ô	Ô	# $
for
Õ	Õ	 
(
Õ	Õ	 
int
Õ	Õ	 
i
Õ	Õ	 
=
Õ	Õ	 
nLong
Õ	Õ	 
;
Õ	Õ	 
i
Õ	Õ	  !
>
Õ	Õ	" #
$num
Õ	Õ	$ %
;
Õ	Õ	% &
i
Õ	Õ	' (
--
Õ	Õ	( *
)
Õ	Õ	* +
{
Ö	Ö	 
this
×	×	 
.
×	×	 
_SetLong
×	×	 
(
×	×	 
wIndex
×	×	 $
,
×	×	$ %
$num
×	×	& '
)
×	×	' (
;
×	×	( )
wIndex
Ø	Ø	 
+=
Ø	Ø	 
$num
Ø	Ø	 
;
Ø	Ø	 
}
Ù	Ù	 
if
Ú	Ú	 
(
Ú	Ú	 
nBytes
Ú	Ú	 
==
Ú	Ú	 
$num
Ú	Ú	 
)
Ú	Ú	 
{
Û	Û	 
this
Ü	Ü	 
.
Ü	Ü	 
_SetInt
Ü	Ü	 
(
Ü	Ü	 
wIndex
Ü	Ü	 #
,
Ü	Ü	# $
$num
Ü	Ü	% &
)
Ü	Ü	& '
;
Ü	Ü	' (
wIndex
İ	İ	 
+=
İ	İ	 
$num
İ	İ	 
;
İ	İ	 
}
Ş	Ş	 
else
ß	ß	 
if
ß	ß	 
(
ß	ß	 
nBytes
ß	ß	 
<
ß	ß	 
$num
ß	ß	 
)
ß	ß	  
{
à	à	 
for
á	á	 
(
á	á	 
int
á	á	 
i
á	á	 
=
á	á	 
nBytes
á	á	 #
;
á	á	# $
i
á	á	% &
>
á	á	' (
$num
á	á	) *
;
á	á	* +
i
á	á	, -
--
á	á	- /
)
á	á	/ 0
{
â	â	 
this
ã	ã	 
.
ã	ã	 
_SetByte
ã	ã	 !
(
ã	ã	! "
wIndex
ã	ã	" (
,
ã	ã	( )
$num
ã	ã	* +
)
ã	ã	+ ,
;
ã	ã	, -
wIndex
ä	ä	 
++
ä	ä	 
;
ä	ä	 
}
å	å	 
}
æ	æ	 
else
ç	ç	 
{
è	è	 
this
é	é	 
.
é	é	 
_SetInt
é	é	 
(
é	é	 
wIndex
é	é	 #
,
é	é	# $
$num
é	é	% &
)
é	é	& '
;
é	é	' (
wIndex
ê	ê	 
+=
ê	ê	 
$num
ê	ê	 
;
ê	ê	 
for
ë	ë	 
(
ë	ë	 
int
ë	ë	 
i
ë	ë	 
=
ë	ë	 
nBytes
ë	ë	 #
-
ë	ë	$ %
$num
ë	ë	& '
;
ë	ë	' (
i
ë	ë	) *
>
ë	ë	+ ,
$num
ë	ë	- .
;
ë	ë	. /
i
ë	ë	0 1
--
ë	ë	1 3
)
ë	ë	3 4
{
ì	ì	 
this
í	í	 
.
í	í	 
_SetByte
í	í	 !
(
í	í	! "
wIndex
í	í	" (
,
í	í	( )
$num
í	í	* +
)
í	í	+ ,
;
í	í	, -
wIndex
î	î	 
++
î	î	 
;
î	î	 
}
ï	ï	 
}
ğ	ğ	 
this
ò	ò	 
.
ò	ò	 
writerIndex
ò	ò	 
=
ò	ò	 
wIndex
ò	ò	 %
;
ò	ò	% &
return
ó	ó	 
this
ó	ó	 
;
ó	ó	 
}
ô	ô	 	
public
ö	ö	 
virtual
ö	ö	 
int
ö	ö	 
WriteCharSequence
ö	ö	 ,
(
ö	ö	, -
ICharSequence
ö	ö	- :
sequence
ö	ö	; C
,
ö	ö	C D
Encoding
ö	ö	E M
encoding
ö	ö	N V
)
ö	ö	V W
{
÷	÷	 	
int
ø	ø	 
written
ø	ø	 
=
ø	ø	 
this
ø	ø	 
.
ø	ø	 
SetCharSequence0
ø	ø	 /
(
ø	ø	/ 0
this
ø	ø	0 4
.
ø	ø	4 5
writerIndex
ø	ø	5 @
,
ø	ø	@ A
sequence
ø	ø	B J
,
ø	ø	J K
encoding
ø	ø	L T
,
ø	ø	T U
true
ø	ø	V Z
)
ø	ø	Z [
;
ø	ø	[ \
this
ù	ù	 
.
ù	ù	 
writerIndex
ù	ù	 
+=
ù	ù	 
written
ù	ù	  '
;
ù	ù	' (
return
ú	ú	 
written
ú	ú	 
;
ú	ú	 
}
û	û	 	
public
ı	ı	 
virtual
ı	ı	 
int
ı	ı	 
WriteString
ı	ı	 &
(
ı	ı	& '
string
ı	ı	' -
value
ı	ı	. 3
,
ı	ı	3 4
Encoding
ı	ı	5 =
encoding
ı	ı	> F
)
ı	ı	F G
{
ş	ş	 	
int
ÿ	ÿ	 
written
ÿ	ÿ	 
=
ÿ	ÿ	 
this
ÿ	ÿ	 
.
ÿ	ÿ	 

SetString0
ÿ	ÿ	 )
(
ÿ	ÿ	) *
this
ÿ	ÿ	* .
.
ÿ	ÿ	. /
writerIndex
ÿ	ÿ	/ :
,
ÿ	ÿ	: ;
value
ÿ	ÿ	< A
,
ÿ	ÿ	A B
encoding
ÿ	ÿ	C K
,
ÿ	ÿ	K L
true
ÿ	ÿ	M Q
)
ÿ	ÿ	Q R
;
ÿ	ÿ	R S
this
€
€
 
.
€
€
 
writerIndex
€
€
 
+=
€
€
 
written
€
€
  '
;
€
€
' (
return


 
written


 
;


 
}
‚
‚
 	
public
„
„
 
virtual
„
„
 
IByteBuffer
„
„
 "
Copy
„
„
# '
(
„
„
' (
)
„
„
( )
=>
„
„
* ,
this
„
„
- 1
.
„
„
1 2
Copy
„
„
2 6
(
„
„
6 7
this
„
„
7 ;
.
„
„
; <
readerIndex
„
„
< G
,
„
„
G H
this
„
„
I M
.
„
„
M N
ReadableBytes
„
„
N [
)
„
„
[ \
;
„
„
\ ]
public
†
†
 
abstract
†
†
 
IByteBuffer
†
†
 #
Copy
†
†
$ (
(
†
†
( )
int
†
†
) ,
index
†
†
- 2
,
†
†
2 3
int
†
†
4 7
length
†
†
8 >
)
†
†
> ?
;
†
†
? @
public
ˆ
ˆ
 
virtual
ˆ
ˆ
 
IByteBuffer
ˆ
ˆ
 "
	Duplicate
ˆ
ˆ
# ,
(
ˆ
ˆ
, -
)
ˆ
ˆ
- .
=>
ˆ
ˆ
/ 1
new
ˆ
ˆ
2 5*
UnpooledDuplicatedByteBuffer
ˆ
ˆ
6 R
(
ˆ
ˆ
R S
this
ˆ
ˆ
S W
)
ˆ
ˆ
W X
;
ˆ
ˆ
X Y
public
Š
Š
 
virtual
Š
Š
 
IByteBuffer
Š
Š
 "
RetainedDuplicate
Š
Š
# 4
(
Š
Š
4 5
)
Š
Š
5 6
=>
Š
Š
7 9
(
Š
Š
: ;
IByteBuffer
Š
Š
; F
)
Š
Š
F G
this
Š
Š
G K
.
Š
Š
K L
	Duplicate
Š
Š
L U
(
Š
Š
U V
)
Š
Š
V W
.
Š
Š
W X
Retain
Š
Š
X ^
(
Š
Š
^ _
)
Š
Š
_ `
;
Š
Š
` a
public
Œ
Œ
 
virtual
Œ
Œ
 
IByteBuffer
Œ
Œ
 "
Slice
Œ
Œ
# (
(
Œ
Œ
( )
)
Œ
Œ
) *
=>
Œ
Œ
+ -
this
Œ
Œ
. 2
.
Œ
Œ
2 3
Slice
Œ
Œ
3 8
(
Œ
Œ
8 9
this
Œ
Œ
9 =
.
Œ
Œ
= >
readerIndex
Œ
Œ
> I
,
Œ
Œ
I J
this
Œ
Œ
K O
.
Œ
Œ
O P
ReadableBytes
Œ
Œ
P ]
)
Œ
Œ
] ^
;
Œ
Œ
^ _
public


 
virtual


 
IByteBuffer


 "
RetainedSlice


# 0
(


0 1
)


1 2
=>


3 5
(


6 7
IByteBuffer


7 B
)


B C
this


C G
.


G H
Slice


H M
(


M N
)


N O
.


O P
Retain


P V
(


V W
)


W X
;


X Y
public


 
virtual


 
IByteBuffer


 "
Slice


# (
(


( )
int


) ,
index


- 2
,


2 3
int


4 7
length


8 >
)


> ?
=>


@ B
new


C F&
UnpooledSlicedByteBuffer


G _
(


_ `
this


` d
,


d e
index


f k
,


k l
length


m s
)


s t
;


t u
public
’
’
 
virtual
’
’
 
IByteBuffer
’
’
 "
RetainedSlice
’
’
# 0
(
’
’
0 1
int
’
’
1 4
index
’
’
5 :
,
’
’
: ;
int
’
’
< ?
length
’
’
@ F
)
’
’
F G
=>
’
’
H J
(
’
’
K L
IByteBuffer
’
’
L W
)
’
’
W X
this
’
’
X \
.
’
’
\ ]
Slice
’
’
] b
(
’
’
b c
index
’
’
c h
,
’
’
h i
length
’
’
j p
)
’
’
p q
.
’
’
q r
Retain
’
’
r x
(
’
’
x y
)
’
’
y z
;
’
’
z {
public
”
”
 
virtual
”
”
 
string
”
”
 
ToString
”
”
 &
(
”
”
& '
Encoding
”
”
' /
encoding
”
”
0 8
)
”
”
8 9
=>
”
”
: <
this
”
”
= A
.
”
”
A B
ToString
”
”
B J
(
”
”
J K
this
”
”
K O
.
”
”
O P
readerIndex
”
”
P [
,
”
”
[ \
this
”
”
] a
.
”
”
a b
ReadableBytes
”
”
b o
,
”
”
o p
encoding
”
”
q y
)
”
”
y z
;
”
”
z {
public
–
–
 
virtual
–
–
 
string
–
–
 
ToString
–
–
 &
(
–
–
& '
int
–
–
' *
index
–
–
+ 0
,
–
–
0 1
int
–
–
2 5
length
–
–
6 <
,
–
–
< =
Encoding
–
–
> F
encoding
–
–
G O
)
–
–
O P
=>
–
–
Q S
ByteBufferUtil
–
–
T b
.
–
–
b c
DecodeString
–
–
c o
(
–
–
o p
this
–
–
p t
,
–
–
t u
index
–
–
v {
,
–
–
{ |
length–
–
} ƒ
,–
–
ƒ „
encoding–
–
… 
)–
–
 
;–
–
 
public
˜
˜
 
virtual
˜
˜
 
int
˜
˜
 
IndexOf
˜
˜
 "
(
˜
˜
" #
int
˜
˜
# &
	fromIndex
˜
˜
' 0
,
˜
˜
0 1
int
˜
˜
2 5
toIndex
˜
˜
6 =
,
˜
˜
= >
byte
˜
˜
? C
value
˜
˜
D I
)
˜
˜
I J
=>
˜
˜
K M
ByteBufferUtil
˜
˜
N \
.
˜
˜
\ ]
IndexOf
˜
˜
] d
(
˜
˜
d e
this
˜
˜
e i
,
˜
˜
i j
	fromIndex
˜
˜
k t
,
˜
˜
t u
toIndex
˜
˜
v }
,
˜
˜
} ~
value˜
˜
 „
)˜
˜
„ …
;˜
˜
… †
public
š
š
 
int
š
š
 
BytesBefore
š
š
 
(
š
š
 
byte
š
š
 #
value
š
š
$ )
)
š
š
) *
=>
š
š
+ -
this
š
š
. 2
.
š
š
2 3
BytesBefore
š
š
3 >
(
š
š
> ?
this
š
š
? C
.
š
š
C D
ReaderIndex
š
š
D O
,
š
š
O P
this
š
š
Q U
.
š
š
U V
ReadableBytes
š
š
V c
,
š
š
c d
value
š
š
e j
)
š
š
j k
;
š
š
k l
public
œ
œ
 
int
œ
œ
 
BytesBefore
œ
œ
 
(
œ
œ
 
int
œ
œ
 "
length
œ
œ
# )
,
œ
œ
) *
byte
œ
œ
+ /
value
œ
œ
0 5
)
œ
œ
5 6
{


 	
this


 
.


  
CheckReadableBytes


 #
(


# $
length


$ *
)


* +
;


+ ,
return
Ÿ
Ÿ
 
this
Ÿ
Ÿ
 
.
Ÿ
Ÿ
 
BytesBefore
Ÿ
Ÿ
 #
(
Ÿ
Ÿ
# $
this
Ÿ
Ÿ
$ (
.
Ÿ
Ÿ
( )
ReaderIndex
Ÿ
Ÿ
) 4
,
Ÿ
Ÿ
4 5
length
Ÿ
Ÿ
6 <
,
Ÿ
Ÿ
< =
value
Ÿ
Ÿ
> C
)
Ÿ
Ÿ
C D
;
Ÿ
Ÿ
D E
}
 
 
 	
public
¢
¢
 
virtual
¢
¢
 
int
¢
¢
 
BytesBefore
¢
¢
 &
(
¢
¢
& '
int
¢
¢
' *
index
¢
¢
+ 0
,
¢
¢
0 1
int
¢
¢
2 5
length
¢
¢
6 <
,
¢
¢
< =
byte
¢
¢
> B
value
¢
¢
C H
)
¢
¢
H I
{
£
£
 	
int
¤
¤
 
endIndex
¤
¤
 
=
¤
¤
 
this
¤
¤
 
.
¤
¤
  
IndexOf
¤
¤
  '
(
¤
¤
' (
index
¤
¤
( -
,
¤
¤
- .
index
¤
¤
/ 4
+
¤
¤
5 6
length
¤
¤
7 =
,
¤
¤
= >
value
¤
¤
? D
)
¤
¤
D E
;
¤
¤
E F
if
¥
¥
 
(
¥
¥
 
endIndex
¥
¥
 
<
¥
¥
 
$num
¥
¥
 
)
¥
¥
 
{
¦
¦
 
return
§
§
 
-
§
§
 
$num
§
§
 
;
§
§
 
}
¨
¨
 
return
ª
ª
 
endIndex
ª
ª
 
-
ª
ª
 
index
ª
ª
 #
;
ª
ª
# $
}
«
«
 	
public
­
­
 
virtual
­
­
 
int
­
­
 
ForEachByte
­
­
 &
(
­
­
& '
IByteProcessor
­
­
' 5
	processor
­
­
6 ?
)
­
­
? @
{
®
®
 	
this
¯
¯
 
.
¯
¯
 
EnsureAccessible
¯
¯
 !
(
¯
¯
! "
)
¯
¯
" #
;
¯
¯
# $
return
°
°
 
this
°
°
 
.
°
°
 
ForEachByteAsc0
°
°
 '
(
°
°
' (
this
°
°
( ,
.
°
°
, -
readerIndex
°
°
- 8
,
°
°
8 9
this
°
°
: >
.
°
°
> ?
writerIndex
°
°
? J
,
°
°
J K
	processor
°
°
L U
)
°
°
U V
;
°
°
V W
}
±
±
 	
public
³
³
 
virtual
³
³
 
int
³
³
 
ForEachByte
³
³
 &
(
³
³
& '
int
³
³
' *
index
³
³
+ 0
,
³
³
0 1
int
³
³
2 5
length
³
³
6 <
,
³
³
< =
IByteProcessor
³
³
> L
	processor
³
³
M V
)
³
³
V W
{
´
´
 	
this
µ
µ
 
.
µ
µ
 

CheckIndex
µ
µ
 
(
µ
µ
 
index
µ
µ
 !
,
µ
µ
! "
length
µ
µ
# )
)
µ
µ
) *
;
µ
µ
* +
return
¶
¶
 
this
¶
¶
 
.
¶
¶
 
ForEachByteAsc0
¶
¶
 '
(
¶
¶
' (
index
¶
¶
( -
,
¶
¶
- .
index
¶
¶
/ 4
+
¶
¶
5 6
length
¶
¶
7 =
,
¶
¶
= >
	processor
¶
¶
? H
)
¶
¶
H I
;
¶
¶
I J
}
·
·
 	
int
¹
¹
 
ForEachByteAsc0
¹
¹
 
(
¹
¹
 
int
¹
¹
 
start
¹
¹
  %
,
¹
¹
% &
int
¹
¹
' *
end
¹
¹
+ .
,
¹
¹
. /
IByteProcessor
¹
¹
0 >
	processor
¹
¹
? H
)
¹
¹
H I
{
º
º
 	
for
»
»
 
(
»
»
 
;
»
»
 
start
»
»
 
<
»
»
 
end
»
»
 
;
»
»
 
++
»
»
  "
start
»
»
" '
)
»
»
' (
{
¼
¼
 
if
½
½
 
(
½
½
 
!
½
½
 
	processor
½
½
 
.
½
½
 
Process
½
½
 &
(
½
½
& '
this
½
½
' +
.
½
½
+ ,
_GetByte
½
½
, 4
(
½
½
4 5
start
½
½
5 :
)
½
½
: ;
)
½
½
; <
)
½
½
< =
{
¾
¾
 
return
¿
¿
 
start
¿
¿
  
;
¿
¿
  !
}
À
À
 
}
Á
Á
 
return
Ã
Ã
 
-
Ã
Ã
 
$num
Ã
Ã
 
;
Ã
Ã
 
}
Ä
Ä
 	
public
Æ
Æ
 
virtual
Æ
Æ
 
int
Æ
Æ
 
ForEachByteDesc
Æ
Æ
 *
(
Æ
Æ
* +
IByteProcessor
Æ
Æ
+ 9
	processor
Æ
Æ
: C
)
Æ
Æ
C D
{
Ç
Ç
 	
this
È
È
 
.
È
È
 
EnsureAccessible
È
È
 !
(
È
È
! "
)
È
È
" #
;
È
È
# $
return
É
É
 
this
É
É
 
.
É
É
 
ForEachByteDesc0
É
É
 (
(
É
É
( )
this
É
É
) -
.
É
É
- .
writerIndex
É
É
. 9
-
É
É
: ;
$num
É
É
< =
,
É
É
= >
this
É
É
? C
.
É
É
C D
readerIndex
É
É
D O
,
É
É
O P
	processor
É
É
Q Z
)
É
É
Z [
;
É
É
[ \
}
Ê
Ê
 	
public
Ì
Ì
 
virtual
Ì
Ì
 
int
Ì
Ì
 
ForEachByteDesc
Ì
Ì
 *
(
Ì
Ì
* +
int
Ì
Ì
+ .
index
Ì
Ì
/ 4
,
Ì
Ì
4 5
int
Ì
Ì
6 9
length
Ì
Ì
: @
,
Ì
Ì
@ A
IByteProcessor
Ì
Ì
B P
	processor
Ì
Ì
Q Z
)
Ì
Ì
Z [
{
Í
Í
 	
this
Î
Î
 
.
Î
Î
 

CheckIndex
Î
Î
 
(
Î
Î
 
index
Î
Î
 !
,
Î
Î
! "
length
Î
Î
# )
)
Î
Î
) *
;
Î
Î
* +
return
Ï
Ï
 
this
Ï
Ï
 
.
Ï
Ï
 
ForEachByteDesc0
Ï
Ï
 (
(
Ï
Ï
( )
index
Ï
Ï
) .
+
Ï
Ï
/ 0
length
Ï
Ï
1 7
-
Ï
Ï
8 9
$num
Ï
Ï
: ;
,
Ï
Ï
; <
index
Ï
Ï
= B
,
Ï
Ï
B C
	processor
Ï
Ï
D M
)
Ï
Ï
M N
;
Ï
Ï
N O
}
Ğ
Ğ
 	
int
Ò
Ò
 
ForEachByteDesc0
Ò
Ò
 
(
Ò
Ò
 
int
Ò
Ò
  
rStart
Ò
Ò
! '
,
Ò
Ò
' (
int
Ò
Ò
) ,
rEnd
Ò
Ò
- 1
,
Ò
Ò
1 2
IByteProcessor
Ò
Ò
3 A
	processor
Ò
Ò
B K
)
Ò
Ò
K L
{
Ó
Ó
 	
for
Ô
Ô
 
(
Ô
Ô
 
;
Ô
Ô
 
rStart
Ô
Ô
 
>=
Ô
Ô
 
rEnd
Ô
Ô
 !
;
Ô
Ô
! "
--
Ô
Ô
# %
rStart
Ô
Ô
% +
)
Ô
Ô
+ ,
{
Õ
Õ
 
if
Ö
Ö
 
(
Ö
Ö
 
!
Ö
Ö
 
	processor
Ö
Ö
 
.
Ö
Ö
 
Process
Ö
Ö
 &
(
Ö
Ö
& '
this
Ö
Ö
' +
.
Ö
Ö
+ ,
_GetByte
Ö
Ö
, 4
(
Ö
Ö
4 5
rStart
Ö
Ö
5 ;
)
Ö
Ö
; <
)
Ö
Ö
< =
)
Ö
Ö
= >
{
×
×
 
return
Ø
Ø
 
rStart
Ø
Ø
 !
;
Ø
Ø
! "
}
Ù
Ù
 
}
Ú
Ú
 
return
Ü
Ü
 
-
Ü
Ü
 
$num
Ü
Ü
 
;
Ü
Ü
 
}
İ
İ
 	
public
ß
ß
 
override
ß
ß
 
int
ß
ß
 
GetHashCode
ß
ß
 '
(
ß
ß
' (
)
ß
ß
( )
=>
ß
ß
* ,
ByteBufferUtil
ß
ß
- ;
.
ß
ß
; <
HashCode
ß
ß
< D
(
ß
ß
D E
this
ß
ß
E I
)
ß
ß
I J
;
ß
ß
J K
public
á
á
 
sealed
á
á
 
override
á
á
 
bool
á
á
 #
Equals
á
á
$ *
(
á
á
* +
object
á
á
+ 1
o
á
á
2 3
)
á
á
3 4
=>
á
á
5 7
this
á
á
8 <
.
á
á
< =
Equals
á
á
= C
(
á
á
C D
o
á
á
D E
as
á
á
F H
IByteBuffer
á
á
I T
)
á
á
T U
;
á
á
U V
public
ã
ã
 
virtual
ã
ã
 
bool
ã
ã
 
Equals
ã
ã
 "
(
ã
ã
" #
IByteBuffer
ã
ã
# .
buffer
ã
ã
/ 5
)
ã
ã
5 6
=>
ã
ã
7 9
ReferenceEquals
ä
ä
 
(
ä
ä
 
this
ä
ä
  
,
ä
ä
  !
buffer
ä
ä
" (
)
ä
ä
( )
||
ä
ä
* ,
buffer
ä
ä
- 3
!=
ä
ä
4 6
null
ä
ä
7 ;
&&
ä
ä
< >
ByteBufferUtil
ä
ä
? M
.
ä
ä
M N
Equals
ä
ä
N T
(
ä
ä
T U
this
ä
ä
U Y
,
ä
ä
Y Z
buffer
ä
ä
[ a
)
ä
ä
a b
;
ä
ä
b c
public
æ
æ
 
virtual
æ
æ
 
int
æ
æ
 
	CompareTo
æ
æ
 $
(
æ
æ
$ %
IByteBuffer
æ
æ
% 0
that
æ
æ
1 5
)
æ
æ
5 6
=>
æ
æ
7 9
ByteBufferUtil
æ
æ
: H
.
æ
æ
H I
Compare
æ
æ
I P
(
æ
æ
P Q
this
æ
æ
Q U
,
æ
æ
U V
that
æ
æ
W [
)
æ
æ
[ \
;
æ
æ
\ ]
public
è
è
 
override
è
è
 
string
è
è
 
ToString
è
è
 '
(
è
è
' (
)
è
è
( )
{
é
é
 	
if
ê
ê
 
(
ê
ê
 
this
ê
ê
 
.
ê
ê
 
ReferenceCount
ê
ê
 #
==
ê
ê
$ &
$num
ê
ê
' (
)
ê
ê
( )
{
ë
ë
 
return
ì
ì
 

StringUtil
ì
ì
 !
.
ì
ì
! "
SimpleClassName
ì
ì
" 1
(
ì
ì
1 2
this
ì
ì
2 6
)
ì
ì
6 7
+
ì
ì
8 9
$str
ì
ì
: C
;
ì
ì
C D
}
í
í
 
StringBuilder
ï
ï
 
buf
ï
ï
 
=
ï
ï
 
new
ï
ï
  #
StringBuilder
ï
ï
$ 1
(
ï
ï
1 2
)
ï
ï
2 3
.
ğ
ğ
 
Append
ğ
ğ
 
(
ğ
ğ
 

StringUtil
ğ
ğ
 "
.
ğ
ğ
" #
SimpleClassName
ğ
ğ
# 2
(
ğ
ğ
2 3
this
ğ
ğ
3 7
)
ğ
ğ
7 8
)
ğ
ğ
8 9
.
ñ
ñ
 
Append
ñ
ñ
 
(
ñ
ñ
 
$str
ñ
ñ
 !
)
ñ
ñ
! "
.
ñ
ñ
" #
Append
ñ
ñ
# )
(
ñ
ñ
) *
this
ñ
ñ
* .
.
ñ
ñ
. /
readerIndex
ñ
ñ
/ :
)
ñ
ñ
: ;
.
ò
ò
 
Append
ò
ò
 
(
ò
ò
 
$str
ò
ò
 "
)
ò
ò
" #
.
ò
ò
# $
Append
ò
ò
$ *
(
ò
ò
* +
this
ò
ò
+ /
.
ò
ò
/ 0
writerIndex
ò
ò
0 ;
)
ò
ò
; <
.
ó
ó
 
Append
ó
ó
 
(
ó
ó
 
$str
ó
ó
 !
)
ó
ó
! "
.
ó
ó
" #
Append
ó
ó
# )
(
ó
ó
) *
this
ó
ó
* .
.
ó
ó
. /
Capacity
ó
ó
/ 7
)
ó
ó
7 8
;
ó
ó
8 9
if
ô
ô
 
(
ô
ô
 
this
ô
ô
 
.
ô
ô
 
MaxCapacity
ô
ô
  
!=
ô
ô
! #
int
ô
ô
$ '
.
ô
ô
' (
MaxValue
ô
ô
( 0
)
ô
ô
0 1
{
õ
õ
 
buf
ö
ö
 
.
ö
ö
 
Append
ö
ö
 
(
ö
ö
 
$char
ö
ö
 
)
ö
ö
 
.
ö
ö
  
Append
ö
ö
  &
(
ö
ö
& '
this
ö
ö
' +
.
ö
ö
+ ,
MaxCapacity
ö
ö
, 7
)
ö
ö
7 8
;
ö
ö
8 9
}
÷
÷
 
IByteBuffer
ù
ù
 
	unwrapped
ù
ù
 !
=
ù
ù
" #
this
ù
ù
$ (
.
ù
ù
( )
Unwrap
ù
ù
) /
(
ù
ù
/ 0
)
ù
ù
0 1
;
ù
ù
1 2
if
ú
ú
 
(
ú
ú
 
	unwrapped
ú
ú
 
!=
ú
ú
 
null
ú
ú
 !
)
ú
ú
! "
{
û
û
 
buf
ü
ü
 
.
ü
ü
 
Append
ü
ü
 
(
ü
ü
 
$str
ü
ü
 *
)
ü
ü
* +
.
ü
ü
+ ,
Append
ü
ü
, 2
(
ü
ü
2 3
	unwrapped
ü
ü
3 <
)
ü
ü
< =
;
ü
ü
= >
}
ı
ı
 
buf
ş
ş
 
.
ş
ş
 
Append
ş
ş
 
(
ş
ş
 
$char
ş
ş
 
)
ş
ş
 
;
ş
ş
 
return
ÿ
ÿ
 
buf
ÿ
ÿ
 
.
ÿ
ÿ
 
ToString
ÿ
ÿ
 
(
ÿ
ÿ
  
)
ÿ
ÿ
  !
;
ÿ
ÿ
! "
}
€€ 	
	protected
‚‚ 
void
‚‚ 

CheckIndex
‚‚ !
(
‚‚! "
int
‚‚" %
index
‚‚& +
)
‚‚+ ,
=>
‚‚- /
this
‚‚0 4
.
‚‚4 5

CheckIndex
‚‚5 ?
(
‚‚? @
index
‚‚@ E
,
‚‚E F
$num
‚‚G H
)
‚‚H I
;
‚‚I J
	protected
„„ 
internal
„„ 
void
„„ 

CheckIndex
„„  *
(
„„* +
int
„„+ .
index
„„/ 4
,
„„4 5
int
„„6 9
fieldLength
„„: E
)
„„E F
{
…… 	
this
†† 
.
†† 
EnsureAccessible
†† !
(
††! "
)
††" #
;
††# $
this
‡‡ 
.
‡‡ 
CheckIndex0
‡‡ 
(
‡‡ 
index
‡‡ "
,
‡‡" #
fieldLength
‡‡$ /
)
‡‡/ 0
;
‡‡0 1
}
ˆˆ 	
[
ŠŠ 	

MethodImpl
ŠŠ	 
(
ŠŠ 
MethodImplOptions
ŠŠ %
.
ŠŠ% & 
AggressiveInlining
ŠŠ& 8
)
ŠŠ8 9
]
ŠŠ9 :
	protected
‹‹ 
void
‹‹ 
CheckIndex0
‹‹ "
(
‹‹" #
int
‹‹# &
index
‹‹' ,
,
‹‹, -
int
‹‹. 1
fieldLength
‹‹2 =
)
‹‹= >
{
ŒŒ 	
if
 
(
 
MathUtil
 
.
 
IsOutOfBounds
 &
(
& '
index
' ,
,
, -
fieldLength
. 9
,
9 :
this
; ?
.
? @
Capacity
@ H
)
H I
)
I J
{
 
ThrowHelper
 
.
 1
#ThrowIndexOutOfRangeException_Index
 ?
(
? @
index
@ E
,
E F
fieldLength
G R
,
R S
this
T X
.
X Y
Capacity
Y a
)
a b
;
b c
}
 
}
‘‘ 	
[
““ 	

MethodImpl
““	 
(
““ 
MethodImplOptions
““ %
.
““% & 
AggressiveInlining
““& 8
)
““8 9
]
““9 :
	protected
”” 
void
”” 
CheckSrcIndex
”” $
(
””$ %
int
””% (
index
””) .
,
””. /
int
””0 3
length
””4 :
,
””: ;
int
””< ?
srcIndex
””@ H
,
””H I
int
””J M
srcCapacity
””N Y
)
””Y Z
{
•• 	
this
–– 
.
–– 

CheckIndex
–– 
(
–– 
index
–– !
,
––! "
length
––# )
)
––) *
;
––* +
if
—— 
(
—— 
MathUtil
—— 
.
—— 
IsOutOfBounds
—— &
(
——& '
srcIndex
——' /
,
——/ 0
length
——1 7
,
——7 8
srcCapacity
——9 D
)
——D E
)
——E F
{
˜˜ 
ThrowHelper
™™ 
.
™™ 4
&ThrowIndexOutOfRangeException_SrcIndex
™™ B
(
™™B C
srcIndex
™™C K
,
™™K L
length
™™M S
,
™™S T
srcCapacity
™™U `
)
™™` a
;
™™a b
}
šš 
}
›› 	
[
 	

MethodImpl
	 
(
 
MethodImplOptions
 %
.
% & 
AggressiveInlining
& 8
)
8 9
]
9 :
	protected
 
void
 
CheckDstIndex
 $
(
$ %
int
% (
index
) .
,
. /
int
0 3
length
4 :
,
: ;
int
< ?
dstIndex
@ H
,
H I
int
J M
dstCapacity
N Y
)
Y Z
{
ŸŸ 	
this
   
.
   

CheckIndex
   
(
   
index
   !
,
  ! "
length
  # )
)
  ) *
;
  * +
if
¡¡ 
(
¡¡ 
MathUtil
¡¡ 
.
¡¡ 
IsOutOfBounds
¡¡ &
(
¡¡& '
dstIndex
¡¡' /
,
¡¡/ 0
length
¡¡1 7
,
¡¡7 8
dstCapacity
¡¡9 D
)
¡¡D E
)
¡¡E F
{
¢¢ 
ThrowHelper
££ 
.
££ 4
&ThrowIndexOutOfRangeException_DstIndex
££ B
(
££B C
dstIndex
££C K
,
££K L
length
££M S
,
££S T
dstCapacity
££U `
)
££` a
;
££a b
}
¤¤ 
}
¥¥ 	
	protected
§§ 
void
§§  
CheckReadableBytes
§§ )
(
§§) *
int
§§* -"
minimumReadableBytes
§§. B
)
§§B C
{
¨¨ 	
if
©© 
(
©© "
minimumReadableBytes
©© $
<
©©% &
$num
©©' (
)
©©( )
{
ªª 
ThrowHelper
«« 
.
«« C
5ThrowArgumentOutOfRangeException_MinimumReadableBytes
«« Q
(
««Q R"
minimumReadableBytes
««R f
)
««f g
;
««g h
}
¬¬ 
this
®® 
.
®® !
CheckReadableBytes0
®® $
(
®®$ %"
minimumReadableBytes
®®% 9
)
®®9 :
;
®®: ;
}
¯¯ 	
	protected
±± 
void
±± 
CheckNewCapacity
±± '
(
±±' (
int
±±( +
newCapacity
±±, 7
)
±±7 8
{
²² 	
this
³³ 
.
³³ 
EnsureAccessible
³³ !
(
³³! "
)
³³" #
;
³³# $
if
´´ 
(
´´ 
newCapacity
´´ 
<
´´ 
$num
´´ 
||
´´  "
newCapacity
´´# .
>
´´/ 0
this
´´1 5
.
´´5 6
MaxCapacity
´´6 A
)
´´A B
{
µµ 
ThrowHelper
¶¶ 
.
¶¶ 7
)ThrowArgumentOutOfRangeException_Capacity
¶¶ E
(
¶¶E F
newCapacity
¶¶F Q
,
¶¶Q R
this
¶¶S W
.
¶¶W X
MaxCapacity
¶¶X c
)
¶¶c d
;
¶¶d e
}
·· 
}
¸¸ 	
[
ºº 	

MethodImpl
ºº	 
(
ºº 
MethodImplOptions
ºº %
.
ºº% & 
AggressiveInlining
ºº& 8
)
ºº8 9
]
ºº9 :
void
»» !
CheckReadableBytes0
»»  
(
»»  !
int
»»! $"
minimumReadableBytes
»»% 9
)
»»9 :
{
¼¼ 	
this
½½ 
.
½½ 
EnsureAccessible
½½ !
(
½½! "
)
½½" #
;
½½# $
if
¾¾ 
(
¾¾ 
this
¾¾ 
.
¾¾ 
readerIndex
¾¾  
>
¾¾! "
this
¾¾# '
.
¾¾' (
writerIndex
¾¾( 3
-
¾¾4 5"
minimumReadableBytes
¾¾6 J
)
¾¾J K
{
¿¿ 
ThrowHelper
ÀÀ 
.
ÀÀ 7
)ThrowIndexOutOfRangeException_ReaderIndex
ÀÀ E
(
ÀÀE F"
minimumReadableBytes
ÀÀF Z
,
ÀÀZ [
this
ÀÀ\ `
.
ÀÀ` a
readerIndex
ÀÀa l
,
ÀÀl m
this
ÀÀn r
.
ÀÀr s
writerIndex
ÀÀs ~
,
ÀÀ~ 
thisÀÀ€ „
)ÀÀ„ …
;ÀÀ… †
}
ÁÁ 
}
ÂÂ 	
[
ÄÄ 	

MethodImpl
ÄÄ	 
(
ÄÄ 
MethodImplOptions
ÄÄ %
.
ÄÄ% & 
AggressiveInlining
ÄÄ& 8
)
ÄÄ8 9
]
ÄÄ9 :
	protected
ÅÅ 
void
ÅÅ 
EnsureAccessible
ÅÅ '
(
ÅÅ' (
)
ÅÅ( )
{
ÆÆ 	
if
ÇÇ 
(
ÇÇ 
CheckAccessible
ÇÇ 
&&
ÇÇ  "
this
ÇÇ# '
.
ÇÇ' (
ReferenceCount
ÇÇ( 6
==
ÇÇ7 9
$num
ÇÇ: ;
)
ÇÇ; <
{
ÈÈ 
ThrowHelper
ÉÉ 
.
ÉÉ 1
#ThrowIllegalReferenceCountException
ÉÉ ?
(
ÉÉ? @
$num
ÉÉ@ A
)
ÉÉA B
;
ÉÉB C
}
ÊÊ 
}
ËË 	
	protected
ÍÍ 
void
ÍÍ 
	SetIndex0
ÍÍ  
(
ÍÍ  !
int
ÍÍ! $
	readerIdx
ÍÍ% .
,
ÍÍ. /
int
ÍÍ0 3
	writerIdx
ÍÍ4 =
)
ÍÍ= >
{
ÎÎ 	
this
ÏÏ 
.
ÏÏ 
readerIndex
ÏÏ 
=
ÏÏ 
	readerIdx
ÏÏ (
;
ÏÏ( )
this
ĞĞ 
.
ĞĞ 
writerIndex
ĞĞ 
=
ĞĞ 
	writerIdx
ĞĞ (
;
ĞĞ( )
}
ÑÑ 	
	protected
ÓÓ 
void
ÓÓ 
DiscardMarks
ÓÓ #
(
ÓÓ# $
)
ÓÓ$ %
{
ÔÔ 	
this
ÕÕ 
.
ÕÕ 
markedReaderIndex
ÕÕ "
=
ÕÕ# $
this
ÕÕ% )
.
ÕÕ) *
markedWriterIndex
ÕÕ* ;
=
ÕÕ< =
$num
ÕÕ> ?
;
ÕÕ? @
}
ÖÖ 	
public
ØØ 
abstract
ØØ 
int
ØØ 
IoBufferCount
ØØ )
{
ØØ* +
get
ØØ, /
;
ØØ/ 0
}
ØØ1 2
public
ÚÚ 
ArraySegment
ÚÚ 
<
ÚÚ 
byte
ÚÚ  
>
ÚÚ  !
GetIoBuffer
ÚÚ" -
(
ÚÚ- .
)
ÚÚ. /
=>
ÚÚ0 2
this
ÚÚ3 7
.
ÚÚ7 8
GetIoBuffer
ÚÚ8 C
(
ÚÚC D
this
ÚÚD H
.
ÚÚH I
readerIndex
ÚÚI T
,
ÚÚT U
this
ÚÚV Z
.
ÚÚZ [
ReadableBytes
ÚÚ[ h
)
ÚÚh i
;
ÚÚi j
public
ÜÜ 
abstract
ÜÜ 
ArraySegment
ÜÜ $
<
ÜÜ$ %
byte
ÜÜ% )
>
ÜÜ) *
GetIoBuffer
ÜÜ+ 6
(
ÜÜ6 7
int
ÜÜ7 :
index
ÜÜ; @
,
ÜÜ@ A
int
ÜÜB E
length
ÜÜF L
)
ÜÜL M
;
ÜÜM N
public
ŞŞ 
ArraySegment
ŞŞ 
<
ŞŞ 
byte
ŞŞ  
>
ŞŞ  !
[
ŞŞ! "
]
ŞŞ" #
GetIoBuffers
ŞŞ$ 0
(
ŞŞ0 1
)
ŞŞ1 2
=>
ŞŞ3 5
this
ŞŞ6 :
.
ŞŞ: ;
GetIoBuffers
ŞŞ; G
(
ŞŞG H
this
ŞŞH L
.
ŞŞL M
readerIndex
ŞŞM X
,
ŞŞX Y
this
ŞŞZ ^
.
ŞŞ^ _
ReadableBytes
ŞŞ_ l
)
ŞŞl m
;
ŞŞm n
public
àà 
abstract
àà 
ArraySegment
àà $
<
àà$ %
byte
àà% )
>
àà) *
[
àà* +
]
àà+ ,
GetIoBuffers
àà- 9
(
àà9 :
int
àà: =
index
àà> C
,
ààC D
int
ààE H
length
ààI O
)
ààO P
;
ààP Q
public
ââ 
abstract
ââ 
bool
ââ 
HasArray
ââ %
{
ââ& '
get
ââ( +
;
ââ+ ,
}
ââ- .
public
ää 
abstract
ää 
byte
ää 
[
ää 
]
ää 
Array
ää $
{
ää% &
get
ää' *
;
ää* +
}
ää, -
public
ææ 
abstract
ææ 
int
ææ 
ArrayOffset
ææ '
{
ææ( )
get
ææ* -
;
ææ- .
}
ææ/ 0
public
èè 
abstract
èè 
bool
èè 
HasMemoryAddress
èè -
{
èè. /
get
èè0 3
;
èè3 4
}
èè5 6
public
êê 
abstract
êê 
ref
êê 
byte
êê  &
GetPinnableMemoryAddress
êê! 9
(
êê9 :
)
êê: ;
;
êê; <
public
ìì 
abstract
ìì 
IntPtr
ìì #
AddressOfPinnedMemory
ìì 4
(
ìì4 5
)
ìì5 6
;
ìì6 7
public
îî 
abstract
îî 
IByteBuffer
îî #
Unwrap
îî$ *
(
îî* +
)
îî+ ,
;
îî, -
public
ğğ 
abstract
ğğ 
bool
ğğ 
IsDirect
ğğ %
{
ğğ& '
get
ğğ( +
;
ğğ+ ,
}
ğğ- .
public
òò 
abstract
òò 
int
òò 
ReferenceCount
òò *
{
òò+ ,
get
òò- 0
;
òò0 1
}
òò2 3
public
ôô 
abstract
ôô 
IReferenceCounted
ôô )
Retain
ôô* 0
(
ôô0 1
)
ôô1 2
;
ôô2 3
public
öö 
abstract
öö 
IReferenceCounted
öö )
Retain
öö* 0
(
öö0 1
int
öö1 4
	increment
öö5 >
)
öö> ?
;
öö? @
public
øø 
abstract
øø 
IReferenceCounted
øø )
Touch
øø* /
(
øø/ 0
)
øø0 1
;
øø1 2
public
úú 
abstract
úú 
IReferenceCounted
úú )
Touch
úú* /
(
úú/ 0
object
úú0 6
hint
úú7 ;
)
úú; <
;
úú< =
public
üü 
abstract
üü 
bool
üü 
Release
üü $
(
üü$ %
)
üü% &
;
üü& '
public
şş 
abstract
şş 
bool
şş 
Release
şş $
(
şş$ %
int
şş% (
	decrement
şş) 2
)
şş2 3
;
şş3 4
}
ÿÿ 
}€€ ¿‘
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class '
AbstractByteBufferAllocator 5
:6 7 
IByteBufferAllocator8 L
{ 
public 
const 
int "
DefaultInitialCapacity /
=0 1
$num2 5
;5 6
public 
const 
int  
DefaultMaxComponents -
=. /
$num0 2
;2 3
public 
const 
int 
DefaultMaxCapacity +
=, -
int. 1
.1 2
MaxValue2 :
;: ;
const 
int 
CalculateThreshold $
=% &
$num' .
*/ 0
$num1 2
;2 3
	protected 
static 
IByteBuffer $
ToLeakAwareBuffer% 6
(6 7
IByteBuffer7 B
bufC F
)F G
{ 	 
IResourceLeakTracker  
leak! %
;% &
switch 
(  
ResourceLeakDetector (
.( )
Level) .
). /
{ 
case  
ResourceLeakDetector )
.) *
DetectionLevel* 8
.8 9
Simple9 ?
:? @
leak 
= 
AbstractByteBuffer -
.- .
LeakDetector. :
.: ;
Track; @
(@ A
bufA D
)D E
;E F
if 
( 
leak 
!= 
null  $
)$ %
{ 
buf 
= 
new !%
SimpleLeakAwareByteBuffer" ;
(; <
buf< ?
,? @
leakA E
)E F
;F G
} 
break   
;   
case!!  
ResourceLeakDetector!! )
.!!) *
DetectionLevel!!* 8
.!!8 9
Advanced!!9 A
:!!A B
case""  
ResourceLeakDetector"" )
."") *
DetectionLevel""* 8
.""8 9
Paranoid""9 A
:""A B
leak## 
=## 
AbstractByteBuffer## -
.##- .
LeakDetector##. :
.##: ;
Track##; @
(##@ A
buf##A D
)##D E
;##E F
if$$ 
($$ 
leak$$ 
!=$$ 
null$$  $
)$$$ %
{%% 
buf&& 
=&& 
new&& !'
AdvancedLeakAwareByteBuffer&&" =
(&&= >
buf&&> A
,&&A B
leak&&C G
)&&G H
;&&H I
}'' 
break(( 
;(( 
case))  
ResourceLeakDetector)) )
.))) *
DetectionLevel))* 8
.))8 9
Disabled))9 A
:))A B
break** 
;** 
default++ 
:++ 
throw,, 
new,, '
ArgumentOutOfRangeException,, 9
(,,9 :
),,: ;
;,,; <
}-- 
return// 
buf// 
;// 
}00 	
	protected22 
static22 
CompositeByteBuffer22 ,
ToLeakAwareBuffer22- >
(22> ?
CompositeByteBuffer22? R
buf22S V
)22V W
{33 	 
IResourceLeakTracker44  
leak44! %
;44% &
switch55 
(55  
ResourceLeakDetector55 (
.55( )
Level55) .
)55. /
{66 
case77  
ResourceLeakDetector77 )
.77) *
DetectionLevel77* 8
.778 9
Simple779 ?
:77? @
leak88 
=88 
AbstractByteBuffer88 -
.88- .
LeakDetector88. :
.88: ;
Track88; @
(88@ A
buf88A D
)88D E
;88E F
if99 
(99 
leak99 
!=99 
null99  $
)99$ %
{:: 
buf;; 
=;; 
new;; !.
"SimpleLeakAwareCompositeByteBuffer;;" D
(;;D E
buf;;E H
,;;H I
leak;;J N
);;N O
;;;O P
}<< 
break== 
;== 
case>>  
ResourceLeakDetector>> )
.>>) *
DetectionLevel>>* 8
.>>8 9
Advanced>>9 A
:>>A B
case??  
ResourceLeakDetector?? )
.??) *
DetectionLevel??* 8
.??8 9
Paranoid??9 A
:??A B
leak@@ 
=@@ 
AbstractByteBuffer@@ -
.@@- .
LeakDetector@@. :
.@@: ;
Track@@; @
(@@@ A
buf@@A D
)@@D E
;@@E F
ifAA 
(AA 
leakAA 
!=AA 
nullAA  $
)AA$ %
{BB 
bufCC 
=CC 
newCC !0
$AdvancedLeakAwareCompositeByteBufferCC" F
(CCF G
bufCCG J
,CCJ K
leakCCL P
)CCP Q
;CCQ R
}DD 
breakEE 
;EE 
caseFF  
ResourceLeakDetectorFF )
.FF) *
DetectionLevelFF* 8
.FF8 9
DisabledFF9 A
:FFA B
breakGG 
;GG 
defaultHH 
:HH 
throwII 
newII '
ArgumentOutOfRangeExceptionII 9
(II9 :
)II: ;
;II; <
}JJ 
returnLL 
bufLL 
;LL 
}MM 	
readonlyOO 
boolOO 
directByDefaultOO %
;OO% &
readonlyPP 
IByteBufferPP 
emptyBufferPP (
;PP( )
	protectedRR '
AbstractByteBufferAllocatorRR -
(RR- .
)RR. /
{SS 	
thisTT 
.TT 
emptyBufferTT 
=TT 
newTT "
EmptyByteBufferTT# 2
(TT2 3
thisTT3 7
)TT7 8
;TT8 9
}UU 	
	protectedWW '
AbstractByteBufferAllocatorWW -
(WW- .
boolWW. 2
preferDirectWW3 ?
)WW? @
{XX 	
thisYY 
.YY 
directByDefaultYY  
=YY! "
preferDirectYY# /
;YY/ 0
thisZZ 
.ZZ 
emptyBufferZZ 
=ZZ 
newZZ "
EmptyByteBufferZZ# 2
(ZZ2 3
thisZZ3 7
)ZZ7 8
;ZZ8 9
}[[ 	
public]] 
IByteBuffer]] 
Buffer]] !
(]]! "
)]]" #
=>]]$ &
this]]' +
.]]+ ,
directByDefault]], ;
?]]< =
this]]> B
.]]B C
DirectBuffer]]C O
(]]O P
)]]P Q
:]]R S
this]]T X
.]]X Y

HeapBuffer]]Y c
(]]c d
)]]d e
;]]e f
public__ 
IByteBuffer__ 
Buffer__ !
(__! "
int__" %
initialCapacity__& 5
)__5 6
=>__7 9
this`` 
.`` 
directByDefault``  
?``! "
this``# '
.``' (
DirectBuffer``( 4
(``4 5
initialCapacity``5 D
)``D E
:``F G
this``H L
.``L M

HeapBuffer``M W
(``W X
initialCapacity``X g
)``g h
;``h i
publicbb 
IByteBufferbb 
Bufferbb !
(bb! "
intbb" %
initialCapacitybb& 5
,bb5 6
intbb7 :
maxCapacitybb; F
)bbF G
=>bbH J
thiscc 
.cc 
directByDefaultcc  
?cc! "
thiscc# '
.cc' (
DirectBuffercc( 4
(cc4 5
initialCapacitycc5 D
,ccD E
maxCapacityccF Q
)ccQ R
:ccS T
thisccU Y
.ccY Z

HeapBufferccZ d
(ccd e
initialCapacitycce t
,cct u
maxCapacity	ccv 
)
cc ‚
;
cc‚ ƒ
publicee 
IByteBufferee 

HeapBufferee %
(ee% &
)ee& '
=>ee( *
thisee+ /
.ee/ 0

HeapBufferee0 :
(ee: ;"
DefaultInitialCapacityee; Q
,eeQ R
DefaultMaxCapacityeeS e
)eee f
;eef g
publicgg 
IByteBuffergg 

HeapBuffergg %
(gg% &
intgg& )
initialCapacitygg* 9
)gg9 :
=>gg; =
thisgg> B
.ggB C

HeapBufferggC M
(ggM N
initialCapacityggN ]
,gg] ^
DefaultMaxCapacitygg_ q
)ggq r
;ggr s
publicii 
IByteBufferii 

HeapBufferii %
(ii% &
intii& )
initialCapacityii* 9
,ii9 :
intii; >
maxCapacityii? J
)iiJ K
{jj 	
ifkk 
(kk 
initialCapacitykk 
==kk  "
$numkk# $
&&kk% '
maxCapacitykk( 3
==kk4 6
$numkk7 8
)kk8 9
{ll 
returnmm 
thismm 
.mm 
emptyBuffermm '
;mm' (
}nn 
Validatepp 
(pp 
initialCapacitypp $
,pp$ %
maxCapacitypp& 1
)pp1 2
;pp2 3
returnqq 
thisqq 
.qq 
NewHeapBufferqq %
(qq% &
initialCapacityqq& 5
,qq5 6
maxCapacityqq7 B
)qqB C
;qqC D
}rr 	
publictt 
unsafett 
IByteBuffertt !
DirectBuffertt" .
(tt. /
)tt/ 0
=>tt1 3
thistt4 8
.tt8 9
DirectBuffertt9 E
(ttE F"
DefaultInitialCapacityttF \
,tt\ ]
DefaultMaxCapacitytt^ p
)ttp q
;ttq r
publicvv 
unsafevv 
IByteBuffervv !
DirectBuffervv" .
(vv. /
intvv/ 2
initialCapacityvv3 B
)vvB C
=>vvD F
thisvvG K
.vvK L
DirectBuffervvL X
(vvX Y
initialCapacityvvY h
,vvh i
DefaultMaxCapacityvvj |
)vv| }
;vv} ~
publicxx 
unsafexx 
IByteBufferxx !
DirectBufferxx" .
(xx. /
intxx/ 2
initialCapacityxx3 B
,xxB C
intxxD G
maxCapacityxxH S
)xxS T
{yy 	
ifzz 
(zz 
initialCapacityzz 
==zz  "
$numzz# $
&&zz% '
maxCapacityzz( 3
==zz4 6
$numzz7 8
)zz8 9
{{{ 
return|| 
this|| 
.|| 
emptyBuffer|| '
;||' (
}}} 
Validate~~ 
(~~ 
initialCapacity~~ $
,~~$ %
maxCapacity~~& 1
)~~1 2
;~~2 3
return 
this 
. 
NewDirectBuffer '
(' (
initialCapacity( 7
,7 8
maxCapacity9 D
)D E
;E F
}
€€ 	
public
‚‚ !
CompositeByteBuffer
‚‚ "
CompositeBuffer
‚‚# 2
(
‚‚2 3
)
‚‚3 4
=>
‚‚5 7
this
ƒƒ 
.
ƒƒ 
directByDefault
ƒƒ  
?
ƒƒ! "
this
ƒƒ# '
.
ƒƒ' (#
CompositeDirectBuffer
ƒƒ( =
(
ƒƒ= >
)
ƒƒ> ?
:
ƒƒ@ A
this
ƒƒB F
.
ƒƒF G!
CompositeHeapBuffer
ƒƒG Z
(
ƒƒZ [
)
ƒƒ[ \
;
ƒƒ\ ]
public
…… !
CompositeByteBuffer
…… "
CompositeBuffer
……# 2
(
……2 3
int
……3 6
maxComponents
……7 D
)
……D E
=>
……F H
this
†† 
.
†† 
directByDefault
††  
?
††! "
this
††# '
.
††' (#
CompositeDirectBuffer
††( =
(
††= >
maxComponents
††> K
)
††K L
:
††M N
this
††O S
.
††S T!
CompositeHeapBuffer
††T g
(
††g h
maxComponents
††h u
)
††u v
;
††v w
public
ˆˆ !
CompositeByteBuffer
ˆˆ "!
CompositeHeapBuffer
ˆˆ# 6
(
ˆˆ6 7
)
ˆˆ7 8
=>
ˆˆ9 ;
this
ˆˆ< @
.
ˆˆ@ A!
CompositeHeapBuffer
ˆˆA T
(
ˆˆT U"
DefaultMaxComponents
ˆˆU i
)
ˆˆi j
;
ˆˆj k
public
ŠŠ 
virtual
ŠŠ !
CompositeByteBuffer
ŠŠ *!
CompositeHeapBuffer
ŠŠ+ >
(
ŠŠ> ?
int
ŠŠ? B
maxNumComponents
ŠŠC S
)
ŠŠS T
=>
ŠŠU W
ToLeakAwareBuffer
‹‹ 
(
‹‹ 
new
‹‹ !!
CompositeByteBuffer
‹‹" 5
(
‹‹5 6
this
‹‹6 :
,
‹‹: ;
false
‹‹< A
,
‹‹A B
maxNumComponents
‹‹C S
)
‹‹S T
)
‹‹T U
;
‹‹U V
public
 
unsafe
 !
CompositeByteBuffer
 )#
CompositeDirectBuffer
* ?
(
? @
)
@ A
=>
B D
this
E I
.
I J#
CompositeDirectBuffer
J _
(
_ `"
DefaultMaxComponents
` t
)
t u
;
u v
public
 
unsafe
 
virtual
 !
CompositeByteBuffer
 1#
CompositeDirectBuffer
2 G
(
G H
int
H K
maxNumComponents
L \
)
\ ]
=>
^ `
ToLeakAwareBuffer
 
(
 
new
 !!
CompositeByteBuffer
" 5
(
5 6
this
6 :
,
: ;
true
< @
,
@ A
maxNumComponents
B R
)
R S
)
S T
;
T U
[
’’ 	

MethodImpl
’’	 
(
’’ 
MethodImplOptions
’’ %
.
’’% & 
AggressiveInlining
’’& 8
)
’’8 9
]
’’9 :
static
““ 
void
““ 
Validate
““ 
(
““ 
int
““  
initialCapacity
““! 0
,
““0 1
int
““2 5
maxCapacity
““6 A
)
““A B
{
”” 	
if
•• 
(
•• 
initialCapacity
•• 
<
••  !
$num
••" #
)
••# $
{
–– 
ThrowHelper
—— 
.
—— >
0ThrowArgumentOutOfRangeException_InitialCapacity
—— L
(
——L M
)
——M N
;
——N O
}
˜˜ 
if
šš 
(
šš 
initialCapacity
šš 
>
šš  !
maxCapacity
šš" -
)
šš- .
{
›› 
ThrowHelper
œœ 
.
œœ >
0ThrowArgumentOutOfRangeException_InitialCapacity
œœ L
(
œœL M
initialCapacity
œœM \
,
œœ\ ]
maxCapacity
œœ^ i
)
œœi j
;
œœj k
}
 
}
 	
	protected
   
abstract
   
IByteBuffer
   &
NewHeapBuffer
  ' 4
(
  4 5
int
  5 8
initialCapacity
  9 H
,
  H I
int
  J M
maxCapacity
  N Y
)
  Y Z
;
  Z [
	protected
¢¢ 
unsafe
¢¢ 
abstract
¢¢ !
IByteBuffer
¢¢" -
NewDirectBuffer
¢¢. =
(
¢¢= >
int
¢¢> A
initialCapacity
¢¢B Q
,
¢¢Q R
int
¢¢S V
maxCapacity
¢¢W b
)
¢¢b c
;
¢¢c d
public
¤¤ 
abstract
¤¤ 
bool
¤¤ "
IsDirectBufferPooled
¤¤ 1
{
¤¤2 3
get
¤¤4 7
;
¤¤7 8
}
¤¤9 :
public
¦¦ 
int
¦¦ "
CalculateNewCapacity
¦¦ '
(
¦¦' (
int
¦¦( +
minNewCapacity
¦¦, :
,
¦¦: ;
int
¦¦< ?
maxCapacity
¦¦@ K
)
¦¦K L
{
§§ 	
if
¨¨ 
(
¨¨ 
minNewCapacity
¨¨ 
<
¨¨  
$num
¨¨! "
)
¨¨" #
{
©© 
ThrowHelper
ªª 
.
ªª =
/ThrowArgumentOutOfRangeException_MinNewCapacity
ªª K
(
ªªK L
minNewCapacity
ªªL Z
)
ªªZ [
;
ªª[ \
}
«« 
if
¬¬ 
(
¬¬ 
minNewCapacity
¬¬ 
>
¬¬  
maxCapacity
¬¬! ,
)
¬¬, -
{
­­ 
ThrowHelper
®® 
.
®® :
,ThrowArgumentOutOfRangeException_MaxCapacity
®® H
(
®®H I
minNewCapacity
®®I W
,
®®W X
maxCapacity
®®Y d
)
®®d e
;
®®e f
}
¯¯ 
const
±± 
int
±± 
	Threshold
±± 
=
±±  ! 
CalculateThreshold
±±" 4
;
±±4 5
if
²² 
(
²² 
minNewCapacity
²² 
==
²² ! 
CalculateThreshold
²²" 4
)
²²4 5
{
³³ 
return
´´ 
	Threshold
´´  
;
´´  !
}
µµ 
int
·· 
newCapacity
·· 
;
·· 
if
¹¹ 
(
¹¹ 
minNewCapacity
¹¹ 
>
¹¹  
	Threshold
¹¹! *
)
¹¹* +
{
ºº 
newCapacity
»» 
=
»» 
minNewCapacity
»» ,
/
»»- .
	Threshold
»»/ 8
*
»»9 :
	Threshold
»»; D
;
»»D E
if
¼¼ 
(
¼¼ 
newCapacity
¼¼ 
>
¼¼  !
maxCapacity
¼¼" -
-
¼¼. /
	Threshold
¼¼0 9
)
¼¼9 :
{
½½ 
newCapacity
¾¾ 
=
¾¾  !
maxCapacity
¾¾" -
;
¾¾- .
}
¿¿ 
else
ÀÀ 
{
ÁÁ 
newCapacity
ÂÂ 
+=
ÂÂ  "
	Threshold
ÂÂ# ,
;
ÂÂ, -
}
ÃÃ 
return
ÅÅ 
newCapacity
ÅÅ "
;
ÅÅ" #
}
ÆÆ 
newCapacity
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
while
ÊÊ 
(
ÊÊ 
newCapacity
ÊÊ 
<
ÊÊ  
minNewCapacity
ÊÊ! /
)
ÊÊ/ 0
{
ËË 
newCapacity
ÌÌ 
<<=
ÌÌ 
$num
ÌÌ  !
;
ÌÌ! "
}
ÍÍ 
return
ÏÏ 
Math
ÏÏ 
.
ÏÏ 
Min
ÏÏ 
(
ÏÏ 
newCapacity
ÏÏ '
,
ÏÏ' (
maxCapacity
ÏÏ) 4
)
ÏÏ4 5
;
ÏÏ5 6
}
ĞĞ 	
}
ÑÑ 
}ÒÒ ß/
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractDerivedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class %
AbstractDerivedByteBuffer 3
:4 5
AbstractByteBuffer6 H
{ 
	protected %
AbstractDerivedByteBuffer +
(+ ,
int, /
maxCapacity0 ;
); <
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
sealed 
override 
int "
ReferenceCount# 1
=>2 4
this5 9
.9 :
ReferenceCount0: I
(I J
)J K
;K L
	protected 
virtual 
int 
ReferenceCount0 -
(- .
). /
=>0 2
this3 7
.7 8
Unwrap8 >
(> ?
)? @
.@ A
ReferenceCountA O
;O P
public 
sealed 
override 
IReferenceCounted 0
Retain1 7
(7 8
)8 9
=>: <
this= A
.A B
Retain0B I
(I J
)J K
;K L
	protected 
virtual 
IByteBuffer %
Retain0& -
(- .
). /
{ 	
this 
. 
Unwrap 
( 
) 
. 
Retain  
(  !
)! "
;" #
return 
this 
; 
} 	
public!! 
sealed!! 
override!! 
IReferenceCounted!! 0
Retain!!1 7
(!!7 8
int!!8 ;
	increment!!< E
)!!E F
=>!!G I
this!!J N
.!!N O
Retain0!!O V
(!!V W
	increment!!W `
)!!` a
;!!a b
	protected## 
virtual## 
IByteBuffer## %
Retain0##& -
(##- .
int##. 1
	increment##2 ;
)##; <
{$$ 	
this%% 
.%% 
Unwrap%% 
(%% 
)%% 
.%% 
Retain%%  
(%%  !
	increment%%! *
)%%* +
;%%+ ,
return&& 
this&& 
;&& 
}'' 	
public)) 
sealed)) 
override)) 
IReferenceCounted)) 0
Touch))1 6
())6 7
)))7 8
=>))9 ;
this))< @
.))@ A
Touch0))A G
())G H
)))H I
;))I J
	protected++ 
virtual++ 
IByteBuffer++ %
Touch0++& ,
(++, -
)++- .
{,, 	
this-- 
.-- 
Unwrap-- 
(-- 
)-- 
.-- 
Touch-- 
(--  
)--  !
;--! "
return.. 
this.. 
;.. 
}// 	
public11 
sealed11 
override11 
IReferenceCounted11 0
Touch111 6
(116 7
object117 =
hint11> B
)11B C
=>11D F
this11G K
.11K L
Touch011L R
(11R S
hint11S W
)11W X
;11X Y
	protected33 
virtual33 
IByteBuffer33 %
Touch033& ,
(33, -
object33- 3
hint334 8
)338 9
{44 	
this55 
.55 
Unwrap55 
(55 
)55 
.55 
Touch55 
(55  
hint55  $
)55$ %
;55% &
return66 
this66 
;66 
}77 	
public99 
sealed99 
override99 
bool99 #
Release99$ +
(99+ ,
)99, -
=>99. 0
this991 5
.995 6
Release0996 >
(99> ?
)99? @
;99@ A
	protected;; 
virtual;; 
bool;; 
Release0;; '
(;;' (
);;( )
=>;;* ,
this;;- 1
.;;1 2
Unwrap;;2 8
(;;8 9
);;9 :
.;;: ;
Release;;; B
(;;B C
);;C D
;;;D E
public== 
sealed== 
override== 
bool== #
Release==$ +
(==+ ,
int==, /
	decrement==0 9
)==9 :
=>==; =
this==> B
.==B C
Release0==C K
(==K L
	decrement==L U
)==U V
;==V W
	protected?? 
virtual?? 
bool?? 
Release0?? '
(??' (
int??( +
	decrement??, 5
)??5 6
=>??7 9
this??: >
.??> ?
Unwrap??? E
(??E F
)??F G
.??G H
Release??H O
(??O P
	decrement??P Y
)??Y Z
;??Z [
publicAA 
overrideAA 
ArraySegmentAA $
<AA$ %
byteAA% )
>AA) *
GetIoBufferAA+ 6
(AA6 7
intAA7 :
indexAA; @
,AA@ A
intAAB E
lengthAAF L
)AAL M
=>AAN P
thisAAQ U
.AAU V
UnwrapAAV \
(AA\ ]
)AA] ^
.AA^ _
GetIoBufferAA_ j
(AAj k
indexAAk p
,AAp q
lengthAAr x
)AAx y
;AAy z
publicCC 
overrideCC 
ArraySegmentCC $
<CC$ %
byteCC% )
>CC) *
[CC* +
]CC+ ,
GetIoBuffersCC- 9
(CC9 :
intCC: =
indexCC> C
,CCC D
intCCE H
lengthCCI O
)CCO P
=>CCQ S
thisCCT X
.CCX Y
UnwrapCCY _
(CC_ `
)CC` a
.CCa b
GetIoBuffersCCb n
(CCn o
indexCCo t
,CCt u
lengthCCv |
)CC| }
;CC} ~
}EE 
}FF È£
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractPooledDerivedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract

 
class

 +
AbstractPooledDerivedByteBuffer

 2
:

3 4.
"AbstractReferenceCountedByteBuffer

5 W
{ 
readonly 
ThreadLocalPool  
.  !
Handle! '
recyclerHandle( 6
;6 7
AbstractByteBuffer 

rootParent %
;% &
IByteBuffer 
parent 
; 
	protected +
AbstractPooledDerivedByteBuffer 1
(1 2
ThreadLocalPool2 A
.A B
HandleB H
recyclerHandleI W
)W X
: 
base 
( 
$num 
) 
{ 	
this 
. 
recyclerHandle 
=  !
recyclerHandle" 0
;0 1
} 	
internal 
void 
Parent 
( 
IByteBuffer (
	newParent) 2
)2 3
{ 	
Debug 
. 
Assert 
( 
	newParent "
is# %%
SimpleLeakAwareByteBuffer& ?
)? @
;@ A
this   
.   
parent   
=   
	newParent   #
;  # $
}!! 	
public## 
sealed## 
override## 
IByteBuffer## *
Unwrap##+ 1
(##1 2
)##2 3
=>##4 6
this##7 ;
.##; <

UnwrapCore##< F
(##F G
)##G H
;##H I
	protected%% 
AbstractByteBuffer%% $

UnwrapCore%%% /
(%%/ 0
)%%0 1
=>%%2 4
this%%5 9
.%%9 :

rootParent%%: D
;%%D E
internal'' 
T'' 
Init'' 
<'' 
T'' 
>'' 
('' 
AbstractByteBuffer(( 
	unwrapped(( (
,((( )
IByteBuffer((* 5
wrapped((6 =
,((= >
int((? B
readerIndex((C N
,((N O
int((P S
writerIndex((T _
,((_ `
int((a d
maxCapacity((e p
)((p q
where)) 
T)) 
:)) +
AbstractPooledDerivedByteBuffer)) 5
{** 	
wrapped++ 
.++ 
Retain++ 
(++ 
)++ 
;++ 
this,, 
.,, 
parent,, 
=,, 
wrapped,, !
;,,! "
this-- 
.-- 

rootParent-- 
=-- 
	unwrapped-- '
;--' (
try// 
{00 
this11 
.11 
SetMaxCapacity11 #
(11# $
maxCapacity11$ /
)11/ 0
;110 1
this22 
.22 
	SetIndex022 
(22 
readerIndex22 *
,22* +
writerIndex22, 7
)227 8
;228 9
this33 
.33 
SetReferenceCount33 &
(33& '
$num33' (
)33( )
;33) *
wrapped55 
=55 
null55 
;55 
return66 
(66 
T66 
)66 
this66 
;66 
}77 
finally88 
{99 
if:: 
(:: 
wrapped:: 
!=:: 
null:: #
)::# $
{;; 
this<< 
.<< 
parent<< 
=<<  !
this<<" &
.<<& '

rootParent<<' 1
=<<2 3
null<<4 8
;<<8 9
wrapped== 
.== 
Release== #
(==# $
)==$ %
;==% &
}>> 
}?? 
}@@ 	
	protectedBB 
internalBB 
sealedBB !
overrideBB" *
voidBB+ /

DeallocateBB0 :
(BB: ;
)BB; <
{CC 	
IByteBufferGG 
	parentBufGG !
=GG" #
thisGG$ (
.GG( )
parentGG) /
;GG/ 0
thisHH 
.HH 
recyclerHandleHH 
.HH  
ReleaseHH  '
(HH' (
thisHH( ,
)HH, -
;HH- .
	parentBufII 
.II 
ReleaseII 
(II 
)II 
;II  
}JJ 	
publicLL 
sealedLL 
overrideLL  
IByteBufferAllocatorLL 3
	AllocatorLL4 =
=>LL> @
thisLLA E
.LLE F
UnwrapLLF L
(LLL M
)LLM N
.LLN O
	AllocatorLLO X
;LLX Y
publicNN 
sealedNN 
overrideNN 
boolNN #
IsDirectNN$ ,
=>NN- /
thisNN0 4
.NN4 5
UnwrapNN5 ;
(NN; <
)NN< =
.NN= >
IsDirectNN> F
;NNF G
publicPP 
overridePP 
boolPP 
HasArrayPP %
=>PP& (
thisPP) -
.PP- .
UnwrapPP. 4
(PP4 5
)PP5 6
.PP6 7
HasArrayPP7 ?
;PP? @
publicRR 
overrideRR 
byteRR 
[RR 
]RR 
ArrayRR $
=>RR% '
thisRR( ,
.RR, -
UnwrapRR- 3
(RR3 4
)RR4 5
.RR5 6
ArrayRR6 ;
;RR; <
publicTT 
overrideTT 
boolTT 
HasMemoryAddressTT -
=>TT. 0
thisTT1 5
.TT5 6
UnwrapTT6 <
(TT< =
)TT= >
.TT> ?
HasMemoryAddressTT? O
;TTO P
publicVV 
sealedVV 
overrideVV 
intVV "
IoBufferCountVV# 0
=>VV1 3
thisVV4 8
.VV8 9
UnwrapVV9 ?
(VV? @
)VV@ A
.VVA B
IoBufferCountVVB O
;VVO P
publicXX 
sealedXX 
overrideXX 
IByteBufferXX *
RetainedSliceXX+ 8
(XX8 9
)XX9 :
{YY 	
intZZ 
indexZZ 
=ZZ 
thisZZ 
.ZZ 
ReaderIndexZZ (
;ZZ( )
return[[ 
base[[ 
.[[ 
RetainedSlice[[ %
([[% &
index[[& +
,[[+ ,
this[[- 1
.[[1 2
WriterIndex[[2 =
-[[> ?
index[[@ E
)[[E F
;[[F G
}\\ 	
public^^ 
override^^ 
IByteBuffer^^ #
Slice^^$ )
(^^) *
int^^* -
index^^. 3
,^^3 4
int^^5 8
length^^9 ?
)^^? @
{__ 	
returnaa 
newaa -
!PooledNonRetainedSlicedByteBufferaa 8
(aa8 9
thisaa9 =
,aa= >
(aa? @
AbstractByteBufferaa@ R
)aaR S
thisaaS W
.aaW X
UnwrapaaX ^
(aa^ _
)aa_ `
,aa` a
indexaab g
,aag h
lengthaai o
)aao p
;aap q
}bb 	
	protecteddd 
IByteBufferdd 

Duplicate0dd (
(dd( )
)dd) *
{ee 	
returngg 
newgg 0
$PooledNonRetainedDuplicateByteBuffergg ;
(gg; <
thisgg< @
,gg@ A
(ggB C
AbstractByteBufferggC U
)ggU V
thisggV Z
.ggZ [
Unwrapgg[ a
(gga b
)ggb c
)ggc d
;ggd e
}hh 	
sealedjj 
classjj 0
$PooledNonRetainedDuplicateByteBufferjj 9
:jj: ;(
UnpooledDuplicatedByteBufferjj< X
{kk 	
readonlyll 
IReferenceCountedll &"
referenceCountDelegatell' =
;ll= >
internalnn 0
$PooledNonRetainedDuplicateByteBuffernn 9
(nn9 :
IReferenceCountednn: K"
referenceCountDelegatennL b
,nnb c
AbstractByteBuffernnd v
buffernnw }
)nn} ~
:oo 
baseoo 
(oo 
bufferoo 
)oo 
{pp 
thisqq 
.qq "
referenceCountDelegateqq +
=qq, -"
referenceCountDelegateqq. D
;qqD E
}rr 
	protectedtt 
overridett 
inttt "
ReferenceCount0tt# 2
(tt2 3
)tt3 4
=>tt5 7
thistt8 <
.tt< ="
referenceCountDelegatett= S
.ttS T
ReferenceCountttT b
;ttb c
	protectedvv 
overridevv 
IByteBuffervv *
Retain0vv+ 2
(vv2 3
)vv3 4
{ww 
thisxx 
.xx "
referenceCountDelegatexx +
.xx+ ,
Retainxx, 2
(xx2 3
)xx3 4
;xx4 5
returnyy 
thisyy 
;yy 
}zz 
	protected|| 
override|| 
IByteBuffer|| *
Retain0||+ 2
(||2 3
int||3 6
	increment||7 @
)||@ A
{}} 
this~~ 
.~~ "
referenceCountDelegate~~ +
.~~+ ,
Retain~~, 2
(~~2 3
	increment~~3 <
)~~< =
;~~= >
return 
this 
; 
}
€€ 
	protected
‚‚ 
override
‚‚ 
IByteBuffer
‚‚ *
Touch0
‚‚+ 1
(
‚‚1 2
)
‚‚2 3
{
ƒƒ 
this
„„ 
.
„„ $
referenceCountDelegate
„„ +
.
„„+ ,
Touch
„„, 1
(
„„1 2
)
„„2 3
;
„„3 4
return
…… 
this
…… 
;
…… 
}
†† 
	protected
ˆˆ 
override
ˆˆ 
IByteBuffer
ˆˆ *
Touch0
ˆˆ+ 1
(
ˆˆ1 2
object
ˆˆ2 8
hint
ˆˆ9 =
)
ˆˆ= >
{
‰‰ 
this
ŠŠ 
.
ŠŠ $
referenceCountDelegate
ŠŠ +
.
ŠŠ+ ,
Touch
ŠŠ, 1
(
ŠŠ1 2
hint
ŠŠ2 6
)
ŠŠ6 7
;
ŠŠ7 8
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
ŒŒ 
	protected
 
override
 
bool
 #
Release0
$ ,
(
, -
)
- .
=>
/ 1
this
2 6
.
6 7$
referenceCountDelegate
7 M
.
M N
Release
N U
(
U V
)
V W
;
W X
	protected
 
override
 
bool
 #
Release0
$ ,
(
, -
int
- 0
	decrement
1 :
)
: ;
=>
< >
this
? C
.
C D$
referenceCountDelegate
D Z
.
Z [
Release
[ b
(
b c
	decrement
c l
)
l m
;
m n
public
’’ 
override
’’ 
IByteBuffer
’’ '
	Duplicate
’’( 1
(
’’1 2
)
’’2 3
=>
’’4 6
new
’’7 :2
$PooledNonRetainedDuplicateByteBuffer
’’; _
(
’’_ `
this
’’` d
.
’’d e$
referenceCountDelegate
’’e {
,
’’{ |
this’’} 
)’’ ‚
;’’‚ ƒ
public
”” 
override
”” 
IByteBuffer
”” '
RetainedDuplicate
””( 9
(
””9 :
)
””: ;
=>
””< >(
PooledDuplicatedByteBuffer
””? Y
.
””Y Z
NewInstance
””Z e
(
””e f
this
””f j
.
””j k

UnwrapCore
””k u
(
””u v
)
””v w
,
””w x
this
””y }
,
””} ~
this”” ƒ
.””ƒ „
ReaderIndex””„ 
,”” 
this””‘ •
.””• –
WriterIndex””– ¡
)””¡ ¢
;””¢ £
public
–– 
override
–– 
IByteBuffer
–– '
Slice
––( -
(
––- .
int
––. 1
index
––2 7
,
––7 8
int
––9 <
length
––= C
)
––C D
{
—— 
this
˜˜ 
.
˜˜ 
CheckIndex0
˜˜  
(
˜˜  !
index
˜˜! &
,
˜˜& '
length
˜˜( .
)
˜˜. /
;
˜˜/ 0
return
™™ 
new
™™ /
!PooledNonRetainedSlicedByteBuffer
™™ <
(
™™< =
this
™™= A
.
™™A B$
referenceCountDelegate
™™B X
,
™™X Y
(
™™Z [ 
AbstractByteBuffer
™™[ m
)
™™m n
this
™™n r
.
™™r s
Unwrap
™™s y
(
™™y z
)
™™z {
,
™™{ |
index™™} ‚
,™™‚ ƒ
length™™„ Š
)™™Š ‹
;™™‹ Œ
}
šš 
public
 
override
 
IByteBuffer
 '
RetainedSlice
( 5
(
5 6
)
6 7
=>
8 :
this
; ?
.
? @
RetainedSlice
@ M
(
M N
this
N R
.
R S
ReaderIndex
S ^
,
^ _
this
` d
.
d e
Capacity
e m
)
m n
;
n o
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ '
RetainedSlice
ŸŸ( 5
(
ŸŸ5 6
int
ŸŸ6 9
index
ŸŸ: ?
,
ŸŸ? @
int
ŸŸA D
length
ŸŸE K
)
ŸŸK L
=>
ŸŸM O$
PooledSlicedByteBuffer
ŸŸP f
.
ŸŸf g
NewInstance
ŸŸg r
(
ŸŸr s
this
ŸŸs w
.
ŸŸw x

UnwrapCoreŸŸx ‚
(ŸŸ‚ ƒ
)ŸŸƒ „
,ŸŸ„ …
thisŸŸ† Š
,ŸŸŠ ‹
indexŸŸŒ ‘
,ŸŸ‘ ’
lengthŸŸ“ ™
)ŸŸ™ š
;ŸŸš ›
}
   	
sealed
¢¢ 
class
¢¢ /
!PooledNonRetainedSlicedByteBuffer
¢¢ 6
:
¢¢7 8&
UnpooledSlicedByteBuffer
¢¢9 Q
{
££ 	
readonly
¤¤ 
IReferenceCounted
¤¤ &$
referenceCountDelegate
¤¤' =
;
¤¤= >
public
¦¦ /
!PooledNonRetainedSlicedByteBuffer
¦¦ 4
(
¦¦4 5
IReferenceCounted
¦¦5 F$
referenceCountDelegate
¦¦G ]
,
¦¦] ^ 
AbstractByteBuffer
¦¦_ q
buffer
¦¦r x
,
¦¦x y
int
¦¦z }
index¦¦~ ƒ
,¦¦ƒ „
int¦¦… ˆ
length¦¦‰ 
)¦¦ 
:
§§ 
base
§§ 
(
§§ 
buffer
§§ 
,
§§ 
index
§§ $
,
§§$ %
length
§§& ,
)
§§, -
{
¨¨ 
this
©© 
.
©© $
referenceCountDelegate
©© +
=
©©, -$
referenceCountDelegate
©©. D
;
©©D E
}
ªª 
	protected
¬¬ 
override
¬¬ 
int
¬¬ "
ReferenceCount0
¬¬# 2
(
¬¬2 3
)
¬¬3 4
=>
¬¬5 7
this
¬¬8 <
.
¬¬< =$
referenceCountDelegate
¬¬= S
.
¬¬S T
ReferenceCount
¬¬T b
;
¬¬b c
	protected
®® 
override
®® 
IByteBuffer
®® *
Retain0
®®+ 2
(
®®2 3
)
®®3 4
{
¯¯ 
this
°° 
.
°° $
referenceCountDelegate
°° +
.
°°+ ,
Retain
°°, 2
(
°°2 3
)
°°3 4
;
°°4 5
return
±± 
this
±± 
;
±± 
}
²² 
	protected
´´ 
override
´´ 
IByteBuffer
´´ *
Retain0
´´+ 2
(
´´2 3
int
´´3 6
	increment
´´7 @
)
´´@ A
{
µµ 
this
¶¶ 
.
¶¶ $
referenceCountDelegate
¶¶ +
.
¶¶+ ,
Retain
¶¶, 2
(
¶¶2 3
	increment
¶¶3 <
)
¶¶< =
;
¶¶= >
return
·· 
this
·· 
;
·· 
}
¸¸ 
	protected
ºº 
override
ºº 
IByteBuffer
ºº *
Touch0
ºº+ 1
(
ºº1 2
)
ºº2 3
{
»» 
this
¼¼ 
.
¼¼ $
referenceCountDelegate
¼¼ +
.
¼¼+ ,
Touch
¼¼, 1
(
¼¼1 2
)
¼¼2 3
;
¼¼3 4
return
½½ 
this
½½ 
;
½½ 
}
¾¾ 
	protected
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ *
Touch0
ÀÀ+ 1
(
ÀÀ1 2
object
ÀÀ2 8
hint
ÀÀ9 =
)
ÀÀ= >
{
ÁÁ 
this
ÂÂ 
.
ÂÂ $
referenceCountDelegate
ÂÂ +
.
ÂÂ+ ,
Touch
ÂÂ, 1
(
ÂÂ1 2
hint
ÂÂ2 6
)
ÂÂ6 7
;
ÂÂ7 8
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÄÄ 
	protected
ÆÆ 
override
ÆÆ 
bool
ÆÆ #
Release0
ÆÆ$ ,
(
ÆÆ, -
)
ÆÆ- .
=>
ÆÆ/ 1
this
ÆÆ2 6
.
ÆÆ6 7$
referenceCountDelegate
ÆÆ7 M
.
ÆÆM N
Release
ÆÆN U
(
ÆÆU V
)
ÆÆV W
;
ÆÆW X
	protected
ÈÈ 
override
ÈÈ 
bool
ÈÈ #
Release0
ÈÈ$ ,
(
ÈÈ, -
int
ÈÈ- 0
	decrement
ÈÈ1 :
)
ÈÈ: ;
=>
ÈÈ< >
this
ÈÈ? C
.
ÈÈC D$
referenceCountDelegate
ÈÈD Z
.
ÈÈZ [
Release
ÈÈ[ b
(
ÈÈb c
	decrement
ÈÈc l
)
ÈÈl m
;
ÈÈm n
public
ÊÊ 
override
ÊÊ 
IByteBuffer
ÊÊ '
	Duplicate
ÊÊ( 1
(
ÊÊ1 2
)
ÊÊ2 3
=>
ÊÊ4 6
new
ËË 2
$PooledNonRetainedDuplicateByteBuffer
ËË 8
(
ËË8 9
this
ËË9 =
.
ËË= >$
referenceCountDelegate
ËË> T
,
ËËT U
this
ËËV Z
.
ËËZ [

UnwrapCore
ËË[ e
(
ËËe f
)
ËËf g
)
ËËg h
.
ÌÌ 
SetIndex
ÌÌ 
(
ÌÌ 
this
ÌÌ "
.
ÌÌ" #
Idx
ÌÌ# &
(
ÌÌ& '
this
ÌÌ' +
.
ÌÌ+ ,
ReaderIndex
ÌÌ, 7
)
ÌÌ7 8
,
ÌÌ8 9
this
ÌÌ: >
.
ÌÌ> ?
Idx
ÌÌ? B
(
ÌÌB C
this
ÌÌC G
.
ÌÌG H
WriterIndex
ÌÌH S
)
ÌÌS T
)
ÌÌT U
;
ÌÌU V
public
ÎÎ 
override
ÎÎ 
IByteBuffer
ÎÎ '
RetainedDuplicate
ÎÎ( 9
(
ÎÎ9 :
)
ÎÎ: ;
=>
ÎÎ< >(
PooledDuplicatedByteBuffer
ÎÎ? Y
.
ÎÎY Z
NewInstance
ÎÎZ e
(
ÎÎe f
this
ÎÎf j
.
ÎÎj k

UnwrapCore
ÎÎk u
(
ÎÎu v
)
ÎÎv w
,
ÎÎw x
this
ÎÎy }
,
ÎÎ} ~
thisÎÎ ƒ
.ÎÎƒ „
IdxÎÎ„ ‡
(ÎÎ‡ ˆ
thisÎÎˆ Œ
.ÎÎŒ 
ReaderIndexÎÎ ˜
)ÎÎ˜ ™
,ÎÎ™ š
thisÎÎ› Ÿ
.ÎÎŸ  
IdxÎÎ  £
(ÎÎ£ ¤
thisÎÎ¤ ¨
.ÎÎ¨ ©
WriterIndexÎÎ© ´
)ÎÎ´ µ
)ÎÎµ ¶
;ÎÎ¶ ·
public
ĞĞ 
override
ĞĞ 
IByteBuffer
ĞĞ '
Slice
ĞĞ( -
(
ĞĞ- .
int
ĞĞ. 1
index
ĞĞ2 7
,
ĞĞ7 8
int
ĞĞ9 <
length
ĞĞ= C
)
ĞĞC D
{
ÑÑ 
this
ÒÒ 
.
ÒÒ 
CheckIndex0
ÒÒ  
(
ÒÒ  !
index
ÒÒ! &
,
ÒÒ& '
length
ÒÒ( .
)
ÒÒ. /
;
ÒÒ/ 0
return
ÓÓ 
new
ÓÓ /
!PooledNonRetainedSlicedByteBuffer
ÓÓ <
(
ÓÓ< =
this
ÓÓ= A
.
ÓÓA B$
referenceCountDelegate
ÓÓB X
,
ÓÓX Y
this
ÓÓZ ^
.
ÓÓ^ _

UnwrapCore
ÓÓ_ i
(
ÓÓi j
)
ÓÓj k
,
ÓÓk l
this
ÓÓm q
.
ÓÓq r
Idx
ÓÓr u
(
ÓÓu v
index
ÓÓv {
)
ÓÓ{ |
,
ÓÓ| }
lengthÓÓ~ „
)ÓÓ„ …
;ÓÓ… †
}
ÔÔ 
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ '
RetainedSlice
ÖÖ( 5
(
ÖÖ5 6
int
ÖÖ6 9
index
ÖÖ: ?
,
ÖÖ? @
int
ÖÖA D
length
ÖÖE K
)
ÖÖK L
=>
ÖÖM O$
PooledSlicedByteBuffer
ÖÖP f
.
ÖÖf g
NewInstance
ÖÖg r
(
ÖÖr s
this
ÖÖs w
.
ÖÖw x

UnwrapCoreÖÖx ‚
(ÖÖ‚ ƒ
)ÖÖƒ „
,ÖÖ„ …
thisÖÖ† Š
,ÖÖŠ ‹
thisÖÖŒ 
.ÖÖ ‘
IdxÖÖ‘ ”
(ÖÖ” •
indexÖÖ• š
)ÖÖš ›
,ÖÖ› œ
lengthÖÖ £
)ÖÖ£ ¤
;ÖÖ¤ ¥
}
×× 	
}
ØØ 
}ÙÙ ù.
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractReferenceCountedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class .
"AbstractReferenceCountedByteBuffer <
:= >
AbstractByteBuffer? Q
{ 
volatile 
int 
referenceCount #
=$ %
$num& '
;' (
	protected .
"AbstractReferenceCountedByteBuffer 4
(4 5
int5 8
maxCapacity9 D
)D E
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
override 
int 
ReferenceCount *
=>+ -
this. 2
.2 3
referenceCount3 A
;A B
	protected 
internal 
void 
SetReferenceCount  1
(1 2
int2 5
value6 ;
); <
=>= ?
this@ D
.D E
referenceCountE S
=T U
valueV [
;[ \
public 
override 
IReferenceCounted )
Retain* 0
(0 1
)1 2
=>3 5
this6 :
.: ;
Retain0; B
(B C
$numC D
)D E
;E F
public 
override 
IReferenceCounted )
Retain* 0
(0 1
int1 4
	increment5 >
)> ?
{ 	
Contract 
. 
Requires 
( 
	increment '
>( )
$num* +
)+ ,
;, -
return!! 
this!! 
.!! 
Retain0!! 
(!!  
	increment!!  )
)!!) *
;!!* +
}"" 	
IReferenceCounted$$ 
Retain0$$ !
($$! "
int$$" %
	increment$$& /
)$$/ 0
{%% 	
while&& 
(&& 
true&& 
)&& 
{'' 
int(( 
refCnt(( 
=(( 
this(( !
.((! "
referenceCount((" 0
;((0 1
int)) 
nextCnt)) 
=)) 
refCnt)) $
+))% &
	increment))' 0
;))0 1
if,, 
(,, 
nextCnt,, 
<=,, 
	increment,, (
),,( )
{-- 
throw.. 
new.. *
IllegalReferenceCountException.. <
(..< =
refCnt..= C
,..C D
	increment..E N
)..N O
;..O P
}// 
if00 
(00 
Interlocked00 
.00  
CompareExchange00  /
(00/ 0
ref000 3
this004 8
.008 9
referenceCount009 G
,00G H
refCnt00I O
+00P Q
	increment00R [
,00[ \
refCnt00] c
)00c d
==00e g
refCnt00h n
)00n o
{11 
break22 
;22 
}33 
}44 
return66 
this66 
;66 
}77 	
public99 
override99 
IReferenceCounted99 )
Touch99* /
(99/ 0
)990 1
=>992 4
this995 9
;999 :
public;; 
override;; 
IReferenceCounted;; )
Touch;;* /
(;;/ 0
object;;0 6
hint;;7 ;
);;; <
=>;;= ?
this;;@ D
;;;D E
public== 
override== 
bool== 
Release== $
(==$ %
)==% &
=>==' )
this==* .
.==. /
Release0==/ 7
(==7 8
$num==8 9
)==9 :
;==: ;
public?? 
override?? 
bool?? 
Release?? $
(??$ %
int??% (
	decrement??) 2
)??2 3
{@@ 	
ContractAA 
.AA 
RequiresAA 
(AA 
	decrementAA '
>AA( )
$numAA* +
)AA+ ,
;AA, -
returnCC 
thisCC 
.CC 
Release0CC  
(CC  !
	decrementCC! *
)CC* +
;CC+ ,
}DD 	
boolFF 
Release0FF 
(FF 
intFF 
	decrementFF #
)FF# $
{GG 	
whileHH 
(HH 
trueHH 
)HH 
{II 
intJJ 
refCntJJ 
=JJ 
thisJJ !
.JJ! "
ReferenceCountJJ" 0
;JJ0 1
ifKK 
(KK 
refCntKK 
<KK 
	decrementKK &
)KK& '
{LL 
throwMM 
newMM *
IllegalReferenceCountExceptionMM <
(MM< =
refCntMM= C
,MMC D
-MME F
	decrementMMF O
)MMO P
;MMP Q
}NN 
ifPP 
(PP 
InterlockedPP 
.PP  
CompareExchangePP  /
(PP/ 0
refPP0 3
thisPP4 8
.PP8 9
referenceCountPP9 G
,PPG H
refCntPPI O
-PPP Q
	decrementPPR [
,PP[ \
refCntPP] c
)PPc d
==PPe g
refCntPPh n
)PPn o
{QQ 
ifRR 
(RR 
refCntRR 
==RR !
	decrementRR" +
)RR+ ,
{SS 
thisTT 
.TT 

DeallocateTT '
(TT' (
)TT( )
;TT) *
returnUU 
trueUU #
;UU# $
}VV 
returnXX 
falseXX  
;XX  !
}YY 
}ZZ 
}[[ 	
	protected]] 
internal]] 
abstract]] #
void]]$ (

Deallocate]]) 3
(]]3 4
)]]4 5
;]]5 6
}^^ 
}__ çÒ
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractUnpooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract 
class ,
 AbstractUnpooledSlicedByteBuffer 3
:4 5%
AbstractDerivedByteBuffer6 O
{ 
readonly 
IByteBuffer 
buffer #
;# $
readonly 
int 

adjustment 
;  
	protected ,
 AbstractUnpooledSlicedByteBuffer 2
(2 3
IByteBuffer3 >
buffer? E
,E F
intG J
indexK P
,P Q
intR U
lengthV \
)\ ]
: 
base 
( 
length 
) 
{ 	!
CheckSliceOutOfBounds !
(! "
index" '
,' (
length) /
,/ 0
buffer1 7
)7 8
;8 9
if 
( 
buffer 
is ,
 AbstractUnpooledSlicedByteBuffer :

byteBuffer; E
)E F
{ 
this 
. 
buffer 
= 

byteBuffer (
.( )
buffer) /
;/ 0
this 
. 

adjustment 
=  !

byteBuffer" ,
., -

adjustment- 7
+8 9
index: ?
;? @
} 
else 
if 
( 
buffer 
is (
UnpooledDuplicatedByteBuffer ;
); <
{ 
this 
. 
buffer 
= 
buffer $
.$ %
Unwrap% +
(+ ,
), -
;- .
this   
.   

adjustment   
=    !
index  " '
;  ' (
}!! 
else"" 
{## 
this$$ 
.$$ 
buffer$$ 
=$$ 
buffer$$ $
;$$$ %
this%% 
.%% 

adjustment%% 
=%%  !
index%%" '
;%%' (
}&& 
this(( 
.(( 
SetWriterIndex0((  
(((  !
length((! '
)((' (
;((( )
})) 	
internal++ 
int++ 
Length++ 
=>++ 
this++ #
.++# $
Capacity++$ ,
;++, -
public-- 
override-- 
IByteBuffer-- #
Unwrap--$ *
(--* +
)--+ ,
=>--- /
this--0 4
.--4 5
buffer--5 ;
;--; <
public// 
override//  
IByteBufferAllocator// ,
	Allocator//- 6
=>//7 9
this//: >
.//> ?
Unwrap//? E
(//E F
)//F G
.//G H
	Allocator//H Q
;//Q R
public11 
override11 
bool11 
IsDirect11 %
=>11& (
this11) -
.11- .
Unwrap11. 4
(114 5
)115 6
.116 7
IsDirect117 ?
;11? @
public33 
override33 
IByteBuffer33 #
AdjustCapacity33$ 2
(332 3
int333 6
newCapacity337 B
)33B C
=>33D F
throw33G L
new33M P!
NotSupportedException33Q f
(33f g
$str33g v
)33v w
;33w x
public55 
override55 
bool55 
HasArray55 %
=>55& (
this55) -
.55- .
Unwrap55. 4
(554 5
)555 6
.556 7
HasArray557 ?
;55? @
public77 
override77 
byte77 
[77 
]77 
Array77 $
=>77% '
this77( ,
.77, -
Unwrap77- 3
(773 4
)774 5
.775 6
Array776 ;
;77; <
public99 
override99 
int99 
ArrayOffset99 '
=>99( *
this99+ /
.99/ 0
Idx990 3
(993 4
this994 8
.998 9
Unwrap999 ?
(99? @
)99@ A
.99A B
ArrayOffset99B M
)99M N
;99N O
public;; 
override;; 
bool;; 
HasMemoryAddress;; -
=>;;. 0
this;;1 5
.;;5 6
Unwrap;;6 <
(;;< =
);;= >
.;;> ?
HasMemoryAddress;;? O
;;;O P
public== 
override== 
ref== 
byte==  $
GetPinnableMemoryAddress==! 9
(==9 :
)==: ;
=>==< >
ref==? B
Unsafe==C I
.==I J
Add==J M
(==M N
ref==N Q
this==R V
.==V W
Unwrap==W ]
(==] ^
)==^ _
.==_ `$
GetPinnableMemoryAddress==` x
(==x y
)==y z
,==z {
this	==| €
.
==€ 

adjustment
== ‹
)
==‹ Œ
;
==Œ 
public?? 
override?? 
IntPtr?? !
AddressOfPinnedMemory?? 4
(??4 5
)??5 6
{@@ 	
IntPtrAA 
ptrAA 
=AA 
thisAA 
.AA 
UnwrapAA $
(AA$ %
)AA% &
.AA& '!
AddressOfPinnedMemoryAA' <
(AA< =
)AA= >
;AA> ?
ifBB 
(BB 
ptrBB 
==BB 
IntPtrBB 
.BB 
ZeroBB "
)BB" #
{CC 
returnDD 
ptrDD 
;DD 
}EE 
returnFF 
ptrFF 
+FF 
thisFF 
.FF 

adjustmentFF (
;FF( )
}GG 	
publicII 
overrideII 
byteII 
GetByteII $
(II$ %
intII% (
indexII) .
)II. /
{JJ 	
thisKK 
.KK 
CheckIndex0KK 
(KK 
indexKK "
,KK" #
$numKK$ %
)KK% &
;KK& '
returnLL 
thisLL 
.LL 
UnwrapLL 
(LL 
)LL  
.LL  !
GetByteLL! (
(LL( )
thisLL) -
.LL- .
IdxLL. 1
(LL1 2
indexLL2 7
)LL7 8
)LL8 9
;LL9 :
}MM 	
	protectedOO 
internalOO 
overrideOO #
byteOO$ (
_GetByteOO) 1
(OO1 2
intOO2 5
indexOO6 ;
)OO; <
=>OO= ?
thisOO@ D
.OOD E
UnwrapOOE K
(OOK L
)OOL M
.OOM N
GetByteOON U
(OOU V
thisOOV Z
.OOZ [
IdxOO[ ^
(OO^ _
indexOO_ d
)OOd e
)OOe f
;OOf g
publicQQ 
overrideQQ 
shortQQ 
GetShortQQ &
(QQ& '
intQQ' *
indexQQ+ 0
)QQ0 1
{RR 	
thisSS 
.SS 
CheckIndex0SS 
(SS 
indexSS "
,SS" #
$numSS$ %
)SS% &
;SS& '
returnTT 
thisTT 
.TT 
UnwrapTT 
(TT 
)TT  
.TT  !
GetShortTT! )
(TT) *
thisTT* .
.TT. /
IdxTT/ 2
(TT2 3
indexTT3 8
)TT8 9
)TT9 :
;TT: ;
}UU 	
	protectedWW 
internalWW 
overrideWW #
shortWW$ )
	_GetShortWW* 3
(WW3 4
intWW4 7
indexWW8 =
)WW= >
=>WW? A
thisWWB F
.WWF G
UnwrapWWG M
(WWM N
)WWN O
.WWO P
GetShortWWP X
(WWX Y
thisWWY ]
.WW] ^
IdxWW^ a
(WWa b
indexWWb g
)WWg h
)WWh i
;WWi j
publicYY 
overrideYY 
shortYY 

GetShortLEYY (
(YY( )
intYY) ,
indexYY- 2
)YY2 3
{ZZ 	
this[[ 
.[[ 
CheckIndex0[[ 
([[ 
index[[ "
,[[" #
$num[[$ %
)[[% &
;[[& '
return\\ 
this\\ 
.\\ 
Unwrap\\ 
(\\ 
)\\  
.\\  !

GetShortLE\\! +
(\\+ ,
this\\, 0
.\\0 1
Idx\\1 4
(\\4 5
index\\5 :
)\\: ;
)\\; <
;\\< =
}]] 	
	protected__ 
internal__ 
override__ #
short__$ )
_GetShortLE__* 5
(__5 6
int__6 9
index__: ?
)__? @
=>__A C
this__D H
.__H I
Unwrap__I O
(__O P
)__P Q
.__Q R

GetShortLE__R \
(__\ ]
this__] a
.__a b
Idx__b e
(__e f
index__f k
)__k l
)__l m
;__m n
publicaa 
overrideaa 
intaa 
GetUnsignedMediumaa -
(aa- .
intaa. 1
indexaa2 7
)aa7 8
{bb 	
thiscc 
.cc 
CheckIndex0cc 
(cc 
indexcc "
,cc" #
$numcc$ %
)cc% &
;cc& '
returndd 
thisdd 
.dd 
Unwrapdd 
(dd 
)dd  
.dd  !
GetUnsignedMediumdd! 2
(dd2 3
thisdd3 7
.dd7 8
Idxdd8 ;
(dd; <
indexdd< A
)ddA B
)ddB C
;ddC D
}ee 	
	protectedgg 
internalgg 
overridegg #
intgg$ '
_GetUnsignedMediumgg( :
(gg: ;
intgg; >
indexgg? D
)ggD E
=>ggF H
thisggI M
.ggM N
UnwrapggN T
(ggT U
)ggU V
.ggV W
GetUnsignedMediumggW h
(ggh i
thisggi m
.ggm n
Idxggn q
(ggq r
indexggr w
)ggw x
)ggx y
;ggy z
publicii 
overrideii 
intii 
GetUnsignedMediumLEii /
(ii/ 0
intii0 3
indexii4 9
)ii9 :
{jj 	
thiskk 
.kk 
CheckIndex0kk 
(kk 
indexkk "
,kk" #
$numkk$ %
)kk% &
;kk& '
returnll 
thisll 
.ll 
Unwrapll 
(ll 
)ll  
.ll  !
GetUnsignedMediumLEll! 4
(ll4 5
thisll5 9
.ll9 :
Idxll: =
(ll= >
indexll> C
)llC D
)llD E
;llE F
}mm 	
	protectedoo 
internaloo 
overrideoo #
intoo$ ' 
_GetUnsignedMediumLEoo( <
(oo< =
intoo= @
indexooA F
)ooF G
=>ooH J
thisooK O
.ooO P
UnwrapooP V
(ooV W
)ooW X
.ooX Y
GetUnsignedMediumLEooY l
(ool m
thisoom q
.ooq r
Idxoor u
(oou v
indexoov {
)oo{ |
)oo| }
;oo} ~
publicqq 
overrideqq 
intqq 
GetIntqq "
(qq" #
intqq# &
indexqq' ,
)qq, -
{rr 	
thisss 
.ss 
CheckIndex0ss 
(ss 
indexss "
,ss" #
$numss$ %
)ss% &
;ss& '
returntt 
thistt 
.tt 
Unwraptt 
(tt 
)tt  
.tt  !
GetInttt! '
(tt' (
thistt( ,
.tt, -
Idxtt- 0
(tt0 1
indextt1 6
)tt6 7
)tt7 8
;tt8 9
}uu 	
	protectedww 
internalww 
overrideww #
intww$ '
_GetIntww( /
(ww/ 0
intww0 3
indexww4 9
)ww9 :
=>ww; =
thisww> B
.wwB C
UnwrapwwC I
(wwI J
)wwJ K
.wwK L
GetIntwwL R
(wwR S
thiswwS W
.wwW X
IdxwwX [
(ww[ \
indexww\ a
)wwa b
)wwb c
;wwc d
publicyy 
overrideyy 
intyy 
GetIntLEyy $
(yy$ %
intyy% (
indexyy) .
)yy. /
{zz 	
this{{ 
.{{ 
CheckIndex0{{ 
({{ 
index{{ "
,{{" #
$num{{$ %
){{% &
;{{& '
return|| 
this|| 
.|| 
Unwrap|| 
(|| 
)||  
.||  !
GetIntLE||! )
(||) *
this||* .
.||. /
Idx||/ 2
(||2 3
index||3 8
)||8 9
)||9 :
;||: ;
}}} 	
	protected 
internal 
override #
int$ '
	_GetIntLE( 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E
UnwrapE K
(K L
)L M
.M N
GetIntLEN V
(V W
thisW [
.[ \
Idx\ _
(_ `
index` e
)e f
)f g
;g h
public
 
override
 
long
 
GetLong
 $
(
$ %
int
% (
index
) .
)
. /
{
‚‚ 	
this
ƒƒ 
.
ƒƒ 
CheckIndex0
ƒƒ 
(
ƒƒ 
index
ƒƒ "
,
ƒƒ" #
$num
ƒƒ$ %
)
ƒƒ% &
;
ƒƒ& '
return
„„ 
this
„„ 
.
„„ 
Unwrap
„„ 
(
„„ 
)
„„  
.
„„  !
GetLong
„„! (
(
„„( )
this
„„) -
.
„„- .
Idx
„„. 1
(
„„1 2
index
„„2 7
)
„„7 8
)
„„8 9
;
„„9 :
}
…… 	
	protected
‡‡ 
internal
‡‡ 
override
‡‡ #
long
‡‡$ (
_GetLong
‡‡) 1
(
‡‡1 2
int
‡‡2 5
index
‡‡6 ;
)
‡‡; <
=>
‡‡= ?
this
‡‡@ D
.
‡‡D E
Unwrap
‡‡E K
(
‡‡K L
)
‡‡L M
.
‡‡M N
GetLong
‡‡N U
(
‡‡U V
this
‡‡V Z
.
‡‡Z [
Idx
‡‡[ ^
(
‡‡^ _
index
‡‡_ d
)
‡‡d e
)
‡‡e f
;
‡‡f g
public
‰‰ 
override
‰‰ 
long
‰‰ 
	GetLongLE
‰‰ &
(
‰‰& '
int
‰‰' *
index
‰‰+ 0
)
‰‰0 1
{
ŠŠ 	
this
‹‹ 
.
‹‹ 
CheckIndex0
‹‹ 
(
‹‹ 
index
‹‹ "
,
‹‹" #
$num
‹‹$ %
)
‹‹% &
;
‹‹& '
return
ŒŒ 
this
ŒŒ 
.
ŒŒ 
Unwrap
ŒŒ 
(
ŒŒ 
)
ŒŒ  
.
ŒŒ  !
	GetLongLE
ŒŒ! *
(
ŒŒ* +
this
ŒŒ+ /
.
ŒŒ/ 0
Idx
ŒŒ0 3
(
ŒŒ3 4
index
ŒŒ4 9
)
ŒŒ9 :
)
ŒŒ: ;
;
ŒŒ; <
}
 	
	protected
 
internal
 
override
 #
long
$ (

_GetLongLE
) 3
(
3 4
int
4 7
index
8 =
)
= >
=>
? A
this
B F
.
F G
Unwrap
G M
(
M N
)
N O
.
O P
	GetLongLE
P Y
(
Y Z
this
Z ^
.
^ _
Idx
_ b
(
b c
index
c h
)
h i
)
i j
;
j k
public
‘‘ 
override
‘‘ 
IByteBuffer
‘‘ #
	Duplicate
‘‘$ -
(
‘‘- .
)
‘‘. /
=>
‘‘0 2
this
‘‘3 7
.
‘‘7 8
Unwrap
‘‘8 >
(
‘‘> ?
)
‘‘? @
.
‘‘@ A
	Duplicate
‘‘A J
(
‘‘J K
)
‘‘K L
.
‘‘L M
SetIndex
‘‘M U
(
‘‘U V
this
‘‘V Z
.
‘‘Z [
Idx
‘‘[ ^
(
‘‘^ _
this
‘‘_ c
.
‘‘c d
ReaderIndex
‘‘d o
)
‘‘o p
,
‘‘p q
this
‘‘r v
.
‘‘v w
Idx
‘‘w z
(
‘‘z {
this
‘‘{ 
.‘‘ €
WriterIndex‘‘€ ‹
)‘‘‹ Œ
)‘‘Œ 
;‘‘ 
public
““ 
override
““ 
IByteBuffer
““ #
Copy
““$ (
(
““( )
int
““) ,
index
““- 2
,
““2 3
int
““4 7
length
““8 >
)
““> ?
{
”” 	
this
•• 
.
•• 
CheckIndex0
•• 
(
•• 
index
•• "
,
••" #
length
••$ *
)
••* +
;
••+ ,
return
–– 
this
–– 
.
–– 
Unwrap
–– 
(
–– 
)
––  
.
––  !
Copy
––! %
(
––% &
this
––& *
.
––* +
Idx
––+ .
(
––. /
index
––/ 4
)
––4 5
,
––5 6
length
––7 =
)
––= >
;
––> ?
}
—— 	
public
™™ 
override
™™ 
IByteBuffer
™™ #
Slice
™™$ )
(
™™) *
int
™™* -
index
™™. 3
,
™™3 4
int
™™5 8
length
™™9 ?
)
™™? @
{
šš 	
this
›› 
.
›› 
CheckIndex0
›› 
(
›› 
index
›› "
,
››" #
length
››$ *
)
››* +
;
››+ ,
return
œœ 
this
œœ 
.
œœ 
Unwrap
œœ 
(
œœ 
)
œœ  
.
œœ  !
Slice
œœ! &
(
œœ& '
this
œœ' +
.
œœ+ ,
Idx
œœ, /
(
œœ/ 0
index
œœ0 5
)
œœ5 6
,
œœ6 7
length
œœ8 >
)
œœ> ?
;
œœ? @
}
 	
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ #
GetBytes
ŸŸ$ ,
(
ŸŸ, -
int
ŸŸ- 0
index
ŸŸ1 6
,
ŸŸ6 7
IByteBuffer
ŸŸ8 C
dst
ŸŸD G
,
ŸŸG H
int
ŸŸI L
dstIndex
ŸŸM U
,
ŸŸU V
int
ŸŸW Z
length
ŸŸ[ a
)
ŸŸa b
{
   	
this
¡¡ 
.
¡¡ 
CheckIndex0
¡¡ 
(
¡¡ 
index
¡¡ "
,
¡¡" #
length
¡¡$ *
)
¡¡* +
;
¡¡+ ,
this
¢¢ 
.
¢¢ 
Unwrap
¢¢ 
(
¢¢ 
)
¢¢ 
.
¢¢ 
GetBytes
¢¢ "
(
¢¢" #
this
¢¢# '
.
¢¢' (
Idx
¢¢( +
(
¢¢+ ,
index
¢¢, 1
)
¢¢1 2
,
¢¢2 3
dst
¢¢4 7
,
¢¢7 8
dstIndex
¢¢9 A
,
¢¢A B
length
¢¢C I
)
¢¢I J
;
¢¢J K
return
££ 
this
££ 
;
££ 
}
¤¤ 	
public
¦¦ 
override
¦¦ 
IByteBuffer
¦¦ #
GetBytes
¦¦$ ,
(
¦¦, -
int
¦¦- 0
index
¦¦1 6
,
¦¦6 7
byte
¦¦8 <
[
¦¦< =
]
¦¦= >
dst
¦¦? B
,
¦¦B C
int
¦¦D G
dstIndex
¦¦H P
,
¦¦P Q
int
¦¦R U
length
¦¦V \
)
¦¦\ ]
{
§§ 	
this
¨¨ 
.
¨¨ 
CheckIndex0
¨¨ 
(
¨¨ 
index
¨¨ "
,
¨¨" #
length
¨¨$ *
)
¨¨* +
;
¨¨+ ,
this
©© 
.
©© 
Unwrap
©© 
(
©© 
)
©© 
.
©© 
GetBytes
©© "
(
©©" #
this
©©# '
.
©©' (
Idx
©©( +
(
©©+ ,
index
©©, 1
)
©©1 2
,
©©2 3
dst
©©4 7
,
©©7 8
dstIndex
©©9 A
,
©©A B
length
©©C I
)
©©I J
;
©©J K
return
ªª 
this
ªª 
;
ªª 
}
«« 	
public
­­ 
override
­­ 
IByteBuffer
­­ #
GetBytes
­­$ ,
(
­­, -
int
­­- 0
index
­­1 6
,
­­6 7
Stream
­­8 >
destination
­­? J
,
­­J K
int
­­L O
length
­­P V
)
­­V W
{
®® 	
this
¯¯ 
.
¯¯ 
CheckIndex0
¯¯ 
(
¯¯ 
index
¯¯ "
,
¯¯" #
length
¯¯$ *
)
¯¯* +
;
¯¯+ ,
this
°° 
.
°° 
Unwrap
°° 
(
°° 
)
°° 
.
°° 
GetBytes
°° "
(
°°" #
this
°°# '
.
°°' (
Idx
°°( +
(
°°+ ,
index
°°, 1
)
°°1 2
,
°°2 3
destination
°°4 ?
,
°°? @
length
°°A G
)
°°G H
;
°°H I
return
±± 
this
±± 
;
±± 
}
²² 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
SetByte
´´$ +
(
´´+ ,
int
´´, /
index
´´0 5
,
´´5 6
int
´´7 :
value
´´; @
)
´´@ A
{
µµ 	
this
¶¶ 
.
¶¶ 
CheckIndex0
¶¶ 
(
¶¶ 
index
¶¶ "
,
¶¶" #
$num
¶¶$ %
)
¶¶% &
;
¶¶& '
this
·· 
.
·· 
Unwrap
·· 
(
·· 
)
·· 
.
·· 
SetByte
·· !
(
··! "
this
··" &
.
··& '
Idx
··' *
(
··* +
index
··+ 0
)
··0 1
,
··1 2
value
··3 8
)
··8 9
;
··9 :
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
	protected
»» 
internal
»» 
override
»» #
void
»»$ (
_SetByte
»») 1
(
»»1 2
int
»»2 5
index
»»6 ;
,
»»; <
int
»»= @
value
»»A F
)
»»F G
=>
»»H J
this
»»K O
.
»»O P
Unwrap
»»P V
(
»»V W
)
»»W X
.
»»X Y
SetByte
»»Y `
(
»»` a
this
»»a e
.
»»e f
Idx
»»f i
(
»»i j
index
»»j o
)
»»o p
,
»»p q
value
»»r w
)
»»w x
;
»»x y
public
½½ 
override
½½ 
IByteBuffer
½½ #
SetShort
½½$ ,
(
½½, -
int
½½- 0
index
½½1 6
,
½½6 7
int
½½8 ;
value
½½< A
)
½½A B
{
¾¾ 	
this
¿¿ 
.
¿¿ 
CheckIndex0
¿¿ 
(
¿¿ 
index
¿¿ "
,
¿¿" #
$num
¿¿$ %
)
¿¿% &
;
¿¿& '
this
ÀÀ 
.
ÀÀ 
Unwrap
ÀÀ 
(
ÀÀ 
)
ÀÀ 
.
ÀÀ 
SetShort
ÀÀ "
(
ÀÀ" #
this
ÀÀ# '
.
ÀÀ' (
Idx
ÀÀ( +
(
ÀÀ+ ,
index
ÀÀ, 1
)
ÀÀ1 2
,
ÀÀ2 3
value
ÀÀ4 9
)
ÀÀ9 :
;
ÀÀ: ;
return
ÁÁ 
this
ÁÁ 
;
ÁÁ 
}
ÂÂ 	
	protected
ÄÄ 
internal
ÄÄ 
override
ÄÄ #
void
ÄÄ$ (
	_SetShort
ÄÄ) 2
(
ÄÄ2 3
int
ÄÄ3 6
index
ÄÄ7 <
,
ÄÄ< =
int
ÄÄ> A
value
ÄÄB G
)
ÄÄG H
=>
ÄÄI K
this
ÄÄL P
.
ÄÄP Q
Unwrap
ÄÄQ W
(
ÄÄW X
)
ÄÄX Y
.
ÄÄY Z
SetShort
ÄÄZ b
(
ÄÄb c
this
ÄÄc g
.
ÄÄg h
Idx
ÄÄh k
(
ÄÄk l
index
ÄÄl q
)
ÄÄq r
,
ÄÄr s
value
ÄÄt y
)
ÄÄy z
;
ÄÄz {
public
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ #

SetShortLE
ÆÆ$ .
(
ÆÆ. /
int
ÆÆ/ 2
index
ÆÆ3 8
,
ÆÆ8 9
int
ÆÆ: =
value
ÆÆ> C
)
ÆÆC D
{
ÇÇ 	
this
ÈÈ 
.
ÈÈ 
CheckIndex0
ÈÈ 
(
ÈÈ 
index
ÈÈ "
,
ÈÈ" #
$num
ÈÈ$ %
)
ÈÈ% &
;
ÈÈ& '
this
ÉÉ 
.
ÉÉ 
Unwrap
ÉÉ 
(
ÉÉ 
)
ÉÉ 
.
ÉÉ 

SetShortLE
ÉÉ $
(
ÉÉ$ %
this
ÉÉ% )
.
ÉÉ) *
Idx
ÉÉ* -
(
ÉÉ- .
index
ÉÉ. 3
)
ÉÉ3 4
,
ÉÉ4 5
value
ÉÉ6 ;
)
ÉÉ; <
;
ÉÉ< =
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ËË 	
	protected
ÍÍ 
internal
ÍÍ 
override
ÍÍ #
void
ÍÍ$ (
_SetShortLE
ÍÍ) 4
(
ÍÍ4 5
int
ÍÍ5 8
index
ÍÍ9 >
,
ÍÍ> ?
int
ÍÍ@ C
value
ÍÍD I
)
ÍÍI J
=>
ÍÍK M
this
ÍÍN R
.
ÍÍR S
Unwrap
ÍÍS Y
(
ÍÍY Z
)
ÍÍZ [
.
ÍÍ[ \

SetShortLE
ÍÍ\ f
(
ÍÍf g
this
ÍÍg k
.
ÍÍk l
Idx
ÍÍl o
(
ÍÍo p
index
ÍÍp u
)
ÍÍu v
,
ÍÍv w
value
ÍÍx }
)
ÍÍ} ~
;
ÍÍ~ 
public
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ #
	SetMedium
ÏÏ$ -
(
ÏÏ- .
int
ÏÏ. 1
index
ÏÏ2 7
,
ÏÏ7 8
int
ÏÏ9 <
value
ÏÏ= B
)
ÏÏB C
{
ĞĞ 	
this
ÑÑ 
.
ÑÑ 
CheckIndex0
ÑÑ 
(
ÑÑ 
index
ÑÑ "
,
ÑÑ" #
$num
ÑÑ$ %
)
ÑÑ% &
;
ÑÑ& '
this
ÒÒ 
.
ÒÒ 
Unwrap
ÒÒ 
(
ÒÒ 
)
ÒÒ 
.
ÒÒ 
	SetMedium
ÒÒ #
(
ÒÒ# $
this
ÒÒ$ (
.
ÒÒ( )
Idx
ÒÒ) ,
(
ÒÒ, -
index
ÒÒ- 2
)
ÒÒ2 3
,
ÒÒ3 4
value
ÒÒ5 :
)
ÒÒ: ;
;
ÒÒ; <
return
ÓÓ 
this
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
	protected
ÖÖ 
internal
ÖÖ 
override
ÖÖ #
void
ÖÖ$ (

_SetMedium
ÖÖ) 3
(
ÖÖ3 4
int
ÖÖ4 7
index
ÖÖ8 =
,
ÖÖ= >
int
ÖÖ? B
value
ÖÖC H
)
ÖÖH I
=>
ÖÖJ L
this
ÖÖM Q
.
ÖÖQ R
Unwrap
ÖÖR X
(
ÖÖX Y
)
ÖÖY Z
.
ÖÖZ [
	SetMedium
ÖÖ[ d
(
ÖÖd e
this
ÖÖe i
.
ÖÖi j
Idx
ÖÖj m
(
ÖÖm n
index
ÖÖn s
)
ÖÖs t
,
ÖÖt u
value
ÖÖv {
)
ÖÖ{ |
;
ÖÖ| }
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
SetMediumLE
ØØ$ /
(
ØØ/ 0
int
ØØ0 3
index
ØØ4 9
,
ØØ9 :
int
ØØ; >
value
ØØ? D
)
ØØD E
{
ÙÙ 	
this
ÚÚ 
.
ÚÚ 
CheckIndex0
ÚÚ 
(
ÚÚ 
index
ÚÚ "
,
ÚÚ" #
$num
ÚÚ$ %
)
ÚÚ% &
;
ÚÚ& '
this
ÛÛ 
.
ÛÛ 
Unwrap
ÛÛ 
(
ÛÛ 
)
ÛÛ 
.
ÛÛ 
SetMediumLE
ÛÛ %
(
ÛÛ% &
this
ÛÛ& *
.
ÛÛ* +
Idx
ÛÛ+ .
(
ÛÛ. /
index
ÛÛ/ 4
)
ÛÛ4 5
,
ÛÛ5 6
value
ÛÛ7 <
)
ÛÛ< =
;
ÛÛ= >
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
İİ 	
	protected
ßß 
internal
ßß 
override
ßß #
void
ßß$ (
_SetMediumLE
ßß) 5
(
ßß5 6
int
ßß6 9
index
ßß: ?
,
ßß? @
int
ßßA D
value
ßßE J
)
ßßJ K
=>
ßßL N
this
ßßO S
.
ßßS T
Unwrap
ßßT Z
(
ßßZ [
)
ßß[ \
.
ßß\ ]
SetMediumLE
ßß] h
(
ßßh i
this
ßßi m
.
ßßm n
Idx
ßßn q
(
ßßq r
index
ßßr w
)
ßßw x
,
ßßx y
value
ßßz 
)ßß €
;ßß€ 
public
áá 
override
áá 
IByteBuffer
áá #
SetInt
áá$ *
(
áá* +
int
áá+ .
index
áá/ 4
,
áá4 5
int
áá6 9
value
áá: ?
)
áá? @
{
ââ 	
this
ãã 
.
ãã 
CheckIndex0
ãã 
(
ãã 
index
ãã "
,
ãã" #
$num
ãã$ %
)
ãã% &
;
ãã& '
this
ää 
.
ää 
Unwrap
ää 
(
ää 
)
ää 
.
ää 
SetInt
ää  
(
ää  !
this
ää! %
.
ää% &
Idx
ää& )
(
ää) *
index
ää* /
)
ää/ 0
,
ää0 1
value
ää2 7
)
ää7 8
;
ää8 9
return
åå 
this
åå 
;
åå 
}
ææ 	
	protected
èè 
internal
èè 
override
èè #
void
èè$ (
_SetInt
èè) 0
(
èè0 1
int
èè1 4
index
èè5 :
,
èè: ;
int
èè< ?
value
èè@ E
)
èèE F
=>
èèG I
this
èèJ N
.
èèN O
Unwrap
èèO U
(
èèU V
)
èèV W
.
èèW X
SetInt
èèX ^
(
èè^ _
this
èè_ c
.
èèc d
Idx
èèd g
(
èèg h
index
èèh m
)
èèm n
,
èèn o
value
èèp u
)
èèu v
;
èèv w
public
êê 
override
êê 
IByteBuffer
êê #
SetIntLE
êê$ ,
(
êê, -
int
êê- 0
index
êê1 6
,
êê6 7
int
êê8 ;
value
êê< A
)
êêA B
{
ëë 	
this
ìì 
.
ìì 
CheckIndex0
ìì 
(
ìì 
index
ìì "
,
ìì" #
$num
ìì$ %
)
ìì% &
;
ìì& '
this
íí 
.
íí 
Unwrap
íí 
(
íí 
)
íí 
.
íí 
SetIntLE
íí "
(
íí" #
this
íí# '
.
íí' (
Idx
íí( +
(
íí+ ,
index
íí, 1
)
íí1 2
,
íí2 3
value
íí4 9
)
íí9 :
;
íí: ;
return
îî 
this
îî 
;
îî 
}
ïï 	
	protected
ññ 
internal
ññ 
override
ññ #
void
ññ$ (
	_SetIntLE
ññ) 2
(
ññ2 3
int
ññ3 6
index
ññ7 <
,
ññ< =
int
ññ> A
value
ññB G
)
ññG H
=>
ññI K
this
ññL P
.
ññP Q
Unwrap
ññQ W
(
ññW X
)
ññX Y
.
ññY Z
SetIntLE
ññZ b
(
ññb c
this
ññc g
.
ññg h
Idx
ññh k
(
ññk l
index
ññl q
)
ññq r
,
ññr s
value
ññt y
)
ññy z
;
ññz {
public
óó 
override
óó 
IByteBuffer
óó #
SetLong
óó$ +
(
óó+ ,
int
óó, /
index
óó0 5
,
óó5 6
long
óó7 ;
value
óó< A
)
óóA B
{
ôô 	
this
õõ 
.
õõ 
CheckIndex0
õõ 
(
õõ 
index
õõ "
,
õõ" #
$num
õõ$ %
)
õõ% &
;
õõ& '
this
öö 
.
öö 
Unwrap
öö 
(
öö 
)
öö 
.
öö 
SetLong
öö !
(
öö! "
this
öö" &
.
öö& '
Idx
öö' *
(
öö* +
index
öö+ 0
)
öö0 1
,
öö1 2
value
öö3 8
)
öö8 9
;
öö9 :
return
÷÷ 
this
÷÷ 
;
÷÷ 
}
øø 	
	protected
úú 
internal
úú 
override
úú #
void
úú$ (
_SetLong
úú) 1
(
úú1 2
int
úú2 5
index
úú6 ;
,
úú; <
long
úú= A
value
úúB G
)
úúG H
=>
úúI K
this
úúL P
.
úúP Q
Unwrap
úúQ W
(
úúW X
)
úúX Y
.
úúY Z
SetLong
úúZ a
(
úúa b
this
úúb f
.
úúf g
Idx
úúg j
(
úúj k
index
úúk p
)
úúp q
,
úúq r
value
úús x
)
úúx y
;
úúy z
public
üü 
override
üü 
IByteBuffer
üü #
	SetLongLE
üü$ -
(
üü- .
int
üü. 1
index
üü2 7
,
üü7 8
long
üü9 =
value
üü> C
)
üüC D
{
ıı 	
this
şş 
.
şş 
CheckIndex0
şş 
(
şş 
index
şş "
,
şş" #
$num
şş$ %
)
şş% &
;
şş& '
this
ÿÿ 
.
ÿÿ 
Unwrap
ÿÿ 
(
ÿÿ 
)
ÿÿ 
.
ÿÿ 
	SetLongLE
ÿÿ #
(
ÿÿ# $
this
ÿÿ$ (
.
ÿÿ( )
Idx
ÿÿ) ,
(
ÿÿ, -
index
ÿÿ- 2
)
ÿÿ2 3
,
ÿÿ3 4
value
ÿÿ5 :
)
ÿÿ: ;
;
ÿÿ; <
return
€€ 
this
€€ 
;
€€ 
}
 	
	protected
ƒƒ 
internal
ƒƒ 
override
ƒƒ #
void
ƒƒ$ (

_SetLongLE
ƒƒ) 3
(
ƒƒ3 4
int
ƒƒ4 7
index
ƒƒ8 =
,
ƒƒ= >
long
ƒƒ? C
value
ƒƒD I
)
ƒƒI J
=>
ƒƒK M
this
ƒƒN R
.
ƒƒR S
Unwrap
ƒƒS Y
(
ƒƒY Z
)
ƒƒZ [
.
ƒƒ[ \
	SetLongLE
ƒƒ\ e
(
ƒƒe f
this
ƒƒf j
.
ƒƒj k
Idx
ƒƒk n
(
ƒƒn o
index
ƒƒo t
)
ƒƒt u
,
ƒƒu v
value
ƒƒw |
)
ƒƒ| }
;
ƒƒ} ~
public
…… 
override
…… 
IByteBuffer
…… #
SetBytes
……$ ,
(
……, -
int
……- 0
index
……1 6
,
……6 7
byte
……8 <
[
……< =
]
……= >
src
……? B
,
……B C
int
……D G
srcIndex
……H P
,
……P Q
int
……R U
length
……V \
)
……\ ]
{
†† 	
this
‡‡ 
.
‡‡ 
CheckIndex0
‡‡ 
(
‡‡ 
index
‡‡ "
,
‡‡" #
length
‡‡$ *
)
‡‡* +
;
‡‡+ ,
this
ˆˆ 
.
ˆˆ 
Unwrap
ˆˆ 
(
ˆˆ 
)
ˆˆ 
.
ˆˆ 
SetBytes
ˆˆ "
(
ˆˆ" #
this
ˆˆ# '
.
ˆˆ' (
Idx
ˆˆ( +
(
ˆˆ+ ,
index
ˆˆ, 1
)
ˆˆ1 2
,
ˆˆ2 3
src
ˆˆ4 7
,
ˆˆ7 8
srcIndex
ˆˆ9 A
,
ˆˆA B
length
ˆˆC I
)
ˆˆI J
;
ˆˆJ K
return
‰‰ 
this
‰‰ 
;
‰‰ 
}
ŠŠ 	
public
ŒŒ 
override
ŒŒ 
IByteBuffer
ŒŒ #
SetBytes
ŒŒ$ ,
(
ŒŒ, -
int
ŒŒ- 0
index
ŒŒ1 6
,
ŒŒ6 7
IByteBuffer
ŒŒ8 C
src
ŒŒD G
,
ŒŒG H
int
ŒŒI L
srcIndex
ŒŒM U
,
ŒŒU V
int
ŒŒW Z
length
ŒŒ[ a
)
ŒŒa b
{
 	
this
 
.
 
CheckIndex0
 
(
 
index
 "
,
" #
length
$ *
)
* +
;
+ ,
this
 
.
 
Unwrap
 
(
 
)
 
.
 
SetBytes
 "
(
" #
this
# '
.
' (
Idx
( +
(
+ ,
index
, 1
)
1 2
,
2 3
src
4 7
,
7 8
srcIndex
9 A
,
A B
length
C I
)
I J
;
J K
return
 
this
 
;
 
}
‘‘ 	
public
““ 
override
““ 
Task
““ 
<
““ 
int
““  
>
““  !
SetBytesAsync
““" /
(
““/ 0
int
““0 3
index
““4 9
,
““9 :
Stream
““; A
src
““B E
,
““E F
int
““G J
length
““K Q
,
““Q R
CancellationToken
““S d
cancellationToken
““e v
)
““v w
{
”” 	
this
•• 
.
•• 
CheckIndex0
•• 
(
•• 
index
•• "
,
••" #
length
••$ *
)
••* +
;
••+ ,
return
–– 
this
–– 
.
–– 
Unwrap
–– 
(
–– 
)
––  
.
––  !
SetBytesAsync
––! .
(
––. /
index
––/ 4
+
––5 6
this
––7 ;
.
––; <

adjustment
––< F
,
––F G
src
––H K
,
––K L
length
––M S
,
––S T
cancellationToken
––U f
)
––f g
;
––g h
}
—— 	
public
™™ 
override
™™ 
int
™™ 
IoBufferCount
™™ )
=>
™™* ,
this
™™- 1
.
™™1 2
Unwrap
™™2 8
(
™™8 9
)
™™9 :
.
™™: ;
IoBufferCount
™™; H
;
™™H I
public
›› 
override
›› 
ArraySegment
›› $
<
››$ %
byte
››% )
>
››) *
GetIoBuffer
››+ 6
(
››6 7
int
››7 :
index
››; @
,
››@ A
int
››B E
length
››F L
)
››L M
{
œœ 	
this
 
.
 
CheckIndex0
 
(
 
index
 "
,
" #
length
$ *
)
* +
;
+ ,
return
 
this
 
.
 
Unwrap
 
(
 
)
  
.
  !
GetIoBuffer
! ,
(
, -
index
- 2
+
3 4
this
5 9
.
9 :

adjustment
: D
,
D E
length
F L
)
L M
;
M N
}
ŸŸ 	
public
¡¡ 
override
¡¡ 
ArraySegment
¡¡ $
<
¡¡$ %
byte
¡¡% )
>
¡¡) *
[
¡¡* +
]
¡¡+ ,
GetIoBuffers
¡¡- 9
(
¡¡9 :
int
¡¡: =
index
¡¡> C
,
¡¡C D
int
¡¡E H
length
¡¡I O
)
¡¡O P
{
¢¢ 	
this
££ 
.
££ 
CheckIndex0
££ 
(
££ 
index
££ "
,
££" #
length
££$ *
)
££* +
;
££+ ,
return
¤¤ 
this
¤¤ 
.
¤¤ 
Unwrap
¤¤ 
(
¤¤ 
)
¤¤  
.
¤¤  !
GetIoBuffers
¤¤! -
(
¤¤- .
index
¤¤. 3
+
¤¤4 5
this
¤¤6 :
.
¤¤: ;

adjustment
¤¤; E
,
¤¤E F
length
¤¤G M
)
¤¤M N
;
¤¤N O
}
¥¥ 	
public
§§ 
override
§§ 
int
§§ 
ForEachByte
§§ '
(
§§' (
int
§§( +
index
§§, 1
,
§§1 2
int
§§3 6
length
§§7 =
,
§§= >
IByteProcessor
§§? M
	processor
§§N W
)
§§W X
{
¨¨ 	
this
©© 
.
©© 
CheckIndex0
©© 
(
©© 
index
©© "
,
©©" #
length
©©$ *
)
©©* +
;
©©+ ,
int
ªª 
ret
ªª 
=
ªª 
this
ªª 
.
ªª 
Unwrap
ªª !
(
ªª! "
)
ªª" #
.
ªª# $
ForEachByte
ªª$ /
(
ªª/ 0
this
ªª0 4
.
ªª4 5
Idx
ªª5 8
(
ªª8 9
index
ªª9 >
)
ªª> ?
,
ªª? @
length
ªªA G
,
ªªG H
	processor
ªªI R
)
ªªR S
;
ªªS T
if
«« 
(
«« 
ret
«« 
>=
«« 
this
«« 
.
«« 

adjustment
«« &
)
««& '
{
¬¬ 
return
­­ 
ret
­­ 
-
­­ 
this
­­ !
.
­­! "

adjustment
­­" ,
;
­­, -
}
®® 
else
¯¯ 
{
°° 
return
±± 
-
±± 
$num
±± 
;
±± 
}
²² 
}
³³ 	
public
µµ 
override
µµ 
int
µµ 
ForEachByteDesc
µµ +
(
µµ+ ,
int
µµ, /
index
µµ0 5
,
µµ5 6
int
µµ7 :
length
µµ; A
,
µµA B
IByteProcessor
µµC Q
	processor
µµR [
)
µµ[ \
{
¶¶ 	
this
·· 
.
·· 
CheckIndex0
·· 
(
·· 
index
·· "
,
··" #
length
··$ *
)
··* +
;
··+ ,
int
¸¸ 
ret
¸¸ 
=
¸¸ 
this
¸¸ 
.
¸¸ 
Unwrap
¸¸ !
(
¸¸! "
)
¸¸" #
.
¸¸# $
ForEachByteDesc
¸¸$ 3
(
¸¸3 4
this
¸¸4 8
.
¸¸8 9
Idx
¸¸9 <
(
¸¸< =
index
¸¸= B
)
¸¸B C
,
¸¸C D
length
¸¸E K
,
¸¸K L
	processor
¸¸M V
)
¸¸V W
;
¸¸W X
if
¹¹ 
(
¹¹ 
ret
¹¹ 
>=
¹¹ 
this
¹¹ 
.
¹¹ 

adjustment
¹¹ &
)
¹¹& '
{
ºº 
return
»» 
ret
»» 
-
»» 
this
»» !
.
»»! "

adjustment
»»" ,
;
»», -
}
¼¼ 
else
½½ 
{
¾¾ 
return
¿¿ 
-
¿¿ 
$num
¿¿ 
;
¿¿ 
}
ÀÀ 
}
ÁÁ 	
	protected
ÄÄ 
int
ÄÄ 
Idx
ÄÄ 
(
ÄÄ 
int
ÄÄ 
index
ÄÄ #
)
ÄÄ# $
=>
ÄÄ% '
index
ÄÄ( -
+
ÄÄ. /
this
ÄÄ0 4
.
ÄÄ4 5

adjustment
ÄÄ5 ?
;
ÄÄ? @
internal
ÆÆ 
static
ÆÆ 
void
ÆÆ #
CheckSliceOutOfBounds
ÆÆ 2
(
ÆÆ2 3
int
ÆÆ3 6
index
ÆÆ7 <
,
ÆÆ< =
int
ÆÆ> A
length
ÆÆB H
,
ÆÆH I
IByteBuffer
ÆÆJ U
buffer
ÆÆV \
)
ÆÆ\ ]
{
ÇÇ 	
if
ÈÈ 
(
ÈÈ 
MathUtil
ÈÈ 
.
ÈÈ 
IsOutOfBounds
ÈÈ &
(
ÈÈ& '
index
ÈÈ' ,
,
ÈÈ, -
length
ÈÈ. 4
,
ÈÈ4 5
buffer
ÈÈ6 <
.
ÈÈ< =
Capacity
ÈÈ= E
)
ÈÈE F
)
ÈÈF G
{
ÉÉ 
throw
ÊÊ 
new
ÊÊ &
IndexOutOfRangeException
ÊÊ 2
(
ÊÊ2 3
$"
ÊÊ3 5
{
ÊÊ5 6
buffer
ÊÊ6 <
}
ÊÊ< =
$str
ÊÊ= D
{
ÊÊD E
index
ÊÊE J
}
ÊÊJ K
$str
ÊÊK M
{
ÊÊM N
length
ÊÊN T
}
ÊÊT U
$str
ÊÊU V
"
ÊÊV W
)
ÊÊW X
;
ÊÊX Y
}
ËË 
}
ÌÌ 	
}
ÍÍ 
}ÎÎ ÃÇ
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AdvancedLeakAwareByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class '
AdvancedLeakAwareByteBuffer ,
:- .%
SimpleLeakAwareByteBuffer/ H
{ 
const 
string %
PropAcquireAndReleaseOnly .
=/ 0
$str1 _
;_ `
static 
readonly 
bool !
AcquireAndReleaseOnly 2
;2 3
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S'
AdvancedLeakAwareByteBufferS n
>n o
(o p
)p q
;q r
static '
AdvancedLeakAwareByteBuffer *
(* +
)+ ,
{ 	!
AcquireAndReleaseOnly !
=" #
SystemPropertyUtil$ 6
.6 7

GetBoolean7 A
(A B%
PropAcquireAndReleaseOnlyB [
,[ \
false] b
)b c
;c d
if 
( 
Logger 
. 
DebugEnabled #
)# $
{ 
Logger 
. 
Debug 
( 
$str '
,' (%
PropAcquireAndReleaseOnly) B
,B C!
AcquireAndReleaseOnlyD Y
)Y Z
;Z [
} 
} 	
internal!! '
AdvancedLeakAwareByteBuffer!! ,
(!!, -
IByteBuffer!!- 8
buf!!9 <
,!!< = 
IResourceLeakTracker!!> R
leak!!S W
)!!W X
:"" 
base"" 
("" 
buf"" 
,"" 
leak"" 
)"" 
{## 	
}$$ 	
internal&& '
AdvancedLeakAwareByteBuffer&& ,
(&&, -
IByteBuffer&&- 8
wrapped&&9 @
,&&@ A
IByteBuffer&&B M
trackedByteBuf&&N \
,&&\ ] 
IResourceLeakTracker&&^ r
leak&&s w
)&&w x
:'' 
base'' 
('' 
wrapped'' 
,'' 
trackedByteBuf'' *
,''* +
leak'', 0
)''0 1
{(( 	
})) 	
internal++ 
static++ 
void++ -
!RecordLeakNonRefCountingOperation++ >
(++> ? 
IResourceLeakTracker++? S
leak++T X
)++X Y
{,, 	
if-- 
(-- 
!-- !
AcquireAndReleaseOnly-- &
)--& '
{.. 
leak// 
.// 
Record// 
(// 
)// 
;// 
}00 
}11 	
public33 
override33 
IByteBuffer33 #
Slice33$ )
(33) *
)33* +
{44 	-
!RecordLeakNonRefCountingOperation55 -
(55- .
this55. 2
.552 3
Leak553 7
)557 8
;558 9
return66 
base66 
.66 
Slice66 
(66 
)66 
;66  
}77 	
public99 
override99 
IByteBuffer99 #
Slice99$ )
(99) *
int99* -
index99. 3
,993 4
int995 8
length999 ?
)99? @
{:: 	-
!RecordLeakNonRefCountingOperation;; -
(;;- .
this;;. 2
.;;2 3
Leak;;3 7
);;7 8
;;;8 9
return<< 
base<< 
.<< 
Slice<< 
(<< 
index<< #
,<<# $
length<<% +
)<<+ ,
;<<, -
}== 	
public?? 
override?? 
IByteBuffer?? #
	Duplicate??$ -
(??- .
)??. /
{@@ 	-
!RecordLeakNonRefCountingOperationAA -
(AA- .
thisAA. 2
.AA2 3
LeakAA3 7
)AA7 8
;AA8 9
returnBB 
baseBB 
.BB 
	DuplicateBB !
(BB! "
)BB" #
;BB# $
}CC 	
publicEE 
overrideEE 
IByteBufferEE #
	ReadSliceEE$ -
(EE- .
intEE. 1
lengthEE2 8
)EE8 9
{FF 	-
!RecordLeakNonRefCountingOperationGG -
(GG- .
thisGG. 2
.GG2 3
LeakGG3 7
)GG7 8
;GG8 9
returnHH 
baseHH 
.HH 
	ReadSliceHH !
(HH! "
lengthHH" (
)HH( )
;HH) *
}II 	
publicKK 
overrideKK 
IByteBufferKK #
DiscardReadBytesKK$ 4
(KK4 5
)KK5 6
{LL 	-
!RecordLeakNonRefCountingOperationMM -
(MM- .
thisMM. 2
.MM2 3
LeakMM3 7
)MM7 8
;MM8 9
returnNN 
baseNN 
.NN 
DiscardReadBytesNN (
(NN( )
)NN) *
;NN* +
}OO 	
publicQQ 
overrideQQ 
IByteBufferQQ # 
DiscardSomeReadBytesQQ$ 8
(QQ8 9
)QQ9 :
{RR 	-
!RecordLeakNonRefCountingOperationSS -
(SS- .
thisSS. 2
.SS2 3
LeakSS3 7
)SS7 8
;SS8 9
returnTT 
baseTT 
.TT  
DiscardSomeReadBytesTT ,
(TT, -
)TT- .
;TT. /
}UU 	
publicWW 
overrideWW 
IByteBufferWW #
EnsureWritableWW$ 2
(WW2 3
intWW3 6
minWritableBytesWW7 G
)WWG H
{XX 	-
!RecordLeakNonRefCountingOperationYY -
(YY- .
thisYY. 2
.YY2 3
LeakYY3 7
)YY7 8
;YY8 9
returnZZ 
baseZZ 
.ZZ 
EnsureWritableZZ &
(ZZ& '
minWritableBytesZZ' 7
)ZZ7 8
;ZZ8 9
}[[ 	
public]] 
override]] 
int]] 
EnsureWritable]] *
(]]* +
int]]+ .
minWritableBytes]]/ ?
,]]? @
bool]]A E
force]]F K
)]]K L
{^^ 	-
!RecordLeakNonRefCountingOperation__ -
(__- .
this__. 2
.__2 3
Leak__3 7
)__7 8
;__8 9
return`` 
base`` 
.`` 
EnsureWritable`` &
(``& '
minWritableBytes``' 7
,``7 8
force``9 >
)``> ?
;``? @
}aa 	
publiccc 
overridecc 
boolcc 

GetBooleancc '
(cc' (
intcc( +
indexcc, 1
)cc1 2
{dd 	-
!RecordLeakNonRefCountingOperationee -
(ee- .
thisee. 2
.ee2 3
Leakee3 7
)ee7 8
;ee8 9
returnff 
baseff 
.ff 

GetBooleanff "
(ff" #
indexff# (
)ff( )
;ff) *
}gg 	
publicii 
overrideii 
byteii 
GetByteii $
(ii$ %
intii% (
indexii) .
)ii. /
{jj 	-
!RecordLeakNonRefCountingOperationkk -
(kk- .
thiskk. 2
.kk2 3
Leakkk3 7
)kk7 8
;kk8 9
returnll 
basell 
.ll 
GetBytell 
(ll  
indexll  %
)ll% &
;ll& '
}mm 	
publicoo 
overrideoo 
intoo 
	GetMediumoo %
(oo% &
intoo& )
indexoo* /
)oo/ 0
{pp 	-
!RecordLeakNonRefCountingOperationqq -
(qq- .
thisqq. 2
.qq2 3
Leakqq3 7
)qq7 8
;qq8 9
returnrr 
baserr 
.rr 
	GetMediumrr !
(rr! "
indexrr" '
)rr' (
;rr( )
}ss 	
publicuu 
overrideuu 
intuu 
GetUnsignedMediumuu -
(uu- .
intuu. 1
indexuu2 7
)uu7 8
{vv 	-
!RecordLeakNonRefCountingOperationww -
(ww- .
thisww. 2
.ww2 3
Leakww3 7
)ww7 8
;ww8 9
returnxx 
basexx 
.xx 
GetUnsignedMediumxx )
(xx) *
indexxx* /
)xx/ 0
;xx0 1
}yy 	
public{{ 
override{{ 
short{{ 
GetShort{{ &
({{& '
int{{' *
index{{+ 0
){{0 1
{|| 	-
!RecordLeakNonRefCountingOperation}} -
(}}- .
this}}. 2
.}}2 3
Leak}}3 7
)}}7 8
;}}8 9
return~~ 
base~~ 
.~~ 
GetShort~~  
(~~  !
index~~! &
)~~& '
;~~' (
} 	
public
 
override
 
ushort
 
GetUnsignedShort
 /
(
/ 0
int
0 3
index
4 9
)
9 :
{
‚‚ 	/
!RecordLeakNonRefCountingOperation
ƒƒ -
(
ƒƒ- .
this
ƒƒ. 2
.
ƒƒ2 3
Leak
ƒƒ3 7
)
ƒƒ7 8
;
ƒƒ8 9
return
„„ 
base
„„ 
.
„„ 
GetUnsignedShort
„„ (
(
„„( )
index
„„) .
)
„„. /
;
„„/ 0
}
…… 	
public
‡‡ 
override
‡‡ 
int
‡‡ 
GetInt
‡‡ "
(
‡‡" #
int
‡‡# &
index
‡‡' ,
)
‡‡, -
{
ˆˆ 	/
!RecordLeakNonRefCountingOperation
‰‰ -
(
‰‰- .
this
‰‰. 2
.
‰‰2 3
Leak
‰‰3 7
)
‰‰7 8
;
‰‰8 9
return
ŠŠ 
base
ŠŠ 
.
ŠŠ 
GetInt
ŠŠ 
(
ŠŠ 
index
ŠŠ $
)
ŠŠ$ %
;
ŠŠ% &
}
‹‹ 	
public
 
override
 
uint
 
GetUnsignedInt
 +
(
+ ,
int
, /
index
0 5
)
5 6
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
GetUnsignedInt
 &
(
& '
index
' ,
)
, -
;
- .
}
‘‘ 	
public
““ 
override
““ 
long
““ 
GetLong
““ $
(
““$ %
int
““% (
index
““) .
)
““. /
{
”” 	/
!RecordLeakNonRefCountingOperation
•• -
(
••- .
this
••. 2
.
••2 3
Leak
••3 7
)
••7 8
;
••8 9
return
–– 
base
–– 
.
–– 
GetLong
–– 
(
––  
index
––  %
)
––% &
;
––& '
}
—— 	
public
™™ 
override
™™ 
char
™™ 
GetChar
™™ $
(
™™$ %
int
™™% (
index
™™) .
)
™™. /
{
šš 	/
!RecordLeakNonRefCountingOperation
›› -
(
››- .
this
››. 2
.
››2 3
Leak
››3 7
)
››7 8
;
››8 9
return
œœ 
base
œœ 
.
œœ 
GetChar
œœ 
(
œœ  
index
œœ  %
)
œœ% &
;
œœ& '
}
 	
public
ŸŸ 
override
ŸŸ 
float
ŸŸ 
GetFloat
ŸŸ &
(
ŸŸ& '
int
ŸŸ' *
index
ŸŸ+ 0
)
ŸŸ0 1
{
   	/
!RecordLeakNonRefCountingOperation
¡¡ -
(
¡¡- .
this
¡¡. 2
.
¡¡2 3
Leak
¡¡3 7
)
¡¡7 8
;
¡¡8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
GetFloat
¢¢  
(
¢¢  !
index
¢¢! &
)
¢¢& '
;
¢¢' (
}
££ 	
public
¥¥ 
override
¥¥ 
double
¥¥ 
	GetDouble
¥¥ (
(
¥¥( )
int
¥¥) ,
index
¥¥- 2
)
¥¥2 3
{
¦¦ 	/
!RecordLeakNonRefCountingOperation
§§ -
(
§§- .
this
§§. 2
.
§§2 3
Leak
§§3 7
)
§§7 8
;
§§8 9
return
¨¨ 
base
¨¨ 
.
¨¨ 
	GetDouble
¨¨ !
(
¨¨! "
index
¨¨" '
)
¨¨' (
;
¨¨( )
}
©© 	
public
«« 
override
«« 
IByteBuffer
«« #
GetBytes
««$ ,
(
««, -
int
««- 0
index
««1 6
,
««6 7
IByteBuffer
««8 C
dst
««D G
)
««G H
{
¬¬ 	/
!RecordLeakNonRefCountingOperation
­­ -
(
­­- .
this
­­. 2
.
­­2 3
Leak
­­3 7
)
­­7 8
;
­­8 9
return
®® 
base
®® 
.
®® 
GetBytes
®®  
(
®®  !
index
®®! &
,
®®& '
dst
®®( +
)
®®+ ,
;
®®, -
}
¯¯ 	
public
±± 
override
±± 
IByteBuffer
±± #
GetBytes
±±$ ,
(
±±, -
int
±±- 0
index
±±1 6
,
±±6 7
IByteBuffer
±±8 C
dst
±±D G
,
±±G H
int
±±I L
length
±±M S
)
±±S T
{
²² 	/
!RecordLeakNonRefCountingOperation
³³ -
(
³³- .
this
³³. 2
.
³³2 3
Leak
³³3 7
)
³³7 8
;
³³8 9
return
´´ 
base
´´ 
.
´´ 
GetBytes
´´  
(
´´  !
index
´´! &
,
´´& '
dst
´´( +
,
´´+ ,
length
´´- 3
)
´´3 4
;
´´4 5
}
µµ 	
public
·· 
override
·· 
IByteBuffer
·· #
GetBytes
··$ ,
(
··, -
int
··- 0
index
··1 6
,
··6 7
IByteBuffer
··8 C
dst
··D G
,
··G H
int
··I L
dstIndex
··M U
,
··U V
int
··W Z
length
··[ a
)
··a b
{
¸¸ 	/
!RecordLeakNonRefCountingOperation
¹¹ -
(
¹¹- .
this
¹¹. 2
.
¹¹2 3
Leak
¹¹3 7
)
¹¹7 8
;
¹¹8 9
return
ºº 
base
ºº 
.
ºº 
GetBytes
ºº  
(
ºº  !
index
ºº! &
,
ºº& '
dst
ºº( +
,
ºº+ ,
dstIndex
ºº- 5
,
ºº5 6
length
ºº7 =
)
ºº= >
;
ºº> ?
}
»» 	
public
½½ 
override
½½ 
IByteBuffer
½½ #
GetBytes
½½$ ,
(
½½, -
int
½½- 0
index
½½1 6
,
½½6 7
byte
½½8 <
[
½½< =
]
½½= >
dst
½½? B
)
½½B C
{
¾¾ 	/
!RecordLeakNonRefCountingOperation
¿¿ -
(
¿¿- .
this
¿¿. 2
.
¿¿2 3
Leak
¿¿3 7
)
¿¿7 8
;
¿¿8 9
return
ÀÀ 
base
ÀÀ 
.
ÀÀ 
GetBytes
ÀÀ  
(
ÀÀ  !
index
ÀÀ! &
,
ÀÀ& '
dst
ÀÀ( +
)
ÀÀ+ ,
;
ÀÀ, -
}
ÁÁ 	
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
GetBytes
ÃÃ$ ,
(
ÃÃ, -
int
ÃÃ- 0
index
ÃÃ1 6
,
ÃÃ6 7
byte
ÃÃ8 <
[
ÃÃ< =
]
ÃÃ= >
dst
ÃÃ? B
,
ÃÃB C
int
ÃÃD G
dstIndex
ÃÃH P
,
ÃÃP Q
int
ÃÃR U
length
ÃÃV \
)
ÃÃ\ ]
{
ÄÄ 	/
!RecordLeakNonRefCountingOperation
ÅÅ -
(
ÅÅ- .
this
ÅÅ. 2
.
ÅÅ2 3
Leak
ÅÅ3 7
)
ÅÅ7 8
;
ÅÅ8 9
return
ÆÆ 
base
ÆÆ 
.
ÆÆ 
GetBytes
ÆÆ  
(
ÆÆ  !
index
ÆÆ! &
,
ÆÆ& '
dst
ÆÆ( +
,
ÆÆ+ ,
dstIndex
ÆÆ- 5
,
ÆÆ5 6
length
ÆÆ7 =
)
ÆÆ= >
;
ÆÆ> ?
}
ÇÇ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #

SetBoolean
ÉÉ$ .
(
ÉÉ. /
int
ÉÉ/ 2
index
ÉÉ3 8
,
ÉÉ8 9
bool
ÉÉ: >
value
ÉÉ? D
)
ÉÉD E
{
ÊÊ 	/
!RecordLeakNonRefCountingOperation
ËË -
(
ËË- .
this
ËË. 2
.
ËË2 3
Leak
ËË3 7
)
ËË7 8
;
ËË8 9
return
ÌÌ 
base
ÌÌ 
.
ÌÌ 

SetBoolean
ÌÌ "
(
ÌÌ" #
index
ÌÌ# (
,
ÌÌ( )
value
ÌÌ* /
)
ÌÌ/ 0
;
ÌÌ0 1
}
ÍÍ 	
public
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ #
SetByte
ÏÏ$ +
(
ÏÏ+ ,
int
ÏÏ, /
index
ÏÏ0 5
,
ÏÏ5 6
int
ÏÏ7 :
value
ÏÏ; @
)
ÏÏ@ A
{
ĞĞ 	/
!RecordLeakNonRefCountingOperation
ÑÑ -
(
ÑÑ- .
this
ÑÑ. 2
.
ÑÑ2 3
Leak
ÑÑ3 7
)
ÑÑ7 8
;
ÑÑ8 9
return
ÒÒ 
base
ÒÒ 
.
ÒÒ 
SetByte
ÒÒ 
(
ÒÒ  
index
ÒÒ  %
,
ÒÒ% &
value
ÒÒ' ,
)
ÒÒ, -
;
ÒÒ- .
}
ÓÓ 	
public
ÕÕ 
override
ÕÕ 
IByteBuffer
ÕÕ #
	SetMedium
ÕÕ$ -
(
ÕÕ- .
int
ÕÕ. 1
index
ÕÕ2 7
,
ÕÕ7 8
int
ÕÕ9 <
value
ÕÕ= B
)
ÕÕB C
{
ÖÖ 	/
!RecordLeakNonRefCountingOperation
×× -
(
××- .
this
××. 2
.
××2 3
Leak
××3 7
)
××7 8
;
××8 9
return
ØØ 
base
ØØ 
.
ØØ 
	SetMedium
ØØ !
(
ØØ! "
index
ØØ" '
,
ØØ' (
value
ØØ) .
)
ØØ. /
;
ØØ/ 0
}
ÙÙ 	
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #
SetShort
ÛÛ$ ,
(
ÛÛ, -
int
ÛÛ- 0
index
ÛÛ1 6
,
ÛÛ6 7
int
ÛÛ8 ;
value
ÛÛ< A
)
ÛÛA B
{
ÜÜ 	/
!RecordLeakNonRefCountingOperation
İİ -
(
İİ- .
this
İİ. 2
.
İİ2 3
Leak
İİ3 7
)
İİ7 8
;
İİ8 9
return
ŞŞ 
base
ŞŞ 
.
ŞŞ 
SetShort
ŞŞ  
(
ŞŞ  !
index
ŞŞ! &
,
ŞŞ& '
value
ŞŞ( -
)
ŞŞ- .
;
ŞŞ. /
}
ßß 	
public
áá 
override
áá 
IByteBuffer
áá #
SetInt
áá$ *
(
áá* +
int
áá+ .
index
áá/ 4
,
áá4 5
int
áá6 9
value
áá: ?
)
áá? @
{
ââ 	/
!RecordLeakNonRefCountingOperation
ãã -
(
ãã- .
this
ãã. 2
.
ãã2 3
Leak
ãã3 7
)
ãã7 8
;
ãã8 9
return
ää 
base
ää 
.
ää 
SetInt
ää 
(
ää 
index
ää $
,
ää$ %
value
ää& +
)
ää+ ,
;
ää, -
}
åå 	
public
çç 
override
çç 
IByteBuffer
çç #
SetLong
çç$ +
(
çç+ ,
int
çç, /
index
çç0 5
,
çç5 6
long
çç7 ;
value
çç< A
)
ççA B
{
èè 	/
!RecordLeakNonRefCountingOperation
éé -
(
éé- .
this
éé. 2
.
éé2 3
Leak
éé3 7
)
éé7 8
;
éé8 9
return
êê 
base
êê 
.
êê 
SetLong
êê 
(
êê  
index
êê  %
,
êê% &
value
êê' ,
)
êê, -
;
êê- .
}
ëë 	
public
íí 
override
íí 
IByteBuffer
íí #
SetChar
íí$ +
(
íí+ ,
int
íí, /
index
íí0 5
,
íí5 6
char
íí7 ;
value
íí< A
)
ííA B
{
îî 	/
!RecordLeakNonRefCountingOperation
ïï -
(
ïï- .
this
ïï. 2
.
ïï2 3
Leak
ïï3 7
)
ïï7 8
;
ïï8 9
return
ğğ 
base
ğğ 
.
ğğ 
SetChar
ğğ 
(
ğğ  
index
ğğ  %
,
ğğ% &
value
ğğ' ,
)
ğğ, -
;
ğğ- .
}
ññ 	
public
óó 
override
óó 
IByteBuffer
óó #
SetFloat
óó$ ,
(
óó, -
int
óó- 0
index
óó1 6
,
óó6 7
float
óó8 =
value
óó> C
)
óóC D
{
ôô 	/
!RecordLeakNonRefCountingOperation
õõ -
(
õõ- .
this
õõ. 2
.
õõ2 3
Leak
õõ3 7
)
õõ7 8
;
õõ8 9
return
öö 
base
öö 
.
öö 
SetFloat
öö  
(
öö  !
index
öö! &
,
öö& '
value
öö( -
)
öö- .
;
öö. /
}
÷÷ 	
public
ùù 
override
ùù 
IByteBuffer
ùù #
	SetDouble
ùù$ -
(
ùù- .
int
ùù. 1
index
ùù2 7
,
ùù7 8
double
ùù9 ?
value
ùù@ E
)
ùùE F
{
úú 	/
!RecordLeakNonRefCountingOperation
ûû -
(
ûû- .
this
ûû. 2
.
ûû2 3
Leak
ûû3 7
)
ûû7 8
;
ûû8 9
return
üü 
base
üü 
.
üü 
	SetDouble
üü !
(
üü! "
index
üü" '
,
üü' (
value
üü) .
)
üü. /
;
üü/ 0
}
ıı 	
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
SetBytes
ÿÿ$ ,
(
ÿÿ, -
int
ÿÿ- 0
index
ÿÿ1 6
,
ÿÿ6 7
IByteBuffer
ÿÿ8 C
src
ÿÿD G
)
ÿÿG H
{
€€ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
‚‚ 
base
‚‚ 
.
‚‚ 
SetBytes
‚‚  
(
‚‚  !
index
‚‚! &
,
‚‚& '
src
‚‚( +
)
‚‚+ ,
;
‚‚, -
}
ƒƒ 	
public
…… 
override
…… 
IByteBuffer
…… #
SetBytes
……$ ,
(
……, -
int
……- 0
index
……1 6
,
……6 7
IByteBuffer
……8 C
src
……D G
,
……G H
int
……I L
length
……M S
)
……S T
{
†† 	/
!RecordLeakNonRefCountingOperation
‡‡ -
(
‡‡- .
this
‡‡. 2
.
‡‡2 3
Leak
‡‡3 7
)
‡‡7 8
;
‡‡8 9
return
ˆˆ 
base
ˆˆ 
.
ˆˆ 
SetBytes
ˆˆ  
(
ˆˆ  !
index
ˆˆ! &
,
ˆˆ& '
src
ˆˆ( +
,
ˆˆ+ ,
length
ˆˆ- 3
)
ˆˆ3 4
;
ˆˆ4 5
}
‰‰ 	
public
‹‹ 
override
‹‹ 
IByteBuffer
‹‹ #
SetBytes
‹‹$ ,
(
‹‹, -
int
‹‹- 0
index
‹‹1 6
,
‹‹6 7
IByteBuffer
‹‹8 C
src
‹‹D G
,
‹‹G H
int
‹‹I L
srcIndex
‹‹M U
,
‹‹U V
int
‹‹W Z
length
‹‹[ a
)
‹‹a b
{
ŒŒ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
SetBytes
  
(
  !
index
! &
,
& '
src
( +
,
+ ,
srcIndex
- 5
,
5 6
length
7 =
)
= >
;
> ?
}
 	
public
‘‘ 
override
‘‘ 
IByteBuffer
‘‘ #
SetBytes
‘‘$ ,
(
‘‘, -
int
‘‘- 0
index
‘‘1 6
,
‘‘6 7
byte
‘‘8 <
[
‘‘< =
]
‘‘= >
src
‘‘? B
)
‘‘B C
{
’’ 	/
!RecordLeakNonRefCountingOperation
““ -
(
““- .
this
““. 2
.
““2 3
Leak
““3 7
)
““7 8
;
““8 9
return
”” 
base
”” 
.
”” 
SetBytes
””  
(
””  !
index
””! &
,
””& '
src
””( +
)
””+ ,
;
””, -
}
•• 	
public
—— 
override
—— 
IByteBuffer
—— #
SetBytes
——$ ,
(
——, -
int
——- 0
index
——1 6
,
——6 7
byte
——8 <
[
——< =
]
——= >
src
——? B
,
——B C
int
——D G
srcIndex
——H P
,
——P Q
int
——R U
length
——V \
)
——\ ]
{
˜˜ 	/
!RecordLeakNonRefCountingOperation
™™ -
(
™™- .
this
™™. 2
.
™™2 3
Leak
™™3 7
)
™™7 8
;
™™8 9
return
šš 
base
šš 
.
šš 
SetBytes
šš  
(
šš  !
index
šš! &
,
šš& '
src
šš( +
,
šš+ ,
srcIndex
šš- 5
,
šš5 6
length
šš7 =
)
šš= >
;
šš> ?
}
›› 	
public
 
override
 
Task
 
<
 
int
  
>
  !
SetBytesAsync
" /
(
/ 0
int
0 3
index
4 9
,
9 :
Stream
; A
input
B G
,
G H
int
I L
length
M S
,
S T
CancellationToken
U f
cancellationToken
g x
)
x y
{
 	/
!RecordLeakNonRefCountingOperation
ŸŸ -
(
ŸŸ- .
this
ŸŸ. 2
.
ŸŸ2 3
Leak
ŸŸ3 7
)
ŸŸ7 8
;
ŸŸ8 9
return
   
base
   
.
   
SetBytesAsync
   %
(
  % &
index
  & +
,
  + ,
input
  - 2
,
  2 3
length
  4 :
,
  : ;
cancellationToken
  < M
)
  M N
;
  N O
}
¡¡ 	
public
££ 
override
££ 
IByteBuffer
££ #
SetZero
££$ +
(
££+ ,
int
££, /
index
££0 5
,
££5 6
int
££7 :
length
££; A
)
££A B
{
¤¤ 	/
!RecordLeakNonRefCountingOperation
¥¥ -
(
¥¥- .
this
¥¥. 2
.
¥¥2 3
Leak
¥¥3 7
)
¥¥7 8
;
¥¥8 9
return
¦¦ 
base
¦¦ 
.
¦¦ 
SetZero
¦¦ 
(
¦¦  
index
¦¦  %
,
¦¦% &
length
¦¦' -
)
¦¦- .
;
¦¦. /
}
§§ 	
public
©© 
override
©© 
bool
©© 
ReadBoolean
©© (
(
©©( )
)
©©) *
{
ªª 	/
!RecordLeakNonRefCountingOperation
«« -
(
««- .
this
««. 2
.
««2 3
Leak
««3 7
)
««7 8
;
««8 9
return
¬¬ 
base
¬¬ 
.
¬¬ 
ReadBoolean
¬¬ #
(
¬¬# $
)
¬¬$ %
;
¬¬% &
}
­­ 	
public
¯¯ 
override
¯¯ 
byte
¯¯ 
ReadByte
¯¯ %
(
¯¯% &
)
¯¯& '
{
°° 	/
!RecordLeakNonRefCountingOperation
±± -
(
±±- .
this
±±. 2
.
±±2 3
Leak
±±3 7
)
±±7 8
;
±±8 9
return
²² 
base
²² 
.
²² 
ReadByte
²²  
(
²²  !
)
²²! "
;
²²" #
}
³³ 	
public
µµ 
override
µµ 
short
µµ 
	ReadShort
µµ '
(
µµ' (
)
µµ( )
{
¶¶ 	/
!RecordLeakNonRefCountingOperation
·· -
(
··- .
this
··. 2
.
··2 3
Leak
··3 7
)
··7 8
;
··8 9
return
¸¸ 
base
¸¸ 
.
¸¸ 
	ReadShort
¸¸ !
(
¸¸! "
)
¸¸" #
;
¸¸# $
}
¹¹ 	
public
»» 
override
»» 
ushort
»» 
ReadUnsignedShort
»» 0
(
»»0 1
)
»»1 2
{
¼¼ 	/
!RecordLeakNonRefCountingOperation
½½ -
(
½½- .
this
½½. 2
.
½½2 3
Leak
½½3 7
)
½½7 8
;
½½8 9
return
¾¾ 
base
¾¾ 
.
¾¾ 
ReadUnsignedShort
¾¾ )
(
¾¾) *
)
¾¾* +
;
¾¾+ ,
}
¿¿ 	
public
ÁÁ 
override
ÁÁ 
int
ÁÁ 

ReadMedium
ÁÁ &
(
ÁÁ& '
)
ÁÁ' (
{
ÂÂ 	/
!RecordLeakNonRefCountingOperation
ÃÃ -
(
ÃÃ- .
this
ÃÃ. 2
.
ÃÃ2 3
Leak
ÃÃ3 7
)
ÃÃ7 8
;
ÃÃ8 9
return
ÄÄ 
base
ÄÄ 
.
ÄÄ 

ReadMedium
ÄÄ "
(
ÄÄ" #
)
ÄÄ# $
;
ÄÄ$ %
}
ÅÅ 	
public
ÇÇ 
override
ÇÇ 
int
ÇÇ  
ReadUnsignedMedium
ÇÇ .
(
ÇÇ. /
)
ÇÇ/ 0
{
ÈÈ 	/
!RecordLeakNonRefCountingOperation
ÉÉ -
(
ÉÉ- .
this
ÉÉ. 2
.
ÉÉ2 3
Leak
ÉÉ3 7
)
ÉÉ7 8
;
ÉÉ8 9
return
ÊÊ 
base
ÊÊ 
.
ÊÊ  
ReadUnsignedMedium
ÊÊ *
(
ÊÊ* +
)
ÊÊ+ ,
;
ÊÊ, -
}
ËË 	
public
ÍÍ 
override
ÍÍ 
int
ÍÍ 
ReadInt
ÍÍ #
(
ÍÍ# $
)
ÍÍ$ %
{
ÎÎ 	/
!RecordLeakNonRefCountingOperation
ÏÏ -
(
ÏÏ- .
this
ÏÏ. 2
.
ÏÏ2 3
Leak
ÏÏ3 7
)
ÏÏ7 8
;
ÏÏ8 9
return
ĞĞ 
base
ĞĞ 
.
ĞĞ 
ReadInt
ĞĞ 
(
ĞĞ  
)
ĞĞ  !
;
ĞĞ! "
}
ÑÑ 	
public
ÓÓ 
override
ÓÓ 
uint
ÓÓ 
ReadUnsignedInt
ÓÓ ,
(
ÓÓ, -
)
ÓÓ- .
{
ÔÔ 	/
!RecordLeakNonRefCountingOperation
ÕÕ -
(
ÕÕ- .
this
ÕÕ. 2
.
ÕÕ2 3
Leak
ÕÕ3 7
)
ÕÕ7 8
;
ÕÕ8 9
return
ÖÖ 
base
ÖÖ 
.
ÖÖ 
ReadUnsignedInt
ÖÖ '
(
ÖÖ' (
)
ÖÖ( )
;
ÖÖ) *
}
×× 	
public
ÙÙ 
override
ÙÙ 
long
ÙÙ 
ReadLong
ÙÙ %
(
ÙÙ% &
)
ÙÙ& '
{
ÚÚ 	/
!RecordLeakNonRefCountingOperation
ÛÛ -
(
ÛÛ- .
this
ÛÛ. 2
.
ÛÛ2 3
Leak
ÛÛ3 7
)
ÛÛ7 8
;
ÛÛ8 9
return
ÜÜ 
base
ÜÜ 
.
ÜÜ 
ReadLong
ÜÜ  
(
ÜÜ  !
)
ÜÜ! "
;
ÜÜ" #
}
İİ 	
public
ßß 
override
ßß 
char
ßß 
ReadChar
ßß %
(
ßß% &
)
ßß& '
{
àà 	/
!RecordLeakNonRefCountingOperation
áá -
(
áá- .
this
áá. 2
.
áá2 3
Leak
áá3 7
)
áá7 8
;
áá8 9
return
ââ 
base
ââ 
.
ââ 
ReadChar
ââ  
(
ââ  !
)
ââ! "
;
ââ" #
}
ãã 	
public
åå 
override
åå 
float
åå 
	ReadFloat
åå '
(
åå' (
)
åå( )
{
ææ 	/
!RecordLeakNonRefCountingOperation
çç -
(
çç- .
this
çç. 2
.
çç2 3
Leak
çç3 7
)
çç7 8
;
çç8 9
return
èè 
base
èè 
.
èè 
	ReadFloat
èè !
(
èè! "
)
èè" #
;
èè# $
}
éé 	
public
ëë 
override
ëë 
double
ëë 

ReadDouble
ëë )
(
ëë) *
)
ëë* +
{
ìì 	/
!RecordLeakNonRefCountingOperation
íí -
(
íí- .
this
íí. 2
.
íí2 3
Leak
íí3 7
)
íí7 8
;
íí8 9
return
îî 
base
îî 
.
îî 

ReadDouble
îî "
(
îî" #
)
îî# $
;
îî$ %
}
ïï 	
public
ññ 
override
ññ 
IByteBuffer
ññ #
	ReadBytes
ññ$ -
(
ññ- .
int
ññ. 1
length
ññ2 8
)
ññ8 9
{
òò 	/
!RecordLeakNonRefCountingOperation
óó -
(
óó- .
this
óó. 2
.
óó2 3
Leak
óó3 7
)
óó7 8
;
óó8 9
return
ôô 
base
ôô 
.
ôô 
	ReadBytes
ôô !
(
ôô! "
length
ôô" (
)
ôô( )
;
ôô) *
}
õõ 	
public
÷÷ 
override
÷÷ 
IByteBuffer
÷÷ #
	ReadBytes
÷÷$ -
(
÷÷- .
IByteBuffer
÷÷. 9
dst
÷÷: =
)
÷÷= >
{
øø 	/
!RecordLeakNonRefCountingOperation
ùù -
(
ùù- .
this
ùù. 2
.
ùù2 3
Leak
ùù3 7
)
ùù7 8
;
ùù8 9
return
úú 
base
úú 
.
úú 
	ReadBytes
úú !
(
úú! "
dst
úú" %
)
úú% &
;
úú& '
}
ûû 	
public
ıı 
override
ıı 
IByteBuffer
ıı #
	ReadBytes
ıı$ -
(
ıı- .
IByteBuffer
ıı. 9
dst
ıı: =
,
ıı= >
int
ıı? B
length
ııC I
)
ııI J
{
şş 	/
!RecordLeakNonRefCountingOperation
ÿÿ -
(
ÿÿ- .
this
ÿÿ. 2
.
ÿÿ2 3
Leak
ÿÿ3 7
)
ÿÿ7 8
;
ÿÿ8 9
return
€€ 
base
€€ 
.
€€ 
	ReadBytes
€€ !
(
€€! "
dst
€€" %
,
€€% &
length
€€' -
)
€€- .
;
€€. /
}
 	
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #
	ReadBytes
ƒƒ$ -
(
ƒƒ- .
IByteBuffer
ƒƒ. 9
dst
ƒƒ: =
,
ƒƒ= >
int
ƒƒ? B
dstIndex
ƒƒC K
,
ƒƒK L
int
ƒƒM P
length
ƒƒQ W
)
ƒƒW X
{
„„ 	/
!RecordLeakNonRefCountingOperation
…… -
(
……- .
this
……. 2
.
……2 3
Leak
……3 7
)
……7 8
;
……8 9
return
†† 
base
†† 
.
†† 
	ReadBytes
†† !
(
††! "
dst
††" %
,
††% &
dstIndex
††' /
,
††/ 0
length
††1 7
)
††7 8
;
††8 9
}
‡‡ 	
public
‰‰ 
override
‰‰ 
IByteBuffer
‰‰ #
	ReadBytes
‰‰$ -
(
‰‰- .
byte
‰‰. 2
[
‰‰2 3
]
‰‰3 4
dst
‰‰5 8
)
‰‰8 9
{
ŠŠ 	/
!RecordLeakNonRefCountingOperation
‹‹ -
(
‹‹- .
this
‹‹. 2
.
‹‹2 3
Leak
‹‹3 7
)
‹‹7 8
;
‹‹8 9
return
ŒŒ 
base
ŒŒ 
.
ŒŒ 
	ReadBytes
ŒŒ !
(
ŒŒ! "
dst
ŒŒ" %
)
ŒŒ% &
;
ŒŒ& '
}
 	
public
 
override
 
IByteBuffer
 #
	ReadBytes
$ -
(
- .
byte
. 2
[
2 3
]
3 4
dst
5 8
,
8 9
int
: =
dstIndex
> F
,
F G
int
H K
length
L R
)
R S
{
 	/
!RecordLeakNonRefCountingOperation
‘‘ -
(
‘‘- .
this
‘‘. 2
.
‘‘2 3
Leak
‘‘3 7
)
‘‘7 8
;
‘‘8 9
return
’’ 
base
’’ 
.
’’ 
	ReadBytes
’’ !
(
’’! "
dst
’’" %
,
’’% &
dstIndex
’’' /
,
’’/ 0
length
’’1 7
)
’’7 8
;
’’8 9
}
““ 	
public
•• 
override
•• 
IByteBuffer
•• #
	ReadBytes
••$ -
(
••- .
Stream
••. 4
output
••5 ;
,
••; <
int
••= @
length
••A G
)
••G H
{
–– 	/
!RecordLeakNonRefCountingOperation
—— -
(
——- .
this
——. 2
.
——2 3
Leak
——3 7
)
——7 8
;
——8 9
return
˜˜ 
base
˜˜ 
.
˜˜ 
	ReadBytes
˜˜ !
(
˜˜! "
output
˜˜" (
,
˜˜( )
length
˜˜* 0
)
˜˜0 1
;
˜˜1 2
}
™™ 	
public
›› 
override
›› 
IByteBuffer
›› #
	SkipBytes
››$ -
(
››- .
int
››. 1
length
››2 8
)
››8 9
{
œœ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
	SkipBytes
 !
(
! "
length
" (
)
( )
;
) *
}
ŸŸ 	
public
¡¡ 
override
¡¡ 
IByteBuffer
¡¡ #
WriteBoolean
¡¡$ 0
(
¡¡0 1
bool
¡¡1 5
value
¡¡6 ;
)
¡¡; <
{
¢¢ 	/
!RecordLeakNonRefCountingOperation
££ -
(
££- .
this
££. 2
.
££2 3
Leak
££3 7
)
££7 8
;
££8 9
return
¤¤ 
base
¤¤ 
.
¤¤ 
WriteBoolean
¤¤ $
(
¤¤$ %
value
¤¤% *
)
¤¤* +
;
¤¤+ ,
}
¥¥ 	
public
§§ 
override
§§ 
IByteBuffer
§§ #
	WriteByte
§§$ -
(
§§- .
int
§§. 1
value
§§2 7
)
§§7 8
{
¨¨ 	/
!RecordLeakNonRefCountingOperation
©© -
(
©©- .
this
©©. 2
.
©©2 3
Leak
©©3 7
)
©©7 8
;
©©8 9
return
ªª 
base
ªª 
.
ªª 
	WriteByte
ªª !
(
ªª! "
value
ªª" '
)
ªª' (
;
ªª( )
}
«« 	
public
­­ 
override
­­ 
IByteBuffer
­­ #

WriteShort
­­$ .
(
­­. /
int
­­/ 2
value
­­3 8
)
­­8 9
{
®® 	/
!RecordLeakNonRefCountingOperation
¯¯ -
(
¯¯- .
this
¯¯. 2
.
¯¯2 3
Leak
¯¯3 7
)
¯¯7 8
;
¯¯8 9
return
°° 
base
°° 
.
°° 

WriteShort
°° "
(
°°" #
value
°°# (
)
°°( )
;
°°) *
}
±± 	
public
³³ 
override
³³ 
IByteBuffer
³³ #
WriteInt
³³$ ,
(
³³, -
int
³³- 0
value
³³1 6
)
³³6 7
{
´´ 	/
!RecordLeakNonRefCountingOperation
µµ -
(
µµ- .
this
µµ. 2
.
µµ2 3
Leak
µµ3 7
)
µµ7 8
;
µµ8 9
return
¶¶ 
base
¶¶ 
.
¶¶ 
WriteInt
¶¶  
(
¶¶  !
value
¶¶! &
)
¶¶& '
;
¶¶' (
}
·· 	
public
¹¹ 
override
¹¹ 
IByteBuffer
¹¹ #
WriteMedium
¹¹$ /
(
¹¹/ 0
int
¹¹0 3
value
¹¹4 9
)
¹¹9 :
{
ºº 	/
!RecordLeakNonRefCountingOperation
»» -
(
»»- .
this
»». 2
.
»»2 3
Leak
»»3 7
)
»»7 8
;
»»8 9
return
¼¼ 
base
¼¼ 
.
¼¼ 
WriteMedium
¼¼ #
(
¼¼# $
value
¼¼$ )
)
¼¼) *
;
¼¼* +
}
½½ 	
public
¿¿ 
override
¿¿ 
IByteBuffer
¿¿ #
	WriteLong
¿¿$ -
(
¿¿- .
long
¿¿. 2
value
¿¿3 8
)
¿¿8 9
{
ÀÀ 	/
!RecordLeakNonRefCountingOperation
ÁÁ -
(
ÁÁ- .
this
ÁÁ. 2
.
ÁÁ2 3
Leak
ÁÁ3 7
)
ÁÁ7 8
;
ÁÁ8 9
return
ÂÂ 
base
ÂÂ 
.
ÂÂ 
	WriteLong
ÂÂ !
(
ÂÂ! "
value
ÂÂ" '
)
ÂÂ' (
;
ÂÂ( )
}
ÃÃ 	
public
ÅÅ 
override
ÅÅ 
IByteBuffer
ÅÅ #
	WriteChar
ÅÅ$ -
(
ÅÅ- .
char
ÅÅ. 2
value
ÅÅ3 8
)
ÅÅ8 9
{
ÆÆ 	/
!RecordLeakNonRefCountingOperation
ÇÇ -
(
ÇÇ- .
this
ÇÇ. 2
.
ÇÇ2 3
Leak
ÇÇ3 7
)
ÇÇ7 8
;
ÇÇ8 9
return
ÈÈ 
base
ÈÈ 
.
ÈÈ 
	WriteChar
ÈÈ !
(
ÈÈ! "
value
ÈÈ" '
)
ÈÈ' (
;
ÈÈ( )
}
ÉÉ 	
public
ËË 
override
ËË 
IByteBuffer
ËË #

WriteFloat
ËË$ .
(
ËË. /
float
ËË/ 4
value
ËË5 :
)
ËË: ;
{
ÌÌ 	/
!RecordLeakNonRefCountingOperation
ÍÍ -
(
ÍÍ- .
this
ÍÍ. 2
.
ÍÍ2 3
Leak
ÍÍ3 7
)
ÍÍ7 8
;
ÍÍ8 9
return
ÎÎ 
base
ÎÎ 
.
ÎÎ 

WriteFloat
ÎÎ "
(
ÎÎ" #
value
ÎÎ# (
)
ÎÎ( )
;
ÎÎ) *
}
ÏÏ 	
public
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ #
WriteDouble
ÑÑ$ /
(
ÑÑ/ 0
double
ÑÑ0 6
value
ÑÑ7 <
)
ÑÑ< =
{
ÒÒ 	/
!RecordLeakNonRefCountingOperation
ÓÓ -
(
ÓÓ- .
this
ÓÓ. 2
.
ÓÓ2 3
Leak
ÓÓ3 7
)
ÓÓ7 8
;
ÓÓ8 9
return
ÔÔ 
base
ÔÔ 
.
ÔÔ 
WriteDouble
ÔÔ #
(
ÔÔ# $
value
ÔÔ$ )
)
ÔÔ) *
;
ÔÔ* +
}
ÕÕ 	
public
×× 
override
×× 
IByteBuffer
×× #

WriteBytes
××$ .
(
××. /
IByteBuffer
××/ :
src
××; >
)
××> ?
{
ØØ 	/
!RecordLeakNonRefCountingOperation
ÙÙ -
(
ÙÙ- .
this
ÙÙ. 2
.
ÙÙ2 3
Leak
ÙÙ3 7
)
ÙÙ7 8
;
ÙÙ8 9
return
ÚÚ 
base
ÚÚ 
.
ÚÚ 

WriteBytes
ÚÚ "
(
ÚÚ" #
src
ÚÚ# &
)
ÚÚ& '
;
ÚÚ' (
}
ÛÛ 	
public
İİ 
override
İİ 
IByteBuffer
İİ #

WriteBytes
İİ$ .
(
İİ. /
IByteBuffer
İİ/ :
src
İİ; >
,
İİ> ?
int
İİ@ C
length
İİD J
)
İİJ K
{
ŞŞ 	/
!RecordLeakNonRefCountingOperation
ßß -
(
ßß- .
this
ßß. 2
.
ßß2 3
Leak
ßß3 7
)
ßß7 8
;
ßß8 9
return
àà 
base
àà 
.
àà 

WriteBytes
àà "
(
àà" #
src
àà# &
,
àà& '
length
àà( .
)
àà. /
;
àà/ 0
}
áá 	
public
ãã 
override
ãã 
IByteBuffer
ãã #

WriteBytes
ãã$ .
(
ãã. /
IByteBuffer
ãã/ :
src
ãã; >
,
ãã> ?
int
ãã@ C
srcIndex
ããD L
,
ããL M
int
ããN Q
length
ããR X
)
ããX Y
{
ää 	/
!RecordLeakNonRefCountingOperation
åå -
(
åå- .
this
åå. 2
.
åå2 3
Leak
åå3 7
)
åå7 8
;
åå8 9
return
ææ 
base
ææ 
.
ææ 

WriteBytes
ææ "
(
ææ" #
src
ææ# &
,
ææ& '
srcIndex
ææ( 0
,
ææ0 1
length
ææ2 8
)
ææ8 9
;
ææ9 :
}
çç 	
public
éé 
override
éé 
IByteBuffer
éé #

WriteBytes
éé$ .
(
éé. /
byte
éé/ 3
[
éé3 4
]
éé4 5
src
éé6 9
)
éé9 :
{
êê 	/
!RecordLeakNonRefCountingOperation
ëë -
(
ëë- .
this
ëë. 2
.
ëë2 3
Leak
ëë3 7
)
ëë7 8
;
ëë8 9
return
ìì 
base
ìì 
.
ìì 

WriteBytes
ìì "
(
ìì" #
src
ìì# &
)
ìì& '
;
ìì' (
}
íí 	
public
ïï 
override
ïï 
IByteBuffer
ïï #

WriteBytes
ïï$ .
(
ïï. /
byte
ïï/ 3
[
ïï3 4
]
ïï4 5
src
ïï6 9
,
ïï9 :
int
ïï; >
srcIndex
ïï? G
,
ïïG H
int
ïïI L
length
ïïM S
)
ïïS T
{
ğğ 	/
!RecordLeakNonRefCountingOperation
ññ -
(
ññ- .
this
ññ. 2
.
ññ2 3
Leak
ññ3 7
)
ññ7 8
;
ññ8 9
return
òò 
base
òò 
.
òò 

WriteBytes
òò "
(
òò" #
src
òò# &
,
òò& '
srcIndex
òò( 0
,
òò0 1
length
òò2 8
)
òò8 9
;
òò9 :
}
óó 	
public
õõ 
override
õõ 
Task
õõ 
WriteBytesAsync
õõ ,
(
õõ, -
Stream
õõ- 3
input
õõ4 9
,
õõ9 :
int
õõ; >
length
õõ? E
,
õõE F
CancellationToken
õõG X
cancellationToken
õõY j
)
õõj k
{
öö 	/
!RecordLeakNonRefCountingOperation
÷÷ -
(
÷÷- .
this
÷÷. 2
.
÷÷2 3
Leak
÷÷3 7
)
÷÷7 8
;
÷÷8 9
return
øø 
base
øø 
.
øø 
WriteBytesAsync
øø '
(
øø' (
input
øø( -
,
øø- .
length
øø/ 5
,
øø5 6
cancellationToken
øø7 H
)
øøH I
;
øøI J
}
ùù 	
public
ûû 
override
ûû 
IByteBuffer
ûû #
	WriteZero
ûû$ -
(
ûû- .
int
ûû. 1
length
ûû2 8
)
ûû8 9
{
üü 	/
!RecordLeakNonRefCountingOperation
ıı -
(
ıı- .
this
ıı. 2
.
ıı2 3
Leak
ıı3 7
)
ıı7 8
;
ıı8 9
return
şş 
base
şş 
.
şş 
	WriteZero
şş !
(
şş! "
length
şş" (
)
şş( )
;
şş) *
}
ÿÿ 	
public
 
override
 
int
 
IndexOf
 #
(
# $
int
$ '
	fromIndex
( 1
,
1 2
int
3 6
toIndex
7 >
,
> ?
byte
@ D
value
E J
)
J K
{
‚‚ 	/
!RecordLeakNonRefCountingOperation
ƒƒ -
(
ƒƒ- .
this
ƒƒ. 2
.
ƒƒ2 3
Leak
ƒƒ3 7
)
ƒƒ7 8
;
ƒƒ8 9
return
„„ 
base
„„ 
.
„„ 
IndexOf
„„ 
(
„„  
	fromIndex
„„  )
,
„„) *
toIndex
„„+ 2
,
„„2 3
value
„„4 9
)
„„9 :
;
„„: ;
}
…… 	
public
‡‡ 
override
‡‡ 
int
‡‡ 
BytesBefore
‡‡ '
(
‡‡' (
byte
‡‡( ,
value
‡‡- 2
)
‡‡2 3
{
ˆˆ 	/
!RecordLeakNonRefCountingOperation
‰‰ -
(
‰‰- .
this
‰‰. 2
.
‰‰2 3
Leak
‰‰3 7
)
‰‰7 8
;
‰‰8 9
return
ŠŠ 
base
ŠŠ 
.
ŠŠ 
BytesBefore
ŠŠ #
(
ŠŠ# $
value
ŠŠ$ )
)
ŠŠ) *
;
ŠŠ* +
}
‹‹ 	
public
 
override
 
int
 
BytesBefore
 '
(
' (
int
( +
length
, 2
,
2 3
byte
4 8
value
9 >
)
> ?
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
BytesBefore
 #
(
# $
length
$ *
,
* +
value
, 1
)
1 2
;
2 3
}
‘‘ 	
public
““ 
override
““ 
int
““ 
BytesBefore
““ '
(
““' (
int
““( +
index
““, 1
,
““1 2
int
““3 6
length
““7 =
,
““= >
byte
““? C
value
““D I
)
““I J
{
”” 	/
!RecordLeakNonRefCountingOperation
•• -
(
••- .
this
••. 2
.
••2 3
Leak
••3 7
)
••7 8
;
••8 9
return
–– 
base
–– 
.
–– 
BytesBefore
–– #
(
––# $
index
––$ )
,
––) *
length
––+ 1
,
––1 2
value
––3 8
)
––8 9
;
––9 :
}
—— 	
public
™™ 
override
™™ 
int
™™ 
ForEachByte
™™ '
(
™™' (
IByteProcessor
™™( 6
	processor
™™7 @
)
™™@ A
{
šš 	/
!RecordLeakNonRefCountingOperation
›› -
(
››- .
this
››. 2
.
››2 3
Leak
››3 7
)
››7 8
;
››8 9
return
œœ 
base
œœ 
.
œœ 
ForEachByte
œœ #
(
œœ# $
	processor
œœ$ -
)
œœ- .
;
œœ. /
}
 	
public
ŸŸ 
override
ŸŸ 
int
ŸŸ 
ForEachByte
ŸŸ '
(
ŸŸ' (
int
ŸŸ( +
index
ŸŸ, 1
,
ŸŸ1 2
int
ŸŸ3 6
length
ŸŸ7 =
,
ŸŸ= >
IByteProcessor
ŸŸ? M
	processor
ŸŸN W
)
ŸŸW X
{
   	/
!RecordLeakNonRefCountingOperation
¡¡ -
(
¡¡- .
this
¡¡. 2
.
¡¡2 3
Leak
¡¡3 7
)
¡¡7 8
;
¡¡8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
ForEachByte
¢¢ #
(
¢¢# $
index
¢¢$ )
,
¢¢) *
length
¢¢+ 1
,
¢¢1 2
	processor
¢¢3 <
)
¢¢< =
;
¢¢= >
}
££ 	
public
¥¥ 
override
¥¥ 
int
¥¥ 
ForEachByteDesc
¥¥ +
(
¥¥+ ,
IByteProcessor
¥¥, :
	processor
¥¥; D
)
¥¥D E
{
¦¦ 	/
!RecordLeakNonRefCountingOperation
§§ -
(
§§- .
this
§§. 2
.
§§2 3
Leak
§§3 7
)
§§7 8
;
§§8 9
return
¨¨ 
base
¨¨ 
.
¨¨ 
ForEachByteDesc
¨¨ '
(
¨¨' (
	processor
¨¨( 1
)
¨¨1 2
;
¨¨2 3
}
©© 	
public
«« 
override
«« 
int
«« 
ForEachByteDesc
«« +
(
««+ ,
int
««, /
index
««0 5
,
««5 6
int
««7 :
length
««; A
,
««A B
IByteProcessor
««C Q
	processor
««R [
)
««[ \
{
¬¬ 	/
!RecordLeakNonRefCountingOperation
­­ -
(
­­- .
this
­­. 2
.
­­2 3
Leak
­­3 7
)
­­7 8
;
­­8 9
return
®® 
base
®® 
.
®® 
ForEachByteDesc
®® '
(
®®' (
index
®®( -
,
®®- .
length
®®/ 5
,
®®5 6
	processor
®®7 @
)
®®@ A
;
®®A B
}
¯¯ 	
public
±± 
override
±± 
IByteBuffer
±± #
Copy
±±$ (
(
±±( )
)
±±) *
{
²² 	/
!RecordLeakNonRefCountingOperation
³³ -
(
³³- .
this
³³. 2
.
³³2 3
Leak
³³3 7
)
³³7 8
;
³³8 9
return
´´ 
base
´´ 
.
´´ 
Copy
´´ 
(
´´ 
)
´´ 
;
´´ 
}
µµ 	
public
·· 
override
·· 
IByteBuffer
·· #
Copy
··$ (
(
··( )
int
··) ,
index
··- 2
,
··2 3
int
··4 7
length
··8 >
)
··> ?
{
¸¸ 	/
!RecordLeakNonRefCountingOperation
¹¹ -
(
¹¹- .
this
¹¹. 2
.
¹¹2 3
Leak
¹¹3 7
)
¹¹7 8
;
¹¹8 9
return
ºº 
base
ºº 
.
ºº 
Copy
ºº 
(
ºº 
index
ºº "
,
ºº" #
length
ºº$ *
)
ºº* +
;
ºº+ ,
}
»» 	
public
½½ 
override
½½ 
int
½½ 
IoBufferCount
½½ )
{
¾¾ 	
get
¿¿ 
{
ÀÀ /
!RecordLeakNonRefCountingOperation
ÁÁ 1
(
ÁÁ1 2
this
ÁÁ2 6
.
ÁÁ6 7
Leak
ÁÁ7 ;
)
ÁÁ; <
;
ÁÁ< =
return
ÂÂ 
base
ÂÂ 
.
ÂÂ 
IoBufferCount
ÂÂ )
;
ÂÂ) *
}
ÃÃ 
}
ÄÄ 	
public
ÆÆ 
override
ÆÆ 
ArraySegment
ÆÆ $
<
ÆÆ$ %
byte
ÆÆ% )
>
ÆÆ) *
GetIoBuffer
ÆÆ+ 6
(
ÆÆ6 7
)
ÆÆ7 8
{
ÇÇ 	/
!RecordLeakNonRefCountingOperation
ÈÈ -
(
ÈÈ- .
this
ÈÈ. 2
.
ÈÈ2 3
Leak
ÈÈ3 7
)
ÈÈ7 8
;
ÈÈ8 9
return
ÉÉ 
base
ÉÉ 
.
ÉÉ 
GetIoBuffer
ÉÉ #
(
ÉÉ# $
)
ÉÉ$ %
;
ÉÉ% &
}
ÊÊ 	
public
ÌÌ 
override
ÌÌ 
ArraySegment
ÌÌ $
<
ÌÌ$ %
byte
ÌÌ% )
>
ÌÌ) *
GetIoBuffer
ÌÌ+ 6
(
ÌÌ6 7
int
ÌÌ7 :
index
ÌÌ; @
,
ÌÌ@ A
int
ÌÌB E
length
ÌÌF L
)
ÌÌL M
{
ÍÍ 	/
!RecordLeakNonRefCountingOperation
ÎÎ -
(
ÎÎ- .
this
ÎÎ. 2
.
ÎÎ2 3
Leak
ÎÎ3 7
)
ÎÎ7 8
;
ÎÎ8 9
return
ÏÏ 
base
ÏÏ 
.
ÏÏ 
GetIoBuffer
ÏÏ #
(
ÏÏ# $
index
ÏÏ$ )
,
ÏÏ) *
length
ÏÏ+ 1
)
ÏÏ1 2
;
ÏÏ2 3
}
ĞĞ 	
public
ÒÒ 
override
ÒÒ 
ArraySegment
ÒÒ $
<
ÒÒ$ %
byte
ÒÒ% )
>
ÒÒ) *
[
ÒÒ* +
]
ÒÒ+ ,
GetIoBuffers
ÒÒ- 9
(
ÒÒ9 :
)
ÒÒ: ;
{
ÓÓ 	/
!RecordLeakNonRefCountingOperation
ÔÔ -
(
ÔÔ- .
this
ÔÔ. 2
.
ÔÔ2 3
Leak
ÔÔ3 7
)
ÔÔ7 8
;
ÔÔ8 9
return
ÕÕ 
base
ÕÕ 
.
ÕÕ 
GetIoBuffers
ÕÕ $
(
ÕÕ$ %
)
ÕÕ% &
;
ÕÕ& '
}
ÖÖ 	
public
ØØ 
override
ØØ 
ArraySegment
ØØ $
<
ØØ$ %
byte
ØØ% )
>
ØØ) *
[
ØØ* +
]
ØØ+ ,
GetIoBuffers
ØØ- 9
(
ØØ9 :
int
ØØ: =
index
ØØ> C
,
ØØC D
int
ØØE H
length
ØØI O
)
ØØO P
{
ÙÙ 	/
!RecordLeakNonRefCountingOperation
ÚÚ -
(
ÚÚ- .
this
ÚÚ. 2
.
ÚÚ2 3
Leak
ÚÚ3 7
)
ÚÚ7 8
;
ÚÚ8 9
return
ÛÛ 
base
ÛÛ 
.
ÛÛ 
GetIoBuffers
ÛÛ $
(
ÛÛ$ %
index
ÛÛ% *
,
ÛÛ* +
length
ÛÛ, 2
)
ÛÛ2 3
;
ÛÛ3 4
}
ÜÜ 	
public
ŞŞ 
override
ŞŞ 
string
ŞŞ 
ToString
ŞŞ '
(
ŞŞ' (
Encoding
ŞŞ( 0
encoding
ŞŞ1 9
)
ŞŞ9 :
{
ßß 	/
!RecordLeakNonRefCountingOperation
àà -
(
àà- .
this
àà. 2
.
àà2 3
Leak
àà3 7
)
àà7 8
;
àà8 9
return
áá 
base
áá 
.
áá 
ToString
áá  
(
áá  !
encoding
áá! )
)
áá) *
;
áá* +
}
ââ 	
public
ää 
override
ää 
string
ää 
ToString
ää '
(
ää' (
int
ää( +
index
ää, 1
,
ää1 2
int
ää3 6
length
ää7 =
,
ää= >
Encoding
ää? G
encoding
ääH P
)
ääP Q
{
åå 	/
!RecordLeakNonRefCountingOperation
ææ -
(
ææ- .
this
ææ. 2
.
ææ2 3
Leak
ææ3 7
)
ææ7 8
;
ææ8 9
return
çç 
base
çç 
.
çç 
ToString
çç  
(
çç  !
index
çç! &
,
çç& '
length
çç( .
,
çç. /
encoding
çç0 8
)
çç8 9
;
çç9 :
}
èè 	
public
êê 
override
êê 
IByteBuffer
êê #
AdjustCapacity
êê$ 2
(
êê2 3
int
êê3 6
newCapacity
êê7 B
)
êêB C
{
ëë 	/
!RecordLeakNonRefCountingOperation
ìì -
(
ìì- .
this
ìì. 2
.
ìì2 3
Leak
ìì3 7
)
ìì7 8
;
ìì8 9
return
íí 
base
íí 
.
íí 
AdjustCapacity
íí &
(
íí& '
newCapacity
íí' 2
)
íí2 3
;
íí3 4
}
îî 	
public
ğğ 
override
ğğ 
short
ğğ 

GetShortLE
ğğ (
(
ğğ( )
int
ğğ) ,
index
ğğ- 2
)
ğğ2 3
{
ññ 	/
!RecordLeakNonRefCountingOperation
òò -
(
òò- .
this
òò. 2
.
òò2 3
Leak
òò3 7
)
òò7 8
;
òò8 9
return
óó 
base
óó 
.
óó 

GetShortLE
óó "
(
óó" #
index
óó# (
)
óó( )
;
óó) *
}
ôô 	
public
öö 
override
öö 
ushort
öö  
GetUnsignedShortLE
öö 1
(
öö1 2
int
öö2 5
index
öö6 ;
)
öö; <
{
÷÷ 	/
!RecordLeakNonRefCountingOperation
øø -
(
øø- .
this
øø. 2
.
øø2 3
Leak
øø3 7
)
øø7 8
;
øø8 9
return
ùù 
base
ùù 
.
ùù  
GetUnsignedShortLE
ùù *
(
ùù* +
index
ùù+ 0
)
ùù0 1
;
ùù1 2
}
úú 	
public
üü 
override
üü 
int
üü 
GetMediumLE
üü '
(
üü' (
int
üü( +
index
üü, 1
)
üü1 2
{
ıı 	/
!RecordLeakNonRefCountingOperation
şş -
(
şş- .
this
şş. 2
.
şş2 3
Leak
şş3 7
)
şş7 8
;
şş8 9
return
ÿÿ 
base
ÿÿ 
.
ÿÿ 
GetMediumLE
ÿÿ #
(
ÿÿ# $
index
ÿÿ$ )
)
ÿÿ) *
;
ÿÿ* +
}
€€ 	
public
‚‚ 
override
‚‚ 
int
‚‚ !
GetUnsignedMediumLE
‚‚ /
(
‚‚/ 0
int
‚‚0 3
index
‚‚4 9
)
‚‚9 :
{
ƒƒ 	/
!RecordLeakNonRefCountingOperation
„„ -
(
„„- .
this
„„. 2
.
„„2 3
Leak
„„3 7
)
„„7 8
;
„„8 9
return
…… 
base
…… 
.
…… !
GetUnsignedMediumLE
…… +
(
……+ ,
index
……, 1
)
……1 2
;
……2 3
}
†† 	
public
ˆˆ 
override
ˆˆ 
int
ˆˆ 
GetIntLE
ˆˆ $
(
ˆˆ$ %
int
ˆˆ% (
index
ˆˆ) .
)
ˆˆ. /
{
‰‰ 	/
!RecordLeakNonRefCountingOperation
ŠŠ -
(
ŠŠ- .
this
ŠŠ. 2
.
ŠŠ2 3
Leak
ŠŠ3 7
)
ŠŠ7 8
;
ŠŠ8 9
return
‹‹ 
base
‹‹ 
.
‹‹ 
GetIntLE
‹‹  
(
‹‹  !
index
‹‹! &
)
‹‹& '
;
‹‹' (
}
ŒŒ 	
public
 
override
 
uint
 
GetUnsignedIntLE
 -
(
- .
int
. 1
index
2 7
)
7 8
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
‘‘ 
base
‘‘ 
.
‘‘ 
GetUnsignedIntLE
‘‘ (
(
‘‘( )
index
‘‘) .
)
‘‘. /
;
‘‘/ 0
}
’’ 	
public
”” 
override
”” 
long
”” 
	GetLongLE
”” &
(
””& '
int
””' *
index
””+ 0
)
””0 1
{
•• 	/
!RecordLeakNonRefCountingOperation
–– -
(
––- .
this
––. 2
.
––2 3
Leak
––3 7
)
––7 8
;
––8 9
return
—— 
base
—— 
.
—— 
	GetLongLE
—— !
(
——! "
index
——" '
)
——' (
;
——( )
}
˜˜ 	
public
šš 
override
šš 
IByteBuffer
šš #

SetShortLE
šš$ .
(
šš. /
int
šš/ 2
index
šš3 8
,
šš8 9
int
šš: =
value
šš> C
)
ššC D
{
›› 	/
!RecordLeakNonRefCountingOperation
œœ -
(
œœ- .
this
œœ. 2
.
œœ2 3
Leak
œœ3 7
)
œœ7 8
;
œœ8 9
return
 
base
 
.
 

SetShortLE
 "
(
" #
index
# (
,
( )
value
* /
)
/ 0
;
0 1
}
 	
public
   
override
   
IByteBuffer
   #
SetIntLE
  $ ,
(
  , -
int
  - 0
index
  1 6
,
  6 7
int
  8 ;
value
  < A
)
  A B
{
¡¡ 	/
!RecordLeakNonRefCountingOperation
¢¢ -
(
¢¢- .
this
¢¢. 2
.
¢¢2 3
Leak
¢¢3 7
)
¢¢7 8
;
¢¢8 9
return
££ 
base
££ 
.
££ 
SetIntLE
££  
(
££  !
index
££! &
,
££& '
value
££( -
)
££- .
;
££. /
}
¤¤ 	
public
¦¦ 
override
¦¦ 
IByteBuffer
¦¦ #
SetMediumLE
¦¦$ /
(
¦¦/ 0
int
¦¦0 3
index
¦¦4 9
,
¦¦9 :
int
¦¦; >
value
¦¦? D
)
¦¦D E
{
§§ 	/
!RecordLeakNonRefCountingOperation
¨¨ -
(
¨¨- .
this
¨¨. 2
.
¨¨2 3
Leak
¨¨3 7
)
¨¨7 8
;
¨¨8 9
return
©© 
base
©© 
.
©© 
SetMediumLE
©© #
(
©©# $
index
©©$ )
,
©©) *
value
©©+ 0
)
©©0 1
;
©©1 2
}
ªª 	
public
¬¬ 
override
¬¬ 
IByteBuffer
¬¬ #
	SetLongLE
¬¬$ -
(
¬¬- .
int
¬¬. 1
index
¬¬2 7
,
¬¬7 8
long
¬¬9 =
value
¬¬> C
)
¬¬C D
{
­­ 	/
!RecordLeakNonRefCountingOperation
®® -
(
®®- .
this
®®. 2
.
®®2 3
Leak
®®3 7
)
®®7 8
;
®®8 9
return
¯¯ 
base
¯¯ 
.
¯¯ 
	SetLongLE
¯¯ !
(
¯¯! "
index
¯¯" '
,
¯¯' (
value
¯¯) .
)
¯¯. /
;
¯¯/ 0
}
°° 	
public
²² 
override
²² 
short
²² 
ReadShortLE
²² )
(
²²) *
)
²²* +
{
³³ 	/
!RecordLeakNonRefCountingOperation
´´ -
(
´´- .
this
´´. 2
.
´´2 3
Leak
´´3 7
)
´´7 8
;
´´8 9
return
µµ 
base
µµ 
.
µµ 
ReadShortLE
µµ #
(
µµ# $
)
µµ$ %
;
µµ% &
}
¶¶ 	
public
¸¸ 
override
¸¸ 
ushort
¸¸ !
ReadUnsignedShortLE
¸¸ 2
(
¸¸2 3
)
¸¸3 4
{
¹¹ 	/
!RecordLeakNonRefCountingOperation
ºº -
(
ºº- .
this
ºº. 2
.
ºº2 3
Leak
ºº3 7
)
ºº7 8
;
ºº8 9
return
»» 
base
»» 
.
»» !
ReadUnsignedShortLE
»» +
(
»»+ ,
)
»», -
;
»»- .
}
¼¼ 	
public
¾¾ 
override
¾¾ 
int
¾¾ 
ReadMediumLE
¾¾ (
(
¾¾( )
)
¾¾) *
{
¿¿ 	/
!RecordLeakNonRefCountingOperation
ÀÀ -
(
ÀÀ- .
this
ÀÀ. 2
.
ÀÀ2 3
Leak
ÀÀ3 7
)
ÀÀ7 8
;
ÀÀ8 9
return
ÁÁ 
base
ÁÁ 
.
ÁÁ 
ReadMediumLE
ÁÁ $
(
ÁÁ$ %
)
ÁÁ% &
;
ÁÁ& '
}
ÂÂ 	
public
ÄÄ 
override
ÄÄ 
int
ÄÄ "
ReadUnsignedMediumLE
ÄÄ 0
(
ÄÄ0 1
)
ÄÄ1 2
{
ÅÅ 	/
!RecordLeakNonRefCountingOperation
ÆÆ -
(
ÆÆ- .
this
ÆÆ. 2
.
ÆÆ2 3
Leak
ÆÆ3 7
)
ÆÆ7 8
;
ÆÆ8 9
return
ÇÇ 
base
ÇÇ 
.
ÇÇ "
ReadUnsignedMediumLE
ÇÇ ,
(
ÇÇ, -
)
ÇÇ- .
;
ÇÇ. /
}
ÈÈ 	
public
ÊÊ 
override
ÊÊ 
int
ÊÊ 
	ReadIntLE
ÊÊ %
(
ÊÊ% &
)
ÊÊ& '
{
ËË 	/
!RecordLeakNonRefCountingOperation
ÌÌ -
(
ÌÌ- .
this
ÌÌ. 2
.
ÌÌ2 3
Leak
ÌÌ3 7
)
ÌÌ7 8
;
ÌÌ8 9
return
ÍÍ 
base
ÍÍ 
.
ÍÍ 
	ReadIntLE
ÍÍ !
(
ÍÍ! "
)
ÍÍ" #
;
ÍÍ# $
}
ÎÎ 	
public
ĞĞ 
override
ĞĞ 
uint
ĞĞ 
ReadUnsignedIntLE
ĞĞ .
(
ĞĞ. /
)
ĞĞ/ 0
{
ÑÑ 	/
!RecordLeakNonRefCountingOperation
ÒÒ -
(
ÒÒ- .
this
ÒÒ. 2
.
ÒÒ2 3
Leak
ÒÒ3 7
)
ÒÒ7 8
;
ÒÒ8 9
return
ÓÓ 
base
ÓÓ 
.
ÓÓ 
ReadUnsignedIntLE
ÓÓ )
(
ÓÓ) *
)
ÓÓ* +
;
ÓÓ+ ,
}
ÔÔ 	
public
ÖÖ 
override
ÖÖ 
long
ÖÖ 

ReadLongLE
ÖÖ '
(
ÖÖ' (
)
ÖÖ( )
{
×× 	/
!RecordLeakNonRefCountingOperation
ØØ -
(
ØØ- .
this
ØØ. 2
.
ØØ2 3
Leak
ØØ3 7
)
ØØ7 8
;
ØØ8 9
return
ÙÙ 
base
ÙÙ 
.
ÙÙ 

ReadLongLE
ÙÙ "
(
ÙÙ" #
)
ÙÙ# $
;
ÙÙ$ %
}
ÚÚ 	
public
ÜÜ 
override
ÜÜ 
IByteBuffer
ÜÜ #
WriteShortLE
ÜÜ$ 0
(
ÜÜ0 1
int
ÜÜ1 4
value
ÜÜ5 :
)
ÜÜ: ;
{
İİ 	/
!RecordLeakNonRefCountingOperation
ŞŞ -
(
ŞŞ- .
this
ŞŞ. 2
.
ŞŞ2 3
Leak
ŞŞ3 7
)
ŞŞ7 8
;
ŞŞ8 9
return
ßß 
base
ßß 
.
ßß 
WriteShortLE
ßß $
(
ßß$ %
value
ßß% *
)
ßß* +
;
ßß+ ,
}
àà 	
public
ââ 
override
ââ 
IByteBuffer
ââ #
WriteMediumLE
ââ$ 1
(
ââ1 2
int
ââ2 5
value
ââ6 ;
)
ââ; <
{
ãã 	/
!RecordLeakNonRefCountingOperation
ää -
(
ää- .
this
ää. 2
.
ää2 3
Leak
ää3 7
)
ää7 8
;
ää8 9
return
åå 
base
åå 
.
åå 
WriteMediumLE
åå %
(
åå% &
value
åå& +
)
åå+ ,
;
åå, -
}
ææ 	
public
èè 
override
èè 
IByteBuffer
èè #

WriteIntLE
èè$ .
(
èè. /
int
èè/ 2
value
èè3 8
)
èè8 9
{
éé 	/
!RecordLeakNonRefCountingOperation
êê -
(
êê- .
this
êê. 2
.
êê2 3
Leak
êê3 7
)
êê7 8
;
êê8 9
return
ëë 
base
ëë 
.
ëë 

WriteIntLE
ëë "
(
ëë" #
value
ëë# (
)
ëë( )
;
ëë) *
}
ìì 	
public
îî 
override
îî 
IByteBuffer
îî #
WriteLongLE
îî$ /
(
îî/ 0
long
îî0 4
value
îî5 :
)
îî: ;
{
ïï 	/
!RecordLeakNonRefCountingOperation
ğğ -
(
ğğ- .
this
ğğ. 2
.
ğğ2 3
Leak
ğğ3 7
)
ğğ7 8
;
ğğ8 9
return
ññ 
base
ññ 
.
ññ 
WriteLongLE
ññ #
(
ññ# $
value
ññ$ )
)
ññ) *
;
ññ* +
}
òò 	
public
ôô 
override
ôô 
IByteBuffer
ôô #
GetBytes
ôô$ ,
(
ôô, -
int
ôô- 0
index
ôô1 6
,
ôô6 7
Stream
ôô8 >
destination
ôô? J
,
ôôJ K
int
ôôL O
length
ôôP V
)
ôôV W
{
õõ 	/
!RecordLeakNonRefCountingOperation
öö -
(
öö- .
this
öö. 2
.
öö2 3
Leak
öö3 7
)
öö7 8
;
öö8 9
return
÷÷ 
base
÷÷ 
.
÷÷ 
GetBytes
÷÷  
(
÷÷  !
index
÷÷! &
,
÷÷& '
destination
÷÷( 3
,
÷÷3 4
length
÷÷5 ;
)
÷÷; <
;
÷÷< =
}
øø 	
public
úú 
override
úú 
IReferenceCounted
úú )
Retain
úú* 0
(
úú0 1
)
úú1 2
{
ûû 	
this
üü 
.
üü 
Leak
üü 
.
üü 
Record
üü 
(
üü 
)
üü 
;
üü 
return
ıı 
base
ıı 
.
ıı 
Retain
ıı 
(
ıı 
)
ıı  
;
ıı  !
}
şş 	
public
€€ 
override
€€ 
IReferenceCounted
€€ )
Retain
€€* 0
(
€€0 1
int
€€1 4
	increment
€€5 >
)
€€> ?
{
 	
this
‚‚ 
.
‚‚ 
Leak
‚‚ 
.
‚‚ 
Record
‚‚ 
(
‚‚ 
)
‚‚ 
;
‚‚ 
return
ƒƒ 
base
ƒƒ 
.
ƒƒ 
Retain
ƒƒ 
(
ƒƒ 
	increment
ƒƒ (
)
ƒƒ( )
;
ƒƒ) *
}
„„ 	
public
†† 
override
†† 
IByteBuffer
†† #
RetainedSlice
††$ 1
(
††1 2
)
††2 3
{
‡‡ 	/
!RecordLeakNonRefCountingOperation
ˆˆ -
(
ˆˆ- .
this
ˆˆ. 2
.
ˆˆ2 3
Leak
ˆˆ3 7
)
ˆˆ7 8
;
ˆˆ8 9
return
‰‰ 
base
‰‰ 
.
‰‰ 
RetainedSlice
‰‰ %
(
‰‰% &
)
‰‰& '
;
‰‰' (
}
ŠŠ 	
public
ŒŒ 
override
ŒŒ 
IByteBuffer
ŒŒ #
RetainedSlice
ŒŒ$ 1
(
ŒŒ1 2
int
ŒŒ2 5
index
ŒŒ6 ;
,
ŒŒ; <
int
ŒŒ= @
length
ŒŒA G
)
ŒŒG H
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
RetainedSlice
 %
(
% &
index
& +
,
+ ,
length
- 3
)
3 4
;
4 5
}
 	
public
’’ 
override
’’ 
IByteBuffer
’’ #
RetainedDuplicate
’’$ 5
(
’’5 6
)
’’6 7
{
““ 	/
!RecordLeakNonRefCountingOperation
”” -
(
””- .
this
””. 2
.
””2 3
Leak
””3 7
)
””7 8
;
””8 9
return
•• 
base
•• 
.
•• 
RetainedDuplicate
•• )
(
••) *
)
••* +
;
••+ ,
}
–– 	
public
˜˜ 
override
˜˜ 
IByteBuffer
˜˜ #
ReadRetainedSlice
˜˜$ 5
(
˜˜5 6
int
˜˜6 9
length
˜˜: @
)
˜˜@ A
{
™™ 	/
!RecordLeakNonRefCountingOperation
šš -
(
šš- .
this
šš. 2
.
šš2 3
Leak
šš3 7
)
šš7 8
;
šš8 9
return
›› 
base
›› 
.
›› 
ReadRetainedSlice
›› )
(
››) *
length
››* 0
)
››0 1
;
››1 2
}
œœ 	
public
 
override
 
IReferenceCounted
 )
Touch
* /
(
/ 0
)
0 1
{
ŸŸ 	
this
   
.
   
Leak
   
.
   
Record
   
(
   
)
   
;
   
return
¡¡ 
this
¡¡ 
;
¡¡ 
}
¢¢ 	
public
¤¤ 
override
¤¤ 
IReferenceCounted
¤¤ )
Touch
¤¤* /
(
¤¤/ 0
object
¤¤0 6
hint
¤¤7 ;
)
¤¤; <
{
¥¥ 	
this
¦¦ 
.
¦¦ 
Leak
¦¦ 
.
¦¦ 
Record
¦¦ 
(
¦¦ 
hint
¦¦ !
)
¦¦! "
;
¦¦" #
return
§§ 
this
§§ 
;
§§ 
}
¨¨ 	
public
ªª 
override
ªª 
bool
ªª 
Release
ªª $
(
ªª$ %
)
ªª% &
{
«« 	
this
¬¬ 
.
¬¬ 
Leak
¬¬ 
.
¬¬ 
Record
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
return
­­ 
base
­­ 
.
­­ 
Release
­­ 
(
­­  
)
­­  !
;
­­! "
}
®® 	
public
°° 
override
°° 
bool
°° 
Release
°° $
(
°°$ %
int
°°% (
	decrement
°°) 2
)
°°2 3
{
±± 	
this
²² 
.
²² 
Leak
²² 
.
²² 
Record
²² 
(
²² 
)
²² 
;
²² 
return
³³ 
base
³³ 
.
³³ 
Release
³³ 
(
³³  
	decrement
³³  )
)
³³) *
;
³³* +
}
´´ 	
	protected
¶¶ 
override
¶¶ '
SimpleLeakAwareByteBuffer
¶¶ 4$
NewLeakAwareByteBuffer
¶¶5 K
(
¶¶K L
IByteBuffer
¶¶L W
buf
¶¶X [
,
¶¶[ \
IByteBuffer
¶¶] h
trackedByteBuf
¶¶i w
,
¶¶w x#
IResourceLeakTracker¶¶y 
leakTracker¶¶ ™
)¶¶™ š
=>¶¶› 
new
·· )
AdvancedLeakAwareByteBuffer
·· +
(
··+ ,
buf
··, /
,
··/ 0
trackedByteBuf
··1 ?
,
··? @
leakTracker
··A L
)
··L M
;
··M N
}
¸¸ 
}¹¹ ²Ù
wC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AdvancedLeakAwareCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 0
$AdvancedLeakAwareCompositeByteBuffer 5
:6 7.
"SimpleLeakAwareCompositeByteBuffer8 Z
{ 
internal 0
$AdvancedLeakAwareCompositeByteBuffer 5
(5 6
CompositeByteBuffer6 I
wrappedJ Q
,Q R 
IResourceLeakTrackerS g
leakh l
)l m
: 
base 
( 
wrapped 
, 
leak  
)  !
{ 	
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
{ 	-
!RecordLeakNonRefCountingOperation -
(- .
this. 2
.2 3
Leak3 7
)7 8
;8 9
return 
base 
. 
Slice 
( 
) 
;  
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
int* -
index. 3
,3 4
int5 8
length9 ?
)? @
{ 	-
!RecordLeakNonRefCountingOperation   -
(  - .
this  . 2
.  2 3
Leak  3 7
)  7 8
;  8 9
return!! 
base!! 
.!! 
Slice!! 
(!! 
index!! #
,!!# $
length!!% +
)!!+ ,
;!!, -
}"" 	
public$$ 
override$$ 
IByteBuffer$$ #
	Duplicate$$$ -
($$- .
)$$. /
{%% 	-
!RecordLeakNonRefCountingOperation&& -
(&&- .
this&&. 2
.&&2 3
Leak&&3 7
)&&7 8
;&&8 9
return'' 
base'' 
.'' 
	Duplicate'' !
(''! "
)''" #
;''# $
}(( 	
public** 
override** 
IByteBuffer** #
	ReadSlice**$ -
(**- .
int**. 1
length**2 8
)**8 9
{++ 	-
!RecordLeakNonRefCountingOperation,, -
(,,- .
this,,. 2
.,,2 3
Leak,,3 7
),,7 8
;,,8 9
return-- 
base-- 
.-- 
	ReadSlice-- !
(--! "
length--" (
)--( )
;--) *
}.. 	
public00 
override00 
IByteBuffer00 #
DiscardReadBytes00$ 4
(004 5
)005 6
{11 	-
!RecordLeakNonRefCountingOperation22 -
(22- .
this22. 2
.222 3
Leak223 7
)227 8
;228 9
return33 
base33 
.33 
DiscardReadBytes33 (
(33( )
)33) *
;33* +
}44 	
public66 
override66 
IByteBuffer66 # 
DiscardSomeReadBytes66$ 8
(668 9
)669 :
{77 	-
!RecordLeakNonRefCountingOperation88 -
(88- .
this88. 2
.882 3
Leak883 7
)887 8
;888 9
return99 
base99 
.99  
DiscardSomeReadBytes99 ,
(99, -
)99- .
;99. /
}:: 	
public<< 
override<< 
IByteBuffer<< #
EnsureWritable<<$ 2
(<<2 3
int<<3 6
minWritableBytes<<7 G
)<<G H
{== 	-
!RecordLeakNonRefCountingOperation>> -
(>>- .
this>>. 2
.>>2 3
Leak>>3 7
)>>7 8
;>>8 9
return?? 
base?? 
.?? 
EnsureWritable?? &
(??& '
minWritableBytes??' 7
)??7 8
;??8 9
}@@ 	
publicBB 
overrideBB 
intBB 
EnsureWritableBB *
(BB* +
intBB+ .
minWritableBytesBB/ ?
,BB? @
boolBBA E
forceBBF K
)BBK L
{CC 	-
!RecordLeakNonRefCountingOperationDD -
(DD- .
thisDD. 2
.DD2 3
LeakDD3 7
)DD7 8
;DD8 9
returnEE 
baseEE 
.EE 
EnsureWritableEE &
(EE& '
minWritableBytesEE' 7
,EE7 8
forceEE9 >
)EE> ?
;EE? @
}FF 	
publicHH 
overrideHH 
byteHH 
GetByteHH $
(HH$ %
intHH% (
indexHH) .
)HH. /
{II 	-
!RecordLeakNonRefCountingOperationJJ -
(JJ- .
thisJJ. 2
.JJ2 3
LeakJJ3 7
)JJ7 8
;JJ8 9
returnKK 
baseKK 
.KK 
GetByteKK 
(KK  
indexKK  %
)KK% &
;KK& '
}LL 	
publicNN 
overrideNN 
intNN 
GetUnsignedMediumNN -
(NN- .
intNN. 1
indexNN2 7
)NN7 8
{OO 	-
!RecordLeakNonRefCountingOperationPP -
(PP- .
thisPP. 2
.PP2 3
LeakPP3 7
)PP7 8
;PP8 9
returnQQ 
baseQQ 
.QQ 
GetUnsignedMediumQQ )
(QQ) *
indexQQ* /
)QQ/ 0
;QQ0 1
}RR 	
publicTT 
overrideTT 
shortTT 
GetShortTT &
(TT& '
intTT' *
indexTT+ 0
)TT0 1
{UU 	-
!RecordLeakNonRefCountingOperationVV -
(VV- .
thisVV. 2
.VV2 3
LeakVV3 7
)VV7 8
;VV8 9
returnWW 
baseWW 
.WW 
GetShortWW  
(WW  !
indexWW! &
)WW& '
;WW' (
}XX 	
publicZZ 
overrideZZ 
intZZ 
GetIntZZ "
(ZZ" #
intZZ# &
indexZZ' ,
)ZZ, -
{[[ 	-
!RecordLeakNonRefCountingOperation\\ -
(\\- .
this\\. 2
.\\2 3
Leak\\3 7
)\\7 8
;\\8 9
return]] 
base]] 
.]] 
GetInt]] 
(]] 
index]] $
)]]$ %
;]]% &
}^^ 	
public`` 
override`` 
long`` 
GetLong`` $
(``$ %
int``% (
index``) .
)``. /
{aa 	-
!RecordLeakNonRefCountingOperationbb -
(bb- .
thisbb. 2
.bb2 3
Leakbb3 7
)bb7 8
;bb8 9
returncc 
basecc 
.cc 
GetLongcc 
(cc  
indexcc  %
)cc% &
;cc& '
}dd 	
publicff 
overrideff 
charff 
GetCharff $
(ff$ %
intff% (
indexff) .
)ff. /
{gg 	-
!RecordLeakNonRefCountingOperationhh -
(hh- .
thishh. 2
.hh2 3
Leakhh3 7
)hh7 8
;hh8 9
returnii 
baseii 
.ii 
GetCharii 
(ii  
indexii  %
)ii% &
;ii& '
}jj 	
publicll 
overridell 
IByteBufferll #
GetBytesll$ ,
(ll, -
intll- 0
indexll1 6
,ll6 7
IByteBufferll8 C
dstllD G
)llG H
{mm 	-
!RecordLeakNonRefCountingOperationnn -
(nn- .
thisnn. 2
.nn2 3
Leaknn3 7
)nn7 8
;nn8 9
returnoo 
baseoo 
.oo 
GetBytesoo  
(oo  !
indexoo! &
,oo& '
dstoo( +
)oo+ ,
;oo, -
}pp 	
publicrr 
overriderr 
IByteBufferrr #
GetBytesrr$ ,
(rr, -
intrr- 0
indexrr1 6
,rr6 7
IByteBufferrr8 C
dstrrD G
,rrG H
intrrI L
lengthrrM S
)rrS T
{ss 	-
!RecordLeakNonRefCountingOperationtt -
(tt- .
thistt. 2
.tt2 3
Leaktt3 7
)tt7 8
;tt8 9
returnuu 
baseuu 
.uu 
GetBytesuu  
(uu  !
indexuu! &
,uu& '
dstuu( +
,uu+ ,
lengthuu- 3
)uu3 4
;uu4 5
}vv 	
publicxx 
overridexx 
IByteBufferxx #
GetBytesxx$ ,
(xx, -
intxx- 0
indexxx1 6
,xx6 7
IByteBufferxx8 C
dstxxD G
,xxG H
intxxI L
dstIndexxxM U
,xxU V
intxxW Z
lengthxx[ a
)xxa b
{yy 	-
!RecordLeakNonRefCountingOperationzz -
(zz- .
thiszz. 2
.zz2 3
Leakzz3 7
)zz7 8
;zz8 9
return{{ 
base{{ 
.{{ 
GetBytes{{  
({{  !
index{{! &
,{{& '
dst{{( +
,{{+ ,
dstIndex{{- 5
,{{5 6
length{{7 =
){{= >
;{{> ?
}|| 	
public~~ 
override~~ 
IByteBuffer~~ #
GetBytes~~$ ,
(~~, -
int~~- 0
index~~1 6
,~~6 7
byte~~8 <
[~~< =
]~~= >
dst~~? B
)~~B C
{ 	/
!RecordLeakNonRefCountingOperation
€€ -
(
€€- .
this
€€. 2
.
€€2 3
Leak
€€3 7
)
€€7 8
;
€€8 9
return
 
base
 
.
 
GetBytes
  
(
  !
index
! &
,
& '
dst
( +
)
+ ,
;
, -
}
‚‚ 	
public
„„ 
override
„„ 
IByteBuffer
„„ #
GetBytes
„„$ ,
(
„„, -
int
„„- 0
index
„„1 6
,
„„6 7
byte
„„8 <
[
„„< =
]
„„= >
dst
„„? B
,
„„B C
int
„„D G
dstIndex
„„H P
,
„„P Q
int
„„R U
length
„„V \
)
„„\ ]
{
…… 	/
!RecordLeakNonRefCountingOperation
†† -
(
††- .
this
††. 2
.
††2 3
Leak
††3 7
)
††7 8
;
††8 9
return
‡‡ 
base
‡‡ 
.
‡‡ 
GetBytes
‡‡  
(
‡‡  !
index
‡‡! &
,
‡‡& '
dst
‡‡( +
,
‡‡+ ,
dstIndex
‡‡- 5
,
‡‡5 6
length
‡‡7 =
)
‡‡= >
;
‡‡> ?
}
ˆˆ 	
public
ŠŠ 
override
ŠŠ 
IByteBuffer
ŠŠ #

SetBoolean
ŠŠ$ .
(
ŠŠ. /
int
ŠŠ/ 2
index
ŠŠ3 8
,
ŠŠ8 9
bool
ŠŠ: >
value
ŠŠ? D
)
ŠŠD E
{
‹‹ 	/
!RecordLeakNonRefCountingOperation
ŒŒ -
(
ŒŒ- .
this
ŒŒ. 2
.
ŒŒ2 3
Leak
ŒŒ3 7
)
ŒŒ7 8
;
ŒŒ8 9
return
 
base
 
.
 

SetBoolean
 "
(
" #
index
# (
,
( )
value
* /
)
/ 0
;
0 1
}
 	
public
 
override
 
IByteBuffer
 #
SetByte
$ +
(
+ ,
int
, /
index
0 5
,
5 6
int
7 :
value
; @
)
@ A
{
‘‘ 	/
!RecordLeakNonRefCountingOperation
’’ -
(
’’- .
this
’’. 2
.
’’2 3
Leak
’’3 7
)
’’7 8
;
’’8 9
return
““ 
base
““ 
.
““ 
SetByte
““ 
(
““  
index
““  %
,
““% &
value
““' ,
)
““, -
;
““- .
}
”” 	
public
–– 
override
–– 
IByteBuffer
–– #
	SetMedium
––$ -
(
––- .
int
––. 1
index
––2 7
,
––7 8
int
––9 <
value
––= B
)
––B C
{
—— 	/
!RecordLeakNonRefCountingOperation
˜˜ -
(
˜˜- .
this
˜˜. 2
.
˜˜2 3
Leak
˜˜3 7
)
˜˜7 8
;
˜˜8 9
return
™™ 
base
™™ 
.
™™ 
	SetMedium
™™ !
(
™™! "
index
™™" '
,
™™' (
value
™™) .
)
™™. /
;
™™/ 0
}
šš 	
public
œœ 
override
œœ 
IByteBuffer
œœ #
SetShort
œœ$ ,
(
œœ, -
int
œœ- 0
index
œœ1 6
,
œœ6 7
int
œœ8 ;
value
œœ< A
)
œœA B
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
ŸŸ 
base
ŸŸ 
.
ŸŸ 
SetShort
ŸŸ  
(
ŸŸ  !
index
ŸŸ! &
,
ŸŸ& '
value
ŸŸ( -
)
ŸŸ- .
;
ŸŸ. /
}
   	
public
¢¢ 
override
¢¢ 
IByteBuffer
¢¢ #
SetInt
¢¢$ *
(
¢¢* +
int
¢¢+ .
index
¢¢/ 4
,
¢¢4 5
int
¢¢6 9
value
¢¢: ?
)
¢¢? @
{
££ 	/
!RecordLeakNonRefCountingOperation
¤¤ -
(
¤¤- .
this
¤¤. 2
.
¤¤2 3
Leak
¤¤3 7
)
¤¤7 8
;
¤¤8 9
return
¥¥ 
base
¥¥ 
.
¥¥ 
SetInt
¥¥ 
(
¥¥ 
index
¥¥ $
,
¥¥$ %
value
¥¥& +
)
¥¥+ ,
;
¥¥, -
}
¦¦ 	
public
¨¨ 
override
¨¨ 
IByteBuffer
¨¨ #
SetLong
¨¨$ +
(
¨¨+ ,
int
¨¨, /
index
¨¨0 5
,
¨¨5 6
long
¨¨7 ;
value
¨¨< A
)
¨¨A B
{
©© 	/
!RecordLeakNonRefCountingOperation
ªª -
(
ªª- .
this
ªª. 2
.
ªª2 3
Leak
ªª3 7
)
ªª7 8
;
ªª8 9
return
«« 
base
«« 
.
«« 
SetLong
«« 
(
««  
index
««  %
,
««% &
value
««' ,
)
««, -
;
««- .
}
¬¬ 	
public
®® 
override
®® 
IByteBuffer
®® #
SetChar
®®$ +
(
®®+ ,
int
®®, /
index
®®0 5
,
®®5 6
char
®®7 ;
value
®®< A
)
®®A B
{
¯¯ 	/
!RecordLeakNonRefCountingOperation
°° -
(
°°- .
this
°°. 2
.
°°2 3
Leak
°°3 7
)
°°7 8
;
°°8 9
return
±± 
base
±± 
.
±± 
SetChar
±± 
(
±±  
index
±±  %
,
±±% &
value
±±' ,
)
±±, -
;
±±- .
}
²² 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
SetFloat
´´$ ,
(
´´, -
int
´´- 0
index
´´1 6
,
´´6 7
float
´´8 =
value
´´> C
)
´´C D
{
µµ 	/
!RecordLeakNonRefCountingOperation
¶¶ -
(
¶¶- .
this
¶¶. 2
.
¶¶2 3
Leak
¶¶3 7
)
¶¶7 8
;
¶¶8 9
return
·· 
base
·· 
.
·· 
SetFloat
··  
(
··  !
index
··! &
,
··& '
value
··( -
)
··- .
;
··. /
}
¸¸ 	
public
ºº 
override
ºº 
IByteBuffer
ºº #
	SetDouble
ºº$ -
(
ºº- .
int
ºº. 1
index
ºº2 7
,
ºº7 8
double
ºº9 ?
value
ºº@ E
)
ººE F
{
»» 	/
!RecordLeakNonRefCountingOperation
¼¼ -
(
¼¼- .
this
¼¼. 2
.
¼¼2 3
Leak
¼¼3 7
)
¼¼7 8
;
¼¼8 9
return
½½ 
base
½½ 
.
½½ 
	SetDouble
½½ !
(
½½! "
index
½½" '
,
½½' (
value
½½) .
)
½½. /
;
½½/ 0
}
¾¾ 	
public
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ #
SetBytes
ÀÀ$ ,
(
ÀÀ, -
int
ÀÀ- 0
index
ÀÀ1 6
,
ÀÀ6 7
IByteBuffer
ÀÀ8 C
src
ÀÀD G
)
ÀÀG H
{
ÁÁ 	/
!RecordLeakNonRefCountingOperation
ÂÂ -
(
ÂÂ- .
this
ÂÂ. 2
.
ÂÂ2 3
Leak
ÂÂ3 7
)
ÂÂ7 8
;
ÂÂ8 9
return
ÃÃ 
base
ÃÃ 
.
ÃÃ 
SetBytes
ÃÃ  
(
ÃÃ  !
index
ÃÃ! &
,
ÃÃ& '
src
ÃÃ( +
)
ÃÃ+ ,
;
ÃÃ, -
}
ÄÄ 	
public
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ #
SetBytes
ÆÆ$ ,
(
ÆÆ, -
int
ÆÆ- 0
index
ÆÆ1 6
,
ÆÆ6 7
IByteBuffer
ÆÆ8 C
src
ÆÆD G
,
ÆÆG H
int
ÆÆI L
length
ÆÆM S
)
ÆÆS T
{
ÇÇ 	/
!RecordLeakNonRefCountingOperation
ÈÈ -
(
ÈÈ- .
this
ÈÈ. 2
.
ÈÈ2 3
Leak
ÈÈ3 7
)
ÈÈ7 8
;
ÈÈ8 9
return
ÉÉ 
base
ÉÉ 
.
ÉÉ 
SetBytes
ÉÉ  
(
ÉÉ  !
index
ÉÉ! &
,
ÉÉ& '
src
ÉÉ( +
,
ÉÉ+ ,
length
ÉÉ- 3
)
ÉÉ3 4
;
ÉÉ4 5
}
ÊÊ 	
public
ÌÌ 
override
ÌÌ 
IByteBuffer
ÌÌ #
SetBytes
ÌÌ$ ,
(
ÌÌ, -
int
ÌÌ- 0
index
ÌÌ1 6
,
ÌÌ6 7
IByteBuffer
ÌÌ8 C
src
ÌÌD G
,
ÌÌG H
int
ÌÌI L
srcIndex
ÌÌM U
,
ÌÌU V
int
ÌÌW Z
length
ÌÌ[ a
)
ÌÌa b
{
ÍÍ 	/
!RecordLeakNonRefCountingOperation
ÎÎ -
(
ÎÎ- .
this
ÎÎ. 2
.
ÎÎ2 3
Leak
ÎÎ3 7
)
ÎÎ7 8
;
ÎÎ8 9
return
ÏÏ 
base
ÏÏ 
.
ÏÏ 
SetBytes
ÏÏ  
(
ÏÏ  !
index
ÏÏ! &
,
ÏÏ& '
src
ÏÏ( +
,
ÏÏ+ ,
srcIndex
ÏÏ- 5
,
ÏÏ5 6
length
ÏÏ7 =
)
ÏÏ= >
;
ÏÏ> ?
}
ĞĞ 	
public
ÒÒ 
override
ÒÒ 
IByteBuffer
ÒÒ #
SetBytes
ÒÒ$ ,
(
ÒÒ, -
int
ÒÒ- 0
index
ÒÒ1 6
,
ÒÒ6 7
byte
ÒÒ8 <
[
ÒÒ< =
]
ÒÒ= >
src
ÒÒ? B
)
ÒÒB C
{
ÓÓ 	/
!RecordLeakNonRefCountingOperation
ÔÔ -
(
ÔÔ- .
this
ÔÔ. 2
.
ÔÔ2 3
Leak
ÔÔ3 7
)
ÔÔ7 8
;
ÔÔ8 9
return
ÕÕ 
base
ÕÕ 
.
ÕÕ 
SetBytes
ÕÕ  
(
ÕÕ  !
index
ÕÕ! &
,
ÕÕ& '
src
ÕÕ( +
)
ÕÕ+ ,
;
ÕÕ, -
}
ÖÖ 	
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
SetBytes
ØØ$ ,
(
ØØ, -
int
ØØ- 0
index
ØØ1 6
,
ØØ6 7
byte
ØØ8 <
[
ØØ< =
]
ØØ= >
src
ØØ? B
,
ØØB C
int
ØØD G
srcIndex
ØØH P
,
ØØP Q
int
ØØR U
length
ØØV \
)
ØØ\ ]
{
ÙÙ 	/
!RecordLeakNonRefCountingOperation
ÚÚ -
(
ÚÚ- .
this
ÚÚ. 2
.
ÚÚ2 3
Leak
ÚÚ3 7
)
ÚÚ7 8
;
ÚÚ8 9
return
ÛÛ 
base
ÛÛ 
.
ÛÛ 
SetBytes
ÛÛ  
(
ÛÛ  !
index
ÛÛ! &
,
ÛÛ& '
src
ÛÛ( +
,
ÛÛ+ ,
srcIndex
ÛÛ- 5
,
ÛÛ5 6
length
ÛÛ7 =
)
ÛÛ= >
;
ÛÛ> ?
}
ÜÜ 	
public
ŞŞ 
override
ŞŞ 
Task
ŞŞ 
<
ŞŞ 
int
ŞŞ  
>
ŞŞ  !
SetBytesAsync
ŞŞ" /
(
ŞŞ/ 0
int
ŞŞ0 3
index
ŞŞ4 9
,
ŞŞ9 :
Stream
ŞŞ; A
input
ŞŞB G
,
ŞŞG H
int
ŞŞI L
length
ŞŞM S
,
ŞŞS T
CancellationToken
ŞŞU f
cancellationToken
ŞŞg x
)
ŞŞx y
{
ßß 	/
!RecordLeakNonRefCountingOperation
àà -
(
àà- .
this
àà. 2
.
àà2 3
Leak
àà3 7
)
àà7 8
;
àà8 9
return
áá 
base
áá 
.
áá 
SetBytesAsync
áá %
(
áá% &
index
áá& +
,
áá+ ,
input
áá- 2
,
áá2 3
length
áá4 :
,
áá: ;
cancellationToken
áá< M
)
ááM N
;
ááN O
}
ââ 	
public
ää 
override
ää 
IByteBuffer
ää #
SetZero
ää$ +
(
ää+ ,
int
ää, /
index
ää0 5
,
ää5 6
int
ää7 :
length
ää; A
)
ääA B
{
åå 	/
!RecordLeakNonRefCountingOperation
ææ -
(
ææ- .
this
ææ. 2
.
ææ2 3
Leak
ææ3 7
)
ææ7 8
;
ææ8 9
return
çç 
base
çç 
.
çç 
SetZero
çç 
(
çç  
index
çç  %
,
çç% &
length
çç' -
)
çç- .
;
çç. /
}
èè 	
public
êê 
override
êê 
byte
êê 
ReadByte
êê %
(
êê% &
)
êê& '
{
ëë 	/
!RecordLeakNonRefCountingOperation
ìì -
(
ìì- .
this
ìì. 2
.
ìì2 3
Leak
ìì3 7
)
ìì7 8
;
ìì8 9
return
íí 
base
íí 
.
íí 
ReadByte
íí  
(
íí  !
)
íí! "
;
íí" #
}
îî 	
public
ğğ 
override
ğğ 
short
ğğ 
	ReadShort
ğğ '
(
ğğ' (
)
ğğ( )
{
ññ 	/
!RecordLeakNonRefCountingOperation
òò -
(
òò- .
this
òò. 2
.
òò2 3
Leak
òò3 7
)
òò7 8
;
òò8 9
return
óó 
base
óó 
.
óó 
	ReadShort
óó !
(
óó! "
)
óó" #
;
óó# $
}
ôô 	
public
öö 
override
öö 
int
öö  
ReadUnsignedMedium
öö .
(
öö. /
)
öö/ 0
{
÷÷ 	/
!RecordLeakNonRefCountingOperation
øø -
(
øø- .
this
øø. 2
.
øø2 3
Leak
øø3 7
)
øø7 8
;
øø8 9
return
ùù 
base
ùù 
.
ùù  
ReadUnsignedMedium
ùù *
(
ùù* +
)
ùù+ ,
;
ùù, -
}
úú 	
public
üü 
override
üü 
int
üü 
ReadInt
üü #
(
üü# $
)
üü$ %
{
ıı 	/
!RecordLeakNonRefCountingOperation
şş -
(
şş- .
this
şş. 2
.
şş2 3
Leak
şş3 7
)
şş7 8
;
şş8 9
return
ÿÿ 
base
ÿÿ 
.
ÿÿ 
ReadInt
ÿÿ 
(
ÿÿ  
)
ÿÿ  !
;
ÿÿ! "
}
€€ 	
public
‚‚ 
override
‚‚ 
long
‚‚ 
ReadLong
‚‚ %
(
‚‚% &
)
‚‚& '
{
ƒƒ 	/
!RecordLeakNonRefCountingOperation
„„ -
(
„„- .
this
„„. 2
.
„„2 3
Leak
„„3 7
)
„„7 8
;
„„8 9
return
…… 
base
…… 
.
…… 
ReadLong
……  
(
……  !
)
……! "
;
……" #
}
†† 	
public
ˆˆ 
override
ˆˆ 
IByteBuffer
ˆˆ #
	ReadBytes
ˆˆ$ -
(
ˆˆ- .
int
ˆˆ. 1
length
ˆˆ2 8
)
ˆˆ8 9
{
‰‰ 	/
!RecordLeakNonRefCountingOperation
ŠŠ -
(
ŠŠ- .
this
ŠŠ. 2
.
ŠŠ2 3
Leak
ŠŠ3 7
)
ŠŠ7 8
;
ŠŠ8 9
return
‹‹ 
base
‹‹ 
.
‹‹ 
	ReadBytes
‹‹ !
(
‹‹! "
length
‹‹" (
)
‹‹( )
;
‹‹) *
}
ŒŒ 	
public
 
override
 
IByteBuffer
 #
	ReadBytes
$ -
(
- .
IByteBuffer
. 9
dst
: =
)
= >
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
‘‘ 
base
‘‘ 
.
‘‘ 
	ReadBytes
‘‘ !
(
‘‘! "
dst
‘‘" %
)
‘‘% &
;
‘‘& '
}
’’ 	
public
”” 
override
”” 
IByteBuffer
”” #
	ReadBytes
””$ -
(
””- .
IByteBuffer
””. 9
dst
””: =
,
””= >
int
””? B
length
””C I
)
””I J
{
•• 	/
!RecordLeakNonRefCountingOperation
–– -
(
––- .
this
––. 2
.
––2 3
Leak
––3 7
)
––7 8
;
––8 9
return
—— 
base
—— 
.
—— 
	ReadBytes
—— !
(
——! "
dst
——" %
,
——% &
length
——' -
)
——- .
;
——. /
}
˜˜ 	
public
šš 
override
šš 
IByteBuffer
šš #
	ReadBytes
šš$ -
(
šš- .
IByteBuffer
šš. 9
dst
šš: =
,
šš= >
int
šš? B
dstIndex
ššC K
,
ššK L
int
ššM P
length
ššQ W
)
ššW X
{
›› 	/
!RecordLeakNonRefCountingOperation
œœ -
(
œœ- .
this
œœ. 2
.
œœ2 3
Leak
œœ3 7
)
œœ7 8
;
œœ8 9
return
 
base
 
.
 
	ReadBytes
 !
(
! "
dst
" %
,
% &
dstIndex
' /
,
/ 0
length
1 7
)
7 8
;
8 9
}
 	
public
   
override
   
IByteBuffer
   #
	ReadBytes
  $ -
(
  - .
byte
  . 2
[
  2 3
]
  3 4
dst
  5 8
)
  8 9
{
¡¡ 	/
!RecordLeakNonRefCountingOperation
¢¢ -
(
¢¢- .
this
¢¢. 2
.
¢¢2 3
Leak
¢¢3 7
)
¢¢7 8
;
¢¢8 9
return
££ 
base
££ 
.
££ 
	ReadBytes
££ !
(
££! "
dst
££" %
)
££% &
;
££& '
}
¤¤ 	
public
¦¦ 
override
¦¦ 
IByteBuffer
¦¦ #
	ReadBytes
¦¦$ -
(
¦¦- .
byte
¦¦. 2
[
¦¦2 3
]
¦¦3 4
dst
¦¦5 8
,
¦¦8 9
int
¦¦: =
dstIndex
¦¦> F
,
¦¦F G
int
¦¦H K
length
¦¦L R
)
¦¦R S
{
§§ 	/
!RecordLeakNonRefCountingOperation
¨¨ -
(
¨¨- .
this
¨¨. 2
.
¨¨2 3
Leak
¨¨3 7
)
¨¨7 8
;
¨¨8 9
return
©© 
base
©© 
.
©© 
	ReadBytes
©© !
(
©©! "
dst
©©" %
,
©©% &
dstIndex
©©' /
,
©©/ 0
length
©©1 7
)
©©7 8
;
©©8 9
}
ªª 	
public
¬¬ 
override
¬¬ 
IByteBuffer
¬¬ #
	ReadBytes
¬¬$ -
(
¬¬- .
Stream
¬¬. 4
output
¬¬5 ;
,
¬¬; <
int
¬¬= @
length
¬¬A G
)
¬¬G H
{
­­ 	/
!RecordLeakNonRefCountingOperation
®® -
(
®®- .
this
®®. 2
.
®®2 3
Leak
®®3 7
)
®®7 8
;
®®8 9
return
¯¯ 
base
¯¯ 
.
¯¯ 
	ReadBytes
¯¯ !
(
¯¯! "
output
¯¯" (
,
¯¯( )
length
¯¯* 0
)
¯¯0 1
;
¯¯1 2
}
°° 	
public
²² 
override
²² 
IByteBuffer
²² #
	SkipBytes
²²$ -
(
²²- .
int
²². 1
length
²²2 8
)
²²8 9
{
³³ 	/
!RecordLeakNonRefCountingOperation
´´ -
(
´´- .
this
´´. 2
.
´´2 3
Leak
´´3 7
)
´´7 8
;
´´8 9
return
µµ 
base
µµ 
.
µµ 
	SkipBytes
µµ !
(
µµ! "
length
µµ" (
)
µµ( )
;
µµ) *
}
¶¶ 	
public
¸¸ 
override
¸¸ 
IByteBuffer
¸¸ #
WriteBoolean
¸¸$ 0
(
¸¸0 1
bool
¸¸1 5
value
¸¸6 ;
)
¸¸; <
{
¹¹ 	/
!RecordLeakNonRefCountingOperation
ºº -
(
ºº- .
this
ºº. 2
.
ºº2 3
Leak
ºº3 7
)
ºº7 8
;
ºº8 9
return
»» 
base
»» 
.
»» 
WriteBoolean
»» $
(
»»$ %
value
»»% *
)
»»* +
;
»»+ ,
}
¼¼ 	
public
¾¾ 
override
¾¾ 
IByteBuffer
¾¾ #
	WriteByte
¾¾$ -
(
¾¾- .
int
¾¾. 1
value
¾¾2 7
)
¾¾7 8
{
¿¿ 	/
!RecordLeakNonRefCountingOperation
ÀÀ -
(
ÀÀ- .
this
ÀÀ. 2
.
ÀÀ2 3
Leak
ÀÀ3 7
)
ÀÀ7 8
;
ÀÀ8 9
return
ÁÁ 
base
ÁÁ 
.
ÁÁ 
	WriteByte
ÁÁ !
(
ÁÁ! "
value
ÁÁ" '
)
ÁÁ' (
;
ÁÁ( )
}
ÂÂ 	
public
ÄÄ 
override
ÄÄ 
IByteBuffer
ÄÄ #

WriteShort
ÄÄ$ .
(
ÄÄ. /
int
ÄÄ/ 2
value
ÄÄ3 8
)
ÄÄ8 9
{
ÅÅ 	/
!RecordLeakNonRefCountingOperation
ÆÆ -
(
ÆÆ- .
this
ÆÆ. 2
.
ÆÆ2 3
Leak
ÆÆ3 7
)
ÆÆ7 8
;
ÆÆ8 9
return
ÇÇ 
base
ÇÇ 
.
ÇÇ 

WriteShort
ÇÇ "
(
ÇÇ" #
value
ÇÇ# (
)
ÇÇ( )
;
ÇÇ) *
}
ÈÈ 	
public
ÊÊ 
override
ÊÊ 
IByteBuffer
ÊÊ #
WriteInt
ÊÊ$ ,
(
ÊÊ, -
int
ÊÊ- 0
value
ÊÊ1 6
)
ÊÊ6 7
{
ËË 	/
!RecordLeakNonRefCountingOperation
ÌÌ -
(
ÌÌ- .
this
ÌÌ. 2
.
ÌÌ2 3
Leak
ÌÌ3 7
)
ÌÌ7 8
;
ÌÌ8 9
return
ÍÍ 
base
ÍÍ 
.
ÍÍ 
WriteInt
ÍÍ  
(
ÍÍ  !
value
ÍÍ! &
)
ÍÍ& '
;
ÍÍ' (
}
ÎÎ 	
public
ĞĞ 
override
ĞĞ 
IByteBuffer
ĞĞ #
WriteMedium
ĞĞ$ /
(
ĞĞ/ 0
int
ĞĞ0 3
value
ĞĞ4 9
)
ĞĞ9 :
{
ÑÑ 	/
!RecordLeakNonRefCountingOperation
ÒÒ -
(
ÒÒ- .
this
ÒÒ. 2
.
ÒÒ2 3
Leak
ÒÒ3 7
)
ÒÒ7 8
;
ÒÒ8 9
return
ÓÓ 
base
ÓÓ 
.
ÓÓ 
WriteMedium
ÓÓ #
(
ÓÓ# $
value
ÓÓ$ )
)
ÓÓ) *
;
ÓÓ* +
}
ÔÔ 	
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ #
	WriteLong
ÖÖ$ -
(
ÖÖ- .
long
ÖÖ. 2
value
ÖÖ3 8
)
ÖÖ8 9
{
×× 	/
!RecordLeakNonRefCountingOperation
ØØ -
(
ØØ- .
this
ØØ. 2
.
ØØ2 3
Leak
ØØ3 7
)
ØØ7 8
;
ØØ8 9
return
ÙÙ 
base
ÙÙ 
.
ÙÙ 
	WriteLong
ÙÙ !
(
ÙÙ! "
value
ÙÙ" '
)
ÙÙ' (
;
ÙÙ( )
}
ÚÚ 	
public
ÜÜ 
override
ÜÜ 
IByteBuffer
ÜÜ #
	WriteChar
ÜÜ$ -
(
ÜÜ- .
char
ÜÜ. 2
value
ÜÜ3 8
)
ÜÜ8 9
{
İİ 	/
!RecordLeakNonRefCountingOperation
ŞŞ -
(
ŞŞ- .
this
ŞŞ. 2
.
ŞŞ2 3
Leak
ŞŞ3 7
)
ŞŞ7 8
;
ŞŞ8 9
return
ßß 
base
ßß 
.
ßß 
	WriteChar
ßß !
(
ßß! "
value
ßß" '
)
ßß' (
;
ßß( )
}
àà 	
public
ââ 
override
ââ 
IByteBuffer
ââ #

WriteFloat
ââ$ .
(
ââ. /
float
ââ/ 4
value
ââ5 :
)
ââ: ;
{
ãã 	/
!RecordLeakNonRefCountingOperation
ää -
(
ää- .
this
ää. 2
.
ää2 3
Leak
ää3 7
)
ää7 8
;
ää8 9
return
åå 
base
åå 
.
åå 

WriteFloat
åå "
(
åå" #
value
åå# (
)
åå( )
;
åå) *
}
ææ 	
public
èè 
override
èè 
IByteBuffer
èè #
WriteDouble
èè$ /
(
èè/ 0
double
èè0 6
value
èè7 <
)
èè< =
{
éé 	/
!RecordLeakNonRefCountingOperation
êê -
(
êê- .
this
êê. 2
.
êê2 3
Leak
êê3 7
)
êê7 8
;
êê8 9
return
ëë 
base
ëë 
.
ëë 
WriteDouble
ëë #
(
ëë# $
value
ëë$ )
)
ëë) *
;
ëë* +
}
ìì 	
public
îî 
override
îî 
IByteBuffer
îî #

WriteBytes
îî$ .
(
îî. /
IByteBuffer
îî/ :
src
îî; >
)
îî> ?
{
ïï 	/
!RecordLeakNonRefCountingOperation
ğğ -
(
ğğ- .
this
ğğ. 2
.
ğğ2 3
Leak
ğğ3 7
)
ğğ7 8
;
ğğ8 9
return
ññ 
base
ññ 
.
ññ 

WriteBytes
ññ "
(
ññ" #
src
ññ# &
)
ññ& '
;
ññ' (
}
òò 	
public
ôô 
override
ôô 
IByteBuffer
ôô #

WriteBytes
ôô$ .
(
ôô. /
IByteBuffer
ôô/ :
src
ôô; >
,
ôô> ?
int
ôô@ C
length
ôôD J
)
ôôJ K
{
õõ 	/
!RecordLeakNonRefCountingOperation
öö -
(
öö- .
this
öö. 2
.
öö2 3
Leak
öö3 7
)
öö7 8
;
öö8 9
return
÷÷ 
base
÷÷ 
.
÷÷ 

WriteBytes
÷÷ "
(
÷÷" #
src
÷÷# &
,
÷÷& '
length
÷÷( .
)
÷÷. /
;
÷÷/ 0
}
øø 	
public
úú 
override
úú 
IByteBuffer
úú #

WriteBytes
úú$ .
(
úú. /
IByteBuffer
úú/ :
src
úú; >
,
úú> ?
int
úú@ C
srcIndex
úúD L
,
úúL M
int
úúN Q
length
úúR X
)
úúX Y
{
ûû 	/
!RecordLeakNonRefCountingOperation
üü -
(
üü- .
this
üü. 2
.
üü2 3
Leak
üü3 7
)
üü7 8
;
üü8 9
return
ıı 
base
ıı 
.
ıı 

WriteBytes
ıı "
(
ıı" #
src
ıı# &
,
ıı& '
srcIndex
ıı( 0
,
ıı0 1
length
ıı2 8
)
ıı8 9
;
ıı9 :
}
şş 	
public
€€ 
override
€€ 
IByteBuffer
€€ #

WriteBytes
€€$ .
(
€€. /
byte
€€/ 3
[
€€3 4
]
€€4 5
src
€€6 9
)
€€9 :
{
 	/
!RecordLeakNonRefCountingOperation
‚‚ -
(
‚‚- .
this
‚‚. 2
.
‚‚2 3
Leak
‚‚3 7
)
‚‚7 8
;
‚‚8 9
return
ƒƒ 
base
ƒƒ 
.
ƒƒ 

WriteBytes
ƒƒ "
(
ƒƒ" #
src
ƒƒ# &
)
ƒƒ& '
;
ƒƒ' (
}
„„ 	
public
†† 
override
†† 
IByteBuffer
†† #

WriteBytes
††$ .
(
††. /
byte
††/ 3
[
††3 4
]
††4 5
src
††6 9
,
††9 :
int
††; >
srcIndex
††? G
,
††G H
int
††I L
length
††M S
)
††S T
{
‡‡ 	/
!RecordLeakNonRefCountingOperation
ˆˆ -
(
ˆˆ- .
this
ˆˆ. 2
.
ˆˆ2 3
Leak
ˆˆ3 7
)
ˆˆ7 8
;
ˆˆ8 9
return
‰‰ 
base
‰‰ 
.
‰‰ 

WriteBytes
‰‰ "
(
‰‰" #
src
‰‰# &
,
‰‰& '
srcIndex
‰‰( 0
,
‰‰0 1
length
‰‰2 8
)
‰‰8 9
;
‰‰9 :
}
ŠŠ 	
public
ŒŒ 
override
ŒŒ 
Task
ŒŒ 
WriteBytesAsync
ŒŒ ,
(
ŒŒ, -
Stream
ŒŒ- 3
input
ŒŒ4 9
,
ŒŒ9 :
int
ŒŒ; >
length
ŒŒ? E
,
ŒŒE F
CancellationToken
ŒŒG X
cancellationToken
ŒŒY j
)
ŒŒj k
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
WriteBytesAsync
 '
(
' (
input
( -
,
- .
length
/ 5
,
5 6
cancellationToken
7 H
)
H I
;
I J
}
 	
public
’’ 
override
’’ 
IByteBuffer
’’ #
	WriteZero
’’$ -
(
’’- .
int
’’. 1
length
’’2 8
)
’’8 9
{
““ 	/
!RecordLeakNonRefCountingOperation
”” -
(
””- .
this
””. 2
.
””2 3
Leak
””3 7
)
””7 8
;
””8 9
return
•• 
base
•• 
.
•• 
	WriteZero
•• !
(
••! "
length
••" (
)
••( )
;
••) *
}
–– 	
public
˜˜ 
override
˜˜ 
int
˜˜ 
IndexOf
˜˜ #
(
˜˜# $
int
˜˜$ '
	fromIndex
˜˜( 1
,
˜˜1 2
int
˜˜3 6
toIndex
˜˜7 >
,
˜˜> ?
byte
˜˜@ D
value
˜˜E J
)
˜˜J K
{
™™ 	/
!RecordLeakNonRefCountingOperation
šš -
(
šš- .
this
šš. 2
.
šš2 3
Leak
šš3 7
)
šš7 8
;
šš8 9
return
›› 
base
›› 
.
›› 
IndexOf
›› 
(
››  
	fromIndex
››  )
,
››) *
toIndex
››+ 2
,
››2 3
value
››4 9
)
››9 :
;
››: ;
}
œœ 	
public
 
override
 
int
 
BytesBefore
 '
(
' (
int
( +
index
, 1
,
1 2
int
3 6
length
7 =
,
= >
byte
? C
value
D I
)
I J
{
ŸŸ 	/
!RecordLeakNonRefCountingOperation
   -
(
  - .
this
  . 2
.
  2 3
Leak
  3 7
)
  7 8
;
  8 9
return
¡¡ 
base
¡¡ 
.
¡¡ 
BytesBefore
¡¡ #
(
¡¡# $
index
¡¡$ )
,
¡¡) *
length
¡¡+ 1
,
¡¡1 2
value
¡¡3 8
)
¡¡8 9
;
¡¡9 :
}
¢¢ 	
public
¤¤ 
override
¤¤ 
int
¤¤ 
ForEachByte
¤¤ '
(
¤¤' (
IByteProcessor
¤¤( 6
	processor
¤¤7 @
)
¤¤@ A
{
¥¥ 	/
!RecordLeakNonRefCountingOperation
¦¦ -
(
¦¦- .
this
¦¦. 2
.
¦¦2 3
Leak
¦¦3 7
)
¦¦7 8
;
¦¦8 9
return
§§ 
base
§§ 
.
§§ 
ForEachByte
§§ #
(
§§# $
	processor
§§$ -
)
§§- .
;
§§. /
}
¨¨ 	
public
ªª 
override
ªª 
int
ªª 
ForEachByte
ªª '
(
ªª' (
int
ªª( +
index
ªª, 1
,
ªª1 2
int
ªª3 6
length
ªª7 =
,
ªª= >
IByteProcessor
ªª? M
	processor
ªªN W
)
ªªW X
{
«« 	/
!RecordLeakNonRefCountingOperation
¬¬ -
(
¬¬- .
this
¬¬. 2
.
¬¬2 3
Leak
¬¬3 7
)
¬¬7 8
;
¬¬8 9
return
­­ 
base
­­ 
.
­­ 
ForEachByte
­­ #
(
­­# $
index
­­$ )
,
­­) *
length
­­+ 1
,
­­1 2
	processor
­­3 <
)
­­< =
;
­­= >
}
®® 	
public
°° 
override
°° 
int
°° 
ForEachByteDesc
°° +
(
°°+ ,
IByteProcessor
°°, :
	processor
°°; D
)
°°D E
{
±± 	/
!RecordLeakNonRefCountingOperation
²² -
(
²²- .
this
²². 2
.
²²2 3
Leak
²²3 7
)
²²7 8
;
²²8 9
return
³³ 
base
³³ 
.
³³ 
ForEachByteDesc
³³ '
(
³³' (
	processor
³³( 1
)
³³1 2
;
³³2 3
}
´´ 	
public
¶¶ 
override
¶¶ 
int
¶¶ 
ForEachByteDesc
¶¶ +
(
¶¶+ ,
int
¶¶, /
index
¶¶0 5
,
¶¶5 6
int
¶¶7 :
length
¶¶; A
,
¶¶A B
IByteProcessor
¶¶C Q
	processor
¶¶R [
)
¶¶[ \
{
·· 	/
!RecordLeakNonRefCountingOperation
¸¸ -
(
¸¸- .
this
¸¸. 2
.
¸¸2 3
Leak
¸¸3 7
)
¸¸7 8
;
¸¸8 9
return
¹¹ 
base
¹¹ 
.
¹¹ 
ForEachByteDesc
¹¹ '
(
¹¹' (
index
¹¹( -
,
¹¹- .
length
¹¹/ 5
,
¹¹5 6
	processor
¹¹7 @
)
¹¹@ A
;
¹¹A B
}
ºº 	
public
¼¼ 
override
¼¼ 
IByteBuffer
¼¼ #
Copy
¼¼$ (
(
¼¼( )
)
¼¼) *
{
½½ 	/
!RecordLeakNonRefCountingOperation
¾¾ -
(
¾¾- .
this
¾¾. 2
.
¾¾2 3
Leak
¾¾3 7
)
¾¾7 8
;
¾¾8 9
return
¿¿ 
base
¿¿ 
.
¿¿ 
Copy
¿¿ 
(
¿¿ 
)
¿¿ 
;
¿¿ 
}
ÀÀ 	
public
ÂÂ 
override
ÂÂ 
IByteBuffer
ÂÂ #
Copy
ÂÂ$ (
(
ÂÂ( )
int
ÂÂ) ,
index
ÂÂ- 2
,
ÂÂ2 3
int
ÂÂ4 7
length
ÂÂ8 >
)
ÂÂ> ?
{
ÃÃ 	/
!RecordLeakNonRefCountingOperation
ÄÄ -
(
ÄÄ- .
this
ÄÄ. 2
.
ÄÄ2 3
Leak
ÄÄ3 7
)
ÄÄ7 8
;
ÄÄ8 9
return
ÅÅ 
base
ÅÅ 
.
ÅÅ 
Copy
ÅÅ 
(
ÅÅ 
index
ÅÅ "
,
ÅÅ" #
length
ÅÅ$ *
)
ÅÅ* +
;
ÅÅ+ ,
}
ÆÆ 	
public
ÈÈ 
override
ÈÈ 
int
ÈÈ 
IoBufferCount
ÈÈ )
{
ÉÉ 	
get
ÊÊ 
{
ËË /
!RecordLeakNonRefCountingOperation
ÌÌ 1
(
ÌÌ1 2
this
ÌÌ2 6
.
ÌÌ6 7
Leak
ÌÌ7 ;
)
ÌÌ; <
;
ÌÌ< =
return
ÍÍ 
base
ÍÍ 
.
ÍÍ 
IoBufferCount
ÍÍ )
;
ÍÍ) *
}
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
override
ÑÑ 
ArraySegment
ÑÑ $
<
ÑÑ$ %
byte
ÑÑ% )
>
ÑÑ) *
GetIoBuffer
ÑÑ+ 6
(
ÑÑ6 7
int
ÑÑ7 :
index
ÑÑ; @
,
ÑÑ@ A
int
ÑÑB E
length
ÑÑF L
)
ÑÑL M
{
ÒÒ 	/
!RecordLeakNonRefCountingOperation
ÓÓ -
(
ÓÓ- .
this
ÓÓ. 2
.
ÓÓ2 3
Leak
ÓÓ3 7
)
ÓÓ7 8
;
ÓÓ8 9
return
ÔÔ 
base
ÔÔ 
.
ÔÔ 
GetIoBuffer
ÔÔ #
(
ÔÔ# $
index
ÔÔ$ )
,
ÔÔ) *
length
ÔÔ+ 1
)
ÔÔ1 2
;
ÔÔ2 3
}
ÕÕ 	
public
×× 
override
×× 
ArraySegment
×× $
<
××$ %
byte
××% )
>
××) *
[
××* +
]
××+ ,
GetIoBuffers
××- 9
(
××9 :
int
××: =
index
××> C
,
××C D
int
××E H
length
××I O
)
××O P
{
ØØ 	/
!RecordLeakNonRefCountingOperation
ÙÙ -
(
ÙÙ- .
this
ÙÙ. 2
.
ÙÙ2 3
Leak
ÙÙ3 7
)
ÙÙ7 8
;
ÙÙ8 9
return
ÚÚ 
base
ÚÚ 
.
ÚÚ 
GetIoBuffers
ÚÚ $
(
ÚÚ$ %
index
ÚÚ% *
,
ÚÚ* +
length
ÚÚ, 2
)
ÚÚ2 3
;
ÚÚ3 4
}
ÛÛ 	
public
İİ 
override
İİ 
string
İİ 
ToString
İİ '
(
İİ' (
Encoding
İİ( 0
encoding
İİ1 9
)
İİ9 :
{
ŞŞ 	/
!RecordLeakNonRefCountingOperation
ßß -
(
ßß- .
this
ßß. 2
.
ßß2 3
Leak
ßß3 7
)
ßß7 8
;
ßß8 9
return
àà 
base
àà 
.
àà 
ToString
àà  
(
àà  !
encoding
àà! )
)
àà) *
;
àà* +
}
áá 	
public
ãã 
override
ãã 
string
ãã 
ToString
ãã '
(
ãã' (
int
ãã( +
index
ãã, 1
,
ãã1 2
int
ãã3 6
length
ãã7 =
,
ãã= >
Encoding
ãã? G
encoding
ããH P
)
ããP Q
{
ää 	/
!RecordLeakNonRefCountingOperation
åå -
(
åå- .
this
åå. 2
.
åå2 3
Leak
åå3 7
)
åå7 8
;
åå8 9
return
ææ 
base
ææ 
.
ææ 
ToString
ææ  
(
ææ  !
index
ææ! &
,
ææ& '
length
ææ( .
,
ææ. /
encoding
ææ0 8
)
ææ8 9
;
ææ9 :
}
çç 	
public
éé 
override
éé 
IByteBuffer
éé #
AdjustCapacity
éé$ 2
(
éé2 3
int
éé3 6
newCapacity
éé7 B
)
ééB C
{
êê 	/
!RecordLeakNonRefCountingOperation
ëë -
(
ëë- .
this
ëë. 2
.
ëë2 3
Leak
ëë3 7
)
ëë7 8
;
ëë8 9
return
ìì 
base
ìì 
.
ìì 
AdjustCapacity
ìì &
(
ìì& '
newCapacity
ìì' 2
)
ìì2 3
;
ìì3 4
}
íí 	
public
ïï 
override
ïï 
short
ïï 

GetShortLE
ïï (
(
ïï( )
int
ïï) ,
index
ïï- 2
)
ïï2 3
{
ğğ 	/
!RecordLeakNonRefCountingOperation
ññ -
(
ññ- .
this
ññ. 2
.
ññ2 3
Leak
ññ3 7
)
ññ7 8
;
ññ8 9
return
òò 
base
òò 
.
òò 

GetShortLE
òò "
(
òò" #
index
òò# (
)
òò( )
;
òò) *
}
óó 	
public
õõ 
override
õõ 
int
õõ !
GetUnsignedMediumLE
õõ /
(
õõ/ 0
int
õõ0 3
index
õõ4 9
)
õõ9 :
{
öö 	/
!RecordLeakNonRefCountingOperation
÷÷ -
(
÷÷- .
this
÷÷. 2
.
÷÷2 3
Leak
÷÷3 7
)
÷÷7 8
;
÷÷8 9
return
øø 
base
øø 
.
øø !
GetUnsignedMediumLE
øø +
(
øø+ ,
index
øø, 1
)
øø1 2
;
øø2 3
}
ùù 	
public
ûû 
override
ûû 
int
ûû 
GetIntLE
ûû $
(
ûû$ %
int
ûû% (
index
ûû) .
)
ûû. /
{
üü 	/
!RecordLeakNonRefCountingOperation
ıı -
(
ıı- .
this
ıı. 2
.
ıı2 3
Leak
ıı3 7
)
ıı7 8
;
ıı8 9
return
şş 
base
şş 
.
şş 
GetIntLE
şş  
(
şş  !
index
şş! &
)
şş& '
;
şş' (
}
ÿÿ 	
public
 
override
 
long
 
	GetLongLE
 &
(
& '
int
' *
index
+ 0
)
0 1
{
‚‚ 	/
!RecordLeakNonRefCountingOperation
ƒƒ -
(
ƒƒ- .
this
ƒƒ. 2
.
ƒƒ2 3
Leak
ƒƒ3 7
)
ƒƒ7 8
;
ƒƒ8 9
return
„„ 
base
„„ 
.
„„ 
	GetLongLE
„„ !
(
„„! "
index
„„" '
)
„„' (
;
„„( )
}
…… 	
public
‡‡ 
override
‡‡ 
IByteBuffer
‡‡ #

SetShortLE
‡‡$ .
(
‡‡. /
int
‡‡/ 2
index
‡‡3 8
,
‡‡8 9
int
‡‡: =
value
‡‡> C
)
‡‡C D
{
ˆˆ 	/
!RecordLeakNonRefCountingOperation
‰‰ -
(
‰‰- .
this
‰‰. 2
.
‰‰2 3
Leak
‰‰3 7
)
‰‰7 8
;
‰‰8 9
return
ŠŠ 
base
ŠŠ 
.
ŠŠ 

SetShortLE
ŠŠ "
(
ŠŠ" #
index
ŠŠ# (
,
ŠŠ( )
value
ŠŠ* /
)
ŠŠ/ 0
;
ŠŠ0 1
}
‹‹ 	
public
 
override
 
IByteBuffer
 #
SetIntLE
$ ,
(
, -
int
- 0
index
1 6
,
6 7
int
8 ;
value
< A
)
A B
{
 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
SetIntLE
  
(
  !
index
! &
,
& '
value
( -
)
- .
;
. /
}
‘‘ 	
public
““ 
override
““ 
IByteBuffer
““ #
SetMediumLE
““$ /
(
““/ 0
int
““0 3
index
““4 9
,
““9 :
int
““; >
value
““? D
)
““D E
{
”” 	/
!RecordLeakNonRefCountingOperation
•• -
(
••- .
this
••. 2
.
••2 3
Leak
••3 7
)
••7 8
;
••8 9
return
–– 
base
–– 
.
–– 
SetMediumLE
–– #
(
––# $
index
––$ )
,
––) *
value
––+ 0
)
––0 1
;
––1 2
}
—— 	
public
™™ 
override
™™ 
IByteBuffer
™™ #
	SetLongLE
™™$ -
(
™™- .
int
™™. 1
index
™™2 7
,
™™7 8
long
™™9 =
value
™™> C
)
™™C D
{
šš 	/
!RecordLeakNonRefCountingOperation
›› -
(
››- .
this
››. 2
.
››2 3
Leak
››3 7
)
››7 8
;
››8 9
return
œœ 
base
œœ 
.
œœ 
	SetLongLE
œœ !
(
œœ! "
index
œœ" '
,
œœ' (
value
œœ) .
)
œœ. /
;
œœ/ 0
}
 	
public
ŸŸ 
override
ŸŸ 
short
ŸŸ 
ReadShortLE
ŸŸ )
(
ŸŸ) *
)
ŸŸ* +
{
   	/
!RecordLeakNonRefCountingOperation
¡¡ -
(
¡¡- .
this
¡¡. 2
.
¡¡2 3
Leak
¡¡3 7
)
¡¡7 8
;
¡¡8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
ReadShortLE
¢¢ #
(
¢¢# $
)
¢¢$ %
;
¢¢% &
}
££ 	
public
¥¥ 
override
¥¥ 
int
¥¥ "
ReadUnsignedMediumLE
¥¥ 0
(
¥¥0 1
)
¥¥1 2
{
¦¦ 	/
!RecordLeakNonRefCountingOperation
§§ -
(
§§- .
this
§§. 2
.
§§2 3
Leak
§§3 7
)
§§7 8
;
§§8 9
return
¨¨ 
base
¨¨ 
.
¨¨ "
ReadUnsignedMediumLE
¨¨ ,
(
¨¨, -
)
¨¨- .
;
¨¨. /
}
©© 	
public
«« 
override
«« 
int
«« 
	ReadIntLE
«« %
(
««% &
)
««& '
{
¬¬ 	/
!RecordLeakNonRefCountingOperation
­­ -
(
­­- .
this
­­. 2
.
­­2 3
Leak
­­3 7
)
­­7 8
;
­­8 9
return
®® 
base
®® 
.
®® 
	ReadIntLE
®® !
(
®®! "
)
®®" #
;
®®# $
}
¯¯ 	
public
±± 
override
±± 
long
±± 

ReadLongLE
±± '
(
±±' (
)
±±( )
{
²² 	/
!RecordLeakNonRefCountingOperation
³³ -
(
³³- .
this
³³. 2
.
³³2 3
Leak
³³3 7
)
³³7 8
;
³³8 9
return
´´ 
base
´´ 
.
´´ 

ReadLongLE
´´ "
(
´´" #
)
´´# $
;
´´$ %
}
µµ 	
public
·· 
override
·· 
IByteBuffer
·· #
WriteShortLE
··$ 0
(
··0 1
int
··1 4
value
··5 :
)
··: ;
{
¸¸ 	/
!RecordLeakNonRefCountingOperation
¹¹ -
(
¹¹- .
this
¹¹. 2
.
¹¹2 3
Leak
¹¹3 7
)
¹¹7 8
;
¹¹8 9
return
ºº 
base
ºº 
.
ºº 
WriteShortLE
ºº $
(
ºº$ %
value
ºº% *
)
ºº* +
;
ºº+ ,
}
»» 	
public
½½ 
override
½½ 
IByteBuffer
½½ #
WriteMediumLE
½½$ 1
(
½½1 2
int
½½2 5
value
½½6 ;
)
½½; <
{
¾¾ 	/
!RecordLeakNonRefCountingOperation
¿¿ -
(
¿¿- .
this
¿¿. 2
.
¿¿2 3
Leak
¿¿3 7
)
¿¿7 8
;
¿¿8 9
return
ÀÀ 
base
ÀÀ 
.
ÀÀ 
WriteMediumLE
ÀÀ %
(
ÀÀ% &
value
ÀÀ& +
)
ÀÀ+ ,
;
ÀÀ, -
}
ÁÁ 	
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #

WriteIntLE
ÃÃ$ .
(
ÃÃ. /
int
ÃÃ/ 2
value
ÃÃ3 8
)
ÃÃ8 9
{
ÄÄ 	/
!RecordLeakNonRefCountingOperation
ÅÅ -
(
ÅÅ- .
this
ÅÅ. 2
.
ÅÅ2 3
Leak
ÅÅ3 7
)
ÅÅ7 8
;
ÅÅ8 9
return
ÆÆ 
base
ÆÆ 
.
ÆÆ 

WriteIntLE
ÆÆ "
(
ÆÆ" #
value
ÆÆ# (
)
ÆÆ( )
;
ÆÆ) *
}
ÇÇ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
WriteLongLE
ÉÉ$ /
(
ÉÉ/ 0
long
ÉÉ0 4
value
ÉÉ5 :
)
ÉÉ: ;
{
ÊÊ 	/
!RecordLeakNonRefCountingOperation
ËË -
(
ËË- .
this
ËË. 2
.
ËË2 3
Leak
ËË3 7
)
ËË7 8
;
ËË8 9
return
ÌÌ 
base
ÌÌ 
.
ÌÌ 
WriteLongLE
ÌÌ #
(
ÌÌ# $
value
ÌÌ$ )
)
ÌÌ) *
;
ÌÌ* +
}
ÍÍ 	
public
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ #
GetBytes
ÏÏ$ ,
(
ÏÏ, -
int
ÏÏ- 0
index
ÏÏ1 6
,
ÏÏ6 7
Stream
ÏÏ8 >
destination
ÏÏ? J
,
ÏÏJ K
int
ÏÏL O
length
ÏÏP V
)
ÏÏV W
{
ĞĞ 	/
!RecordLeakNonRefCountingOperation
ÑÑ -
(
ÑÑ- .
this
ÑÑ. 2
.
ÑÑ2 3
Leak
ÑÑ3 7
)
ÑÑ7 8
;
ÑÑ8 9
return
ÒÒ 
base
ÒÒ 
.
ÒÒ 
GetBytes
ÒÒ  
(
ÒÒ  !
index
ÒÒ! &
,
ÒÒ& '
destination
ÒÒ( 3
,
ÒÒ3 4
length
ÒÒ5 ;
)
ÒÒ; <
;
ÒÒ< =
}
ÓÓ 	
public
ÕÕ 
override
ÕÕ !
CompositeByteBuffer
ÕÕ +
AddComponent
ÕÕ, 8
(
ÕÕ8 9
bool
ÕÕ9 =!
increaseWriterIndex
ÕÕ> Q
,
ÕÕQ R
IByteBuffer
ÕÕS ^
buffer
ÕÕ_ e
)
ÕÕe f
{
ÖÖ 	/
!RecordLeakNonRefCountingOperation
×× -
(
××- .
this
××. 2
.
××2 3
Leak
××3 7
)
××7 8
;
××8 9
return
ØØ 
base
ØØ 
.
ØØ 
AddComponent
ØØ $
(
ØØ$ %!
increaseWriterIndex
ØØ% 8
,
ØØ8 9
buffer
ØØ: @
)
ØØ@ A
;
ØØA B
}
ÙÙ 	
public
ÛÛ 
override
ÛÛ !
CompositeByteBuffer
ÛÛ +
AddComponent
ÛÛ, 8
(
ÛÛ8 9
bool
ÛÛ9 =!
increaseWriterIndex
ÛÛ> Q
,
ÛÛQ R
int
ÛÛS V
cIndex
ÛÛW ]
,
ÛÛ] ^
IByteBuffer
ÛÛ_ j
buffer
ÛÛk q
)
ÛÛq r
{
ÜÜ 	/
!RecordLeakNonRefCountingOperation
İİ -
(
İİ- .
this
İİ. 2
.
İİ2 3
Leak
İİ3 7
)
İİ7 8
;
İİ8 9
return
ŞŞ 
base
ŞŞ 
.
ŞŞ 
AddComponent
ŞŞ $
(
ŞŞ$ %!
increaseWriterIndex
ŞŞ% 8
,
ŞŞ8 9
cIndex
ŞŞ: @
,
ŞŞ@ A
buffer
ŞŞB H
)
ŞŞH I
;
ŞŞI J
}
ßß 	
public
áá 
override
áá !
CompositeByteBuffer
áá +
AddComponent
áá, 8
(
áá8 9
IByteBuffer
áá9 D
buffer
ááE K
)
ááK L
{
ââ 	/
!RecordLeakNonRefCountingOperation
ãã -
(
ãã- .
this
ãã. 2
.
ãã2 3
Leak
ãã3 7
)
ãã7 8
;
ãã8 9
return
ää 
base
ää 
.
ää 
AddComponent
ää $
(
ää$ %
buffer
ää% +
)
ää+ ,
;
ää, -
}
åå 	
public
çç 
override
çç !
CompositeByteBuffer
çç +
AddComponent
çç, 8
(
çç8 9
int
çç9 <
cIndex
çç= C
,
ççC D
IByteBuffer
ççE P
buffer
ççQ W
)
ççW X
{
èè 	/
!RecordLeakNonRefCountingOperation
éé -
(
éé- .
this
éé. 2
.
éé2 3
Leak
éé3 7
)
éé7 8
;
éé8 9
return
êê 
base
êê 
.
êê 
AddComponent
êê $
(
êê$ %
cIndex
êê% +
,
êê+ ,
buffer
êê- 3
)
êê3 4
;
êê4 5
}
ëë 	
public
íí 
override
íí !
CompositeByteBuffer
íí +
AddComponents
íí, 9
(
íí9 :
bool
íí: >!
increaseWriterIndex
íí? R
,
ííR S
params
ííT Z
IByteBuffer
íí[ f
[
ííf g
]
ííg h
buffers
ííi p
)
ííp q
{
îî 	/
!RecordLeakNonRefCountingOperation
ïï -
(
ïï- .
this
ïï. 2
.
ïï2 3
Leak
ïï3 7
)
ïï7 8
;
ïï8 9
return
ğğ 
base
ğğ 
.
ğğ 
AddComponents
ğğ %
(
ğğ% &!
increaseWriterIndex
ğğ& 9
,
ğğ9 :
buffers
ğğ; B
)
ğğB C
;
ğğC D
}
ññ 	
public
óó 
override
óó !
CompositeByteBuffer
óó +
AddComponents
óó, 9
(
óó9 :
bool
óó: >!
increaseWriterIndex
óó? R
,
óóR S
IEnumerable
óóT _
<
óó_ `
IByteBuffer
óó` k
>
óók l
buffers
óóm t
)
óót u
{
ôô 	/
!RecordLeakNonRefCountingOperation
õõ -
(
õõ- .
this
õõ. 2
.
õõ2 3
Leak
õõ3 7
)
õõ7 8
;
õõ8 9
return
öö 
base
öö 
.
öö 
AddComponents
öö %
(
öö% &!
increaseWriterIndex
öö& 9
,
öö9 :
buffers
öö; B
)
ööB C
;
ööC D
}
÷÷ 	
public
ùù 
override
ùù !
CompositeByteBuffer
ùù +
AddComponents
ùù, 9
(
ùù9 :
IEnumerable
ùù: E
<
ùùE F
IByteBuffer
ùùF Q
>
ùùQ R
buffers
ùùS Z
)
ùùZ [
{
úú 	/
!RecordLeakNonRefCountingOperation
ûû -
(
ûû- .
this
ûû. 2
.
ûû2 3
Leak
ûû3 7
)
ûû7 8
;
ûû8 9
return
üü 
base
üü 
.
üü 
AddComponents
üü %
(
üü% &
buffers
üü& -
)
üü- .
;
üü. /
}
ıı 	
public
ÿÿ 
override
ÿÿ !
CompositeByteBuffer
ÿÿ +
AddComponents
ÿÿ, 9
(
ÿÿ9 :
int
ÿÿ: =
cIndex
ÿÿ> D
,
ÿÿD E
IEnumerable
ÿÿF Q
<
ÿÿQ R
IByteBuffer
ÿÿR ]
>
ÿÿ] ^
buffers
ÿÿ_ f
)
ÿÿf g
{
€€ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
‚‚ 
base
‚‚ 
.
‚‚ 
AddComponents
‚‚ %
(
‚‚% &
cIndex
‚‚& ,
,
‚‚, -
buffers
‚‚. 5
)
‚‚5 6
;
‚‚6 7
}
ƒƒ 	
public
…… 
override
…… !
CompositeByteBuffer
…… +
AddComponents
……, 9
(
……9 :
int
……: =
cIndex
……> D
,
……D E
params
……F L
IByteBuffer
……M X
[
……X Y
]
……Y Z
buffers
……[ b
)
……b c
{
†† 	/
!RecordLeakNonRefCountingOperation
‡‡ -
(
‡‡- .
this
‡‡. 2
.
‡‡2 3
Leak
‡‡3 7
)
‡‡7 8
;
‡‡8 9
return
ˆˆ 
base
ˆˆ 
.
ˆˆ 
AddComponents
ˆˆ %
(
ˆˆ% &
cIndex
ˆˆ& ,
,
ˆˆ, -
buffers
ˆˆ. 5
)
ˆˆ5 6
;
ˆˆ6 7
}
‰‰ 	
public
‹‹ 
override
‹‹ !
CompositeByteBuffer
‹‹ +
AddComponents
‹‹, 9
(
‹‹9 :
params
‹‹: @
IByteBuffer
‹‹A L
[
‹‹L M
]
‹‹M N
buffers
‹‹O V
)
‹‹V W
{
ŒŒ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
 
base
 
.
 
AddComponents
 %
(
% &
buffers
& -
)
- .
;
. /
}
 	
public
‘‘ 
override
‘‘ !
CompositeByteBuffer
‘‘ +
RemoveComponent
‘‘, ;
(
‘‘; <
int
‘‘< ?
cIndex
‘‘@ F
)
‘‘F G
{
’’ 	/
!RecordLeakNonRefCountingOperation
““ -
(
““- .
this
““. 2
.
““2 3
Leak
““3 7
)
““7 8
;
““8 9
return
”” 
base
”” 
.
”” 
RemoveComponent
”” '
(
””' (
cIndex
””( .
)
””. /
;
””/ 0
}
•• 	
public
—— 
override
—— !
CompositeByteBuffer
—— +
RemoveComponents
——, <
(
——< =
int
——= @
cIndex
——A G
,
——G H
int
——I L
numComponents
——M Z
)
——Z [
{
˜˜ 	/
!RecordLeakNonRefCountingOperation
™™ -
(
™™- .
this
™™. 2
.
™™2 3
Leak
™™3 7
)
™™7 8
;
™™8 9
return
šš 
base
šš 
.
šš 
RemoveComponents
šš (
(
šš( )
cIndex
šš) /
,
šš/ 0
numComponents
šš1 >
)
šš> ?
;
šš? @
}
›› 	
public
 
override
 !
CompositeByteBuffer
 +
Consolidate
, 7
(
7 8
)
8 9
{
 	/
!RecordLeakNonRefCountingOperation
ŸŸ -
(
ŸŸ- .
this
ŸŸ. 2
.
ŸŸ2 3
Leak
ŸŸ3 7
)
ŸŸ7 8
;
ŸŸ8 9
return
   
base
   
.
   
Consolidate
   #
(
  # $
)
  $ %
;
  % &
}
¡¡ 	
public
££ 
override
££ !
CompositeByteBuffer
££ +
Consolidate
££, 7
(
££7 8
int
££8 ;
cIndex
££< B
,
££B C
int
££D G
numComponents
££H U
)
££U V
{
¤¤ 	/
!RecordLeakNonRefCountingOperation
¥¥ -
(
¥¥- .
this
¥¥. 2
.
¥¥2 3
Leak
¥¥3 7
)
¥¥7 8
;
¥¥8 9
return
¦¦ 
base
¦¦ 
.
¦¦ 
Consolidate
¦¦ #
(
¦¦# $
cIndex
¦¦$ *
,
¦¦* +
numComponents
¦¦, 9
)
¦¦9 :
;
¦¦: ;
}
§§ 	
public
©© 
override
©© !
CompositeByteBuffer
©© +#
DiscardReadComponents
©©, A
(
©©A B
)
©©B C
{
ªª 	/
!RecordLeakNonRefCountingOperation
«« -
(
««- .
this
««. 2
.
««2 3
Leak
««3 7
)
««7 8
;
««8 9
return
¬¬ 
base
¬¬ 
.
¬¬ #
DiscardReadComponents
¬¬ -
(
¬¬- .
)
¬¬. /
;
¬¬/ 0
}
­­ 	
public
¯¯ 
override
¯¯ 
IList
¯¯ 
<
¯¯ 
IByteBuffer
¯¯ )
>
¯¯) *
	Decompose
¯¯+ 4
(
¯¯4 5
int
¯¯5 8
offset
¯¯9 ?
,
¯¯? @
int
¯¯A D
length
¯¯E K
)
¯¯K L
{
°° 	/
!RecordLeakNonRefCountingOperation
±± -
(
±±- .
this
±±. 2
.
±±2 3
Leak
±±3 7
)
±±7 8
;
±±8 9
return
²² 
base
²² 
.
²² 
	Decompose
²² !
(
²²! "
offset
²²" (
,
²²( )
length
²²* 0
)
²²0 1
;
²²1 2
}
³³ 	
public
µµ 
override
µµ 
ICharSequence
µµ %
GetCharSequence
µµ& 5
(
µµ5 6
int
µµ6 9
index
µµ: ?
,
µµ? @
int
µµA D
length
µµE K
,
µµK L
Encoding
µµM U
encoding
µµV ^
)
µµ^ _
{
¶¶ 	/
!RecordLeakNonRefCountingOperation
·· -
(
··- .
this
··. 2
.
··2 3
Leak
··3 7
)
··7 8
;
··8 9
return
¸¸ 
base
¸¸ 
.
¸¸ 
GetCharSequence
¸¸ '
(
¸¸' (
index
¸¸( -
,
¸¸- .
length
¸¸/ 5
,
¸¸5 6
encoding
¸¸7 ?
)
¸¸? @
;
¸¸@ A
}
¹¹ 	
public
»» 
override
»» 
ICharSequence
»» %
ReadCharSequence
»»& 6
(
»»6 7
int
»»7 :
length
»»; A
,
»»A B
Encoding
»»C K
encoding
»»L T
)
»»T U
{
¼¼ 	/
!RecordLeakNonRefCountingOperation
½½ -
(
½½- .
this
½½. 2
.
½½2 3
Leak
½½3 7
)
½½7 8
;
½½8 9
return
¾¾ 
base
¾¾ 
.
¾¾ 
ReadCharSequence
¾¾ (
(
¾¾( )
length
¾¾) /
,
¾¾/ 0
encoding
¾¾1 9
)
¾¾9 :
;
¾¾: ;
}
¿¿ 	
public
ÁÁ 
override
ÁÁ 
int
ÁÁ 
SetCharSequence
ÁÁ +
(
ÁÁ+ ,
int
ÁÁ, /
index
ÁÁ0 5
,
ÁÁ5 6
ICharSequence
ÁÁ7 D
sequence
ÁÁE M
,
ÁÁM N
Encoding
ÁÁO W
encoding
ÁÁX `
)
ÁÁ` a
{
ÂÂ 	/
!RecordLeakNonRefCountingOperation
ÃÃ -
(
ÃÃ- .
this
ÃÃ. 2
.
ÃÃ2 3
Leak
ÃÃ3 7
)
ÃÃ7 8
;
ÃÃ8 9
return
ÄÄ 
base
ÄÄ 
.
ÄÄ 
SetCharSequence
ÄÄ '
(
ÄÄ' (
index
ÄÄ( -
,
ÄÄ- .
sequence
ÄÄ/ 7
,
ÄÄ7 8
encoding
ÄÄ9 A
)
ÄÄA B
;
ÄÄB C
}
ÅÅ 	
public
ÇÇ 
override
ÇÇ 
int
ÇÇ 
WriteCharSequence
ÇÇ -
(
ÇÇ- .
ICharSequence
ÇÇ. ;
sequence
ÇÇ< D
,
ÇÇD E
Encoding
ÇÇF N
encoding
ÇÇO W
)
ÇÇW X
{
ÈÈ 	/
!RecordLeakNonRefCountingOperation
ÉÉ -
(
ÉÉ- .
this
ÉÉ. 2
.
ÉÉ2 3
Leak
ÉÉ3 7
)
ÉÉ7 8
;
ÉÉ8 9
return
ÊÊ 
base
ÊÊ 
.
ÊÊ 
WriteCharSequence
ÊÊ )
(
ÊÊ) *
sequence
ÊÊ* 2
,
ÊÊ2 3
encoding
ÊÊ4 <
)
ÊÊ< =
;
ÊÊ= >
}
ËË 	
public
ÍÍ 
override
ÍÍ 
string
ÍÍ 
	GetString
ÍÍ (
(
ÍÍ( )
int
ÍÍ) ,
index
ÍÍ- 2
,
ÍÍ2 3
int
ÍÍ4 7
length
ÍÍ8 >
,
ÍÍ> ?
Encoding
ÍÍ@ H
encoding
ÍÍI Q
)
ÍÍQ R
{
ÎÎ 	/
!RecordLeakNonRefCountingOperation
ÏÏ -
(
ÏÏ- .
this
ÏÏ. 2
.
ÏÏ2 3
Leak
ÏÏ3 7
)
ÏÏ7 8
;
ÏÏ8 9
return
ĞĞ 
base
ĞĞ 
.
ĞĞ 
	GetString
ĞĞ !
(
ĞĞ! "
index
ĞĞ" '
,
ĞĞ' (
length
ĞĞ) /
,
ĞĞ/ 0
encoding
ĞĞ1 9
)
ĞĞ9 :
;
ĞĞ: ;
}
ÑÑ 	
public
ÓÓ 
override
ÓÓ 
string
ÓÓ 

ReadString
ÓÓ )
(
ÓÓ) *
int
ÓÓ* -
length
ÓÓ. 4
,
ÓÓ4 5
Encoding
ÓÓ6 >
encoding
ÓÓ? G
)
ÓÓG H
{
ÔÔ 	/
!RecordLeakNonRefCountingOperation
ÕÕ -
(
ÕÕ- .
this
ÕÕ. 2
.
ÕÕ2 3
Leak
ÕÕ3 7
)
ÕÕ7 8
;
ÕÕ8 9
return
ÖÖ 
base
ÖÖ 
.
ÖÖ 

ReadString
ÖÖ "
(
ÖÖ" #
length
ÖÖ# )
,
ÖÖ) *
encoding
ÖÖ+ 3
)
ÖÖ3 4
;
ÖÖ4 5
}
×× 	
public
ÙÙ 
override
ÙÙ 
int
ÙÙ 
	SetString
ÙÙ %
(
ÙÙ% &
int
ÙÙ& )
index
ÙÙ* /
,
ÙÙ/ 0
string
ÙÙ1 7
value
ÙÙ8 =
,
ÙÙ= >
Encoding
ÙÙ? G
encoding
ÙÙH P
)
ÙÙP Q
{
ÚÚ 	/
!RecordLeakNonRefCountingOperation
ÛÛ -
(
ÛÛ- .
this
ÛÛ. 2
.
ÛÛ2 3
Leak
ÛÛ3 7
)
ÛÛ7 8
;
ÛÛ8 9
return
ÜÜ 
base
ÜÜ 
.
ÜÜ 
	SetString
ÜÜ !
(
ÜÜ! "
index
ÜÜ" '
,
ÜÜ' (
value
ÜÜ) .
,
ÜÜ. /
encoding
ÜÜ0 8
)
ÜÜ8 9
;
ÜÜ9 :
}
İİ 	
public
ßß 
override
ßß 
int
ßß 
WriteString
ßß '
(
ßß' (
string
ßß( .
value
ßß/ 4
,
ßß4 5
Encoding
ßß6 >
encoding
ßß? G
)
ßßG H
{
àà 	/
!RecordLeakNonRefCountingOperation
áá -
(
áá- .
this
áá. 2
.
áá2 3
Leak
áá3 7
)
áá7 8
;
áá8 9
return
ââ 
base
ââ 
.
ââ 
WriteString
ââ #
(
ââ# $
value
ââ$ )
,
ââ) *
encoding
ââ+ 3
)
ââ3 4
;
ââ4 5
}
ãã 	
public
åå 
override
åå 
IEnumerator
åå #
<
åå# $
IByteBuffer
åå$ /
>
åå/ 0
GetEnumerator
åå1 >
(
åå> ?
)
åå? @
{
ææ 	/
!RecordLeakNonRefCountingOperation
çç -
(
çç- .
this
çç. 2
.
çç2 3
Leak
çç3 7
)
çç7 8
;
çç8 9
return
èè 
base
èè 
.
èè 
GetEnumerator
èè %
(
èè% &
)
èè& '
;
èè' (
}
éé 	
public
ëë 
override
ëë 
IReferenceCounted
ëë )
Retain
ëë* 0
(
ëë0 1
)
ëë1 2
{
ìì 	
this
íí 
.
íí 
Leak
íí 
.
íí 
Record
íí 
(
íí 
)
íí 
;
íí 
return
îî 
base
îî 
.
îî 
Retain
îî 
(
îî 
)
îî  
;
îî  !
}
ïï 	
public
ññ 
override
ññ 
IReferenceCounted
ññ )
Retain
ññ* 0
(
ññ0 1
int
ññ1 4
	increment
ññ5 >
)
ññ> ?
{
òò 	
this
óó 
.
óó 
Leak
óó 
.
óó 
Record
óó 
(
óó 
)
óó 
;
óó 
return
ôô 
base
ôô 
.
ôô 
Retain
ôô 
(
ôô 
	increment
ôô (
)
ôô( )
;
ôô) *
}
õõ 	
public
÷÷ 
override
÷÷ 
IByteBuffer
÷÷ #
RetainedSlice
÷÷$ 1
(
÷÷1 2
)
÷÷2 3
{
øø 	/
!RecordLeakNonRefCountingOperation
ùù -
(
ùù- .
this
ùù. 2
.
ùù2 3
Leak
ùù3 7
)
ùù7 8
;
ùù8 9
return
úú 
base
úú 
.
úú 
RetainedSlice
úú %
(
úú% &
)
úú& '
;
úú' (
}
ûû 	
public
ıı 
override
ıı 
IByteBuffer
ıı #
RetainedSlice
ıı$ 1
(
ıı1 2
int
ıı2 5
index
ıı6 ;
,
ıı; <
int
ıı= @
length
ııA G
)
ııG H
{
şş 	/
!RecordLeakNonRefCountingOperation
ÿÿ -
(
ÿÿ- .
this
ÿÿ. 2
.
ÿÿ2 3
Leak
ÿÿ3 7
)
ÿÿ7 8
;
ÿÿ8 9
return
€€ 
base
€€ 
.
€€ 
RetainedSlice
€€ %
(
€€% &
index
€€& +
,
€€+ ,
length
€€- 3
)
€€3 4
;
€€4 5
}
 	
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #
RetainedDuplicate
ƒƒ$ 5
(
ƒƒ5 6
)
ƒƒ6 7
{
„„ 	/
!RecordLeakNonRefCountingOperation
…… -
(
……- .
this
……. 2
.
……2 3
Leak
……3 7
)
……7 8
;
……8 9
return
†† 
base
†† 
.
†† 
RetainedDuplicate
†† )
(
††) *
)
††* +
;
††+ ,
}
‡‡ 	
public
‰‰ 
override
‰‰ 
IByteBuffer
‰‰ #
ReadRetainedSlice
‰‰$ 5
(
‰‰5 6
int
‰‰6 9
length
‰‰: @
)
‰‰@ A
{
ŠŠ 	/
!RecordLeakNonRefCountingOperation
‹‹ -
(
‹‹- .
this
‹‹. 2
.
‹‹2 3
Leak
‹‹3 7
)
‹‹7 8
;
‹‹8 9
return
ŒŒ 
base
ŒŒ 
.
ŒŒ 
ReadRetainedSlice
ŒŒ )
(
ŒŒ) *
length
ŒŒ* 0
)
ŒŒ0 1
;
ŒŒ1 2
}
 	
public
 
override
 
bool
 
Release
 $
(
$ %
)
% &
{
 	
this
‘‘ 
.
‘‘ 
Leak
‘‘ 
.
‘‘ 
Record
‘‘ 
(
‘‘ 
)
‘‘ 
;
‘‘ 
return
’’ 
base
’’ 
.
’’ 
Release
’’ 
(
’’  
)
’’  !
;
’’! "
}
““ 	
public
•• 
override
•• 
bool
•• 
Release
•• $
(
••$ %
int
••% (
	decrement
••) 2
)
••2 3
{
–– 	
this
—— 
.
—— 
Leak
—— 
.
—— 
Record
—— 
(
—— 
)
—— 
;
—— 
return
˜˜ 
base
˜˜ 
.
˜˜ 
Release
˜˜ 
(
˜˜  
	decrement
˜˜  )
)
˜˜) *
;
˜˜* +
}
™™ 	
public
›› 
override
›› 
IReferenceCounted
›› )
Touch
››* /
(
››/ 0
)
››0 1
{
œœ 	
this
 
.
 
Leak
 
.
 
Record
 
(
 
)
 
;
 
return
 
this
 
;
 
}
ŸŸ 	
public
¡¡ 
override
¡¡ 
IReferenceCounted
¡¡ )
Touch
¡¡* /
(
¡¡/ 0
object
¡¡0 6
hint
¡¡7 ;
)
¡¡; <
{
¢¢ 	
this
££ 
.
££ 
Leak
££ 
.
££ 
Record
££ 
(
££ 
hint
££ !
)
££! "
;
££" #
return
¤¤ 
this
¤¤ 
;
¤¤ 
}
¥¥ 	
	protected
§§ 
override
§§ '
SimpleLeakAwareByteBuffer
§§ 4$
NewLeakAwareByteBuffer
§§5 K
(
§§K L
IByteBuffer
§§L W
wrapped
§§X _
,
§§_ `
IByteBuffer
§§a l
trackedByteBuf
§§m {
,
§§{ |#
IResourceLeakTracker§§} ‘
leakTracker§§’ 
)§§ 
=>§§Ÿ ¡
new
¨¨ )
AdvancedLeakAwareByteBuffer
¨¨ +
(
¨¨+ ,
wrapped
¨¨, 3
,
¨¨3 4
trackedByteBuf
¨¨5 C
,
¨¨C D
leakTracker
¨¨E P
)
¨¨P Q
;
¨¨Q R
}
©© 
}ªª üõ
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

static 
class 
ByteBufferUtil &
{ 
const 
char 
WriteUtfUnknown "
=# $
$char% (
;( )
static 
readonly 
int 
MaxBytesPerCharUtf8 /
=0 1
Encoding2 :
.: ;
UTF8; ?
.? @
GetMaxByteCount@ O
(O P
$numP Q
)Q R
;R S
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
ByteBufferUtilZ h
)h i
)i j
;j k
public 
static 
readonly  
IByteBufferAllocator 3
DefaultAllocator4 D
;D E
static 
ByteBufferUtil 
( 
) 
{ 	
string 
	allocType 
= 
SystemPropertyUtil 1
.1 2
Get2 5
(5 6
$str6 O
,O P
$strQ Y
)Y Z
;Z [
	allocType 
= 
	allocType !
.! "
Trim" &
(& '
)' (
;( ) 
IByteBufferAllocator  
alloc! &
;& '
if 
( 
$str 
. 
Equals !
(! "
	allocType" +
,+ ,
StringComparison- =
.= >
OrdinalIgnoreCase> O
)O P
)P Q
{ 
alloc 
= '
UnpooledByteBufferAllocator 3
.3 4
Default4 ;
;; <
Logger   
.   
Debug   
(   
$str   <
,  < =
	allocType  > G
)  G H
;  H I
}!! 
else"" 
if"" 
("" 
$str"" 
."" 
Equals"" $
(""$ %
	allocType""% .
,"". /
StringComparison""0 @
.""@ A
OrdinalIgnoreCase""A R
)""R S
)""S T
{## 
alloc$$ 
=$$ %
PooledByteBufferAllocator$$ 1
.$$1 2
Default$$2 9
;$$9 :
Logger%% 
.%% 
Debug%% 
(%% 
$str%% <
,%%< =
	allocType%%> G
)%%G H
;%%H I
}&& 
else'' 
{(( 
alloc)) 
=)) %
PooledByteBufferAllocator)) 1
.))1 2
Default))2 9
;))9 :
Logger** 
.** 
Debug** 
(** 
$str** N
,**N O
	allocType**P Y
)**Y Z
;**Z [
}++ 
DefaultAllocator-- 
=-- 
alloc-- $
;--$ %
}.. 	
public44 
static44 
string44 
HexDump44 $
(44$ %
IByteBuffer44% 0
buffer441 7
)447 8
=>449 ;
HexDump44< C
(44C D
buffer44D J
,44J K
buffer44L R
.44R S
ReaderIndex44S ^
,44^ _
buffer44` f
.44f g
ReadableBytes44g t
)44t u
;44u v
public:: 
static:: 
string:: 
HexDump:: $
(::$ %
IByteBuffer::% 0
buffer::1 7
,::7 8
int::9 <
	fromIndex::= F
,::F G
int::H K
length::L R
)::R S
=>::T V
HexUtil::W ^
.::^ _
	DoHexDump::_ h
(::h i
buffer::i o
,::o p
	fromIndex::q z
,::z {
length	::| ‚
)
::‚ ƒ
;
::ƒ „
public@@ 
static@@ 
string@@ 
HexDump@@ $
(@@$ %
byte@@% )
[@@) *
]@@* +
array@@, 1
)@@1 2
=>@@3 5
HexDump@@6 =
(@@= >
array@@> C
,@@C D
$num@@E F
,@@F G
array@@H M
.@@M N
Length@@N T
)@@T U
;@@U V
publicFF 
staticFF 
stringFF 
HexDumpFF $
(FF$ %
byteFF% )
[FF) *
]FF* +
arrayFF, 1
,FF1 2
intFF3 6
	fromIndexFF7 @
,FF@ A
intFFB E
lengthFFF L
)FFL M
=>FFN P
HexUtilFFQ X
.FFX Y
	DoHexDumpFFY b
(FFb c
arrayFFc h
,FFh i
	fromIndexFFj s
,FFs t
lengthFFu {
)FF{ |
;FF| }
publicHH 
staticHH 
boolHH !
EnsureWritableSuccessHH 0
(HH0 1
intHH1 4 
ensureWritableResultHH5 I
)HHI J
=>HHK M 
ensureWritableResultHHN b
==HHc e
$numHHf g
||HHh j 
ensureWritableResultHHk 
==
HH€ ‚
$num
HHƒ „
;
HH„ …
publicNN 
staticNN 
intNN 
HashCodeNN "
(NN" #
IByteBufferNN# .
bufferNN/ 5
)NN5 6
{OO 	
intPP 
aLenPP 
=PP 
bufferPP 
.PP 
ReadableBytesPP +
;PP+ ,
intQQ 
intCountQQ 
=QQ 
(QQ 
intQQ 
)QQ  
(QQ  !
(QQ! "
uintQQ" &
)QQ& '
aLenQQ' +
>>QQ, .
$numQQ/ 0
)QQ0 1
;QQ1 2
intRR 
	byteCountRR 
=RR 
aLenRR  
&RR! "
$numRR# $
;RR$ %
intTT 
hashCodeTT 
=TT 
$numTT 
;TT 
intUU 

arrayIndexUU 
=UU 
bufferUU #
.UU# $
ReaderIndexUU$ /
;UU/ 0
forVV 
(VV 
intVV 
iVV 
=VV 
intCountVV !
;VV! "
iVV# $
>VV% &
$numVV' (
;VV( )
iVV* +
--VV+ -
)VV- .
{WW 
hashCodeXX 
=XX 
$numXX 
*XX 
hashCodeXX  (
+XX) *
bufferXX+ 1
.XX1 2
GetIntXX2 8
(XX8 9

arrayIndexXX9 C
)XXC D
;XXD E

arrayIndexYY 
+=YY 
$numYY 
;YY  
}ZZ 
for\\ 
(\\ 
int\\ 
i\\ 
=\\ 
	byteCount\\ "
;\\" #
i\\$ %
>\\& '
$num\\( )
;\\) *
i\\+ ,
--\\, .
)\\. /
{]] 
hashCode^^ 
=^^ 
$num^^ 
*^^ 
hashCode^^  (
+^^) *
buffer^^+ 1
.^^1 2
GetByte^^2 9
(^^9 :

arrayIndex^^: D
++^^D F
)^^F G
;^^G H
}__ 
ifaa 
(aa 
hashCodeaa 
==aa 
$numaa 
)aa 
{bb 
hashCodecc 
=cc 
$numcc 
;cc 
}dd 
returnff 
hashCodeff 
;ff 
}gg 	
publicll 
staticll 
intll 
IndexOfll !
(ll! "
IByteBufferll" -
needlell. 4
,ll4 5
IByteBufferll6 A
haystackllB J
)llJ K
{mm 	
intoo 
attemptsoo 
=oo 
haystackoo #
.oo# $
ReadableBytesoo$ 1
-oo2 3
needleoo4 :
.oo: ;
ReadableBytesoo; H
+ooI J
$numooK L
;ooL M
forpp 
(pp 
intpp 
ipp 
=pp 
$numpp 
;pp 
ipp 
<pp 
attemptspp  (
;pp( )
ipp* +
++pp+ -
)pp- .
{qq 
ifrr 
(rr 
Equalsrr 
(rr 
needlerr !
,rr! "
needlerr# )
.rr) *
ReaderIndexrr* 5
,rr5 6
haystackrr7 ?
,rr? @
haystackrrA I
.rrI J
ReaderIndexrrJ U
+rrV W
irrX Y
,rrY Z
needlerr[ a
.rra b
ReadableBytesrrb o
)rro p
)rrp q
{ss 
returntt 
haystacktt #
.tt# $
ReaderIndextt$ /
+tt0 1
itt2 3
;tt3 4
}uu 
}vv 
returnxx 
-xx 
$numxx 
;xx 
}yy 	
public
ƒƒ 
static
ƒƒ 
bool
ƒƒ 
Equals
ƒƒ !
(
ƒƒ! "
IByteBuffer
ƒƒ" -
a
ƒƒ. /
,
ƒƒ/ 0
int
ƒƒ1 4
aStartIndex
ƒƒ5 @
,
ƒƒ@ A
IByteBuffer
ƒƒB M
b
ƒƒN O
,
ƒƒO P
int
ƒƒQ T
bStartIndex
ƒƒU `
,
ƒƒ` a
int
ƒƒb e
length
ƒƒf l
)
ƒƒl m
{
„„ 	
if
…… 
(
…… 
aStartIndex
…… 
<
…… 
$num
…… 
||
……  "
bStartIndex
……# .
<
……/ 0
$num
……1 2
||
……3 5
length
……6 <
<
……= >
$num
……? @
)
……@ A
{
†† 
throw
‡‡ 
new
‡‡ 
ArgumentException
‡‡ +
(
‡‡+ ,
$str
‡‡, Z
)
‡‡Z [
;
‡‡[ \
}
ˆˆ 
if
‰‰ 
(
‰‰ 
a
‰‰ 
.
‰‰ 
WriterIndex
‰‰ 
-
‰‰ 
length
‰‰  &
<
‰‰' (
aStartIndex
‰‰) 4
||
‰‰5 7
b
‰‰8 9
.
‰‰9 :
WriterIndex
‰‰: E
-
‰‰F G
length
‰‰H N
<
‰‰O P
bStartIndex
‰‰Q \
)
‰‰\ ]
{
ŠŠ 
return
‹‹ 
false
‹‹ 
;
‹‹ 
}
ŒŒ 
int
 
	longCount
 
=
 
	unchecked
 %
(
% &
(
& '
int
' *
)
* +
(
+ ,
(
, -
uint
- 1
)
1 2
length
2 8
>>
9 ;
$num
< =
)
= >
)
> ?
;
? @
int
 
	byteCount
 
=
 
length
 "
&
# $
$num
% &
;
& '
for
‘‘ 
(
‘‘ 
int
‘‘ 
i
‘‘ 
=
‘‘ 
	longCount
‘‘ "
;
‘‘" #
i
‘‘$ %
>
‘‘& '
$num
‘‘( )
;
‘‘) *
i
‘‘+ ,
--
‘‘, .
)
‘‘. /
{
’’ 
if
““ 
(
““ 
a
““ 
.
““ 
GetLong
““ 
(
““ 
aStartIndex
““ )
)
““) *
!=
““+ -
b
““. /
.
““/ 0
GetLong
““0 7
(
““7 8
bStartIndex
““8 C
)
““C D
)
““D E
{
”” 
return
•• 
false
••  
;
••  !
}
–– 
aStartIndex
—— 
+=
—— 
$num
——  
;
——  !
bStartIndex
˜˜ 
+=
˜˜ 
$num
˜˜  
;
˜˜  !
}
™™ 
for
›› 
(
›› 
int
›› 
i
›› 
=
›› 
	byteCount
›› "
;
››" #
i
››$ %
>
››& '
$num
››( )
;
››) *
i
››+ ,
--
››, .
)
››. /
{
œœ 
if
 
(
 
a
 
.
 
GetByte
 
(
 
aStartIndex
 )
)
) *
!=
+ -
b
. /
.
/ 0
GetByte
0 7
(
7 8
bStartIndex
8 C
)
C D
)
D E
{
 
return
ŸŸ 
false
ŸŸ  
;
ŸŸ  !
}
   
aStartIndex
¡¡ 
++
¡¡ 
;
¡¡ 
bStartIndex
¢¢ 
++
¢¢ 
;
¢¢ 
}
££ 
return
¥¥ 
true
¥¥ 
;
¥¥ 
}
¦¦ 	
public
­­ 
static
­­ 
bool
­­ 
Equals
­­ !
(
­­! "
IByteBuffer
­­" -
bufferA
­­. 5
,
­­5 6
IByteBuffer
­­7 B
bufferB
­­C J
)
­­J K
{
®® 	
int
¯¯ 
aLen
¯¯ 
=
¯¯ 
bufferA
¯¯ 
.
¯¯ 
ReadableBytes
¯¯ ,
;
¯¯, -
if
°° 
(
°° 
aLen
°° 
!=
°° 
bufferB
°° 
.
°°  
ReadableBytes
°°  -
)
°°- .
{
±± 
return
²² 
false
²² 
;
²² 
}
³³ 
return
µµ 
Equals
µµ 
(
µµ 
bufferA
µµ !
,
µµ! "
bufferA
µµ# *
.
µµ* +
ReaderIndex
µµ+ 6
,
µµ6 7
bufferB
µµ8 ?
,
µµ? @
bufferB
µµA H
.
µµH I
ReaderIndex
µµI T
,
µµT U
aLen
µµV Z
)
µµZ [
;
µµ[ \
}
¶¶ 	
public
¼¼ 
static
¼¼ 
int
¼¼ 
Compare
¼¼ !
(
¼¼! "
IByteBuffer
¼¼" -
bufferA
¼¼. 5
,
¼¼5 6
IByteBuffer
¼¼7 B
bufferB
¼¼C J
)
¼¼J K
{
½½ 	
int
¾¾ 
aLen
¾¾ 
=
¾¾ 
bufferA
¾¾ 
.
¾¾ 
ReadableBytes
¾¾ ,
;
¾¾, -
int
¿¿ 
bLen
¿¿ 
=
¿¿ 
bufferB
¿¿ 
.
¿¿ 
ReadableBytes
¿¿ ,
;
¿¿, -
int
ÀÀ 
	minLength
ÀÀ 
=
ÀÀ 
Math
ÀÀ  
.
ÀÀ  !
Min
ÀÀ! $
(
ÀÀ$ %
aLen
ÀÀ% )
,
ÀÀ) *
bLen
ÀÀ+ /
)
ÀÀ/ 0
;
ÀÀ0 1
int
ÁÁ 
	uintCount
ÁÁ 
=
ÁÁ 
	minLength
ÁÁ %
.
ÁÁ% &
RightUShift
ÁÁ& 1
(
ÁÁ1 2
$num
ÁÁ2 3
)
ÁÁ3 4
;
ÁÁ4 5
int
ÂÂ 
	byteCount
ÂÂ 
=
ÂÂ 
	minLength
ÂÂ %
&
ÂÂ& '
$num
ÂÂ( )
;
ÂÂ) *
int
ÄÄ 
aIndex
ÄÄ 
=
ÄÄ 
bufferA
ÄÄ  
.
ÄÄ  !
ReaderIndex
ÄÄ! ,
;
ÄÄ, -
int
ÅÅ 
bIndex
ÅÅ 
=
ÅÅ 
bufferB
ÅÅ  
.
ÅÅ  !
ReaderIndex
ÅÅ! ,
;
ÅÅ, -
if
ÇÇ 
(
ÇÇ 
	uintCount
ÇÇ 
>
ÇÇ 
$num
ÇÇ 
)
ÇÇ 
{
ÈÈ 
int
ÉÉ  
uintCountIncrement
ÉÉ &
=
ÉÉ' (
	uintCount
ÉÉ) 2
<<
ÉÉ3 5
$num
ÉÉ6 7
;
ÉÉ7 8
int
ÊÊ 
res
ÊÊ 
=
ÊÊ 
CompareUint
ÊÊ %
(
ÊÊ% &
bufferA
ÊÊ& -
,
ÊÊ- .
bufferB
ÊÊ/ 6
,
ÊÊ6 7
aIndex
ÊÊ8 >
,
ÊÊ> ?
bIndex
ÊÊ@ F
,
ÊÊF G 
uintCountIncrement
ÊÊH Z
)
ÊÊZ [
;
ÊÊ[ \
if
ËË 
(
ËË 
res
ËË 
!=
ËË 
$num
ËË 
)
ËË 
{
ÌÌ 
return
ÍÍ 
res
ÍÍ 
;
ÍÍ 
}
ÎÎ 
aIndex
ĞĞ 
+=
ĞĞ  
uintCountIncrement
ĞĞ ,
;
ĞĞ, -
bIndex
ÑÑ 
+=
ÑÑ  
uintCountIncrement
ÑÑ ,
;
ÑÑ, -
}
ÒÒ 
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
aEnd
ÔÔ 
=
ÔÔ 
aIndex
ÔÔ "
+
ÔÔ# $
	byteCount
ÔÔ% .
;
ÔÔ. /
aIndex
ÔÔ0 6
<
ÔÔ7 8
aEnd
ÔÔ9 =
;
ÔÔ= >
++
ÔÔ? A
aIndex
ÔÔA G
,
ÔÔG H
++
ÔÔI K
bIndex
ÔÔK Q
)
ÔÔQ R
{
ÕÕ 
int
ÖÖ 
comp
ÖÖ 
=
ÖÖ 
bufferA
ÖÖ "
.
ÖÖ" #
GetByte
ÖÖ# *
(
ÖÖ* +
aIndex
ÖÖ+ 1
)
ÖÖ1 2
-
ÖÖ3 4
bufferB
ÖÖ5 <
.
ÖÖ< =
GetByte
ÖÖ= D
(
ÖÖD E
bIndex
ÖÖE K
)
ÖÖK L
;
ÖÖL M
if
×× 
(
×× 
comp
×× 
!=
×× 
$num
×× 
)
×× 
{
ØØ 
return
ÙÙ 
comp
ÙÙ 
;
ÙÙ  
}
ÚÚ 
}
ÛÛ 
return
İİ 
aLen
İİ 
-
İİ 
bLen
İİ 
;
İİ 
}
ŞŞ 	
static
àà 
int
àà 
CompareUint
àà 
(
àà 
IByteBuffer
àà *
bufferA
àà+ 2
,
àà2 3
IByteBuffer
àà4 ?
bufferB
àà@ G
,
ààG H
int
ààI L
aIndex
ààM S
,
ààS T
int
ààU X
bIndex
ààY _
,
àà_ `
int
ààa d 
uintCountIncrement
ààe w
)
ààw x
{
áá 	
for
ââ 
(
ââ 
int
ââ 
aEnd
ââ 
=
ââ 
aIndex
ââ "
+
ââ# $ 
uintCountIncrement
ââ% 7
;
ââ7 8
aIndex
ââ9 ?
<
ââ@ A
aEnd
ââB F
;
ââF G
aIndex
ââH N
+=
ââO Q
$num
ââR S
,
ââS T
bIndex
ââU [
+=
ââ\ ^
$num
ââ_ `
)
ââ` a
{
ãã 
long
ää 
va
ää 
=
ää 
bufferA
ää !
.
ää! "
GetUnsignedInt
ää" 0
(
ää0 1
aIndex
ää1 7
)
ää7 8
;
ää8 9
long
åå 
vb
åå 
=
åå 
bufferB
åå !
.
åå! "
GetUnsignedInt
åå" 0
(
åå0 1
bIndex
åå1 7
)
åå7 8
;
åå8 9
if
ææ 
(
ææ 
va
ææ 
>
ææ 
vb
ææ 
)
ææ 
{
çç 
return
èè 
$num
èè 
;
èè 
}
éé 
if
êê 
(
êê 
va
êê 
<
êê 
vb
êê 
)
êê 
{
ëë 
return
ìì 
-
ìì 
$num
ìì 
;
ìì 
}
íí 
}
îî 
return
ïï 
$num
ïï 
;
ïï 
}
ğğ 	
public
öö 
static
öö 
int
öö 
IndexOf
öö !
(
öö! "
IByteBuffer
öö" -
buffer
öö. 4
,
öö4 5
int
öö6 9
	fromIndex
öö: C
,
ööC D
int
ööE H
toIndex
ööI P
,
ööP Q
byte
ööR V
value
ööW \
)
öö\ ]
{
÷÷ 	
if
øø 
(
øø 
	fromIndex
øø 
<=
øø 
toIndex
øø $
)
øø$ %
{
ùù 
return
úú 
FirstIndexOf
úú #
(
úú# $
buffer
úú$ *
,
úú* +
	fromIndex
úú, 5
,
úú5 6
toIndex
úú7 >
,
úú> ?
value
úú@ E
)
úúE F
;
úúF G
}
ûû 
else
üü 
{
ıı 
return
şş 
LastIndexOf
şş "
(
şş" #
buffer
şş# )
,
şş) *
	fromIndex
şş+ 4
,
şş4 5
toIndex
şş6 =
,
şş= >
value
şş? D
)
şşD E
;
şşE F
}
ÿÿ 
}
€€ 	
public
…… 
static
…… 
IByteBuffer
…… !
	ReadBytes
……" +
(
……+ ,"
IByteBufferAllocator
……, @
alloc
……A F
,
……F G
IByteBuffer
……H S
buffer
……T Z
,
……Z [
int
……\ _
length
……` f
)
……f g
{
†† 	
bool
‡‡ 
release
‡‡ 
=
‡‡ 
true
‡‡ 
;
‡‡  
IByteBuffer
ˆˆ 
dst
ˆˆ 
=
ˆˆ 
alloc
ˆˆ #
.
ˆˆ# $
Buffer
ˆˆ$ *
(
ˆˆ* +
length
ˆˆ+ 1
)
ˆˆ1 2
;
ˆˆ2 3
try
‰‰ 
{
ŠŠ 
buffer
‹‹ 
.
‹‹ 
	ReadBytes
‹‹  
(
‹‹  !
dst
‹‹! $
)
‹‹$ %
;
‹‹% &
release
ŒŒ 
=
ŒŒ 
false
ŒŒ 
;
ŒŒ  
return
 
dst
 
;
 
}
 
finally
 
{
 
if
‘‘ 
(
‘‘ 
release
‘‘ 
)
‘‘ 
{
’’ 
dst
““ 
.
““ 
Release
““ 
(
““  
)
““  !
;
““! "
}
”” 
}
•• 
}
–– 	
static
˜˜ 
int
˜˜ 
FirstIndexOf
˜˜ 
(
˜˜  
IByteBuffer
˜˜  +
buffer
˜˜, 2
,
˜˜2 3
int
˜˜4 7
	fromIndex
˜˜8 A
,
˜˜A B
int
˜˜C F
toIndex
˜˜G N
,
˜˜N O
byte
˜˜P T
value
˜˜U Z
)
˜˜Z [
{
™™ 	
	fromIndex
šš 
=
šš 
Math
šš 
.
šš 
Max
šš  
(
šš  !
	fromIndex
šš! *
,
šš* +
$num
šš, -
)
šš- .
;
šš. /
if
›› 
(
›› 
	fromIndex
›› 
>=
›› 
toIndex
›› $
||
››% '
buffer
››( .
.
››. /
Capacity
››/ 7
==
››8 :
$num
››; <
)
››< =
{
œœ 
return
 
-
 
$num
 
;
 
}
 
return
   
buffer
   
.
   
ForEachByte
   %
(
  % &
	fromIndex
  & /
,
  / 0
toIndex
  1 8
-
  9 :
	fromIndex
  ; D
,
  D E
new
  F I
IndexOfProcessor
  J Z
(
  Z [
value
  [ `
)
  ` a
)
  a b
;
  b c
}
¡¡ 	
static
££ 
int
££ 
LastIndexOf
££ 
(
££ 
IByteBuffer
££ *
buffer
££+ 1
,
££1 2
int
££3 6
	fromIndex
££7 @
,
££@ A
int
££B E
toIndex
££F M
,
££M N
byte
££O S
value
££T Y
)
££Y Z
{
¤¤ 	
	fromIndex
¥¥ 
=
¥¥ 
Math
¥¥ 
.
¥¥ 
Min
¥¥  
(
¥¥  !
	fromIndex
¥¥! *
,
¥¥* +
buffer
¥¥, 2
.
¥¥2 3
Capacity
¥¥3 ;
)
¥¥; <
;
¥¥< =
if
¦¦ 
(
¦¦ 
	fromIndex
¦¦ 
<
¦¦ 
$num
¦¦ 
||
¦¦  
buffer
¦¦! '
.
¦¦' (
Capacity
¦¦( 0
==
¦¦1 3
$num
¦¦4 5
)
¦¦5 6
{
§§ 
return
¨¨ 
-
¨¨ 
$num
¨¨ 
;
¨¨ 
}
©© 
return
«« 
buffer
«« 
.
«« 
ForEachByteDesc
«« )
(
««) *
toIndex
««* 1
,
««1 2
	fromIndex
««3 <
-
««= >
toIndex
««? F
,
««F G
new
««H K
IndexOfProcessor
««L \
(
««\ ]
value
««] b
)
««b c
)
««c d
;
««d e
}
¬¬ 	
public
®® 
static
®® 
IByteBuffer
®® !
	WriteUtf8
®®" +
(
®®+ ,"
IByteBufferAllocator
®®, @
alloc
®®A F
,
®®F G
ICharSequence
®®H U
seq
®®V Y
)
®®Y Z
{
¯¯ 	
IByteBuffer
±± 
buf
±± 
=
±± 
alloc
±± #
.
±±# $
Buffer
±±$ *
(
±±* +
Utf8MaxBytes
±±+ 7
(
±±7 8
seq
±±8 ;
)
±±; <
)
±±< =
;
±±= >
	WriteUtf8
²² 
(
²² 
buf
²² 
,
²² 
seq
²² 
)
²² 
;
²²  
return
³³ 
buf
³³ 
;
³³ 
}
´´ 	
public
¶¶ 
static
¶¶ 
int
¶¶ 
	WriteUtf8
¶¶ #
(
¶¶# $
IByteBuffer
¶¶$ /
buf
¶¶0 3
,
¶¶3 4
ICharSequence
¶¶5 B
seq
¶¶C F
)
¶¶F G
=>
¶¶H J!
ReserveAndWriteUtf8
¶¶K ^
(
¶¶^ _
buf
¶¶_ b
,
¶¶b c
seq
¶¶d g
,
¶¶g h
Utf8MaxBytes
¶¶i u
(
¶¶u v
seq
¶¶v y
)
¶¶y z
)
¶¶z {
;
¶¶{ |
public
¸¸ 
static
¸¸ 
int
¸¸ !
ReserveAndWriteUtf8
¸¸ -
(
¸¸- .
IByteBuffer
¸¸. 9
buf
¸¸: =
,
¸¸= >
ICharSequence
¸¸? L
seq
¸¸M P
,
¸¸P Q
int
¸¸R U
reserveBytes
¸¸V b
)
¸¸b c
{
¹¹ 	
for
ºº 
(
ºº 
;
ºº 
;
ºº 
)
ºº 
{
»» 
if
¼¼ 
(
¼¼ 
buf
¼¼ 
is
¼¼  
AbstractByteBuffer
¼¼ -
byteBuf
¼¼. 5
)
¼¼5 6
{
½½ 
byteBuf
¾¾ 
.
¾¾ 
EnsureWritable0
¾¾ +
(
¾¾+ ,
reserveBytes
¾¾, 8
)
¾¾8 9
;
¾¾9 :
int
¿¿ 
written
¿¿ 
=
¿¿  !
	WriteUtf8
¿¿" +
(
¿¿+ ,
byteBuf
¿¿, 3
,
¿¿3 4
byteBuf
¿¿5 <
.
¿¿< =
WriterIndex
¿¿= H
,
¿¿H I
seq
¿¿J M
,
¿¿M N
seq
¿¿O R
.
¿¿R S
Count
¿¿S X
)
¿¿X Y
;
¿¿Y Z
byteBuf
ÀÀ 
.
ÀÀ 
SetWriterIndex
ÀÀ *
(
ÀÀ* +
byteBuf
ÀÀ+ 2
.
ÀÀ2 3
WriterIndex
ÀÀ3 >
+
ÀÀ? @
written
ÀÀA H
)
ÀÀH I
;
ÀÀI J
return
ÁÁ 
written
ÁÁ "
;
ÁÁ" #
}
ÂÂ 
else
ÃÃ 
if
ÃÃ 
(
ÃÃ 
buf
ÃÃ 
is
ÃÃ 
WrappedByteBuffer
ÃÃ  1
)
ÃÃ1 2
{
ÄÄ 
buf
ÆÆ 
=
ÆÆ 
buf
ÆÆ 
.
ÆÆ 
Unwrap
ÆÆ $
(
ÆÆ$ %
)
ÆÆ% &
;
ÆÆ& '
}
ÇÇ 
else
ÈÈ 
{
ÉÉ 
byte
ÊÊ 
[
ÊÊ 
]
ÊÊ 
bytes
ÊÊ  
=
ÊÊ! "
Encoding
ÊÊ# +
.
ÊÊ+ ,
UTF8
ÊÊ, 0
.
ÊÊ0 1
GetBytes
ÊÊ1 9
(
ÊÊ9 :
seq
ÊÊ: =
.
ÊÊ= >
ToString
ÊÊ> F
(
ÊÊF G
)
ÊÊG H
)
ÊÊH I
;
ÊÊI J
buf
ËË 
.
ËË 

WriteBytes
ËË "
(
ËË" #
bytes
ËË# (
)
ËË( )
;
ËË) *
return
ÌÌ 
bytes
ÌÌ  
.
ÌÌ  !
Length
ÌÌ! '
;
ÌÌ' (
}
ÍÍ 
}
ÎÎ 
}
ÏÏ 	
internal
ÒÒ 
static
ÒÒ 
int
ÒÒ 
	WriteUtf8
ÒÒ %
(
ÒÒ% & 
AbstractByteBuffer
ÒÒ& 8
buffer
ÒÒ9 ?
,
ÒÒ? @
int
ÒÒA D
writerIndex
ÒÒE P
,
ÒÒP Q
ICharSequence
ÒÒR _
value
ÒÒ` e
,
ÒÒe f
int
ÒÒg j
len
ÒÒk n
)
ÒÒn o
{
ÓÓ 	
int
ÔÔ 
oldWriterIndex
ÔÔ 
=
ÔÔ  
writerIndex
ÔÔ! ,
;
ÔÔ, -
for
ØØ 
(
ØØ 
int
ØØ 
i
ØØ 
=
ØØ 
$num
ØØ 
;
ØØ 
i
ØØ 
<
ØØ 
len
ØØ  #
;
ØØ# $
i
ØØ% &
++
ØØ& (
)
ØØ( )
{
ÙÙ 
char
ÚÚ 
c
ÚÚ 
=
ÚÚ 
value
ÚÚ 
[
ÚÚ 
i
ÚÚ  
]
ÚÚ  !
;
ÚÚ! "
if
ÛÛ 
(
ÛÛ 
c
ÛÛ 
<
ÛÛ 
$num
ÛÛ 
)
ÛÛ 
{
ÜÜ 
buffer
İİ 
.
İİ 
_SetByte
İİ #
(
İİ# $
writerIndex
İİ$ /
++
İİ/ 1
,
İİ1 2
(
İİ3 4
byte
İİ4 8
)
İİ8 9
c
İİ9 :
)
İİ: ;
;
İİ; <
}
ŞŞ 
else
ßß 
if
ßß 
(
ßß 
c
ßß 
<
ßß 
$num
ßß "
)
ßß" #
{
àà 
buffer
áá 
.
áá 
_SetByte
áá #
(
áá# $
writerIndex
áá$ /
++
áá/ 1
,
áá1 2
(
áá3 4
byte
áá4 8
)
áá8 9
(
áá9 :
$num
áá: >
|
áá? @
(
ááA B
c
ááB C
>>
ááD F
$num
ááG H
)
ááH I
)
ááI J
)
ááJ K
;
ááK L
buffer
ââ 
.
ââ 
_SetByte
ââ #
(
ââ# $
writerIndex
ââ$ /
++
ââ/ 1
,
ââ1 2
(
ââ3 4
byte
ââ4 8
)
ââ8 9
(
ââ9 :
$num
ââ: >
|
ââ? @
(
ââA B
c
ââB C
&
ââD E
$num
ââF J
)
ââJ K
)
ââK L
)
ââL M
;
ââM N
}
ãã 
else
ää 
if
ää 
(
ää 
char
ää 
.
ää 
IsSurrogate
ää )
(
ää) *
c
ää* +
)
ää+ ,
)
ää, -
{
åå 
if
ææ 
(
ææ 
!
ææ 
char
ææ 
.
ææ 
IsHighSurrogate
ææ -
(
ææ- .
c
ææ. /
)
ææ/ 0
)
ææ0 1
{
çç 
buffer
èè 
.
èè 
_SetByte
èè '
(
èè' (
writerIndex
èè( 3
++
èè3 5
,
èè5 6
WriteUtfUnknown
èè7 F
)
èèF G
;
èèG H
continue
éé  
;
éé  !
}
êê 
char
ëë 
c2
ëë 
;
ëë 
try
ìì 
{
íí 
c2
ññ 
=
ññ 
value
ññ "
[
ññ" #
++
ññ# %
i
ññ% &
]
ññ& '
;
ññ' (
}
òò 
catch
óó 
(
óó &
IndexOutOfRangeException
óó 3
)
óó3 4
{
ôô 
buffer
õõ 
.
õõ 
_SetByte
õõ '
(
õõ' (
writerIndex
õõ( 3
++
õõ3 5
,
õõ5 6
WriteUtfUnknown
õõ7 F
)
õõF G
;
õõG H
break
öö 
;
öö 
}
÷÷ 
if
øø 
(
øø 
!
øø 
char
øø 
.
øø 
IsLowSurrogate
øø ,
(
øø, -
c2
øø- /
)
øø/ 0
)
øø0 1
{
ùù 
buffer
úú 
.
úú 
_SetByte
úú '
(
úú' (
writerIndex
úú( 3
++
úú3 5
,
úú5 6
WriteUtfUnknown
úú7 F
)
úúF G
;
úúG H
buffer
ûû 
.
ûû 
_SetByte
ûû '
(
ûû' (
writerIndex
ûû( 3
++
ûû3 5
,
ûû5 6
char
ûû7 ;
.
ûû; <
IsHighSurrogate
ûû< K
(
ûûK L
c2
ûûL N
)
ûûN O
?
ûûP Q
WriteUtfUnknown
ûûR a
:
ûûb c
c2
ûûd f
)
ûûf g
;
ûûg h
continue
üü  
;
üü  !
}
ıı 
int
şş 
	codePoint
şş !
=
şş" #
CharUtil
şş$ ,
.
şş, -
ToCodePoint
şş- 8
(
şş8 9
c
şş9 :
,
şş: ;
c2
şş< >
)
şş> ?
;
şş? @
buffer
€€ 
.
€€ 
_SetByte
€€ #
(
€€# $
writerIndex
€€$ /
++
€€/ 1
,
€€1 2
(
€€3 4
byte
€€4 8
)
€€8 9
(
€€9 :
$num
€€: >
|
€€? @
(
€€A B
	codePoint
€€B K
>>
€€L N
$num
€€O Q
)
€€Q R
)
€€R S
)
€€S T
;
€€T U
buffer
 
.
 
_SetByte
 #
(
# $
writerIndex
$ /
++
/ 1
,
1 2
(
3 4
byte
4 8
)
8 9
(
9 :
$num
: >
|
? @
(
A B
(
B C
	codePoint
C L
>>
M O
$num
P R
)
R S
&
T U
$num
V Z
)
Z [
)
[ \
)
\ ]
;
] ^
buffer
‚‚ 
.
‚‚ 
_SetByte
‚‚ #
(
‚‚# $
writerIndex
‚‚$ /
++
‚‚/ 1
,
‚‚1 2
(
‚‚3 4
byte
‚‚4 8
)
‚‚8 9
(
‚‚9 :
$num
‚‚: >
|
‚‚? @
(
‚‚A B
(
‚‚B C
	codePoint
‚‚C L
>>
‚‚M O
$num
‚‚P Q
)
‚‚Q R
&
‚‚S T
$num
‚‚U Y
)
‚‚Y Z
)
‚‚Z [
)
‚‚[ \
;
‚‚\ ]
buffer
ƒƒ 
.
ƒƒ 
_SetByte
ƒƒ #
(
ƒƒ# $
writerIndex
ƒƒ$ /
++
ƒƒ/ 1
,
ƒƒ1 2
(
ƒƒ3 4
byte
ƒƒ4 8
)
ƒƒ8 9
(
ƒƒ9 :
$num
ƒƒ: >
|
ƒƒ? @
(
ƒƒA B
	codePoint
ƒƒB K
&
ƒƒL M
$num
ƒƒN R
)
ƒƒR S
)
ƒƒS T
)
ƒƒT U
;
ƒƒU V
}
„„ 
else
…… 
{
†† 
buffer
‡‡ 
.
‡‡ 
_SetByte
‡‡ #
(
‡‡# $
writerIndex
‡‡$ /
++
‡‡/ 1
,
‡‡1 2
(
‡‡3 4
byte
‡‡4 8
)
‡‡8 9
(
‡‡9 :
$num
‡‡: >
|
‡‡? @
(
‡‡A B
c
‡‡B C
>>
‡‡D F
$num
‡‡G I
)
‡‡I J
)
‡‡J K
)
‡‡K L
;
‡‡L M
buffer
ˆˆ 
.
ˆˆ 
_SetByte
ˆˆ #
(
ˆˆ# $
writerIndex
ˆˆ$ /
++
ˆˆ/ 1
,
ˆˆ1 2
(
ˆˆ3 4
byte
ˆˆ4 8
)
ˆˆ8 9
(
ˆˆ9 :
$num
ˆˆ: >
|
ˆˆ? @
(
ˆˆA B
(
ˆˆB C
c
ˆˆC D
>>
ˆˆE G
$num
ˆˆH I
)
ˆˆI J
&
ˆˆK L
$num
ˆˆM Q
)
ˆˆQ R
)
ˆˆR S
)
ˆˆS T
;
ˆˆT U
buffer
‰‰ 
.
‰‰ 
_SetByte
‰‰ #
(
‰‰# $
writerIndex
‰‰$ /
++
‰‰/ 1
,
‰‰1 2
(
‰‰3 4
byte
‰‰4 8
)
‰‰8 9
(
‰‰9 :
$num
‰‰: >
|
‰‰? @
(
‰‰A B
c
‰‰B C
&
‰‰D E
$num
‰‰F J
)
‰‰J K
)
‰‰K L
)
‰‰L M
;
‰‰M N
}
ŠŠ 
}
‹‹ 
return
 
writerIndex
 
-
  
oldWriterIndex
! /
;
/ 0
}
 	
public
 
static
 
IByteBuffer
 !
	WriteUtf8
" +
(
+ ,"
IByteBufferAllocator
, @
alloc
A F
,
F G
string
H N
value
O T
)
T U
{
‘‘ 	
IByteBuffer
““ 
buf
““ 
=
““ 
alloc
““ #
.
““# $
Buffer
““$ *
(
““* +
Utf8MaxBytes
““+ 7
(
““7 8
value
““8 =
)
““= >
)
““> ?
;
““? @
	WriteUtf8
”” 
(
”” 
buf
”” 
,
”” 
value
””  
)
””  !
;
””! "
return
•• 
buf
•• 
;
•• 
}
–– 	
public
˜˜ 
static
˜˜ 
int
˜˜ 
	WriteUtf8
˜˜ #
(
˜˜# $
IByteBuffer
˜˜$ /
buf
˜˜0 3
,
˜˜3 4
string
˜˜5 ;
seq
˜˜< ?
)
˜˜? @
=>
˜˜A C!
ReserveAndWriteUtf8
˜˜D W
(
˜˜W X
buf
˜˜X [
,
˜˜[ \
seq
˜˜] `
,
˜˜` a
Utf8MaxBytes
˜˜b n
(
˜˜n o
seq
˜˜o r
)
˜˜r s
)
˜˜s t
;
˜˜t u
public
¡¡ 
static
¡¡ 
int
¡¡ !
ReserveAndWriteUtf8
¡¡ -
(
¡¡- .
IByteBuffer
¡¡. 9
buf
¡¡: =
,
¡¡= >
string
¡¡? E
value
¡¡F K
,
¡¡K L
int
¡¡M P
reserveBytes
¡¡Q ]
)
¡¡] ^
{
¢¢ 	
for
££ 
(
££ 
;
££ 
;
££ 
)
££ 
{
¤¤ 
if
¥¥ 
(
¥¥ 
buf
¥¥ 
is
¥¥  
AbstractByteBuffer
¥¥ -
byteBuf
¥¥. 5
)
¥¥5 6
{
¦¦ 
byteBuf
§§ 
.
§§ 
EnsureWritable0
§§ +
(
§§+ ,
reserveBytes
§§, 8
)
§§8 9
;
§§9 :
int
¨¨ 
written
¨¨ 
=
¨¨  !
	WriteUtf8
¨¨" +
(
¨¨+ ,
byteBuf
¨¨, 3
,
¨¨3 4
byteBuf
¨¨5 <
.
¨¨< =
WriterIndex
¨¨= H
,
¨¨H I
value
¨¨J O
,
¨¨O P
value
¨¨Q V
.
¨¨V W
Length
¨¨W ]
)
¨¨] ^
;
¨¨^ _
byteBuf
©© 
.
©© 
SetWriterIndex
©© *
(
©©* +
byteBuf
©©+ 2
.
©©2 3
WriterIndex
©©3 >
+
©©? @
written
©©A H
)
©©H I
;
©©I J
return
ªª 
written
ªª "
;
ªª" #
}
«« 
else
¬¬ 
if
¬¬ 
(
¬¬ 
buf
¬¬ 
is
¬¬ 
WrappedByteBuffer
¬¬  1
)
¬¬1 2
{
­­ 
buf
¯¯ 
=
¯¯ 
buf
¯¯ 
.
¯¯ 
Unwrap
¯¯ $
(
¯¯$ %
)
¯¯% &
;
¯¯& '
}
°° 
else
±± 
{
²² 
byte
³³ 
[
³³ 
]
³³ 
bytes
³³  
=
³³! "
Encoding
³³# +
.
³³+ ,
UTF8
³³, 0
.
³³0 1
GetBytes
³³1 9
(
³³9 :
value
³³: ?
)
³³? @
;
³³@ A
buf
´´ 
.
´´ 

WriteBytes
´´ "
(
´´" #
bytes
´´# (
)
´´( )
;
´´) *
return
µµ 
bytes
µµ  
.
µµ  !
Length
µµ! '
;
µµ' (
}
¶¶ 
}
·· 
}
¸¸ 	
internal
»» 
static
»» 
int
»» 
	WriteUtf8
»» %
(
»»% & 
AbstractByteBuffer
»»& 8
buffer
»»9 ?
,
»»? @
int
»»A D
writerIndex
»»E P
,
»»P Q
string
»»R X
value
»»Y ^
,
»»^ _
int
»»` c
len
»»d g
)
»»g h
{
¼¼ 	
int
½½ 
oldWriterIndex
½½ 
=
½½  
writerIndex
½½! ,
;
½½, -
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
i
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
i
ÁÁ 
<
ÁÁ 
len
ÁÁ  #
;
ÁÁ# $
i
ÁÁ% &
++
ÁÁ& (
)
ÁÁ( )
{
ÂÂ 
char
ÃÃ 
c
ÃÃ 
=
ÃÃ 
value
ÃÃ 
[
ÃÃ 
i
ÃÃ  
]
ÃÃ  !
;
ÃÃ! "
if
ÄÄ 
(
ÄÄ 
c
ÄÄ 
<
ÄÄ 
$num
ÄÄ 
)
ÄÄ 
{
ÅÅ 
buffer
ÆÆ 
.
ÆÆ 
_SetByte
ÆÆ #
(
ÆÆ# $
writerIndex
ÆÆ$ /
++
ÆÆ/ 1
,
ÆÆ1 2
(
ÆÆ3 4
byte
ÆÆ4 8
)
ÆÆ8 9
c
ÆÆ9 :
)
ÆÆ: ;
;
ÆÆ; <
}
ÇÇ 
else
ÈÈ 
if
ÈÈ 
(
ÈÈ 
c
ÈÈ 
<
ÈÈ 
$num
ÈÈ "
)
ÈÈ" #
{
ÉÉ 
buffer
ÊÊ 
.
ÊÊ 
_SetByte
ÊÊ #
(
ÊÊ# $
writerIndex
ÊÊ$ /
++
ÊÊ/ 1
,
ÊÊ1 2
(
ÊÊ3 4
byte
ÊÊ4 8
)
ÊÊ8 9
(
ÊÊ9 :
$num
ÊÊ: >
|
ÊÊ? @
(
ÊÊA B
c
ÊÊB C
>>
ÊÊD F
$num
ÊÊG H
)
ÊÊH I
)
ÊÊI J
)
ÊÊJ K
;
ÊÊK L
buffer
ËË 
.
ËË 
_SetByte
ËË #
(
ËË# $
writerIndex
ËË$ /
++
ËË/ 1
,
ËË1 2
(
ËË3 4
byte
ËË4 8
)
ËË8 9
(
ËË9 :
$num
ËË: >
|
ËË? @
(
ËËA B
c
ËËB C
&
ËËD E
$num
ËËF J
)
ËËJ K
)
ËËK L
)
ËËL M
;
ËËM N
}
ÌÌ 
else
ÍÍ 
if
ÍÍ 
(
ÍÍ 
char
ÍÍ 
.
ÍÍ 
IsSurrogate
ÍÍ )
(
ÍÍ) *
c
ÍÍ* +
)
ÍÍ+ ,
)
ÍÍ, -
{
ÎÎ 
if
ÏÏ 
(
ÏÏ 
!
ÏÏ 
char
ÏÏ 
.
ÏÏ 
IsHighSurrogate
ÏÏ -
(
ÏÏ- .
c
ÏÏ. /
)
ÏÏ/ 0
)
ÏÏ0 1
{
ĞĞ 
buffer
ÑÑ 
.
ÑÑ 
_SetByte
ÑÑ '
(
ÑÑ' (
writerIndex
ÑÑ( 3
++
ÑÑ3 5
,
ÑÑ5 6
WriteUtfUnknown
ÑÑ7 F
)
ÑÑF G
;
ÑÑG H
continue
ÒÒ  
;
ÒÒ  !
}
ÓÓ 
char
ÔÔ 
c2
ÔÔ 
;
ÔÔ 
try
ÕÕ 
{
ÖÖ 
c2
ÚÚ 
=
ÚÚ 
value
ÚÚ "
[
ÚÚ" #
++
ÚÚ# %
i
ÚÚ% &
]
ÚÚ& '
;
ÚÚ' (
}
ÛÛ 
catch
ÜÜ 
(
ÜÜ &
IndexOutOfRangeException
ÜÜ 3
)
ÜÜ3 4
{
İİ 
buffer
ŞŞ 
.
ŞŞ 
_SetByte
ŞŞ '
(
ŞŞ' (
writerIndex
ŞŞ( 3
++
ŞŞ3 5
,
ŞŞ5 6
WriteUtfUnknown
ŞŞ7 F
)
ŞŞF G
;
ŞŞG H
break
ßß 
;
ßß 
}
àà 
if
áá 
(
áá 
!
áá 
char
áá 
.
áá 
IsLowSurrogate
áá ,
(
áá, -
c2
áá- /
)
áá/ 0
)
áá0 1
{
ââ 
buffer
ãã 
.
ãã 
_SetByte
ãã '
(
ãã' (
writerIndex
ãã( 3
++
ãã3 5
,
ãã5 6
WriteUtfUnknown
ãã7 F
)
ããF G
;
ããG H
buffer
ää 
.
ää 
_SetByte
ää '
(
ää' (
writerIndex
ää( 3
++
ää3 5
,
ää5 6
char
ää7 ;
.
ää; <
IsHighSurrogate
ää< K
(
ääK L
c2
ääL N
)
ääN O
?
ääP Q
WriteUtfUnknown
ääR a
:
ääb c
c2
ääd f
)
ääf g
;
ääg h
continue
åå  
;
åå  !
}
ææ 
int
çç 
	codePoint
çç !
=
çç" #
CharUtil
çç$ ,
.
çç, -
ToCodePoint
çç- 8
(
çç8 9
c
çç9 :
,
çç: ;
c2
çç< >
)
çç> ?
;
çç? @
buffer
éé 
.
éé 
_SetByte
éé #
(
éé# $
writerIndex
éé$ /
++
éé/ 1
,
éé1 2
(
éé3 4
byte
éé4 8
)
éé8 9
(
éé9 :
$num
éé: >
|
éé? @
(
ééA B
	codePoint
ééB K
>>
ééL N
$num
ééO Q
)
ééQ R
)
ééR S
)
ééS T
;
ééT U
buffer
êê 
.
êê 
_SetByte
êê #
(
êê# $
writerIndex
êê$ /
++
êê/ 1
,
êê1 2
(
êê3 4
byte
êê4 8
)
êê8 9
(
êê9 :
$num
êê: >
|
êê? @
(
êêA B
(
êêB C
	codePoint
êêC L
>>
êêM O
$num
êêP R
)
êêR S
&
êêT U
$num
êêV Z
)
êêZ [
)
êê[ \
)
êê\ ]
;
êê] ^
buffer
ëë 
.
ëë 
_SetByte
ëë #
(
ëë# $
writerIndex
ëë$ /
++
ëë/ 1
,
ëë1 2
(
ëë3 4
byte
ëë4 8
)
ëë8 9
(
ëë9 :
$num
ëë: >
|
ëë? @
(
ëëA B
(
ëëB C
	codePoint
ëëC L
>>
ëëM O
$num
ëëP Q
)
ëëQ R
&
ëëS T
$num
ëëU Y
)
ëëY Z
)
ëëZ [
)
ëë[ \
;
ëë\ ]
buffer
ìì 
.
ìì 
_SetByte
ìì #
(
ìì# $
writerIndex
ìì$ /
++
ìì/ 1
,
ìì1 2
(
ìì3 4
byte
ìì4 8
)
ìì8 9
(
ìì9 :
$num
ìì: >
|
ìì? @
(
ììA B
	codePoint
ììB K
&
ììL M
$num
ììN R
)
ììR S
)
ììS T
)
ììT U
;
ììU V
}
íí 
else
îî 
{
ïï 
buffer
ğğ 
.
ğğ 
_SetByte
ğğ #
(
ğğ# $
writerIndex
ğğ$ /
++
ğğ/ 1
,
ğğ1 2
(
ğğ3 4
byte
ğğ4 8
)
ğğ8 9
(
ğğ9 :
$num
ğğ: >
|
ğğ? @
(
ğğA B
c
ğğB C
>>
ğğD F
$num
ğğG I
)
ğğI J
)
ğğJ K
)
ğğK L
;
ğğL M
buffer
ññ 
.
ññ 
_SetByte
ññ #
(
ññ# $
writerIndex
ññ$ /
++
ññ/ 1
,
ññ1 2
(
ññ3 4
byte
ññ4 8
)
ññ8 9
(
ññ9 :
$num
ññ: >
|
ññ? @
(
ññA B
(
ññB C
c
ññC D
>>
ññE G
$num
ññH I
)
ññI J
&
ññK L
$num
ññM Q
)
ññQ R
)
ññR S
)
ññS T
;
ññT U
buffer
òò 
.
òò 
_SetByte
òò #
(
òò# $
writerIndex
òò$ /
++
òò/ 1
,
òò1 2
(
òò3 4
byte
òò4 8
)
òò8 9
(
òò9 :
$num
òò: >
|
òò? @
(
òòA B
c
òòB C
&
òòD E
$num
òòF J
)
òòJ K
)
òòK L
)
òòL M
;
òòM N
}
óó 
}
ôô 
return
öö 
writerIndex
öö 
-
öö  
oldWriterIndex
öö! /
;
öö/ 0
}
÷÷ 	
internal
ùù 
static
ùù 
int
ùù 
Utf8MaxBytes
ùù (
(
ùù( )
ICharSequence
ùù) 6
seq
ùù7 :
)
ùù: ;
=>
ùù< >
Utf8MaxBytes
ùù? K
(
ùùK L
seq
ùùL O
.
ùùO P
Count
ùùP U
)
ùùU V
;
ùùV W
public
ûû 
static
ûû 
int
ûû 
Utf8MaxBytes
ûû &
(
ûû& '
string
ûû' -
seq
ûû. 1
)
ûû1 2
=>
ûû3 5
Utf8MaxBytes
ûû6 B
(
ûûB C
seq
ûûC F
.
ûûF G
Length
ûûG M
)
ûûM N
;
ûûN O
internal
ıı 
static
ıı 
int
ıı 
Utf8MaxBytes
ıı (
(
ıı( )
int
ıı) ,
	seqLength
ıı- 6
)
ıı6 7
=>
ıı8 :
	seqLength
ıı; D
*
ııE F!
MaxBytesPerCharUtf8
ııG Z
;
ııZ [
internal
ÿÿ 
static
ÿÿ 
int
ÿÿ 
	Utf8Bytes
ÿÿ %
(
ÿÿ% &
string
ÿÿ& ,
seq
ÿÿ- 0
)
ÿÿ0 1
{
€€ 	
int
 
	seqLength
 
=
 
seq
 
.
  
Length
  &
;
& '
int
‚‚ 
i
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
while
„„ 
(
„„ 
i
„„ 
<
„„ 
	seqLength
„„  
&&
„„! #
seq
„„$ '
[
„„' (
i
„„( )
]
„„) *
<
„„+ ,
$num
„„- 1
)
„„1 2
{
…… 
++
†† 
i
†† 
;
†† 
}
‡‡ 
return
‰‰ 
i
‰‰ 
<
‰‰ 
	seqLength
‰‰  
?
‰‰! "
i
‰‰# $
+
‰‰% &
	Utf8Bytes
‰‰' 0
(
‰‰0 1
seq
‰‰1 4
,
‰‰4 5
i
‰‰6 7
,
‰‰7 8
	seqLength
‰‰9 B
)
‰‰B C
:
‰‰D E
i
‰‰F G
;
‰‰G H
}
ŠŠ 	
static
ŒŒ 
int
ŒŒ 
	Utf8Bytes
ŒŒ 
(
ŒŒ 
string
ŒŒ #
seq
ŒŒ$ '
,
ŒŒ' (
int
ŒŒ) ,
start
ŒŒ- 2
,
ŒŒ2 3
int
ŒŒ4 7
length
ŒŒ8 >
)
ŒŒ> ?
{
 	
int
 
encodedLength
 
=
 
$num
  !
;
! "
for
 
(
 
int
 
i
 
=
 
start
 
;
 
i
  !
<
" #
length
$ *
;
* +
i
, -
++
- /
)
/ 0
{
 
char
‘‘ 
c
‘‘ 
=
‘‘ 
seq
‘‘ 
[
‘‘ 
i
‘‘ 
]
‘‘ 
;
‘‘  
if
““ 
(
““ 
c
““ 
<
““ 
$num
““ 
)
““ 
{
”” 
encodedLength
–– !
+=
––" $
(
––% &
(
––& '
$num
––' +
-
––, -
c
––. /
)
––/ 0
.
––0 1
RightUShift
––1 <
(
––< =
$num
––= ?
)
––? @
)
––@ A
+
––B C
$num
––D E
;
––E F
}
—— 
else
˜˜ 
if
˜˜ 
(
˜˜ 
char
˜˜ 
.
˜˜ 
IsSurrogate
˜˜ )
(
˜˜) *
c
˜˜* +
)
˜˜+ ,
)
˜˜, -
{
™™ 
if
šš 
(
šš 
!
šš 
char
šš 
.
šš 
IsHighSurrogate
šš -
(
šš- .
c
šš. /
)
šš/ 0
)
šš0 1
{
›› 
encodedLength
œœ %
++
œœ% '
;
œœ' (
continue
  
;
  !
}
ŸŸ 
char
   
c2
   
;
   
try
¡¡ 
{
¢¢ 
c2
¥¥ 
=
¥¥ 
seq
¥¥  
[
¥¥  !
++
¥¥! #
i
¥¥# $
]
¥¥$ %
;
¥¥% &
}
¦¦ 
catch
§§ 
(
§§ &
IndexOutOfRangeException
§§ 3
)
§§3 4
{
¨¨ 
encodedLength
©© %
++
©©% '
;
©©' (
break
«« 
;
«« 
}
¬¬ 
if
­­ 
(
­­ 
!
­­ 
char
­­ 
.
­­ 
IsLowSurrogate
­­ ,
(
­­, -
c2
­­- /
)
­­/ 0
)
­­0 1
{
®® 
encodedLength
°° %
+=
°°& (
$num
°°) *
;
°°* +
continue
±±  
;
±±  !
}
²² 
encodedLength
´´ !
+=
´´" $
$num
´´% &
;
´´& '
}
µµ 
else
¶¶ 
{
·· 
encodedLength
¸¸ !
+=
¸¸" $
$num
¸¸% &
;
¸¸& '
}
¹¹ 
}
ºº 
return
»» 
encodedLength
»»  
;
»»  !
}
¼¼ 	
public
¾¾ 
static
¾¾ 
IByteBuffer
¾¾ !

WriteAscii
¾¾" ,
(
¾¾, -"
IByteBufferAllocator
¾¾- A
alloc
¾¾B G
,
¾¾G H
ICharSequence
¾¾I V
seq
¾¾W Z
)
¾¾Z [
{
¿¿ 	
IByteBuffer
ÁÁ 
buf
ÁÁ 
=
ÁÁ 
alloc
ÁÁ #
.
ÁÁ# $
Buffer
ÁÁ$ *
(
ÁÁ* +
seq
ÁÁ+ .
.
ÁÁ. /
Count
ÁÁ/ 4
)
ÁÁ4 5
;
ÁÁ5 6

WriteAscii
ÂÂ 
(
ÂÂ 
buf
ÂÂ 
,
ÂÂ 
seq
ÂÂ 
)
ÂÂ  
;
ÂÂ  !
return
ÃÃ 
buf
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
public
ÆÆ 
static
ÆÆ 
int
ÆÆ 

WriteAscii
ÆÆ $
(
ÆÆ$ %
IByteBuffer
ÆÆ% 0
buf
ÆÆ1 4
,
ÆÆ4 5
ICharSequence
ÆÆ6 C
seq
ÆÆD G
)
ÆÆG H
{
ÇÇ 	
int
ÉÉ 
len
ÉÉ 
=
ÉÉ 
seq
ÉÉ 
.
ÉÉ 
Count
ÉÉ 
;
ÉÉ  
if
ÊÊ 
(
ÊÊ 
seq
ÊÊ 
is
ÊÊ 
AsciiString
ÊÊ "
asciiString
ÊÊ# .
)
ÊÊ. /
{
ËË 
buf
ÌÌ 
.
ÌÌ 

WriteBytes
ÌÌ 
(
ÌÌ 
asciiString
ÌÌ *
.
ÌÌ* +
Array
ÌÌ+ 0
,
ÌÌ0 1
asciiString
ÌÌ2 =
.
ÌÌ= >
Offset
ÌÌ> D
,
ÌÌD E
len
ÌÌF I
)
ÌÌI J
;
ÌÌJ K
}
ÍÍ 
else
ÎÎ 
{
ÏÏ 
for
ĞĞ 
(
ĞĞ 
;
ĞĞ 
;
ĞĞ 
)
ĞĞ 
{
ÑÑ 
if
ÒÒ 
(
ÒÒ 
buf
ÒÒ 
is
ÒÒ  
AbstractByteBuffer
ÒÒ 1
byteBuf
ÒÒ2 9
)
ÒÒ9 :
{
ÓÓ 
byteBuf
ÔÔ 
.
ÔÔ  
EnsureWritable0
ÔÔ  /
(
ÔÔ/ 0
len
ÔÔ0 3
)
ÔÔ3 4
;
ÔÔ4 5
int
ÕÕ 
written
ÕÕ #
=
ÕÕ$ %

WriteAscii
ÕÕ& 0
(
ÕÕ0 1
byteBuf
ÕÕ1 8
,
ÕÕ8 9
byteBuf
ÕÕ: A
.
ÕÕA B
WriterIndex
ÕÕB M
,
ÕÕM N
seq
ÕÕO R
,
ÕÕR S
len
ÕÕT W
)
ÕÕW X
;
ÕÕX Y
byteBuf
ÖÖ 
.
ÖÖ  
SetWriterIndex
ÖÖ  .
(
ÖÖ. /
byteBuf
ÖÖ/ 6
.
ÖÖ6 7
WriterIndex
ÖÖ7 B
+
ÖÖC D
written
ÖÖE L
)
ÖÖL M
;
ÖÖM N
return
×× 
written
×× &
;
××& '
}
ØØ 
else
ÙÙ 
if
ÙÙ 
(
ÙÙ 
buf
ÙÙ  
is
ÙÙ! #
WrappedByteBuffer
ÙÙ$ 5
)
ÙÙ5 6
{
ÚÚ 
buf
ÜÜ 
=
ÜÜ 
buf
ÜÜ !
.
ÜÜ! "
Unwrap
ÜÜ" (
(
ÜÜ( )
)
ÜÜ) *
;
ÜÜ* +
}
İİ 
else
ŞŞ 
{
ßß 
byte
àà 
[
àà 
]
àà 
bytes
àà $
=
àà% &
Encoding
àà' /
.
àà/ 0
ASCII
àà0 5
.
àà5 6
GetBytes
àà6 >
(
àà> ?
seq
àà? B
.
ààB C
ToString
ààC K
(
ààK L
)
ààL M
)
ààM N
;
ààN O
buf
áá 
.
áá 

WriteBytes
áá &
(
áá& '
bytes
áá' ,
)
áá, -
;
áá- .
return
ââ 
bytes
ââ $
.
ââ$ %
Length
ââ% +
;
ââ+ ,
}
ãã 
}
ää 
}
åå 
return
ææ 
len
ææ 
;
ææ 
}
çç 	
internal
êê 
static
êê 
int
êê 

WriteAscii
êê &
(
êê& ' 
AbstractByteBuffer
êê' 9
buffer
êê: @
,
êê@ A
int
êêB E
writerIndex
êêF Q
,
êêQ R
ICharSequence
êêS `
seq
êêa d
,
êêd e
int
êêf i
len
êêj m
)
êêm n
{
ëë 	
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
$num
îî 
;
îî 
i
îî 
<
îî 
len
îî  #
;
îî# $
i
îî% &
++
îî& (
)
îî( )
{
ïï 
buffer
ğğ 
.
ğğ 
_SetByte
ğğ 
(
ğğ  
writerIndex
ğğ  +
++
ğğ+ -
,
ğğ- .
AsciiString
ğğ/ :
.
ğğ: ;

CharToByte
ğğ; E
(
ğğE F
seq
ğğF I
[
ğğI J
i
ğğJ K
]
ğğK L
)
ğğL M
)
ğğM N
;
ğğN O
}
ññ 
return
òò 
len
òò 
;
òò 
}
óó 	
public
õõ 
static
õõ 
IByteBuffer
õõ !

WriteAscii
õõ" ,
(
õõ, -"
IByteBufferAllocator
õõ- A
alloc
õõB G
,
õõG H
string
õõI O
value
õõP U
)
õõU V
{
öö 	
IByteBuffer
øø 
buf
øø 
=
øø 
alloc
øø #
.
øø# $
Buffer
øø$ *
(
øø* +
value
øø+ 0
.
øø0 1
Length
øø1 7
)
øø7 8
;
øø8 9

WriteAscii
ùù 
(
ùù 
buf
ùù 
,
ùù 
value
ùù !
)
ùù! "
;
ùù" #
return
úú 
buf
úú 
;
úú 
}
ûû 	
public
ıı 
static
ıı 
int
ıı 

WriteAscii
ıı $
(
ıı$ %
IByteBuffer
ıı% 0
buf
ıı1 4
,
ıı4 5
string
ıı6 <
value
ıı= B
)
ııB C
{
şş 	
int
€€ 
len
€€ 
=
€€ 
value
€€ 
.
€€ 
Length
€€ "
;
€€" #
for
 
(
 
;
 
;
 
)
 
{
‚‚ 
if
ƒƒ 
(
ƒƒ 
buf
ƒƒ 
is
ƒƒ  
AbstractByteBuffer
ƒƒ -
byteBuf
ƒƒ. 5
)
ƒƒ5 6
{
„„ 
byteBuf
…… 
.
…… 
EnsureWritable0
…… +
(
……+ ,
len
……, /
)
……/ 0
;
……0 1
int
†† 
written
†† 
=
††  !

WriteAscii
††" ,
(
††, -
byteBuf
††- 4
,
††4 5
byteBuf
††6 =
.
††= >
WriterIndex
††> I
,
††I J
value
††K P
,
††P Q
len
††R U
)
††U V
;
††V W
byteBuf
‡‡ 
.
‡‡ 
SetWriterIndex
‡‡ *
(
‡‡* +
byteBuf
‡‡+ 2
.
‡‡2 3
WriterIndex
‡‡3 >
+
‡‡? @
written
‡‡A H
)
‡‡H I
;
‡‡I J
return
ˆˆ 
written
ˆˆ "
;
ˆˆ" #
}
‰‰ 
else
ŠŠ 
if
ŠŠ 
(
ŠŠ 
buf
ŠŠ 
is
ŠŠ 
WrappedByteBuffer
ŠŠ  1
)
ŠŠ1 2
{
‹‹ 
buf
 
=
 
buf
 
.
 
Unwrap
 $
(
$ %
)
% &
;
& '
}
 
else
 
{
 
byte
‘‘ 
[
‘‘ 
]
‘‘ 
bytes
‘‘  
=
‘‘! "
Encoding
‘‘# +
.
‘‘+ ,
ASCII
‘‘, 1
.
‘‘1 2
GetBytes
‘‘2 :
(
‘‘: ;
value
‘‘; @
)
‘‘@ A
;
‘‘A B
buf
’’ 
.
’’ 

WriteBytes
’’ "
(
’’" #
bytes
’’# (
)
’’( )
;
’’) *
return
““ 
bytes
““  
.
““  !
Length
““! '
;
““' (
}
”” 
}
•• 
}
–– 	
internal
˜˜ 
static
˜˜ 
int
˜˜ 

WriteAscii
˜˜ &
(
˜˜& ' 
AbstractByteBuffer
˜˜' 9
buffer
˜˜: @
,
˜˜@ A
int
˜˜B E
writerIndex
˜˜F Q
,
˜˜Q R
string
˜˜S Y
value
˜˜Z _
,
˜˜_ `
int
˜˜a d
len
˜˜e h
)
˜˜h i
{
™™ 	
for
œœ 
(
œœ 
int
œœ 
i
œœ 
=
œœ 
$num
œœ 
;
œœ 
i
œœ 
<
œœ 
len
œœ  #
;
œœ# $
i
œœ% &
++
œœ& (
)
œœ( )
{
 
buffer
 
.
 
_SetByte
 
(
  
writerIndex
  +
++
+ -
,
- .
(
/ 0
byte
0 4
)
4 5
value
5 :
[
: ;
i
; <
]
< =
)
= >
;
> ?
}
ŸŸ 
return
   
len
   
;
   
}
¡¡ 	
public
«« 
static
«« 
IByteBuffer
«« !
EncodeString
««" .
(
««. /"
IByteBufferAllocator
««/ C
alloc
««D I
,
««I J
string
««K Q
src
««R U
,
««U V
Encoding
««W _
encoding
««` h
)
««h i
=>
««j l
EncodeString0
««m z
(
««z {
alloc««{ €
,««€ 
false««‚ ‡
,««‡ ˆ
src««‰ Œ
,««Œ 
encoding«« –
,««– —
$num««˜ ™
)««™ š
;««š ›
public
¶¶ 
static
¶¶ 
IByteBuffer
¶¶ !
EncodeString
¶¶" .
(
¶¶. /"
IByteBufferAllocator
¶¶/ C
alloc
¶¶D I
,
¶¶I J
string
¶¶K Q
src
¶¶R U
,
¶¶U V
Encoding
¶¶W _
encoding
¶¶` h
,
¶¶h i
int
¶¶j m
extraCapacity
¶¶n {
)
¶¶{ |
=>
¶¶} 
EncodeString0¶¶€ 
(¶¶ 
alloc¶¶ “
,¶¶“ ”
false¶¶• š
,¶¶š ›
src¶¶œ Ÿ
,¶¶Ÿ  
encoding¶¶¡ ©
,¶¶© ª
extraCapacity¶¶« ¸
)¶¶¸ ¹
;¶¶¹ º
internal
¸¸ 
static
¸¸ 
IByteBuffer
¸¸ #
EncodeString0
¸¸$ 1
(
¸¸1 2"
IByteBufferAllocator
¸¸2 F
alloc
¸¸G L
,
¸¸L M
bool
¸¸N R
enforceHeap
¸¸S ^
,
¸¸^ _
string
¸¸` f
src
¸¸g j
,
¸¸j k
Encoding
¸¸l t
encoding
¸¸u }
,
¸¸} ~
int¸¸ ‚
extraCapacity¸¸ƒ 
)¸¸ ‘
{
¹¹ 	
int
ºº 
length
ºº 
=
ºº 
encoding
ºº !
.
ºº! "
GetMaxByteCount
ºº" 1
(
ºº1 2
src
ºº2 5
.
ºº5 6
Length
ºº6 <
)
ºº< =
+
ºº> ?
extraCapacity
ºº@ M
;
ººM N
bool
»» 
release
»» 
=
»» 
true
»» 
;
»»  
IByteBuffer
½½ 
dst
½½ 
=
½½ 
enforceHeap
½½ )
?
½½* +
alloc
½½, 1
.
½½1 2

HeapBuffer
½½2 <
(
½½< =
length
½½= C
)
½½C D
:
½½E F
alloc
½½G L
.
½½L M
Buffer
½½M S
(
½½S T
length
½½T Z
)
½½Z [
;
½½[ \
Contract
¾¾ 
.
¾¾ 
Assert
¾¾ 
(
¾¾ 
dst
¾¾ 
.
¾¾  
HasArray
¾¾  (
,
¾¾( )
$str
¾¾* g
)
¾¾g h
;
¾¾h i
try
ÀÀ 
{
ÁÁ 
int
ÂÂ 
written
ÂÂ 
=
ÂÂ 
encoding
ÂÂ &
.
ÂÂ& '
GetBytes
ÂÂ' /
(
ÂÂ/ 0
src
ÂÂ0 3
,
ÂÂ3 4
$num
ÂÂ5 6
,
ÂÂ6 7
src
ÂÂ8 ;
.
ÂÂ; <
Length
ÂÂ< B
,
ÂÂB C
dst
ÂÂD G
.
ÂÂG H
Array
ÂÂH M
,
ÂÂM N
dst
ÂÂO R
.
ÂÂR S
ArrayOffset
ÂÂS ^
+
ÂÂ_ `
dst
ÂÂa d
.
ÂÂd e
WriterIndex
ÂÂe p
)
ÂÂp q
;
ÂÂq r
dst
ÃÃ 
.
ÃÃ 
SetWriterIndex
ÃÃ "
(
ÃÃ" #
dst
ÃÃ# &
.
ÃÃ& '
WriterIndex
ÃÃ' 2
+
ÃÃ3 4
written
ÃÃ5 <
)
ÃÃ< =
;
ÃÃ= >
release
ÄÄ 
=
ÄÄ 
false
ÄÄ 
;
ÄÄ  
return
ÆÆ 
dst
ÆÆ 
;
ÆÆ 
}
ÇÇ 
finally
ÈÈ 
{
ÉÉ 
if
ÊÊ 
(
ÊÊ 
release
ÊÊ 
)
ÊÊ 
{
ËË 
dst
ÌÌ 
.
ÌÌ 
Release
ÌÌ 
(
ÌÌ  
)
ÌÌ  !
;
ÌÌ! "
}
ÍÍ 
}
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
static
ÑÑ 
string
ÑÑ 
DecodeString
ÑÑ )
(
ÑÑ) *
IByteBuffer
ÑÑ* 5
src
ÑÑ6 9
,
ÑÑ9 :
int
ÑÑ; >
readerIndex
ÑÑ? J
,
ÑÑJ K
int
ÑÑL O
len
ÑÑP S
,
ÑÑS T
Encoding
ÑÑU ]
encoding
ÑÑ^ f
)
ÑÑf g
{
ÒÒ 	
if
ÓÓ 
(
ÓÓ 
len
ÓÓ 
==
ÓÓ 
$num
ÓÓ 
)
ÓÓ 
{
ÔÔ 
return
ÕÕ 
string
ÕÕ 
.
ÕÕ 
Empty
ÕÕ #
;
ÕÕ# $
}
ÖÖ 
if
ØØ 
(
ØØ 
src
ØØ 
.
ØØ 
IoBufferCount
ØØ !
==
ØØ" $
$num
ØØ% &
)
ØØ& '
{
ÙÙ 
ArraySegment
ÚÚ 
<
ÚÚ 
byte
ÚÚ !
>
ÚÚ! "
ioBuf
ÚÚ# (
=
ÚÚ) *
src
ÚÚ+ .
.
ÚÚ. /
GetIoBuffer
ÚÚ/ :
(
ÚÚ: ;
readerIndex
ÚÚ; F
,
ÚÚF G
len
ÚÚH K
)
ÚÚK L
;
ÚÚL M
return
ÛÛ 
encoding
ÛÛ 
.
ÛÛ  
	GetString
ÛÛ  )
(
ÛÛ) *
ioBuf
ÛÛ* /
.
ÛÛ/ 0
Array
ÛÛ0 5
,
ÛÛ5 6
ioBuf
ÛÛ7 <
.
ÛÛ< =
Offset
ÛÛ= C
,
ÛÛC D
ioBuf
ÛÛE J
.
ÛÛJ K
Count
ÛÛK P
)
ÛÛP Q
;
ÛÛQ R
}
ÜÜ 
else
İİ 
{
ŞŞ 
int
ßß 
	maxLength
ßß 
=
ßß 
encoding
ßß  (
.
ßß( )
GetMaxCharCount
ßß) 8
(
ßß8 9
len
ßß9 <
)
ßß< =
;
ßß= >
IByteBuffer
àà 
buffer
àà "
=
àà# $
src
àà% (
.
àà( )
	Allocator
àà) 2
.
àà2 3

HeapBuffer
àà3 =
(
àà= >
	maxLength
àà> G
)
ààG H
;
ààH I
try
áá 
{
ââ 
buffer
ãã 
.
ãã 

WriteBytes
ãã %
(
ãã% &
src
ãã& )
,
ãã) *
readerIndex
ãã+ 6
,
ãã6 7
len
ãã8 ;
)
ãã; <
;
ãã< =
ArraySegment
ää  
<
ää  !
byte
ää! %
>
ää% &
ioBuf
ää' ,
=
ää- .
buffer
ää/ 5
.
ää5 6
GetIoBuffer
ää6 A
(
ääA B
)
ääB C
;
ääC D
return
åå 
encoding
åå #
.
åå# $
	GetString
åå$ -
(
åå- .
ioBuf
åå. 3
.
åå3 4
Array
åå4 9
,
åå9 :
ioBuf
åå; @
.
åå@ A
Offset
ååA G
,
ååG H
ioBuf
ååI N
.
ååN O
Count
ååO T
)
ååT U
;
ååU V
}
ææ 
finally
çç 
{
èè 
buffer
êê 
.
êê 
Release
êê "
(
êê" #
)
êê# $
;
êê$ %
}
ëë 
}
ìì 
}
íí 	
public
ïï 
static
ïï 
void
ïï 
Copy
ïï 
(
ïï  
AsciiString
ïï  +
src
ïï, /
,
ïï/ 0
IByteBuffer
ïï1 <
dst
ïï= @
)
ïï@ A
=>
ïïB D
Copy
ïïE I
(
ïïI J
src
ïïJ M
,
ïïM N
$num
ïïO P
,
ïïP Q
dst
ïïR U
,
ïïU V
src
ïïW Z
.
ïïZ [
Count
ïï[ `
)
ïï` a
;
ïïa b
[
ññ 	

MethodImpl
ññ	 
(
ññ 
MethodImplOptions
ññ %
.
ññ% & 
AggressiveInlining
ññ& 8
)
ññ8 9
]
ññ9 :
public
òò 
static
òò 
void
òò 
Copy
òò 
(
òò  
AsciiString
òò  +
src
òò, /
,
òò/ 0
int
òò1 4
srcIdx
òò5 ;
,
òò; <
IByteBuffer
òò= H
dst
òòI L
,
òòL M
int
òòN Q
dstIdx
òòR X
,
òòX Y
int
òòZ ]
length
òò^ d
)
òòd e
{
óó 	
if
ôô 
(
ôô 
MathUtil
ôô 
.
ôô 
IsOutOfBounds
ôô &
(
ôô& '
srcIdx
ôô' -
,
ôô- .
length
ôô/ 5
,
ôô5 6
src
ôô7 :
.
ôô: ;
Count
ôô; @
)
ôô@ A
)
ôôA B
{
õõ 
ThrowHelper
öö 
.
öö /
!ThrowIndexOutOfRangeException_Src
öö =
(
öö= >
srcIdx
öö> D
,
ööD E
length
ööF L
,
ööL M
src
ööN Q
.
ööQ R
Count
ööR W
)
ööW X
;
ööX Y
}
÷÷ 
if
øø 
(
øø 
dst
øø 
==
øø 
null
øø 
)
øø 
{
ùù 
ThrowHelper
úú 
.
úú ,
ThrowArgumentNullException_Dst
úú :
(
úú: ;
)
úú; <
;
úú< =
}
ûû 
dst
ıı 
.
ıı 
SetBytes
ıı 
(
ıı 
dstIdx
ıı 
,
ıı  
src
ıı! $
.
ıı$ %
Array
ıı% *
,
ıı* +
srcIdx
ıı, 2
+
ıı3 4
src
ıı5 8
.
ıı8 9
Offset
ıı9 ?
,
ıı? @
length
ııA G
)
ııG H
;
ııH I
}
şş 	
[
€€ 	

MethodImpl
€€	 
(
€€ 
MethodImplOptions
€€ %
.
€€% & 
AggressiveInlining
€€& 8
)
€€8 9
]
€€9 :
public
 
static
 
void
 
Copy
 
(
  
AsciiString
  +
src
, /
,
/ 0
int
1 4
srcIdx
5 ;
,
; <
IByteBuffer
= H
dst
I L
,
L M
int
N Q
length
R X
)
X Y
{
‚‚ 	
if
ƒƒ 
(
ƒƒ 
MathUtil
ƒƒ 
.
ƒƒ 
IsOutOfBounds
ƒƒ &
(
ƒƒ& '
srcIdx
ƒƒ' -
,
ƒƒ- .
length
ƒƒ/ 5
,
ƒƒ5 6
src
ƒƒ7 :
.
ƒƒ: ;
Count
ƒƒ; @
)
ƒƒ@ A
)
ƒƒA B
{
„„ 
ThrowHelper
…… 
.
…… /
!ThrowIndexOutOfRangeException_Src
…… =
(
……= >
srcIdx
……> D
,
……D E
length
……F L
,
……L M
src
……N Q
.
……Q R
Count
……R W
)
……W X
;
……X Y
}
†† 
if
‡‡ 
(
‡‡ 
dst
‡‡ 
==
‡‡ 
null
‡‡ 
)
‡‡ 
{
ˆˆ 
ThrowHelper
‰‰ 
.
‰‰ ,
ThrowArgumentNullException_Dst
‰‰ :
(
‰‰: ;
)
‰‰; <
;
‰‰< =
}
ŠŠ 
dst
ŒŒ 
.
ŒŒ 

WriteBytes
ŒŒ 
(
ŒŒ 
src
ŒŒ 
.
ŒŒ 
Array
ŒŒ $
,
ŒŒ$ %
srcIdx
ŒŒ& ,
+
ŒŒ- .
src
ŒŒ/ 2
.
ŒŒ2 3
Offset
ŒŒ3 9
,
ŒŒ9 :
length
ŒŒ; A
)
ŒŒA B
;
ŒŒB C
}
 	
public
’’ 
static
’’ 
string
’’ 
PrettyHexDump
’’ *
(
’’* +
IByteBuffer
’’+ 6
buffer
’’7 =
)
’’= >
=>
’’? A
PrettyHexDump
’’B O
(
’’O P
buffer
’’P V
,
’’V W
buffer
’’X ^
.
’’^ _
ReaderIndex
’’_ j
,
’’j k
buffer
’’l r
.
’’r s
ReadableBytes’’s €
)’’€ 
;’’ ‚
public
˜˜ 
static
˜˜ 
string
˜˜ 
PrettyHexDump
˜˜ *
(
˜˜* +
IByteBuffer
˜˜+ 6
buffer
˜˜7 =
,
˜˜= >
int
˜˜? B
offset
˜˜C I
,
˜˜I J
int
˜˜K N
length
˜˜O U
)
˜˜U V
=>
˜˜W Y
HexUtil
˜˜Z a
.
˜˜a b
DoPrettyHexDump
˜˜b q
(
˜˜q r
buffer
˜˜r x
,
˜˜x y
offset˜˜z €
,˜˜€ 
length˜˜‚ ˆ
)˜˜ˆ ‰
;˜˜‰ Š
public
 
static
 
void
 !
AppendPrettyHexDump
 .
(
. /
StringBuilder
/ <
dump
= A
,
A B
IByteBuffer
C N
buf
O R
)
R S
=>
T V!
AppendPrettyHexDump
W j
(
j k
dump
k o
,
o p
buf
q t
,
t u
buf
v y
.
y z
ReaderIndexz …
,… †
buf‡ Š
.Š ‹
ReadableBytes‹ ˜
)˜ ™
;™ š
public
¥¥ 
static
¥¥ 
void
¥¥ !
AppendPrettyHexDump
¥¥ .
(
¥¥. /
StringBuilder
¥¥/ <
dump
¥¥= A
,
¥¥A B
IByteBuffer
¥¥C N
buf
¥¥O R
,
¥¥R S
int
¥¥T W
offset
¥¥X ^
,
¥¥^ _
int
¥¥` c
length
¥¥d j
)
¥¥j k
=>
¥¥l n
HexUtil
¥¥o v
.
¥¥v w$
DoAppendPrettyHexDump¥¥w Œ
(¥¥Œ 
dump¥¥ ‘
,¥¥‘ ’
buf¥¥“ –
,¥¥– —
offset¥¥˜ 
,¥¥ Ÿ
length¥¥  ¦
)¥¥¦ §
;¥¥§ ¨
static
§§ 
class
§§ 
HexUtil
§§ 
{
¨¨ 	
static
©© 
readonly
©© 
char
©©  
[
©©  !
]
©©! "
HexdumpTable
©©# /
=
©©0 1
new
©©2 5
char
©©6 :
[
©©: ;
$num
©©; >
*
©©? @
$num
©©A B
]
©©B C
;
©©C D
static
ªª 
readonly
ªª 
string
ªª "
Newline
ªª# *
=
ªª+ ,

StringUtil
ªª- 7
.
ªª7 8
Newline
ªª8 ?
;
ªª? @
static
«« 
readonly
«« 
string
«« "
[
««" #
]
««# $
Byte2Hex
««% -
=
««. /
new
««0 3
string
««4 :
[
««: ;
$num
««; >
]
««> ?
;
««? @
static
¬¬ 
readonly
¬¬ 
string
¬¬ "
[
¬¬" #
]
¬¬# $

HexPadding
¬¬% /
=
¬¬0 1
new
¬¬2 5
string
¬¬6 <
[
¬¬< =
$num
¬¬= ?
]
¬¬? @
;
¬¬@ A
static
­­ 
readonly
­­ 
string
­­ "
[
­­" #
]
­­# $
BytePadding
­­% 0
=
­­1 2
new
­­3 6
string
­­7 =
[
­­= >
$num
­­> @
]
­­@ A
;
­­A B
static
®® 
readonly
®® 
char
®®  
[
®®  !
]
®®! "
	Byte2Char
®®# ,
=
®®- .
new
®®/ 2
char
®®3 7
[
®®7 8
$num
®®8 ;
]
®®; <
;
®®< =
static
¯¯ 
readonly
¯¯ 
string
¯¯ "
[
¯¯" #
]
¯¯# $ 
HexDumpRowPrefixes
¯¯% 7
=
¯¯8 9
new
¯¯: =
string
¯¯> D
[
¯¯D E
(
¯¯E F
int
¯¯F I
)
¯¯I J
(
¯¯J K
(
¯¯K L
uint
¯¯L P
)
¯¯P Q
$num
¯¯Q V
>>
¯¯W Y
$num
¯¯Z [
)
¯¯[ \
]
¯¯\ ]
;
¯¯] ^
static
±± 
HexUtil
±± 
(
±± 
)
±± 
{
²² 
char
³³ 
[
³³ 
]
³³ 
digits
³³ 
=
³³ 
$str
³³  2
.
³³2 3
ToCharArray
³³3 >
(
³³> ?
)
³³? @
;
³³@ A
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´  !
<
´´" #
$num
´´$ '
;
´´' (
i
´´) *
++
´´* ,
)
´´, -
{
µµ 
HexdumpTable
¶¶  
[
¶¶  !
i
¶¶! "
<<
¶¶# %
$num
¶¶& '
]
¶¶' (
=
¶¶) *
digits
¶¶+ 1
[
¶¶1 2
(
¶¶2 3
int
¶¶3 6
)
¶¶6 7
(
¶¶7 8
(
¶¶8 9
uint
¶¶9 =
)
¶¶= >
i
¶¶> ?
>>
¶¶@ B
$num
¶¶C D
&
¶¶E F
$num
¶¶G K
)
¶¶K L
]
¶¶L M
;
¶¶M N
HexdumpTable
··  
[
··  !
(
··! "
i
··" #
<<
··$ &
$num
··' (
)
··( )
+
··* +
$num
··, -
]
··- .
=
··/ 0
digits
··1 7
[
··7 8
i
··8 9
&
··: ;
$num
··< @
]
··@ A
;
··A B
}
¸¸ 
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»»  !
<
»»" #
Byte2Hex
»»$ ,
.
»», -
Length
»»- 3
;
»»3 4
i
»»5 6
++
»»6 8
)
»»8 9
{
¼¼ 
Byte2Hex
½½ 
[
½½ 
i
½½ 
]
½½ 
=
½½  !
$char
½½" %
+
½½& '

StringUtil
½½( 2
.
½½2 3#
ByteToHexStringPadded
½½3 H
(
½½H I
i
½½I J
)
½½J K
;
½½K L
}
¾¾ 
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
i
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
i
ÁÁ  !
<
ÁÁ" #

HexPadding
ÁÁ$ .
.
ÁÁ. /
Length
ÁÁ/ 5
;
ÁÁ5 6
i
ÁÁ7 8
++
ÁÁ8 :
)
ÁÁ: ;
{
ÂÂ 
int
ÃÃ 
padding
ÃÃ 
=
ÃÃ  !

HexPadding
ÃÃ" ,
.
ÃÃ, -
Length
ÃÃ- 3
-
ÃÃ4 5
i
ÃÃ6 7
;
ÃÃ7 8
var
ÄÄ 
buf
ÄÄ 
=
ÄÄ 
new
ÄÄ !
StringBuilder
ÄÄ" /
(
ÄÄ/ 0
padding
ÄÄ0 7
*
ÄÄ8 9
$num
ÄÄ: ;
)
ÄÄ; <
;
ÄÄ< =
for
ÅÅ 
(
ÅÅ 
int
ÅÅ 
j
ÅÅ 
=
ÅÅ  
$num
ÅÅ! "
;
ÅÅ" #
j
ÅÅ$ %
<
ÅÅ& '
padding
ÅÅ( /
;
ÅÅ/ 0
j
ÅÅ1 2
++
ÅÅ2 4
)
ÅÅ4 5
{
ÆÆ 
buf
ÇÇ 
.
ÇÇ 
Append
ÇÇ "
(
ÇÇ" #
$str
ÇÇ# (
)
ÇÇ( )
;
ÇÇ) *
}
ÈÈ 

HexPadding
ÉÉ 
[
ÉÉ 
i
ÉÉ  
]
ÉÉ  !
=
ÉÉ" #
buf
ÉÉ$ '
.
ÉÉ' (
ToString
ÉÉ( 0
(
ÉÉ0 1
)
ÉÉ1 2
;
ÉÉ2 3
}
ÊÊ 
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
i
ÍÍ  !
<
ÍÍ" #
BytePadding
ÍÍ$ /
.
ÍÍ/ 0
Length
ÍÍ0 6
;
ÍÍ6 7
i
ÍÍ8 9
++
ÍÍ9 ;
)
ÍÍ; <
{
ÎÎ 
int
ÏÏ 
padding
ÏÏ 
=
ÏÏ  !
BytePadding
ÏÏ" -
.
ÏÏ- .
Length
ÏÏ. 4
-
ÏÏ5 6
i
ÏÏ7 8
;
ÏÏ8 9
var
ĞĞ 
buf
ĞĞ 
=
ĞĞ 
new
ĞĞ !
StringBuilder
ĞĞ" /
(
ĞĞ/ 0
padding
ĞĞ0 7
)
ĞĞ7 8
;
ĞĞ8 9
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
j
ÑÑ 
=
ÑÑ  
$num
ÑÑ! "
;
ÑÑ" #
j
ÑÑ$ %
<
ÑÑ& '
padding
ÑÑ( /
;
ÑÑ/ 0
j
ÑÑ1 2
++
ÑÑ2 4
)
ÑÑ4 5
{
ÒÒ 
buf
ÓÓ 
.
ÓÓ 
Append
ÓÓ "
(
ÓÓ" #
$char
ÓÓ# &
)
ÓÓ& '
;
ÓÓ' (
}
ÔÔ 
BytePadding
ÕÕ 
[
ÕÕ  
i
ÕÕ  !
]
ÕÕ! "
=
ÕÕ# $
buf
ÕÕ% (
.
ÕÕ( )
ToString
ÕÕ) 1
(
ÕÕ1 2
)
ÕÕ2 3
;
ÕÕ3 4
}
ÖÖ 
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ  !
<
ÙÙ" #
	Byte2Char
ÙÙ$ -
.
ÙÙ- .
Length
ÙÙ. 4
;
ÙÙ4 5
i
ÙÙ6 7
++
ÙÙ7 9
)
ÙÙ9 :
{
ÚÚ 
if
ÛÛ 
(
ÛÛ 
i
ÛÛ 
<=
ÛÛ 
$num
ÛÛ !
||
ÛÛ" $
i
ÛÛ% &
>=
ÛÛ' )
$num
ÛÛ* .
)
ÛÛ. /
{
ÜÜ 
	Byte2Char
İİ !
[
İİ! "
i
İİ" #
]
İİ# $
=
İİ% &
$char
İİ' *
;
İİ* +
}
ŞŞ 
else
ßß 
{
àà 
	Byte2Char
áá !
[
áá! "
i
áá" #
]
áá# $
=
áá% &
(
áá' (
char
áá( ,
)
áá, -
i
áá- .
;
áá. /
}
ââ 
}
ãã 
for
ææ 
(
ææ 
int
ææ 
i
ææ 
=
ææ 
$num
ææ 
;
ææ 
i
ææ  !
<
ææ" # 
HexDumpRowPrefixes
ææ$ 6
.
ææ6 7
Length
ææ7 =
;
ææ= >
i
ææ? @
++
ææ@ B
)
ææB C
{
çç 
var
èè 
buf
èè 
=
èè 
new
èè !
StringBuilder
èè" /
(
èè/ 0
$num
èè0 2
)
èè2 3
;
èè3 4
buf
éé 
.
éé 
Append
éé 
(
éé 
Environment
éé *
.
éé* +
NewLine
éé+ 2
)
éé2 3
;
éé3 4
buf
êê 
.
êê 
Append
êê 
(
êê 
(
êê  
i
êê  !
<<
êê" $
$num
êê% &
&
êê' (
$num
êê) 4
|
êê5 6
$num
êê7 C
)
êêC D
.
êêD E
ToString
êêE M
(
êêM N
$str
êêN R
)
êêR S
)
êêS T
;
êêT U
buf
ëë 
.
ëë 
Insert
ëë 
(
ëë 
buf
ëë "
.
ëë" #
Length
ëë# )
-
ëë* +
$num
ëë, -
,
ëë- .
$char
ëë/ 2
)
ëë2 3
;
ëë3 4
buf
ìì 
.
ìì 
Append
ìì 
(
ìì 
$char
ìì "
)
ìì" #
;
ìì# $ 
HexDumpRowPrefixes
íí &
[
íí& '
i
íí' (
]
íí( )
=
íí* +
buf
íí, /
.
íí/ 0
ToString
íí0 8
(
íí8 9
)
íí9 :
;
íí: ;
}
îî 
}
ïï 
public
ññ 
static
ññ 
string
ññ  
	DoHexDump
ññ! *
(
ññ* +
IByteBuffer
ññ+ 6
buffer
ññ7 =
,
ññ= >
int
ññ? B
	fromIndex
ññC L
,
ññL M
int
ññN Q
length
ññR X
)
ññX Y
{
òò 
Contract
óó 
.
óó 
Requires
óó !
(
óó! "
length
óó" (
>=
óó) +
$num
óó, -
)
óó- .
;
óó. /
if
ôô 
(
ôô 
length
ôô 
==
ôô 
$num
ôô 
)
ôô  
{
õõ 
return
öö 
$str
öö 
;
öö 
}
÷÷ 
int
øø 
endIndex
øø 
=
øø 
	fromIndex
øø (
+
øø) *
length
øø+ 1
;
øø1 2
var
ùù 
buf
ùù 
=
ùù 
new
ùù 
char
ùù "
[
ùù" #
length
ùù# )
<<
ùù* ,
$num
ùù- .
]
ùù. /
;
ùù/ 0
int
ûû 
srcIdx
ûû 
=
ûû 
	fromIndex
ûû &
;
ûû& '
int
üü 
dstIdx
üü 
=
üü 
$num
üü 
;
üü 
for
ıı 
(
ıı 
;
ıı 
srcIdx
ıı 
<
ıı 
endIndex
ıı  (
;
ıı( )
srcIdx
ıı* 0
++
ıı0 2
,
ıı2 3
dstIdx
ıı4 :
+=
ıı; =
$num
ıı> ?
)
ıı? @
{
şş 
Array
ÿÿ 
.
ÿÿ 
Copy
ÿÿ 
(
ÿÿ 
HexdumpTable
€€ $
,
€€$ %
buffer
€€& ,
.
€€, -
GetByte
€€- 4
(
€€4 5
srcIdx
€€5 ;
)
€€; <
<<
€€= ?
$num
€€@ A
,
€€A B
buf
 
,
 
dstIdx
 #
,
# $
$num
% &
)
& '
;
' (
}
‚‚ 
return
„„ 
new
„„ 
string
„„ !
(
„„! "
buf
„„" %
)
„„% &
;
„„& '
}
…… 
public
‡‡ 
static
‡‡ 
string
‡‡  
	DoHexDump
‡‡! *
(
‡‡* +
byte
‡‡+ /
[
‡‡/ 0
]
‡‡0 1
array
‡‡2 7
,
‡‡7 8
int
‡‡9 <
	fromIndex
‡‡= F
,
‡‡F G
int
‡‡H K
length
‡‡L R
)
‡‡R S
{
ˆˆ 
Contract
‰‰ 
.
‰‰ 
Requires
‰‰ !
(
‰‰! "
length
‰‰" (
>=
‰‰) +
$num
‰‰, -
)
‰‰- .
;
‰‰. /
if
‹‹ 
(
‹‹ 
length
‹‹ 
==
‹‹ 
$num
‹‹ 
)
‹‹  
{
ŒŒ 
return
 
$str
 
;
 
}
 
int
 
endIndex
 
=
 
	fromIndex
 (
+
) *
length
+ 1
;
1 2
var
‘‘ 
buf
‘‘ 
=
‘‘ 
new
‘‘ 
char
‘‘ "
[
‘‘" #
length
‘‘# )
<<
‘‘* ,
$num
‘‘- .
]
‘‘. /
;
‘‘/ 0
int
““ 
srcIdx
““ 
=
““ 
	fromIndex
““ &
;
““& '
int
”” 
dstIdx
”” 
=
”” 
$num
”” 
;
”” 
for
•• 
(
•• 
;
•• 
srcIdx
•• 
<
•• 
endIndex
••  (
;
••( )
srcIdx
••* 0
++
••0 2
,
••2 3
dstIdx
••4 :
+=
••; =
$num
••> ?
)
••? @
{
–– 
Array
—— 
.
—— 
Copy
—— 
(
—— 
HexdumpTable
—— +
,
——+ ,
(
——- .
array
——. 3
[
——3 4
srcIdx
——4 :
]
——: ;
&
——< =
$num
——> B
)
——B C
<<
——D F
$num
——G H
,
——H I
buf
——J M
,
——M N
dstIdx
——O U
,
——U V
$num
——W X
)
——X Y
;
——Y Z
}
˜˜ 
return
šš 
new
šš 
string
šš !
(
šš! "
buf
šš" %
)
šš% &
;
šš& '
}
›› 
public
 
static
 
string
  
DoPrettyHexDump
! 0
(
0 1
IByteBuffer
1 <
buffer
= C
,
C D
int
E H
offset
I O
,
O P
int
Q T
length
U [
)
[ \
{
 
if
ŸŸ 
(
ŸŸ 
length
ŸŸ 
==
ŸŸ 
$num
ŸŸ 
)
ŸŸ  
{
   
return
¡¡ 
string
¡¡ !
.
¡¡! "
Empty
¡¡" '
;
¡¡' (
}
¢¢ 
else
££ 
{
¤¤ 
int
¥¥ 
rows
¥¥ 
=
¥¥ 
length
¥¥ %
/
¥¥& '
$num
¥¥( *
+
¥¥+ ,
(
¥¥- .
length
¥¥. 4
%
¥¥5 6
$num
¥¥7 9
==
¥¥: <
$num
¥¥= >
?
¥¥? @
$num
¥¥A B
:
¥¥C D
$num
¥¥E F
)
¥¥F G
+
¥¥H I
$num
¥¥J K
;
¥¥K L
var
¦¦ 
buf
¦¦ 
=
¦¦ 
new
¦¦ !
StringBuilder
¦¦" /
(
¦¦/ 0
rows
¦¦0 4
*
¦¦5 6
$num
¦¦7 9
)
¦¦9 :
;
¦¦: ;!
AppendPrettyHexDump
§§ '
(
§§' (
buf
§§( +
,
§§+ ,
buffer
§§- 3
,
§§3 4
offset
§§5 ;
,
§§; <
length
§§= C
)
§§C D
;
§§D E
return
¨¨ 
buf
¨¨ 
.
¨¨ 
ToString
¨¨ '
(
¨¨' (
)
¨¨( )
;
¨¨) *
}
©© 
}
ªª 
public
¬¬ 
static
¬¬ 
void
¬¬ #
DoAppendPrettyHexDump
¬¬ 4
(
¬¬4 5
StringBuilder
¬¬5 B
dump
¬¬C G
,
¬¬G H
IByteBuffer
¬¬I T
buf
¬¬U X
,
¬¬X Y
int
¬¬Z ]
offset
¬¬^ d
,
¬¬d e
int
¬¬f i
length
¬¬j p
)
¬¬p q
{
­­ 
if
®® 
(
®® 
MathUtil
®® 
.
®® 
IsOutOfBounds
®® *
(
®®* +
offset
®®+ 1
,
®®1 2
length
®®3 9
,
®®9 :
buf
®®; >
.
®®> ?
Capacity
®®? G
)
®®G H
)
®®H I
{
¯¯ 
throw
°° 
new
°° &
IndexOutOfRangeException
°° 6
(
°°6 7
$"
±± 
$str
±± 0
{
±±0 1
offset
±±1 7
}
±±7 8
$str
±±8 M
{
±±M N
length
±±N T
}
±±T U
$str
±±U g
{
±±g h
buf
±±h k
.
±±k l
Capacity
±±l t
}
±±t u
{
±±u v
$char
±±v y
}
±±y z
"
±±z {
)
±±{ |
;
±±| }
}
²² 
if
³³ 
(
³³ 
length
³³ 
==
³³ 
$num
³³ 
)
³³  
{
´´ 
return
µµ 
;
µµ 
}
¶¶ 
dump
·· 
.
·· 
Append
·· 
(
·· 
$str
¸¸ R
+
¸¸S T
Newline
¹¹ 
+
¹¹ 
$str
¹¹ \
+
¹¹] ^
Newline
ºº 
+
ºº 
$str
ºº m
)
ººm n
;
ººn o
int
¼¼ 

startIndex
¼¼ 
=
¼¼  
offset
¼¼! '
;
¼¼' (
int
½½ 
fullRows
½½ 
=
½½ 
(
½½  
int
½½  #
)
½½# $
(
½½$ %
(
½½% &
uint
½½& *
)
½½* +
length
½½+ 1
>>
½½2 4
$num
½½5 6
)
½½6 7
;
½½7 8
int
¾¾ 
	remainder
¾¾ 
=
¾¾ 
length
¾¾  &
&
¾¾' (
$num
¾¾) ,
;
¾¾, -
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
row
ÁÁ 
=
ÁÁ 
$num
ÁÁ  
;
ÁÁ  !
row
ÁÁ" %
<
ÁÁ& '
fullRows
ÁÁ( 0
;
ÁÁ0 1
row
ÁÁ2 5
++
ÁÁ5 7
)
ÁÁ7 8
{
ÂÂ 
int
ÃÃ 
rowStartIndex
ÃÃ %
=
ÃÃ& '
(
ÃÃ( )
row
ÃÃ) ,
<<
ÃÃ- /
$num
ÃÃ0 1
)
ÃÃ1 2
+
ÃÃ3 4

startIndex
ÃÃ5 ?
;
ÃÃ? @$
AppendHexDumpRowPrefix
ÆÆ *
(
ÆÆ* +
dump
ÆÆ+ /
,
ÆÆ/ 0
row
ÆÆ1 4
,
ÆÆ4 5
rowStartIndex
ÆÆ6 C
)
ÆÆC D
;
ÆÆD E
int
ÉÉ 
rowEndIndex
ÉÉ #
=
ÉÉ$ %
rowStartIndex
ÉÉ& 3
+
ÉÉ4 5
$num
ÉÉ6 8
;
ÉÉ8 9
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
j
ÊÊ 
=
ÊÊ  
rowStartIndex
ÊÊ! .
;
ÊÊ. /
j
ÊÊ0 1
<
ÊÊ2 3
rowEndIndex
ÊÊ4 ?
;
ÊÊ? @
j
ÊÊA B
++
ÊÊB D
)
ÊÊD E
{
ËË 
dump
ÌÌ 
.
ÌÌ 
Append
ÌÌ #
(
ÌÌ# $
Byte2Hex
ÌÌ$ ,
[
ÌÌ, -
buf
ÌÌ- 0
.
ÌÌ0 1
GetByte
ÌÌ1 8
(
ÌÌ8 9
j
ÌÌ9 :
)
ÌÌ: ;
]
ÌÌ; <
)
ÌÌ< =
;
ÌÌ= >
}
ÍÍ 
dump
ÎÎ 
.
ÎÎ 
Append
ÎÎ 
(
ÎÎ  
$str
ÎÎ  $
)
ÎÎ$ %
;
ÎÎ% &
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
j
ÑÑ 
=
ÑÑ  
rowStartIndex
ÑÑ! .
;
ÑÑ. /
j
ÑÑ0 1
<
ÑÑ2 3
rowEndIndex
ÑÑ4 ?
;
ÑÑ? @
j
ÑÑA B
++
ÑÑB D
)
ÑÑD E
{
ÒÒ 
dump
ÓÓ 
.
ÓÓ 
Append
ÓÓ #
(
ÓÓ# $
	Byte2Char
ÓÓ$ -
[
ÓÓ- .
buf
ÓÓ. 1
.
ÓÓ1 2
GetByte
ÓÓ2 9
(
ÓÓ9 :
j
ÓÓ: ;
)
ÓÓ; <
]
ÓÓ< =
)
ÓÓ= >
;
ÓÓ> ?
}
ÔÔ 
dump
ÕÕ 
.
ÕÕ 
Append
ÕÕ 
(
ÕÕ  
$char
ÕÕ  #
)
ÕÕ# $
;
ÕÕ$ %
}
ÖÖ 
if
ÙÙ 
(
ÙÙ 
	remainder
ÙÙ 
!=
ÙÙ  
$num
ÙÙ! "
)
ÙÙ" #
{
ÚÚ 
int
ÛÛ 
rowStartIndex
ÛÛ %
=
ÛÛ& '
(
ÛÛ( )
fullRows
ÛÛ) 1
<<
ÛÛ2 4
$num
ÛÛ5 6
)
ÛÛ6 7
+
ÛÛ8 9

startIndex
ÛÛ: D
;
ÛÛD E$
AppendHexDumpRowPrefix
ÜÜ *
(
ÜÜ* +
dump
ÜÜ+ /
,
ÜÜ/ 0
fullRows
ÜÜ1 9
,
ÜÜ9 :
rowStartIndex
ÜÜ; H
)
ÜÜH I
;
ÜÜI J
int
ßß 
rowEndIndex
ßß #
=
ßß$ %
rowStartIndex
ßß& 3
+
ßß4 5
	remainder
ßß6 ?
;
ßß? @
for
àà 
(
àà 
int
àà 
j
àà 
=
àà  
rowStartIndex
àà! .
;
àà. /
j
àà0 1
<
àà2 3
rowEndIndex
àà4 ?
;
àà? @
j
ààA B
++
ààB D
)
ààD E
{
áá 
dump
ââ 
.
ââ 
Append
ââ #
(
ââ# $
Byte2Hex
ââ$ ,
[
ââ, -
buf
ââ- 0
.
ââ0 1
GetByte
ââ1 8
(
ââ8 9
j
ââ9 :
)
ââ: ;
]
ââ; <
)
ââ< =
;
ââ= >
}
ãã 
dump
ää 
.
ää 
Append
ää 
(
ää  

HexPadding
ää  *
[
ää* +
	remainder
ää+ 4
]
ää4 5
)
ää5 6
;
ää6 7
dump
åå 
.
åå 
Append
åå 
(
åå  
$str
åå  $
)
åå$ %
;
åå% &
for
èè 
(
èè 
int
èè 
j
èè 
=
èè  
rowStartIndex
èè! .
;
èè. /
j
èè0 1
<
èè2 3
rowEndIndex
èè4 ?
;
èè? @
j
èèA B
++
èèB D
)
èèD E
{
éé 
dump
êê 
.
êê 
Append
êê #
(
êê# $
	Byte2Char
êê$ -
[
êê- .
buf
êê. 1
.
êê1 2
GetByte
êê2 9
(
êê9 :
j
êê: ;
)
êê; <
]
êê< =
)
êê= >
;
êê> ?
}
ëë 
dump
ìì 
.
ìì 
Append
ìì 
(
ìì  
BytePadding
ìì  +
[
ìì+ ,
	remainder
ìì, 5
]
ìì5 6
)
ìì6 7
;
ìì7 8
dump
íí 
.
íí 
Append
íí 
(
íí  
$char
íí  #
)
íí# $
;
íí$ %
}
îî 
dump
ğğ 
.
ğğ 
Append
ğğ 
(
ğğ 
Newline
ğğ #
+
ğğ$ %
$str
ğğ& u
)
ğğu v
;
ğğv w
}
ññ 
static
óó 
void
óó $
AppendHexDumpRowPrefix
óó .
(
óó. /
StringBuilder
óó/ <
dump
óó= A
,
óóA B
int
óóC F
row
óóG J
,
óóJ K
int
óóL O
rowStartIndex
óóP ]
)
óó] ^
{
ôô 
if
õõ 
(
õõ 
row
õõ 
<
õõ  
HexDumpRowPrefixes
õõ ,
.
õõ, -
Length
õõ- 3
)
õõ3 4
{
öö 
dump
÷÷ 
.
÷÷ 
Append
÷÷ 
(
÷÷   
HexDumpRowPrefixes
÷÷  2
[
÷÷2 3
row
÷÷3 6
]
÷÷6 7
)
÷÷7 8
;
÷÷8 9
}
øø 
else
ùù 
{
úú 
dump
ûû 
.
ûû 
Append
ûû 
(
ûû  
Environment
ûû  +
.
ûû+ ,
NewLine
ûû, 3
)
ûû3 4
;
ûû4 5
dump
üü 
.
üü 
Append
üü 
(
üü  
(
üü  !
rowStartIndex
üü! .
&
üü/ 0
$num
üü1 <
|
üü= >
$num
üü? K
)
üüK L
.
üüL M
ToString
üüM U
(
üüU V
$str
üüV Z
)
üüZ [
)
üü[ \
;
üü\ ]
dump
ıı 
.
ıı 
Insert
ıı 
(
ıı  
dump
ıı  $
.
ıı$ %
Length
ıı% +
-
ıı, -
$num
ıı. /
,
ıı/ 0
$char
ıı1 4
)
ıı4 5
;
ıı5 6
dump
şş 
.
şş 
Append
şş 
(
şş  
$char
şş  #
)
şş# $
;
şş$ %
}
ÿÿ 
}
€€ 
}
 	
public
ƒƒ 
static
ƒƒ 
bool
ƒƒ 
IsText
ƒƒ !
(
ƒƒ! "
IByteBuffer
ƒƒ" -
buf
ƒƒ. 1
,
ƒƒ1 2
int
ƒƒ3 6
index
ƒƒ7 <
,
ƒƒ< =
int
ƒƒ> A
length
ƒƒB H
,
ƒƒH I
Encoding
ƒƒJ R
encoding
ƒƒS [
)
ƒƒ[ \
{
„„ 	
Contract
…… 
.
…… 
Requires
…… 
(
…… 
buf
…… !
!=
……" $
null
……% )
)
……) *
;
……* +
Contract
†† 
.
†† 
Requires
†† 
(
†† 
encoding
†† &
!=
††' )
null
††* .
)
††. /
;
††/ 0
int
ˆˆ 
maxIndex
ˆˆ 
=
ˆˆ 
buf
ˆˆ 
.
ˆˆ 
ReaderIndex
ˆˆ *
+
ˆˆ+ ,
buf
ˆˆ- 0
.
ˆˆ0 1
ReadableBytes
ˆˆ1 >
;
ˆˆ> ?
if
‰‰ 
(
‰‰ 
index
‰‰ 
<
‰‰ 
$num
‰‰ 
||
‰‰ 
length
‰‰ #
<
‰‰$ %
$num
‰‰& '
||
‰‰( *
index
‰‰+ 0
>
‰‰1 2
maxIndex
‰‰3 ;
-
‰‰< =
length
‰‰> D
)
‰‰D E
{
ŠŠ 
throw
‹‹ 
new
‹‹ &
IndexOutOfRangeException
‹‹ 2
(
‹‹2 3
$"
‹‹3 5
$str
‹‹5 <
{
‹‹< =
index
‹‹= B
}
‹‹B C
$str
‹‹C K
{
‹‹K L
length
‹‹L R
}
‹‹R S
"
‹‹S T
)
‹‹T U
;
‹‹U V
}
ŒŒ 
if
 
(
 
ReferenceEquals
 
(
  
Encoding
  (
.
( )
UTF8
) -
,
- .
encoding
/ 7
)
7 8
)
8 9
{
 
return
 
IsUtf8
 
(
 
buf
 !
,
! "
index
# (
,
( )
length
* 0
)
0 1
;
1 2
}
 
else
‘‘ 
if
‘‘ 
(
‘‘ 
ReferenceEquals
‘‘ $
(
‘‘$ %
Encoding
‘‘% -
.
‘‘- .
ASCII
‘‘. 3
,
‘‘3 4
encoding
‘‘5 =
)
‘‘= >
)
‘‘> ?
{
’’ 
return
““ 
IsAscii
““ 
(
““ 
buf
““ "
,
““" #
index
““$ )
,
““) *
length
““+ 1
)
““1 2
;
““2 3
}
”” 
else
•• 
{
–– 
try
—— 
{
˜˜ 
if
™™ 
(
™™ 
buf
™™ 
.
™™ 
IoBufferCount
™™ )
==
™™* ,
$num
™™- .
)
™™. /
{
šš 
ArraySegment
›› $
<
››$ %
byte
››% )
>
››) *
segment
››+ 2
=
››3 4
buf
››5 8
.
››8 9
GetIoBuffer
››9 D
(
››D E
)
››E F
;
››F G
encoding
œœ  
.
œœ  !
GetChars
œœ! )
(
œœ) *
segment
œœ* 1
.
œœ1 2
Array
œœ2 7
,
œœ7 8
segment
œœ9 @
.
œœ@ A
Offset
œœA G
,
œœG H
segment
œœI P
.
œœP Q
Count
œœQ V
)
œœV W
;
œœW X
}
 
else
 
{
ŸŸ 
IByteBuffer
   #

heapBuffer
  $ .
=
  / 0
buf
  1 4
.
  4 5
	Allocator
  5 >
.
  > ?

HeapBuffer
  ? I
(
  I J
length
  J P
)
  P Q
;
  Q R
try
¡¡ 
{
¢¢ 

heapBuffer
££ &
.
££& '

WriteBytes
££' 1
(
££1 2
buf
££2 5
,
££5 6
index
££7 <
,
££< =
length
££> D
)
££D E
;
££E F
ArraySegment
¤¤ (
<
¤¤( )
byte
¤¤) -
>
¤¤- .
segment
¤¤/ 6
=
¤¤7 8

heapBuffer
¤¤9 C
.
¤¤C D
GetIoBuffer
¤¤D O
(
¤¤O P
)
¤¤P Q
;
¤¤Q R
encoding
¥¥ $
.
¥¥$ %
GetChars
¥¥% -
(
¥¥- .
segment
¥¥. 5
.
¥¥5 6
Array
¥¥6 ;
,
¥¥; <
segment
¥¥= D
.
¥¥D E
Offset
¥¥E K
,
¥¥K L
segment
¥¥M T
.
¥¥T U
Count
¥¥U Z
)
¥¥Z [
;
¥¥[ \
}
¦¦ 
finally
§§ 
{
¨¨ 

heapBuffer
©© &
.
©©& '
Release
©©' .
(
©©. /
)
©©/ 0
;
©©0 1
}
ªª 
}
«« 
return
¬¬ 
true
¬¬ 
;
¬¬  
}
­­ 
catch
®® 
{
¯¯ 
return
°° 
false
°°  
;
°°  !
}
±± 
}
²² 
}
³³ 	
static
µµ 
readonly
µµ 
FindNonAscii
µµ $ 
AsciiByteProcessor
µµ% 7
=
µµ8 9
new
µµ: =
FindNonAscii
µµ> J
(
µµJ K
)
µµK L
;
µµL M
sealed
·· 
class
·· 
FindNonAscii
·· !
:
··" #
IByteProcessor
··$ 2
{
¸¸ 	
public
¹¹ 
bool
¹¹ 
Process
¹¹ 
(
¹¹  
byte
¹¹  $
value
¹¹% *
)
¹¹* +
=>
¹¹, .
value
¹¹/ 4
<
¹¹5 6
$num
¹¹7 ;
;
¹¹; <
}
ºº 	
static
¼¼ 
bool
¼¼ 
IsAscii
¼¼ 
(
¼¼ 
IByteBuffer
¼¼ '
buf
¼¼( +
,
¼¼+ ,
int
¼¼- 0
index
¼¼1 6
,
¼¼6 7
int
¼¼8 ;
length
¼¼< B
)
¼¼B C
=>
¼¼D F
buf
¼¼G J
.
¼¼J K
ForEachByte
¼¼K V
(
¼¼V W
index
¼¼W \
,
¼¼\ ]
length
¼¼^ d
,
¼¼d e 
AsciiByteProcessor
¼¼f x
)
¼¼x y
==
¼¼z |
-
¼¼} ~
$num
¼¼~ 
;¼¼ €
static
¾¾ 
bool
¾¾ 
IsUtf8
¾¾ 
(
¾¾ 
IByteBuffer
¾¾ &
buf
¾¾' *
,
¾¾* +
int
¾¾, /
index
¾¾0 5
,
¾¾5 6
int
¾¾7 :
length
¾¾; A
)
¾¾A B
{
¿¿ 	
int
ÀÀ 
endIndex
ÀÀ 
=
ÀÀ 
index
ÀÀ  
+
ÀÀ! "
length
ÀÀ# )
;
ÀÀ) *
while
ÁÁ 
(
ÁÁ 
index
ÁÁ 
<
ÁÁ 
endIndex
ÁÁ #
)
ÁÁ# $
{
ÂÂ 
byte
ÃÃ 
b1
ÃÃ 
=
ÃÃ 
buf
ÃÃ 
.
ÃÃ 
GetByte
ÃÃ %
(
ÃÃ% &
index
ÃÃ& +
++
ÃÃ+ -
)
ÃÃ- .
;
ÃÃ. /
byte
ÄÄ 
b2
ÄÄ 
,
ÄÄ 
b3
ÄÄ 
;
ÄÄ 
if
ÅÅ 
(
ÅÅ 
(
ÅÅ 
b1
ÅÅ 
&
ÅÅ 
$num
ÅÅ 
)
ÅÅ 
==
ÅÅ  "
$num
ÅÅ# $
)
ÅÅ$ %
{
ÆÆ 
continue
ÈÈ 
;
ÈÈ 
}
ÉÉ 
if
ÊÊ 
(
ÊÊ 
(
ÊÊ 
b1
ÊÊ 
&
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
==
ÊÊ  "
$num
ÊÊ# '
)
ÊÊ' (
{
ËË 
if
ÑÑ 
(
ÑÑ 
index
ÑÑ 
>=
ÑÑ  
endIndex
ÑÑ! )
)
ÑÑ) *
{
ÒÒ 
return
ÓÓ 
false
ÓÓ $
;
ÓÓ$ %
}
ÔÔ 
b2
ÕÕ 
=
ÕÕ 
buf
ÕÕ 
.
ÕÕ 
GetByte
ÕÕ $
(
ÕÕ$ %
index
ÕÕ% *
++
ÕÕ* ,
)
ÕÕ, -
;
ÕÕ- .
if
ÖÖ 
(
ÖÖ 
(
ÖÖ 
b2
ÖÖ 
&
ÖÖ 
$num
ÖÖ "
)
ÖÖ" #
!=
ÖÖ$ &
$num
ÖÖ' +
)
ÖÖ+ ,
{
×× 
return
ØØ 
false
ØØ $
;
ØØ$ %
}
ÙÙ 
if
ÚÚ 
(
ÚÚ 
(
ÚÚ 
b1
ÚÚ 
&
ÚÚ 
$num
ÚÚ "
)
ÚÚ" #
<
ÚÚ$ %
$num
ÚÚ& *
)
ÚÚ* +
{
ÛÛ 
return
ÜÜ 
false
ÜÜ $
;
ÜÜ$ %
}
İİ 
}
ŞŞ 
else
ßß 
if
ßß 
(
ßß 
(
ßß 
b1
ßß 
&
ßß 
$num
ßß #
)
ßß# $
==
ßß% '
$num
ßß( ,
)
ßß, -
{
àà 
if
éé 
(
éé 
index
éé 
>
éé 
endIndex
éé  (
-
éé) *
$num
éé+ ,
)
éé, -
{
êê 
return
ëë 
false
ëë $
;
ëë$ %
}
ìì 
b2
íí 
=
íí 
buf
íí 
.
íí 
GetByte
íí $
(
íí$ %
index
íí% *
++
íí* ,
)
íí, -
;
íí- .
b3
îî 
=
îî 
buf
îî 
.
îî 
GetByte
îî $
(
îî$ %
index
îî% *
++
îî* ,
)
îî, -
;
îî- .
if
ïï 
(
ïï 
(
ïï 
b2
ïï 
&
ïï 
$num
ïï "
)
ïï" #
!=
ïï$ &
$num
ïï' +
||
ïï, .
(
ïï/ 0
b3
ïï0 2
&
ïï3 4
$num
ïï5 9
)
ïï9 :
!=
ïï; =
$num
ïï> B
)
ïïB C
{
ğğ 
return
ññ 
false
ññ $
;
ññ$ %
}
òò 
if
óó 
(
óó 
(
óó 
b1
óó 
&
óó 
$num
óó "
)
óó" #
==
óó$ &
$num
óó' +
&&
óó, .
(
óó/ 0
b2
óó0 2
&
óó3 4
$num
óó5 9
)
óó9 :
<
óó; <
$num
óó= A
)
óóA B
{
ôô 
return
õõ 
false
õõ $
;
õõ$ %
}
öö 
if
÷÷ 
(
÷÷ 
(
÷÷ 
b1
÷÷ 
&
÷÷ 
$num
÷÷ "
)
÷÷" #
==
÷÷$ &
$num
÷÷' +
&&
÷÷, .
(
÷÷/ 0
b2
÷÷0 2
&
÷÷3 4
$num
÷÷5 9
)
÷÷9 :
>
÷÷; <
$num
÷÷= A
)
÷÷A B
{
øø 
return
ùù 
false
ùù $
;
ùù$ %
}
úú 
}
ûû 
else
üü 
if
üü 
(
üü 
(
üü 
b1
üü 
&
üü 
$num
üü #
)
üü# $
==
üü% '
$num
üü( ,
)
üü, -
{
ıı 
if
…	…	 
(
…	…	 
index
…	…	 
>
…	…	 
endIndex
…	…	  (
-
…	…	) *
$num
…	…	+ ,
)
…	…	, -
{
†	†	 
return
‡	‡	 
false
‡	‡	 $
;
‡	‡	$ %
}
ˆ	ˆ	 
b2
‰	‰	 
=
‰	‰	 
buf
‰	‰	 
.
‰	‰	 
GetByte
‰	‰	 $
(
‰	‰	$ %
index
‰	‰	% *
++
‰	‰	* ,
)
‰	‰	, -
;
‰	‰	- .
b3
Š	Š	 
=
Š	Š	 
buf
Š	Š	 
.
Š	Š	 
GetByte
Š	Š	 $
(
Š	Š	$ %
index
Š	Š	% *
++
Š	Š	* ,
)
Š	Š	, -
;
Š	Š	- .
byte
‹	‹	 
b4
‹	‹	 
=
‹	‹	 
buf
‹	‹	 !
.
‹	‹	! "
GetByte
‹	‹	" )
(
‹	‹	) *
index
‹	‹	* /
++
‹	‹	/ 1
)
‹	‹	1 2
;
‹	‹	2 3
if
Œ	Œ	 
(
Œ	Œ	 
(
Œ	Œ	 
b2
Œ	Œ	 
&
Œ	Œ	 
$num
Œ	Œ	 "
)
Œ	Œ	" #
!=
Œ	Œ	$ &
$num
Œ	Œ	' +
||
Œ	Œ	, .
(
Œ	Œ	/ 0
b3
Œ	Œ	0 2
&
Œ	Œ	3 4
$num
Œ	Œ	5 9
)
Œ	Œ	9 :
!=
Œ	Œ	; =
$num
Œ	Œ	> B
||
Œ	Œ	C E
(
Œ	Œ	F G
b4
Œ	Œ	G I
&
Œ	Œ	J K
$num
Œ	Œ	L P
)
Œ	Œ	P Q
!=
Œ	Œ	R T
$num
Œ	Œ	U Y
)
Œ	Œ	Y Z
{
		 
return
		 
false
		 $
;
		$ %
}
		 
if
‘	‘	 
(
‘	‘	 
(
‘	‘	 
b1
‘	‘	 
&
‘	‘	 
$num
‘	‘	 "
)
‘	‘	" #
>
‘	‘	$ %
$num
‘	‘	& *
||
’	’	 
(
’	’	 
b1
’	’	 
&
’	’	  
$num
’	’	! %
)
’	’	% &
==
’	’	' )
$num
’	’	* .
&&
’	’	/ 1
(
’	’	2 3
b2
’	’	3 5
&
’	’	6 7
$num
’	’	8 <
)
’	’	< =
<
’	’	> ?
$num
’	’	@ D
||
“	“	 
(
“	“	 
b1
“	“	 
&
“	“	  
$num
“	“	! %
)
“	“	% &
==
“	“	' )
$num
“	“	* .
&&
“	“	/ 1
(
“	“	2 3
b2
“	“	3 5
&
“	“	6 7
$num
“	“	8 <
)
“	“	< =
>
“	“	> ?
$num
“	“	@ D
)
“	“	D E
{
”	”	 
return
•	•	 
false
•	•	 $
;
•	•	$ %
}
–	–	 
}
—	—	 
else
˜	˜	 
{
™	™	 
return
š	š	 
false
š	š	  
;
š	š	  !
}
›	›	 
}
œ	œ	 
return
		 
true
		 
;
		 
}
Ÿ	Ÿ	 	
public
¡	¡	 
static
¡	¡	 
unsafe
¡	¡	 
int
¡	¡	  
SingleToInt32Bits
¡	¡	! 2
(
¡	¡	2 3
float
¡	¡	3 8
value
¡	¡	9 >
)
¡	¡	> ?
{
¢	¢	 	
return
£	£	 
*
£	£	 
(
£	£	 
int
£	£	 
*
£	£	 
)
£	£	 
(
£	£	 
&
£	£	 
value
£	£	 !
)
£	£	! "
;
£	£	" #
}
¤	¤	 	
public
¦	¦	 
static
¦	¦	 
unsafe
¦	¦	 
float
¦	¦	 "
Int32BitsToSingle
¦	¦	# 4
(
¦	¦	4 5
int
¦	¦	5 8
value
¦	¦	9 >
)
¦	¦	> ?
{
§	§	 	
return
¨	¨	 
*
¨	¨	 
(
¨	¨	 
float
¨	¨	 
*
¨	¨	 
)
¨	¨	 
(
¨	¨	 
&
¨	¨	 
value
¨	¨	 #
)
¨	¨	# $
;
¨	¨	$ %
}
©	©	 	
public
®	®	 
static
®	®	 
long
®	®	 
SwapLong
®	®	 #
(
®	®	# $
long
®	®	$ (
value
®	®	) .
)
®	®	. /
=>
¯	¯	 
(
¯	¯	 
(
¯	¯	 
SwapInt
¯	¯	 
(
¯	¯	 
(
¯	¯	 
int
¯	¯	 
)
¯	¯	 
value
¯	¯	 #
)
¯	¯	# $
&
¯	¯	% &
$num
¯	¯	' 1
)
¯	¯	1 2
<<
¯	¯	3 5
$num
¯	¯	6 8
)
¯	¯	8 9
|
°	°	 
(
°	°	 
SwapInt
°	°	 
(
°	°	 
(
°	°	 
int
°	°	 
)
°	°	  
(
°	°	  !
value
°	°	! &
>>
°	°	' )
$num
°	°	* ,
)
°	°	, -
)
°	°	- .
&
°	°	/ 0
$num
°	°	1 ;
)
°	°	; <
;
°	°	< =
public
µ	µ	 
static
µ	µ	 
int
µ	µ	 
SwapInt
µ	µ	 !
(
µ	µ	! "
int
µ	µ	" %
value
µ	µ	& +
)
µ	µ	+ ,
=>
¶	¶	 
(
¶	¶	 
(
¶	¶	 
	SwapShort
¶	¶	 
(
¶	¶	 
(
¶	¶	 
short
¶	¶	 !
)
¶	¶	! "
value
¶	¶	" '
)
¶	¶	' (
&
¶	¶	) *
$num
¶	¶	+ 1
)
¶	¶	1 2
<<
¶	¶	3 5
$num
¶	¶	6 8
)
¶	¶	8 9
|
·	·	 
(
·	·	 
	SwapShort
·	·	 
(
·	·	 
(
·	·	 
short
·	·	 #
)
·	·	# $
(
·	·	$ %
value
·	·	% *
>>
·	·	+ -
$num
·	·	. 0
)
·	·	0 1
)
·	·	1 2
&
·	·	3 4
$num
·	·	5 ;
)
·	·	; <
;
·	·	< =
public
¼	¼	 
static
¼	¼	 
short
¼	¼	 
	SwapShort
¼	¼	 %
(
¼	¼	% &
short
¼	¼	& +
value
¼	¼	, 1
)
¼	¼	1 2
=>
¼	¼	3 5
(
¼	¼	6 7
short
¼	¼	7 <
)
¼	¼	< =
(
¼	¼	= >
(
¼	¼	> ?
(
¼	¼	? @
value
¼	¼	@ E
&
¼	¼	F G
$num
¼	¼	H L
)
¼	¼	L M
<<
¼	¼	N P
$num
¼	¼	Q R
)
¼	¼	R S
|
¼	¼	T U
(
¼	¼	V W
value
¼	¼	W \
>>
¼	¼	] _
$num
¼	¼	` a
)
¼	¼	a b
&
¼	¼	c d
$num
¼	¼	e i
)
¼	¼	i j
;
¼	¼	j k
}
¾	¾	 
}¿	¿	 ¤
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ByteOrder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

enum 
	ByteOrder 
{ 
LittleEndian 
= 
$num 
, 
	BigEndian 
= 
$num 
} 
} ‹µ
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\CompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class 
CompositeByteBuffer $
:% &.
"AbstractReferenceCountedByteBuffer' I
,I J
IEnumerableK V
<V W
IByteBufferW b
>b c
{ 
static 
readonly 
IList 
< 
IByteBuffer )
>) *
	EmptyList+ 4
=5 6
new7 :
ReadOnlyCollection; M
<M N
IByteBufferN Y
>Y Z
(Z [
new[ ^
IByteBuffer_ j
[j k
$numk l
]l m
)m n
;n o
class 
ComponentEntry 
{ 	
public 
readonly 
IByteBuffer '
Buffer( .
;. /
public 
readonly 
int 
Length  &
;& '
public 
int 
Offset 
; 
public 
int 
	EndOffset  
;  !
public 
ComponentEntry !
(! "
IByteBuffer" -
buffer. 4
)4 5
{   
this!! 
.!! 
Buffer!! 
=!! 
buffer!! $
;!!$ %
this"" 
."" 
Length"" 
="" 
buffer"" $
.""$ %
ReadableBytes""% 2
;""2 3
}## 
public%% 
void%% 
FreeIfNecessary%% '
(%%' (
)%%( )
=>%%* ,
this%%- 1
.%%1 2
Buffer%%2 8
.%%8 9
Release%%9 @
(%%@ A
)%%A B
;%%B C
}&& 	
static(( 
readonly(( 
ArraySegment(( $
<(($ %
byte((% )
>(() *
EmptyNioBuffer((+ 9
=((: ;
Unpooled((< D
.((D E
Empty((E J
.((J K
GetIoBuffer((K V
(((V W
)((W X
;((X Y
readonly**  
IByteBufferAllocator** %
	allocator**& /
;**/ 0
readonly++ 
bool++ 
direct++ 
;++ 
readonly,, 
List,, 
<,, 
ComponentEntry,, $
>,,$ %

components,,& 0
;,,0 1
readonly-- 
int-- 
maxNumComponents-- %
;--% &
bool// 
freed// 
;// 
public11 
CompositeByteBuffer11 "
(11" # 
IByteBufferAllocator11# 7
	allocator118 A
,11A B
bool11C G
direct11H N
,11N O
int11P S
maxNumComponents11T d
)11d e
:22 
base22 
(22 '
AbstractByteBufferAllocator22 .
.22. /
DefaultMaxCapacity22/ A
)22A B
{33 	
Contract44 
.44 
Requires44 
(44 
	allocator44 '
!=44( *
null44+ /
)44/ 0
;440 1
Contract55 
.55 
Requires55 
(55 
maxNumComponents55 .
>=55/ 1
$num552 3
)553 4
;554 5
this77 
.77 
	allocator77 
=77 
	allocator77 &
;77& '
this88 
.88 
direct88 
=88 
direct88  
;88  !
this99 
.99 
maxNumComponents99 !
=99" #
maxNumComponents99$ 4
;994 5
this:: 
.:: 

components:: 
=:: 
NewList:: %
(::% &
maxNumComponents::& 6
)::6 7
;::7 8
};; 	
public== 
CompositeByteBuffer== "
(==" # 
IByteBufferAllocator==# 7
	allocator==8 A
,==A B
bool==C G
direct==H N
,==N O
int==P S
maxNumComponents==T d
,==d e
params==f l
IByteBuffer==m x
[==x y
]==y z
buffers	=={ ‚
)
==‚ ƒ
:>> 
this>> 
(>> 
	allocator>> 
,>> 
direct>> $
,>>$ %
maxNumComponents>>& 6
,>>6 7
buffers>>8 ?
,>>? @
$num>>A B
,>>B C
buffers>>D K
.>>K L
Length>>L R
)>>R S
{?? 	
}@@ 	
internalBB 
CompositeByteBufferBB $
(BB$ % 
IByteBufferAllocatorBB% 9
	allocatorBB: C
,BBC D
boolBBE I
directBBJ P
,BBP Q
intBBR U
maxNumComponentsBBV f
,BBf g
IByteBufferBBh s
[BBs t
]BBt u
buffersBBv }
,BB} ~
int	BB ‚
offset
BBƒ ‰
,
BB‰ Š
int
BB‹ 
length
BB •
)
BB• –
:CC 
baseCC 
(CC '
AbstractByteBufferAllocatorCC .
.CC. /
DefaultMaxCapacityCC/ A
)CCA B
{DD 	
ContractEE 
.EE 
RequiresEE 
(EE 
	allocatorEE '
!=EE( *
nullEE+ /
)EE/ 0
;EE0 1
ContractFF 
.FF 
RequiresFF 
(FF 
maxNumComponentsFF .
>=FF/ 1
$numFF2 3
)FF3 4
;FF4 5
thisHH 
.HH 
	allocatorHH 
=HH 
	allocatorHH &
;HH& '
thisII 
.II 
directII 
=II 
directII  
;II  !
thisJJ 
.JJ 
maxNumComponentsJJ !
=JJ" #
maxNumComponentsJJ$ 4
;JJ4 5
thisKK 
.KK 

componentsKK 
=KK 
NewListKK %
(KK% &
maxNumComponentsKK& 6
)KK6 7
;KK7 8
thisMM 
.MM 
AddComponents0MM 
(MM  
falseMM  %
,MM% &
$numMM' (
,MM( )
buffersMM* 1
,MM1 2
offsetMM3 9
,MM9 :
lengthMM; A
)MMA B
;MMB C
thisNN 
.NN 
ConsolidateIfNeededNN $
(NN$ %
)NN% &
;NN& '
thisOO 
.OO 
	SetIndex0OO 
(OO 
$numOO 
,OO 
GetCapacityOO )
(OO) *
thisOO* .
.OO. /

componentsOO/ 9
)OO9 :
)OO: ;
;OO; <
}PP 	
publicRR 
CompositeByteBufferRR "
(RR" # 
IByteBufferAllocatorSS  
	allocatorSS! *
,SS* +
boolSS, 0
directSS1 7
,SS7 8
intSS9 <
maxNumComponentsSS= M
,SSM N
IEnumerableSSO Z
<SSZ [
IByteBufferSS[ f
>SSf g
buffersSSh o
)SSo p
:TT 
baseTT 
(TT '
AbstractByteBufferAllocatorTT .
.TT. /
DefaultMaxCapacityTT/ A
)TTA B
{UU 	
ContractVV 
.VV 
RequiresVV 
(VV 
	allocatorVV '
!=VV( *
nullVV+ /
)VV/ 0
;VV0 1
ContractWW 
.WW 
RequiresWW 
(WW 
maxNumComponentsWW .
>=WW/ 1
$numWW2 3
)WW3 4
;WW4 5
thisYY 
.YY 
	allocatorYY 
=YY 
	allocatorYY &
;YY& '
thisZZ 
.ZZ 
directZZ 
=ZZ 
directZZ  
;ZZ  !
this[[ 
.[[ 
maxNumComponents[[ !
=[[" #
maxNumComponents[[$ 4
;[[4 5
this\\ 
.\\ 

components\\ 
=\\ 
NewList\\ %
(\\% &
maxNumComponents\\& 6
)\\6 7
;\\7 8
this^^ 
.^^ 
AddComponents0^^ 
(^^  
false^^  %
,^^% &
$num^^' (
,^^( )
buffers^^* 1
)^^1 2
;^^2 3
this__ 
.__ 
ConsolidateIfNeeded__ $
(__$ %
)__% &
;__& '
this`` 
.`` 
	SetIndex0`` 
(`` 
$num`` 
,`` 
GetCapacity`` )
(``) *
this``* .
.``. /

components``/ 9
)``9 :
)``: ;
;``; <
}aa 	
staticcc 
Listcc 
<cc 
ComponentEntrycc "
>cc" #
NewListcc$ +
(cc+ ,
intcc, /
maxNumComponentscc0 @
)cc@ A
=>ccB D
newdd 
Listdd 
<dd 
ComponentEntrydd #
>dd# $
(dd$ %
Mathdd% )
.dd) *
Mindd* -
(dd- .'
AbstractByteBufferAllocatordd. I
.ddI J 
DefaultMaxComponentsddJ ^
,dd^ _
maxNumComponentsdd` p
)ddp q
)ddq r
;ddr s
internalgg 
CompositeByteBuffergg $
(gg$ % 
IByteBufferAllocatorgg% 9
	allocatorgg: C
)ggC D
:ggE F
baseggG K
(ggK L
intggL O
.ggO P
MaxValueggP X
)ggX Y
{hh 	
thisii 
.ii 
	allocatorii 
=ii 
	allocatorii &
;ii& '
thisjj 
.jj 
directjj 
=jj 
falsejj 
;jj  
thiskk 
.kk 
maxNumComponentskk !
=kk" #
$numkk$ %
;kk% &
thisll 
.ll 

componentsll 
=ll 
newll !
Listll" &
<ll& '
ComponentEntryll' 5
>ll5 6
(ll6 7
$numll7 8
)ll8 9
;ll9 :
}mm 	
publicuu 
virtualuu 
CompositeByteBufferuu *
AddComponentuu+ 7
(uu7 8
IByteBufferuu8 C
bufferuuD J
)uuJ K
=>uuL N
thisuuO S
.uuS T
AddComponentuuT `
(uu` a
falseuua f
,uuf g
bufferuuh n
)uun o
;uuo p
public}} 
virtual}} 
CompositeByteBuffer}} *
AddComponents}}+ 8
(}}8 9
params}}9 ?
IByteBuffer}}@ K
[}}K L
]}}L M
buffers}}N U
)}}U V
=>}}W Y
this}}Z ^
.}}^ _
AddComponents}}_ l
(}}l m
false}}m r
,}}r s
buffers}}t {
)}}{ |
;}}| }
public
…… 
virtual
…… !
CompositeByteBuffer
…… *
AddComponents
……+ 8
(
……8 9
IEnumerable
……9 D
<
……D E
IByteBuffer
……E P
>
……P Q
buffers
……R Y
)
……Y Z
=>
……[ ]
this
……^ b
.
……b c
AddComponents
……c p
(
……p q
false
……q v
,
……v w
buffers
……x 
)…… €
;……€ 
public
 
virtual
 !
CompositeByteBuffer
 *
AddComponent
+ 7
(
7 8
int
8 ;
cIndex
< B
,
B C
IByteBuffer
D O
buffer
P V
)
V W
=>
X Z
this
[ _
.
_ `
AddComponent
` l
(
l m
false
m r
,
r s
cIndex
t z
,
z {
buffer| ‚
)‚ ƒ
;ƒ „
public
 
virtual
 !
CompositeByteBuffer
 *
AddComponent
+ 7
(
7 8
bool
8 <!
increaseWriterIndex
= P
,
P Q
IByteBuffer
R ]
buffer
^ d
)
d e
{
‘‘ 	
Contract
’’ 
.
’’ 
Requires
’’ 
(
’’ 
buffer
’’ $
!=
’’% '
null
’’( ,
)
’’, -
;
’’- .
this
““ 
.
““ 
AddComponent0
““ 
(
““ !
increaseWriterIndex
““ 2
,
““2 3
this
““4 8
.
““8 9

components
““9 C
.
““C D
Count
““D I
,
““I J
buffer
““K Q
)
““Q R
;
““R S
this
”” 
.
”” !
ConsolidateIfNeeded
”” $
(
””$ %
)
””% &
;
””& '
return
•• 
this
•• 
;
•• 
}
–– 	
public
˜˜ 
virtual
˜˜ !
CompositeByteBuffer
˜˜ *
AddComponents
˜˜+ 8
(
˜˜8 9
bool
˜˜9 =!
increaseWriterIndex
˜˜> Q
,
˜˜Q R
params
˜˜S Y
IByteBuffer
˜˜Z e
[
˜˜e f
]
˜˜f g
buffers
˜˜h o
)
˜˜o p
{
™™ 	
this
šš 
.
šš 
AddComponents0
šš 
(
šš  !
increaseWriterIndex
šš  3
,
šš3 4
this
šš5 9
.
šš9 :

components
šš: D
.
ššD E
Count
ššE J
,
ššJ K
buffers
ššL S
,
ššS T
$num
ššU V
,
ššV W
buffers
ššX _
.
šš_ `
Length
šš` f
)
ššf g
;
ššg h
this
›› 
.
›› !
ConsolidateIfNeeded
›› $
(
››$ %
)
››% &
;
››& '
return
œœ 
this
œœ 
;
œœ 
}
 	
public
ŸŸ 
virtual
ŸŸ !
CompositeByteBuffer
ŸŸ *
AddComponents
ŸŸ+ 8
(
ŸŸ8 9
bool
ŸŸ9 =!
increaseWriterIndex
ŸŸ> Q
,
ŸŸQ R
IEnumerable
ŸŸS ^
<
ŸŸ^ _
IByteBuffer
ŸŸ_ j
>
ŸŸj k
buffers
ŸŸl s
)
ŸŸs t
{
   	
this
¡¡ 
.
¡¡ 
AddComponents0
¡¡ 
(
¡¡  !
increaseWriterIndex
¡¡  3
,
¡¡3 4
this
¡¡5 9
.
¡¡9 :

components
¡¡: D
.
¡¡D E
Count
¡¡E J
,
¡¡J K
buffers
¡¡L S
)
¡¡S T
;
¡¡T U
this
¢¢ 
.
¢¢ !
ConsolidateIfNeeded
¢¢ $
(
¢¢$ %
)
¢¢% &
;
¢¢& '
return
££ 
this
££ 
;
££ 
}
¤¤ 	
public
¦¦ 
virtual
¦¦ !
CompositeByteBuffer
¦¦ *
AddComponent
¦¦+ 7
(
¦¦7 8
bool
¦¦8 <!
increaseWriterIndex
¦¦= P
,
¦¦P Q
int
¦¦R U
cIndex
¦¦V \
,
¦¦\ ]
IByteBuffer
¦¦^ i
buffer
¦¦j p
)
¦¦p q
{
§§ 	
Contract
¨¨ 
.
¨¨ 
Requires
¨¨ 
(
¨¨ 
buffer
¨¨ $
!=
¨¨% '
null
¨¨( ,
)
¨¨, -
;
¨¨- .
this
©© 
.
©© 
AddComponent0
©© 
(
©© !
increaseWriterIndex
©© 2
,
©©2 3
cIndex
©©4 :
,
©©: ;
buffer
©©< B
)
©©B C
;
©©C D
this
ªª 
.
ªª !
ConsolidateIfNeeded
ªª $
(
ªª$ %
)
ªª% &
;
ªª& '
return
«« 
this
«« 
;
«« 
}
¬¬ 	
int
®® 
AddComponent0
®® 
(
®® 
bool
®® !
increaseWriterIndex
®® 2
,
®®2 3
int
®®4 7
cIndex
®®8 >
,
®®> ?
IByteBuffer
®®@ K
buffer
®®L R
)
®®R S
{
¯¯ 	
bool
°° 
wasAdded
°° 
=
°° 
false
°° !
;
°°! "
try
±± 
{
²² 
this
³³ 
.
³³ !
CheckComponentIndex
³³ (
(
³³( )
cIndex
³³) /
)
³³/ 0
;
³³0 1
int
µµ 
readableBytes
µµ !
=
µµ" #
buffer
µµ$ *
.
µµ* +
ReadableBytes
µµ+ 8
;
µµ8 9
var
¸¸ 
c
¸¸ 
=
¸¸ 
new
¸¸ 
ComponentEntry
¸¸ *
(
¸¸* +
buffer
¸¸+ 1
.
¸¸1 2
Slice
¸¸2 7
(
¸¸7 8
)
¸¸8 9
)
¸¸9 :
;
¸¸: ;
if
¹¹ 
(
¹¹ 
cIndex
¹¹ 
==
¹¹ 
this
¹¹ "
.
¹¹" #

components
¹¹# -
.
¹¹- .
Count
¹¹. 3
)
¹¹3 4
{
ºº 
this
»» 
.
»» 

components
»» #
.
»»# $
Add
»»$ '
(
»»' (
c
»»( )
)
»») *
;
»»* +
wasAdded
¼¼ 
=
¼¼ 
true
¼¼ #
;
¼¼# $
if
½½ 
(
½½ 
cIndex
½½ 
==
½½ !
$num
½½" #
)
½½# $
{
¾¾ 
c
¿¿ 
.
¿¿ 
	EndOffset
¿¿ #
=
¿¿$ %
readableBytes
¿¿& 3
;
¿¿3 4
}
ÀÀ 
else
ÁÁ 
{
ÂÂ 
ComponentEntry
ÃÃ &
prev
ÃÃ' +
=
ÃÃ, -
this
ÃÃ. 2
.
ÃÃ2 3

components
ÃÃ3 =
[
ÃÃ= >
cIndex
ÃÃ> D
-
ÃÃE F
$num
ÃÃG H
]
ÃÃH I
;
ÃÃI J
c
ÄÄ 
.
ÄÄ 
Offset
ÄÄ  
=
ÄÄ! "
prev
ÄÄ# '
.
ÄÄ' (
	EndOffset
ÄÄ( 1
;
ÄÄ1 2
c
ÅÅ 
.
ÅÅ 
	EndOffset
ÅÅ #
=
ÅÅ$ %
c
ÅÅ& '
.
ÅÅ' (
Offset
ÅÅ( .
+
ÅÅ/ 0
readableBytes
ÅÅ1 >
;
ÅÅ> ?
}
ÆÆ 
}
ÇÇ 
else
ÈÈ 
{
ÉÉ 
this
ÊÊ 
.
ÊÊ 

components
ÊÊ #
.
ÊÊ# $
Insert
ÊÊ$ *
(
ÊÊ* +
cIndex
ÊÊ+ 1
,
ÊÊ1 2
c
ÊÊ3 4
)
ÊÊ4 5
;
ÊÊ5 6
wasAdded
ËË 
=
ËË 
true
ËË #
;
ËË# $
if
ÌÌ 
(
ÌÌ 
readableBytes
ÌÌ %
!=
ÌÌ& (
$num
ÌÌ) *
)
ÌÌ* +
{
ÍÍ 
this
ÎÎ 
.
ÎÎ $
UpdateComponentOffsets
ÎÎ 3
(
ÎÎ3 4
cIndex
ÎÎ4 :
)
ÎÎ: ;
;
ÎÎ; <
}
ÏÏ 
}
ĞĞ 
if
ÑÑ 
(
ÑÑ !
increaseWriterIndex
ÑÑ '
)
ÑÑ' (
{
ÒÒ 
this
ÓÓ 
.
ÓÓ 
SetWriterIndex
ÓÓ '
(
ÓÓ' (
this
ÓÓ( ,
.
ÓÓ, -
WriterIndex
ÓÓ- 8
+
ÓÓ9 :
buffer
ÓÓ; A
.
ÓÓA B
ReadableBytes
ÓÓB O
)
ÓÓO P
;
ÓÓP Q
}
ÔÔ 
return
ÕÕ 
cIndex
ÕÕ 
;
ÕÕ 
}
ÖÖ 
finally
×× 
{
ØØ 
if
ÙÙ 
(
ÙÙ 
!
ÙÙ 
wasAdded
ÙÙ 
)
ÙÙ 
{
ÚÚ 
buffer
ÛÛ 
.
ÛÛ 
Release
ÛÛ "
(
ÛÛ" #
)
ÛÛ# $
;
ÛÛ$ %
}
ÜÜ 
}
İİ 
}
ŞŞ 	
public
çç 
virtual
çç !
CompositeByteBuffer
çç *
AddComponents
çç+ 8
(
çç8 9
int
çç9 <
cIndex
çç= C
,
ççC D
params
ççE K
IByteBuffer
ççL W
[
ççW X
]
ççX Y
buffers
ççZ a
)
çça b
{
èè 	
this
éé 
.
éé 
AddComponents0
éé 
(
éé  
false
éé  %
,
éé% &
cIndex
éé' -
,
éé- .
buffers
éé/ 6
,
éé6 7
$num
éé8 9
,
éé9 :
buffers
éé; B
.
ééB C
Length
ééC I
)
ééI J
;
ééJ K
this
êê 
.
êê !
ConsolidateIfNeeded
êê $
(
êê$ %
)
êê% &
;
êê& '
return
ëë 
this
ëë 
;
ëë 
}
ìì 	
int
îî 
AddComponents0
îî 
(
îî 
bool
îî !
increaseWriterIndex
îî  3
,
îî3 4
int
îî5 8
cIndex
îî9 ?
,
îî? @
IByteBuffer
îîA L
[
îîL M
]
îîM N
buffers
îîO V
,
îîV W
int
îîX [
offset
îî\ b
,
îîb c
int
îîd g
len
îîh k
)
îîk l
{
ïï 	
Contract
ğğ 
.
ğğ 
Requires
ğğ 
(
ğğ 
buffers
ğğ %
!=
ğğ& (
null
ğğ) -
)
ğğ- .
;
ğğ. /
int
ññ 
i
ññ 
=
ññ 
offset
ññ 
;
ññ 
try
òò 
{
óó 
this
ôô 
.
ôô !
CheckComponentIndex
ôô (
(
ôô( )
cIndex
ôô) /
)
ôô/ 0
;
ôô0 1
while
÷÷ 
(
÷÷ 
i
÷÷ 
<
÷÷ 
len
÷÷ 
)
÷÷ 
{
øø 
IByteBuffer
ûû 
b
ûû  !
=
ûû" #
buffers
ûû$ +
[
ûû+ ,
i
ûû, -
++
ûû- /
]
ûû/ 0
;
ûû0 1
if
üü 
(
üü 
b
üü 
==
üü 
null
üü !
)
üü! "
{
ıı 
break
şş 
;
şş 
}
ÿÿ 
cIndex
€€ 
=
€€ 
this
€€ !
.
€€! "
AddComponent0
€€" /
(
€€/ 0!
increaseWriterIndex
€€0 C
,
€€C D
cIndex
€€E K
,
€€K L
b
€€M N
)
€€N O
+
€€P Q
$num
€€R S
;
€€S T
int
 
size
 
=
 
this
 #
.
# $

components
$ .
.
. /
Count
/ 4
;
4 5
if
‚‚ 
(
‚‚ 
cIndex
‚‚ 
>
‚‚  
size
‚‚! %
)
‚‚% &
{
ƒƒ 
cIndex
„„ 
=
„„  
size
„„! %
;
„„% &
}
…… 
}
†† 
return
ˆˆ 
cIndex
ˆˆ 
;
ˆˆ 
}
‰‰ 
finally
ŠŠ 
{
‹‹ 
for
ŒŒ 
(
ŒŒ 
;
ŒŒ 
i
ŒŒ 
<
ŒŒ 
len
ŒŒ 
;
ŒŒ 
++
ŒŒ  "
i
ŒŒ" #
)
ŒŒ# $
{
 
IByteBuffer
 
b
  !
=
" #
buffers
$ +
[
+ ,
i
, -
]
- .
;
. /
if
 
(
 
b
 
!=
 
null
 !
)
! "
{
 
try
‘‘ 
{
’’ 
b
““ 
.
““ 
Release
““ %
(
““% &
)
““& '
;
““' (
}
”” 
catch
•• 
{
–– 
}
˜˜ 
}
™™ 
}
šš 
}
›› 
}
œœ 	
public
¥¥ 
virtual
¥¥ !
CompositeByteBuffer
¥¥ *
AddComponents
¥¥+ 8
(
¥¥8 9
int
¥¥9 <
cIndex
¥¥= C
,
¥¥C D
IEnumerable
¥¥E P
<
¥¥P Q
IByteBuffer
¥¥Q \
>
¥¥\ ]
buffers
¥¥^ e
)
¥¥e f
{
¦¦ 	
this
§§ 
.
§§ 
AddComponents0
§§ 
(
§§  
false
§§  %
,
§§% &
cIndex
§§' -
,
§§- .
buffers
§§/ 6
)
§§6 7
;
§§7 8
this
¨¨ 
.
¨¨ !
ConsolidateIfNeeded
¨¨ $
(
¨¨$ %
)
¨¨% &
;
¨¨& '
return
©© 
this
©© 
;
©© 
}
ªª 	
int
¬¬ 
AddComponents0
¬¬ 
(
¬¬ 
bool
¬¬ 
increaseIndex
¬¬  -
,
¬¬- .
int
¬¬/ 2
cIndex
¬¬3 9
,
¬¬9 :
IEnumerable
¬¬; F
<
¬¬F G
IByteBuffer
¬¬G R
>
¬¬R S
buffers
¬¬T [
)
¬¬[ \
{
­­ 	
Contract
®® 
.
®® 
Requires
®® 
(
®® 
buffers
®® %
!=
®®& (
null
®®) -
)
®®- .
;
®®. /
if
°° 
(
°° 
buffers
°° 
is
°° 
IByteBuffer
°° &
buffer
°°' -
)
°°- .
{
±± 
return
³³ 
this
³³ 
.
³³ 
AddComponent0
³³ )
(
³³) *
increaseIndex
³³* 7
,
³³7 8
cIndex
³³9 ?
,
³³? @
buffer
³³A G
)
³³G H
;
³³H I
}
´´ 
IByteBuffer
¶¶ 
[
¶¶ 
]
¶¶ 
array
¶¶ 
=
¶¶  !
buffers
¶¶" )
.
¶¶) *
ToArray
¶¶* 1
(
¶¶1 2
)
¶¶2 3
;
¶¶3 4
return
·· 
this
·· 
.
·· 
AddComponents0
·· &
(
··& '
increaseIndex
··' 4
,
··4 5
cIndex
··6 <
,
··< =
array
··> C
,
··C D
$num
··E F
,
··F G
array
··H M
.
··M N
Length
··N T
)
··T U
;
··U V
}
¸¸ 	
void
¾¾ !
ConsolidateIfNeeded
¾¾  
(
¾¾  !
)
¾¾! "
{
¿¿ 	
int
ÂÂ 
numComponents
ÂÂ 
=
ÂÂ 
this
ÂÂ  $
.
ÂÂ$ %

components
ÂÂ% /
.
ÂÂ/ 0
Count
ÂÂ0 5
;
ÂÂ5 6
if
ÃÃ 
(
ÃÃ 
numComponents
ÃÃ 
>
ÃÃ 
this
ÃÃ  $
.
ÃÃ$ %
MaxNumComponents
ÃÃ% 5
)
ÃÃ5 6
{
ÄÄ 
int
ÅÅ 
capacity
ÅÅ 
=
ÅÅ 
this
ÅÅ #
.
ÅÅ# $

components
ÅÅ$ .
[
ÅÅ. /
numComponents
ÅÅ/ <
-
ÅÅ= >
$num
ÅÅ? @
]
ÅÅ@ A
.
ÅÅA B
	EndOffset
ÅÅB K
;
ÅÅK L
IByteBuffer
ÇÇ 
consolidated
ÇÇ (
=
ÇÇ) *
this
ÇÇ+ /
.
ÇÇ/ 0
AllocateBuffer
ÇÇ0 >
(
ÇÇ> ?
capacity
ÇÇ? G
)
ÇÇG H
;
ÇÇH I
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ  !
<
ÊÊ" #
numComponents
ÊÊ$ 1
;
ÊÊ1 2
i
ÊÊ3 4
++
ÊÊ4 6
)
ÊÊ6 7
{
ËË 
ComponentEntry
ÌÌ "
c1
ÌÌ# %
=
ÌÌ& '
this
ÌÌ( ,
.
ÌÌ, -

components
ÌÌ- 7
[
ÌÌ7 8
i
ÌÌ8 9
]
ÌÌ9 :
;
ÌÌ: ;
IByteBuffer
ÍÍ 
b
ÍÍ  !
=
ÍÍ" #
c1
ÍÍ$ &
.
ÍÍ& '
Buffer
ÍÍ' -
;
ÍÍ- .
consolidated
ÎÎ  
.
ÎÎ  !

WriteBytes
ÎÎ! +
(
ÎÎ+ ,
b
ÎÎ, -
)
ÎÎ- .
;
ÎÎ. /
c1
ÏÏ 
.
ÏÏ 
FreeIfNecessary
ÏÏ &
(
ÏÏ& '
)
ÏÏ' (
;
ÏÏ( )
}
ĞĞ 
var
ÑÑ 
c
ÑÑ 
=
ÑÑ 
new
ÑÑ 
ComponentEntry
ÑÑ *
(
ÑÑ* +
consolidated
ÑÑ+ 7
)
ÑÑ7 8
;
ÑÑ8 9
c
ÒÒ 
.
ÒÒ 
	EndOffset
ÒÒ 
=
ÒÒ 
c
ÒÒ 
.
ÒÒ  
Length
ÒÒ  &
;
ÒÒ& '
this
ÓÓ 
.
ÓÓ 

components
ÓÓ 
.
ÓÓ  
Clear
ÓÓ  %
(
ÓÓ% &
)
ÓÓ& '
;
ÓÓ' (
this
ÔÔ 
.
ÔÔ 

components
ÔÔ 
.
ÔÔ  
Add
ÔÔ  #
(
ÔÔ# $
c
ÔÔ$ %
)
ÔÔ% &
;
ÔÔ& '
}
ÕÕ 
}
ÖÖ 	
void
ØØ !
CheckComponentIndex
ØØ  
(
ØØ  !
int
ØØ! $
cIndex
ØØ% +
)
ØØ+ ,
{
ÙÙ 	
this
ÚÚ 
.
ÚÚ 
EnsureAccessible
ÚÚ !
(
ÚÚ! "
)
ÚÚ" #
;
ÚÚ# $
if
ÛÛ 
(
ÛÛ 
cIndex
ÛÛ 
<
ÛÛ 
$num
ÛÛ 
||
ÛÛ 
cIndex
ÛÛ $
>
ÛÛ% &
this
ÛÛ' +
.
ÛÛ+ ,

components
ÛÛ, 6
.
ÛÛ6 7
Count
ÛÛ7 <
)
ÛÛ< =
{
ÜÜ 
throw
İİ 
new
İİ )
ArgumentOutOfRangeException
İİ 5
(
İİ5 6
$"
İİ6 8
$str
İİ8 @
{
İİ@ A
cIndex
İİA G
}
İİG H
$str
İİH m
{
İİm n
this
İİn r
.
İİr s

components
İİs }
.
İİ} ~
Countİİ~ ƒ
}İİƒ „
$strİİ„ †
"İİ† ‡
)İİ‡ ˆ
;İİˆ ‰
}
ŞŞ 
}
ßß 	
void
áá !
CheckComponentIndex
áá  
(
áá  !
int
áá! $
cIndex
áá% +
,
áá+ ,
int
áá- 0
numComponents
áá1 >
)
áá> ?
{
ââ 	
this
ãã 
.
ãã 
EnsureAccessible
ãã !
(
ãã! "
)
ãã" #
;
ãã# $
if
ää 
(
ää 
cIndex
ää 
<
ää 
$num
ää 
||
ää 
cIndex
ää $
+
ää% &
numComponents
ää' 4
>
ää5 6
this
ää7 ;
.
ää; <

components
ää< F
.
ääF G
Count
ääG L
)
ääL M
{
åå 
throw
ææ 
new
ææ )
ArgumentOutOfRangeException
ææ 5
(
ææ5 6
$"
ææ6 8
$str
ææ8 @
{
ææ@ A
cIndex
ææA G
}
ææG H
$str
ææH Y
{
ææY Z
numComponents
ææZ g
}
ææg h
$str
ææh i
"
ææi j
+
ææk l
$"
ææm o
$strææo ¶
{ææ¶ ·
thisææ· »
.ææ» ¼

componentsææ¼ Æ
.ææÆ Ç
CountææÇ Ì
}ææÌ Í
$strææÍ Ï
"ææÏ Ğ
)ææĞ Ñ
;ææÑ Ò
}
çç 
}
èè 	
void
êê $
UpdateComponentOffsets
êê #
(
êê# $
int
êê$ '
cIndex
êê( .
)
êê. /
{
ëë 	
int
ìì 
size
ìì 
=
ìì 
this
ìì 
.
ìì 

components
ìì &
.
ìì& '
Count
ìì' ,
;
ìì, -
if
íí 
(
íí 
size
íí 
<=
íí 
cIndex
íí 
)
íí 
{
îî 
return
ïï 
;
ïï 
}
ğğ 
ComponentEntry
òò 
c
òò 
=
òò 
this
òò #
.
òò# $

components
òò$ .
[
òò. /
cIndex
òò/ 5
]
òò5 6
;
òò6 7
if
óó 
(
óó 
cIndex
óó 
==
óó 
$num
óó 
)
óó 
{
ôô 
c
õõ 
.
õõ 
Offset
õõ 
=
õõ 
$num
õõ 
;
õõ 
c
öö 
.
öö 
	EndOffset
öö 
=
öö 
c
öö 
.
öö  
Length
öö  &
;
öö& '
cIndex
÷÷ 
++
÷÷ 
;
÷÷ 
}
øø 
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
cIndex
úú 
;
úú  
i
úú! "
<
úú# $
size
úú% )
;
úú) *
i
úú+ ,
++
úú, .
)
úú. /
{
ûû 
ComponentEntry
üü 
prev
üü #
=
üü$ %
this
üü& *
.
üü* +

components
üü+ 5
[
üü5 6
i
üü6 7
-
üü8 9
$num
üü: ;
]
üü; <
;
üü< =
ComponentEntry
ıı 
cur
ıı "
=
ıı# $
this
ıı% )
.
ıı) *

components
ıı* 4
[
ıı4 5
i
ıı5 6
]
ıı6 7
;
ıı7 8
cur
şş 
.
şş 
Offset
şş 
=
şş 
prev
şş !
.
şş! "
	EndOffset
şş" +
;
şş+ ,
cur
ÿÿ 
.
ÿÿ 
	EndOffset
ÿÿ 
=
ÿÿ 
cur
ÿÿ  #
.
ÿÿ# $
Offset
ÿÿ$ *
+
ÿÿ+ ,
cur
ÿÿ- 0
.
ÿÿ0 1
Length
ÿÿ1 7
;
ÿÿ7 8
}
€€ 
}
 	
public
‡‡ 
virtual
‡‡ !
CompositeByteBuffer
‡‡ *
RemoveComponent
‡‡+ :
(
‡‡: ;
int
‡‡; >
cIndex
‡‡? E
)
‡‡E F
{
ˆˆ 	
this
‰‰ 
.
‰‰ !
CheckComponentIndex
‰‰ $
(
‰‰$ %
cIndex
‰‰% +
)
‰‰+ ,
;
‰‰, -
ComponentEntry
ŠŠ 
comp
ŠŠ 
=
ŠŠ  !
this
ŠŠ" &
.
ŠŠ& '

components
ŠŠ' 1
[
ŠŠ1 2
cIndex
ŠŠ2 8
]
ŠŠ8 9
;
ŠŠ9 :
this
‹‹ 
.
‹‹ 

components
‹‹ 
.
‹‹ 
RemoveAt
‹‹ $
(
‹‹$ %
cIndex
‹‹% +
)
‹‹+ ,
;
‹‹, -
comp
ŒŒ 
.
ŒŒ 
FreeIfNecessary
ŒŒ  
(
ŒŒ  !
)
ŒŒ! "
;
ŒŒ" #
if
 
(
 
comp
 
.
 
Length
 
>
 
$num
 
)
  
{
 
this
 
.
 $
UpdateComponentOffsets
 +
(
+ ,
cIndex
, 2
)
2 3
;
3 4
}
‘‘ 
return
’’ 
this
’’ 
;
’’ 
}
““ 	
public
šš 
virtual
šš !
CompositeByteBuffer
šš *
RemoveComponents
šš+ ;
(
šš; <
int
šš< ?
cIndex
šš@ F
,
ššF G
int
ššH K
numComponents
ššL Y
)
ššY Z
{
›› 	
this
œœ 
.
œœ !
CheckComponentIndex
œœ $
(
œœ$ %
cIndex
œœ% +
,
œœ+ ,
numComponents
œœ- :
)
œœ: ;
;
œœ; <
if
 
(
 
numComponents
 
==
  
$num
! "
)
" #
{
ŸŸ 
return
   
this
   
;
   
}
¡¡ 
bool
¢¢ 
needsUpdate
¢¢ 
=
¢¢ 
false
¢¢ $
;
¢¢$ %
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
cIndex
££ 
+
££  !
numComponents
££" /
;
££/ 0
i
££1 2
>=
££3 5
cIndex
££6 <
;
££< =
i
££> ?
--
££? A
)
££A B
{
¤¤ 
ComponentEntry
¥¥ 
c
¥¥  
=
¥¥! "
this
¥¥# '
.
¥¥' (

components
¥¥( 2
[
¥¥2 3
i
¥¥3 4
]
¥¥4 5
;
¥¥5 6
needsUpdate
¦¦ 
|=
¦¦ 
c
¦¦  
.
¦¦  !
Length
¦¦! '
>
¦¦( )
$num
¦¦* +
;
¦¦+ ,
c
§§ 
.
§§ 
FreeIfNecessary
§§ !
(
§§! "
)
§§" #
;
§§# $
this
¨¨ 
.
¨¨ 

components
¨¨ 
.
¨¨  
RemoveAt
¨¨  (
(
¨¨( )
i
¨¨) *
)
¨¨* +
;
¨¨+ ,
}
©© 
if
«« 
(
«« 
needsUpdate
«« 
)
«« 
{
¬¬ 
this
®® 
.
®® $
UpdateComponentOffsets
®® +
(
®®+ ,
cIndex
®®, 2
)
®®2 3
;
®®3 4
}
¯¯ 
return
°° 
this
°° 
;
°° 
}
±± 	
public
³³ 
virtual
³³ 
IEnumerator
³³ "
<
³³" #
IByteBuffer
³³# .
>
³³. /
GetEnumerator
³³0 =
(
³³= >
)
³³> ?
{
´´ 	
this
µµ 
.
µµ 
EnsureAccessible
µµ !
(
µµ! "
)
µµ" #
;
µµ# $
foreach
¶¶ 
(
¶¶ 
ComponentEntry
¶¶ #
c
¶¶$ %
in
¶¶& (
this
¶¶) -
.
¶¶- .

components
¶¶. 8
)
¶¶8 9
{
·· 
yield
¸¸ 
return
¸¸ 
c
¸¸ 
.
¸¸ 
Buffer
¸¸ %
;
¸¸% &
}
¹¹ 
}
ºº 	
IEnumerator
¼¼ 
IEnumerable
¼¼ 
.
¼¼  
GetEnumerator
¼¼  -
(
¼¼- .
)
¼¼. /
=>
¼¼0 2
this
¼¼3 7
.
¼¼7 8
GetEnumerator
¼¼8 E
(
¼¼E F
)
¼¼F G
;
¼¼G H
public
ÁÁ 
virtual
ÁÁ 
IList
ÁÁ 
<
ÁÁ 
IByteBuffer
ÁÁ (
>
ÁÁ( )
	Decompose
ÁÁ* 3
(
ÁÁ3 4
int
ÁÁ4 7
offset
ÁÁ8 >
,
ÁÁ> ?
int
ÁÁ@ C
length
ÁÁD J
)
ÁÁJ K
{
ÂÂ 	
this
ÃÃ 
.
ÃÃ 

CheckIndex
ÃÃ 
(
ÃÃ 
offset
ÃÃ "
,
ÃÃ" #
length
ÃÃ$ *
)
ÃÃ* +
;
ÃÃ+ ,
if
ÄÄ 
(
ÄÄ 
length
ÄÄ 
==
ÄÄ 
$num
ÄÄ 
)
ÄÄ 
{
ÅÅ 
return
ÆÆ 
	EmptyList
ÆÆ  
;
ÆÆ  !
}
ÇÇ 
int
ÉÉ 
componentId
ÉÉ 
=
ÉÉ 
this
ÉÉ "
.
ÉÉ" #
ToComponentIndex
ÉÉ# 3
(
ÉÉ3 4
offset
ÉÉ4 :
)
ÉÉ: ;
;
ÉÉ; <
var
ÊÊ 
slice
ÊÊ 
=
ÊÊ 
new
ÊÊ 
List
ÊÊ  
<
ÊÊ  !
IByteBuffer
ÊÊ! ,
>
ÊÊ, -
(
ÊÊ- .
this
ÊÊ. 2
.
ÊÊ2 3

components
ÊÊ3 =
.
ÊÊ= >
Count
ÊÊ> C
)
ÊÊC D
;
ÊÊD E
ComponentEntry
ÍÍ 
firstC
ÍÍ !
=
ÍÍ" #
this
ÍÍ$ (
.
ÍÍ( )

components
ÍÍ) 3
[
ÍÍ3 4
componentId
ÍÍ4 ?
]
ÍÍ? @
;
ÍÍ@ A
IByteBuffer
ÎÎ 
first
ÎÎ 
=
ÎÎ 
firstC
ÎÎ  &
.
ÎÎ& '
Buffer
ÎÎ' -
.
ÎÎ- .
	Duplicate
ÎÎ. 7
(
ÎÎ7 8
)
ÎÎ8 9
;
ÎÎ9 :
first
ÏÏ 
.
ÏÏ 
SetReaderIndex
ÏÏ  
(
ÏÏ  !
offset
ÏÏ! '
-
ÏÏ( )
firstC
ÏÏ* 0
.
ÏÏ0 1
Offset
ÏÏ1 7
)
ÏÏ7 8
;
ÏÏ8 9
IByteBuffer
ÑÑ 
buffer
ÑÑ 
=
ÑÑ  
first
ÑÑ! &
;
ÑÑ& '
int
ÒÒ 
bytesToSlice
ÒÒ 
=
ÒÒ 
length
ÒÒ %
;
ÒÒ% &
do
ÓÓ 
{
ÔÔ 
int
ÕÕ 
readableBytes
ÕÕ !
=
ÕÕ" #
buffer
ÕÕ$ *
.
ÕÕ* +
ReadableBytes
ÕÕ+ 8
;
ÕÕ8 9
if
ÖÖ 
(
ÖÖ 
bytesToSlice
ÖÖ  
<=
ÖÖ! #
readableBytes
ÖÖ$ 1
)
ÖÖ1 2
{
×× 
buffer
ÙÙ 
.
ÙÙ 
SetWriterIndex
ÙÙ )
(
ÙÙ) *
buffer
ÙÙ* 0
.
ÙÙ0 1
ReaderIndex
ÙÙ1 <
+
ÙÙ= >
bytesToSlice
ÙÙ? K
)
ÙÙK L
;
ÙÙL M
slice
ÚÚ 
.
ÚÚ 
Add
ÚÚ 
(
ÚÚ 
buffer
ÚÚ $
)
ÚÚ$ %
;
ÚÚ% &
break
ÛÛ 
;
ÛÛ 
}
ÜÜ 
else
İİ 
{
ŞŞ 
slice
àà 
.
àà 
Add
àà 
(
àà 
buffer
àà $
)
àà$ %
;
àà% &
bytesToSlice
áá  
-=
áá! #
readableBytes
áá$ 1
;
áá1 2
componentId
ââ 
++
ââ !
;
ââ! "
buffer
åå 
=
åå 
this
åå !
.
åå! "

components
åå" ,
[
åå, -
componentId
åå- 8
]
åå8 9
.
åå9 :
Buffer
åå: @
.
åå@ A
	Duplicate
ååA J
(
ååJ K
)
ååK L
;
ååL M
}
ææ 
}
çç 
while
èè 
(
èè 
bytesToSlice
èè 
>
èè  !
$num
èè" #
)
èè# $
;
èè$ %
for
ëë 
(
ëë 
int
ëë 
i
ëë 
=
ëë 
$num
ëë 
;
ëë 
i
ëë 
<
ëë 
slice
ëë  %
.
ëë% &
Count
ëë& +
;
ëë+ ,
i
ëë- .
++
ëë. 0
)
ëë0 1
{
ìì 
slice
íí 
[
íí 
i
íí 
]
íí 
=
íí 
slice
íí  
[
íí  !
i
íí! "
]
íí" #
.
íí# $
Slice
íí$ )
(
íí) *
)
íí* +
;
íí+ ,
}
îî 
return
ğğ 
slice
ğğ 
;
ğğ 
}
ññ 	
public
óó 
override
óó 
int
óó 
IoBufferCount
óó )
{
ôô 	
get
õõ 
{
öö 
switch
÷÷ 
(
÷÷ 
this
÷÷ 
.
÷÷ 

components
÷÷ '
.
÷÷' (
Count
÷÷( -
)
÷÷- .
{
øø 
case
ùù 
$num
ùù 
:
ùù 
return
úú 
$num
úú  
;
úú  !
case
ûû 
$num
ûû 
:
ûû 
return
üü 
this
üü #
.
üü# $

components
üü$ .
[
üü. /
$num
üü/ 0
]
üü0 1
.
üü1 2
Buffer
üü2 8
.
üü8 9
IoBufferCount
üü9 F
;
üüF G
default
ıı 
:
ıı 
int
şş 
count
şş !
=
şş" #
$num
şş$ %
;
şş% &
int
ÿÿ 
componentsCount
ÿÿ +
=
ÿÿ, -
this
ÿÿ. 2
.
ÿÿ2 3

components
ÿÿ3 =
.
ÿÿ= >
Count
ÿÿ> C
;
ÿÿC D
for
€€ 
(
€€ 
int
€€  
i
€€! "
=
€€# $
$num
€€% &
;
€€& '
i
€€( )
<
€€* +
componentsCount
€€, ;
;
€€; <
i
€€= >
++
€€> @
)
€€@ A
{
 
ComponentEntry
‚‚ *
c
‚‚+ ,
=
‚‚- .
this
‚‚/ 3
.
‚‚3 4

components
‚‚4 >
[
‚‚> ?
i
‚‚? @
]
‚‚@ A
;
‚‚A B
count
ƒƒ !
+=
ƒƒ" $
c
ƒƒ% &
.
ƒƒ& '
Buffer
ƒƒ' -
.
ƒƒ- .
IoBufferCount
ƒƒ. ;
;
ƒƒ; <
}
„„ 
return
…… 
count
…… $
;
……$ %
}
†† 
}
‡‡ 
}
ˆˆ 	
public
ŠŠ 
override
ŠŠ 
ArraySegment
ŠŠ $
<
ŠŠ$ %
byte
ŠŠ% )
>
ŠŠ) *
GetIoBuffer
ŠŠ+ 6
(
ŠŠ6 7
int
ŠŠ7 :
index
ŠŠ; @
,
ŠŠ@ A
int
ŠŠB E
length
ŠŠF L
)
ŠŠL M
{
‹‹ 	
this
ŒŒ 
.
ŒŒ 

CheckIndex
ŒŒ 
(
ŒŒ 
index
ŒŒ !
,
ŒŒ! "
length
ŒŒ# )
)
ŒŒ) *
;
ŒŒ* +
switch
 
(
 
this
 
.
 

components
 #
.
# $
Count
$ )
)
) *
{
 
case
 
$num
 
:
 
return
‘‘ 
EmptyNioBuffer
‘‘ )
;
‘‘) *
case
’’ 
$num
’’ 
:
’’ 
IByteBuffer
““ 
buf
““  #
=
““$ %
this
““& *
.
““* +

components
““+ 5
[
““5 6
$num
““6 7
]
““7 8
.
““8 9
Buffer
““9 ?
;
““? @
if
”” 
(
”” 
buf
”” 
.
”” 
IoBufferCount
”” )
==
””* ,
$num
””- .
)
””. /
{
•• 
return
–– 
this
–– #
.
––# $

components
––$ .
[
––. /
$num
––/ 0
]
––0 1
.
––1 2
Buffer
––2 8
.
––8 9
GetIoBuffer
––9 D
(
––D E
index
––E J
,
––J K
length
––L R
)
––R S
;
––S T
}
—— 
break
˜˜ 
;
˜˜ 
}
™™ 
var
›› 
merged
›› 
=
›› 
new
›› 
byte
›› !
[
››! "
length
››" (
]
››( )
;
››) *
ArraySegment
œœ 
<
œœ 
byte
œœ 
>
œœ 
[
œœ 
]
œœ  
buffers
œœ! (
=
œœ) *
this
œœ+ /
.
œœ/ 0
GetIoBuffers
œœ0 <
(
œœ< =
index
œœ= B
,
œœB C
length
œœD J
)
œœJ K
;
œœK L
int
 
offset
 
=
 
$num
 
;
 
foreach
ŸŸ 
(
ŸŸ 
ArraySegment
ŸŸ !
<
ŸŸ! "
byte
ŸŸ" &
>
ŸŸ& '
buf
ŸŸ( +
in
ŸŸ, .
buffers
ŸŸ/ 6
)
ŸŸ6 7
{
   
Contract
¡¡ 
.
¡¡ 
Assert
¡¡ 
(
¡¡  
merged
¡¡  &
.
¡¡& '
Length
¡¡' -
-
¡¡. /
offset
¡¡0 6
>=
¡¡7 9
buf
¡¡: =
.
¡¡= >
Count
¡¡> C
)
¡¡C D
;
¡¡D E
PlatformDependent
££ !
.
££! "

CopyMemory
££" ,
(
££, -
buf
££- 0
.
££0 1
Array
££1 6
,
££6 7
buf
££8 ;
.
££; <
Offset
££< B
,
££B C
merged
££D J
,
££J K
offset
££L R
,
££R S
buf
££T W
.
££W X
Count
££X ]
)
££] ^
;
££^ _
offset
¤¤ 
+=
¤¤ 
buf
¤¤ 
.
¤¤ 
Count
¤¤ #
;
¤¤# $
}
¥¥ 
return
§§ 
new
§§ 
ArraySegment
§§ #
<
§§# $
byte
§§$ (
>
§§( )
(
§§) *
merged
§§* 0
)
§§0 1
;
§§1 2
}
¨¨ 	
public
ªª 
override
ªª 
ArraySegment
ªª $
<
ªª$ %
byte
ªª% )
>
ªª) *
[
ªª* +
]
ªª+ ,
GetIoBuffers
ªª- 9
(
ªª9 :
int
ªª: =
index
ªª> C
,
ªªC D
int
ªªE H
length
ªªI O
)
ªªO P
{
«« 	
this
¬¬ 
.
¬¬ 

CheckIndex
¬¬ 
(
¬¬ 
index
¬¬ !
,
¬¬! "
length
¬¬# )
)
¬¬) *
;
¬¬* +
if
­­ 
(
­­ 
length
­­ 
==
­­ 
$num
­­ 
)
­­ 
{
®® 
return
¯¯ 
new
¯¯ 
[
¯¯ 
]
¯¯ 
{
¯¯ 
EmptyNioBuffer
¯¯ -
}
¯¯. /
;
¯¯/ 0
}
°° 
var
²² 
buffers
²² 
=
²² 
new
²² 
List
²² "
<
²²" #
ArraySegment
²²# /
<
²²/ 0
byte
²²0 4
>
²²4 5
>
²²5 6
(
²²6 7
this
²²7 ;
.
²²; <

components
²²< F
.
²²F G
Count
²²G L
)
²²L M
;
²²M N
int
³³ 
i
³³ 
=
³³ 
this
³³ 
.
³³ 
ToComponentIndex
³³ )
(
³³) *
index
³³* /
)
³³/ 0
;
³³0 1
while
´´ 
(
´´ 
length
´´ 
>
´´ 
$num
´´ 
)
´´ 
{
µµ 
ComponentEntry
¶¶ 
c
¶¶  
=
¶¶! "
this
¶¶# '
.
¶¶' (

components
¶¶( 2
[
¶¶2 3
i
¶¶3 4
]
¶¶4 5
;
¶¶5 6
IByteBuffer
·· 
s
·· 
=
·· 
c
··  !
.
··! "
Buffer
··" (
;
··( )
int
¸¸ 

adjustment
¸¸ 
=
¸¸  
c
¸¸! "
.
¸¸" #
Offset
¸¸# )
;
¸¸) *
int
¹¹ 
localLength
¹¹ 
=
¹¹  !
Math
¹¹" &
.
¹¹& '
Min
¹¹' *
(
¹¹* +
length
¹¹+ 1
,
¹¹1 2
s
¹¹3 4
.
¹¹4 5
Capacity
¹¹5 =
-
¹¹> ?
(
¹¹@ A
index
¹¹A F
-
¹¹G H

adjustment
¹¹I S
)
¹¹S T
)
¹¹T U
;
¹¹U V
switch
ºº 
(
ºº 
s
ºº 
.
ºº 
IoBufferCount
ºº '
)
ºº' (
{
»» 
case
¼¼ 
$num
¼¼ 
:
¼¼ 
throw
½½ 
new
½½ !#
NotSupportedException
½½" 7
(
½½7 8
)
½½8 9
;
½½9 :
case
¾¾ 
$num
¾¾ 
:
¾¾ 
buffers
¿¿ 
.
¿¿  
Add
¿¿  #
(
¿¿# $
s
¿¿$ %
.
¿¿% &
GetIoBuffer
¿¿& 1
(
¿¿1 2
index
¿¿2 7
-
¿¿8 9

adjustment
¿¿: D
,
¿¿D E
localLength
¿¿F Q
)
¿¿Q R
)
¿¿R S
;
¿¿S T
break
ÀÀ 
;
ÀÀ 
default
ÁÁ 
:
ÁÁ 
buffers
ÂÂ 
.
ÂÂ  
AddRange
ÂÂ  (
(
ÂÂ( )
s
ÂÂ) *
.
ÂÂ* +
GetIoBuffers
ÂÂ+ 7
(
ÂÂ7 8
index
ÂÂ8 =
-
ÂÂ> ?

adjustment
ÂÂ@ J
,
ÂÂJ K
localLength
ÂÂL W
)
ÂÂW X
)
ÂÂX Y
;
ÂÂY Z
break
ÃÃ 
;
ÃÃ 
}
ÄÄ 
index
ÆÆ 
+=
ÆÆ 
localLength
ÆÆ $
;
ÆÆ$ %
length
ÇÇ 
-=
ÇÇ 
localLength
ÇÇ %
;
ÇÇ% &
i
ÈÈ 
++
ÈÈ 
;
ÈÈ 
}
ÉÉ 
return
ËË 
buffers
ËË 
.
ËË 
ToArray
ËË "
(
ËË" #
)
ËË# $
;
ËË$ %
}
ÌÌ 	
public
ÏÏ 
override
ÏÏ 
bool
ÏÏ 
IsDirect
ÏÏ %
{
ĞĞ 	
get
ÑÑ 
{
ÒÒ 
int
ÓÓ 
size
ÓÓ 
=
ÓÓ 
this
ÓÓ 
.
ÓÓ  

components
ÓÓ  *
.
ÓÓ* +
Count
ÓÓ+ 0
;
ÓÓ0 1
if
ÔÔ 
(
ÔÔ 
size
ÔÔ 
==
ÔÔ 
$num
ÔÔ 
)
ÔÔ 
{
ÕÕ 
return
ÖÖ 
false
ÖÖ  
;
ÖÖ  !
}
×× 
for
ØØ 
(
ØØ 
int
ØØ 
i
ØØ 
=
ØØ 
$num
ØØ 
;
ØØ 
i
ØØ  !
<
ØØ" #
size
ØØ$ (
;
ØØ( )
i
ØØ* +
++
ØØ+ -
)
ØØ- .
{
ÙÙ 
if
ÚÚ 
(
ÚÚ 
!
ÚÚ 
this
ÚÚ 
.
ÚÚ 

components
ÚÚ (
[
ÚÚ( )
i
ÚÚ) *
]
ÚÚ* +
.
ÚÚ+ ,
Buffer
ÚÚ, 2
.
ÚÚ2 3
IsDirect
ÚÚ3 ;
)
ÚÚ; <
{
ÛÛ 
return
ÜÜ 
false
ÜÜ $
;
ÜÜ$ %
}
İİ 
}
ŞŞ 
return
ßß 
true
ßß 
;
ßß 
}
àà 
}
áá 	
public
ãã 
override
ãã 
bool
ãã 
HasArray
ãã %
{
ää 	
get
åå 
{
ææ 
switch
çç 
(
çç 
this
çç 
.
çç 

components
çç '
.
çç' (
Count
çç( -
)
çç- .
{
èè 
case
éé 
$num
éé 
:
éé 
return
êê 
true
êê #
;
êê# $
case
ëë 
$num
ëë 
:
ëë 
return
ìì 
this
ìì #
.
ìì# $

components
ìì$ .
[
ìì. /
$num
ìì/ 0
]
ìì0 1
.
ìì1 2
Buffer
ìì2 8
.
ìì8 9
HasArray
ìì9 A
;
ììA B
default
íí 
:
íí 
return
îî 
false
îî $
;
îî$ %
}
ïï 
}
ğğ 
}
ññ 	
public
óó 
override
óó 
byte
óó 
[
óó 
]
óó 
Array
óó $
{
ôô 	
get
õõ 
{
öö 
switch
÷÷ 
(
÷÷ 
this
÷÷ 
.
÷÷ 

components
÷÷ '
.
÷÷' (
Count
÷÷( -
)
÷÷- .
{
øø 
case
ùù 
$num
ùù 
:
ùù 
return
úú 
ArrayExtensions
úú .
.
úú. /
	ZeroBytes
úú/ 8
;
úú8 9
case
ûû 
$num
ûû 
:
ûû 
return
üü 
this
üü #
.
üü# $

components
üü$ .
[
üü. /
$num
üü/ 0
]
üü0 1
.
üü1 2
Buffer
üü2 8
.
üü8 9
Array
üü9 >
;
üü> ?
default
ıı 
:
ıı 
throw
şş 
new
şş !#
NotSupportedException
şş" 7
(
şş7 8
)
şş8 9
;
şş9 :
}
ÿÿ 
}
€€ 
}
 	
public
ƒƒ 
override
ƒƒ 
int
ƒƒ 
ArrayOffset
ƒƒ '
{
„„ 	
get
…… 
{
†† 
switch
‡‡ 
(
‡‡ 
this
‡‡ 
.
‡‡ 

components
‡‡ '
.
‡‡' (
Count
‡‡( -
)
‡‡- .
{
ˆˆ 
case
‰‰ 
$num
‰‰ 
:
‰‰ 
return
ŠŠ 
$num
ŠŠ  
;
ŠŠ  !
case
‹‹ 
$num
‹‹ 
:
‹‹ 
return
ŒŒ 
this
ŒŒ #
.
ŒŒ# $

components
ŒŒ$ .
[
ŒŒ. /
$num
ŒŒ/ 0
]
ŒŒ0 1
.
ŒŒ1 2
Buffer
ŒŒ2 8
.
ŒŒ8 9
ArrayOffset
ŒŒ9 D
;
ŒŒD E
default
 
:
 
throw
 
new
 !#
NotSupportedException
" 7
(
7 8
)
8 9
;
9 :
}
 
}
 
}
‘‘ 	
public
““ 
override
““ 
bool
““ 
HasMemoryAddress
““ -
{
”” 	
get
•• 
{
–– 
switch
—— 
(
—— 
this
—— 
.
—— 

components
—— '
.
——' (
Count
——( -
)
——- .
{
˜˜ 
case
™™ 
$num
™™ 
:
™™ 
return
šš 
this
šš #
.
šš# $

components
šš$ .
[
šš. /
$num
šš/ 0
]
šš0 1
.
šš1 2
Buffer
šš2 8
.
šš8 9
HasMemoryAddress
šš9 I
;
ššI J
default
›› 
:
›› 
return
œœ 
false
œœ $
;
œœ$ %
}
 
}
 
}
ŸŸ 	
public
¡¡ 
override
¡¡ 
ref
¡¡ 
byte
¡¡  &
GetPinnableMemoryAddress
¡¡! 9
(
¡¡9 :
)
¡¡: ;
{
¢¢ 	
switch
££ 
(
££ 
this
££ 
.
££ 

components
££ #
.
££# $
Count
££$ )
)
££) *
{
¤¤ 
case
¥¥ 
$num
¥¥ 
:
¥¥ 
return
¦¦ 
ref
¦¦ 
this
¦¦ #
.
¦¦# $

components
¦¦$ .
[
¦¦. /
$num
¦¦/ 0
]
¦¦0 1
.
¦¦1 2
Buffer
¦¦2 8
.
¦¦8 9&
GetPinnableMemoryAddress
¦¦9 Q
(
¦¦Q R
)
¦¦R S
;
¦¦S T
default
§§ 
:
§§ 
throw
¨¨ 
new
¨¨ #
NotSupportedException
¨¨ 3
(
¨¨3 4
)
¨¨4 5
;
¨¨5 6
}
©© 
}
ªª 	
public
¬¬ 
override
¬¬ 
IntPtr
¬¬ #
AddressOfPinnedMemory
¬¬ 4
(
¬¬4 5
)
¬¬5 6
{
­­ 	
switch
®® 
(
®® 
this
®® 
.
®® 

components
®® #
.
®®# $
Count
®®$ )
)
®®) *
{
¯¯ 
case
°° 
$num
°° 
:
°° 
return
±± 
this
±± 
.
±±  

components
±±  *
[
±±* +
$num
±±+ ,
]
±±, -
.
±±- .
Buffer
±±. 4
.
±±4 5#
AddressOfPinnedMemory
±±5 J
(
±±J K
)
±±K L
;
±±L M
default
²² 
:
²² 
throw
³³ 
new
³³ #
NotSupportedException
³³ 3
(
³³3 4
)
³³4 5
;
³³5 6
}
´´ 
}
µµ 	
public
·· 
override
·· 
int
·· 
Capacity
·· $
=>
··% '
GetCapacity
··( 3
(
··3 4
this
··4 8
.
··8 9

components
··9 C
)
··C D
;
··D E
static
¹¹ 
int
¹¹ 
GetCapacity
¹¹ 
(
¹¹ 
List
¹¹ #
<
¹¹# $
ComponentEntry
¹¹$ 2
>
¹¹2 3

components
¹¹4 >
)
¹¹> ?
{
ºº 	
int
»» 
numComponents
»» 
=
»» 

components
»»  *
.
»»* +
Count
»»+ 0
;
»»0 1
if
¼¼ 
(
¼¼ 
numComponents
¼¼ 
==
¼¼  
$num
¼¼! "
)
¼¼" #
{
½½ 
return
¾¾ 
$num
¾¾ 
;
¾¾ 
}
¿¿ 
return
ÁÁ 

components
ÁÁ 
[
ÁÁ 
numComponents
ÁÁ +
-
ÁÁ, -
$num
ÁÁ. /
]
ÁÁ/ 0
.
ÁÁ0 1
	EndOffset
ÁÁ1 :
;
ÁÁ: ;
}
ÂÂ 	
public
ÄÄ 
override
ÄÄ 
IByteBuffer
ÄÄ #
AdjustCapacity
ÄÄ$ 2
(
ÄÄ2 3
int
ÄÄ3 6
newCapacity
ÄÄ7 B
)
ÄÄB C
{
ÅÅ 	
this
ÆÆ 
.
ÆÆ 
CheckNewCapacity
ÆÆ !
(
ÆÆ! "
newCapacity
ÆÆ" -
)
ÆÆ- .
;
ÆÆ. /
int
ÈÈ 
oldCapacity
ÈÈ 
=
ÈÈ 
this
ÈÈ "
.
ÈÈ" #
Capacity
ÈÈ# +
;
ÈÈ+ ,
if
ÉÉ 
(
ÉÉ 
newCapacity
ÉÉ 
>
ÉÉ 
oldCapacity
ÉÉ )
)
ÉÉ) *
{
ÊÊ 
int
ËË 
paddingLength
ËË !
=
ËË" #
newCapacity
ËË$ /
-
ËË0 1
oldCapacity
ËË2 =
;
ËË= >
IByteBuffer
ÌÌ 
padding
ÌÌ #
;
ÌÌ# $
int
ÍÍ 
nComponents
ÍÍ 
=
ÍÍ  !
this
ÍÍ" &
.
ÍÍ& '

components
ÍÍ' 1
.
ÍÍ1 2
Count
ÍÍ2 7
;
ÍÍ7 8
if
ÎÎ 
(
ÎÎ 
nComponents
ÎÎ 
<
ÎÎ  !
this
ÎÎ" &
.
ÎÎ& '
MaxNumComponents
ÎÎ' 7
)
ÎÎ7 8
{
ÏÏ 
padding
ĞĞ 
=
ĞĞ 
this
ĞĞ "
.
ĞĞ" #
AllocateBuffer
ĞĞ# 1
(
ĞĞ1 2
paddingLength
ĞĞ2 ?
)
ĞĞ? @
;
ĞĞ@ A
padding
ÑÑ 
.
ÑÑ 
SetIndex
ÑÑ $
(
ÑÑ$ %
$num
ÑÑ% &
,
ÑÑ& '
paddingLength
ÑÑ( 5
)
ÑÑ5 6
;
ÑÑ6 7
this
ÒÒ 
.
ÒÒ 
AddComponent0
ÒÒ &
(
ÒÒ& '
false
ÒÒ' ,
,
ÒÒ, -
this
ÒÒ. 2
.
ÒÒ2 3

components
ÒÒ3 =
.
ÒÒ= >
Count
ÒÒ> C
,
ÒÒC D
padding
ÒÒE L
)
ÒÒL M
;
ÒÒM N
}
ÓÓ 
else
ÔÔ 
{
ÕÕ 
padding
ÖÖ 
=
ÖÖ 
this
ÖÖ "
.
ÖÖ" #
AllocateBuffer
ÖÖ# 1
(
ÖÖ1 2
paddingLength
ÖÖ2 ?
)
ÖÖ? @
;
ÖÖ@ A
padding
×× 
.
×× 
SetIndex
×× $
(
××$ %
$num
××% &
,
××& '
paddingLength
××( 5
)
××5 6
;
××6 7
this
ÚÚ 
.
ÚÚ 
AddComponent0
ÚÚ &
(
ÚÚ& '
false
ÚÚ' ,
,
ÚÚ, -
this
ÚÚ. 2
.
ÚÚ2 3

components
ÚÚ3 =
.
ÚÚ= >
Count
ÚÚ> C
,
ÚÚC D
padding
ÚÚE L
)
ÚÚL M
;
ÚÚM N
this
ÛÛ 
.
ÛÛ !
ConsolidateIfNeeded
ÛÛ ,
(
ÛÛ, -
)
ÛÛ- .
;
ÛÛ. /
}
ÜÜ 
}
İİ 
else
ŞŞ 
if
ŞŞ 
(
ŞŞ 
newCapacity
ŞŞ  
<
ŞŞ! "
oldCapacity
ŞŞ# .
)
ŞŞ. /
{
ßß 
int
àà 
bytesToTrim
àà 
=
àà  !
oldCapacity
àà" -
-
àà. /
newCapacity
àà0 ;
;
àà; <
for
áá 
(
áá 
int
áá 
i
áá 
=
áá 
this
áá !
.
áá! "

components
áá" ,
.
áá, -
Count
áá- 2
-
áá3 4
$num
áá5 6
;
áá6 7
i
áá8 9
>=
áá: <
$num
áá= >
;
áá> ?
i
áá@ A
--
ááA C
)
ááC D
{
ââ 
ComponentEntry
ãã "
c
ãã# $
=
ãã% &
this
ãã' +
.
ãã+ ,

components
ãã, 6
[
ãã6 7
i
ãã7 8
]
ãã8 9
;
ãã9 :
if
ää 
(
ää 
bytesToTrim
ää #
>=
ää$ &
c
ää' (
.
ää( )
Length
ää) /
)
ää/ 0
{
åå 
bytesToTrim
ææ #
-=
ææ$ &
c
ææ' (
.
ææ( )
Length
ææ) /
;
ææ/ 0
this
çç 
.
çç 

components
çç '
.
çç' (
RemoveAt
çç( 0
(
çç0 1
i
çç1 2
)
çç2 3
;
çç3 4
continue
èè  
;
èè  !
}
éé 
var
ìì 
newC
ìì 
=
ìì 
new
ìì "
ComponentEntry
ìì# 1
(
ìì1 2
c
ìì2 3
.
ìì3 4
Buffer
ìì4 :
.
ìì: ;
Slice
ìì; @
(
ìì@ A
$num
ììA B
,
ììB C
c
ììD E
.
ììE F
Length
ììF L
-
ììM N
bytesToTrim
ììO Z
)
ììZ [
)
ìì[ \
;
ìì\ ]
newC
íí 
.
íí 
Offset
íí 
=
íí  !
c
íí" #
.
íí# $
Offset
íí$ *
;
íí* +
newC
îî 
.
îî 
	EndOffset
îî "
=
îî# $
newC
îî% )
.
îî) *
Offset
îî* 0
+
îî1 2
newC
îî3 7
.
îî7 8
Length
îî8 >
;
îî> ?
this
ïï 
.
ïï 

components
ïï #
[
ïï# $
i
ïï$ %
]
ïï% &
=
ïï' (
newC
ïï) -
;
ïï- .
break
ğğ 
;
ğğ 
}
ññ 
if
óó 
(
óó 
this
óó 
.
óó 
ReaderIndex
óó $
>
óó% &
newCapacity
óó' 2
)
óó2 3
{
ôô 
this
õõ 
.
õõ 
SetIndex
õõ !
(
õõ! "
newCapacity
õõ" -
,
õõ- .
newCapacity
õõ/ :
)
õõ: ;
;
õõ; <
}
öö 
else
÷÷ 
if
÷÷ 
(
÷÷ 
this
÷÷ 
.
÷÷ 
WriterIndex
÷÷ )
>
÷÷* +
newCapacity
÷÷, 7
)
÷÷7 8
{
øø 
this
ùù 
.
ùù 
SetWriterIndex
ùù '
(
ùù' (
newCapacity
ùù( 3
)
ùù3 4
;
ùù4 5
}
úú 
}
ûû 
return
üü 
this
üü 
;
üü 
}
ıı 	
public
ÿÿ 
override
ÿÿ "
IByteBufferAllocator
ÿÿ ,
	Allocator
ÿÿ- 6
=>
ÿÿ7 9
this
ÿÿ: >
.
ÿÿ> ?
	allocator
ÿÿ? H
;
ÿÿH I
public
„„ 
virtual
„„ 
int
„„ 
NumComponents
„„ (
=>
„„) +
this
„„, 0
.
„„0 1

components
„„1 ;
.
„„; <
Count
„„< A
;
„„A B
public
‰‰ 
virtual
‰‰ 
int
‰‰ 
MaxNumComponents
‰‰ +
=>
‰‰, .
this
‰‰/ 3
.
‰‰3 4
maxNumComponents
‰‰4 D
;
‰‰D E
public
 
virtual
 
int
 
ToComponentIndex
 +
(
+ ,
int
, /
offset
0 6
)
6 7
{
 	
this
 
.
 

CheckIndex
 
(
 
offset
 "
)
" #
;
# $
for
’’ 
(
’’ 
int
’’ 
low
’’ 
=
’’ 
$num
’’ 
,
’’ 
high
’’ "
=
’’# $
this
’’% )
.
’’) *

components
’’* 4
.
’’4 5
Count
’’5 :
;
’’: ;
low
’’< ?
<=
’’@ B
high
’’C G
;
’’G H
)
’’H I
{
““ 
int
”” 
mid
”” 
=
”” 
(
”” 
low
”” 
+
””  
high
””! %
)
””% &
.
””& '
RightUShift
””' 2
(
””2 3
$num
””3 4
)
””4 5
;
””5 6
ComponentEntry
•• 
c
••  
=
••! "
this
••# '
.
••' (

components
••( 2
[
••2 3
mid
••3 6
]
••6 7
;
••7 8
if
–– 
(
–– 
offset
–– 
>=
–– 
c
–– 
.
––  
	EndOffset
––  )
)
––) *
{
—— 
low
˜˜ 
=
˜˜ 
mid
˜˜ 
+
˜˜ 
$num
˜˜  !
;
˜˜! "
}
™™ 
else
šš 
if
šš 
(
šš 
offset
šš 
<
šš  !
c
šš" #
.
šš# $
Offset
šš$ *
)
šš* +
{
›› 
high
œœ 
=
œœ 
mid
œœ 
-
œœ  
$num
œœ! "
;
œœ" #
}
 
else
 
{
ŸŸ 
return
   
mid
   
;
   
}
¡¡ 
}
¢¢ 
throw
¤¤ 
new
¤¤ 
	Exception
¤¤ 
(
¤¤  
$str
¤¤  7
)
¤¤7 8
;
¤¤8 9
}
¥¥ 	
public
§§ 
virtual
§§ 
int
§§ 
ToByteIndex
§§ &
(
§§& '
int
§§' *
cIndex
§§+ 1
)
§§1 2
{
¨¨ 	
this
©© 
.
©© !
CheckComponentIndex
©© $
(
©©$ %
cIndex
©©% +
)
©©+ ,
;
©©, -
return
ªª 
this
ªª 
.
ªª 

components
ªª "
[
ªª" #
cIndex
ªª# )
]
ªª) *
.
ªª* +
Offset
ªª+ 1
;
ªª1 2
}
«« 	
	protected
­­ 
internal
­­ 
override
­­ #
byte
­­$ (
_GetByte
­­) 1
(
­­1 2
int
­­2 5
index
­­6 ;
)
­­; <
{
®® 	
ComponentEntry
¯¯ 
c
¯¯ 
=
¯¯ 
this
¯¯ #
.
¯¯# $
FindComponent
¯¯$ 1
(
¯¯1 2
index
¯¯2 7
)
¯¯7 8
;
¯¯8 9
return
°° 
c
°° 
.
°° 
Buffer
°° 
.
°° 
GetByte
°° #
(
°°# $
index
°°$ )
-
°°* +
c
°°, -
.
°°- .
Offset
°°. 4
)
°°4 5
;
°°5 6
}
±± 	
	protected
³³ 
internal
³³ 
override
³³ #
short
³³$ )
	_GetShort
³³* 3
(
³³3 4
int
³³4 7
index
³³8 =
)
³³= >
{
´´ 	
ComponentEntry
µµ 
c
µµ 
=
µµ 
this
µµ #
.
µµ# $
FindComponent
µµ$ 1
(
µµ1 2
index
µµ2 7
)
µµ7 8
;
µµ8 9
if
¶¶ 
(
¶¶ 
index
¶¶ 
+
¶¶ 
$num
¶¶ 
<=
¶¶ 
c
¶¶ 
.
¶¶ 
	EndOffset
¶¶ (
)
¶¶( )
{
·· 
return
¸¸ 
c
¸¸ 
.
¸¸ 
Buffer
¸¸ 
.
¸¸  
GetShort
¸¸  (
(
¸¸( )
index
¸¸) .
-
¸¸/ 0
c
¸¸1 2
.
¸¸2 3
Offset
¸¸3 9
)
¸¸9 :
;
¸¸: ;
}
¹¹ 
return
»» 
(
»» 
short
»» 
)
»» 
(
»» 
this
»» 
.
»»  
_GetByte
»»  (
(
»»( )
index
»») .
)
»». /
<<
»»0 2
$num
»»3 4
|
»»5 6
this
»»7 ;
.
»»; <
_GetByte
»»< D
(
»»D E
index
»»E J
+
»»K L
$num
»»M N
)
»»N O
)
»»O P
;
»»P Q
}
¼¼ 	
	protected
¾¾ 
internal
¾¾ 
override
¾¾ #
short
¾¾$ )
_GetShortLE
¾¾* 5
(
¾¾5 6
int
¾¾6 9
index
¾¾: ?
)
¾¾? @
{
¿¿ 	
ComponentEntry
ÀÀ 
c
ÀÀ 
=
ÀÀ 
this
ÀÀ #
.
ÀÀ# $
FindComponent
ÀÀ$ 1
(
ÀÀ1 2
index
ÀÀ2 7
)
ÀÀ7 8
;
ÀÀ8 9
if
ÁÁ 
(
ÁÁ 
index
ÁÁ 
+
ÁÁ 
$num
ÁÁ 
<=
ÁÁ 
c
ÁÁ 
.
ÁÁ 
	EndOffset
ÁÁ (
)
ÁÁ( )
{
ÂÂ 
return
ÃÃ 
c
ÃÃ 
.
ÃÃ 
Buffer
ÃÃ 
.
ÃÃ  

GetShortLE
ÃÃ  *
(
ÃÃ* +
index
ÃÃ+ 0
-
ÃÃ1 2
c
ÃÃ3 4
.
ÃÃ4 5
Offset
ÃÃ5 ;
)
ÃÃ; <
;
ÃÃ< =
}
ÄÄ 
return
ÆÆ 
(
ÆÆ 
short
ÆÆ 
)
ÆÆ 
(
ÆÆ 
this
ÆÆ 
.
ÆÆ  
_GetByte
ÆÆ  (
(
ÆÆ( )
index
ÆÆ) .
)
ÆÆ. /
<<
ÆÆ0 2
$num
ÆÆ3 4
|
ÆÆ5 6
this
ÆÆ7 ;
.
ÆÆ; <
_GetByte
ÆÆ< D
(
ÆÆD E
index
ÆÆE J
+
ÆÆK L
$num
ÆÆM N
)
ÆÆN O
)
ÆÆO P
;
ÆÆP Q
}
ÇÇ 	
	protected
ÉÉ 
internal
ÉÉ 
override
ÉÉ #
int
ÉÉ$ ' 
_GetUnsignedMedium
ÉÉ( :
(
ÉÉ: ;
int
ÉÉ; >
index
ÉÉ? D
)
ÉÉD E
{
ÊÊ 	
ComponentEntry
ËË 
c
ËË 
=
ËË 
this
ËË #
.
ËË# $
FindComponent
ËË$ 1
(
ËË1 2
index
ËË2 7
)
ËË7 8
;
ËË8 9
if
ÌÌ 
(
ÌÌ 
index
ÌÌ 
+
ÌÌ 
$num
ÌÌ 
<=
ÌÌ 
c
ÌÌ 
.
ÌÌ 
	EndOffset
ÌÌ (
)
ÌÌ( )
{
ÍÍ 
return
ÎÎ 
c
ÎÎ 
.
ÎÎ 
Buffer
ÎÎ 
.
ÎÎ  
GetUnsignedMedium
ÎÎ  1
(
ÎÎ1 2
index
ÎÎ2 7
-
ÎÎ8 9
c
ÎÎ: ;
.
ÎÎ; <
Offset
ÎÎ< B
)
ÎÎB C
;
ÎÎC D
}
ÏÏ 
return
ÑÑ 
(
ÑÑ 
this
ÑÑ 
.
ÑÑ 
	_GetShort
ÑÑ "
(
ÑÑ" #
index
ÑÑ# (
)
ÑÑ( )
&
ÑÑ* +
$num
ÑÑ, 2
)
ÑÑ2 3
<<
ÑÑ4 6
$num
ÑÑ7 8
|
ÑÑ9 :
this
ÑÑ; ?
.
ÑÑ? @
_GetByte
ÑÑ@ H
(
ÑÑH I
index
ÑÑI N
+
ÑÑO P
$num
ÑÑQ R
)
ÑÑR S
;
ÑÑS T
}
ÒÒ 	
	protected
ÔÔ 
internal
ÔÔ 
override
ÔÔ #
int
ÔÔ$ '"
_GetUnsignedMediumLE
ÔÔ( <
(
ÔÔ< =
int
ÔÔ= @
index
ÔÔA F
)
ÔÔF G
{
ÕÕ 	
ComponentEntry
ÖÖ 
c
ÖÖ 
=
ÖÖ 
this
ÖÖ #
.
ÖÖ# $
FindComponent
ÖÖ$ 1
(
ÖÖ1 2
index
ÖÖ2 7
)
ÖÖ7 8
;
ÖÖ8 9
if
×× 
(
×× 
index
×× 
+
×× 
$num
×× 
<=
×× 
c
×× 
.
×× 
	EndOffset
×× (
)
××( )
{
ØØ 
return
ÙÙ 
c
ÙÙ 
.
ÙÙ 
Buffer
ÙÙ 
.
ÙÙ  !
GetUnsignedMediumLE
ÙÙ  3
(
ÙÙ3 4
index
ÙÙ4 9
-
ÙÙ: ;
c
ÙÙ< =
.
ÙÙ= >
Offset
ÙÙ> D
)
ÙÙD E
;
ÙÙE F
}
ÚÚ 
return
ÜÜ 
(
ÜÜ 
this
ÜÜ 
.
ÜÜ 
_GetShortLE
ÜÜ $
(
ÜÜ$ %
index
ÜÜ% *
)
ÜÜ* +
&
ÜÜ, -
$num
ÜÜ. 4
)
ÜÜ4 5
<<
ÜÜ6 8
$num
ÜÜ9 :
|
ÜÜ; <
this
ÜÜ= A
.
ÜÜA B
_GetByte
ÜÜB J
(
ÜÜJ K
index
ÜÜK P
+
ÜÜQ R
$num
ÜÜS T
)
ÜÜT U
;
ÜÜU V
}
İİ 	
	protected
ßß 
internal
ßß 
override
ßß #
int
ßß$ '
_GetInt
ßß( /
(
ßß/ 0
int
ßß0 3
index
ßß4 9
)
ßß9 :
{
àà 	
ComponentEntry
áá 
c
áá 
=
áá 
this
áá #
.
áá# $
FindComponent
áá$ 1
(
áá1 2
index
áá2 7
)
áá7 8
;
áá8 9
if
ââ 
(
ââ 
index
ââ 
+
ââ 
$num
ââ 
<=
ââ 
c
ââ 
.
ââ 
	EndOffset
ââ (
)
ââ( )
{
ãã 
return
ää 
c
ää 
.
ää 
Buffer
ää 
.
ää  
GetInt
ää  &
(
ää& '
index
ää' ,
-
ää- .
c
ää/ 0
.
ää0 1
Offset
ää1 7
)
ää7 8
;
ää8 9
}
åå 
return
çç 
this
çç 
.
çç 
	_GetShort
çç !
(
çç! "
index
çç" '
)
çç' (
<<
çç) +
$num
çç, .
|
çç/ 0
(
çç1 2
ushort
çç2 8
)
çç8 9
this
çç9 =
.
çç= >
	_GetShort
çç> G
(
ççG H
index
ççH M
+
ççN O
$num
ççP Q
)
ççQ R
;
ççR S
}
èè 	
	protected
êê 
internal
êê 
override
êê #
int
êê$ '
	_GetIntLE
êê( 1
(
êê1 2
int
êê2 5
index
êê6 ;
)
êê; <
{
ëë 	
ComponentEntry
ìì 
c
ìì 
=
ìì 
this
ìì #
.
ìì# $
FindComponent
ìì$ 1
(
ìì1 2
index
ìì2 7
)
ìì7 8
;
ìì8 9
if
íí 
(
íí 
index
íí 
+
íí 
$num
íí 
<=
íí 
c
íí 
.
íí 
	EndOffset
íí (
)
íí( )
{
îî 
return
ïï 
c
ïï 
.
ïï 
Buffer
ïï 
.
ïï  
GetIntLE
ïï  (
(
ïï( )
index
ïï) .
-
ïï/ 0
c
ïï1 2
.
ïï2 3
Offset
ïï3 9
)
ïï9 :
;
ïï: ;
}
ğğ 
return
òò 
(
òò 
this
òò 
.
òò 
_GetShortLE
òò $
(
òò$ %
index
òò% *
)
òò* +
<<
òò, .
$num
òò/ 1
|
òò2 3
(
òò4 5
ushort
òò5 ;
)
òò; <
this
òò< @
.
òò@ A
_GetShortLE
òòA L
(
òòL M
index
òòM R
+
òòS T
$num
òòU V
)
òòV W
)
òòW X
;
òòX Y
}
óó 	
	protected
õõ 
internal
õõ 
override
õõ #
long
õõ$ (
_GetLong
õõ) 1
(
õõ1 2
int
õõ2 5
index
õõ6 ;
)
õõ; <
{
öö 	
ComponentEntry
÷÷ 
c
÷÷ 
=
÷÷ 
this
÷÷ #
.
÷÷# $
FindComponent
÷÷$ 1
(
÷÷1 2
index
÷÷2 7
)
÷÷7 8
;
÷÷8 9
if
øø 
(
øø 
index
øø 
+
øø 
$num
øø 
<=
øø 
c
øø 
.
øø 
	EndOffset
øø (
)
øø( )
{
ùù 
return
úú 
c
úú 
.
úú 
Buffer
úú 
.
úú  
GetLong
úú  '
(
úú' (
index
úú( -
-
úú. /
c
úú0 1
.
úú1 2
Offset
úú2 8
)
úú8 9
;
úú9 :
}
ûû 
return
ıı 
(
ıı 
long
ıı 
)
ıı 
this
ıı 
.
ıı 
_GetInt
ıı %
(
ıı% &
index
ıı& +
)
ıı+ ,
<<
ıı- /
$num
ıı0 2
|
ıı3 4
(
ıı5 6
uint
ıı6 :
)
ıı: ;
this
ıı; ?
.
ıı? @
_GetInt
ıı@ G
(
ııG H
index
ııH M
+
ııN O
$num
ııP Q
)
ııQ R
;
ııR S
}
şş 	
	protected
€€ 
internal
€€ 
override
€€ #
long
€€$ (

_GetLongLE
€€) 3
(
€€3 4
int
€€4 7
index
€€8 =
)
€€= >
{
 	
ComponentEntry
‚‚ 
c
‚‚ 
=
‚‚ 
this
‚‚ #
.
‚‚# $
FindComponent
‚‚$ 1
(
‚‚1 2
index
‚‚2 7
)
‚‚7 8
;
‚‚8 9
if
ƒƒ 
(
ƒƒ 
index
ƒƒ 
+
ƒƒ 
$num
ƒƒ 
<=
ƒƒ 
c
ƒƒ 
.
ƒƒ 
	EndOffset
ƒƒ (
)
ƒƒ( )
{
„„ 
return
…… 
c
…… 
.
…… 
Buffer
…… 
.
……  
	GetLongLE
……  )
(
……) *
index
……* /
-
……0 1
c
……2 3
.
……3 4
Offset
……4 :
)
……: ;
;
……; <
}
†† 
return
ˆˆ 
(
ˆˆ 
this
ˆˆ 
.
ˆˆ 
	_GetIntLE
ˆˆ "
(
ˆˆ" #
index
ˆˆ# (
)
ˆˆ( )
<<
ˆˆ* ,
$num
ˆˆ- /
|
ˆˆ0 1
this
ˆˆ2 6
.
ˆˆ6 7
	_GetIntLE
ˆˆ7 @
(
ˆˆ@ A
index
ˆˆA F
+
ˆˆG H
$num
ˆˆI J
)
ˆˆJ K
)
ˆˆK L
;
ˆˆL M
}
‰‰ 	
public
‹‹ 
override
‹‹ 
IByteBuffer
‹‹ #
GetBytes
‹‹$ ,
(
‹‹, -
int
‹‹- 0
index
‹‹1 6
,
‹‹6 7
byte
‹‹8 <
[
‹‹< =
]
‹‹= >
dst
‹‹? B
,
‹‹B C
int
‹‹D G
dstIndex
‹‹H P
,
‹‹P Q
int
‹‹R U
length
‹‹V \
)
‹‹\ ]
{
ŒŒ 	
this
 
.
 
CheckDstIndex
 
(
 
index
 $
,
$ %
length
& ,
,
, -
dstIndex
. 6
,
6 7
dst
8 ;
.
; <
Length
< B
)
B C
;
C D
if
 
(
 
length
 
==
 
$num
 
)
 
{
 
return
 
this
 
;
 
}
‘‘ 
int
““ 
i
““ 
=
““ 
this
““ 
.
““ 
ToComponentIndex
““ )
(
““) *
index
““* /
)
““/ 0
;
““0 1
while
”” 
(
”” 
length
”” 
>
”” 
$num
”” 
)
”” 
{
•• 
ComponentEntry
–– 
c
––  
=
––! "
this
––# '
.
––' (

components
––( 2
[
––2 3
i
––3 4
]
––4 5
;
––5 6
IByteBuffer
—— 
s
—— 
=
—— 
c
——  !
.
——! "
Buffer
——" (
;
——( )
int
˜˜ 

adjustment
˜˜ 
=
˜˜  
c
˜˜! "
.
˜˜" #
Offset
˜˜# )
;
˜˜) *
int
™™ 
localLength
™™ 
=
™™  !
Math
™™" &
.
™™& '
Min
™™' *
(
™™* +
length
™™+ 1
,
™™1 2
s
™™3 4
.
™™4 5
Capacity
™™5 =
-
™™> ?
(
™™@ A
index
™™A F
-
™™G H

adjustment
™™I S
)
™™S T
)
™™T U
;
™™U V
s
šš 
.
šš 
GetBytes
šš 
(
šš 
index
šš  
-
šš! "

adjustment
šš# -
,
šš- .
dst
šš/ 2
,
šš2 3
dstIndex
šš4 <
,
šš< =
localLength
šš> I
)
ššI J
;
ššJ K
index
›› 
+=
›› 
localLength
›› $
;
››$ %
dstIndex
œœ 
+=
œœ 
localLength
œœ '
;
œœ' (
length
 
-=
 
localLength
 %
;
% &
i
 
++
 
;
 
}
ŸŸ 
return
   
this
   
;
   
}
¡¡ 	
public
££ 
override
££ 
IByteBuffer
££ #
GetBytes
££$ ,
(
££, -
int
££- 0
index
££1 6
,
££6 7
Stream
££8 >
destination
££? J
,
££J K
int
££L O
length
££P V
)
££V W
{
¤¤ 	
this
¥¥ 
.
¥¥ 

CheckIndex
¥¥ 
(
¥¥ 
index
¥¥ !
,
¥¥! "
length
¥¥# )
)
¥¥) *
;
¥¥* +
if
¦¦ 
(
¦¦ 
length
¦¦ 
==
¦¦ 
$num
¦¦ 
)
¦¦ 
{
§§ 
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
©© 
int
«« 
i
«« 
=
«« 
this
«« 
.
«« 
ToComponentIndex
«« )
(
««) *
index
««* /
)
««/ 0
;
««0 1
while
¬¬ 
(
¬¬ 
length
¬¬ 
>
¬¬ 
$num
¬¬ 
)
¬¬ 
{
­­ 
ComponentEntry
®® 
c
®®  
=
®®! "
this
®®# '
.
®®' (

components
®®( 2
[
®®2 3
i
®®3 4
]
®®4 5
;
®®5 6
IByteBuffer
¯¯ 
s
¯¯ 
=
¯¯ 
c
¯¯  !
.
¯¯! "
Buffer
¯¯" (
;
¯¯( )
int
°° 

adjustment
°° 
=
°°  
c
°°! "
.
°°" #
Offset
°°# )
;
°°) *
int
±± 
localLength
±± 
=
±±  !
Math
±±" &
.
±±& '
Min
±±' *
(
±±* +
length
±±+ 1
,
±±1 2
s
±±3 4
.
±±4 5
Capacity
±±5 =
-
±±> ?
(
±±@ A
index
±±A F
-
±±G H

adjustment
±±I S
)
±±S T
)
±±T U
;
±±U V
s
²² 
.
²² 
GetBytes
²² 
(
²² 
index
²²  
-
²²! "

adjustment
²²# -
,
²²- .
destination
²²/ :
,
²²: ;
localLength
²²< G
)
²²G H
;
²²H I
index
³³ 
+=
³³ 
localLength
³³ $
;
³³$ %
length
´´ 
-=
´´ 
localLength
´´ %
;
´´% &
i
µµ 
++
µµ 
;
µµ 
}
¶¶ 
return
·· 
this
·· 
;
·· 
}
¸¸ 	
public
ºº 
override
ºº 
IByteBuffer
ºº #
GetBytes
ºº$ ,
(
ºº, -
int
ºº- 0
index
ºº1 6
,
ºº6 7
IByteBuffer
ºº8 C
dst
ººD G
,
ººG H
int
ººI L
dstIndex
ººM U
,
ººU V
int
ººW Z
length
ºº[ a
)
ººa b
{
»» 	
this
¼¼ 
.
¼¼ 
CheckDstIndex
¼¼ 
(
¼¼ 
index
¼¼ $
,
¼¼$ %
length
¼¼& ,
,
¼¼, -
dstIndex
¼¼. 6
,
¼¼6 7
dst
¼¼8 ;
.
¼¼; <
Capacity
¼¼< D
)
¼¼D E
;
¼¼E F
if
½½ 
(
½½ 
length
½½ 
==
½½ 
$num
½½ 
)
½½ 
{
¾¾ 
return
¿¿ 
this
¿¿ 
;
¿¿ 
}
ÀÀ 
int
ÂÂ 
i
ÂÂ 
=
ÂÂ 
this
ÂÂ 
.
ÂÂ 
ToComponentIndex
ÂÂ )
(
ÂÂ) *
index
ÂÂ* /
)
ÂÂ/ 0
;
ÂÂ0 1
while
ÃÃ 
(
ÃÃ 
length
ÃÃ 
>
ÃÃ 
$num
ÃÃ 
)
ÃÃ 
{
ÄÄ 
ComponentEntry
ÅÅ 
c
ÅÅ  
=
ÅÅ! "
this
ÅÅ# '
.
ÅÅ' (

components
ÅÅ( 2
[
ÅÅ2 3
i
ÅÅ3 4
]
ÅÅ4 5
;
ÅÅ5 6
IByteBuffer
ÆÆ 
s
ÆÆ 
=
ÆÆ 
c
ÆÆ  !
.
ÆÆ! "
Buffer
ÆÆ" (
;
ÆÆ( )
int
ÇÇ 

adjustment
ÇÇ 
=
ÇÇ  
c
ÇÇ! "
.
ÇÇ" #
Offset
ÇÇ# )
;
ÇÇ) *
int
ÈÈ 
localLength
ÈÈ 
=
ÈÈ  !
Math
ÈÈ" &
.
ÈÈ& '
Min
ÈÈ' *
(
ÈÈ* +
length
ÈÈ+ 1
,
ÈÈ1 2
s
ÈÈ3 4
.
ÈÈ4 5
Capacity
ÈÈ5 =
-
ÈÈ> ?
(
ÈÈ@ A
index
ÈÈA F
-
ÈÈG H

adjustment
ÈÈI S
)
ÈÈS T
)
ÈÈT U
;
ÈÈU V
s
ÉÉ 
.
ÉÉ 
GetBytes
ÉÉ 
(
ÉÉ 
index
ÉÉ  
-
ÉÉ! "

adjustment
ÉÉ# -
,
ÉÉ- .
dst
ÉÉ/ 2
,
ÉÉ2 3
dstIndex
ÉÉ4 <
,
ÉÉ< =
localLength
ÉÉ> I
)
ÉÉI J
;
ÉÉJ K
index
ÊÊ 
+=
ÊÊ 
localLength
ÊÊ $
;
ÊÊ$ %
dstIndex
ËË 
+=
ËË 
localLength
ËË '
;
ËË' (
length
ÌÌ 
-=
ÌÌ 
localLength
ÌÌ %
;
ÌÌ% &
i
ÍÍ 
++
ÍÍ 
;
ÍÍ 
}
ÎÎ 
return
ÏÏ 
this
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
	protected
ÒÒ 
internal
ÒÒ 
override
ÒÒ #
void
ÒÒ$ (
_SetByte
ÒÒ) 1
(
ÒÒ1 2
int
ÒÒ2 5
index
ÒÒ6 ;
,
ÒÒ; <
int
ÒÒ= @
value
ÒÒA F
)
ÒÒF G
{
ÓÓ 	
ComponentEntry
ÔÔ 
c
ÔÔ 
=
ÔÔ 
this
ÔÔ #
.
ÔÔ# $
FindComponent
ÔÔ$ 1
(
ÔÔ1 2
index
ÔÔ2 7
)
ÔÔ7 8
;
ÔÔ8 9
c
ÕÕ 
.
ÕÕ 
Buffer
ÕÕ 
.
ÕÕ 
SetByte
ÕÕ 
(
ÕÕ 
index
ÕÕ "
-
ÕÕ# $
c
ÕÕ% &
.
ÕÕ& '
Offset
ÕÕ' -
,
ÕÕ- .
value
ÕÕ/ 4
)
ÕÕ4 5
;
ÕÕ5 6
}
ÖÖ 	
	protected
ØØ 
internal
ØØ 
override
ØØ #
void
ØØ$ (
	_SetShort
ØØ) 2
(
ØØ2 3
int
ØØ3 6
index
ØØ7 <
,
ØØ< =
int
ØØ> A
value
ØØB G
)
ØØG H
{
ÙÙ 	
ComponentEntry
ÚÚ 
c
ÚÚ 
=
ÚÚ 
this
ÚÚ #
.
ÚÚ# $
FindComponent
ÚÚ$ 1
(
ÚÚ1 2
index
ÚÚ2 7
)
ÚÚ7 8
;
ÚÚ8 9
if
ÛÛ 
(
ÛÛ 
index
ÛÛ 
+
ÛÛ 
$num
ÛÛ 
<=
ÛÛ 
c
ÛÛ 
.
ÛÛ 
	EndOffset
ÛÛ (
)
ÛÛ( )
{
ÜÜ 
c
İİ 
.
İİ 
Buffer
İİ 
.
İİ 
SetShort
İİ !
(
İİ! "
index
İİ" '
-
İİ( )
c
İİ* +
.
İİ+ ,
Offset
İİ, 2
,
İİ2 3
value
İİ4 9
)
İİ9 :
;
İİ: ;
}
ŞŞ 
else
ßß 
{
àà 
this
áá 
.
áá 
_SetByte
áá 
(
áá 
index
áá #
,
áá# $
(
áá% &
byte
áá& *
)
áá* +
(
áá+ ,
(
áá, -
uint
áá- 1
)
áá1 2
value
áá2 7
>>
áá8 :
$num
áá; <
)
áá< =
)
áá= >
;
áá> ?
this
ââ 
.
ââ 
_SetByte
ââ 
(
ââ 
index
ââ #
+
ââ$ %
$num
ââ& '
,
ââ' (
(
ââ) *
byte
ââ* .
)
ââ. /
value
ââ/ 4
)
ââ4 5
;
ââ5 6
}
ãã 
}
ää 	
	protected
ææ 
internal
ææ 
override
ææ #
void
ææ$ (
_SetShortLE
ææ) 4
(
ææ4 5
int
ææ5 8
index
ææ9 >
,
ææ> ?
int
ææ@ C
value
ææD I
)
ææI J
{
çç 	
ComponentEntry
èè 
c
èè 
=
èè 
this
èè #
.
èè# $
FindComponent
èè$ 1
(
èè1 2
index
èè2 7
)
èè7 8
;
èè8 9
if
éé 
(
éé 
index
éé 
+
éé 
$num
éé 
<=
éé 
c
éé 
.
éé 
	EndOffset
éé (
)
éé( )
{
êê 
c
ëë 
.
ëë 
Buffer
ëë 
.
ëë 

SetShortLE
ëë #
(
ëë# $
index
ëë$ )
-
ëë* +
c
ëë, -
.
ëë- .
Offset
ëë. 4
,
ëë4 5
value
ëë6 ;
)
ëë; <
;
ëë< =
}
ìì 
else
íí 
{
îî 
this
ïï 
.
ïï 
_SetByte
ïï 
(
ïï 
index
ïï #
,
ïï# $
(
ïï% &
byte
ïï& *
)
ïï* +
(
ïï+ ,
value
ïï, 1
.
ïï1 2
RightUShift
ïï2 =
(
ïï= >
$num
ïï> ?
)
ïï? @
)
ïï@ A
)
ïïA B
;
ïïB C
this
ğğ 
.
ğğ 
_SetByte
ğğ 
(
ğğ 
index
ğğ #
+
ğğ$ %
$num
ğğ& '
,
ğğ' (
(
ğğ) *
byte
ğğ* .
)
ğğ. /
value
ğğ/ 4
)
ğğ4 5
;
ğğ5 6
}
ññ 
}
òò 	
	protected
ôô 
internal
ôô 
override
ôô #
void
ôô$ (

_SetMedium
ôô) 3
(
ôô3 4
int
ôô4 7
index
ôô8 =
,
ôô= >
int
ôô? B
value
ôôC H
)
ôôH I
{
õõ 	
ComponentEntry
öö 
c
öö 
=
öö 
this
öö #
.
öö# $
FindComponent
öö$ 1
(
öö1 2
index
öö2 7
)
öö7 8
;
öö8 9
if
÷÷ 
(
÷÷ 
index
÷÷ 
+
÷÷ 
$num
÷÷ 
<=
÷÷ 
c
÷÷ 
.
÷÷ 
	EndOffset
÷÷ (
)
÷÷( )
{
øø 
c
ùù 
.
ùù 
Buffer
ùù 
.
ùù 
	SetMedium
ùù "
(
ùù" #
index
ùù# (
-
ùù) *
c
ùù+ ,
.
ùù, -
Offset
ùù- 3
,
ùù3 4
value
ùù5 :
)
ùù: ;
;
ùù; <
}
úú 
else
ûû 
{
üü 
this
ıı 
.
ıı 
	_SetShort
ıı 
(
ıı 
index
ıı $
,
ıı$ %
(
ıı& '
short
ıı' ,
)
ıı, -
(
ıı- .
value
ıı. 3
>>
ıı4 6
$num
ıı7 8
)
ıı8 9
)
ıı9 :
;
ıı: ;
this
şş 
.
şş 
_SetByte
şş 
(
şş 
index
şş #
+
şş$ %
$num
şş& '
,
şş' (
(
şş) *
byte
şş* .
)
şş. /
value
şş/ 4
)
şş4 5
;
şş5 6
}
ÿÿ 
}
€€ 	
	protected
‚‚ 
internal
‚‚ 
override
‚‚ #
void
‚‚$ (
_SetMediumLE
‚‚) 5
(
‚‚5 6
int
‚‚6 9
index
‚‚: ?
,
‚‚? @
int
‚‚A D
value
‚‚E J
)
‚‚J K
{
ƒƒ 	
ComponentEntry
„„ 
c
„„ 
=
„„ 
this
„„ #
.
„„# $
FindComponent
„„$ 1
(
„„1 2
index
„„2 7
)
„„7 8
;
„„8 9
if
…… 
(
…… 
index
…… 
+
…… 
$num
…… 
<=
…… 
c
…… 
.
…… 
	EndOffset
…… (
)
……( )
{
†† 
c
‡‡ 
.
‡‡ 
Buffer
‡‡ 
.
‡‡ 
SetMediumLE
‡‡ $
(
‡‡$ %
index
‡‡% *
-
‡‡+ ,
c
‡‡- .
.
‡‡. /
Offset
‡‡/ 5
,
‡‡5 6
value
‡‡7 <
)
‡‡< =
;
‡‡= >
}
ˆˆ 
else
‰‰ 
{
ŠŠ 
this
‹‹ 
.
‹‹ 
_SetShortLE
‹‹  
(
‹‹  !
index
‹‹! &
,
‹‹& '
(
‹‹( )
short
‹‹) .
)
‹‹. /
(
‹‹/ 0
value
‹‹0 5
>>
‹‹6 8
$num
‹‹9 :
)
‹‹: ;
)
‹‹; <
;
‹‹< =
this
ŒŒ 
.
ŒŒ 
_SetByte
ŒŒ 
(
ŒŒ 
index
ŒŒ #
+
ŒŒ$ %
$num
ŒŒ& '
,
ŒŒ' (
(
ŒŒ) *
byte
ŒŒ* .
)
ŒŒ. /
value
ŒŒ/ 4
)
ŒŒ4 5
;
ŒŒ5 6
}
 
}
 	
	protected
 
internal
 
override
 #
void
$ (
_SetInt
) 0
(
0 1
int
1 4
index
5 :
,
: ;
int
< ?
value
@ E
)
E F
{
‘‘ 	
ComponentEntry
’’ 
c
’’ 
=
’’ 
this
’’ #
.
’’# $
FindComponent
’’$ 1
(
’’1 2
index
’’2 7
)
’’7 8
;
’’8 9
if
““ 
(
““ 
index
““ 
+
““ 
$num
““ 
<=
““ 
c
““ 
.
““ 
	EndOffset
““ (
)
““( )
{
”” 
c
•• 
.
•• 
Buffer
•• 
.
•• 
SetInt
•• 
(
••  
index
••  %
-
••& '
c
••( )
.
••) *
Offset
••* 0
,
••0 1
value
••2 7
)
••7 8
;
••8 9
}
–– 
else
—— 
{
˜˜ 
this
™™ 
.
™™ 
	_SetShort
™™ 
(
™™ 
index
™™ $
,
™™$ %
(
™™& '
short
™™' ,
)
™™, -
(
™™- .
(
™™. /
uint
™™/ 3
)
™™3 4
value
™™4 9
>>
™™: <
$num
™™= ?
)
™™? @
)
™™@ A
;
™™A B
this
šš 
.
šš 
	_SetShort
šš 
(
šš 
index
šš $
+
šš% &
$num
šš' (
,
šš( )
(
šš* +
short
šš+ 0
)
šš0 1
value
šš1 6
)
šš6 7
;
šš7 8
}
›› 
}
œœ 	
	protected
 
internal
 
override
 #
void
$ (
	_SetIntLE
) 2
(
2 3
int
3 6
index
7 <
,
< =
int
> A
value
B G
)
G H
{
ŸŸ 	
ComponentEntry
   
c
   
=
   
this
   #
.
  # $
FindComponent
  $ 1
(
  1 2
index
  2 7
)
  7 8
;
  8 9
if
¡¡ 
(
¡¡ 
index
¡¡ 
+
¡¡ 
$num
¡¡ 
<=
¡¡ 
c
¡¡ 
.
¡¡ 
	EndOffset
¡¡ (
)
¡¡( )
{
¢¢ 
c
££ 
.
££ 
Buffer
££ 
.
££ 
SetIntLE
££ !
(
££! "
index
££" '
-
££( )
c
££* +
.
££+ ,
Offset
££, 2
,
££2 3
value
££4 9
)
££9 :
;
££: ;
}
¤¤ 
else
¥¥ 
{
¦¦ 
this
§§ 
.
§§ 
_SetShortLE
§§  
(
§§  !
index
§§! &
,
§§& '
(
§§( )
short
§§) .
)
§§. /
value
§§/ 4
.
§§4 5
RightUShift
§§5 @
(
§§@ A
$num
§§A C
)
§§C D
)
§§D E
;
§§E F
this
¨¨ 
.
¨¨ 
_SetShortLE
¨¨  
(
¨¨  !
index
¨¨! &
+
¨¨' (
$num
¨¨) *
,
¨¨* +
(
¨¨, -
short
¨¨- 2
)
¨¨2 3
value
¨¨3 8
)
¨¨8 9
;
¨¨9 :
}
©© 
}
ªª 	
	protected
¬¬ 
internal
¬¬ 
override
¬¬ #
void
¬¬$ (
_SetLong
¬¬) 1
(
¬¬1 2
int
¬¬2 5
index
¬¬6 ;
,
¬¬; <
long
¬¬= A
value
¬¬B G
)
¬¬G H
{
­­ 	
ComponentEntry
®® 
c
®® 
=
®® 
this
®® #
.
®®# $
FindComponent
®®$ 1
(
®®1 2
index
®®2 7
)
®®7 8
;
®®8 9
if
¯¯ 
(
¯¯ 
index
¯¯ 
+
¯¯ 
$num
¯¯ 
<=
¯¯ 
c
¯¯ 
.
¯¯ 
	EndOffset
¯¯ (
)
¯¯( )
{
°° 
c
±± 
.
±± 
Buffer
±± 
.
±± 
SetLong
±±  
(
±±  !
index
±±! &
-
±±' (
c
±±) *
.
±±* +
Offset
±±+ 1
,
±±1 2
value
±±3 8
)
±±8 9
;
±±9 :
}
²² 
else
³³ 
{
´´ 
this
µµ 
.
µµ 
_SetInt
µµ 
(
µµ 
index
µµ "
,
µµ" #
(
µµ$ %
int
µµ% (
)
µµ( )
(
µµ) *
(
µµ* +
ulong
µµ+ 0
)
µµ0 1
value
µµ1 6
>>
µµ7 9
$num
µµ: <
)
µµ< =
)
µµ= >
;
µµ> ?
this
¶¶ 
.
¶¶ 
_SetInt
¶¶ 
(
¶¶ 
index
¶¶ "
+
¶¶# $
$num
¶¶% &
,
¶¶& '
(
¶¶( )
int
¶¶) ,
)
¶¶, -
value
¶¶- 2
)
¶¶2 3
;
¶¶3 4
}
·· 
}
¸¸ 	
	protected
ºº 
internal
ºº 
override
ºº #
void
ºº$ (

_SetLongLE
ºº) 3
(
ºº3 4
int
ºº4 7
index
ºº8 =
,
ºº= >
long
ºº? C
value
ººD I
)
ººI J
{
»» 	
ComponentEntry
¼¼ 
c
¼¼ 
=
¼¼ 
this
¼¼ #
.
¼¼# $
FindComponent
¼¼$ 1
(
¼¼1 2
index
¼¼2 7
)
¼¼7 8
;
¼¼8 9
if
½½ 
(
½½ 
index
½½ 
+
½½ 
$num
½½ 
<=
½½ 
c
½½ 
.
½½ 
	EndOffset
½½ (
)
½½( )
{
¾¾ 
c
¿¿ 
.
¿¿ 
Buffer
¿¿ 
.
¿¿ 
	SetLongLE
¿¿ "
(
¿¿" #
index
¿¿# (
-
¿¿) *
c
¿¿+ ,
.
¿¿, -
Offset
¿¿- 3
,
¿¿3 4
value
¿¿5 :
)
¿¿: ;
;
¿¿; <
}
ÀÀ 
else
ÁÁ 
{
ÂÂ 
this
ÃÃ 
.
ÃÃ 
	_SetIntLE
ÃÃ 
(
ÃÃ 
index
ÃÃ $
,
ÃÃ$ %
(
ÃÃ& '
int
ÃÃ' *
)
ÃÃ* +
value
ÃÃ+ 0
.
ÃÃ0 1
RightUShift
ÃÃ1 <
(
ÃÃ< =
$num
ÃÃ= ?
)
ÃÃ? @
)
ÃÃ@ A
;
ÃÃA B
this
ÄÄ 
.
ÄÄ 
	_SetIntLE
ÄÄ 
(
ÄÄ 
index
ÄÄ $
+
ÄÄ% &
$num
ÄÄ' (
,
ÄÄ( )
(
ÄÄ* +
int
ÄÄ+ .
)
ÄÄ. /
value
ÄÄ/ 4
)
ÄÄ4 5
;
ÄÄ5 6
}
ÅÅ 
}
ÆÆ 	
public
ÈÈ 
override
ÈÈ 
IByteBuffer
ÈÈ #
SetBytes
ÈÈ$ ,
(
ÈÈ, -
int
ÈÈ- 0
index
ÈÈ1 6
,
ÈÈ6 7
byte
ÈÈ8 <
[
ÈÈ< =
]
ÈÈ= >
src
ÈÈ? B
,
ÈÈB C
int
ÈÈD G
srcIndex
ÈÈH P
,
ÈÈP Q
int
ÈÈR U
length
ÈÈV \
)
ÈÈ\ ]
{
ÉÉ 	
this
ÊÊ 
.
ÊÊ 
CheckSrcIndex
ÊÊ 
(
ÊÊ 
index
ÊÊ $
,
ÊÊ$ %
length
ÊÊ& ,
,
ÊÊ, -
srcIndex
ÊÊ. 6
,
ÊÊ6 7
src
ÊÊ8 ;
.
ÊÊ; <
Length
ÊÊ< B
)
ÊÊB C
;
ÊÊC D
if
ËË 
(
ËË 
length
ËË 
==
ËË 
$num
ËË 
)
ËË 
{
ÌÌ 
return
ÍÍ 
this
ÍÍ 
;
ÍÍ 
}
ÎÎ 
int
ĞĞ 
i
ĞĞ 
=
ĞĞ 
this
ĞĞ 
.
ĞĞ 
ToComponentIndex
ĞĞ )
(
ĞĞ) *
index
ĞĞ* /
)
ĞĞ/ 0
;
ĞĞ0 1
while
ÑÑ 
(
ÑÑ 
length
ÑÑ 
>
ÑÑ 
$num
ÑÑ 
)
ÑÑ 
{
ÒÒ 
ComponentEntry
ÓÓ 
c
ÓÓ  
=
ÓÓ! "
this
ÓÓ# '
.
ÓÓ' (

components
ÓÓ( 2
[
ÓÓ2 3
i
ÓÓ3 4
]
ÓÓ4 5
;
ÓÓ5 6
IByteBuffer
ÔÔ 
s
ÔÔ 
=
ÔÔ 
c
ÔÔ  !
.
ÔÔ! "
Buffer
ÔÔ" (
;
ÔÔ( )
int
ÕÕ 

adjustment
ÕÕ 
=
ÕÕ  
c
ÕÕ! "
.
ÕÕ" #
Offset
ÕÕ# )
;
ÕÕ) *
int
ÖÖ 
localLength
ÖÖ 
=
ÖÖ  !
Math
ÖÖ" &
.
ÖÖ& '
Min
ÖÖ' *
(
ÖÖ* +
length
ÖÖ+ 1
,
ÖÖ1 2
s
ÖÖ3 4
.
ÖÖ4 5
Capacity
ÖÖ5 =
-
ÖÖ> ?
(
ÖÖ@ A
index
ÖÖA F
-
ÖÖG H

adjustment
ÖÖI S
)
ÖÖS T
)
ÖÖT U
;
ÖÖU V
s
×× 
.
×× 
SetBytes
×× 
(
×× 
index
××  
-
××! "

adjustment
××# -
,
××- .
src
××/ 2
,
××2 3
srcIndex
××4 <
,
××< =
localLength
××> I
)
××I J
;
××J K
index
ØØ 
+=
ØØ 
localLength
ØØ $
;
ØØ$ %
srcIndex
ÙÙ 
+=
ÙÙ 
localLength
ÙÙ '
;
ÙÙ' (
length
ÚÚ 
-=
ÚÚ 
localLength
ÚÚ %
;
ÚÚ% &
i
ÛÛ 
++
ÛÛ 
;
ÛÛ 
}
ÜÜ 
return
İİ 
this
İİ 
;
İİ 
}
ŞŞ 	
public
àà 
override
àà 
async
àà 
Task
àà "
<
àà" #
int
àà# &
>
àà& '
SetBytesAsync
àà( 5
(
àà5 6
int
àà6 9
index
àà: ?
,
àà? @
Stream
ààA G
src
ààH K
,
ààK L
int
ààM P
length
ààQ W
,
ààW X
CancellationToken
ààY j
cancellationToken
ààk |
)
àà| }
{
áá 	
this
ââ 
.
ââ 

CheckIndex
ââ 
(
ââ 
index
ââ !
,
ââ! "
length
ââ# )
)
ââ) *
;
ââ* +
if
ãã 
(
ãã 
length
ãã 
==
ãã 
$num
ãã 
)
ãã 
{
ää 
return
åå 
$num
åå 
;
åå 
}
çç 
int
éé 
i
éé 
=
éé 
this
éé 
.
éé 
ToComponentIndex
éé )
(
éé) *
index
éé* /
)
éé/ 0
;
éé0 1
int
êê 
	readBytes
êê 
=
êê 
$num
êê 
;
êê 
do
ìì 
{
íí 
ComponentEntry
îî 
c
îî  
=
îî! "
this
îî# '
.
îî' (

components
îî( 2
[
îî2 3
i
îî3 4
]
îî4 5
;
îî5 6
IByteBuffer
ïï 
s
ïï 
=
ïï 
c
ïï  !
.
ïï! "
Buffer
ïï" (
;
ïï( )
int
ğğ 

adjustment
ğğ 
=
ğğ  
c
ğğ! "
.
ğğ" #
Offset
ğğ# )
;
ğğ) *
int
ññ 
localLength
ññ 
=
ññ  !
Math
ññ" &
.
ññ& '
Min
ññ' *
(
ññ* +
length
ññ+ 1
,
ññ1 2
s
ññ3 4
.
ññ4 5
Capacity
ññ5 =
-
ññ> ?
(
ññ@ A
index
ññA F
-
ññG H

adjustment
ññI S
)
ññS T
)
ññT U
;
ññU V
int
òò 
localReadBytes
òò "
=
òò# $
await
òò% *
s
òò+ ,
.
òò, -
SetBytesAsync
òò- :
(
òò: ;
index
òò; @
-
òòA B

adjustment
òòC M
,
òòM N
src
òòO R
,
òòR S
localLength
òòT _
,
òò_ `
cancellationToken
òòa r
)
òòr s
;
òòs t
if
óó 
(
óó 
localReadBytes
óó "
<
óó# $
$num
óó% &
)
óó& '
{
ôô 
if
õõ 
(
õõ 
	readBytes
õõ !
==
õõ" $
$num
õõ% &
)
õõ& '
{
öö 
return
÷÷ 
-
÷÷  
$num
÷÷  !
;
÷÷! "
}
øø 
else
ùù 
{
úú 
break
ûû 
;
ûû 
}
üü 
}
ıı 
if
ÿÿ 
(
ÿÿ 
localReadBytes
ÿÿ "
==
ÿÿ# %
localLength
ÿÿ& 1
)
ÿÿ1 2
{
€	€	 
index
		 
+=
		 
localLength
		 (
;
		( )
length
‚	‚	 
-=
‚	‚	 
localLength
‚	‚	 )
;
‚	‚	) *
	readBytes
ƒ	ƒ	 
+=
ƒ	ƒ	  
localLength
ƒ	ƒ	! ,
;
ƒ	ƒ	, -
i
„	„	 
++
„	„	 
;
„	„	 
}
…	…	 
else
†	†	 
{
‡	‡	 
index
ˆ	ˆ	 
+=
ˆ	ˆ	 
localReadBytes
ˆ	ˆ	 +
;
ˆ	ˆ	+ ,
length
‰	‰	 
-=
‰	‰	 
localReadBytes
‰	‰	 ,
;
‰	‰	, -
	readBytes
Š	Š	 
+=
Š	Š	  
localReadBytes
Š	Š	! /
;
Š	Š	/ 0
}
‹	‹	 
}
Œ	Œ	 
while
		 
(
		 
length
		 
>
		 
$num
		 
)
		 
;
		 
return
		 
	readBytes
		 
;
		 
}
		 	
public
’	’	 
override
’	’	 
IByteBuffer
’	’	 #
SetBytes
’	’	$ ,
(
’	’	, -
int
’	’	- 0
index
’	’	1 6
,
’	’	6 7
IByteBuffer
’	’	8 C
src
’	’	D G
,
’	’	G H
int
’	’	I L
srcIndex
’	’	M U
,
’	’	U V
int
’	’	W Z
length
’	’	[ a
)
’	’	a b
{
“	“	 	
this
”	”	 
.
”	”	 
CheckSrcIndex
”	”	 
(
”	”	 
index
”	”	 $
,
”	”	$ %
length
”	”	& ,
,
”	”	, -
srcIndex
”	”	. 6
,
”	”	6 7
src
”	”	8 ;
.
”	”	; <
Capacity
”	”	< D
)
”	”	D E
;
”	”	E F
if
•	•	 
(
•	•	 
length
•	•	 
==
•	•	 
$num
•	•	 
)
•	•	 
{
–	–	 
return
—	—	 
this
—	—	 
;
—	—	 
}
˜	˜	 
int
š	š	 
i
š	š	 
=
š	š	 
this
š	š	 
.
š	š	 
ToComponentIndex
š	š	 )
(
š	š	) *
index
š	š	* /
)
š	š	/ 0
;
š	š	0 1
while
›	›	 
(
›	›	 
length
›	›	 
>
›	›	 
$num
›	›	 
)
›	›	 
{
œ	œ	 
ComponentEntry
		 
c
		  
=
		! "
this
		# '
.
		' (

components
		( 2
[
		2 3
i
		3 4
]
		4 5
;
		5 6
IByteBuffer
		 
s
		 
=
		 
c
		  !
.
		! "
Buffer
		" (
;
		( )
int
Ÿ	Ÿ	 

adjustment
Ÿ	Ÿ	 
=
Ÿ	Ÿ	  
c
Ÿ	Ÿ	! "
.
Ÿ	Ÿ	" #
Offset
Ÿ	Ÿ	# )
;
Ÿ	Ÿ	) *
int
 	 	 
localLength
 	 	 
=
 	 	  !
Math
 	 	" &
.
 	 	& '
Min
 	 	' *
(
 	 	* +
length
 	 	+ 1
,
 	 	1 2
s
 	 	3 4
.
 	 	4 5
Capacity
 	 	5 =
-
 	 	> ?
(
 	 	@ A
index
 	 	A F
-
 	 	G H

adjustment
 	 	I S
)
 	 	S T
)
 	 	T U
;
 	 	U V
s
¡	¡	 
.
¡	¡	 
SetBytes
¡	¡	 
(
¡	¡	 
index
¡	¡	  
-
¡	¡	! "

adjustment
¡	¡	# -
,
¡	¡	- .
src
¡	¡	/ 2
,
¡	¡	2 3
srcIndex
¡	¡	4 <
,
¡	¡	< =
localLength
¡	¡	> I
)
¡	¡	I J
;
¡	¡	J K
index
¢	¢	 
+=
¢	¢	 
localLength
¢	¢	 $
;
¢	¢	$ %
srcIndex
£	£	 
+=
£	£	 
localLength
£	£	 '
;
£	£	' (
length
¤	¤	 
-=
¤	¤	 
localLength
¤	¤	 %
;
¤	¤	% &
i
¥	¥	 
++
¥	¥	 
;
¥	¥	 
}
¦	¦	 
return
§	§	 
this
§	§	 
;
§	§	 
}
¨	¨	 	
public
ª	ª	 
override
ª	ª	 
IByteBuffer
ª	ª	 #
SetZero
ª	ª	$ +
(
ª	ª	+ ,
int
ª	ª	, /
index
ª	ª	0 5
,
ª	ª	5 6
int
ª	ª	7 :
length
ª	ª	; A
)
ª	ª	A B
{
«	«	 	
this
¬	¬	 
.
¬	¬	 

CheckIndex
¬	¬	 
(
¬	¬	 
index
¬	¬	 !
,
¬	¬	! "
length
¬	¬	# )
)
¬	¬	) *
;
¬	¬	* +
if
­	­	 
(
­	­	 
length
­	­	 
==
­	­	 
$num
­	­	 
)
­	­	 
{
®	®	 
return
¯	¯	 
this
¯	¯	 
;
¯	¯	 
}
°	°	 
int
²	²	 
i
²	²	 
=
²	²	 
this
²	²	 
.
²	²	 
ToComponentIndex
²	²	 )
(
²	²	) *
index
²	²	* /
)
²	²	/ 0
;
²	²	0 1
while
³	³	 
(
³	³	 
length
³	³	 
>
³	³	 
$num
³	³	 
)
³	³	 
{
´	´	 
ComponentEntry
µ	µ	 
c
µ	µ	  
=
µ	µ	! "
this
µ	µ	# '
.
µ	µ	' (

components
µ	µ	( 2
[
µ	µ	2 3
i
µ	µ	3 4
]
µ	µ	4 5
;
µ	µ	5 6
IByteBuffer
¶	¶	 
s
¶	¶	 
=
¶	¶	 
c
¶	¶	  !
.
¶	¶	! "
Buffer
¶	¶	" (
;
¶	¶	( )
int
·	·	 

adjustment
·	·	 
=
·	·	  
c
·	·	! "
.
·	·	" #
Offset
·	·	# )
;
·	·	) *
int
¸	¸	 
localLength
¸	¸	 
=
¸	¸	  !
Math
¸	¸	" &
.
¸	¸	& '
Min
¸	¸	' *
(
¸	¸	* +
length
¸	¸	+ 1
,
¸	¸	1 2
s
¸	¸	3 4
.
¸	¸	4 5
Capacity
¸	¸	5 =
-
¸	¸	> ?
(
¸	¸	@ A
index
¸	¸	A F
-
¸	¸	G H

adjustment
¸	¸	I S
)
¸	¸	S T
)
¸	¸	T U
;
¸	¸	U V
s
¹	¹	 
.
¹	¹	 
SetZero
¹	¹	 
(
¹	¹	 
index
¹	¹	 
-
¹	¹	  !

adjustment
¹	¹	" ,
,
¹	¹	, -
localLength
¹	¹	. 9
)
¹	¹	9 :
;
¹	¹	: ;
index
º	º	 
+=
º	º	 
localLength
º	º	 $
;
º	º	$ %
length
»	»	 
-=
»	»	 
localLength
»	»	 %
;
»	»	% &
i
¼	¼	 
++
¼	¼	 
;
¼	¼	 
}
½	½	 
return
¾	¾	 
this
¾	¾	 
;
¾	¾	 
}
¿	¿	 	
public
Á	Á	 
override
Á	Á	 
IByteBuffer
Á	Á	 #
Copy
Á	Á	$ (
(
Á	Á	( )
int
Á	Á	) ,
index
Á	Á	- 2
,
Á	Á	2 3
int
Á	Á	4 7
length
Á	Á	8 >
)
Á	Á	> ?
{
Â	Â	 	
this
Ã	Ã	 
.
Ã	Ã	 

CheckIndex
Ã	Ã	 
(
Ã	Ã	 
index
Ã	Ã	 !
,
Ã	Ã	! "
length
Ã	Ã	# )
)
Ã	Ã	) *
;
Ã	Ã	* +
IByteBuffer
Ä	Ä	 
dst
Ä	Ä	 
=
Ä	Ä	 
this
Ä	Ä	 "
.
Ä	Ä	" #
AllocateBuffer
Ä	Ä	# 1
(
Ä	Ä	1 2
length
Ä	Ä	2 8
)
Ä	Ä	8 9
;
Ä	Ä	9 :
if
Å	Å	 
(
Å	Å	 
length
Å	Å	 
!=
Å	Å	 
$num
Å	Å	 
)
Å	Å	 
{
Æ	Æ	 
this
Ç	Ç	 
.
Ç	Ç	 
CopyTo
Ç	Ç	 
(
Ç	Ç	 
index
Ç	Ç	 !
,
Ç	Ç	! "
length
Ç	Ç	# )
,
Ç	Ç	) *
this
Ç	Ç	+ /
.
Ç	Ç	/ 0
ToComponentIndex
Ç	Ç	0 @
(
Ç	Ç	@ A
index
Ç	Ç	A F
)
Ç	Ç	F G
,
Ç	Ç	G H
dst
Ç	Ç	I L
)
Ç	Ç	L M
;
Ç	Ç	M N
}
È	È	 
return
É	É	 
dst
É	É	 
;
É	É	 
}
Ê	Ê	 	
void
Ì	Ì	 
CopyTo
Ì	Ì	 
(
Ì	Ì	 
int
Ì	Ì	 
index
Ì	Ì	 
,
Ì	Ì	 
int
Ì	Ì	 "
length
Ì	Ì	# )
,
Ì	Ì	) *
int
Ì	Ì	+ .
componentId
Ì	Ì	/ :
,
Ì	Ì	: ;
IByteBuffer
Ì	Ì	< G
dst
Ì	Ì	H K
)
Ì	Ì	K L
{
Í	Í	 	
int
Î	Î	 
dstIndex
Î	Î	 
=
Î	Î	 
$num
Î	Î	 
;
Î	Î	 
int
Ï	Ï	 
i
Ï	Ï	 
=
Ï	Ï	 
componentId
Ï	Ï	 
;
Ï	Ï	  
while
Ñ	Ñ	 
(
Ñ	Ñ	 
length
Ñ	Ñ	 
>
Ñ	Ñ	 
$num
Ñ	Ñ	 
)
Ñ	Ñ	 
{
Ò	Ò	 
ComponentEntry
Ó	Ó	 
c
Ó	Ó	  
=
Ó	Ó	! "
this
Ó	Ó	# '
.
Ó	Ó	' (

components
Ó	Ó	( 2
[
Ó	Ó	2 3
i
Ó	Ó	3 4
]
Ó	Ó	4 5
;
Ó	Ó	5 6
IByteBuffer
Ô	Ô	 
s
Ô	Ô	 
=
Ô	Ô	 
c
Ô	Ô	  !
.
Ô	Ô	! "
Buffer
Ô	Ô	" (
;
Ô	Ô	( )
int
Õ	Õ	 

adjustment
Õ	Õ	 
=
Õ	Õ	  
c
Õ	Õ	! "
.
Õ	Õ	" #
Offset
Õ	Õ	# )
;
Õ	Õ	) *
int
Ö	Ö	 
localLength
Ö	Ö	 
=
Ö	Ö	  !
Math
Ö	Ö	" &
.
Ö	Ö	& '
Min
Ö	Ö	' *
(
Ö	Ö	* +
length
Ö	Ö	+ 1
,
Ö	Ö	1 2
s
Ö	Ö	3 4
.
Ö	Ö	4 5
Capacity
Ö	Ö	5 =
-
Ö	Ö	> ?
(
Ö	Ö	@ A
index
Ö	Ö	A F
-
Ö	Ö	G H

adjustment
Ö	Ö	I S
)
Ö	Ö	S T
)
Ö	Ö	T U
;
Ö	Ö	U V
s
×	×	 
.
×	×	 
GetBytes
×	×	 
(
×	×	 
index
×	×	  
-
×	×	! "

adjustment
×	×	# -
,
×	×	- .
dst
×	×	/ 2
,
×	×	2 3
dstIndex
×	×	4 <
,
×	×	< =
localLength
×	×	> I
)
×	×	I J
;
×	×	J K
index
Ø	Ø	 
+=
Ø	Ø	 
localLength
Ø	Ø	 $
;
Ø	Ø	$ %
dstIndex
Ù	Ù	 
+=
Ù	Ù	 
localLength
Ù	Ù	 '
;
Ù	Ù	' (
length
Ú	Ú	 
-=
Ú	Ú	 
localLength
Ú	Ú	 %
;
Ú	Ú	% &
i
Û	Û	 
++
Û	Û	 
;
Û	Û	 
}
Ü	Ü	 
dst
Ş	Ş	 
.
Ş	Ş	 
SetWriterIndex
Ş	Ş	 
(
Ş	Ş	 
dst
Ş	Ş	 "
.
Ş	Ş	" #
Capacity
Ş	Ş	# +
)
Ş	Ş	+ ,
;
Ş	Ş	, -
}
ß	ß	 	
public
æ	æ	 
virtual
æ	æ	 
IByteBuffer
æ	æ	 "
this
æ	æ	# '
[
æ	æ	' (
int
æ	æ	( +
cIndex
æ	æ	, 2
]
æ	æ	2 3
=>
æ	æ	4 6
this
æ	æ	7 ;
.
æ	æ	; <
InternalComponent
æ	æ	< M
(
æ	æ	M N
cIndex
æ	æ	N T
)
æ	æ	T U
.
æ	æ	U V
	Duplicate
æ	æ	V _
(
æ	æ	_ `
)
æ	æ	` a
;
æ	æ	a b
public
í	í	 
virtual
í	í	 
IByteBuffer
í	í	 "
ComponentAtOffset
í	í	# 4
(
í	í	4 5
int
í	í	5 8
offset
í	í	9 ?
)
í	í	? @
=>
í	í	A C
this
í	í	D H
.
í	í	H I'
InternalComponentAtOffset
í	í	I b
(
í	í	b c
offset
í	í	c i
)
í	í	i j
.
í	í	j k
	Duplicate
í	í	k t
(
í	í	t u
)
í	í	u v
;
í	í	v w
public
ô	ô	 
virtual
ô	ô	 
IByteBuffer
ô	ô	 "
InternalComponent
ô	ô	# 4
(
ô	ô	4 5
int
ô	ô	5 8
cIndex
ô	ô	9 ?
)
ô	ô	? @
{
õ	õ	 	
this
ö	ö	 
.
ö	ö	 !
CheckComponentIndex
ö	ö	 $
(
ö	ö	$ %
cIndex
ö	ö	% +
)
ö	ö	+ ,
;
ö	ö	, -
return
÷	÷	 
this
÷	÷	 
.
÷	÷	 

components
÷	÷	 "
[
÷	÷	" #
cIndex
÷	÷	# )
]
÷	÷	) *
.
÷	÷	* +
Buffer
÷	÷	+ 1
;
÷	÷	1 2
}
ø	ø	 	
public
ÿ	ÿ	 
virtual
ÿ	ÿ	 
IByteBuffer
ÿ	ÿ	 "'
InternalComponentAtOffset
ÿ	ÿ	# <
(
ÿ	ÿ	< =
int
ÿ	ÿ	= @
offset
ÿ	ÿ	A G
)
ÿ	ÿ	G H
=>
ÿ	ÿ	I K
this
ÿ	ÿ	L P
.
ÿ	ÿ	P Q
FindComponent
ÿ	ÿ	Q ^
(
ÿ	ÿ	^ _
offset
ÿ	ÿ	_ e
)
ÿ	ÿ	e f
.
ÿ	ÿ	f g
Buffer
ÿ	ÿ	g m
;
ÿ	ÿ	m n
ComponentEntry


 
FindComponent


 $
(


$ %
int


% (
offset


) /
)


/ 0
{
‚
‚
 	
this
ƒ
ƒ
 
.
ƒ
ƒ
 

CheckIndex
ƒ
ƒ
 
(
ƒ
ƒ
 
offset
ƒ
ƒ
 "
)
ƒ
ƒ
" #
;
ƒ
ƒ
# $
for
…
…
 
(
…
…
 
int
…
…
 
low
…
…
 
=
…
…
 
$num
…
…
 
,
…
…
 
high
…
…
 "
=
…
…
# $
this
…
…
% )
.
…
…
) *

components
…
…
* 4
.
…
…
4 5
Count
…
…
5 :
;
…
…
: ;
low
…
…
< ?
<=
…
…
@ B
high
…
…
C G
;
…
…
G H
)
…
…
H I
{
†
†
 
int
‡
‡
 
mid
‡
‡
 
=
‡
‡
 
(
‡
‡
 
low
‡
‡
 
+
‡
‡
  
high
‡
‡
! %
)
‡
‡
% &
.
‡
‡
& '
RightUShift
‡
‡
' 2
(
‡
‡
2 3
$num
‡
‡
3 4
)
‡
‡
4 5
;
‡
‡
5 6
ComponentEntry
ˆ
ˆ
 
c
ˆ
ˆ
  
=
ˆ
ˆ
! "
this
ˆ
ˆ
# '
.
ˆ
ˆ
' (

components
ˆ
ˆ
( 2
[
ˆ
ˆ
2 3
mid
ˆ
ˆ
3 6
]
ˆ
ˆ
6 7
;
ˆ
ˆ
7 8
if
‰
‰
 
(
‰
‰
 
offset
‰
‰
 
>=
‰
‰
 
c
‰
‰
 
.
‰
‰
  
	EndOffset
‰
‰
  )
)
‰
‰
) *
{
Š
Š
 
low
‹
‹
 
=
‹
‹
 
mid
‹
‹
 
+
‹
‹
 
$num
‹
‹
  !
;
‹
‹
! "
}
Œ
Œ
 
else


 
if


 
(


 
offset


 
<


  !
c


" #
.


# $
Offset


$ *
)


* +
{


 
high


 
=


 
mid


 
-


  
$num


! "
;


" #
}


 
else
‘
‘
 
{
’
’
 
Contract
“
“
 
.
“
“
 
Assert
“
“
 #
(
“
“
# $
c
“
“
$ %
.
“
“
% &
Length
“
“
& ,
!=
“
“
- /
$num
“
“
0 1
)
“
“
1 2
;
“
“
2 3
return
”
”
 
c
”
”
 
;
”
”
 
}
•
•
 
}
–
–
 
throw
˜
˜
 
new
˜
˜
 
	Exception
˜
˜
 
(
˜
˜
  
$str
˜
˜
  7
)
˜
˜
7 8
;
˜
˜
8 9
}
™
™
 	
public


 
virtual


 !
CompositeByteBuffer


 *
Consolidate


+ 6
(


6 7
)


7 8
{
Ÿ
Ÿ
 	
this
 
 
 
.
 
 
 
EnsureAccessible
 
 
 !
(
 
 
! "
)
 
 
" #
;
 
 
# $
int
¡
¡
 
numComponents
¡
¡
 
=
¡
¡
 
this
¡
¡
  $
.
¡
¡
$ %
NumComponents
¡
¡
% 2
;
¡
¡
2 3
if
¢
¢
 
(
¢
¢
 
numComponents
¢
¢
 
<=
¢
¢
  
$num
¢
¢
! "
)
¢
¢
" #
{
£
£
 
return
¤
¤
 
this
¤
¤
 
;
¤
¤
 
}
¥
¥
 
ComponentEntry
§
§
 
last
§
§
 
=
§
§
  !
this
§
§
" &
.
§
§
& '

components
§
§
' 1
[
§
§
1 2
numComponents
§
§
2 ?
-
§
§
@ A
$num
§
§
B C
]
§
§
C D
;
§
§
D E
int
¨
¨
 
capacity
¨
¨
 
=
¨
¨
 
last
¨
¨
 
.
¨
¨
  
	EndOffset
¨
¨
  )
;
¨
¨
) *
IByteBuffer
©
©
 
consolidated
©
©
 $
=
©
©
% &
this
©
©
' +
.
©
©
+ ,
AllocateBuffer
©
©
, :
(
©
©
: ;
capacity
©
©
; C
)
©
©
C D
;
©
©
D E
for
«
«
 
(
«
«
 
int
«
«
 
i
«
«
 
=
«
«
 
$num
«
«
 
;
«
«
 
i
«
«
 
<
«
«
 
numComponents
«
«
  -
;
«
«
- .
i
«
«
/ 0
++
«
«
0 2
)
«
«
2 3
{
¬
¬
 
ComponentEntry
­
­
 
c
­
­
  
=
­
­
! "
this
­
­
# '
.
­
­
' (

components
­
­
( 2
[
­
­
2 3
i
­
­
3 4
]
­
­
4 5
;
­
­
5 6
IByteBuffer
®
®
 
b
®
®
 
=
®
®
 
c
®
®
  !
.
®
®
! "
Buffer
®
®
" (
;
®
®
( )
consolidated
¯
¯
 
.
¯
¯
 

WriteBytes
¯
¯
 '
(
¯
¯
' (
b
¯
¯
( )
)
¯
¯
) *
;
¯
¯
* +
c
°
°
 
.
°
°
 
FreeIfNecessary
°
°
 !
(
°
°
! "
)
°
°
" #
;
°
°
# $
}
±
±
 
this
³
³
 
.
³
³
 

components
³
³
 
.
³
³
 
Clear
³
³
 !
(
³
³
! "
)
³
³
" #
;
³
³
# $
this
´
´
 
.
´
´
 

components
´
´
 
.
´
´
 
Add
´
´
 
(
´
´
  
new
´
´
  #
ComponentEntry
´
´
$ 2
(
´
´
2 3
consolidated
´
´
3 ?
)
´
´
? @
)
´
´
@ A
;
´
´
A B
this
µ
µ
 
.
µ
µ
 $
UpdateComponentOffsets
µ
µ
 '
(
µ
µ
' (
$num
µ
µ
( )
)
µ
µ
) *
;
µ
µ
* +
return
¶
¶
 
this
¶
¶
 
;
¶
¶
 
}
·
·
 	
public
¾
¾
 
virtual
¾
¾
 !
CompositeByteBuffer
¾
¾
 *
Consolidate
¾
¾
+ 6
(
¾
¾
6 7
int
¾
¾
7 :
cIndex
¾
¾
; A
,
¾
¾
A B
int
¾
¾
C F
numComponents
¾
¾
G T
)
¾
¾
T U
{
¿
¿
 	
this
À
À
 
.
À
À
 !
CheckComponentIndex
À
À
 $
(
À
À
$ %
cIndex
À
À
% +
,
À
À
+ ,
numComponents
À
À
- :
)
À
À
: ;
;
À
À
; <
if
Á
Á
 
(
Á
Á
 
numComponents
Á
Á
 
<=
Á
Á
  
$num
Á
Á
! "
)
Á
Á
" #
{
Â
Â
 
return
Ã
Ã
 
this
Ã
Ã
 
;
Ã
Ã
 
}
Ä
Ä
 
int
Æ
Æ
 
	endCIndex
Æ
Æ
 
=
Æ
Æ
 
cIndex
Æ
Æ
 "
+
Æ
Æ
# $
numComponents
Æ
Æ
% 2
;
Æ
Æ
2 3
ComponentEntry
Ç
Ç
 
last
Ç
Ç
 
=
Ç
Ç
  !
this
Ç
Ç
" &
.
Ç
Ç
& '

components
Ç
Ç
' 1
[
Ç
Ç
1 2
	endCIndex
Ç
Ç
2 ;
-
Ç
Ç
< =
$num
Ç
Ç
> ?
]
Ç
Ç
? @
;
Ç
Ç
@ A
int
È
È
 
capacity
È
È
 
=
È
È
 
last
È
È
 
.
È
È
  
	EndOffset
È
È
  )
-
È
È
* +
this
È
È
, 0
.
È
È
0 1

components
È
È
1 ;
[
È
È
; <
cIndex
È
È
< B
]
È
È
B C
.
È
È
C D
Offset
È
È
D J
;
È
È
J K
IByteBuffer
É
É
 
consolidated
É
É
 $
=
É
É
% &
this
É
É
' +
.
É
É
+ ,
AllocateBuffer
É
É
, :
(
É
É
: ;
capacity
É
É
; C
)
É
É
C D
;
É
É
D E
for
Ë
Ë
 
(
Ë
Ë
 
int
Ë
Ë
 
i
Ë
Ë
 
=
Ë
Ë
 
cIndex
Ë
Ë
 
;
Ë
Ë
  
i
Ë
Ë
! "
<
Ë
Ë
# $
	endCIndex
Ë
Ë
% .
;
Ë
Ë
. /
i
Ë
Ë
0 1
++
Ë
Ë
1 3
)
Ë
Ë
3 4
{
Ì
Ì
 
ComponentEntry
Í
Í
 
c
Í
Í
  
=
Í
Í
! "
this
Í
Í
# '
.
Í
Í
' (

components
Í
Í
( 2
[
Í
Í
2 3
i
Í
Í
3 4
]
Í
Í
4 5
;
Í
Í
5 6
IByteBuffer
Î
Î
 
b
Î
Î
 
=
Î
Î
 
c
Î
Î
  !
.
Î
Î
! "
Buffer
Î
Î
" (
;
Î
Î
( )
consolidated
Ï
Ï
 
.
Ï
Ï
 

WriteBytes
Ï
Ï
 '
(
Ï
Ï
' (
b
Ï
Ï
( )
)
Ï
Ï
) *
;
Ï
Ï
* +
c
Ğ
Ğ
 
.
Ğ
Ğ
 
FreeIfNecessary
Ğ
Ğ
 !
(
Ğ
Ğ
! "
)
Ğ
Ğ
" #
;
Ğ
Ğ
# $
}
Ñ
Ñ
 
this
Ó
Ó
 
.
Ó
Ó
 

components
Ó
Ó
 
.
Ó
Ó
 
RemoveRange
Ó
Ó
 '
(
Ó
Ó
' (
cIndex
Ó
Ó
( .
,
Ó
Ó
. /
numComponents
Ó
Ó
0 =
)
Ó
Ó
= >
;
Ó
Ó
> ?
this
Ô
Ô
 
.
Ô
Ô
 

components
Ô
Ô
 
.
Ô
Ô
 
Insert
Ô
Ô
 "
(
Ô
Ô
" #
cIndex
Ô
Ô
# )
,
Ô
Ô
) *
new
Ô
Ô
* -
ComponentEntry
Ô
Ô
. <
(
Ô
Ô
< =
consolidated
Ô
Ô
= I
)
Ô
Ô
I J
)
Ô
Ô
J K
;
Ô
Ô
K L
this
Õ
Õ
 
.
Õ
Õ
 $
UpdateComponentOffsets
Õ
Õ
 '
(
Õ
Õ
' (
cIndex
Õ
Õ
( .
)
Õ
Õ
. /
;
Õ
Õ
/ 0
return
Ö
Ö
 
this
Ö
Ö
 
;
Ö
Ö
 
}
×
×
 	
public
Ü
Ü
 
virtual
Ü
Ü
 !
CompositeByteBuffer
Ü
Ü
 *#
DiscardReadComponents
Ü
Ü
+ @
(
Ü
Ü
@ A
)
Ü
Ü
A B
{
İ
İ
 	
this
Ş
Ş
 
.
Ş
Ş
 
EnsureAccessible
Ş
Ş
 !
(
Ş
Ş
! "
)
Ş
Ş
" #
;
Ş
Ş
# $
int
ß
ß
 
readerIndex
ß
ß
 
=
ß
ß
 
this
ß
ß
 "
.
ß
ß
" #
ReaderIndex
ß
ß
# .
;
ß
ß
. /
if
à
à
 
(
à
à
 
readerIndex
à
à
 
==
à
à
 
$num
à
à
  
)
à
à
  !
{
á
á
 
return
â
â
 
this
â
â
 
;
â
â
 
}
ã
ã
 
int
æ
æ
 
writerIndex
æ
æ
 
=
æ
æ
 
this
æ
æ
 "
.
æ
æ
" #
WriterIndex
æ
æ
# .
;
æ
æ
. /
if
ç
ç
 
(
ç
ç
 
readerIndex
ç
ç
 
==
ç
ç
 
writerIndex
ç
ç
 *
&&
ç
ç
+ -
writerIndex
ç
ç
. 9
==
ç
ç
: <
this
ç
ç
= A
.
ç
ç
A B
Capacity
ç
ç
B J
)
ç
ç
J K
{
è
è
 
foreach
é
é
 
(
é
é
 
ComponentEntry
é
é
 '
c
é
é
( )
in
é
é
* ,
this
é
é
- 1
.
é
é
1 2

components
é
é
2 <
)
é
é
< =
{
ê
ê
 
c
ë
ë
 
.
ë
ë
 
FreeIfNecessary
ë
ë
 %
(
ë
ë
% &
)
ë
ë
& '
;
ë
ë
' (
}
ì
ì
 
this
í
í
 
.
í
í
 

components
í
í
 
.
í
í
  
Clear
í
í
  %
(
í
í
% &
)
í
í
& '
;
í
í
' (
this
î
î
 
.
î
î
 
SetIndex
î
î
 
(
î
î
 
$num
î
î
 
,
î
î
  
$num
î
î
! "
)
î
î
" #
;
î
î
# $
this
ï
ï
 
.
ï
ï
 
AdjustMarkers
ï
ï
 "
(
ï
ï
" #
readerIndex
ï
ï
# .
)
ï
ï
. /
;
ï
ï
/ 0
return
ğ
ğ
 
this
ğ
ğ
 
;
ğ
ğ
 
}
ñ
ñ
 
int
ô
ô
 
firstComponentId
ô
ô
  
=
ô
ô
! "
this
ô
ô
# '
.
ô
ô
' (
ToComponentIndex
ô
ô
( 8
(
ô
ô
8 9
readerIndex
ô
ô
9 D
)
ô
ô
D E
;
ô
ô
E F
for
õ
õ
 
(
õ
õ
 
int
õ
õ
 
i
õ
õ
 
=
õ
õ
 
$num
õ
õ
 
;
õ
õ
 
i
õ
õ
 
<
õ
õ
 
firstComponentId
õ
õ
  0
;
õ
õ
0 1
i
õ
õ
2 3
++
õ
õ
3 5
)
õ
õ
5 6
{
ö
ö
 
this
÷
÷
 
.
÷
÷
 

components
÷
÷
 
[
÷
÷
  
i
÷
÷
  !
]
÷
÷
! "
.
÷
÷
" #
FreeIfNecessary
÷
÷
# 2
(
÷
÷
2 3
)
÷
÷
3 4
;
÷
÷
4 5
}
ø
ø
 
this
ù
ù
 
.
ù
ù
 

components
ù
ù
 
.
ù
ù
 
RemoveRange
ù
ù
 '
(
ù
ù
' (
$num
ù
ù
( )
,
ù
ù
) *
firstComponentId
ù
ù
+ ;
)
ù
ù
; <
;
ù
ù
< =
ComponentEntry
ü
ü
 
first
ü
ü
  
=
ü
ü
! "
this
ü
ü
# '
.
ü
ü
' (

components
ü
ü
( 2
[
ü
ü
2 3
$num
ü
ü
3 4
]
ü
ü
4 5
;
ü
ü
5 6
int
ı
ı
 
offset
ı
ı
 
=
ı
ı
 
first
ı
ı
 
.
ı
ı
 
Offset
ı
ı
 %
;
ı
ı
% &
this
ş
ş
 
.
ş
ş
 $
UpdateComponentOffsets
ş
ş
 '
(
ş
ş
' (
$num
ş
ş
( )
)
ş
ş
) *
;
ş
ş
* +
this
ÿ
ÿ
 
.
ÿ
ÿ
 
SetIndex
ÿ
ÿ
 
(
ÿ
ÿ
 
readerIndex
ÿ
ÿ
 %
-
ÿ
ÿ
& '
offset
ÿ
ÿ
( .
,
ÿ
ÿ
. /
writerIndex
ÿ
ÿ
0 ;
-
ÿ
ÿ
< =
offset
ÿ
ÿ
> D
)
ÿ
ÿ
D E
;
ÿ
ÿ
E F
this
€€ 
.
€€ 
AdjustMarkers
€€ 
(
€€ 
offset
€€ %
)
€€% &
;
€€& '
return
 
this
 
;
 
}
‚‚ 	
public
„„ 
override
„„ 
IByteBuffer
„„ #
DiscardReadBytes
„„$ 4
(
„„4 5
)
„„5 6
{
…… 	
this
†† 
.
†† 
EnsureAccessible
†† !
(
††! "
)
††" #
;
††# $
int
‡‡ 
readerIndex
‡‡ 
=
‡‡ 
this
‡‡ "
.
‡‡" #
ReaderIndex
‡‡# .
;
‡‡. /
if
ˆˆ 
(
ˆˆ 
readerIndex
ˆˆ 
==
ˆˆ 
$num
ˆˆ  
)
ˆˆ  !
{
‰‰ 
return
ŠŠ 
this
ŠŠ 
;
ŠŠ 
}
‹‹ 
int
 
writerIndex
 
=
 
this
 "
.
" #
WriterIndex
# .
;
. /
if
 
(
 
readerIndex
 
==
 
writerIndex
 *
&&
+ -
writerIndex
. 9
==
: <
this
= A
.
A B
Capacity
B J
)
J K
{
 
foreach
‘‘ 
(
‘‘ 
ComponentEntry
‘‘ '
c1
‘‘( *
in
‘‘+ -
this
‘‘. 2
.
‘‘2 3

components
‘‘3 =
)
‘‘= >
{
’’ 
c1
““ 
.
““ 
FreeIfNecessary
““ &
(
““& '
)
““' (
;
““( )
}
”” 
this
•• 
.
•• 

components
•• 
.
••  
Clear
••  %
(
••% &
)
••& '
;
••' (
this
–– 
.
–– 
SetIndex
–– 
(
–– 
$num
–– 
,
––  
$num
––! "
)
––" #
;
––# $
this
—— 
.
—— 
AdjustMarkers
—— "
(
——" #
readerIndex
——# .
)
——. /
;
——/ 0
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
™™ 
int
œœ 
firstComponentId
œœ  
=
œœ! "
this
œœ# '
.
œœ' (
ToComponentIndex
œœ( 8
(
œœ8 9
readerIndex
œœ9 D
)
œœD E
;
œœE F
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 
firstComponentId
  0
;
0 1
i
2 3
++
3 5
)
5 6
{
 
this
ŸŸ 
.
ŸŸ 

components
ŸŸ 
[
ŸŸ  
i
ŸŸ  !
]
ŸŸ! "
.
ŸŸ" #
FreeIfNecessary
ŸŸ# 2
(
ŸŸ2 3
)
ŸŸ3 4
;
ŸŸ4 5
}
   
this
¡¡ 
.
¡¡ 

components
¡¡ 
.
¡¡ 
RemoveRange
¡¡ '
(
¡¡' (
$num
¡¡( )
,
¡¡) *
firstComponentId
¡¡+ ;
)
¡¡; <
;
¡¡< =
ComponentEntry
¤¤ 
c
¤¤ 
=
¤¤ 
this
¤¤ #
.
¤¤# $

components
¤¤$ .
[
¤¤. /
$num
¤¤/ 0
]
¤¤0 1
;
¤¤1 2
int
¥¥ 

adjustment
¥¥ 
=
¥¥ 
readerIndex
¥¥ (
-
¥¥) *
c
¥¥+ ,
.
¥¥, -
Offset
¥¥- 3
;
¥¥3 4
if
¦¦ 
(
¦¦ 

adjustment
¦¦ 
==
¦¦ 
c
¦¦ 
.
¦¦  
Length
¦¦  &
)
¦¦& '
{
§§ 
this
©© 
.
©© 

components
©© 
.
©©  
RemoveAt
©©  (
(
©©( )
$num
©©) *
)
©©* +
;
©©+ ,
}
ªª 
else
«« 
{
¬¬ 
var
­­ 
newC
­­ 
=
­­ 
new
­­ 
ComponentEntry
­­ -
(
­­- .
c
­­. /
.
­­/ 0
Buffer
­­0 6
.
­­6 7
Slice
­­7 <
(
­­< =

adjustment
­­= G
,
­­G H
c
­­I J
.
­­J K
Length
­­K Q
-
­­R S

adjustment
­­T ^
)
­­^ _
)
­­_ `
;
­­` a
this
®® 
.
®® 

components
®® 
[
®®  
$num
®®  !
]
®®! "
=
®®# $
newC
®®% )
;
®®) *
}
¯¯ 
this
²² 
.
²² $
UpdateComponentOffsets
²² '
(
²²' (
$num
²²( )
)
²²) *
;
²²* +
this
³³ 
.
³³ 
SetIndex
³³ 
(
³³ 
$num
³³ 
,
³³ 
writerIndex
³³ (
-
³³) *
readerIndex
³³+ 6
)
³³6 7
;
³³7 8
this
´´ 
.
´´ 
AdjustMarkers
´´ 
(
´´ 
readerIndex
´´ *
)
´´* +
;
´´+ ,
return
µµ 
this
µµ 
;
µµ 
}
¶¶ 	
IByteBuffer
¸¸ 
AllocateBuffer
¸¸ "
(
¸¸" #
int
¸¸# &
capacity
¸¸' /
)
¸¸/ 0
=>
¸¸1 3
this
¹¹ 
.
¹¹ 
direct
¹¹ 
?
¹¹ 
this
¹¹ 
.
¹¹ 
	Allocator
¹¹ (
.
¹¹( )
DirectBuffer
¹¹) 5
(
¹¹5 6
capacity
¹¹6 >
)
¹¹> ?
:
¹¹@ A
this
¹¹B F
.
¹¹F G
	Allocator
¹¹G P
.
¹¹P Q

HeapBuffer
¹¹Q [
(
¹¹[ \
capacity
¹¹\ d
)
¹¹d e
;
¹¹e f
public
»» 
override
»» 
string
»» 
ToString
»» '
(
»»' (
)
»»( )
{
¼¼ 	
string
½½ 
result
½½ 
=
½½ 
base
½½  
.
½½  !
ToString
½½! )
(
½½) *
)
½½* +
;
½½+ ,
result
¾¾ 
=
¾¾ 
result
¾¾ 
.
¾¾ 
	Substring
¾¾ %
(
¾¾% &
$num
¾¾& '
,
¾¾' (
result
¾¾) /
.
¾¾/ 0
Length
¾¾0 6
-
¾¾7 8
$num
¾¾9 :
)
¾¾: ;
;
¾¾; <
return
¿¿ 
$"
¿¿ 
{
¿¿ 
result
¿¿ 
}
¿¿ 
$str
¿¿ *
{
¿¿* +
this
¿¿+ /
.
¿¿/ 0

components
¿¿0 :
.
¿¿: ;
Count
¿¿; @
}
¿¿@ A
$str
¿¿A B
"
¿¿B C
;
¿¿C D
}
ÀÀ 	
public
ÂÂ 
override
ÂÂ 
IReferenceCounted
ÂÂ )
Touch
ÂÂ* /
(
ÂÂ/ 0
)
ÂÂ0 1
=>
ÂÂ2 4
this
ÂÂ5 9
;
ÂÂ9 :
public
ÄÄ 
override
ÄÄ 
IReferenceCounted
ÄÄ )
Touch
ÄÄ* /
(
ÄÄ/ 0
object
ÄÄ0 6
hint
ÄÄ7 ;
)
ÄÄ; <
=>
ÄÄ= ?
this
ÄÄ@ D
;
ÄÄD E
public
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ #"
DiscardSomeReadBytes
ÆÆ$ 8
(
ÆÆ8 9
)
ÆÆ9 :
=>
ÆÆ; =
this
ÆÆ> B
.
ÆÆB C#
DiscardReadComponents
ÆÆC X
(
ÆÆX Y
)
ÆÆY Z
;
ÆÆZ [
	protected
ÈÈ 
internal
ÈÈ 
override
ÈÈ #
void
ÈÈ$ (

Deallocate
ÈÈ) 3
(
ÈÈ3 4
)
ÈÈ4 5
{
ÉÉ 	
if
ÊÊ 
(
ÊÊ 
this
ÊÊ 
.
ÊÊ 
freed
ÊÊ 
)
ÊÊ 
{
ËË 
return
ÌÌ 
;
ÌÌ 
}
ÍÍ 
this
ÏÏ 
.
ÏÏ 
freed
ÏÏ 
=
ÏÏ 
true
ÏÏ 
;
ÏÏ 
int
ĞĞ 
size
ĞĞ 
=
ĞĞ 
this
ĞĞ 
.
ĞĞ 

components
ĞĞ &
.
ĞĞ& '
Count
ĞĞ' ,
;
ĞĞ, -
for
ÓÓ 
(
ÓÓ 
int
ÓÓ 
i
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
i
ÓÓ 
<
ÓÓ 
size
ÓÓ  $
;
ÓÓ$ %
i
ÓÓ& '
++
ÓÓ' )
)
ÓÓ) *
{
ÔÔ 
this
ÕÕ 
.
ÕÕ 

components
ÕÕ 
[
ÕÕ  
i
ÕÕ  !
]
ÕÕ! "
.
ÕÕ" #
FreeIfNecessary
ÕÕ# 2
(
ÕÕ2 3
)
ÕÕ3 4
;
ÕÕ4 5
}
ÖÖ 
}
×× 	
public
ÙÙ 
override
ÙÙ 
IByteBuffer
ÙÙ #
Unwrap
ÙÙ$ *
(
ÙÙ* +
)
ÙÙ+ ,
=>
ÙÙ- /
null
ÙÙ0 4
;
ÙÙ4 5
}
ÚÚ 
}ÛÛ ©1
jC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\DefaultByteBufferHolder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public

 

class

 #
DefaultByteBufferHolder

 (
:

) *
IByteBufferHolder

+ <
{ 
readonly 
IByteBuffer 
data !
;! "
public #
DefaultByteBufferHolder &
(& '
IByteBuffer' 2
data3 7
)7 8
{ 	
Contract 
. 
Requires 
( 
data "
!=# %
null& *
)* +
;+ ,
this 
. 
data 
= 
data 
; 
} 	
public 
IByteBuffer 
Content "
{ 	
get 
{ 
if 
( 
this 
. 
data 
. 
ReferenceCount ,
<=- /
$num0 1
)1 2
{ 
throw 
new *
IllegalReferenceCountException <
(< =
this= A
.A B
dataB F
.F G
ReferenceCountG U
)U V
;V W
} 
return 
this 
. 
data  
;  !
} 
}   	
public"" 
IByteBufferHolder""  
Copy""! %
(""% &
)""& '
=>""( *
this""+ /
.""/ 0
Replace""0 7
(""7 8
this""8 <
.""< =
data""= A
.""A B
Copy""B F
(""F G
)""G H
)""H I
;""I J
public$$ 
IByteBufferHolder$$  
	Duplicate$$! *
($$* +
)$$+ ,
=>$$- /
this$$0 4
.$$4 5
Replace$$5 <
($$< =
this$$= A
.$$A B
data$$B F
.$$F G
	Duplicate$$G P
($$P Q
)$$Q R
)$$R S
;$$S T
public&& 
IByteBufferHolder&&  
RetainedDuplicate&&! 2
(&&2 3
)&&3 4
=>&&5 7
this&&8 <
.&&< =
Replace&&= D
(&&D E
this&&E I
.&&I J
data&&J N
.&&N O
RetainedDuplicate&&O `
(&&` a
)&&a b
)&&b c
;&&c d
public(( 
virtual(( 
IByteBufferHolder(( (
Replace(() 0
(((0 1
IByteBuffer((1 <
content((= D
)((D E
=>((F H
new((I L#
DefaultByteBufferHolder((M d
(((d e
content((e l
)((l m
;((m n
public** 
virtual** 
int** 
ReferenceCount** )
=>*** ,
this**- 1
.**1 2
data**2 6
.**6 7
ReferenceCount**7 E
;**E F
public,, 
IReferenceCounted,,  
Retain,,! '
(,,' (
),,( )
{-- 	
this.. 
... 
data.. 
... 
Retain.. 
(.. 
).. 
;.. 
return// 
this// 
;// 
}00 	
public22 
IReferenceCounted22  
Retain22! '
(22' (
int22( +
	increment22, 5
)225 6
{33 	
this44 
.44 
data44 
.44 
Retain44 
(44 
	increment44 &
)44& '
;44' (
return55 
this55 
;55 
}66 	
public88 
IReferenceCounted88  
Touch88! &
(88& '
)88' (
{99 	
this:: 
.:: 
data:: 
.:: 
Touch:: 
(:: 
):: 
;:: 
return;; 
this;; 
;;; 
}<< 	
public>> 
IReferenceCounted>>  
Touch>>! &
(>>& '
object>>' -
hint>>. 2
)>>2 3
{?? 	
this@@ 
.@@ 
data@@ 
.@@ 
Touch@@ 
(@@ 
hint@@  
)@@  !
;@@! "
returnAA 
thisAA 
;AA 
}BB 	
publicDD 
boolDD 
ReleaseDD 
(DD 
)DD 
=>DD  
thisDD! %
.DD% &
dataDD& *
.DD* +
ReleaseDD+ 2
(DD2 3
)DD3 4
;DD4 5
publicFF 
boolFF 
ReleaseFF 
(FF 
intFF 
	decrementFF  )
)FF) *
=>FF+ -
thisFF. 2
.FF2 3
dataFF3 7
.FF7 8
ReleaseFF8 ?
(FF? @
	decrementFF@ I
)FFI J
;FFJ K
	protectedHH 
stringHH 
ContentToStringHH (
(HH( )
)HH) *
=>HH+ -
thisHH. 2
.HH2 3
dataHH3 7
.HH7 8
ToStringHH8 @
(HH@ A
)HHA B
;HHB C
publicJJ 
overrideJJ 
boolJJ 
EqualsJJ #
(JJ# $
objectJJ$ *
objJJ+ .
)JJ. /
{KK 	
ifLL 
(LL 
ReferenceEqualsLL 
(LL  
thisLL  $
,LL$ %
objLL& )
)LL) *
)LL* +
{MM 
returnNN 
trueNN 
;NN 
}OO 
ifQQ 
(QQ 
objQQ 
isQQ 
IByteBufferHolderQQ (
holderQQ) /
)QQ/ 0
{RR 
returnSS 
thisSS 
.SS 
dataSS  
.SS  !
EqualsSS! '
(SS' (
holderSS( .
.SS. /
ContentSS/ 6
)SS6 7
;SS7 8
}TT 
returnVV 
falseVV 
;VV 
}WW 	
publicYY 
overrideYY 
intYY 
GetHashCodeYY '
(YY' (
)YY( )
=>YY* ,
thisYY- 1
.YY1 2
dataYY2 6
.YY6 7
GetHashCodeYY7 B
(YYB C
)YYC D
;YYD E
}ZZ 
}[[ Êë
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\EmptyByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class 
EmptyByteBuffer '
:( )
IByteBuffer* 5
{ 
static 
readonly 
ArraySegment $
<$ %
byte% )
>) *
EmptyBuffer+ 6
=7 8
new9 <
ArraySegment= I
<I J
byteJ N
>N O
(O P
ArrayExtensionsP _
._ `
	ZeroBytes` i
)i j
;j k
static 
readonly 
ArraySegment $
<$ %
byte% )
>) *
[* +
]+ ,
EmptyBuffers- 9
=: ;
{< =
EmptyBuffer> I
}J K
;K L
public 
EmptyByteBuffer 
(  
IByteBufferAllocator 3
	allocator4 =
)= >
{ 	
Contract 
. 
Requires 
( 
	allocator '
!=( *
null+ /
)/ 0
;0 1
this 
. 
	Allocator 
= 
	allocator &
;& '
} 	
public 
int 
Capacity 
=> 
$num  
;  !
public!! 
IByteBuffer!! 
AdjustCapacity!! )
(!!) *
int!!* -
newCapacity!!. 9
)!!9 :
=>!!; =
throw!!= B
new!!C F!
NotSupportedException!!G \
(!!\ ]
)!!] ^
;!!^ _
public## 
int## 
MaxCapacity## 
=>## !
$num##" #
;### $
public%%  
IByteBufferAllocator%% #
	Allocator%%$ -
{%%. /
get%%0 3
;%%3 4
}%%5 6
public'' 
IByteBuffer'' 
Unwrap'' !
(''! "
)''" #
=>''$ &
null''' +
;''+ ,
public)) 
bool)) 
IsDirect)) 
=>)) 
true))  $
;))$ %
public++ 
int++ 
ReaderIndex++ 
=>++ !
$num++" #
;++# $
public-- 
IByteBuffer-- 
SetReaderIndex-- )
(--) *
int--* -
readerIndex--. 9
)--9 :
=>--; =
this--> B
.--B C

CheckIndex--C M
(--M N
readerIndex--N Y
)--Y Z
;--Z [
public// 
int// 
WriterIndex// 
=>// !
$num//" #
;//# $
public11 
IByteBuffer11 
SetWriterIndex11 )
(11) *
int11* -
writerIndex11. 9
)119 :
=>11; =
this11> B
.11B C

CheckIndex11C M
(11M N
writerIndex11N Y
)11Y Z
;11Z [
public33 
IByteBuffer33 
SetIndex33 #
(33# $
int33$ '
readerIndex33( 3
,333 4
int335 8
writerIndex339 D
)33D E
{44 	
this55 
.55 

CheckIndex55 
(55 
readerIndex55 '
)55' (
;55( )
this66 
.66 

CheckIndex66 
(66 
writerIndex66 '
)66' (
;66( )
return77 
this77 
;77 
}88 	
public:: 
int:: 
ReadableBytes::  
=>::! #
$num::$ %
;::% &
public<< 
int<< 
WritableBytes<<  
=><<! #
$num<<$ %
;<<% &
public>> 
int>> 
MaxWritableBytes>> #
=>>>$ &
$num>>' (
;>>( )
public@@ 
bool@@ 

IsWritable@@ 
(@@ 
)@@  
=>@@! #
false@@$ )
;@@) *
publicBB 
boolBB 

IsWritableBB 
(BB 
intBB "
sizeBB# '
)BB' (
=>BB) +
falseBB, 1
;BB1 2
publicDD 
IByteBufferDD 
ClearDD  
(DD  !
)DD! "
=>DD# %
thisDD& *
;DD* +
publicFF 
IByteBufferFF 
MarkReaderIndexFF *
(FF* +
)FF+ ,
=>FF- /
thisFF0 4
;FF4 5
publicHH 
IByteBufferHH 
ResetReaderIndexHH +
(HH+ ,
)HH, -
=>HH. 0
thisHH1 5
;HH5 6
publicJJ 
IByteBufferJJ 
MarkWriterIndexJJ *
(JJ* +
)JJ+ ,
=>JJ- /
thisJJ0 4
;JJ4 5
publicLL 
IByteBufferLL 
ResetWriterIndexLL +
(LL+ ,
)LL, -
=>LL. 0
thisLL1 5
;LL5 6
publicNN 
IByteBufferNN 
DiscardReadBytesNN +
(NN+ ,
)NN, -
=>NN. 0
thisNN1 5
;NN5 6
publicPP 
IByteBufferPP  
DiscardSomeReadBytesPP /
(PP/ 0
)PP0 1
=>PP2 4
thisPP5 9
;PP9 :
publicRR 
IByteBufferRR 
EnsureWritableRR )
(RR) *
intRR* -
minWritableBytesRR. >
)RR> ?
{SS 	
ContractTT 
.TT 
RequiresTT 
(TT 
minWritableBytesTT .
>=TT/ 1
$numTT2 3
)TT3 4
;TT4 5
ifVV 
(VV 
minWritableBytesVV  
!=VV! #
$numVV$ %
)VV% &
{WW 
throwXX 
newXX $
IndexOutOfRangeExceptionXX 2
(XX2 3
)XX3 4
;XX4 5
}YY 
returnZZ 
thisZZ 
;ZZ 
}[[ 	
public]] 
int]] 
EnsureWritable]] !
(]]! "
int]]" %
minWritableBytes]]& 6
,]]6 7
bool]]8 <
force]]= B
)]]B C
{^^ 	
Contract__ 
.__ 
Requires__ 
(__ 
minWritableBytes__ .
>=__/ 1
$num__2 3
)__3 4
;__4 5
ifaa 
(aa 
minWritableBytesaa  
==aa! #
$numaa$ %
)aa% &
{bb 
returncc 
$numcc 
;cc 
}dd 
returnff 
$numff 
;ff 
}gg 	
publicii 
boolii 

GetBooleanii 
(ii 
intii "
indexii# (
)ii( )
=>ii* ,
throwii- 2
newii3 6$
IndexOutOfRangeExceptionii7 O
(iiO P
)iiP Q
;iiQ R
publickk 
bytekk 
GetBytekk 
(kk 
intkk 
indexkk  %
)kk% &
=>kk' )
throwkk* /
newkk0 3$
IndexOutOfRangeExceptionkk4 L
(kkL M
)kkM N
;kkN O
publicmm 
shortmm 
GetShortmm 
(mm 
intmm !
indexmm" '
)mm' (
=>mm) +
throwmm, 1
newmm2 5$
IndexOutOfRangeExceptionmm6 N
(mmN O
)mmO P
;mmP Q
publicoo 
shortoo 

GetShortLEoo 
(oo  
intoo  #
indexoo$ )
)oo) *
=>oo+ -
throwoo. 3
newoo4 7$
IndexOutOfRangeExceptionoo8 P
(ooP Q
)ooQ R
;ooR S
publicqq 
ushortqq 
GetUnsignedShortqq &
(qq& '
intqq' *
indexqq+ 0
)qq0 1
=>qq2 4
throwqq5 :
newqq; >$
IndexOutOfRangeExceptionqq? W
(qqW X
)qqX Y
;qqY Z
publicss 
ushortss 
GetUnsignedShortLEss (
(ss( )
intss) ,
indexss- 2
)ss2 3
=>ss4 6
throwss7 <
newss= @$
IndexOutOfRangeExceptionssA Y
(ssY Z
)ssZ [
;ss[ \
publicuu 
intuu 
	GetMediumuu 
(uu 
intuu  
indexuu! &
)uu& '
=>uu( *
throwuu+ 0
newuu1 4$
IndexOutOfRangeExceptionuu5 M
(uuM N
)uuN O
;uuO P
publicww 
intww 
GetMediumLEww 
(ww 
intww "
indexww# (
)ww( )
=>ww* ,
throwww- 2
newww3 6$
IndexOutOfRangeExceptionww7 O
(wwO P
)wwP Q
;wwQ R
publicyy 
intyy 
GetUnsignedMediumyy $
(yy$ %
intyy% (
indexyy) .
)yy. /
=>yy0 2
throwyy3 8
newyy9 <$
IndexOutOfRangeExceptionyy= U
(yyU V
)yyV W
;yyW X
public{{ 
int{{ 
GetUnsignedMediumLE{{ &
({{& '
int{{' *
index{{+ 0
){{0 1
=>{{2 4
throw{{5 :
new{{; >$
IndexOutOfRangeException{{? W
({{W X
){{X Y
;{{Y Z
public}} 
int}} 
GetInt}} 
(}} 
int}} 
index}} #
)}}# $
=>}}% '
throw}}( -
new}}. 1$
IndexOutOfRangeException}}2 J
(}}J K
)}}K L
;}}L M
public 
int 
GetIntLE 
( 
int 
index  %
)% &
=>' )
throw* /
new0 3$
IndexOutOfRangeException4 L
(L M
)M N
;N O
public
 
uint
 
GetUnsignedInt
 "
(
" #
int
# &
index
' ,
)
, -
=>
. 0
throw
1 6
new
7 :&
IndexOutOfRangeException
; S
(
S T
)
T U
;
U V
public
ƒƒ 
uint
ƒƒ 
GetUnsignedIntLE
ƒƒ $
(
ƒƒ$ %
int
ƒƒ% (
index
ƒƒ) .
)
ƒƒ. /
=>
ƒƒ0 2
throw
ƒƒ3 8
new
ƒƒ9 <&
IndexOutOfRangeException
ƒƒ= U
(
ƒƒU V
)
ƒƒV W
;
ƒƒW X
public
…… 
long
…… 
GetLong
…… 
(
…… 
int
…… 
index
……  %
)
……% &
=>
……' )
throw
……* /
new
……0 3&
IndexOutOfRangeException
……4 L
(
……L M
)
……M N
;
……N O
public
‡‡ 
long
‡‡ 
	GetLongLE
‡‡ 
(
‡‡ 
int
‡‡ !
index
‡‡" '
)
‡‡' (
=>
‡‡) +
throw
‡‡, 1
new
‡‡2 5&
IndexOutOfRangeException
‡‡6 N
(
‡‡N O
)
‡‡O P
;
‡‡P Q
public
‰‰ 
char
‰‰ 
GetChar
‰‰ 
(
‰‰ 
int
‰‰ 
index
‰‰  %
)
‰‰% &
=>
‰‰' )
throw
‰‰* /
new
‰‰0 3&
IndexOutOfRangeException
‰‰4 L
(
‰‰L M
)
‰‰M N
;
‰‰N O
public
‹‹ 
float
‹‹ 
GetFloat
‹‹ 
(
‹‹ 
int
‹‹ !
index
‹‹" '
)
‹‹' (
=>
‹‹) +
throw
‹‹, 1
new
‹‹2 5&
IndexOutOfRangeException
‹‹6 N
(
‹‹N O
)
‹‹O P
;
‹‹P Q
public
 
float
 

GetFloatLE
 
(
  
int
  #
index
$ )
)
) *
=>
+ -
throw
. 3
new
4 7&
IndexOutOfRangeException
8 P
(
P Q
)
Q R
;
R S
public
 
double
 
	GetDouble
 
(
  
int
  #
index
$ )
)
) *
=>
+ -
throw
. 3
new
4 7&
IndexOutOfRangeException
8 P
(
P Q
)
Q R
;
R S
public
‘‘ 
double
‘‘ 
GetDoubleLE
‘‘ !
(
‘‘! "
int
‘‘" %
index
‘‘& +
)
‘‘+ ,
=>
‘‘- /
throw
‘‘0 5
new
‘‘6 9&
IndexOutOfRangeException
‘‘: R
(
‘‘R S
)
‘‘S T
;
‘‘T U
public
““ 
IByteBuffer
““ 
GetBytes
““ #
(
““# $
int
““$ '
index
““( -
,
““- .
IByteBuffer
““/ :
destination
““; F
)
““F G
=>
““H J
this
““K O
.
““O P

CheckIndex
““P Z
(
““Z [
index
““[ `
,
““` a
destination
““b m
.
““m n
WritableBytes
““n {
)
““{ |
;
““| }
public
•• 
IByteBuffer
•• 
GetBytes
•• #
(
••# $
int
••$ '
index
••( -
,
••- .
IByteBuffer
••/ :
destination
••; F
,
••F G
int
••H K
length
••L R
)
••R S
=>
••T V
this
••W [
.
••[ \

CheckIndex
••\ f
(
••f g
index
••g l
,
••l m
length
••n t
)
••t u
;
••u v
public
—— 
IByteBuffer
—— 
GetBytes
—— #
(
——# $
int
——$ '
index
——( -
,
——- .
IByteBuffer
——/ :
destination
——; F
,
——F G
int
——H K
dstIndex
——L T
,
——T U
int
——V Y
length
——Z `
)
——` a
=>
——b d
this
——e i
.
——i j

CheckIndex
——j t
(
——t u
index
——u z
,
——z {
length——| ‚
)——‚ ƒ
;——ƒ „
public
™™ 
IByteBuffer
™™ 
GetBytes
™™ #
(
™™# $
int
™™$ '
index
™™( -
,
™™- .
byte
™™/ 3
[
™™3 4
]
™™4 5
destination
™™6 A
)
™™A B
=>
™™C E
this
™™F J
.
™™J K

CheckIndex
™™K U
(
™™U V
index
™™V [
,
™™[ \
destination
™™] h
.
™™h i
Length
™™i o
)
™™o p
;
™™p q
public
›› 
IByteBuffer
›› 
GetBytes
›› #
(
››# $
int
››$ '
index
››( -
,
››- .
byte
››/ 3
[
››3 4
]
››4 5
destination
››6 A
,
››A B
int
››C F
dstIndex
››G O
,
››O P
int
››Q T
length
››U [
)
››[ \
=>
››] _
this
››` d
.
››d e

CheckIndex
››e o
(
››o p
index
››p u
,
››u v
length
››w }
)
››} ~
;
››~ 
public
 
IByteBuffer
 
GetBytes
 #
(
# $
int
$ '
index
( -
,
- .
Stream
/ 5
destination
6 A
,
A B
int
C F
length
G M
)
M N
=>
O Q
this
R V
.
V W

CheckIndex
W a
(
a b
index
b g
,
g h
length
i o
)
o p
;
p q
public
ŸŸ 
ICharSequence
ŸŸ 
GetCharSequence
ŸŸ ,
(
ŸŸ, -
int
ŸŸ- 0
index
ŸŸ1 6
,
ŸŸ6 7
int
ŸŸ8 ;
length
ŸŸ< B
,
ŸŸB C
Encoding
ŸŸD L
encoding
ŸŸM U
)
ŸŸU V
{
   	
this
¡¡ 
.
¡¡ 

CheckIndex
¡¡ 
(
¡¡ 
index
¡¡ !
,
¡¡! "
length
¡¡# )
)
¡¡) *
;
¡¡* +
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
public
¥¥ 
string
¥¥ 
	GetString
¥¥ 
(
¥¥  
int
¥¥  #
index
¥¥$ )
,
¥¥) *
int
¥¥+ .
length
¥¥/ 5
,
¥¥5 6
Encoding
¥¥7 ?
encoding
¥¥@ H
)
¥¥H I
{
¦¦ 	
this
§§ 
.
§§ 

CheckIndex
§§ 
(
§§ 
index
§§ !
,
§§! "
length
§§# )
)
§§) *
;
§§* +
return
¨¨ 
null
¨¨ 
;
¨¨ 
}
©© 	
public
«« 
IByteBuffer
«« 

SetBoolean
«« %
(
««% &
int
««& )
index
««* /
,
««/ 0
bool
««1 5
value
««6 ;
)
««; <
=>
««= ?
throw
««@ E
new
««F I&
IndexOutOfRangeException
««J b
(
««b c
)
««c d
;
««d e
public
­­ 
IByteBuffer
­­ 
SetByte
­­ "
(
­­" #
int
­­# &
index
­­' ,
,
­­, -
int
­­. 1
value
­­2 7
)
­­7 8
=>
­­9 ;
throw
­­< A
new
­­B E&
IndexOutOfRangeException
­­F ^
(
­­^ _
)
­­_ `
;
­­` a
public
¯¯ 
IByteBuffer
¯¯ 
SetShort
¯¯ #
(
¯¯# $
int
¯¯$ '
index
¯¯( -
,
¯¯- .
int
¯¯/ 2
value
¯¯3 8
)
¯¯8 9
=>
¯¯: <
throw
¯¯= B
new
¯¯C F&
IndexOutOfRangeException
¯¯G _
(
¯¯_ `
)
¯¯` a
;
¯¯a b
public
±± 
IByteBuffer
±± 

SetShortLE
±± %
(
±±% &
int
±±& )
index
±±* /
,
±±/ 0
int
±±1 4
value
±±5 :
)
±±: ;
=>
±±< >
throw
±±? D
new
±±E H&
IndexOutOfRangeException
±±I a
(
±±a b
)
±±b c
;
±±c d
public
³³ 
IByteBuffer
³³ 
SetUnsignedShort
³³ +
(
³³+ ,
int
³³, /
index
³³0 5
,
³³5 6
ushort
³³7 =
value
³³> C
)
³³C D
=>
³³E G
throw
³³H M
new
³³N Q&
IndexOutOfRangeException
³³R j
(
³³j k
)
³³k l
;
³³l m
public
µµ 
IByteBuffer
µµ  
SetUnsignedShortLE
µµ -
(
µµ- .
int
µµ. 1
index
µµ2 7
,
µµ7 8
ushort
µµ9 ?
value
µµ@ E
)
µµE F
=>
µµG I
throw
µµJ O
new
µµP S&
IndexOutOfRangeException
µµT l
(
µµl m
)
µµm n
;
µµn o
public
·· 
IByteBuffer
·· 
	SetMedium
·· $
(
··$ %
int
··% (
index
··) .
,
··. /
int
··0 3
value
··4 9
)
··9 :
=>
··; =
throw
··> C
new
··D G&
IndexOutOfRangeException
··H `
(
··` a
)
··a b
;
··b c
public
¹¹ 
IByteBuffer
¹¹ 
SetMediumLE
¹¹ &
(
¹¹& '
int
¹¹' *
index
¹¹+ 0
,
¹¹0 1
int
¹¹2 5
value
¹¹6 ;
)
¹¹; <
=>
¹¹= ?
throw
¹¹@ E
new
¹¹F I&
IndexOutOfRangeException
¹¹J b
(
¹¹b c
)
¹¹c d
;
¹¹d e
public
»» 
IByteBuffer
»» 
SetInt
»» !
(
»»! "
int
»»" %
index
»»& +
,
»»+ ,
int
»»- 0
value
»»1 6
)
»»6 7
=>
»»8 :
throw
»»; @
new
»»A D&
IndexOutOfRangeException
»»E ]
(
»»] ^
)
»»^ _
;
»»_ `
public
½½ 
IByteBuffer
½½ 
SetIntLE
½½ #
(
½½# $
int
½½$ '
index
½½( -
,
½½- .
int
½½/ 2
value
½½3 8
)
½½8 9
=>
½½: <
throw
½½= B
new
½½C F&
IndexOutOfRangeException
½½G _
(
½½_ `
)
½½` a
;
½½a b
public
¿¿ 
IByteBuffer
¿¿ 
SetUnsignedInt
¿¿ )
(
¿¿) *
int
¿¿* -
index
¿¿. 3
,
¿¿3 4
uint
¿¿5 9
value
¿¿: ?
)
¿¿? @
=>
¿¿A C
throw
¿¿D I
new
¿¿J M&
IndexOutOfRangeException
¿¿N f
(
¿¿f g
)
¿¿g h
;
¿¿h i
public
ÁÁ 
IByteBuffer
ÁÁ 
SetUnsignedIntLE
ÁÁ +
(
ÁÁ+ ,
int
ÁÁ, /
index
ÁÁ0 5
,
ÁÁ5 6
uint
ÁÁ7 ;
value
ÁÁ< A
)
ÁÁA B
=>
ÁÁC E
throw
ÁÁF K
new
ÁÁL O&
IndexOutOfRangeException
ÁÁP h
(
ÁÁh i
)
ÁÁi j
;
ÁÁj k
public
ÃÃ 
IByteBuffer
ÃÃ 
SetLong
ÃÃ "
(
ÃÃ" #
int
ÃÃ# &
index
ÃÃ' ,
,
ÃÃ, -
long
ÃÃ. 2
value
ÃÃ3 8
)
ÃÃ8 9
=>
ÃÃ: <
throw
ÃÃ= B
new
ÃÃC F&
IndexOutOfRangeException
ÃÃG _
(
ÃÃ_ `
)
ÃÃ` a
;
ÃÃa b
public
ÅÅ 
IByteBuffer
ÅÅ 
	SetLongLE
ÅÅ $
(
ÅÅ$ %
int
ÅÅ% (
index
ÅÅ) .
,
ÅÅ. /
long
ÅÅ0 4
value
ÅÅ5 :
)
ÅÅ: ;
=>
ÅÅ< >
throw
ÅÅ? D
new
ÅÅE H&
IndexOutOfRangeException
ÅÅI a
(
ÅÅa b
)
ÅÅb c
;
ÅÅc d
public
ÇÇ 
IByteBuffer
ÇÇ 
SetChar
ÇÇ "
(
ÇÇ" #
int
ÇÇ# &
index
ÇÇ' ,
,
ÇÇ, -
char
ÇÇ. 2
value
ÇÇ3 8
)
ÇÇ8 9
=>
ÇÇ: <
throw
ÇÇ= B
new
ÇÇC F&
IndexOutOfRangeException
ÇÇG _
(
ÇÇ_ `
)
ÇÇ` a
;
ÇÇa b
public
ÉÉ 
IByteBuffer
ÉÉ 
SetFloat
ÉÉ #
(
ÉÉ# $
int
ÉÉ$ '
index
ÉÉ( -
,
ÉÉ- .
float
ÉÉ/ 4
value
ÉÉ5 :
)
ÉÉ: ;
=>
ÉÉ< >
throw
ÉÉ? D
new
ÉÉE H&
IndexOutOfRangeException
ÉÉI a
(
ÉÉa b
)
ÉÉb c
;
ÉÉc d
public
ËË 
IByteBuffer
ËË 

SetFloatLE
ËË %
(
ËË% &
int
ËË& )
index
ËË* /
,
ËË/ 0
float
ËË1 6
value
ËË7 <
)
ËË< =
=>
ËË> @
throw
ËËA F
new
ËËG J&
IndexOutOfRangeException
ËËK c
(
ËËc d
)
ËËd e
;
ËËe f
public
ÍÍ 
IByteBuffer
ÍÍ 
	SetDouble
ÍÍ $
(
ÍÍ$ %
int
ÍÍ% (
index
ÍÍ) .
,
ÍÍ. /
double
ÍÍ0 6
value
ÍÍ7 <
)
ÍÍ< =
=>
ÍÍ> @
throw
ÍÍA F
new
ÍÍG J&
IndexOutOfRangeException
ÍÍK c
(
ÍÍc d
)
ÍÍd e
;
ÍÍe f
public
ÏÏ 
IByteBuffer
ÏÏ 
SetDoubleLE
ÏÏ &
(
ÏÏ& '
int
ÏÏ' *
index
ÏÏ+ 0
,
ÏÏ0 1
double
ÏÏ2 8
value
ÏÏ9 >
)
ÏÏ> ?
=>
ÏÏ@ B
throw
ÏÏC H
new
ÏÏI L&
IndexOutOfRangeException
ÏÏM e
(
ÏÏe f
)
ÏÏf g
;
ÏÏg h
public
ÑÑ 
IByteBuffer
ÑÑ 
SetBytes
ÑÑ #
(
ÑÑ# $
int
ÑÑ$ '
index
ÑÑ( -
,
ÑÑ- .
IByteBuffer
ÑÑ/ :
src
ÑÑ; >
)
ÑÑ> ?
=>
ÑÑ@ B
throw
ÑÑC H
new
ÑÑI L&
IndexOutOfRangeException
ÑÑM e
(
ÑÑe f
)
ÑÑf g
;
ÑÑg h
public
ÓÓ 
IByteBuffer
ÓÓ 
SetBytes
ÓÓ #
(
ÓÓ# $
int
ÓÓ$ '
index
ÓÓ( -
,
ÓÓ- .
IByteBuffer
ÓÓ/ :
src
ÓÓ; >
,
ÓÓ> ?
int
ÓÓ@ C
length
ÓÓD J
)
ÓÓJ K
=>
ÓÓL N
this
ÓÓO S
.
ÓÓS T

CheckIndex
ÓÓT ^
(
ÓÓ^ _
index
ÓÓ_ d
,
ÓÓd e
length
ÓÓf l
)
ÓÓl m
;
ÓÓm n
public
ÕÕ 
IByteBuffer
ÕÕ 
SetBytes
ÕÕ #
(
ÕÕ# $
int
ÕÕ$ '
index
ÕÕ( -
,
ÕÕ- .
IByteBuffer
ÕÕ/ :
src
ÕÕ; >
,
ÕÕ> ?
int
ÕÕ@ C
srcIndex
ÕÕD L
,
ÕÕL M
int
ÕÕN Q
length
ÕÕR X
)
ÕÕX Y
=>
ÕÕZ \
this
ÕÕ] a
.
ÕÕa b

CheckIndex
ÕÕb l
(
ÕÕl m
index
ÕÕm r
,
ÕÕr s
length
ÕÕt z
)
ÕÕz {
;
ÕÕ{ |
public
×× 
IByteBuffer
×× 
SetBytes
×× #
(
××# $
int
××$ '
index
××( -
,
××- .
byte
××/ 3
[
××3 4
]
××4 5
src
××6 9
)
××9 :
=>
××; =
this
××> B
.
××B C

CheckIndex
××C M
(
××M N
index
××N S
,
××S T
src
××U X
.
××X Y
Length
××Y _
)
××_ `
;
××` a
public
ÙÙ 
IByteBuffer
ÙÙ 
SetBytes
ÙÙ #
(
ÙÙ# $
int
ÙÙ$ '
index
ÙÙ( -
,
ÙÙ- .
byte
ÙÙ/ 3
[
ÙÙ3 4
]
ÙÙ4 5
src
ÙÙ6 9
,
ÙÙ9 :
int
ÙÙ; >
srcIndex
ÙÙ? G
,
ÙÙG H
int
ÙÙI L
length
ÙÙM S
)
ÙÙS T
=>
ÙÙU W
this
ÙÙX \
.
ÙÙ\ ]

CheckIndex
ÙÙ] g
(
ÙÙg h
index
ÙÙh m
,
ÙÙm n
length
ÙÙo u
)
ÙÙu v
;
ÙÙv w
public
ÛÛ 
Task
ÛÛ 
<
ÛÛ 
int
ÛÛ 
>
ÛÛ 
SetBytesAsync
ÛÛ &
(
ÛÛ& '
int
ÛÛ' *
index
ÛÛ+ 0
,
ÛÛ0 1
Stream
ÛÛ2 8
src
ÛÛ9 <
,
ÛÛ< =
int
ÛÛ> A
length
ÛÛB H
,
ÛÛH I
CancellationToken
ÛÛJ [
cancellationToken
ÛÛ\ m
)
ÛÛm n
{
ÜÜ 	
this
İİ 
.
İİ 

CheckIndex
İİ 
(
İİ 
index
İİ !
,
İİ! "
length
İİ# )
)
İİ) *
;
İİ* +
return
ŞŞ 
TaskEx
ŞŞ 
.
ŞŞ 
Zero
ŞŞ 
;
ŞŞ 
}
ßß 	
public
áá 
IByteBuffer
áá 
SetZero
áá "
(
áá" #
int
áá# &
index
áá' ,
,
áá, -
int
áá. 1
length
áá2 8
)
áá8 9
=>
áá: <
this
áá= A
.
ááA B

CheckIndex
ááB L
(
ááL M
index
ááM R
,
ááR S
length
ááT Z
)
ááZ [
;
áá[ \
public
ãã 
int
ãã 
SetCharSequence
ãã "
(
ãã" #
int
ãã# &
index
ãã' ,
,
ãã, -
ICharSequence
ãã. ;
sequence
ãã< D
,
ããD E
Encoding
ããF N
encoding
ããO W
)
ããW X
=>
ããY [
throw
ãã\ a
new
ããb e&
IndexOutOfRangeException
ããf ~
(
ãã~ 
)ãã €
;ãã€ 
public
åå 
int
åå 
	SetString
åå 
(
åå 
int
åå  
index
åå! &
,
åå& '
string
åå( .
value
åå/ 4
,
åå4 5
Encoding
åå6 >
encoding
åå? G
)
ååG H
=>
ååI K
throw
ååL Q
new
ååR U&
IndexOutOfRangeException
ååV n
(
åån o
)
ååo p
;
ååp q
public
çç 
bool
çç 
ReadBoolean
çç 
(
çç  
)
çç  !
=>
çç" $
throw
çç% *
new
çç+ .&
IndexOutOfRangeException
çç/ G
(
ççG H
)
ççH I
;
ççI J
public
éé 
byte
éé 
ReadByte
éé 
(
éé 
)
éé 
=>
éé !
throw
éé" '
new
éé( +&
IndexOutOfRangeException
éé, D
(
ééD E
)
ééE F
;
ééF G
public
ëë 
short
ëë 
	ReadShort
ëë 
(
ëë 
)
ëë  
=>
ëë! #
throw
ëë$ )
new
ëë* -&
IndexOutOfRangeException
ëë. F
(
ëëF G
)
ëëG H
;
ëëH I
public
íí 
short
íí 
ReadShortLE
íí  
(
íí  !
)
íí! "
=>
íí# %
throw
íí& +
new
íí, /&
IndexOutOfRangeException
íí0 H
(
ííH I
)
ííI J
;
ííJ K
public
ïï 
ushort
ïï 
ReadUnsignedShort
ïï '
(
ïï' (
)
ïï( )
=>
ïï* ,
throw
ïï- 2
new
ïï3 6&
IndexOutOfRangeException
ïï7 O
(
ïïO P
)
ïïP Q
;
ïïQ R
public
ññ 
ushort
ññ !
ReadUnsignedShortLE
ññ )
(
ññ) *
)
ññ* +
=>
ññ, .
throw
ññ/ 4
new
ññ5 8&
IndexOutOfRangeException
ññ9 Q
(
ññQ R
)
ññR S
;
ññS T
public
óó 
int
óó 

ReadMedium
óó 
(
óó 
)
óó 
=>
óó  "
throw
óó# (
new
óó) ,&
IndexOutOfRangeException
óó- E
(
óóE F
)
óóF G
;
óóG H
public
õõ 
int
õõ 
ReadMediumLE
õõ 
(
õõ  
)
õõ  !
=>
õõ" $
throw
õõ% *
new
õõ+ .&
IndexOutOfRangeException
õõ/ G
(
õõG H
)
õõH I
;
õõI J
public
÷÷ 
int
÷÷  
ReadUnsignedMedium
÷÷ %
(
÷÷% &
)
÷÷& '
=>
÷÷( *
throw
÷÷+ 0
new
÷÷1 4&
IndexOutOfRangeException
÷÷5 M
(
÷÷M N
)
÷÷N O
;
÷÷O P
public
ùù 
int
ùù "
ReadUnsignedMediumLE
ùù '
(
ùù' (
)
ùù( )
=>
ùù* ,
throw
ùù- 2
new
ùù3 6&
IndexOutOfRangeException
ùù7 O
(
ùùO P
)
ùùP Q
;
ùùQ R
public
ûû 
int
ûû 
ReadInt
ûû 
(
ûû 
)
ûû 
=>
ûû 
throw
ûû  %
new
ûû& )&
IndexOutOfRangeException
ûû* B
(
ûûB C
)
ûûC D
;
ûûD E
public
ıı 
int
ıı 
	ReadIntLE
ıı 
(
ıı 
)
ıı 
=>
ıı !
throw
ıı" '
new
ıı( +&
IndexOutOfRangeException
ıı, D
(
ııD E
)
ııE F
;
ııF G
public
ÿÿ 
uint
ÿÿ 
ReadUnsignedInt
ÿÿ #
(
ÿÿ# $
)
ÿÿ$ %
=>
ÿÿ& (
throw
ÿÿ) .
new
ÿÿ/ 2&
IndexOutOfRangeException
ÿÿ3 K
(
ÿÿK L
)
ÿÿL M
;
ÿÿM N
public
 
uint
 
ReadUnsignedIntLE
 %
(
% &
)
& '
=>
( *
throw
+ 0
new
1 4&
IndexOutOfRangeException
5 M
(
M N
)
N O
;
O P
public
ƒƒ 
long
ƒƒ 
ReadLong
ƒƒ 
(
ƒƒ 
)
ƒƒ 
=>
ƒƒ !
throw
ƒƒ" '
new
ƒƒ( +&
IndexOutOfRangeException
ƒƒ, D
(
ƒƒD E
)
ƒƒE F
;
ƒƒF G
public
…… 
long
…… 

ReadLongLE
…… 
(
…… 
)
……  
=>
……! #
throw
……$ )
new
……* -&
IndexOutOfRangeException
……. F
(
……F G
)
……G H
;
……H I
public
‡‡ 
char
‡‡ 
ReadChar
‡‡ 
(
‡‡ 
)
‡‡ 
=>
‡‡ !
throw
‡‡" '
new
‡‡( +&
IndexOutOfRangeException
‡‡, D
(
‡‡D E
)
‡‡E F
;
‡‡F G
public
‰‰ 
float
‰‰ 
	ReadFloat
‰‰ 
(
‰‰ 
)
‰‰  
=>
‰‰! #
throw
‰‰$ )
new
‰‰* -&
IndexOutOfRangeException
‰‰. F
(
‰‰F G
)
‰‰G H
;
‰‰H I
public
‹‹ 
float
‹‹ 
ReadFloatLE
‹‹  
(
‹‹  !
)
‹‹! "
=>
‹‹# %
throw
‹‹& +
new
‹‹, /&
IndexOutOfRangeException
‹‹0 H
(
‹‹H I
)
‹‹I J
;
‹‹J K
public
 
double
 

ReadDouble
  
(
  !
)
! "
=>
# %
throw
& +
new
, /&
IndexOutOfRangeException
0 H
(
H I
)
I J
;
J K
public
 
double
 
ReadDoubleLE
 "
(
" #
)
# $
=>
% '
throw
( -
new
. 1&
IndexOutOfRangeException
2 J
(
J K
)
K L
;
L M
public
‘‘ 
IByteBuffer
‘‘ 
	ReadBytes
‘‘ $
(
‘‘$ %
int
‘‘% (
length
‘‘) /
)
‘‘/ 0
=>
‘‘1 3
this
‘‘4 8
.
‘‘8 9
CheckLength
‘‘9 D
(
‘‘D E
length
‘‘E K
)
‘‘K L
;
‘‘L M
public
““ 
IByteBuffer
““ 
	ReadBytes
““ $
(
““$ %
IByteBuffer
““% 0
destination
““1 <
)
““< =
=>
““> @
this
““A E
.
““E F
CheckLength
““F Q
(
““Q R
destination
““R ]
.
““] ^
WritableBytes
““^ k
)
““k l
;
““l m
public
•• 
IByteBuffer
•• 
	ReadBytes
•• $
(
••$ %
IByteBuffer
••% 0
destination
••1 <
,
••< =
int
••> A
length
••B H
)
••H I
=>
••J L
this
••M Q
.
••Q R
CheckLength
••R ]
(
••] ^
length
••^ d
)
••d e
;
••e f
public
—— 
IByteBuffer
—— 
	ReadBytes
—— $
(
——$ %
IByteBuffer
——% 0
destination
——1 <
,
——< =
int
——> A
dstIndex
——B J
,
——J K
int
——L O
length
——P V
)
——V W
=>
——X Z
this
——[ _
.
——_ `
CheckLength
——` k
(
——k l
length
——l r
)
——r s
;
——s t
public
™™ 
IByteBuffer
™™ 
	ReadBytes
™™ $
(
™™$ %
byte
™™% )
[
™™) *
]
™™* +
destination
™™, 7
)
™™7 8
=>
™™9 ;
this
™™< @
.
™™@ A
CheckLength
™™A L
(
™™L M
destination
™™M X
.
™™X Y
Length
™™Y _
)
™™_ `
;
™™` a
public
›› 
IByteBuffer
›› 
	ReadBytes
›› $
(
››$ %
byte
››% )
[
››) *
]
››* +
destination
››, 7
,
››7 8
int
››9 <
dstIndex
››= E
,
››E F
int
››G J
length
››K Q
)
››Q R
=>
››S U
this
››V Z
.
››Z [
CheckLength
››[ f
(
››f g
length
››g m
)
››m n
;
››n o
public
 
IByteBuffer
 
	ReadBytes
 $
(
$ %
Stream
% +
destination
, 7
,
7 8
int
9 <
length
= C
)
C D
=>
E G
this
H L
.
L M
CheckLength
M X
(
X Y
length
Y _
)
_ `
;
` a
public
ŸŸ 
ICharSequence
ŸŸ 
ReadCharSequence
ŸŸ -
(
ŸŸ- .
int
ŸŸ. 1
length
ŸŸ2 8
,
ŸŸ8 9
Encoding
ŸŸ: B
encoding
ŸŸC K
)
ŸŸK L
{
   	
this
¡¡ 
.
¡¡ 
CheckLength
¡¡ 
(
¡¡ 
length
¡¡ #
)
¡¡# $
;
¡¡$ %
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
public
¥¥ 
string
¥¥ 

ReadString
¥¥  
(
¥¥  !
int
¥¥! $
length
¥¥% +
,
¥¥+ ,
Encoding
¥¥- 5
encoding
¥¥6 >
)
¥¥> ?
{
¦¦ 	
this
§§ 
.
§§ 
CheckLength
§§ 
(
§§ 
length
§§ #
)
§§# $
;
§§$ %
return
¨¨ 
null
¨¨ 
;
¨¨ 
}
©© 	
public
«« 
IByteBuffer
«« 
	SkipBytes
«« $
(
««$ %
int
««% (
length
««) /
)
««/ 0
=>
««1 3
this
««4 8
.
««8 9
CheckLength
««9 D
(
««D E
length
««E K
)
««K L
;
««L M
public
­­ 
IByteBuffer
­­ 
WriteBoolean
­­ '
(
­­' (
bool
­­( ,
value
­­- 2
)
­­2 3
=>
­­4 6
throw
­­7 <
new
­­= @&
IndexOutOfRangeException
­­A Y
(
­­Y Z
)
­­Z [
;
­­[ \
public
¯¯ 
IByteBuffer
¯¯ 
	WriteByte
¯¯ $
(
¯¯$ %
int
¯¯% (
value
¯¯) .
)
¯¯. /
=>
¯¯0 2
throw
¯¯3 8
new
¯¯9 <&
IndexOutOfRangeException
¯¯= U
(
¯¯U V
)
¯¯V W
;
¯¯W X
public
±± 
IByteBuffer
±± 

WriteShort
±± %
(
±±% &
int
±±& )
value
±±* /
)
±±/ 0
=>
±±1 3
throw
±±4 9
new
±±: =&
IndexOutOfRangeException
±±> V
(
±±V W
)
±±W X
;
±±X Y
public
³³ 
IByteBuffer
³³ 
WriteShortLE
³³ '
(
³³' (
int
³³( +
value
³³, 1
)
³³1 2
=>
³³3 5
throw
³³6 ;
new
³³< ?&
IndexOutOfRangeException
³³@ X
(
³³X Y
)
³³Y Z
;
³³Z [
public
µµ 
IByteBuffer
µµ  
WriteUnsignedShort
µµ -
(
µµ- .
ushort
µµ. 4
value
µµ5 :
)
µµ: ;
=>
µµ< >
throw
µµ? D
new
µµE H&
IndexOutOfRangeException
µµI a
(
µµa b
)
µµb c
;
µµc d
public
·· 
IByteBuffer
·· "
WriteUnsignedShortLE
·· /
(
··/ 0
ushort
··0 6
value
··7 <
)
··< =
=>
··> @
throw
··A F
new
··G J&
IndexOutOfRangeException
··K c
(
··c d
)
··d e
;
··e f
public
¹¹ 
IByteBuffer
¹¹ 
WriteMedium
¹¹ &
(
¹¹& '
int
¹¹' *
value
¹¹+ 0
)
¹¹0 1
=>
¹¹2 4
throw
¹¹5 :
new
¹¹; >&
IndexOutOfRangeException
¹¹? W
(
¹¹W X
)
¹¹X Y
;
¹¹Y Z
public
»» 
IByteBuffer
»» 
WriteMediumLE
»» (
(
»»( )
int
»») ,
value
»»- 2
)
»»2 3
=>
»»4 6
throw
»»7 <
new
»»= @&
IndexOutOfRangeException
»»A Y
(
»»Y Z
)
»»Z [
;
»»[ \
public
½½ 
IByteBuffer
½½ !
WriteUnsignedMedium
½½ .
(
½½. /
int
½½/ 2
value
½½3 8
)
½½8 9
=>
½½: <
throw
½½= B
new
½½C F&
IndexOutOfRangeException
½½G _
(
½½_ `
)
½½` a
;
½½a b
public
¿¿ 
IByteBuffer
¿¿ #
WriteUnsignedMediumLE
¿¿ 0
(
¿¿0 1
int
¿¿1 4
value
¿¿5 :
)
¿¿: ;
=>
¿¿< >
throw
¿¿? D
new
¿¿E H&
IndexOutOfRangeException
¿¿I a
(
¿¿a b
)
¿¿b c
;
¿¿c d
public
ÁÁ 
IByteBuffer
ÁÁ 
WriteInt
ÁÁ #
(
ÁÁ# $
int
ÁÁ$ '
value
ÁÁ( -
)
ÁÁ- .
=>
ÁÁ/ 1
throw
ÁÁ2 7
new
ÁÁ8 ;&
IndexOutOfRangeException
ÁÁ< T
(
ÁÁT U
)
ÁÁU V
;
ÁÁV W
public
ÃÃ 
IByteBuffer
ÃÃ 

WriteIntLE
ÃÃ %
(
ÃÃ% &
int
ÃÃ& )
value
ÃÃ* /
)
ÃÃ/ 0
=>
ÃÃ1 3
throw
ÃÃ4 9
new
ÃÃ: =&
IndexOutOfRangeException
ÃÃ> V
(
ÃÃV W
)
ÃÃW X
;
ÃÃX Y
public
ÅÅ 
IByteBuffer
ÅÅ 
WriteUnsignedInt
ÅÅ +
(
ÅÅ+ ,
uint
ÅÅ, 0
value
ÅÅ1 6
)
ÅÅ6 7
=>
ÅÅ8 :
throw
ÅÅ; @
new
ÅÅA D&
IndexOutOfRangeException
ÅÅE ]
(
ÅÅ] ^
)
ÅÅ^ _
;
ÅÅ_ `
public
ÇÇ 
IByteBuffer
ÇÇ  
WriteUnsignedIntLE
ÇÇ -
(
ÇÇ- .
uint
ÇÇ. 2
value
ÇÇ3 8
)
ÇÇ8 9
=>
ÇÇ: <
throw
ÇÇ= B
new
ÇÇC F&
IndexOutOfRangeException
ÇÇG _
(
ÇÇ_ `
)
ÇÇ` a
;
ÇÇa b
public
ÉÉ 
IByteBuffer
ÉÉ 
	WriteLong
ÉÉ $
(
ÉÉ$ %
long
ÉÉ% )
value
ÉÉ* /
)
ÉÉ/ 0
=>
ÉÉ1 3
throw
ÉÉ4 9
new
ÉÉ: =&
IndexOutOfRangeException
ÉÉ> V
(
ÉÉV W
)
ÉÉW X
;
ÉÉX Y
public
ËË 
IByteBuffer
ËË 
WriteLongLE
ËË &
(
ËË& '
long
ËË' +
value
ËË, 1
)
ËË1 2
=>
ËË3 5
throw
ËË6 ;
new
ËË< ?&
IndexOutOfRangeException
ËË@ X
(
ËËX Y
)
ËËY Z
;
ËËZ [
public
ÍÍ 
IByteBuffer
ÍÍ 
	WriteChar
ÍÍ $
(
ÍÍ$ %
char
ÍÍ% )
value
ÍÍ* /
)
ÍÍ/ 0
=>
ÍÍ1 3
throw
ÍÍ4 9
new
ÍÍ: =&
IndexOutOfRangeException
ÍÍ> V
(
ÍÍV W
)
ÍÍW X
;
ÍÍX Y
public
ÏÏ 
IByteBuffer
ÏÏ 

WriteFloat
ÏÏ %
(
ÏÏ% &
float
ÏÏ& +
value
ÏÏ, 1
)
ÏÏ1 2
=>
ÏÏ3 5
throw
ÏÏ6 ;
new
ÏÏ< ?&
IndexOutOfRangeException
ÏÏ@ X
(
ÏÏX Y
)
ÏÏY Z
;
ÏÏZ [
public
ÑÑ 
IByteBuffer
ÑÑ 
WriteFloatLE
ÑÑ '
(
ÑÑ' (
float
ÑÑ( -
value
ÑÑ. 3
)
ÑÑ3 4
=>
ÑÑ5 7
throw
ÑÑ8 =
new
ÑÑ> A&
IndexOutOfRangeException
ÑÑB Z
(
ÑÑZ [
)
ÑÑ[ \
;
ÑÑ\ ]
public
ÓÓ 
IByteBuffer
ÓÓ 
WriteDouble
ÓÓ &
(
ÓÓ& '
double
ÓÓ' -
value
ÓÓ. 3
)
ÓÓ3 4
=>
ÓÓ5 7
throw
ÓÓ8 =
new
ÓÓ> A&
IndexOutOfRangeException
ÓÓB Z
(
ÓÓZ [
)
ÓÓ[ \
;
ÓÓ\ ]
public
ÕÕ 
IByteBuffer
ÕÕ 
WriteDoubleLE
ÕÕ (
(
ÕÕ( )
double
ÕÕ) /
value
ÕÕ0 5
)
ÕÕ5 6
=>
ÕÕ7 9
throw
ÕÕ: ?
new
ÕÕ@ C&
IndexOutOfRangeException
ÕÕD \
(
ÕÕ\ ]
)
ÕÕ] ^
;
ÕÕ^ _
public
×× 
IByteBuffer
×× 

WriteBytes
×× %
(
××% &
IByteBuffer
××& 1
src
××2 5
)
××5 6
=>
××7 9
this
××: >
.
××> ?
CheckLength
××? J
(
××J K
src
××K N
.
××N O
ReadableBytes
××O \
)
××\ ]
;
××] ^
public
ÙÙ 
IByteBuffer
ÙÙ 

WriteBytes
ÙÙ %
(
ÙÙ% &
IByteBuffer
ÙÙ& 1
src
ÙÙ2 5
,
ÙÙ5 6
int
ÙÙ7 :
length
ÙÙ; A
)
ÙÙA B
=>
ÙÙC E
this
ÙÙF J
.
ÙÙJ K
CheckLength
ÙÙK V
(
ÙÙV W
length
ÙÙW ]
)
ÙÙ] ^
;
ÙÙ^ _
public
ÛÛ 
IByteBuffer
ÛÛ 

WriteBytes
ÛÛ %
(
ÛÛ% &
IByteBuffer
ÛÛ& 1
src
ÛÛ2 5
,
ÛÛ5 6
int
ÛÛ7 :
srcIndex
ÛÛ; C
,
ÛÛC D
int
ÛÛE H
length
ÛÛI O
)
ÛÛO P
=>
ÛÛQ S
this
ÛÛT X
.
ÛÛX Y
CheckLength
ÛÛY d
(
ÛÛd e
length
ÛÛe k
)
ÛÛk l
;
ÛÛl m
public
İİ 
IByteBuffer
İİ 

WriteBytes
İİ %
(
İİ% &
byte
İİ& *
[
İİ* +
]
İİ+ ,
src
İİ- 0
)
İİ0 1
=>
İİ2 4
this
İİ5 9
.
İİ9 :
CheckLength
İİ: E
(
İİE F
src
İİF I
.
İİI J
Length
İİJ P
)
İİP Q
;
İİQ R
public
ßß 
IByteBuffer
ßß 

WriteBytes
ßß %
(
ßß% &
byte
ßß& *
[
ßß* +
]
ßß+ ,
src
ßß- 0
,
ßß0 1
int
ßß2 5
srcIndex
ßß6 >
,
ßß> ?
int
ßß@ C
length
ßßD J
)
ßßJ K
=>
ßßL N
this
ßßO S
.
ßßS T
CheckLength
ßßT _
(
ßß_ `
length
ßß` f
)
ßßf g
;
ßßg h
public
áá 
IByteBuffer
áá 
	WriteZero
áá $
(
áá$ %
int
áá% (
length
áá) /
)
áá/ 0
=>
áá1 3
this
áá4 8
.
áá8 9
CheckLength
áá9 D
(
ááD E
length
ááE K
)
ááK L
;
ááL M
public
ãã 
int
ãã 
WriteCharSequence
ãã $
(
ãã$ %
ICharSequence
ãã% 2
sequence
ãã3 ;
,
ãã; <
Encoding
ãã= E
encoding
ããF N
)
ããN O
=>
ããP R
throw
ããS X
new
ããY \&
IndexOutOfRangeException
ãã] u
(
ããu v
)
ããv w
;
ããw x
public
åå 
int
åå 
WriteString
åå 
(
åå 
string
åå %
value
åå& +
,
åå+ ,
Encoding
åå- 5
encoding
åå6 >
)
åå> ?
=>
åå@ B
throw
ååC H
new
ååI L&
IndexOutOfRangeException
ååM e
(
ååe f
)
ååf g
;
ååg h
public
çç 
int
çç 
IndexOf
çç 
(
çç 
int
çç 
	fromIndex
çç (
,
çç( )
int
çç* -
toIndex
çç. 5
,
çç5 6
byte
çç7 ;
value
çç< A
)
ççA B
{
èè 	
this
éé 
.
éé 

CheckIndex
éé 
(
éé 
	fromIndex
éé %
)
éé% &
;
éé& '
this
êê 
.
êê 

CheckIndex
êê 
(
êê 
toIndex
êê #
)
êê# $
;
êê$ %
return
ëë 
-
ëë 
$num
ëë 
;
ëë 
}
ìì 	
public
îî 
int
îî 
BytesBefore
îî 
(
îî 
byte
îî #
value
îî$ )
)
îî) *
=>
îî+ -
-
îî. /
$num
îî/ 0
;
îî0 1
public
ğğ 
int
ğğ 
BytesBefore
ğğ 
(
ğğ 
int
ğğ "
length
ğğ# )
,
ğğ) *
byte
ğğ+ /
value
ğğ0 5
)
ğğ5 6
{
ññ 	
this
òò 
.
òò 
CheckLength
òò 
(
òò 
length
òò #
)
òò# $
;
òò$ %
return
óó 
-
óó 
$num
óó 
;
óó 
}
ôô 	
public
öö 
int
öö 
BytesBefore
öö 
(
öö 
int
öö "
index
öö# (
,
öö( )
int
öö* -
length
öö. 4
,
öö4 5
byte
öö6 :
value
öö; @
)
öö@ A
{
÷÷ 	
this
øø 
.
øø 

CheckIndex
øø 
(
øø 
index
øø !
,
øø! "
length
øø# )
)
øø) *
;
øø* +
return
ùù 
-
ùù 
$num
ùù 
;
ùù 
}
úú 	
public
üü 
int
üü 
ForEachByte
üü 
(
üü 
IByteProcessor
üü -
	processor
üü. 7
)
üü7 8
=>
üü9 ;
-
üü< =
$num
üü= >
;
üü> ?
public
şş 
int
şş 
ForEachByte
şş 
(
şş 
int
şş "
index
şş# (
,
şş( )
int
şş* -
length
şş. 4
,
şş4 5
IByteProcessor
şş6 D
	processor
şşE N
)
şşN O
{
ÿÿ 	
this
€€ 
.
€€ 

CheckIndex
€€ 
(
€€ 
index
€€ !
,
€€! "
length
€€# )
)
€€) *
;
€€* +
return
 
-
 
$num
 
;
 
}
‚‚ 	
public
„„ 
int
„„ 
ForEachByteDesc
„„ "
(
„„" #
IByteProcessor
„„# 1
	processor
„„2 ;
)
„„; <
=>
„„= ?
-
„„@ A
$num
„„A B
;
„„B C
public
†† 
int
†† 
ForEachByteDesc
†† "
(
††" #
int
††# &
index
††' ,
,
††, -
int
††. 1
length
††2 8
,
††8 9
IByteProcessor
††: H
	processor
††I R
)
††R S
{
‡‡ 	
this
ˆˆ 
.
ˆˆ 

CheckIndex
ˆˆ 
(
ˆˆ 
index
ˆˆ !
,
ˆˆ! "
length
ˆˆ# )
)
ˆˆ) *
;
ˆˆ* +
return
‰‰ 
-
‰‰ 
$num
‰‰ 
;
‰‰ 
}
ŠŠ 	
public
ŒŒ 
IByteBuffer
ŒŒ 
Copy
ŒŒ 
(
ŒŒ  
)
ŒŒ  !
=>
ŒŒ" $
this
ŒŒ% )
;
ŒŒ) *
public
 
IByteBuffer
 
Copy
 
(
  
int
  #
index
$ )
,
) *
int
+ .
length
/ 5
)
5 6
{
 	
this
 
.
 

CheckIndex
 
(
 
index
 !
,
! "
length
# )
)
) *
;
* +
return
‘‘ 
this
‘‘ 
;
‘‘ 
}
’’ 	
public
”” 
IByteBuffer
”” 
Slice
””  
(
””  !
)
””! "
=>
””# %
this
””& *
;
””* +
public
–– 
IByteBuffer
–– 
RetainedSlice
–– (
(
––( )
)
––) *
=>
––+ -
this
––. 2
;
––2 3
public
˜˜ 
IByteBuffer
˜˜ 
Slice
˜˜  
(
˜˜  !
int
˜˜! $
index
˜˜% *
,
˜˜* +
int
˜˜, /
length
˜˜0 6
)
˜˜6 7
=>
˜˜8 :
this
˜˜; ?
.
˜˜? @

CheckIndex
˜˜@ J
(
˜˜J K
index
˜˜K P
,
˜˜P Q
length
˜˜R X
)
˜˜X Y
;
˜˜Y Z
public
šš 
IByteBuffer
šš 
RetainedSlice
šš (
(
šš( )
int
šš) ,
index
šš- 2
,
šš2 3
int
šš4 7
length
šš8 >
)
šš> ?
=>
šš@ B
this
ššC G
.
ššG H

CheckIndex
ššH R
(
ššR S
index
ššS X
,
ššX Y
length
ššZ `
)
šš` a
;
šša b
public
œœ 
IByteBuffer
œœ 
	Duplicate
œœ $
(
œœ$ %
)
œœ% &
=>
œœ' )
this
œœ* .
;
œœ. /
public
 
int
 
IoBufferCount
  
=>
! #
$num
$ %
;
% &
public
   
ArraySegment
   
<
   
byte
    
>
    !
GetIoBuffer
  " -
(
  - .
)
  . /
=>
  0 2
EmptyBuffer
  3 >
;
  > ?
public
¢¢ 
ArraySegment
¢¢ 
<
¢¢ 
byte
¢¢  
>
¢¢  !
GetIoBuffer
¢¢" -
(
¢¢- .
int
¢¢. 1
index
¢¢2 7
,
¢¢7 8
int
¢¢9 <
length
¢¢= C
)
¢¢C D
{
££ 	
this
¤¤ 
.
¤¤ 

CheckIndex
¤¤ 
(
¤¤ 
index
¤¤ !
,
¤¤! "
length
¤¤# )
)
¤¤) *
;
¤¤* +
return
¥¥ 
this
¥¥ 
.
¥¥ 
GetIoBuffer
¥¥ #
(
¥¥# $
)
¥¥$ %
;
¥¥% &
}
¦¦ 	
public
¨¨ 
ArraySegment
¨¨ 
<
¨¨ 
byte
¨¨  
>
¨¨  !
[
¨¨! "
]
¨¨" #
GetIoBuffers
¨¨$ 0
(
¨¨0 1
)
¨¨1 2
=>
¨¨3 5
EmptyBuffers
¨¨6 B
;
¨¨B C
public
ªª 
ArraySegment
ªª 
<
ªª 
byte
ªª  
>
ªª  !
[
ªª! "
]
ªª" #
GetIoBuffers
ªª$ 0
(
ªª0 1
int
ªª1 4
index
ªª5 :
,
ªª: ;
int
ªª< ?
length
ªª@ F
)
ªªF G
{
«« 	
this
¬¬ 
.
¬¬ 

CheckIndex
¬¬ 
(
¬¬ 
index
¬¬ !
,
¬¬! "
length
¬¬# )
)
¬¬) *
;
¬¬* +
return
­­ 
this
­­ 
.
­­ 
GetIoBuffers
­­ $
(
­­$ %
)
­­% &
;
­­& '
}
®® 	
public
°° 
bool
°° 
HasArray
°° 
=>
°° 
true
°°  $
;
°°$ %
public
²² 
byte
²² 
[
²² 
]
²² 
Array
²² 
=>
²² 
ArrayExtensions
²² .
.
²². /
	ZeroBytes
²²/ 8
;
²²8 9
public
´´ 
byte
´´ 
[
´´ 
]
´´ 
ToArray
´´ 
(
´´ 
)
´´ 
=>
´´  "
ArrayExtensions
´´# 2
.
´´2 3
	ZeroBytes
´´3 <
;
´´< =
public
¶¶ 
int
¶¶ 
ArrayOffset
¶¶ 
=>
¶¶ !
$num
¶¶" #
;
¶¶# $
public
¸¸ 
bool
¸¸ 
HasMemoryAddress
¸¸ $
=>
¸¸% '
false
¸¸( -
;
¸¸- .
public
ºº 
ref
ºº 
byte
ºº &
GetPinnableMemoryAddress
ºº 0
(
ºº0 1
)
ºº1 2
=>
ºº3 5
throw
ºº6 ;
new
ºº< ?#
NotSupportedException
ºº@ U
(
ººU V
)
ººV W
;
ººW X
public
¼¼ 
IntPtr
¼¼ #
AddressOfPinnedMemory
¼¼ +
(
¼¼+ ,
)
¼¼, -
=>
¼¼. 0
IntPtr
¼¼1 7
.
¼¼7 8
Zero
¼¼8 <
;
¼¼< =
public
¾¾ 
string
¾¾ 
ToString
¾¾ 
(
¾¾ 
Encoding
¾¾ '
encoding
¾¾( 0
)
¾¾0 1
=>
¾¾2 4
string
¾¾5 ;
.
¾¾; <
Empty
¾¾< A
;
¾¾A B
public
ÀÀ 
string
ÀÀ 
ToString
ÀÀ 
(
ÀÀ 
int
ÀÀ "
index
ÀÀ# (
,
ÀÀ( )
int
ÀÀ* -
length
ÀÀ. 4
,
ÀÀ4 5
Encoding
ÀÀ6 >
encoding
ÀÀ? G
)
ÀÀG H
{
ÁÁ 	
this
ÂÂ 
.
ÂÂ 

CheckIndex
ÂÂ 
(
ÂÂ 
index
ÂÂ !
,
ÂÂ! "
length
ÂÂ# )
)
ÂÂ) *
;
ÂÂ* +
return
ÃÃ 
this
ÃÃ 
.
ÃÃ 
ToString
ÃÃ  
(
ÃÃ  !
encoding
ÃÃ! )
)
ÃÃ) *
;
ÃÃ* +
}
ÄÄ 	
public
ÆÆ 
override
ÆÆ 
int
ÆÆ 
GetHashCode
ÆÆ '
(
ÆÆ' (
)
ÆÆ( )
=>
ÆÆ* ,
$num
ÆÆ- .
;
ÆÆ. /
public
ÈÈ 
bool
ÈÈ 
Equals
ÈÈ 
(
ÈÈ 
IByteBuffer
ÈÈ &
buffer
ÈÈ' -
)
ÈÈ- .
=>
ÈÈ/ 1
buffer
ÈÈ2 8
!=
ÈÈ9 ;
null
ÈÈ< @
&&
ÈÈA C
!
ÈÈD E
buffer
ÈÈE K
.
ÈÈK L

IsReadable
ÈÈL V
(
ÈÈV W
)
ÈÈW X
;
ÈÈX Y
public
ÊÊ 
override
ÊÊ 
bool
ÊÊ 
Equals
ÊÊ #
(
ÊÊ# $
object
ÊÊ$ *
obj
ÊÊ+ .
)
ÊÊ. /
{
ËË 	
var
ÌÌ 
buffer
ÌÌ 
=
ÌÌ 
obj
ÌÌ 
as
ÌÌ 
IByteBuffer
ÌÌ  +
;
ÌÌ+ ,
return
ÍÍ 
this
ÍÍ 
.
ÍÍ 
Equals
ÍÍ 
(
ÍÍ 
buffer
ÍÍ %
)
ÍÍ% &
;
ÍÍ& '
}
ÎÎ 	
public
ĞĞ 
int
ĞĞ 
	CompareTo
ĞĞ 
(
ĞĞ 
IByteBuffer
ĞĞ (
buffer
ĞĞ) /
)
ĞĞ/ 0
=>
ĞĞ1 3
buffer
ĞĞ4 :
.
ĞĞ: ;

IsReadable
ĞĞ; E
(
ĞĞE F
)
ĞĞF G
?
ĞĞH I
-
ĞĞJ K
$num
ĞĞK L
:
ĞĞM N
$num
ĞĞO P
;
ĞĞP Q
public
ÒÒ 
override
ÒÒ 
string
ÒÒ 
ToString
ÒÒ '
(
ÒÒ' (
)
ÒÒ( )
=>
ÒÒ* ,
string
ÒÒ- 3
.
ÒÒ3 4
Empty
ÒÒ4 9
;
ÒÒ9 :
public
ÔÔ 
bool
ÔÔ 

IsReadable
ÔÔ 
(
ÔÔ 
)
ÔÔ  
=>
ÔÔ! #
false
ÔÔ$ )
;
ÔÔ) *
public
ÖÖ 
bool
ÖÖ 

IsReadable
ÖÖ 
(
ÖÖ 
int
ÖÖ "
size
ÖÖ# '
)
ÖÖ' (
=>
ÖÖ) +
false
ÖÖ, 1
;
ÖÖ1 2
public
ØØ 
int
ØØ 
ReferenceCount
ØØ !
=>
ØØ" $
$num
ØØ% &
;
ØØ& '
public
ÚÚ 
IReferenceCounted
ÚÚ  
Retain
ÚÚ! '
(
ÚÚ' (
)
ÚÚ( )
=>
ÚÚ* ,
this
ÚÚ- 1
;
ÚÚ1 2
public
ÜÜ 
IByteBuffer
ÜÜ 
RetainedDuplicate
ÜÜ ,
(
ÜÜ, -
)
ÜÜ- .
=>
ÜÜ/ 1
this
ÜÜ2 6
;
ÜÜ6 7
public
ŞŞ 
IReferenceCounted
ŞŞ  
Retain
ŞŞ! '
(
ŞŞ' (
int
ŞŞ( +
	increment
ŞŞ, 5
)
ŞŞ5 6
=>
ŞŞ7 9
this
ŞŞ: >
;
ŞŞ> ?
public
àà 
IReferenceCounted
àà  
Touch
àà! &
(
àà& '
)
àà' (
=>
àà) +
this
àà, 0
;
àà0 1
public
ââ 
IReferenceCounted
ââ  
Touch
ââ! &
(
ââ& '
object
ââ' -
hint
ââ. 2
)
ââ2 3
=>
ââ4 6
this
ââ7 ;
;
ââ; <
public
ää 
bool
ää 
Release
ää 
(
ää 
)
ää 
=>
ää  
false
ää! &
;
ää& '
public
ææ 
bool
ææ 
Release
ææ 
(
ææ 
int
ææ 
	decrement
ææ  )
)
ææ) *
=>
ææ+ -
false
ææ. 3
;
ææ3 4
public
èè 
IByteBuffer
èè 
	ReadSlice
èè $
(
èè$ %
int
èè% (
length
èè) /
)
èè/ 0
=>
èè1 3
this
èè4 8
.
èè8 9
CheckLength
èè9 D
(
èèD E
length
èèE K
)
èèK L
;
èèL M
public
êê 
IByteBuffer
êê 
ReadRetainedSlice
êê ,
(
êê, -
int
êê- 0
length
êê1 7
)
êê7 8
=>
êê9 ;
this
êê< @
.
êê@ A
CheckLength
êêA L
(
êêL M
length
êêM S
)
êêS T
;
êêT U
public
ìì 
Task
ìì 
WriteBytesAsync
ìì #
(
ìì# $
Stream
ìì$ *
stream
ìì+ 1
,
ìì1 2
int
ìì3 6
length
ìì7 =
)
ìì= >
{
íí 	
this
îî 
.
îî 
CheckLength
îî 
(
îî 
length
îî #
)
îî# $
;
îî$ %
return
ïï 
TaskEx
ïï 
.
ïï 
	Completed
ïï #
;
ïï# $
}
ğğ 	
public
òò 
Task
òò 
WriteBytesAsync
òò #
(
òò# $
Stream
òò$ *
stream
òò+ 1
,
òò1 2
int
òò3 6
length
òò7 =
,
òò= >
CancellationToken
òò? P
cancellationToken
òòQ b
)
òòb c
{
óó 	
this
ôô 
.
ôô 
CheckLength
ôô 
(
ôô 
length
ôô #
)
ôô# $
;
ôô$ %
return
õõ 
TaskEx
õõ 
.
õõ 
	Completed
õõ #
;
õõ# $
}
öö 	
IByteBuffer
ùù 

CheckIndex
ùù 
(
ùù 
int
ùù "
index
ùù# (
)
ùù( )
{
úú 	
if
ûû 
(
ûû 
index
ûû 
!=
ûû 
$num
ûû 
)
ûû 
{
üü 
throw
ıı 
new
ıı &
IndexOutOfRangeException
ıı 2
(
ıı2 3
)
ıı3 4
;
ıı4 5
}
şş 
return
ÿÿ 
this
ÿÿ 
;
ÿÿ 
}
€€ 	
IByteBuffer
‚‚ 

CheckIndex
‚‚ 
(
‚‚ 
int
‚‚ "
index
‚‚# (
,
‚‚( )
int
‚‚* -
length
‚‚. 4
)
‚‚4 5
{
ƒƒ 	
if
„„ 
(
„„ 
length
„„ 
<
„„ 
$num
„„ 
)
„„ 
{
…… 
throw
†† 
new
†† 
ArgumentException
†† +
(
††+ ,
$str
††, 6
+
††7 8
length
††9 ?
)
††? @
;
††@ A
}
‡‡ 
if
ˆˆ 
(
ˆˆ 
index
ˆˆ 
!=
ˆˆ 
$num
ˆˆ 
||
ˆˆ 
length
ˆˆ $
!=
ˆˆ% '
$num
ˆˆ( )
)
ˆˆ) *
{
‰‰ 
throw
ŠŠ 
new
ŠŠ &
IndexOutOfRangeException
ŠŠ 2
(
ŠŠ2 3
)
ŠŠ3 4
;
ŠŠ4 5
}
‹‹ 
return
 
this
 
;
 
}
 	
IByteBuffer
‘‘ 
CheckLength
‘‘ 
(
‘‘  
int
‘‘  #
length
‘‘$ *
)
‘‘* +
{
’’ 	
if
““ 
(
““ 
length
““ 
<
““ 
$num
““ 
)
““ 
{
”” 
throw
•• 
new
•• 
ArgumentException
•• +
(
••+ ,
$str
••, 6
+
••7 8
length
••9 ?
+
••@ A
$str
••B U
)
••U V
;
••V W
}
–– 
if
—— 
(
—— 
length
—— 
!=
—— 
$num
—— 
)
—— 
{
˜˜ 
throw
™™ 
new
™™ &
IndexOutOfRangeException
™™ 2
(
™™2 3
)
™™3 4
;
™™4 5
}
šš 
return
›› 
this
›› 
;
›› 
}
œœ 	
}
 
} —Å
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\HeapByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

class 
HeapByteBufferUtil #
{		 
[

 	

MethodImpl

	 
(

 
MethodImplOptions

 %
.

% &
AggressiveInlining

& 8
)

8 9
]

9 :
internal 
static 
byte 
GetByte $
($ %
byte% )
[) *
]* +
memory, 2
,2 3
int4 7
index8 =
)= >
=>? A
memoryB H
[H I
indexI N
]N O
;O P
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 
GetShort &
(& '
byte' +
[+ ,
], -
memory. 4
,4 5
int6 9
index: ?
)? @
=>A C
	unchecked 
( 
( 
short 
) 
( 
memory $
[$ %
index% *
]* +
<<, .
$num/ 0
|1 2
memory3 9
[9 :
index: ?
+@ A
$numB C
]C D
)D E
)E F
;F G
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 

GetShortLE (
(( )
byte) -
[- .
]. /
memory0 6
,6 7
int8 ;
index< A
)A B
=>C E
	unchecked 
( 
( 
short 
) 
( 
memory $
[$ %
index% *
]* +
|, -
memory. 4
[4 5
index5 :
+; <
$num= >
]> ?
<<@ B
$numC D
)D E
)E F
;F G
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMedium -
(- .
byte. 2
[2 3
]3 4
memory5 ;
,; <
int= @
indexA F
)F G
=>H J
	unchecked 
( 
memory 
[ 
index 
] 
<<  
$num! #
|$ %
memory 
[ 
index 
+ 
$num  
]  !
<<" $
$num% &
|' (
memory 
[ 
index 
+ 
$num  
]  !
)! "
;" #
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMediumLE /
(/ 0
byte0 4
[4 5
]5 6
memory7 =
,= >
int? B
indexC H
)H I
=>J L
	unchecked 
( 
memory 
[ 
index 
] 
| 
memory   
[   
index   
+   
$num    
]    !
<<  " $
$num  % &
|  ' (
memory!! 
[!! 
index!! 
+!! 
$num!!  
]!!  !
<<!!" $
$num!!% '
)!!' (
;!!( )
[## 	

MethodImpl##	 
(## 
MethodImplOptions## %
.##% &
AggressiveInlining##& 8
)##8 9
]##9 :
internal$$ 
static$$ 
int$$ 
GetInt$$ "
($$" #
byte$$# '
[$$' (
]$$( )
memory$$* 0
,$$0 1
int$$2 5
index$$6 ;
)$$; <
=>$$= ?
	unchecked%% 
(%% 
memory&& 
[&& 
index&& 
]&& 
<<&&  
$num&&! #
|&&$ %
memory'' 
['' 
index'' 
+'' 
$num''  
]''  !
<<''" $
$num''% '
|''( )
memory(( 
[(( 
index(( 
+(( 
$num((  
]((  !
<<((" $
$num((% &
|((' (
memory)) 
[)) 
index)) 
+)) 
$num))  
]))  !
)))! "
;))" #
[++ 	

MethodImpl++	 
(++ 
MethodImplOptions++ %
.++% &
AggressiveInlining++& 8
)++8 9
]++9 :
internal,, 
static,, 
int,, 
GetIntLE,, $
(,,$ %
byte,,% )
[,,) *
],,* +
memory,,, 2
,,,2 3
int,,4 7
index,,8 =
),,= >
=>,,? A
	unchecked-- 
(-- 
memory.. 
[.. 
index.. 
].. 
|.. 
memory// 
[// 
index// 
+// 
$num//  
]//  !
<<//" $
$num//% &
|//' (
memory00 
[00 
index00 
+00 
$num00  
]00  !
<<00" $
$num00% '
|00( )
memory11 
[11 
index11 
+11 
$num11  
]11  !
<<11" $
$num11% '
)11' (
;11( )
[33 	

MethodImpl33	 
(33 
MethodImplOptions33 %
.33% &
AggressiveInlining33& 8
)338 9
]339 :
internal44 
static44 
long44 
GetLong44 $
(44$ %
byte44% )
[44) *
]44* +
memory44, 2
,442 3
int444 7
index448 =
)44= >
=>44? A
	unchecked55 
(55 
(66 
long66 
)66 
memory66 
[66 
index66 "
]66" #
<<66$ &
$num66' )
|66* +
(77 
long77 
)77 
memory77 
[77 
index77 "
+77# $
$num77% &
]77& '
<<77( *
$num77+ -
|77. /
(88 
long88 
)88 
memory88 
[88 
index88 "
+88# $
$num88% &
]88& '
<<88( *
$num88+ -
|88. /
(99 
long99 
)99 
memory99 
[99 
index99 "
+99# $
$num99% &
]99& '
<<99( *
$num99+ -
|99. /
(:: 
long:: 
):: 
memory:: 
[:: 
index:: "
+::# $
$num::% &
]::& '
<<::( *
$num::+ -
|::. /
(;; 
long;; 
);; 
memory;; 
[;; 
index;; "
+;;# $
$num;;% &
];;& '
<<;;( *
$num;;+ -
|;;. /
(<< 
long<< 
)<< 
memory<< 
[<< 
index<< "
+<<# $
$num<<% &
]<<& '
<<<<( *
$num<<+ ,
|<<- .
memory== 
[== 
index== 
+== 
$num==  
]==  !
)==! "
;==" #
[?? 	

MethodImpl??	 
(?? 
MethodImplOptions?? %
.??% &
AggressiveInlining??& 8
)??8 9
]??9 :
internal@@ 
static@@ 
long@@ 
	GetLongLE@@ &
(@@& '
byte@@' +
[@@+ ,
]@@, -
memory@@. 4
,@@4 5
int@@6 9
index@@: ?
)@@? @
=>@@A C
	uncheckedAA 
(AA 
memoryBB 
[BB 
indexBB 
]BB 
|BB 
(CC 
longCC 
)CC 
memoryCC 
[CC 
indexCC "
+CC# $
$numCC% &
]CC& '
<<CC( *
$numCC+ ,
|CC- .
(DD 
longDD 
)DD 
memoryDD 
[DD 
indexDD "
+DD# $
$numDD% &
]DD& '
<<DD( *
$numDD+ -
|DD. /
(EE 
longEE 
)EE 
memoryEE 
[EE 
indexEE "
+EE# $
$numEE% &
]EE& '
<<EE( *
$numEE+ -
|EE. /
(FF 
longFF 
)FF 
memoryFF 
[FF 
indexFF "
+FF# $
$numFF% &
]FF& '
<<FF( *
$numFF+ -
|FF. /
(GG 
longGG 
)GG 
memoryGG 
[GG 
indexGG "
+GG# $
$numGG% &
]GG& '
<<GG( *
$numGG+ -
|GG. /
(HH 
longHH 
)HH 
memoryHH 
[HH 
indexHH "
+HH# $
$numHH% &
]HH& '
<<HH( *
$numHH+ -
|HH. /
(II 
longII 
)II 
memoryII 
[II 
indexII "
+II# $
$numII% &
]II& '
<<II( *
$numII+ -
)II- .
;II. /
[KK 	

MethodImplKK	 
(KK 
MethodImplOptionsKK %
.KK% &
AggressiveInliningKK& 8
)KK8 9
]KK9 :
internalLL 
staticLL 
voidLL 
SetByteLL $
(LL$ %
byteLL% )
[LL) *
]LL* +
memoryLL, 2
,LL2 3
intLL4 7
indexLL8 =
,LL= >
intLL? B
valueLLC H
)LLH I
{MM 	
	uncheckedNN 
{OO 
memoryPP 
[PP 
indexPP 
]PP 
=PP 
(PP  !
bytePP! %
)PP% &
valuePP& +
;PP+ ,
}QQ 
}RR 	
[TT 	

MethodImplTT	 
(TT 
MethodImplOptionsTT %
.TT% &
AggressiveInliningTT& 8
)TT8 9
]TT9 :
internalUU 
staticUU 
voidUU 
SetShortUU %
(UU% &
byteUU& *
[UU* +
]UU+ ,
memoryUU- 3
,UU3 4
intUU5 8
indexUU9 >
,UU> ?
intUU@ C
valueUUD I
)UUI J
{VV 	
	uncheckedWW 
{XX 
memoryYY 
[YY 
indexYY 
]YY 
=YY 
(YY  !
byteYY! %
)YY% &
(YY& '
(YY' (
ushortYY( .
)YY. /
valueYY/ 4
>>YY5 7
$numYY8 9
)YY9 :
;YY: ;
memoryZZ 
[ZZ 
indexZZ 
+ZZ 
$numZZ  
]ZZ  !
=ZZ" #
(ZZ$ %
byteZZ% )
)ZZ) *
valueZZ* /
;ZZ/ 0
}[[ 
}\\ 	
[^^ 	

MethodImpl^^	 
(^^ 
MethodImplOptions^^ %
.^^% &
AggressiveInlining^^& 8
)^^8 9
]^^9 :
internal__ 
static__ 
void__ 

SetShortLE__ '
(__' (
byte__( ,
[__, -
]__- .
memory__/ 5
,__5 6
int__7 :
index__; @
,__@ A
int__B E
value__F K
)__K L
{`` 	
	uncheckedaa 
{bb 
memorycc 
[cc 
indexcc 
]cc 
=cc 
(cc  !
bytecc! %
)cc% &
valuecc& +
;cc+ ,
memorydd 
[dd 
indexdd 
+dd 
$numdd  
]dd  !
=dd" #
(dd$ %
bytedd% )
)dd) *
(dd* +
(dd+ ,
ushortdd, 2
)dd2 3
valuedd3 8
>>dd9 ;
$numdd< =
)dd= >
;dd> ?
}ee 
}ff 	
[hh 	

MethodImplhh	 
(hh 
MethodImplOptionshh %
.hh% &
AggressiveInlininghh& 8
)hh8 9
]hh9 :
internalii 
staticii 
voidii 
	SetMediumii &
(ii& '
byteii' +
[ii+ ,
]ii, -
memoryii. 4
,ii4 5
intii6 9
indexii: ?
,ii? @
intiiA D
valueiiE J
)iiJ K
{jj 	
	uncheckedkk 
{ll 
uintmm 
unsignedValuemm "
=mm# $
(mm% &
uintmm& *
)mm* +
valuemm+ 0
;mm0 1
memorynn 
[nn 
indexnn 
]nn 
=nn 
(nn  !
bytenn! %
)nn% &
(nn& '
unsignedValuenn' 4
>>nn5 7
$numnn8 :
)nn: ;
;nn; <
memoryoo 
[oo 
indexoo 
+oo 
$numoo  
]oo  !
=oo" #
(oo$ %
byteoo% )
)oo) *
(oo* +
unsignedValueoo+ 8
>>oo9 ;
$numoo< =
)oo= >
;oo> ?
memorypp 
[pp 
indexpp 
+pp 
$numpp  
]pp  !
=pp" #
(pp$ %
bytepp% )
)pp) *
unsignedValuepp* 7
;pp7 8
}qq 
}rr 	
[tt 	

MethodImpltt	 
(tt 
MethodImplOptionstt %
.tt% &
AggressiveInliningtt& 8
)tt8 9
]tt9 :
internaluu 
staticuu 
voiduu 
SetMediumLEuu (
(uu( )
byteuu) -
[uu- .
]uu. /
memoryuu0 6
,uu6 7
intuu8 ;
indexuu< A
,uuA B
intuuC F
valueuuG L
)uuL M
{vv 	
	uncheckedww 
{xx 
uintyy 
unsignedValueyy "
=yy# $
(yy% &
uintyy& *
)yy* +
valueyy+ 0
;yy0 1
memoryzz 
[zz 
indexzz 
]zz 
=zz 
(zz  !
bytezz! %
)zz% &
unsignedValuezz& 3
;zz3 4
memory{{ 
[{{ 
index{{ 
+{{ 
$num{{  
]{{  !
={{" #
({{$ %
byte{{% )
){{) *
({{* +
unsignedValue{{+ 8
>>{{9 ;
$num{{< =
){{= >
;{{> ?
memory|| 
[|| 
index|| 
+|| 
$num||  
]||  !
=||" #
(||$ %
byte||% )
)||) *
(||* +
unsignedValue||+ 8
>>||9 ;
$num||< >
)||> ?
;||? @
}}} 
}~~ 	
[
€€ 	

MethodImpl
€€	 
(
€€ 
MethodImplOptions
€€ %
.
€€% & 
AggressiveInlining
€€& 8
)
€€8 9
]
€€9 :
internal
 
static
 
void
 
SetInt
 #
(
# $
byte
$ (
[
( )
]
) *
memory
+ 1
,
1 2
int
3 6
index
7 <
,
< =
int
> A
value
B G
)
G H
{
‚‚ 	
	unchecked
ƒƒ 
{
„„ 
uint
…… 
unsignedValue
…… "
=
……# $
(
……% &
uint
……& *
)
……* +
value
……+ 0
;
……0 1
memory
†† 
[
†† 
index
†† 
]
†† 
=
†† 
(
††  !
byte
††! %
)
††% &
(
††& '
unsignedValue
††' 4
>>
††5 7
$num
††8 :
)
††: ;
;
††; <
memory
‡‡ 
[
‡‡ 
index
‡‡ 
+
‡‡ 
$num
‡‡  
]
‡‡  !
=
‡‡" #
(
‡‡$ %
byte
‡‡% )
)
‡‡) *
(
‡‡* +
unsignedValue
‡‡+ 8
>>
‡‡9 ;
$num
‡‡< >
)
‡‡> ?
;
‡‡? @
memory
ˆˆ 
[
ˆˆ 
index
ˆˆ 
+
ˆˆ 
$num
ˆˆ  
]
ˆˆ  !
=
ˆˆ" #
(
ˆˆ$ %
byte
ˆˆ% )
)
ˆˆ) *
(
ˆˆ* +
unsignedValue
ˆˆ+ 8
>>
ˆˆ9 ;
$num
ˆˆ; <
)
ˆˆ< =
;
ˆˆ= >
memory
‰‰ 
[
‰‰ 
index
‰‰ 
+
‰‰ 
$num
‰‰  
]
‰‰  !
=
‰‰" #
(
‰‰$ %
byte
‰‰% )
)
‰‰) *
unsignedValue
‰‰* 7
;
‰‰7 8
}
ŠŠ 
}
‹‹ 	
[
 	

MethodImpl
	 
(
 
MethodImplOptions
 %
.
% & 
AggressiveInlining
& 8
)
8 9
]
9 :
internal
 
static
 
void
 
SetIntLE
 %
(
% &
byte
& *
[
* +
]
+ ,
memory
- 3
,
3 4
int
5 8
index
9 >
,
> ?
int
@ C
value
D I
)
I J
{
 	
	unchecked
 
{
‘‘ 
uint
’’ 
unsignedValue
’’ "
=
’’# $
(
’’% &
uint
’’& *
)
’’* +
value
’’+ 0
;
’’0 1
memory
““ 
[
““ 
index
““ 
]
““ 
=
““ 
(
““  !
byte
““! %
)
““% &
unsignedValue
““& 3
;
““3 4
memory
”” 
[
”” 
index
”” 
+
”” 
$num
””  
]
””  !
=
””" #
(
””$ %
byte
””% )
)
””) *
(
””* +
unsignedValue
””+ 8
>>
””9 ;
$num
””< =
)
””= >
;
””> ?
memory
•• 
[
•• 
index
•• 
+
•• 
$num
••  
]
••  !
=
••" #
(
••$ %
byte
••% )
)
••) *
(
••* +
unsignedValue
••+ 8
>>
••9 ;
$num
••< >
)
••> ?
;
••? @
memory
–– 
[
–– 
index
–– 
+
–– 
$num
––  
]
––  !
=
––" #
(
––$ %
byte
––% )
)
––) *
(
––* +
unsignedValue
––+ 8
>>
––9 ;
$num
––< >
)
––> ?
;
––? @
}
—— 
}
˜˜ 	
[
šš 	

MethodImpl
šš	 
(
šš 
MethodImplOptions
šš %
.
šš% & 
AggressiveInlining
šš& 8
)
šš8 9
]
šš9 :
internal
›› 
static
›› 
void
›› 
SetLong
›› $
(
››$ %
byte
››% )
[
››) *
]
››* +
memory
››, 2
,
››2 3
int
››4 7
index
››8 =
,
››= >
long
››? C
value
››D I
)
››I J
{
œœ 	
	unchecked
 
{
 
ulong
ŸŸ 
unsignedValue
ŸŸ #
=
ŸŸ$ %
(
ŸŸ& '
ulong
ŸŸ' ,
)
ŸŸ, -
value
ŸŸ- 2
;
ŸŸ2 3
memory
   
[
   
index
   
]
   
=
   
(
    !
byte
  ! %
)
  % &
(
  & '
unsignedValue
  ' 4
>>
  5 7
$num
  8 :
)
  : ;
;
  ; <
memory
¡¡ 
[
¡¡ 
index
¡¡ 
+
¡¡ 
$num
¡¡  
]
¡¡  !
=
¡¡" #
(
¡¡$ %
byte
¡¡% )
)
¡¡) *
(
¡¡* +
unsignedValue
¡¡+ 8
>>
¡¡9 ;
$num
¡¡< >
)
¡¡> ?
;
¡¡? @
memory
¢¢ 
[
¢¢ 
index
¢¢ 
+
¢¢ 
$num
¢¢  
]
¢¢  !
=
¢¢" #
(
¢¢$ %
byte
¢¢% )
)
¢¢) *
(
¢¢* +
unsignedValue
¢¢+ 8
>>
¢¢9 ;
$num
¢¢< >
)
¢¢> ?
;
¢¢? @
memory
££ 
[
££ 
index
££ 
+
££ 
$num
££  
]
££  !
=
££" #
(
££$ %
byte
££% )
)
££) *
(
££* +
unsignedValue
££+ 8
>>
££9 ;
$num
££< >
)
££> ?
;
££? @
memory
¤¤ 
[
¤¤ 
index
¤¤ 
+
¤¤ 
$num
¤¤  
]
¤¤  !
=
¤¤" #
(
¤¤$ %
byte
¤¤% )
)
¤¤) *
(
¤¤* +
unsignedValue
¤¤+ 8
>>
¤¤9 ;
$num
¤¤< >
)
¤¤> ?
;
¤¤? @
memory
¥¥ 
[
¥¥ 
index
¥¥ 
+
¥¥ 
$num
¥¥  
]
¥¥  !
=
¥¥" #
(
¥¥$ %
byte
¥¥% )
)
¥¥) *
(
¥¥* +
unsignedValue
¥¥+ 8
>>
¥¥9 ;
$num
¥¥< >
)
¥¥> ?
;
¥¥? @
memory
¦¦ 
[
¦¦ 
index
¦¦ 
+
¦¦ 
$num
¦¦  
]
¦¦  !
=
¦¦" #
(
¦¦$ %
byte
¦¦% )
)
¦¦) *
(
¦¦* +
unsignedValue
¦¦+ 8
>>
¦¦9 ;
$num
¦¦< =
)
¦¦= >
;
¦¦> ?
memory
§§ 
[
§§ 
index
§§ 
+
§§ 
$num
§§  
]
§§  !
=
§§" #
(
§§$ %
byte
§§% )
)
§§) *
unsignedValue
§§* 7
;
§§7 8
}
¨¨ 
}
©© 	
[
«« 	

MethodImpl
««	 
(
«« 
MethodImplOptions
«« %
.
««% & 
AggressiveInlining
««& 8
)
««8 9
]
««9 :
internal
¬¬ 
static
¬¬ 
void
¬¬ 
	SetLongLE
¬¬ &
(
¬¬& '
byte
¬¬' +
[
¬¬+ ,
]
¬¬, -
memory
¬¬. 4
,
¬¬4 5
int
¬¬6 9
index
¬¬: ?
,
¬¬? @
long
¬¬A E
value
¬¬F K
)
¬¬K L
{
­­ 	
	unchecked
®® 
{
¯¯ 
ulong
°° 
unsignedValue
°° #
=
°°$ %
(
°°& '
ulong
°°' ,
)
°°, -
value
°°- 2
;
°°2 3
memory
±± 
[
±± 
index
±± 
]
±± 
=
±± 
(
±±  !
byte
±±! %
)
±±% &
unsignedValue
±±& 3
;
±±3 4
memory
²² 
[
²² 
index
²² 
+
²² 
$num
²²  
]
²²  !
=
²²" #
(
²²$ %
byte
²²% )
)
²²) *
(
²²* +
unsignedValue
²²+ 8
>>
²²9 ;
$num
²²< =
)
²²= >
;
²²> ?
memory
³³ 
[
³³ 
index
³³ 
+
³³ 
$num
³³  
]
³³  !
=
³³" #
(
³³$ %
byte
³³% )
)
³³) *
(
³³* +
unsignedValue
³³+ 8
>>
³³9 ;
$num
³³< >
)
³³> ?
;
³³? @
memory
´´ 
[
´´ 
index
´´ 
+
´´ 
$num
´´  
]
´´  !
=
´´" #
(
´´$ %
byte
´´% )
)
´´) *
(
´´* +
unsignedValue
´´+ 8
>>
´´9 ;
$num
´´< >
)
´´> ?
;
´´? @
memory
µµ 
[
µµ 
index
µµ 
+
µµ 
$num
µµ  
]
µµ  !
=
µµ" #
(
µµ$ %
byte
µµ% )
)
µµ) *
(
µµ* +
unsignedValue
µµ+ 8
>>
µµ9 ;
$num
µµ< >
)
µµ> ?
;
µµ? @
memory
¶¶ 
[
¶¶ 
index
¶¶ 
+
¶¶ 
$num
¶¶  
]
¶¶  !
=
¶¶" #
(
¶¶$ %
byte
¶¶% )
)
¶¶) *
(
¶¶* +
unsignedValue
¶¶+ 8
>>
¶¶9 ;
$num
¶¶< >
)
¶¶> ?
;
¶¶? @
memory
·· 
[
·· 
index
·· 
+
·· 
$num
··  
]
··  !
=
··" #
(
··$ %
byte
··% )
)
··) *
(
··* +
unsignedValue
··+ 8
>>
··9 ;
$num
··< >
)
··> ?
;
··? @
memory
¸¸ 
[
¸¸ 
index
¸¸ 
+
¸¸ 
$num
¸¸  
]
¸¸  !
=
¸¸" #
(
¸¸$ %
byte
¸¸% )
)
¸¸) *
(
¸¸* +
unsignedValue
¸¸+ 8
>>
¸¸9 ;
$num
¸¸< >
)
¸¸> ?
;
¸¸? @
}
¹¹ 
}
ºº 	
}
»» 
}¼¼ å
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IByteBuffer  
:! "
IReferenceCounted# 4
,4 5
IComparable6 A
<A B
IByteBufferB M
>M N
,N O

IEquatableP Z
<Z [
IByteBuffer[ f
>f g
{ 
int 
Capacity 
{ 
get 
; 
} 
IByteBuffer 
AdjustCapacity "
(" #
int# &
newCapacity' 2
)2 3
;3 4
int 
MaxCapacity 
{ 
get 
; 
}   
IByteBufferAllocator$$ 
	Allocator$$ &
{$$' (
get$$) ,
;$$, -
}$$. /
bool&& 
IsDirect&& 
{&& 
get&& 
;&& 
}&& 
int(( 
ReaderIndex(( 
{(( 
get(( 
;(( 
}((  
int** 
WriterIndex** 
{** 
get** 
;** 
}**  
IByteBuffer00 
SetWriterIndex00 "
(00" #
int00# &
writerIndex00' 2
)002 3
;003 4
IByteBuffer99 
SetReaderIndex99 "
(99" #
int99# &
readerIndex99' 2
)992 3
;993 4
IByteBufferBB 
SetIndexBB 
(BB 
intBB  
readerIndexBB! ,
,BB, -
intBB. 1
writerIndexBB2 =
)BB= >
;BB> ?
intDD 
ReadableBytesDD 
{DD 
getDD 
;DD  
}DD! "
intFF 
WritableBytesFF 
{FF 
getFF 
;FF  
}FF! "
intHH 
MaxWritableBytesHH 
{HH 
getHH "
;HH" #
}HH$ %
boolMM 

IsReadableMM 
(MM 
)MM 
;MM 
boolSS 

IsReadableSS 
(SS 
intSS 
sizeSS  
)SS  !
;SS! "
boolXX 

IsWritableXX 
(XX 
)XX 
;XX 
bool__ 

IsWritable__ 
(__ 
int__ 
size__  
)__  !
;__! "
IByteBufferff 
Clearff 
(ff 
)ff 
;ff 
IByteBuffernn 
MarkReaderIndexnn #
(nn# $
)nn$ %
;nn% &
IByteBufferww 
ResetReaderIndexww $
(ww$ %
)ww% &
;ww& '
IByteBuffer 
MarkWriterIndex #
(# $
)$ %
;% &
IByteBuffer
ˆˆ 
ResetWriterIndex
ˆˆ $
(
ˆˆ$ %
)
ˆˆ% &
;
ˆˆ& '
IByteBuffer
 
DiscardReadBytes
 $
(
$ %
)
% &
;
& '
IByteBuffer
˜˜ "
DiscardSomeReadBytes
˜˜ (
(
˜˜( )
)
˜˜) *
;
˜˜* +
IByteBuffer
¤¤ 
EnsureWritable
¤¤ "
(
¤¤" #
int
¤¤# &
minWritableBytes
¤¤' 7
)
¤¤7 8
;
¤¤8 9
int
¹¹ 
EnsureWritable
¹¹ 
(
¹¹ 
int
¹¹ 
minWritableBytes
¹¹ /
,
¹¹/ 0
bool
¹¹1 5
force
¹¹6 ;
)
¹¹; <
;
¹¹< =
bool
ÄÄ 

GetBoolean
ÄÄ 
(
ÄÄ 
int
ÄÄ 
index
ÄÄ !
)
ÄÄ! "
;
ÄÄ" #
byte
ÏÏ 
GetByte
ÏÏ 
(
ÏÏ 
int
ÏÏ 
index
ÏÏ 
)
ÏÏ 
;
ÏÏ  
short
ÚÚ 
GetShort
ÚÚ 
(
ÚÚ 
int
ÚÚ 
index
ÚÚ  
)
ÚÚ  !
;
ÚÚ! "
short
åå 

GetShortLE
åå 
(
åå 
int
åå 
index
åå "
)
åå" #
;
åå# $
ushort
ğğ 
GetUnsignedShort
ğğ 
(
ğğ  
int
ğğ  #
index
ğğ$ )
)
ğğ) *
;
ğğ* +
ushort
ûû  
GetUnsignedShortLE
ûû !
(
ûû! "
int
ûû" %
index
ûû& +
)
ûû+ ,
;
ûû, -
int
†† 
GetInt
†† 
(
†† 
int
†† 
index
†† 
)
†† 
;
†† 
int
‘‘ 
GetIntLE
‘‘ 
(
‘‘ 
int
‘‘ 
index
‘‘ 
)
‘‘ 
;
‘‘  
uint
œœ 
GetUnsignedInt
œœ 
(
œœ 
int
œœ 
index
œœ  %
)
œœ% &
;
œœ& '
uint
§§ 
GetUnsignedIntLE
§§ 
(
§§ 
int
§§ !
index
§§" '
)
§§' (
;
§§( )
long
²² 
GetLong
²² 
(
²² 
int
²² 
index
²² 
)
²² 
;
²²  
long
½½ 
	GetLongLE
½½ 
(
½½ 
int
½½ 
index
½½  
)
½½  !
;
½½! "
int
ÈÈ 
	GetMedium
ÈÈ 
(
ÈÈ 
int
ÈÈ 
index
ÈÈ 
)
ÈÈ  
;
ÈÈ  !
int
ÓÓ 
GetMediumLE
ÓÓ 
(
ÓÓ 
int
ÓÓ 
index
ÓÓ !
)
ÓÓ! "
;
ÓÓ" #
int
ŞŞ 
GetUnsignedMedium
ŞŞ 
(
ŞŞ 
int
ŞŞ !
index
ŞŞ" '
)
ŞŞ' (
;
ŞŞ( )
int
éé !
GetUnsignedMediumLE
éé 
(
éé  
int
éé  #
index
éé$ )
)
éé) *
;
éé* +
char
ôô 
GetChar
ôô 
(
ôô 
int
ôô 
index
ôô 
)
ôô 
;
ôô  
float
ÿÿ 
GetFloat
ÿÿ 
(
ÿÿ 
int
ÿÿ 
index
ÿÿ  
)
ÿÿ  !
;
ÿÿ! "
float
ŠŠ 

GetFloatLE
ŠŠ 
(
ŠŠ 
int
ŠŠ 
index
ŠŠ "
)
ŠŠ" #
;
ŠŠ# $
double
•• 
	GetDouble
•• 
(
•• 
int
•• 
index
•• "
)
••" #
;
••# $
double
   
GetDoubleLE
   
(
   
int
   
index
   $
)
  $ %
;
  % &
IByteBuffer
ªª 
GetBytes
ªª 
(
ªª 
int
ªª  
index
ªª! &
,
ªª& '
IByteBuffer
ªª( 3
destination
ªª4 ?
)
ªª? @
;
ªª@ A
IByteBuffer
´´ 
GetBytes
´´ 
(
´´ 
int
´´  
index
´´! &
,
´´& '
IByteBuffer
´´( 3
destination
´´4 ?
,
´´? @
int
´´A D
length
´´E K
)
´´K L
;
´´L M
IByteBuffer
¾¾ 
GetBytes
¾¾ 
(
¾¾ 
int
¾¾  
index
¾¾! &
,
¾¾& '
IByteBuffer
¾¾( 3
destination
¾¾4 ?
,
¾¾? @
int
¾¾A D
dstIndex
¾¾E M
,
¾¾M N
int
¾¾O R
length
¾¾S Y
)
¾¾Y Z
;
¾¾Z [
IByteBuffer
ÈÈ 
GetBytes
ÈÈ 
(
ÈÈ 
int
ÈÈ  
index
ÈÈ! &
,
ÈÈ& '
byte
ÈÈ( ,
[
ÈÈ, -
]
ÈÈ- .
destination
ÈÈ/ :
)
ÈÈ: ;
;
ÈÈ; <
IByteBuffer
ÒÒ 
GetBytes
ÒÒ 
(
ÒÒ 
int
ÒÒ  
index
ÒÒ! &
,
ÒÒ& '
byte
ÒÒ( ,
[
ÒÒ, -
]
ÒÒ- .
destination
ÒÒ/ :
,
ÒÒ: ;
int
ÒÒ< ?
dstIndex
ÒÒ@ H
,
ÒÒH I
int
ÒÒJ M
length
ÒÒN T
)
ÒÒT U
;
ÒÒU V
IByteBuffer
ää 
GetBytes
ää 
(
ää 
int
ää  
index
ää! &
,
ää& '
Stream
ää( .
destination
ää/ :
,
ää: ;
int
ää< ?
length
ää@ F
)
ääF G
;
ääG H
ICharSequence
çç 
GetCharSequence
çç %
(
çç% &
int
çç& )
index
çç* /
,
çç/ 0
int
çç1 4
length
çç5 ;
,
çç; <
Encoding
çç= E
encoding
ççF N
)
ççN O
;
ççO P
string
óó 
	GetString
óó 
(
óó 
int
óó 
index
óó "
,
óó" #
int
óó$ '
length
óó( .
,
óó. /
Encoding
óó0 8
encoding
óó9 A
)
óóA B
;
óóB C
IByteBuffer
ıı 

SetBoolean
ıı 
(
ıı 
int
ıı "
index
ıı# (
,
ıı( )
bool
ıı* .
value
ıı/ 4
)
ıı4 5
;
ıı5 6
IByteBuffer
‡‡ 
SetByte
‡‡ 
(
‡‡ 
int
‡‡ 
index
‡‡  %
,
‡‡% &
int
‡‡' *
value
‡‡+ 0
)
‡‡0 1
;
‡‡1 2
IByteBuffer
‘‘ 
SetShort
‘‘ 
(
‘‘ 
int
‘‘  
index
‘‘! &
,
‘‘& '
int
‘‘( +
value
‘‘, 1
)
‘‘1 2
;
‘‘2 3
IByteBuffer
œœ 

SetShortLE
œœ 
(
œœ 
int
œœ "
index
œœ# (
,
œœ( )
int
œœ* -
value
œœ. 3
)
œœ3 4
;
œœ4 5
IByteBuffer
¦¦ 
SetUnsignedShort
¦¦ $
(
¦¦$ %
int
¦¦% (
index
¦¦) .
,
¦¦. /
ushort
¦¦0 6
value
¦¦7 <
)
¦¦< =
;
¦¦= >
IByteBuffer
±±  
SetUnsignedShortLE
±± &
(
±±& '
int
±±' *
index
±±+ 0
,
±±0 1
ushort
±±2 8
value
±±9 >
)
±±> ?
;
±±? @
IByteBuffer
»» 
SetInt
»» 
(
»» 
int
»» 
index
»» $
,
»»$ %
int
»»& )
value
»»* /
)
»»/ 0
;
»»0 1
IByteBuffer
ÆÆ 
SetIntLE
ÆÆ 
(
ÆÆ 
int
ÆÆ  
index
ÆÆ! &
,
ÆÆ& '
int
ÆÆ( +
value
ÆÆ, 1
)
ÆÆ1 2
;
ÆÆ2 3
IByteBuffer
ĞĞ 
SetUnsignedInt
ĞĞ "
(
ĞĞ" #
int
ĞĞ# &
index
ĞĞ' ,
,
ĞĞ, -
uint
ĞĞ. 2
value
ĞĞ3 8
)
ĞĞ8 9
;
ĞĞ9 :
IByteBuffer
ÛÛ 
SetUnsignedIntLE
ÛÛ $
(
ÛÛ$ %
int
ÛÛ% (
index
ÛÛ) .
,
ÛÛ. /
uint
ÛÛ0 4
value
ÛÛ5 :
)
ÛÛ: ;
;
ÛÛ; <
IByteBuffer
ææ 
	SetMedium
ææ 
(
ææ 
int
ææ !
index
ææ" '
,
ææ' (
int
ææ) ,
value
ææ- 2
)
ææ2 3
;
ææ3 4
IByteBuffer
ññ 
SetMediumLE
ññ 
(
ññ  
int
ññ  #
index
ññ$ )
,
ññ) *
int
ññ+ .
value
ññ/ 4
)
ññ4 5
;
ññ5 6
IByteBuffer
ûû 
SetLong
ûû 
(
ûû 
int
ûû 
index
ûû  %
,
ûû% &
long
ûû' +
value
ûû, 1
)
ûû1 2
;
ûû2 3
IByteBuffer
†† 
	SetLongLE
†† 
(
†† 
int
†† !
index
††" '
,
††' (
long
††) -
value
††. 3
)
††3 4
;
††4 5
IByteBuffer
 
SetChar
 
(
 
int
 
index
  %
,
% &
char
' +
value
, 1
)
1 2
;
2 3
IByteBuffer
šš 
	SetDouble
šš 
(
šš 
int
šš !
index
šš" '
,
šš' (
double
šš) /
value
šš0 5
)
šš5 6
;
šš6 7
IByteBuffer
¤¤ 
SetFloat
¤¤ 
(
¤¤ 
int
¤¤  
index
¤¤! &
,
¤¤& '
float
¤¤( -
value
¤¤. 3
)
¤¤3 4
;
¤¤4 5
IByteBuffer
¯¯ 
SetDoubleLE
¯¯ 
(
¯¯  
int
¯¯  #
index
¯¯$ )
,
¯¯) *
double
¯¯+ 1
value
¯¯2 7
)
¯¯7 8
;
¯¯8 9
IByteBuffer
ºº 

SetFloatLE
ºº 
(
ºº 
int
ºº "
index
ºº# (
,
ºº( )
float
ºº* /
value
ºº0 5
)
ºº5 6
;
ºº6 7
IByteBuffer
ÄÄ 
SetBytes
ÄÄ 
(
ÄÄ 
int
ÄÄ  
index
ÄÄ! &
,
ÄÄ& '
IByteBuffer
ÄÄ( 3
src
ÄÄ4 7
)
ÄÄ7 8
;
ÄÄ8 9
IByteBuffer
ÏÏ 
SetBytes
ÏÏ 
(
ÏÏ 
int
ÏÏ  
index
ÏÏ! &
,
ÏÏ& '
IByteBuffer
ÏÏ( 3
src
ÏÏ4 7
,
ÏÏ7 8
int
ÏÏ9 <
length
ÏÏ= C
)
ÏÏC D
;
ÏÏD E
IByteBuffer
ÜÜ 
SetBytes
ÜÜ 
(
ÜÜ 
int
ÜÜ  
index
ÜÜ! &
,
ÜÜ& '
IByteBuffer
ÜÜ( 3
src
ÜÜ4 7
,
ÜÜ7 8
int
ÜÜ9 <
srcIndex
ÜÜ= E
,
ÜÜE F
int
ÜÜG J
length
ÜÜK Q
)
ÜÜQ R
;
ÜÜR S
IByteBuffer
ææ 
SetBytes
ææ 
(
ææ 
int
ææ  
index
ææ! &
,
ææ& '
byte
ææ( ,
[
ææ, -
]
ææ- .
src
ææ/ 2
)
ææ2 3
;
ææ3 4
IByteBuffer
óó 
SetBytes
óó 
(
óó 
int
óó  
index
óó! &
,
óó& '
byte
óó( ,
[
óó, -
]
óó- .
src
óó/ 2
,
óó2 3
int
óó4 7
srcIndex
óó8 @
,
óó@ A
int
óóB E
length
óóF L
)
óóL M
;
óóM N
Task
„„ 
<
„„ 
int
„„ 
>
„„ 
SetBytesAsync
„„ 
(
„„  
int
„„  #
index
„„$ )
,
„„) *
Stream
„„+ 1
src
„„2 5
,
„„5 6
int
„„7 :
length
„„; A
,
„„A B
CancellationToken
„„C T
cancellationToken
„„U f
)
„„f g
;
„„g h
IByteBuffer
‘‘ 
SetZero
‘‘ 
(
‘‘ 
int
‘‘ 
index
‘‘  %
,
‘‘% &
int
‘‘' *
length
‘‘+ 1
)
‘‘1 2
;
‘‘2 3
int
““ 
SetCharSequence
““ 
(
““ 
int
““ 
index
““  %
,
““% &
ICharSequence
““' 4
sequence
““5 =
,
““= >
Encoding
““? G
encoding
““H P
)
““P Q
;
““Q R
int
   
	SetString
   
(
   
int
   
index
   
,
    
string
  ! '
value
  ( -
,
  - .
Encoding
  / 7
encoding
  8 @
)
  @ A
;
  A B
bool
§§ 
ReadBoolean
§§ 
(
§§ 
)
§§ 
;
§§ 
byte
®® 
ReadByte
®® 
(
®® 
)
®® 
;
®® 
short
µµ 
	ReadShort
µµ 
(
µµ 
)
µµ 
;
µµ 
short
¼¼ 
ReadShortLE
¼¼ 
(
¼¼ 
)
¼¼ 
;
¼¼ 
int
ÃÃ 

ReadMedium
ÃÃ 
(
ÃÃ 
)
ÃÃ 
;
ÃÃ 
int
ÊÊ 
ReadMediumLE
ÊÊ 
(
ÊÊ 
)
ÊÊ 
;
ÊÊ 
int
ÑÑ  
ReadUnsignedMedium
ÑÑ 
(
ÑÑ 
)
ÑÑ  
;
ÑÑ  !
int
ØØ "
ReadUnsignedMediumLE
ØØ  
(
ØØ  !
)
ØØ! "
;
ØØ" #
ushort
ßß 
ReadUnsignedShort
ßß  
(
ßß  !
)
ßß! "
;
ßß" #
ushort
ææ !
ReadUnsignedShortLE
ææ "
(
ææ" #
)
ææ# $
;
ææ$ %
int
íí 
ReadInt
íí 
(
íí 
)
íí 
;
íí 
int
ôô 
	ReadIntLE
ôô 
(
ôô 
)
ôô 
;
ôô 
uint
ûû 
ReadUnsignedInt
ûû 
(
ûû 
)
ûû 
;
ûû 
uint
‚‚ 
ReadUnsignedIntLE
‚‚ 
(
‚‚ 
)
‚‚  
;
‚‚  !
long
‰‰ 
ReadLong
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰ 
long
 

ReadLongLE
 
(
 
)
 
;
 
char
˜˜ 
ReadChar
˜˜ 
(
˜˜ 
)
˜˜ 
;
˜˜ 
double
   

ReadDouble
   
(
   
)
   
;
   
double
§§ 
ReadDoubleLE
§§ 
(
§§ 
)
§§ 
;
§§ 
float
¯¯ 
	ReadFloat
¯¯ 
(
¯¯ 
)
¯¯ 
;
¯¯ 
float
¶¶ 
ReadFloatLE
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶ 
IByteBuffer
¾¾ 
	ReadBytes
¾¾ 
(
¾¾ 
int
¾¾ !
length
¾¾" (
)
¾¾( )
;
¾¾) *
IByteBuffer
ÉÉ 
	ReadBytes
ÉÉ 
(
ÉÉ 
IByteBuffer
ÉÉ )
destination
ÉÉ* 5
)
ÉÉ5 6
;
ÉÉ6 7
IByteBuffer
ËË 
	ReadBytes
ËË 
(
ËË 
IByteBuffer
ËË )
destination
ËË* 5
,
ËË5 6
int
ËË7 :
length
ËË; A
)
ËËA B
;
ËËB C
IByteBuffer
ÍÍ 
	ReadBytes
ÍÍ 
(
ÍÍ 
IByteBuffer
ÍÍ )
destination
ÍÍ* 5
,
ÍÍ5 6
int
ÍÍ7 :
dstIndex
ÍÍ; C
,
ÍÍC D
int
ÍÍE H
length
ÍÍI O
)
ÍÍO P
;
ÍÍP Q
IByteBuffer
ÏÏ 
	ReadBytes
ÏÏ 
(
ÏÏ 
byte
ÏÏ "
[
ÏÏ" #
]
ÏÏ# $
destination
ÏÏ% 0
)
ÏÏ0 1
;
ÏÏ1 2
IByteBuffer
ÑÑ 
	ReadBytes
ÑÑ 
(
ÑÑ 
byte
ÑÑ "
[
ÑÑ" #
]
ÑÑ# $
destination
ÑÑ% 0
,
ÑÑ0 1
int
ÑÑ2 5
dstIndex
ÑÑ6 >
,
ÑÑ> ?
int
ÑÑ@ C
length
ÑÑD J
)
ÑÑJ K
;
ÑÑK L
IByteBuffer
ÓÓ 
	ReadBytes
ÓÓ 
(
ÓÓ 
Stream
ÓÓ $
destination
ÓÓ% 0
,
ÓÓ0 1
int
ÓÓ2 5
length
ÓÓ6 <
)
ÓÓ< =
;
ÓÓ= >
ICharSequence
ÕÕ 
ReadCharSequence
ÕÕ &
(
ÕÕ& '
int
ÕÕ' *
length
ÕÕ+ 1
,
ÕÕ1 2
Encoding
ÕÕ3 ;
encoding
ÕÕ< D
)
ÕÕD E
;
ÕÕE F
string
ŞŞ 

ReadString
ŞŞ 
(
ŞŞ 
int
ŞŞ 
length
ŞŞ $
,
ŞŞ$ %
Encoding
ŞŞ& .
encoding
ŞŞ/ 7
)
ŞŞ7 8
;
ŞŞ8 9
IByteBuffer
ää 
	SkipBytes
ää 
(
ää 
int
ää !
length
ää" (
)
ää( )
;
ää) *
IByteBuffer
ææ 
WriteBoolean
ææ  
(
ææ  !
bool
ææ! %
value
ææ& +
)
ææ+ ,
;
ææ, -
IByteBuffer
èè 
	WriteByte
èè 
(
èè 
int
èè !
value
èè" '
)
èè' (
;
èè( )
IByteBuffer
êê 

WriteShort
êê 
(
êê 
int
êê "
value
êê# (
)
êê( )
;
êê) *
IByteBuffer
ìì 
WriteShortLE
ìì  
(
ìì  !
int
ìì! $
value
ìì% *
)
ìì* +
;
ìì+ ,
IByteBuffer
îî  
WriteUnsignedShort
îî &
(
îî& '
ushort
îî' -
value
îî. 3
)
îî3 4
;
îî4 5
IByteBuffer
ğğ "
WriteUnsignedShortLE
ğğ (
(
ğğ( )
ushort
ğğ) /
value
ğğ0 5
)
ğğ5 6
;
ğğ6 7
IByteBuffer
òò 
WriteMedium
òò 
(
òò  
int
òò  #
value
òò$ )
)
òò) *
;
òò* +
IByteBuffer
ôô 
WriteMediumLE
ôô !
(
ôô! "
int
ôô" %
value
ôô& +
)
ôô+ ,
;
ôô, -
IByteBuffer
öö 
WriteInt
öö 
(
öö 
int
öö  
value
öö! &
)
öö& '
;
öö' (
IByteBuffer
øø 

WriteIntLE
øø 
(
øø 
int
øø "
value
øø# (
)
øø( )
;
øø) *
IByteBuffer
úú 
	WriteLong
úú 
(
úú 
long
úú "
value
úú# (
)
úú( )
;
úú) *
IByteBuffer
üü 
WriteLongLE
üü 
(
üü  
long
üü  $
value
üü% *
)
üü* +
;
üü+ ,
IByteBuffer
şş 
	WriteChar
şş 
(
şş 
char
şş "
value
şş# (
)
şş( )
;
şş) *
IByteBuffer
€€ 
WriteDouble
€€ 
(
€€  
double
€€  &
value
€€' ,
)
€€, -
;
€€- .
IByteBuffer
‚‚ 
WriteDoubleLE
‚‚ !
(
‚‚! "
double
‚‚" (
value
‚‚) .
)
‚‚. /
;
‚‚/ 0
IByteBuffer
„„ 

WriteFloat
„„ 
(
„„ 
float
„„ $
value
„„% *
)
„„* +
;
„„+ ,
IByteBuffer
†† 
WriteFloatLE
††  
(
††  !
float
††! &
value
††' ,
)
††, -
;
††- .
IByteBuffer
ˆˆ 

WriteBytes
ˆˆ 
(
ˆˆ 
IByteBuffer
ˆˆ *
src
ˆˆ+ .
)
ˆˆ. /
;
ˆˆ/ 0
IByteBuffer
ŠŠ 

WriteBytes
ŠŠ 
(
ŠŠ 
IByteBuffer
ŠŠ *
src
ŠŠ+ .
,
ŠŠ. /
int
ŠŠ0 3
length
ŠŠ4 :
)
ŠŠ: ;
;
ŠŠ; <
IByteBuffer
ŒŒ 

WriteBytes
ŒŒ 
(
ŒŒ 
IByteBuffer
ŒŒ *
src
ŒŒ+ .
,
ŒŒ. /
int
ŒŒ0 3
srcIndex
ŒŒ4 <
,
ŒŒ< =
int
ŒŒ> A
length
ŒŒB H
)
ŒŒH I
;
ŒŒI J
IByteBuffer
 

WriteBytes
 
(
 
byte
 #
[
# $
]
$ %
src
& )
)
) *
;
* +
IByteBuffer
 

WriteBytes
 
(
 
byte
 #
[
# $
]
$ %
src
& )
,
) *
int
+ .
srcIndex
/ 7
,
7 8
int
9 <
length
= C
)
C D
;
D E
int
¡¡ 
IoBufferCount
¡¡ 
{
¡¡ 
get
¡¡ 
;
¡¡  
}
¡¡! "
ArraySegment
²² 
<
²² 
byte
²² 
>
²² 
GetIoBuffer
²² &
(
²²& '
)
²²' (
;
²²( )
ArraySegment
ÂÂ 
<
ÂÂ 
byte
ÂÂ 
>
ÂÂ 
GetIoBuffer
ÂÂ &
(
ÂÂ& '
int
ÂÂ' *
index
ÂÂ+ 0
,
ÂÂ0 1
int
ÂÂ2 5
length
ÂÂ6 <
)
ÂÂ< =
;
ÂÂ= >
ArraySegment
ÓÓ 
<
ÓÓ 
byte
ÓÓ 
>
ÓÓ 
[
ÓÓ 
]
ÓÓ 
GetIoBuffers
ÓÓ )
(
ÓÓ) *
)
ÓÓ* +
;
ÓÓ+ ,
ArraySegment
ää 
<
ää 
byte
ää 
>
ää 
[
ää 
]
ää 
GetIoBuffers
ää )
(
ää) *
int
ää* -
index
ää. 3
,
ää3 4
int
ää5 8
length
ää9 ?
)
ää? @
;
ää@ A
bool
éé 
HasArray
éé 
{
éé 
get
éé 
;
éé 
}
éé 
byte
îî 
[
îî 
]
îî 
Array
îî 
{
îî 
get
îî 
;
îî 
}
îî 
bool
ôô 
HasMemoryAddress
ôô 
{
ôô 
get
ôô  #
;
ôô# $
}
ôô% &
ref
úú 
byte
úú &
GetPinnableMemoryAddress
úú )
(
úú) *
)
úú* +
;
úú+ ,
IntPtr
€	€	 #
AddressOfPinnedMemory
€	€	 $
(
€	€	$ %
)
€	€	% &
;
€	€	& '
IByteBuffer
…	…	 
	Duplicate
…	…	 
(
…	…	 
)
…	…	 
;
…	…	  
IByteBuffer
‡	‡	 
RetainedDuplicate
‡	‡	 %
(
‡	‡	% &
)
‡	‡	& '
;
‡	‡	' (
IByteBuffer
Œ	Œ	 
Unwrap
Œ	Œ	 
(
Œ	Œ	 
)
Œ	Œ	 
;
Œ	Œ	 
IByteBuffer
”	”	 
Copy
”	”	 
(
”	”	 
)
”	”	 
;
”	”	 
IByteBuffer
–	–	 
Copy
–	–	 
(
–	–	 
int
–	–	 
index
–	–	 "
,
–	–	" #
int
–	–	$ '
length
–	–	( .
)
–	–	. /
;
–	–	/ 0
IByteBuffer
˜	˜	 
Slice
˜	˜	 
(
˜	˜	 
)
˜	˜	 
;
˜	˜	 
IByteBuffer
š	š	 
RetainedSlice
š	š	 !
(
š	š	! "
)
š	š	" #
;
š	š	# $
IByteBuffer
œ	œ	 
Slice
œ	œ	 
(
œ	œ	 
int
œ	œ	 
index
œ	œ	 #
,
œ	œ	# $
int
œ	œ	% (
length
œ	œ	) /
)
œ	œ	/ 0
;
œ	œ	0 1
IByteBuffer
		 
RetainedSlice
		 !
(
		! "
int
		" %
index
		& +
,
		+ ,
int
		- 0
length
		1 7
)
		7 8
;
		8 9
int
 	 	 
ArrayOffset
 	 	 
{
 	 	 
get
 	 	 
;
 	 	 
}
 	 	  
IByteBuffer
¢	¢	 
	ReadSlice
¢	¢	 
(
¢	¢	 
int
¢	¢	 !
length
¢	¢	" (
)
¢	¢	( )
;
¢	¢	) *
IByteBuffer
¤	¤	 
ReadRetainedSlice
¤	¤	 %
(
¤	¤	% &
int
¤	¤	& )
length
¤	¤	* 0
)
¤	¤	0 1
;
¤	¤	1 2
Task
¦	¦	 
WriteBytesAsync
¦	¦	 
(
¦	¦	 
Stream
¦	¦	 #
stream
¦	¦	$ *
,
¦	¦	* +
int
¦	¦	, /
length
¦	¦	0 6
)
¦	¦	6 7
;
¦	¦	7 8
Task
¨	¨	 
WriteBytesAsync
¨	¨	 
(
¨	¨	 
Stream
¨	¨	 #
stream
¨	¨	$ *
,
¨	¨	* +
int
¨	¨	, /
length
¨	¨	0 6
,
¨	¨	6 7
CancellationToken
¨	¨	8 I
cancellationToken
¨	¨	J [
)
¨	¨	[ \
;
¨	¨	\ ]
IByteBuffer
ª	ª	 
	WriteZero
ª	ª	 
(
ª	ª	 
int
ª	ª	 !
length
ª	ª	" (
)
ª	ª	( )
;
ª	ª	) *
int
¬	¬	 
WriteCharSequence
¬	¬	 
(
¬	¬	 
ICharSequence
¬	¬	 +
sequence
¬	¬	, 4
,
¬	¬	4 5
Encoding
¬	¬	6 >
encoding
¬	¬	? G
)
¬	¬	G H
;
¬	¬	H I
int
®	®	 
WriteString
®	®	 
(
®	®	 
string
®	®	 
value
®	®	 $
,
®	®	$ %
Encoding
®	®	& .
encoding
®	®	/ 7
)
®	®	7 8
;
®	®	8 9
int
°	°	 
IndexOf
°	°	 
(
°	°	 
int
°	°	 
	fromIndex
°	°	 !
,
°	°	! "
int
°	°	# &
toIndex
°	°	' .
,
°	°	. /
byte
°	°	0 4
value
°	°	5 :
)
°	°	: ;
;
°	°	; <
int
²	²	 
BytesBefore
²	²	 
(
²	²	 
byte
²	²	 
value
²	²	 "
)
²	²	" #
;
²	²	# $
int
´	´	 
BytesBefore
´	´	 
(
´	´	 
int
´	´	 
length
´	´	 "
,
´	´	" #
byte
´	´	$ (
value
´	´	) .
)
´	´	. /
;
´	´	/ 0
int
¶	¶	 
BytesBefore
¶	¶	 
(
¶	¶	 
int
¶	¶	 
index
¶	¶	 !
,
¶	¶	! "
int
¶	¶	# &
length
¶	¶	' -
,
¶	¶	- .
byte
¶	¶	/ 3
value
¶	¶	4 9
)
¶	¶	9 :
;
¶	¶	: ;
string
¸	¸	 
ToString
¸	¸	 
(
¸	¸	 
)
¸	¸	 
;
¸	¸	 
string
º	º	 
ToString
º	º	 
(
º	º	 
Encoding
º	º	  
encoding
º	º	! )
)
º	º	) *
;
º	º	* +
string
¼	¼	 
ToString
¼	¼	 
(
¼	¼	 
int
¼	¼	 
index
¼	¼	 !
,
¼	¼	! "
int
¼	¼	# &
length
¼	¼	' -
,
¼	¼	- .
Encoding
¼	¼	/ 7
encoding
¼	¼	8 @
)
¼	¼	@ A
;
¼	¼	A B
int
Æ	Æ	 
ForEachByte
Æ	Æ	 
(
Æ	Æ	 
IByteProcessor
Æ	Æ	 &
	processor
Æ	Æ	' 0
)
Æ	Æ	0 1
;
Æ	Æ	1 2
int
Ó	Ó	 
ForEachByte
Ó	Ó	 
(
Ó	Ó	 
int
Ó	Ó	 
index
Ó	Ó	 !
,
Ó	Ó	! "
int
Ó	Ó	# &
length
Ó	Ó	' -
,
Ó	Ó	- .
IByteProcessor
Ó	Ó	/ =
	processor
Ó	Ó	> G
)
Ó	Ó	G H
;
Ó	Ó	H I
int
İ	İ	 
ForEachByteDesc
İ	İ	 
(
İ	İ	 
IByteProcessor
İ	İ	 *
	processor
İ	İ	+ 4
)
İ	İ	4 5
;
İ	İ	5 6
int
ê	ê	 
ForEachByteDesc
ê	ê	 
(
ê	ê	 
int
ê	ê	 
index
ê	ê	  %
,
ê	ê	% &
int
ê	ê	' *
length
ê	ê	+ 1
,
ê	ê	1 2
IByteProcessor
ê	ê	3 A
	processor
ê	ê	B K
)
ê	ê	K L
;
ê	ê	L M
}
ë	ë	 
}ì	ì	 –
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public		 

	interface		  
IByteBufferAllocator		 )
{

 
IByteBuffer 
Buffer 
( 
) 
; 
IByteBuffer 
Buffer 
( 
int 
initialCapacity .
). /
;/ 0
IByteBuffer 
Buffer 
( 
int 
initialCapacity .
,. /
int0 3
maxCapacity4 ?
)? @
;@ A
IByteBuffer 

HeapBuffer 
( 
)  
;  !
IByteBuffer 

HeapBuffer 
( 
int "
initialCapacity# 2
)2 3
;3 4
IByteBuffer 

HeapBuffer 
( 
int "
initialCapacity# 2
,2 3
int4 7
maxCapacity8 C
)C D
;D E
IByteBuffer 
DirectBuffer  
(  !
)! "
;" #
IByteBuffer 
DirectBuffer  
(  !
int! $
initialCapacity% 4
)4 5
;5 6
IByteBuffer 
DirectBuffer  
(  !
int! $
initialCapacity% 4
,4 5
int6 9
maxCapacity: E
)E F
;F G
CompositeByteBuffer 
CompositeBuffer +
(+ ,
), -
;- .
CompositeByteBuffer 
CompositeBuffer +
(+ ,
int, /
maxComponents0 =
)= >
;> ?
CompositeByteBuffer!! 
CompositeHeapBuffer!! /
(!!/ 0
)!!0 1
;!!1 2
CompositeByteBuffer## 
CompositeHeapBuffer## /
(##/ 0
int##0 3
maxComponents##4 A
)##A B
;##B C
CompositeByteBuffer%% !
CompositeDirectBuffer%% 1
(%%1 2
)%%2 3
;%%3 4
CompositeByteBuffer'' !
CompositeDirectBuffer'' 1
(''1 2
int''2 5
maxComponents''6 C
)''C D
;''D E
bool))  
IsDirectBufferPooled)) !
{))" #
get))$ '
;))' (
}))) *
int++  
CalculateNewCapacity++  
(++  !
int++! $
minNewCapacity++% 3
,++3 4
int++5 8
maxCapacity++9 D
)++D E
;++E F
},, 
}-- £
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocatorMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface &
IByteBufferAllocatorMetric /
{ 
long 
UsedHeapMemory 
{ 
get !
;! "
}# $
long 
UsedDirectMemory 
{ 
get  #
;# $
}% &
} 
} Ó
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocatorMetricProvider.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface .
"IByteBufferAllocatorMetricProvider 7
{ &
IByteBufferAllocatorMetric "
Metric# )
{* +
get, /
;/ 0
}1 2
} 
} Œ
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferHolder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IByteBufferHolder &
:' (
IReferenceCounted) :
{		 
IByteBuffer 
Content 
{ 
get !
;! "
}# $
IByteBufferHolder 
Copy 
( 
)  
;  !
IByteBufferHolder 
	Duplicate #
(# $
)$ %
;% &
IByteBufferHolder 
RetainedDuplicate +
(+ ,
), -
;- .
IByteBufferHolder!! 
Replace!! !
(!!! "
IByteBuffer!!" -
content!!. 5
)!!5 6
;!!6 7
}"" 
}## ™
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolArenaMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolArenaMetric %
{		 
int 
NumThreadCaches 
{ 
get !
;! "
}# $
int 
NumTinySubpages 
{ 
get !
;! "
}# $
int 
NumSmallSubpages 
{ 
get "
;" #
}$ %
int 
NumChunkLists 
{ 
get 
;  
}! "
IReadOnlyList 
< 
IPoolSubpageMetric (
>( )
TinySubpages* 6
{7 8
get9 <
;< =
}> ?
IReadOnlyList 
< 
IPoolSubpageMetric (
>( )
SmallSubpages* 7
{8 9
get: =
;= >
}? @
IReadOnlyList 
<  
IPoolChunkListMetric *
>* +

ChunkLists, 6
{7 8
get9 <
;< =
}> ?
long   
NumAllocations   
{   
get   !
;  ! "
}  # $
long## 
NumTinyAllocations## 
{##  !
get##" %
;##% &
}##' (
long&& 
NumSmallAllocations&&  
{&&! "
get&&# &
;&&& '
}&&( )
long))  
NumNormalAllocations)) !
{))" #
get))$ '
;))' (
}))) *
long,, 
NumHugeAllocations,, 
{,,  !
get,," %
;,,% &
},,' (
long// 
NumDeallocations// 
{// 
get//  #
;//# $
}//% &
long22  
NumTinyDeallocations22 !
{22" #
get22$ '
;22' (
}22) *
long55 !
NumSmallDeallocations55 "
{55# $
get55% (
;55( )
}55* +
long88 "
NumNormalDeallocations88 #
{88$ %
get88& )
;88) *
}88+ ,
long;;  
NumHugeDeallocations;; !
{;;" #
get;;$ '
;;;' (
};;) *
long>>  
NumActiveAllocations>> !
{>>" #
get>>$ '
;>>' (
}>>) *
longAA $
NumActiveTinyAllocationsAA %
{AA& '
getAA( +
;AA+ ,
}AA- .
longDD %
NumActiveSmallAllocationsDD &
{DD' (
getDD) ,
;DD, -
}DD. /
longGG &
NumActiveNormalAllocationsGG '
{GG( )
getGG* -
;GG- .
}GG/ 0
longJJ $
NumActiveHugeAllocationsJJ %
{JJ& '
getJJ( +
;JJ+ ,
}JJ- .
longMM 
NumActiveBytesMM 
{MM 
getMM !
;MM! "
}MM# $
}NN 
}OO ë
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolChunkListMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface  
IPoolChunkListMetric )
:* +
IEnumerable, 7
<7 8
IPoolChunkMetric8 H
>H I
{		 
int 
MinUsage 
{ 
get 
; 
} 
int 
MaxUsage 
{ 
get 
; 
} 
} 
} ã
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolChunkMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolChunkMetric %
{ 
int		 
Usage		 
{		 
get		 
;		 
}		 
int 
	ChunkSize 
{ 
get 
; 
} 
int 
	FreeBytes 
{ 
get 
; 
} 
} 
} Ú
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolSubpageMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolSubpageMetric '
{ 
int		 
MaxNumElements		 
{		 
get		  
;		  !
}		" #
int 
NumAvailable 
{ 
get 
; 
}  !
int 
ElementSize 
{ 
get 
; 
}  
int 
PageSize 
{ 
get 
; 
} 
} 
} °ê
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolArena.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
enum 
	SizeClass	 
{ 
Tiny 
, 
Small 
, 
Normal 
} 
abstract 
class 
	PoolArena 
< 
T 
> 
:  !
IPoolArenaMetric" 2
{ 
internal 
const 
int 
NumTinySubpagePools .
=/ 0
$num1 4
>>5 7
$num8 9
;9 :
internal 
readonly %
PooledByteBufferAllocator 3
Parent4 :
;: ;
readonly 
int 
maxOrder 
; 
internal 
readonly 
int 
PageSize &
;& '
internal   
readonly   
int   

PageShifts   (
;  ( )
internal!! 
readonly!! 
int!! 
	ChunkSize!! '
;!!' (
internal"" 
readonly"" 
int"" 
SubpageOverflowMask"" 1
;""1 2
internal## 
readonly## 
int##  
NumSmallSubpagePools## 2
;##2 3
readonly$$ 
PoolSubpage$$ 
<$$ 
T$$ 
>$$ 
[$$  
]$$  !
tinySubpagePools$$" 2
;$$2 3
readonly%% 
PoolSubpage%% 
<%% 
T%% 
>%% 
[%%  
]%%  !
smallSubpagePools%%" 3
;%%3 4
readonly'' 
PoolChunkList'' 
<'' 
T''  
>''  !
q050''" &
;''& '
readonly(( 
PoolChunkList(( 
<(( 
T((  
>((  !
q025((" &
;((& '
readonly)) 
PoolChunkList)) 
<)) 
T))  
>))  !
q000))" &
;))& '
readonly** 
PoolChunkList** 
<** 
T**  
>**  !
qInit**" '
;**' (
readonly++ 
PoolChunkList++ 
<++ 
T++  
>++  !
q075++" &
;++& '
readonly,, 
PoolChunkList,, 
<,, 
T,,  
>,,  !
q100,," &
;,,& '
readonly.. 
IReadOnlyList.. 
<..  
IPoolChunkListMetric.. 3
>..3 4
chunkListMetrics..5 E
;..E F
long11 
allocationsNormal11 
;11 
long44 
allocationsTiny44 
;44 
long66 
allocationsSmall66 
;66 
long77 
allocationsHuge77 
;77 
long88 
activeBytesHuge88 
;88 
long:: 
deallocationsTiny:: 
;:: 
long;; 
deallocationsSmall;; 
;;;  
long<< 
deallocationsNormal<<  
;<<  !
long?? 
deallocationsHuge?? 
;?? 
intBB 
numThreadCachesBB 
;BB 
	protectedGG 
	PoolArenaGG 
(GG %
PooledByteBufferAllocatorHH %
parentHH& ,
,HH, -
intII 
pageSizeII 
,II 
intJJ 
maxOrderJJ 
,JJ 
intKK 

pageShiftsKK 
,KK 
intLL 
	chunkSizeLL 
)LL 
{MM 	
thisNN 
.NN 
ParentNN 
=NN 
parentNN  
;NN  !
thisOO 
.OO 
PageSizeOO 
=OO 
pageSizeOO $
;OO$ %
thisPP 
.PP 
maxOrderPP 
=PP 
maxOrderPP $
;PP$ %
thisQQ 
.QQ 

PageShiftsQQ 
=QQ 

pageShiftsQQ (
;QQ( )
thisRR 
.RR 
	ChunkSizeRR 
=RR 
	chunkSizeRR &
;RR& '
thisSS 
.SS 
SubpageOverflowMaskSS $
=SS% &
~SS' (
(SS( )
pageSizeSS) 1
-SS2 3
$numSS4 5
)SS5 6
;SS6 7
thisTT 
.TT 
tinySubpagePoolsTT !
=TT" #
thisTT$ (
.TT( )
NewSubpagePoolArrayTT) <
(TT< =
NumTinySubpagePoolsTT= P
)TTP Q
;TTQ R
forUU 
(UU 
intUU 
iUU 
=UU 
$numUU 
;UU 
iUU 
<UU 
thisUU  $
.UU$ %
tinySubpagePoolsUU% 5
.UU5 6
LengthUU6 <
;UU< =
iUU> ?
++UU? A
)UUA B
{VV 
thisWW 
.WW 
tinySubpagePoolsWW %
[WW% &
iWW& '
]WW' (
=WW) *
thisWW+ /
.WW/ 0
NewSubpagePoolHeadWW0 B
(WWB C
pageSizeWWC K
)WWK L
;WWL M
}XX 
thisZZ 
.ZZ  
NumSmallSubpagePoolsZZ %
=ZZ& '

pageShiftsZZ( 2
-ZZ3 4
$numZZ5 6
;ZZ6 7
this[[ 
.[[ 
smallSubpagePools[[ "
=[[# $
this[[% )
.[[) *
NewSubpagePoolArray[[* =
([[= >
this[[> B
.[[B C 
NumSmallSubpagePools[[C W
)[[W X
;[[X Y
for\\ 
(\\ 
int\\ 
i\\ 
=\\ 
$num\\ 
;\\ 
i\\ 
<\\ 
this\\  $
.\\$ %
smallSubpagePools\\% 6
.\\6 7
Length\\7 =
;\\= >
i\\? @
++\\@ B
)\\B C
{]] 
this^^ 
.^^ 
smallSubpagePools^^ &
[^^& '
i^^' (
]^^( )
=^^* +
this^^, 0
.^^0 1
NewSubpagePoolHead^^1 C
(^^C D
pageSize^^D L
)^^L M
;^^M N
}__ 
thisaa 
.aa 
q100aa 
=aa 
newaa 
PoolChunkListaa )
<aa) *
Taa* +
>aa+ ,
(aa, -
thisaa- 1
,aa1 2
nullaa3 7
,aa7 8
$numaa9 <
,aa< =
intaa> A
.aaA B
MaxValueaaB J
,aaJ K
	chunkSizeaaL U
)aaU V
;aaV W
thisbb 
.bb 
q075bb 
=bb 
newbb 
PoolChunkListbb )
<bb) *
Tbb* +
>bb+ ,
(bb, -
thisbb- 1
,bb1 2
thisbb3 7
.bb7 8
q100bb8 <
,bb< =
$numbb> @
,bb@ A
$numbbB E
,bbE F
	chunkSizebbG P
)bbP Q
;bbQ R
thiscc 
.cc 
q050cc 
=cc 
newcc 
PoolChunkListcc )
<cc) *
Tcc* +
>cc+ ,
(cc, -
thiscc- 1
,cc1 2
thiscc3 7
.cc7 8
q075cc8 <
,cc< =
$numcc> @
,cc@ A
$numccB E
,ccE F
	chunkSizeccG P
)ccP Q
;ccQ R
thisdd 
.dd 
q025dd 
=dd 
newdd 
PoolChunkListdd )
<dd) *
Tdd* +
>dd+ ,
(dd, -
thisdd- 1
,dd1 2
thisdd3 7
.dd7 8
q050dd8 <
,dd< =
$numdd> @
,dd@ A
$numddB D
,ddD E
	chunkSizeddF O
)ddO P
;ddP Q
thisee 
.ee 
q000ee 
=ee 
newee 
PoolChunkListee )
<ee) *
Tee* +
>ee+ ,
(ee, -
thisee- 1
,ee1 2
thisee3 7
.ee7 8
q025ee8 <
,ee< =
$numee> ?
,ee? @
$numeeA C
,eeC D
	chunkSizeeeE N
)eeN O
;eeO P
thisff 
.ff 
qInitff 
=ff 
newff 
PoolChunkListff *
<ff* +
Tff+ ,
>ff, -
(ff- .
thisff. 2
,ff2 3
thisff4 8
.ff8 9
q000ff9 =
,ff= >
intff? B
.ffB C
MinValueffC K
,ffK L
$numffM O
,ffO P
	chunkSizeffQ Z
)ffZ [
;ff[ \
thishh 
.hh 
q100hh 
.hh 
PrevListhh 
(hh 
thishh #
.hh# $
q075hh$ (
)hh( )
;hh) *
thisii 
.ii 
q075ii 
.ii 
PrevListii 
(ii 
thisii #
.ii# $
q050ii$ (
)ii( )
;ii) *
thisjj 
.jj 
q050jj 
.jj 
PrevListjj 
(jj 
thisjj #
.jj# $
q025jj$ (
)jj( )
;jj) *
thiskk 
.kk 
q025kk 
.kk 
PrevListkk 
(kk 
thiskk #
.kk# $
q000kk$ (
)kk( )
;kk) *
thisll 
.ll 
q000ll 
.ll 
PrevListll 
(ll 
nullll #
)ll# $
;ll$ %
thismm 
.mm 
qInitmm 
.mm 
PrevListmm 
(mm  
thismm  $
.mm$ %
qInitmm% *
)mm* +
;mm+ ,
varoo 
metricsoo 
=oo 
newoo 
Listoo "
<oo" # 
IPoolChunkListMetricoo# 7
>oo7 8
(oo8 9
$numoo9 :
)oo: ;
;oo; <
metricspp 
.pp 
Addpp 
(pp 
thispp 
.pp 
qInitpp "
)pp" #
;pp# $
metricsqq 
.qq 
Addqq 
(qq 
thisqq 
.qq 
q000qq !
)qq! "
;qq" #
metricsrr 
.rr 
Addrr 
(rr 
thisrr 
.rr 
q025rr !
)rr! "
;rr" #
metricsss 
.ss 
Addss 
(ss 
thisss 
.ss 
q050ss !
)ss! "
;ss" #
metricstt 
.tt 
Addtt 
(tt 
thistt 
.tt 
q075tt !
)tt! "
;tt" #
metricsuu 
.uu 
Adduu 
(uu 
thisuu 
.uu 
q100uu !
)uu! "
;uu" #
thisvv 
.vv 
chunkListMetricsvv !
=vv" #
metricsvv$ +
;vv+ ,
}ww 	
PoolSubpageyy 
<yy 
Tyy 
>yy 
NewSubpagePoolHeadyy )
(yy) *
intyy* -
pageSizeyy. 6
)yy6 7
{zz 	
var{{ 
head{{ 
={{ 
new{{ 
PoolSubpage{{ &
<{{& '
T{{' (
>{{( )
({{) *
pageSize{{* 2
){{2 3
;{{3 4
head|| 
.|| 
Prev|| 
=|| 
head|| 
;|| 
head}} 
.}} 
Next}} 
=}} 
head}} 
;}} 
return~~ 
head~~ 
;~~ 
} 	
PoolSubpage
 
<
 
T
 
>
 
[
 
]
 !
NewSubpagePoolArray
 ,
(
, -
int
- 0
size
1 5
)
5 6
=>
7 9
new
: =
PoolSubpage
> I
<
I J
T
J K
>
K L
[
L M
size
M Q
]
Q R
;
R S
internal
ƒƒ 
abstract
ƒƒ 
bool
ƒƒ 
IsDirect
ƒƒ '
{
ƒƒ( )
get
ƒƒ* -
;
ƒƒ- .
}
ƒƒ/ 0
internal
…… 
PooledByteBuffer
…… !
<
……! "
T
……" #
>
……# $
Allocate
……% -
(
……- .
PoolThreadCache
……. =
<
……= >
T
……> ?
>
……? @
cache
……A F
,
……F G
int
……H K
reqCapacity
……L W
,
……W X
int
……Y \
maxCapacity
……] h
)
……h i
{
†† 	
PooledByteBuffer
‡‡ 
<
‡‡ 
T
‡‡ 
>
‡‡ 
buf
‡‡  #
=
‡‡$ %
this
‡‡& *
.
‡‡* +

NewByteBuf
‡‡+ 5
(
‡‡5 6
maxCapacity
‡‡6 A
)
‡‡A B
;
‡‡B C
this
ˆˆ 
.
ˆˆ 
Allocate
ˆˆ 
(
ˆˆ 
cache
ˆˆ 
,
ˆˆ  
buf
ˆˆ! $
,
ˆˆ$ %
reqCapacity
ˆˆ& 1
)
ˆˆ1 2
;
ˆˆ2 3
return
‰‰ 
buf
‰‰ 
;
‰‰ 
}
ŠŠ 	
internal
ŒŒ 
static
ŒŒ 
int
ŒŒ 
TinyIdx
ŒŒ #
(
ŒŒ# $
int
ŒŒ$ '
normCapacity
ŒŒ( 4
)
ŒŒ4 5
=>
ŒŒ6 8
normCapacity
ŒŒ9 E
.
ŒŒE F
RightUShift
ŒŒF Q
(
ŒŒQ R
$num
ŒŒR S
)
ŒŒS T
;
ŒŒT U
internal
 
static
 
int
 
SmallIdx
 $
(
$ %
int
% (
normCapacity
) 5
)
5 6
{
 	
int
 
tableIdx
 
=
 
$num
 
;
 
int
‘‘ 
i
‘‘ 
=
‘‘ 
normCapacity
‘‘  
.
‘‘  !
RightUShift
‘‘! ,
(
‘‘, -
$num
‘‘- /
)
‘‘/ 0
;
‘‘0 1
while
’’ 
(
’’ 
i
’’ 
!=
’’ 
$num
’’ 
)
’’ 
{
““ 
i
”” 
=
”” 
i
”” 
.
”” 
RightUShift
”” !
(
””! "
$num
””" #
)
””# $
;
””$ %
tableIdx
•• 
++
•• 
;
•• 
}
–– 
return
—— 
tableIdx
—— 
;
—— 
}
˜˜ 	
internal
›› 
bool
›› 
IsTinyOrSmall
›› #
(
››# $
int
››$ '
normCapacity
››( 4
)
››4 5
=>
››6 8
(
››9 :
normCapacity
››: F
&
››G H
this
››I M
.
››M N!
SubpageOverflowMask
››N a
)
››a b
==
››c e
$num
››f g
;
››g h
internal
 
static
 
bool
 
IsTiny
 #
(
# $
int
$ '
normCapacity
( 4
)
4 5
=>
6 8
(
9 :
normCapacity
: F
&
G H
$num
I S
)
S T
==
U W
$num
X Y
;
Y Z
void
   
Allocate
   
(
   
PoolThreadCache
   %
<
  % &
T
  & '
>
  ' (
cache
  ) .
,
  . /
PooledByteBuffer
  0 @
<
  @ A
T
  A B
>
  B C
buf
  D G
,
  G H
int
  I L
reqCapacity
  M X
)
  X Y
{
¡¡ 	
int
¢¢ 
normCapacity
¢¢ 
=
¢¢ 
this
¢¢ #
.
¢¢# $
NormalizeCapacity
¢¢$ 5
(
¢¢5 6
reqCapacity
¢¢6 A
)
¢¢A B
;
¢¢B C
if
££ 
(
££ 
this
££ 
.
££ 
IsTinyOrSmall
££ "
(
££" #
normCapacity
££# /
)
££/ 0
)
££0 1
{
¤¤ 
int
¦¦ 
tableIdx
¦¦ 
;
¦¦ 
PoolSubpage
§§ 
<
§§ 
T
§§ 
>
§§ 
[
§§ 
]
§§  
table
§§! &
;
§§& '
bool
¨¨ 
tiny
¨¨ 
=
¨¨ 
IsTiny
¨¨ "
(
¨¨" #
normCapacity
¨¨# /
)
¨¨/ 0
;
¨¨0 1
if
©© 
(
©© 
tiny
©© 
)
©© 
{
ªª 
if
¬¬ 
(
¬¬ 
cache
¬¬ 
.
¬¬ 
AllocateTiny
¬¬ *
(
¬¬* +
this
¬¬+ /
,
¬¬/ 0
buf
¬¬1 4
,
¬¬4 5
reqCapacity
¬¬6 A
,
¬¬A B
normCapacity
¬¬C O
)
¬¬O P
)
¬¬P Q
{
­­ 
return
¯¯ 
;
¯¯ 
}
°° 
tableIdx
±± 
=
±± 
TinyIdx
±± &
(
±±& '
normCapacity
±±' 3
)
±±3 4
;
±±4 5
table
²² 
=
²² 
this
²²  
.
²²  !
tinySubpagePools
²²! 1
;
²²1 2
}
³³ 
else
´´ 
{
µµ 
if
¶¶ 
(
¶¶ 
cache
¶¶ 
.
¶¶ 
AllocateSmall
¶¶ +
(
¶¶+ ,
this
¶¶, 0
,
¶¶0 1
buf
¶¶2 5
,
¶¶5 6
reqCapacity
¶¶7 B
,
¶¶B C
normCapacity
¶¶D P
)
¶¶P Q
)
¶¶Q R
{
·· 
return
¹¹ 
;
¹¹ 
}
ºº 
tableIdx
»» 
=
»» 
SmallIdx
»» '
(
»»' (
normCapacity
»»( 4
)
»»4 5
;
»»5 6
table
¼¼ 
=
¼¼ 
this
¼¼  
.
¼¼  !
smallSubpagePools
¼¼! 2
;
¼¼2 3
}
½½ 
PoolSubpage
¿¿ 
<
¿¿ 
T
¿¿ 
>
¿¿ 
head
¿¿ #
=
¿¿$ %
table
¿¿& +
[
¿¿+ ,
tableIdx
¿¿, 4
]
¿¿4 5
;
¿¿5 6
lock
ÅÅ 
(
ÅÅ 
head
ÅÅ 
)
ÅÅ 
{
ÆÆ 
PoolSubpage
ÇÇ 
<
ÇÇ  
T
ÇÇ  !
>
ÇÇ! "
s
ÇÇ# $
=
ÇÇ% &
head
ÇÇ' +
.
ÇÇ+ ,
Next
ÇÇ, 0
;
ÇÇ0 1
if
ÈÈ 
(
ÈÈ 
s
ÈÈ 
!=
ÈÈ 
head
ÈÈ !
)
ÈÈ! "
{
ÉÉ 
Debug
ÊÊ 
.
ÊÊ 
Assert
ÊÊ $
(
ÊÊ$ %
s
ÊÊ% &
.
ÊÊ& '
DoNotDestroy
ÊÊ' 3
&&
ÊÊ4 6
s
ÊÊ7 8
.
ÊÊ8 9
ElemSize
ÊÊ9 A
==
ÊÊB D
normCapacity
ÊÊE Q
)
ÊÊQ R
;
ÊÊR S
long
ËË 
handle
ËË #
=
ËË$ %
s
ËË& '
.
ËË' (
Allocate
ËË( 0
(
ËË0 1
)
ËË1 2
;
ËË2 3
Debug
ÌÌ 
.
ÌÌ 
Assert
ÌÌ $
(
ÌÌ$ %
handle
ÌÌ% +
>=
ÌÌ, .
$num
ÌÌ/ 0
)
ÌÌ0 1
;
ÌÌ1 2
s
ÍÍ 
.
ÍÍ 
Chunk
ÍÍ 
.
ÍÍ   
InitBufWithSubpage
ÍÍ  2
(
ÍÍ2 3
buf
ÍÍ3 6
,
ÍÍ6 7
handle
ÍÍ8 >
,
ÍÍ> ?
reqCapacity
ÍÍ@ K
)
ÍÍK L
;
ÍÍL M
this
ÎÎ 
.
ÎÎ $
IncTinySmallAllocation
ÎÎ 3
(
ÎÎ3 4
tiny
ÎÎ4 8
)
ÎÎ8 9
;
ÎÎ9 :
return
ÏÏ 
;
ÏÏ 
}
ĞĞ 
}
ÑÑ 
lock
ÓÓ 
(
ÓÓ 
this
ÓÓ 
)
ÓÓ 
{
ÔÔ 
this
ÕÕ 
.
ÕÕ 
AllocateNormal
ÕÕ '
(
ÕÕ' (
buf
ÕÕ( +
,
ÕÕ+ ,
reqCapacity
ÕÕ- 8
,
ÕÕ8 9
normCapacity
ÕÕ: F
)
ÕÕF G
;
ÕÕG H
}
ÖÖ 
this
ØØ 
.
ØØ $
IncTinySmallAllocation
ØØ +
(
ØØ+ ,
tiny
ØØ, 0
)
ØØ0 1
;
ØØ1 2
return
ÙÙ 
;
ÙÙ 
}
ÚÚ 
if
ÛÛ 
(
ÛÛ 
normCapacity
ÛÛ 
<=
ÛÛ 
this
ÛÛ  $
.
ÛÛ$ %
	ChunkSize
ÛÛ% .
)
ÛÛ. /
{
ÜÜ 
if
İİ 
(
İİ 
cache
İİ 
.
İİ 
AllocateNormal
İİ (
(
İİ( )
this
İİ) -
,
İİ- .
buf
İİ/ 2
,
İİ2 3
reqCapacity
İİ4 ?
,
İİ? @
normCapacity
İİA M
)
İİM N
)
İİN O
{
ŞŞ 
return
àà 
;
àà 
}
áá 
lock
ãã 
(
ãã 
this
ãã 
)
ãã 
{
ää 
this
åå 
.
åå 
AllocateNormal
åå '
(
åå' (
buf
åå( +
,
åå+ ,
reqCapacity
åå- 8
,
åå8 9
normCapacity
åå: F
)
ååF G
;
ååG H
this
ææ 
.
ææ 
allocationsNormal
ææ *
++
ææ* ,
;
ææ, -
}
çç 
}
èè 
else
éé 
{
êê 
this
ìì 
.
ìì 
AllocateHuge
ìì !
(
ìì! "
buf
ìì" %
,
ìì% &
reqCapacity
ìì' 2
)
ìì2 3
;
ìì3 4
}
íí 
}
îî 	
void
ğğ 
AllocateNormal
ğğ 
(
ğğ 
PooledByteBuffer
ğğ ,
<
ğğ, -
T
ğğ- .
>
ğğ. /
buf
ğğ0 3
,
ğğ3 4
int
ğğ5 8
reqCapacity
ğğ9 D
,
ğğD E
int
ğğF I
normCapacity
ğğJ V
)
ğğV W
{
ññ 	
if
òò 
(
òò 
this
òò 
.
òò 
q050
òò 
.
òò 
Allocate
òò "
(
òò" #
buf
òò# &
,
òò& '
reqCapacity
òò( 3
,
òò3 4
normCapacity
òò5 A
)
òòA B
||
òòC E
this
òòF J
.
òòJ K
q025
òòK O
.
òòO P
Allocate
òòP X
(
òòX Y
buf
òòY \
,
òò\ ]
reqCapacity
òò^ i
,
òòi j
normCapacity
òòk w
)
òòw x
||
óó 
this
óó 
.
óó 
q000
óó 
.
óó 
Allocate
óó %
(
óó% &
buf
óó& )
,
óó) *
reqCapacity
óó+ 6
,
óó6 7
normCapacity
óó8 D
)
óóD E
||
óóF H
this
óóI M
.
óóM N
qInit
óóN S
.
óóS T
Allocate
óóT \
(
óó\ ]
buf
óó] `
,
óó` a
reqCapacity
óób m
,
óóm n
normCapacity
óóo {
)
óó{ |
||
ôô 
this
ôô 
.
ôô 
q075
ôô 
.
ôô 
Allocate
ôô %
(
ôô% &
buf
ôô& )
,
ôô) *
reqCapacity
ôô+ 6
,
ôô6 7
normCapacity
ôô8 D
)
ôôD E
)
ôôE F
{
õõ 
return
öö 
;
öö 
}
÷÷ 
	PoolChunk
úú 
<
úú 
T
úú 
>
úú 
c
úú 
=
úú 
this
úú !
.
úú! "
NewChunk
úú" *
(
úú* +
this
úú+ /
.
úú/ 0
PageSize
úú0 8
,
úú8 9
this
úú: >
.
úú> ?
maxOrder
úú? G
,
úúG H
this
úúI M
.
úúM N

PageShifts
úúN X
,
úúX Y
this
úúZ ^
.
úú^ _
	ChunkSize
úú_ h
)
úúh i
;
úúi j
long
ûû 
handle
ûû 
=
ûû 
c
ûû 
.
ûû 
Allocate
ûû $
(
ûû$ %
normCapacity
ûû% 1
)
ûû1 2
;
ûû2 3
Debug
üü 
.
üü 
Assert
üü 
(
üü 
handle
üü 
>
üü  !
$num
üü" #
)
üü# $
;
üü$ %
c
ıı 
.
ıı 
InitBuf
ıı 
(
ıı 
buf
ıı 
,
ıı 
handle
ıı !
,
ıı! "
reqCapacity
ıı# .
)
ıı. /
;
ıı/ 0
this
şş 
.
şş 
qInit
şş 
.
şş 
Add
şş 
(
şş 
c
şş 
)
şş 
;
şş 
}
ÿÿ 	
void
 $
IncTinySmallAllocation
 #
(
# $
bool
$ (
tiny
) -
)
- .
{
‚‚ 	
if
ƒƒ 
(
ƒƒ 
tiny
ƒƒ 
)
ƒƒ 
{
„„ 
Interlocked
…… 
.
…… 
	Increment
…… %
(
……% &
ref
……& )
this
……* .
.
……. /
allocationsTiny
……/ >
)
……> ?
;
……? @
}
†† 
else
‡‡ 
{
ˆˆ 
Interlocked
‰‰ 
.
‰‰ 
	Increment
‰‰ %
(
‰‰% &
ref
‰‰& )
this
‰‰* .
.
‰‰. /
allocationsSmall
‰‰/ ?
)
‰‰? @
;
‰‰@ A
}
ŠŠ 
}
‹‹ 	
void
 
AllocateHuge
 
(
 
PooledByteBuffer
 *
<
* +
T
+ ,
>
, -
buf
. 1
,
1 2
int
3 6
reqCapacity
7 B
)
B C
{
 	
	PoolChunk
 
<
 
T
 
>
 
chunk
 
=
  
this
! %
.
% &
NewUnpooledChunk
& 6
(
6 7
reqCapacity
7 B
)
B C
;
C D
Interlocked
 
.
 
Add
 
(
 
ref
 
this
  $
.
$ %
activeBytesHuge
% 4
,
4 5
chunk
6 ;
.
; <
	ChunkSize
< E
)
E F
;
F G
buf
‘‘ 
.
‘‘ 
InitUnpooled
‘‘ 
(
‘‘ 
chunk
‘‘ "
,
‘‘" #
reqCapacity
‘‘$ /
)
‘‘/ 0
;
‘‘0 1
Interlocked
’’ 
.
’’ 
	Increment
’’ !
(
’’! "
ref
’’" %
this
’’& *
.
’’* +
allocationsHuge
’’+ :
)
’’: ;
;
’’; <
}
““ 	
internal
•• 
void
•• 
Free
•• 
(
•• 
	PoolChunk
•• $
<
••$ %
T
••% &
>
••& '
chunk
••( -
,
••- .
long
••/ 3
handle
••4 :
,
••: ;
int
••< ?
normCapacity
••@ L
,
••L M
PoolThreadCache
••N ]
<
••] ^
T
••^ _
>
••_ `
cache
••a f
)
••f g
{
–– 	
if
—— 
(
—— 
chunk
—— 
.
—— 
Unpooled
—— 
)
—— 
{
˜˜ 
int
™™ 
size
™™ 
=
™™ 
chunk
™™  
.
™™  !
	ChunkSize
™™! *
;
™™* +
this
šš 
.
šš 
DestroyChunk
šš !
(
šš! "
chunk
šš" '
)
šš' (
;
šš( )
Interlocked
›› 
.
›› 
Add
›› 
(
››  
ref
››  #
this
››$ (
.
››( )
activeBytesHuge
››) 8
,
››8 9
-
››: ;
size
››; ?
)
››? @
;
››@ A
Interlocked
œœ 
.
œœ 
	Increment
œœ %
(
œœ% &
ref
œœ& )
this
œœ* .
.
œœ. /
deallocationsHuge
œœ/ @
)
œœ@ A
;
œœA B
}
 
else
 
{
ŸŸ 
	SizeClass
   
	sizeClass
   #
=
  $ %
this
  & *
.
  * +
	SizeClass
  + 4
(
  4 5
normCapacity
  5 A
)
  A B
;
  B C
if
¡¡ 
(
¡¡ 
cache
¡¡ 
!=
¡¡ 
null
¡¡ !
&&
¡¡" $
cache
¡¡% *
.
¡¡* +
Add
¡¡+ .
(
¡¡. /
this
¡¡/ 3
,
¡¡3 4
chunk
¡¡5 :
,
¡¡: ;
handle
¡¡< B
,
¡¡B C
normCapacity
¡¡D P
,
¡¡P Q
	sizeClass
¡¡R [
)
¡¡[ \
)
¡¡\ ]
{
¢¢ 
return
¤¤ 
;
¤¤ 
}
¥¥ 
this
§§ 
.
§§ 
	FreeChunk
§§ 
(
§§ 
chunk
§§ $
,
§§$ %
handle
§§& ,
,
§§, -
	sizeClass
§§. 7
)
§§7 8
;
§§8 9
}
¨¨ 
}
©© 	
	SizeClass
«« 
	SizeClass
«« 
(
«« 
int
«« 
normCapacity
««  ,
)
««, -
{
¬¬ 	
if
­­ 
(
­­ 
!
­­ 
this
­­ 
.
­­ 
IsTinyOrSmall
­­ #
(
­­# $
normCapacity
­­$ 0
)
­­0 1
)
­­1 2
{
®® 
return
¯¯ 
Buffers
¯¯ 
.
¯¯ 
	SizeClass
¯¯ (
.
¯¯( )
Normal
¯¯) /
;
¯¯/ 0
}
°° 
return
²² 
IsTiny
²² 
(
²² 
normCapacity
²² &
)
²²& '
?
²²( )
Buffers
²²* 1
.
²²1 2
	SizeClass
²²2 ;
.
²²; <
Tiny
²²< @
:
²²A B
Buffers
²²C J
.
²²J K
	SizeClass
²²K T
.
²²T U
Small
²²U Z
;
²²Z [
}
³³ 	
internal
µµ 
void
µµ 
	FreeChunk
µµ 
(
µµ  
	PoolChunk
µµ  )
<
µµ) *
T
µµ* +
>
µµ+ ,
chunk
µµ- 2
,
µµ2 3
long
µµ4 8
handle
µµ9 ?
,
µµ? @
	SizeClass
µµA J
	sizeClass
µµK T
)
µµT U
{
¶¶ 	
bool
·· 
destroyChunk
·· 
;
·· 
lock
¸¸ 
(
¸¸ 
this
¸¸ 
)
¸¸ 
{
¹¹ 
switch
ºº 
(
ºº 
	sizeClass
ºº !
)
ºº! "
{
»» 
case
¼¼ 
Buffers
¼¼  
.
¼¼  !
	SizeClass
¼¼! *
.
¼¼* +
Normal
¼¼+ 1
:
¼¼1 2
++
½½ 
this
½½ 
.
½½ !
deallocationsNormal
½½ 2
;
½½2 3
break
¾¾ 
;
¾¾ 
case
¿¿ 
Buffers
¿¿  
.
¿¿  !
	SizeClass
¿¿! *
.
¿¿* +
Small
¿¿+ 0
:
¿¿0 1
++
ÀÀ 
this
ÀÀ 
.
ÀÀ  
deallocationsSmall
ÀÀ 1
;
ÀÀ1 2
break
ÁÁ 
;
ÁÁ 
case
ÂÂ 
Buffers
ÂÂ  
.
ÂÂ  !
	SizeClass
ÂÂ! *
.
ÂÂ* +
Tiny
ÂÂ+ /
:
ÂÂ/ 0
++
ÃÃ 
this
ÃÃ 
.
ÃÃ 
deallocationsTiny
ÃÃ 0
;
ÃÃ0 1
break
ÄÄ 
;
ÄÄ 
default
ÅÅ 
:
ÅÅ 
throw
ÆÆ 
new
ÆÆ !)
ArgumentOutOfRangeException
ÆÆ" =
(
ÆÆ= >
)
ÆÆ> ?
;
ÆÆ? @
}
ÇÇ 
destroyChunk
ÈÈ 
=
ÈÈ 
!
ÈÈ  
chunk
ÈÈ  %
.
ÈÈ% &
Parent
ÈÈ& ,
.
ÈÈ, -
Free
ÈÈ- 1
(
ÈÈ1 2
chunk
ÈÈ2 7
,
ÈÈ7 8
handle
ÈÈ9 ?
)
ÈÈ? @
;
ÈÈ@ A
}
ÉÉ 
if
ÊÊ 
(
ÊÊ 
destroyChunk
ÊÊ 
)
ÊÊ 
{
ËË 
this
ÍÍ 
.
ÍÍ 
DestroyChunk
ÍÍ !
(
ÍÍ! "
chunk
ÍÍ" '
)
ÍÍ' (
;
ÍÍ( )
}
ÎÎ 
}
ÏÏ 	
internal
ÑÑ 
PoolSubpage
ÑÑ 
<
ÑÑ 
T
ÑÑ 
>
ÑÑ !
FindSubpagePoolHead
ÑÑ  3
(
ÑÑ3 4
int
ÑÑ4 7
elemSize
ÑÑ8 @
)
ÑÑ@ A
{
ÒÒ 	
int
ÓÓ 
tableIdx
ÓÓ 
;
ÓÓ 
PoolSubpage
ÔÔ 
<
ÔÔ 
T
ÔÔ 
>
ÔÔ 
[
ÔÔ 
]
ÔÔ 
table
ÔÔ "
;
ÔÔ" #
if
ÕÕ 
(
ÕÕ 
IsTiny
ÕÕ 
(
ÕÕ 
elemSize
ÕÕ 
)
ÕÕ  
)
ÕÕ  !
{
ÖÖ 
tableIdx
ØØ 
=
ØØ 
elemSize
ØØ #
.
ØØ# $
RightUShift
ØØ$ /
(
ØØ/ 0
$num
ØØ0 1
)
ØØ1 2
;
ØØ2 3
table
ÙÙ 
=
ÙÙ 
this
ÙÙ 
.
ÙÙ 
tinySubpagePools
ÙÙ -
;
ÙÙ- .
}
ÚÚ 
else
ÛÛ 
{
ÜÜ 
tableIdx
İİ 
=
İİ 
$num
İİ 
;
İİ 
elemSize
ŞŞ 
=
ŞŞ 
elemSize
ŞŞ #
.
ŞŞ# $
RightUShift
ŞŞ$ /
(
ŞŞ/ 0
$num
ŞŞ0 2
)
ŞŞ2 3
;
ŞŞ3 4
while
ßß 
(
ßß 
elemSize
ßß 
!=
ßß  "
$num
ßß# $
)
ßß$ %
{
àà 
elemSize
áá 
=
áá 
elemSize
áá '
.
áá' (
RightUShift
áá( 3
(
áá3 4
$num
áá4 5
)
áá5 6
;
áá6 7
tableIdx
ââ 
++
ââ 
;
ââ 
}
ãã 
table
ää 
=
ää 
this
ää 
.
ää 
smallSubpagePools
ää .
;
ää. /
}
åå 
return
çç 
table
çç 
[
çç 
tableIdx
çç !
]
çç! "
;
çç" #
}
èè 	
internal
êê 
int
êê 
NormalizeCapacity
êê &
(
êê& '
int
êê' *
reqCapacity
êê+ 6
)
êê6 7
{
ëë 	
Contract
ìì 
.
ìì 
Requires
ìì 
(
ìì 
reqCapacity
ìì )
>=
ìì* ,
$num
ìì- .
&&
ìì/ 1
reqCapacity
ìì2 =
>=
ìì> @
this
ììA E
.
ììE F
	ChunkSize
ììF O
)
ììO P
;
ììP Q
if
îî 
(
îî 
reqCapacity
îî 
>=
îî 
this
îî #
.
îî# $
	ChunkSize
îî$ -
)
îî- .
{
ïï 
return
ğğ 
reqCapacity
ğğ "
;
ğğ" #
}
ññ 
if
óó 
(
óó 
!
óó 
IsTiny
óó 
(
óó 
reqCapacity
óó #
)
óó# $
)
óó$ %
{
ôô 
int
øø  
normalizedCapacity
øø &
=
øø' (
reqCapacity
øø) 4
;
øø4 5 
normalizedCapacity
ùù "
--
ùù" $
;
ùù$ % 
normalizedCapacity
úú "
|=
úú# % 
normalizedCapacity
úú& 8
.
úú8 9
RightUShift
úú9 D
(
úúD E
$num
úúE F
)
úúF G
;
úúG H 
normalizedCapacity
ûû "
|=
ûû# % 
normalizedCapacity
ûû& 8
.
ûû8 9
RightUShift
ûû9 D
(
ûûD E
$num
ûûE F
)
ûûF G
;
ûûG H 
normalizedCapacity
üü "
|=
üü# % 
normalizedCapacity
üü& 8
.
üü8 9
RightUShift
üü9 D
(
üüD E
$num
üüE F
)
üüF G
;
üüG H 
normalizedCapacity
ıı "
|=
ıı# % 
normalizedCapacity
ıı& 8
.
ıı8 9
RightUShift
ıı9 D
(
ııD E
$num
ııE F
)
ııF G
;
ııG H 
normalizedCapacity
şş "
|=
şş# % 
normalizedCapacity
şş& 8
.
şş8 9
RightUShift
şş9 D
(
şşD E
$num
şşE G
)
şşG H
;
şşH I 
normalizedCapacity
ÿÿ "
++
ÿÿ" $
;
ÿÿ$ %
if
 
(
  
normalizedCapacity
 &
<
' (
$num
) *
)
* +
{
‚‚  
normalizedCapacity
ƒƒ &
=
ƒƒ' ( 
normalizedCapacity
ƒƒ) ;
.
ƒƒ; <
RightUShift
ƒƒ< G
(
ƒƒG H
$num
ƒƒH I
)
ƒƒI J
;
ƒƒJ K
}
„„ 
return
††  
normalizedCapacity
†† )
;
††) *
}
‡‡ 
if
ŠŠ 
(
ŠŠ 
(
ŠŠ 
reqCapacity
ŠŠ 
&
ŠŠ 
$num
ŠŠ !
)
ŠŠ! "
==
ŠŠ# %
$num
ŠŠ& '
)
ŠŠ' (
{
‹‹ 
return
ŒŒ 
reqCapacity
ŒŒ "
;
ŒŒ" #
}
 
return
 
(
 
reqCapacity
 
&
  !
~
" #
$num
# %
)
% &
+
' (
$num
) +
;
+ ,
}
 	
internal
’’ 
void
’’ 

Reallocate
’’  
(
’’  !
PooledByteBuffer
’’! 1
<
’’1 2
T
’’2 3
>
’’3 4
buf
’’5 8
,
’’8 9
int
’’: =
newCapacity
’’> I
,
’’I J
bool
’’K O
freeOldMemory
’’P ]
)
’’] ^
{
““ 	
Contract
”” 
.
”” 
Requires
”” 
(
”” 
newCapacity
”” )
>=
””* ,
$num
””- .
&&
””/ 1
newCapacity
””2 =
<=
””> @
buf
””A D
.
””D E
MaxCapacity
””E P
)
””P Q
;
””Q R
int
–– 
oldCapacity
–– 
=
–– 
buf
–– !
.
––! "
Length
––" (
;
––( )
if
—— 
(
—— 
oldCapacity
—— 
==
—— 
newCapacity
—— *
)
——* +
{
˜˜ 
return
™™ 
;
™™ 
}
šš 
	PoolChunk
œœ 
<
œœ 
T
œœ 
>
œœ 
oldChunk
œœ !
=
œœ" #
buf
œœ$ '
.
œœ' (
Chunk
œœ( -
;
œœ- .
long
 
	oldHandle
 
=
 
buf
  
.
  !
Handle
! '
;
' (
T
 
	oldMemory
 
=
 
buf
 
.
 
Memory
 $
;
$ %
int
ŸŸ 
	oldOffset
ŸŸ 
=
ŸŸ 
buf
ŸŸ 
.
ŸŸ  
Offset
ŸŸ  &
;
ŸŸ& '
int
   
oldMaxLength
   
=
   
buf
   "
.
  " #
	MaxLength
  # ,
;
  , -
int
¡¡ 
readerIndex
¡¡ 
=
¡¡ 
buf
¡¡ !
.
¡¡! "
ReaderIndex
¡¡" -
;
¡¡- .
int
¢¢ 
writerIndex
¢¢ 
=
¢¢ 
buf
¢¢ !
.
¢¢! "
WriterIndex
¢¢" -
;
¢¢- .
this
¤¤ 
.
¤¤ 
Allocate
¤¤ 
(
¤¤ 
this
¤¤ 
.
¤¤ 
Parent
¤¤ %
.
¤¤% &
ThreadCache
¤¤& 1
<
¤¤1 2
T
¤¤2 3
>
¤¤3 4
(
¤¤4 5
)
¤¤5 6
,
¤¤6 7
buf
¤¤8 ;
,
¤¤; <
newCapacity
¤¤= H
)
¤¤H I
;
¤¤I J
if
¥¥ 
(
¥¥ 
newCapacity
¥¥ 
>
¥¥ 
oldCapacity
¥¥ )
)
¥¥) *
{
¦¦ 
this
§§ 
.
§§ 

MemoryCopy
§§ 
(
§§  
	oldMemory
¨¨ 
,
¨¨ 
	oldOffset
¨¨ (
,
¨¨( )
buf
©© 
.
©© 
Memory
©© 
,
©© 
buf
©©  #
.
©©# $
Offset
©©$ *
,
©©* +
oldCapacity
©©, 7
)
©©7 8
;
©©8 9
}
ªª 
else
«« 
if
«« 
(
«« 
newCapacity
««  
<
««! "
oldCapacity
««# .
)
««. /
{
¬¬ 
if
­­ 
(
­­ 
readerIndex
­­ 
<
­­  !
newCapacity
­­" -
)
­­- .
{
®® 
if
¯¯ 
(
¯¯ 
writerIndex
¯¯ #
>
¯¯$ %
newCapacity
¯¯& 1
)
¯¯1 2
{
°° 
writerIndex
±± #
=
±±$ %
newCapacity
±±& 1
;
±±1 2
}
²² 
this
³³ 
.
³³ 

MemoryCopy
³³ #
(
³³# $
	oldMemory
´´ !
,
´´! "
	oldOffset
´´# ,
+
´´- .
readerIndex
´´/ :
,
´´: ;
buf
µµ 
.
µµ 
Memory
µµ "
,
µµ" #
buf
µµ$ '
.
µµ' (
Offset
µµ( .
+
µµ/ 0
readerIndex
µµ1 <
,
µµ< =
writerIndex
µµ> I
-
µµJ K
readerIndex
µµL W
)
µµW X
;
µµX Y
}
¶¶ 
else
·· 
{
¸¸ 
readerIndex
¹¹ 
=
¹¹  !
writerIndex
¹¹" -
=
¹¹. /
newCapacity
¹¹0 ;
;
¹¹; <
}
ºº 
}
»» 
buf
½½ 
.
½½ 
SetIndex
½½ 
(
½½ 
readerIndex
½½ $
,
½½$ %
writerIndex
½½& 1
)
½½1 2
;
½½2 3
if
¿¿ 
(
¿¿ 
freeOldMemory
¿¿ 
)
¿¿ 
{
ÀÀ 
this
ÁÁ 
.
ÁÁ 
Free
ÁÁ 
(
ÁÁ 
oldChunk
ÁÁ "
,
ÁÁ" #
	oldHandle
ÁÁ$ -
,
ÁÁ- .
oldMaxLength
ÁÁ/ ;
,
ÁÁ; <
buf
ÁÁ= @
.
ÁÁ@ A
Cache
ÁÁA F
)
ÁÁF G
;
ÁÁG H
}
ÂÂ 
}
ÃÃ 	
internal
ÅÅ 
void
ÅÅ &
IncrementNumThreadCaches
ÅÅ .
(
ÅÅ. /
)
ÅÅ/ 0
=>
ÅÅ1 3
Interlocked
ÅÅ4 ?
.
ÅÅ? @
	Increment
ÅÅ@ I
(
ÅÅI J
ref
ÅÅJ M
this
ÅÅN R
.
ÅÅR S
numThreadCaches
ÅÅS b
)
ÅÅb c
;
ÅÅc d
internal
ÇÇ 
void
ÇÇ &
DecrementNumThreadCaches
ÇÇ .
(
ÇÇ. /
)
ÇÇ/ 0
=>
ÇÇ1 3
Interlocked
ÇÇ4 ?
.
ÇÇ? @
	Decrement
ÇÇ@ I
(
ÇÇI J
ref
ÇÇJ M
this
ÇÇN R
.
ÇÇR S
numThreadCaches
ÇÇS b
)
ÇÇb c
;
ÇÇc d
public
ÉÉ 
int
ÉÉ 
NumThreadCaches
ÉÉ "
=>
ÉÉ# %
Volatile
ÉÉ& .
.
ÉÉ. /
Read
ÉÉ/ 3
(
ÉÉ3 4
ref
ÉÉ4 7
this
ÉÉ8 <
.
ÉÉ< =
numThreadCaches
ÉÉ= L
)
ÉÉL M
;
ÉÉM N
public
ËË 
int
ËË 
NumTinySubpages
ËË "
=>
ËË# %
this
ËË& *
.
ËË* +
tinySubpagePools
ËË+ ;
.
ËË; <
Length
ËË< B
;
ËËB C
public
ÍÍ 
int
ÍÍ 
NumSmallSubpages
ÍÍ #
=>
ÍÍ$ &
this
ÍÍ' +
.
ÍÍ+ ,
smallSubpagePools
ÍÍ, =
.
ÍÍ= >
Length
ÍÍ> D
;
ÍÍD E
public
ÏÏ 
int
ÏÏ 
NumChunkLists
ÏÏ  
=>
ÏÏ! #
this
ÏÏ$ (
.
ÏÏ( )
chunkListMetrics
ÏÏ) 9
.
ÏÏ9 :
Count
ÏÏ: ?
;
ÏÏ? @
public
ÑÑ 
IReadOnlyList
ÑÑ 
<
ÑÑ  
IPoolSubpageMetric
ÑÑ /
>
ÑÑ/ 0
TinySubpages
ÑÑ1 =
=>
ÑÑ> @
SubPageMetricList
ÑÑA R
(
ÑÑR S
this
ÑÑS W
.
ÑÑW X
tinySubpagePools
ÑÑX h
)
ÑÑh i
;
ÑÑi j
public
ÓÓ 
IReadOnlyList
ÓÓ 
<
ÓÓ  
IPoolSubpageMetric
ÓÓ /
>
ÓÓ/ 0
SmallSubpages
ÓÓ1 >
=>
ÓÓ? A
SubPageMetricList
ÓÓB S
(
ÓÓS T
this
ÓÓT X
.
ÓÓX Y
smallSubpagePools
ÓÓY j
)
ÓÓj k
;
ÓÓk l
public
ÕÕ 
IReadOnlyList
ÕÕ 
<
ÕÕ "
IPoolChunkListMetric
ÕÕ 1
>
ÕÕ1 2

ChunkLists
ÕÕ3 =
=>
ÕÕ> @
this
ÕÕA E
.
ÕÕE F
chunkListMetrics
ÕÕF V
;
ÕÕV W
static
×× 
List
×× 
<
××  
IPoolSubpageMetric
×× &
>
××& '
SubPageMetricList
××( 9
(
××9 :
PoolSubpage
××: E
<
××E F
T
××F G
>
××G H
[
××H I
]
××I J
pages
××K P
)
××P Q
{
ØØ 	
var
ÙÙ 
metrics
ÙÙ 
=
ÙÙ 
new
ÙÙ 
List
ÙÙ "
<
ÙÙ" # 
IPoolSubpageMetric
ÙÙ# 5
>
ÙÙ5 6
(
ÙÙ6 7
)
ÙÙ7 8
;
ÙÙ8 9
foreach
ÚÚ 
(
ÚÚ 
PoolSubpage
ÚÚ  
<
ÚÚ  !
T
ÚÚ! "
>
ÚÚ" #
head
ÚÚ$ (
in
ÚÚ) +
pages
ÚÚ, 1
)
ÚÚ1 2
{
ÛÛ 
if
ÜÜ 
(
ÜÜ 
head
ÜÜ 
.
ÜÜ 
Next
ÜÜ 
==
ÜÜ  
head
ÜÜ! %
)
ÜÜ% &
{
İİ 
continue
ŞŞ 
;
ŞŞ 
}
ßß 
PoolSubpage
àà 
<
àà 
T
àà 
>
àà 
s
àà  
=
àà! "
head
àà# '
.
àà' (
Next
àà( ,
;
àà, -
for
áá 
(
áá 
;
áá 
;
áá 
)
áá 
{
ââ 
metrics
ãã 
.
ãã 
Add
ãã 
(
ãã  
s
ãã  !
)
ãã! "
;
ãã" #
s
ää 
=
ää 
s
ää 
.
ää 
Next
ää 
;
ää 
if
åå 
(
åå 
s
åå 
==
åå 
head
åå !
)
åå! "
{
ææ 
break
çç 
;
çç 
}
èè 
}
éé 
}
êê 
return
ëë 
metrics
ëë 
;
ëë 
}
ìì 	
public
îî 
long
îî 
NumAllocations
îî "
{
ïï 	
get
ğğ 
{
ññ 
long
òò 
allocsNormal
òò !
;
òò! "
lock
óó 
(
óó 
this
óó 
)
óó 
{
ôô 
allocsNormal
õõ  
=
õõ! "
this
õõ# '
.
õõ' (
allocationsNormal
õõ( 9
;
õõ9 :
}
öö 
return
øø 
this
øø 
.
øø  
NumTinyAllocations
øø .
+
øø/ 0
this
øø1 5
.
øø5 6!
NumSmallAllocations
øø6 I
+
øøJ K
allocsNormal
øøL X
+
øøY Z
this
øø[ _
.
øø_ ` 
NumHugeAllocations
øø` r
;
øør s
}
ùù 
}
úú 	
public
üü 
long
üü  
NumTinyAllocations
üü &
=>
üü' )
Volatile
üü* 2
.
üü2 3
Read
üü3 7
(
üü7 8
ref
üü8 ;
this
üü< @
.
üü@ A
allocationsTiny
üüA P
)
üüP Q
;
üüQ R
public
şş 
long
şş !
NumSmallAllocations
şş '
=>
şş( *
Volatile
şş+ 3
.
şş3 4
Read
şş4 8
(
şş8 9
ref
şş9 <
this
şş= A
.
şşA B
allocationsSmall
şşB R
)
şşR S
;
şşS T
public
€€ 
long
€€ "
NumNormalAllocations
€€ (
=>
€€) +
Volatile
€€, 4
.
€€4 5
Read
€€5 9
(
€€9 :
ref
€€: =
this
€€> B
.
€€B C
allocationsNormal
€€C T
)
€€T U
;
€€U V
public
‚‚ 
long
‚‚ 
NumDeallocations
‚‚ $
{
ƒƒ 	
get
„„ 
{
…… 
long
†† 
deallocs
†† 
;
†† 
lock
‡‡ 
(
‡‡ 
this
‡‡ 
)
‡‡ 
{
ˆˆ 
deallocs
‰‰ 
=
‰‰ 
this
‰‰ #
.
‰‰# $
deallocationsTiny
‰‰$ 5
+
‰‰6 7
this
‰‰8 <
.
‰‰< = 
deallocationsSmall
‰‰= O
+
‰‰P Q
this
‰‰R V
.
‰‰V W!
deallocationsNormal
‰‰W j
;
‰‰j k
}
ŠŠ 
return
ŒŒ 
deallocs
ŒŒ 
+
ŒŒ  !
this
ŒŒ" &
.
ŒŒ& '"
NumHugeDeallocations
ŒŒ' ;
;
ŒŒ; <
}
 
}
 	
public
 
long
 "
NumTinyDeallocations
 (
=>
) +
Volatile
, 4
.
4 5
Read
5 9
(
9 :
ref
: =
this
> B
.
B C
deallocationsTiny
C T
)
T U
;
U V
public
’’ 
long
’’ #
NumSmallDeallocations
’’ )
=>
’’* ,
Volatile
’’- 5
.
’’5 6
Read
’’6 :
(
’’: ;
ref
’’; >
this
’’? C
.
’’C D 
deallocationsSmall
’’D V
)
’’V W
;
’’W X
public
”” 
long
”” $
NumNormalDeallocations
”” *
=>
””+ -
Volatile
””. 6
.
””6 7
Read
””7 ;
(
””; <
ref
””< ?
this
””@ D
.
””D E!
deallocationsNormal
””E X
)
””X Y
;
””Y Z
public
–– 
long
––  
NumHugeAllocations
–– &
=>
––' )
Volatile
––* 2
.
––2 3
Read
––3 7
(
––7 8
ref
––8 ;
this
––< @
.
––@ A
allocationsHuge
––A P
)
––P Q
;
––Q R
public
˜˜ 
long
˜˜ "
NumHugeDeallocations
˜˜ (
=>
˜˜) +
Volatile
˜˜, 4
.
˜˜4 5
Read
˜˜5 9
(
˜˜9 :
ref
˜˜: =
this
˜˜> B
.
˜˜B C
deallocationsHuge
˜˜C T
)
˜˜T U
;
˜˜U V
public
šš 
long
šš "
NumActiveAllocations
šš (
{
›› 	
get
œœ 
{
 
long
 
val
 
=
 
this
 
.
   
NumTinyAllocations
  2
+
3 4
this
5 9
.
9 :!
NumSmallAllocations
: M
+
N O
this
P T
.
T U 
NumHugeAllocations
U g
-
ŸŸ 
this
ŸŸ 
.
ŸŸ "
NumHugeDeallocations
ŸŸ /
;
ŸŸ/ 0
lock
   
(
   
this
   
)
   
{
¡¡ 
val
¢¢ 
+=
¢¢ 
this
¢¢ 
.
¢¢  
allocationsNormal
¢¢  1
-
¢¢2 3
(
¢¢4 5
this
¢¢5 9
.
¢¢9 :
deallocationsTiny
¢¢: K
+
¢¢L M
this
¢¢N R
.
¢¢R S 
deallocationsSmall
¢¢S e
+
¢¢f g
this
¢¢h l
.
¢¢l m"
deallocationsNormal¢¢m €
)¢¢€ 
;¢¢ ‚
}
££ 
return
¤¤ 
Math
¤¤ 
.
¤¤ 
Max
¤¤ 
(
¤¤  
val
¤¤  #
,
¤¤# $
$num
¤¤% &
)
¤¤& '
;
¤¤' (
}
¥¥ 
}
¦¦ 	
public
¨¨ 
long
¨¨ &
NumActiveTinyAllocations
¨¨ ,
=>
¨¨- /
Math
¨¨0 4
.
¨¨4 5
Max
¨¨5 8
(
¨¨8 9
this
¨¨9 =
.
¨¨= > 
NumTinyAllocations
¨¨> P
-
¨¨Q R
this
¨¨S W
.
¨¨W X"
NumTinyDeallocations
¨¨X l
,
¨¨l m
$num
¨¨n o
)
¨¨o p
;
¨¨p q
public
ªª 
long
ªª '
NumActiveSmallAllocations
ªª -
=>
ªª. 0
Math
ªª1 5
.
ªª5 6
Max
ªª6 9
(
ªª9 :
this
ªª: >
.
ªª> ?!
NumSmallAllocations
ªª? R
-
ªªS T
this
ªªU Y
.
ªªY Z#
NumSmallDeallocations
ªªZ o
,
ªªo p
$num
ªªq r
)
ªªr s
;
ªªs t
public
¬¬ 
long
¬¬ (
NumActiveNormalAllocations
¬¬ .
{
­­ 	
get
®® 
{
¯¯ 
long
°° 
val
°° 
;
°° 
lock
±± 
(
±± 
this
±± 
)
±± 
{
²² 
val
³³ 
=
³³ 
this
³³ 
.
³³ 
allocationsNormal
³³ 0
-
³³1 2
this
³³3 7
.
³³7 8!
deallocationsNormal
³³8 K
;
³³K L
}
´´ 
return
µµ 
Math
µµ 
.
µµ 
Max
µµ 
(
µµ  
val
µµ  #
,
µµ# $
$num
µµ% &
)
µµ& '
;
µµ' (
}
¶¶ 
}
·· 	
public
¹¹ 
long
¹¹ &
NumActiveHugeAllocations
¹¹ ,
=>
¹¹- /
Math
¹¹0 4
.
¹¹4 5
Max
¹¹5 8
(
¹¹8 9
this
¹¹9 =
.
¹¹= > 
NumHugeAllocations
¹¹> P
-
¹¹Q R
this
¹¹S W
.
¹¹W X"
NumHugeDeallocations
¹¹X l
,
¹¹l m
$num
¹¹n o
)
¹¹o p
;
¹¹p q
public
»» 
long
»» 
NumActiveBytes
»» "
{
¼¼ 	
get
½½ 
{
¾¾ 
long
¿¿ 
val
¿¿ 
=
¿¿ 
Volatile
¿¿ #
.
¿¿# $
Read
¿¿$ (
(
¿¿( )
ref
¿¿) ,
this
¿¿- 1
.
¿¿1 2
activeBytesHuge
¿¿2 A
)
¿¿A B
;
¿¿B C
lock
ÀÀ 
(
ÀÀ 
this
ÀÀ 
)
ÀÀ 
{
ÁÁ 
foreach
ÂÂ 
(
ÂÂ "
IPoolChunkListMetric
ÂÂ 1
t
ÂÂ2 3
in
ÂÂ4 6
this
ÂÂ7 ;
.
ÂÂ; <
chunkListMetrics
ÂÂ< L
)
ÂÂL M
{
ÃÃ 
foreach
ÄÄ 
(
ÄÄ  !
IPoolChunkMetric
ÄÄ! 1
m
ÄÄ2 3
in
ÄÄ4 6
t
ÄÄ7 8
)
ÄÄ8 9
{
ÅÅ 
val
ÆÆ 
+=
ÆÆ  "
m
ÆÆ# $
.
ÆÆ$ %
	ChunkSize
ÆÆ% .
;
ÆÆ. /
}
ÇÇ 
}
ÈÈ 
}
ÉÉ 
return
ÊÊ 
Math
ÊÊ 
.
ÊÊ 
Max
ÊÊ 
(
ÊÊ  
$num
ÊÊ  !
,
ÊÊ! "
val
ÊÊ# &
)
ÊÊ& '
;
ÊÊ' (
}
ËË 
}
ÌÌ 	
	protected
ÎÎ 
abstract
ÎÎ 
	PoolChunk
ÎÎ $
<
ÎÎ$ %
T
ÎÎ% &
>
ÎÎ& '
NewChunk
ÎÎ( 0
(
ÎÎ0 1
int
ÎÎ1 4
pageSize
ÎÎ5 =
,
ÎÎ= >
int
ÎÎ? B
maxOrder
ÎÎC K
,
ÎÎK L
int
ÎÎM P

pageShifts
ÎÎQ [
,
ÎÎ[ \
int
ÎÎ] `
	chunkSize
ÎÎa j
)
ÎÎj k
;
ÎÎk l
	protected
ĞĞ 
abstract
ĞĞ 
	PoolChunk
ĞĞ $
<
ĞĞ$ %
T
ĞĞ% &
>
ĞĞ& '
NewUnpooledChunk
ĞĞ( 8
(
ĞĞ8 9
int
ĞĞ9 <
capacity
ĞĞ= E
)
ĞĞE F
;
ĞĞF G
	protected
ÒÒ 
abstract
ÒÒ 
PooledByteBuffer
ÒÒ +
<
ÒÒ+ ,
T
ÒÒ, -
>
ÒÒ- .

NewByteBuf
ÒÒ/ 9
(
ÒÒ9 :
int
ÒÒ: =
maxCapacity
ÒÒ> I
)
ÒÒI J
;
ÒÒJ K
	protected
ÔÔ 
abstract
ÔÔ 
void
ÔÔ 

MemoryCopy
ÔÔ  *
(
ÔÔ* +
T
ÔÔ+ ,
src
ÔÔ- 0
,
ÔÔ0 1
int
ÔÔ2 5
	srcOffset
ÔÔ6 ?
,
ÔÔ? @
T
ÔÔA B
dst
ÔÔC F
,
ÔÔF G
int
ÔÔH K
	dstOffset
ÔÔL U
,
ÔÔU V
int
ÔÔW Z
length
ÔÔ[ a
)
ÔÔa b
;
ÔÔb c
	protected
ÖÖ 
internal
ÖÖ 
abstract
ÖÖ #
void
ÖÖ$ (
DestroyChunk
ÖÖ) 5
(
ÖÖ5 6
	PoolChunk
ÖÖ6 ?
<
ÖÖ? @
T
ÖÖ@ A
>
ÖÖA B
chunk
ÖÖC H
)
ÖÖH I
;
ÖÖI J
public
ØØ 
override
ØØ 
string
ØØ 
ToString
ØØ '
(
ØØ' (
)
ØØ( )
{
ÙÙ 	
StringBuilder
ÚÚ 
buf
ÚÚ 
=
ÚÚ 
new
ÚÚ  #
StringBuilder
ÚÚ$ 1
(
ÚÚ1 2
)
ÚÚ2 3
.
ÛÛ 
Append
ÛÛ 
(
ÛÛ 
$str
ÛÛ ,
)
ÛÛ, -
.
ÜÜ 
Append
ÜÜ 
(
ÜÜ 

StringUtil
ÜÜ "
.
ÜÜ" #
Newline
ÜÜ# *
)
ÜÜ* +
.
İİ 
Append
İİ 
(
İİ 
this
İİ 
.
İİ 
qInit
İİ "
)
İİ" #
.
ŞŞ 
Append
ŞŞ 
(
ŞŞ 

StringUtil
ŞŞ "
.
ŞŞ" #
Newline
ŞŞ# *
)
ŞŞ* +
.
ßß 
Append
ßß 
(
ßß 
$str
ßß ,
)
ßß, -
.
àà 
Append
àà 
(
àà 

StringUtil
àà "
.
àà" #
Newline
àà# *
)
àà* +
.
áá 
Append
áá 
(
áá 
this
áá 
.
áá 
q000
áá !
)
áá! "
.
ââ 
Append
ââ 
(
ââ 

StringUtil
ââ "
.
ââ" #
Newline
ââ# *
)
ââ* +
.
ãã 
Append
ãã 
(
ãã 
$str
ãã -
)
ãã- .
.
ää 
Append
ää 
(
ää 

StringUtil
ää "
.
ää" #
Newline
ää# *
)
ää* +
.
åå 
Append
åå 
(
åå 
this
åå 
.
åå 
q025
åå !
)
åå! "
.
ææ 
Append
ææ 
(
ææ 

StringUtil
ææ "
.
ææ" #
Newline
ææ# *
)
ææ* +
.
çç 
Append
çç 
(
çç 
$str
çç .
)
çç. /
.
èè 
Append
èè 
(
èè 

StringUtil
èè "
.
èè" #
Newline
èè# *
)
èè* +
.
éé 
Append
éé 
(
éé 
this
éé 
.
éé 
q050
éé !
)
éé! "
.
êê 
Append
êê 
(
êê 

StringUtil
êê "
.
êê" #
Newline
êê# *
)
êê* +
.
ëë 
Append
ëë 
(
ëë 
$str
ëë .
)
ëë. /
.
ìì 
Append
ìì 
(
ìì 

StringUtil
ìì "
.
ìì" #
Newline
ìì# *
)
ìì* +
.
íí 
Append
íí 
(
íí 
this
íí 
.
íí 
q075
íí !
)
íí! "
.
îî 
Append
îî 
(
îî 

StringUtil
îî "
.
îî" #
Newline
îî# *
)
îî* +
.
ïï 
Append
ïï 
(
ïï 
$str
ïï +
)
ïï+ ,
.
ğğ 
Append
ğğ 
(
ğğ 

StringUtil
ğğ "
.
ğğ" #
Newline
ğğ# *
)
ğğ* +
.
ññ 
Append
ññ 
(
ññ 
this
ññ 
.
ññ 
q100
ññ !
)
ññ! "
.
òò 
Append
òò 
(
òò 

StringUtil
òò "
.
òò" #
Newline
òò# *
)
òò* +
.
óó 
Append
óó 
(
óó 
$str
óó (
)
óó( )
;
óó) * 
AppendPoolSubPages
ôô 
(
ôô 
buf
ôô "
,
ôô" #
this
ôô$ (
.
ôô( )
tinySubpagePools
ôô) 9
)
ôô9 :
;
ôô: ;
buf
õõ 
.
õõ 
Append
õõ 
(
õõ 

StringUtil
õõ !
.
õõ! "
Newline
õõ" )
)
õõ) *
.
öö 
Append
öö 
(
öö 
$str
öö )
)
öö) *
;
öö* + 
AppendPoolSubPages
÷÷ 
(
÷÷ 
buf
÷÷ "
,
÷÷" #
this
÷÷$ (
.
÷÷( )
smallSubpagePools
÷÷) :
)
÷÷: ;
;
÷÷; <
buf
øø 
.
øø 
Append
øø 
(
øø 

StringUtil
øø !
.
øø! "
Newline
øø" )
)
øø) *
;
øø* +
return
úú 
buf
úú 
.
úú 
ToString
úú 
(
úú  
)
úú  !
;
úú! "
}
ûû 	
static
ıı 
void
ıı  
AppendPoolSubPages
ıı &
(
ıı& '
StringBuilder
ıı' 4
buf
ıı5 8
,
ıı8 9
PoolSubpage
ıı: E
<
ııE F
T
ııF G
>
ııG H
[
ııH I
]
ııI J
subpages
ııK S
)
ııS T
{
şş 	
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
i
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
i
ÿÿ 
<
ÿÿ 
subpages
ÿÿ  (
.
ÿÿ( )
Length
ÿÿ) /
;
ÿÿ/ 0
i
ÿÿ1 2
++
ÿÿ2 4
)
ÿÿ4 5
{
€€ 
PoolSubpage
 
<
 
T
 
>
 
head
 #
=
$ %
subpages
& .
[
. /
i
/ 0
]
0 1
;
1 2
if
‚‚ 
(
‚‚ 
head
‚‚ 
.
‚‚ 
Next
‚‚ 
==
‚‚  
head
‚‚! %
)
‚‚% &
{
ƒƒ 
continue
„„ 
;
„„ 
}
…… 
buf
‡‡ 
.
‡‡ 
Append
‡‡ 
(
‡‡ 

StringUtil
‡‡ %
.
‡‡% &
Newline
‡‡& -
)
‡‡- .
.
ˆˆ 
Append
ˆˆ 
(
ˆˆ 
i
ˆˆ 
)
ˆˆ 
.
‰‰ 
Append
‰‰ 
(
‰‰ 
$str
‰‰  
)
‰‰  !
;
‰‰! "
PoolSubpage
ŠŠ 
<
ŠŠ 
T
ŠŠ 
>
ŠŠ 
s
ŠŠ  
=
ŠŠ! "
head
ŠŠ# '
.
ŠŠ' (
Next
ŠŠ( ,
;
ŠŠ, -
for
‹‹ 
(
‹‹ 
;
‹‹ 
;
‹‹ 
)
‹‹ 
{
ŒŒ 
buf
 
.
 
Append
 
(
 
s
  
)
  !
;
! "
s
 
=
 
s
 
.
 
Next
 
;
 
if
 
(
 
s
 
==
 
head
 !
)
! "
{
 
break
‘‘ 
;
‘‘ 
}
’’ 
}
““ 
}
”” 
}
•• 	
~
—— 	
	PoolArena
——	 
(
—— 
)
—— 
{
˜˜ 	!
DestroyPoolSubPages
™™ 
(
™™  
this
™™  $
.
™™$ %
smallSubpagePools
™™% 6
)
™™6 7
;
™™7 8!
DestroyPoolSubPages
šš 
(
šš  
this
šš  $
.
šš$ %
tinySubpagePools
šš% 5
)
šš5 6
;
šš6 7
this
›› 
.
›› #
DestroyPoolChunkLists
›› &
(
››& '
this
››' +
.
››+ ,
qInit
››, 1
,
››1 2
this
››3 7
.
››7 8
q000
››8 <
,
››< =
this
››> B
.
››B C
q025
››C G
,
››G H
this
››I M
.
››M N
q050
››N R
,
››R S
this
››T X
.
››X Y
q075
››Y ]
,
››] ^
this
››_ c
.
››c d
q100
››d h
)
››h i
;
››i j
}
œœ 	
static
 
void
 !
DestroyPoolSubPages
 '
(
' (
PoolSubpage
( 3
<
3 4
T
4 5
>
5 6
[
6 7
]
7 8
pages
9 >
)
> ?
{
ŸŸ 	
foreach
   
(
   
PoolSubpage
    
<
    !
T
  ! "
>
  " #
page
  $ (
in
  ) +
pages
  , 1
)
  1 2
{
¡¡ 
page
¢¢ 
.
¢¢ 
Destroy
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
}
££ 
}
¤¤ 	
void
¦¦ #
DestroyPoolChunkLists
¦¦ "
(
¦¦" #
params
¦¦# )
PoolChunkList
¦¦* 7
<
¦¦7 8
T
¦¦8 9
>
¦¦9 :
[
¦¦: ;
]
¦¦; <

chunkLists
¦¦= G
)
¦¦G H
{
§§ 	
foreach
¨¨ 
(
¨¨ 
PoolChunkList
¨¨ "
<
¨¨" #
T
¨¨# $
>
¨¨$ %
	chunkList
¨¨& /
in
¨¨0 2

chunkLists
¨¨3 =
)
¨¨= >
{
©© 
	chunkList
ªª 
.
ªª 
Destroy
ªª !
(
ªª! "
this
ªª" &
)
ªª& '
;
ªª' (
}
«« 
}
¬¬ 	
}
­­ 
sealed
¯¯ 

class
¯¯ 
	HeapArena
¯¯ 
:
¯¯ 
	PoolArena
¯¯ &
<
¯¯& '
byte
¯¯' +
[
¯¯+ ,
]
¯¯, -
>
¯¯- .
{
°° 
public
±± 
	HeapArena
±± 
(
±± '
PooledByteBufferAllocator
±± 2
parent
±±3 9
,
±±9 :
int
±±; >
pageSize
±±? G
,
±±G H
int
±±I L
maxOrder
±±M U
,
±±U V
int
±±W Z

pageShifts
±±[ e
,
±±e f
int
±±g j
	chunkSize
±±k t
)
±±t u
:
²² 
base
²² 
(
²² 
parent
²² 
,
²² 
pageSize
²² #
,
²²# $
maxOrder
²²% -
,
²²- .

pageShifts
²²/ 9
,
²²9 :
	chunkSize
²²; D
)
²²D E
{
³³ 	
}
´´ 	
static
¶¶ 
byte
¶¶ 
[
¶¶ 
]
¶¶ 
NewByteArray
¶¶ "
(
¶¶" #
int
¶¶# &
size
¶¶' +
)
¶¶+ ,
=>
¶¶- /
new
¶¶0 3
byte
¶¶4 8
[
¶¶8 9
size
¶¶9 =
]
¶¶= >
;
¶¶> ?
internal
¸¸ 
override
¸¸ 
bool
¸¸ 
IsDirect
¸¸ '
=>
¸¸( *
false
¸¸+ 0
;
¸¸0 1
	protected
ºº 
override
ºº 
	PoolChunk
ºº $
<
ºº$ %
byte
ºº% )
[
ºº) *
]
ºº* +
>
ºº+ ,
NewChunk
ºº- 5
(
ºº5 6
int
ºº6 9
pageSize
ºº: B
,
ººB C
int
ººD G
maxOrder
ººH P
,
ººP Q
int
ººR U

pageShifts
ººV `
,
ºº` a
int
ººb e
	chunkSize
ººf o
)
ººo p
=>
ººq s
new
»» 
	PoolChunk
»» 
<
»» 
byte
»» 
[
»» 
]
»»  
>
»»  !
(
»»! "
this
»»" &
,
»»& '
NewByteArray
»»( 4
(
»»4 5
	chunkSize
»»5 >
)
»»> ?
,
»»? @
pageSize
»»A I
,
»»I J
maxOrder
»»K S
,
»»S T

pageShifts
»»U _
,
»»_ `
	chunkSize
»»a j
,
»»j k
$num
»»l m
)
»»m n
;
»»n o
	protected
½½ 
override
½½ 
	PoolChunk
½½ $
<
½½$ %
byte
½½% )
[
½½) *
]
½½* +
>
½½+ ,
NewUnpooledChunk
½½- =
(
½½= >
int
½½> A
capacity
½½B J
)
½½J K
=>
½½L N
new
¾¾ 
	PoolChunk
¾¾ 
<
¾¾ 
byte
¾¾ 
[
¾¾ 
]
¾¾  
>
¾¾  !
(
¾¾! "
this
¾¾" &
,
¾¾& '
NewByteArray
¾¾( 4
(
¾¾4 5
capacity
¾¾5 =
)
¾¾= >
,
¾¾> ?
capacity
¾¾@ H
,
¾¾H I
$num
¾¾J K
)
¾¾K L
;
¾¾L M
	protected
ÀÀ 
internal
ÀÀ 
override
ÀÀ #
void
ÀÀ$ (
DestroyChunk
ÀÀ) 5
(
ÀÀ5 6
	PoolChunk
ÀÀ6 ?
<
ÀÀ? @
byte
ÀÀ@ D
[
ÀÀD E
]
ÀÀE F
>
ÀÀF G
chunk
ÀÀH M
)
ÀÀM N
{
ÁÁ 	
}
ÃÃ 	
	protected
ÅÅ 
override
ÅÅ 
PooledByteBuffer
ÅÅ +
<
ÅÅ+ ,
byte
ÅÅ, 0
[
ÅÅ0 1
]
ÅÅ1 2
>
ÅÅ2 3

NewByteBuf
ÅÅ4 >
(
ÅÅ> ?
int
ÅÅ? B
maxCapacity
ÅÅC N
)
ÅÅN O
=>
ÅÅP R"
PooledHeapByteBuffer
ÆÆ  
.
ÆÆ  !
NewInstance
ÆÆ! ,
(
ÆÆ, -
maxCapacity
ÆÆ- 8
)
ÆÆ8 9
;
ÆÆ9 :
	protected
ÈÈ 
override
ÈÈ 
void
ÈÈ 

MemoryCopy
ÈÈ  *
(
ÈÈ* +
byte
ÈÈ+ /
[
ÈÈ/ 0
]
ÈÈ0 1
src
ÈÈ2 5
,
ÈÈ5 6
int
ÈÈ7 :
	srcOffset
ÈÈ; D
,
ÈÈD E
byte
ÈÈF J
[
ÈÈJ K
]
ÈÈK L
dst
ÈÈM P
,
ÈÈP Q
int
ÈÈR U
	dstOffset
ÈÈV _
,
ÈÈ_ `
int
ÈÈa d
length
ÈÈe k
)
ÈÈk l
{
ÉÉ 	
if
ÊÊ 
(
ÊÊ 
length
ÊÊ 
==
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
{
ËË 
return
ÌÌ 
;
ÌÌ 
}
ÍÍ 
PlatformDependent
ÏÏ 
.
ÏÏ 

CopyMemory
ÏÏ (
(
ÏÏ( )
src
ÏÏ) ,
,
ÏÏ, -
	srcOffset
ÏÏ. 7
,
ÏÏ7 8
dst
ÏÏ9 <
,
ÏÏ< =
	dstOffset
ÏÏ> G
,
ÏÏG H
length
ÏÏI O
)
ÏÏO P
;
ÏÏP Q
}
ĞĞ 	
}
ÑÑ 
sealed
ÔÔ 

class
ÔÔ 
DirectArena
ÔÔ 
:
ÔÔ 
	PoolArena
ÔÔ (
<
ÔÔ( )
byte
ÔÔ) -
[
ÔÔ- .
]
ÔÔ. /
>
ÔÔ/ 0
{
ÕÕ 
readonly
ÖÖ 
List
ÖÖ 
<
ÖÖ 
MemoryChunk
ÖÖ !
>
ÖÖ! "
memoryChunks
ÖÖ# /
;
ÖÖ/ 0
public
ØØ 
DirectArena
ØØ 
(
ØØ '
PooledByteBufferAllocator
ØØ 4
parent
ØØ5 ;
,
ØØ; <
int
ØØ= @
pageSize
ØØA I
,
ØØI J
int
ØØK N
maxOrder
ØØO W
,
ØØW X
int
ØØY \

pageShifts
ØØ] g
,
ØØg h
int
ØØi l
	chunkSize
ØØm v
)
ØØv w
:
ÙÙ 
base
ÙÙ 
(
ÙÙ 
parent
ÙÙ 
,
ÙÙ 
pageSize
ÙÙ #
,
ÙÙ# $
maxOrder
ÙÙ% -
,
ÙÙ- .

pageShifts
ÙÙ/ 9
,
ÙÙ9 :
	chunkSize
ÙÙ; D
)
ÙÙD E
{
ÚÚ 	
this
ÛÛ 
.
ÛÛ 
memoryChunks
ÛÛ 
=
ÛÛ 
new
ÛÛ  #
List
ÛÛ$ (
<
ÛÛ( )
MemoryChunk
ÛÛ) 4
>
ÛÛ4 5
(
ÛÛ5 6
)
ÛÛ6 7
;
ÛÛ7 8
}
ÜÜ 	
static
ŞŞ 
MemoryChunk
ŞŞ 
NewMemoryChunk
ŞŞ )
(
ŞŞ) *
int
ŞŞ* -
size
ŞŞ. 2
)
ŞŞ2 3
=>
ŞŞ4 6
new
ŞŞ7 :
MemoryChunk
ŞŞ; F
(
ŞŞF G
size
ŞŞG K
)
ŞŞK L
;
ŞŞL M
internal
àà 
override
àà 
bool
àà 
IsDirect
àà '
=>
àà( *
true
àà+ /
;
àà/ 0
	protected
ââ 
override
ââ 
	PoolChunk
ââ $
<
ââ$ %
byte
ââ% )
[
ââ) *
]
ââ* +
>
ââ+ ,
NewChunk
ââ- 5
(
ââ5 6
int
ââ6 9
pageSize
ââ: B
,
ââB C
int
ââD G
maxOrder
ââH P
,
ââP Q
int
ââR U

pageShifts
ââV `
,
ââ` a
int
ââb e
	chunkSize
ââf o
)
ââo p
{
ãã 	
MemoryChunk
ää 
memoryChunk
ää #
=
ää$ %
NewMemoryChunk
ää& 4
(
ää4 5
	chunkSize
ää5 >
)
ää> ?
;
ää? @
this
åå 
.
åå 
memoryChunks
åå 
.
åå 
Add
åå !
(
åå! "
memoryChunk
åå" -
)
åå- .
;
åå. /
var
ææ 
chunk
ææ 
=
ææ 
new
ææ 
	PoolChunk
ææ %
<
ææ% &
byte
ææ& *
[
ææ* +
]
ææ+ ,
>
ææ, -
(
ææ- .
this
ææ. 2
,
ææ2 3
memoryChunk
ææ4 ?
.
ææ? @
Bytes
ææ@ E
,
ææE F
pageSize
ææG O
,
ææO P
maxOrder
ææQ Y
,
ææY Z

pageShifts
ææ[ e
,
ææe f
	chunkSize
ææg p
,
ææp q
$num
æær s
)
ææs t
;
ææt u
return
çç 
chunk
çç 
;
çç 
}
èè 	
	protected
êê 
override
êê 
	PoolChunk
êê $
<
êê$ %
byte
êê% )
[
êê) *
]
êê* +
>
êê+ ,
NewUnpooledChunk
êê- =
(
êê= >
int
êê> A
capacity
êêB J
)
êêJ K
{
ëë 	
MemoryChunk
ìì 
memoryChunk
ìì #
=
ìì$ %
NewMemoryChunk
ìì& 4
(
ìì4 5
capacity
ìì5 =
)
ìì= >
;
ìì> ?
this
íí 
.
íí 
memoryChunks
íí 
.
íí 
Add
íí !
(
íí! "
memoryChunk
íí" -
)
íí- .
;
íí. /
var
îî 
chunk
îî 
=
îî 
new
îî 
	PoolChunk
îî %
<
îî% &
byte
îî& *
[
îî* +
]
îî+ ,
>
îî, -
(
îî- .
this
îî. 2
,
îî2 3
memoryChunk
îî4 ?
.
îî? @
Bytes
îî@ E
,
îîE F
capacity
îîG O
,
îîO P
$num
îîQ R
)
îîR S
;
îîS T
return
ïï 
chunk
ïï 
;
ïï 
}
ğğ 	
	protected
òò 
override
òò 
PooledByteBuffer
òò +
<
òò+ ,
byte
òò, 0
[
òò0 1
]
òò1 2
>
òò2 3

NewByteBuf
òò4 >
(
òò> ?
int
òò? B
maxCapacity
òòC N
)
òòN O
=>
òòP R*
PooledUnsafeDirectByteBuffer
óó (
.
óó( )
NewInstance
óó) 4
(
óó4 5
maxCapacity
óó5 @
)
óó@ A
;
óóA B
	protected
õõ 
override
õõ 
unsafe
õõ !
void
õõ" &

MemoryCopy
õõ' 1
(
õõ1 2
byte
õõ2 6
[
õõ6 7
]
õõ7 8
src
õõ9 <
,
õõ< =
int
õõ> A
	srcOffset
õõB K
,
õõK L
byte
õõM Q
[
õõQ R
]
õõR S
dst
õõT W
,
õõW X
int
õõY \
	dstOffset
õõ] f
,
õõf g
int
õõh k
length
õõl r
)
õõr s
=>
õõt v
PlatformDependent
öö !
.
öö! "

CopyMemory
öö" ,
(
öö, -
(
öö- .
byte
öö. 2
*
öö2 3
)
öö3 4
Unsafe
öö4 :
.
öö: ;
	AsPointer
öö; D
(
ööD E
ref
ööE H
src
ööI L
[
ööL M
	srcOffset
ööM V
]
ööV W
)
ööW X
,
ööX Y
(
ööZ [
byte
öö[ _
*
öö_ `
)
öö` a
Unsafe
ööa g
.
öög h
	AsPointer
ööh q
(
ööq r
ref
öör u
dst
ööv y
[
ööy z
	dstOffsetööz ƒ
]ööƒ „
)öö„ …
,öö… †
lengthöö‡ 
)öö 
;öö 
	protected
øø 
internal
øø 
override
øø #
void
øø$ (
DestroyChunk
øø) 5
(
øø5 6
	PoolChunk
øø6 ?
<
øø? @
byte
øø@ D
[
øøD E
]
øøE F
>
øøF G
chunk
øøH M
)
øøM N
{
ùù 	
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 
this
úú  $
.
úú$ %
memoryChunks
úú% 1
.
úú1 2
Count
úú2 7
;
úú7 8
i
úú9 :
++
úú: <
)
úú< =
{
ûû 
MemoryChunk
üü 
memoryChunk
üü '
=
üü( )
this
üü* .
.
üü. /
memoryChunks
üü/ ;
[
üü; <
i
üü< =
]
üü= >
;
üü> ?
if
ıı 
(
ıı 
ReferenceEquals
ıı #
(
ıı# $
chunk
ıı$ )
.
ıı) *
Memory
ıı* 0
,
ıı0 1
memoryChunk
ıı2 =
.
ıı= >
Bytes
ıı> C
)
ııC D
)
ııD E
{
şş 
this
ÿÿ 
.
ÿÿ 
memoryChunks
ÿÿ %
.
ÿÿ% &
Remove
ÿÿ& ,
(
ÿÿ, -
memoryChunk
ÿÿ- 8
)
ÿÿ8 9
;
ÿÿ9 :
memoryChunk
€€ 
.
€€  
Dispose
€€  '
(
€€' (
)
€€( )
;
€€) *
break
 
;
 
}
‚‚ 
}
ƒƒ 
}
„„ 	
sealed
†† 
class
†† 
MemoryChunk
††  
:
††! "
IDisposable
††# .
{
‡‡ 	
internal
ˆˆ 
byte
ˆˆ 
[
ˆˆ 
]
ˆˆ 
Bytes
ˆˆ !
;
ˆˆ! "
GCHandle
‰‰ 
handle
‰‰ 
;
‰‰ 
internal
‹‹ 
MemoryChunk
‹‹  
(
‹‹  !
int
‹‹! $
size
‹‹% )
)
‹‹) *
{
ŒŒ 
this
 
.
 
Bytes
 
=
 
new
  
byte
! %
[
% &
size
& *
]
* +
;
+ ,
this
 
.
 
handle
 
=
 
GCHandle
 &
.
& '
Alloc
' ,
(
, -
this
- 1
.
1 2
Bytes
2 7
,
7 8
GCHandleType
9 E
.
E F
Pinned
F L
)
L M
;
M N
}
 
void
‘‘ 
Release
‘‘ 
(
‘‘ 
)
‘‘ 
{
’’ 
if
““ 
(
““ 
this
““ 
.
““ 
handle
““ 
.
““  
IsAllocated
““  +
)
““+ ,
{
”” 
try
•• 
{
–– 
this
—— 
.
—— 
handle
—— #
.
——# $
Free
——$ (
(
——( )
)
——) *
;
——* +
}
˜˜ 
catch
™™ 
(
™™ '
InvalidOperationException
™™ 4
)
™™4 5
{
šš 
}
œœ 
}
 
this
 
.
 
Bytes
 
=
 
null
 !
;
! "
}
ŸŸ 
public
¡¡ 
void
¡¡ 
Dispose
¡¡ 
(
¡¡  
)
¡¡  !
{
¢¢ 
this
££ 
.
££ 
Release
££ 
(
££ 
)
££ 
;
££ 
GC
¤¤ 
.
¤¤ 
SuppressFinalize
¤¤ #
(
¤¤# $
this
¤¤$ (
)
¤¤( )
;
¤¤) *
}
¥¥ 
~
§§ 
MemoryChunk
§§ 
(
§§ 
)
§§ 
{
¨¨ 
this
©© 
.
©© 
Release
©© 
(
©© 
)
©© 
;
©© 
}
ªª 
}
«« 	
}
¬¬ 
}­­ À¢
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolChunk.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealedPP 

classPP 
	PoolChunkPP 
<PP 
TPP 
>PP 
:PP 
IPoolChunkMetricPP  0
{QQ 
constRR 
intRR 
IntegerSizeMinusOneRR %
=RR& '
sizeofRR( .
(RR. /
intRR/ 2
)RR2 3
*RR4 5
$numRR6 7
-RR8 9
$numRR: ;
;RR; <
internalTT 
readonlyTT 
	PoolArenaTT #
<TT# $
TTT$ %
>TT% &
ArenaTT' ,
;TT, -
internalUU 
readonlyUU 
TUU 
MemoryUU "
;UU" #
internalVV 
readonlyVV 
boolVV 
UnpooledVV '
;VV' (
internalWW 
readonlyWW 
intWW 
OffsetWW $
;WW$ %
readonlyYY 
sbyteYY 
[YY 
]YY 
	memoryMapYY "
;YY" #
readonlyZZ 
sbyteZZ 
[ZZ 
]ZZ 
depthMapZZ !
;ZZ! "
readonly[[ 
PoolSubpage[[ 
<[[ 
T[[ 
>[[ 
[[[  
][[  !
subpages[[" *
;[[* +
readonly]] 
int]] 
subpageOverflowMask]] (
;]]( )
readonly^^ 
int^^ 
pageSize^^ 
;^^ 
readonly__ 
int__ 

pageShifts__ 
;__  
readonly`` 
int`` 
maxOrder`` 
;`` 
readonlyaa 
intaa 
	chunkSizeaa 
;aa 
readonlybb 
intbb 
log2ChunkSizebb "
;bb" #
readonlycc 
intcc 
maxSubpageAllocscc %
;cc% &
readonlyee 
sbyteee 
unusableee 
;ee  
intgg 
	freeBytesgg 
;gg 
internalii 
PoolChunkListii 
<ii 
Tii  
>ii  !
Parentii" (
;ii( )
internaljj 
	PoolChunkjj 
<jj 
Tjj 
>jj 
Prevjj "
;jj" #
internalkk 
	PoolChunkkk 
<kk 
Tkk 
>kk 
Nextkk "
;kk" #
internalpp 
	PoolChunkpp 
(pp 
	PoolArenapp $
<pp$ %
Tpp% &
>pp& '
arenapp( -
,pp- .
Tpp/ 0
memorypp1 7
,pp7 8
intpp9 <
pageSizepp= E
,ppE F
intppG J
maxOrderppK S
,ppS T
intppU X

pageShiftsppY c
,ppc d
intppe h
	chunkSizeppi r
,ppr s
intppt w
offsetppx ~
)pp~ 
{qq 	
Contractrr 
.rr 
Requiresrr 
(rr 
maxOrderrr &
<rr' (
$numrr) +
,rr+ ,
$strrr- P
+rrQ R
maxOrderrrS [
)rr[ \
;rr\ ]
thistt 
.tt 
Unpooledtt 
=tt 
falsett !
;tt! "
thisuu 
.uu 
Arenauu 
=uu 
arenauu 
;uu 
thisvv 
.vv 
Memoryvv 
=vv 
memoryvv  
;vv  !
thisww 
.ww 
pageSizeww 
=ww 
pageSizeww $
;ww$ %
thisxx 
.xx 

pageShiftsxx 
=xx 

pageShiftsxx (
;xx( )
thisyy 
.yy 
maxOrderyy 
=yy 
maxOrderyy $
;yy$ %
thiszz 
.zz 
	chunkSizezz 
=zz 
	chunkSizezz &
;zz& '
this{{ 
.{{ 
Offset{{ 
={{ 
offset{{  
;{{  !
this|| 
.|| 
unusable|| 
=|| 
(|| 
sbyte|| "
)||" #
(||# $
maxOrder||$ ,
+||- .
$num||/ 0
)||0 1
;||1 2
this}} 
.}} 
log2ChunkSize}} 
=}}  
Log2}}! %
(}}% &
	chunkSize}}& /
)}}/ 0
;}}0 1
this~~ 
.~~ 
subpageOverflowMask~~ $
=~~% &
~~~' (
(~~( )
pageSize~~) 1
-~~2 3
$num~~4 5
)~~5 6
;~~6 7
this 
. 
	freeBytes 
= 
	chunkSize &
;& '
Contract
 
.
 
Assert
 
(
 
maxOrder
 $
<
% &
$num
' )
,
) *
$str
+ N
+
O P
maxOrder
Q Y
)
Y Z
;
Z [
this
‚‚ 
.
‚‚ 
maxSubpageAllocs
‚‚ !
=
‚‚" #
$num
‚‚$ %
<<
‚‚& (
maxOrder
‚‚) 1
;
‚‚1 2
this
…… 
.
…… 
	memoryMap
…… 
=
…… 
new
……  
sbyte
……! &
[
……& '
this
……' +
.
……+ ,
maxSubpageAllocs
……, <
<<
……= ?
$num
……@ A
]
……A B
;
……B C
this
†† 
.
†† 
depthMap
†† 
=
†† 
new
†† 
sbyte
††  %
[
††% &
this
††& *
.
††* +
	memoryMap
††+ 4
.
††4 5
Length
††5 ;
]
††; <
;
††< =
int
‡‡ 
memoryMapIndex
‡‡ 
=
‡‡  
$num
‡‡! "
;
‡‡" #
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
d
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
d
ˆˆ 
<=
ˆˆ  
maxOrder
ˆˆ! )
;
ˆˆ) *
++
ˆˆ+ -
d
ˆˆ- .
)
ˆˆ. /
{
‰‰ 
int
‹‹ 
depth
‹‹ 
=
‹‹ 
$num
‹‹ 
<<
‹‹  
d
‹‹! "
;
‹‹" #
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
p
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
p
ŒŒ  !
<
ŒŒ" #
depth
ŒŒ$ )
;
ŒŒ) *
++
ŒŒ+ -
p
ŒŒ- .
)
ŒŒ. /
{
 
this
 
.
 
	memoryMap
 "
[
" #
memoryMapIndex
# 1
]
1 2
=
3 4
(
5 6
sbyte
6 ;
)
; <
d
< =
;
= >
this
 
.
 
depthMap
 !
[
! "
memoryMapIndex
" 0
]
0 1
=
2 3
(
4 5
sbyte
5 :
)
: ;
d
; <
;
< =
memoryMapIndex
‘‘ "
++
‘‘" $
;
‘‘$ %
}
’’ 
}
““ 
this
•• 
.
•• 
subpages
•• 
=
•• 
this
••  
.
••  !
NewSubpageArray
••! 0
(
••0 1
this
••1 5
.
••5 6
maxSubpageAllocs
••6 F
)
••F G
;
••G H
}
–– 	
internal
šš 
	PoolChunk
šš 
(
šš 
	PoolArena
šš $
<
šš$ %
T
šš% &
>
šš& '
arena
šš( -
,
šš- .
T
šš/ 0
memory
šš1 7
,
šš7 8
int
šš9 <
size
šš= A
,
ššA B
int
ššC F
offset
ššG M
)
ššM N
{
›› 	
this
œœ 
.
œœ 
Unpooled
œœ 
=
œœ 
true
œœ  
;
œœ  !
this
 
.
 
Arena
 
=
 
arena
 
;
 
this
 
.
 
Memory
 
=
 
memory
  
;
  !
this
ŸŸ 
.
ŸŸ 
Offset
ŸŸ 
=
ŸŸ 
offset
ŸŸ  
;
ŸŸ  !
this
   
.
   
	memoryMap
   
=
   
null
   !
;
  ! "
this
¡¡ 
.
¡¡ 
depthMap
¡¡ 
=
¡¡ 
null
¡¡  
;
¡¡  !
this
¢¢ 
.
¢¢ 
subpages
¢¢ 
=
¢¢ 
null
¢¢  
;
¢¢  !
this
££ 
.
££ !
subpageOverflowMask
££ $
=
££% &
$num
££' (
;
££( )
this
¤¤ 
.
¤¤ 
pageSize
¤¤ 
=
¤¤ 
$num
¤¤ 
;
¤¤ 
this
¥¥ 
.
¥¥ 

pageShifts
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥  
this
¦¦ 
.
¦¦ 
maxOrder
¦¦ 
=
¦¦ 
$num
¦¦ 
;
¦¦ 
this
§§ 
.
§§ 
unusable
§§ 
=
§§ 
(
§§ 
sbyte
§§ "
)
§§" #
(
§§# $
this
§§$ (
.
§§( )
maxOrder
§§) 1
+
§§2 3
$num
§§4 5
)
§§5 6
;
§§6 7
this
¨¨ 
.
¨¨ 
	chunkSize
¨¨ 
=
¨¨ 
size
¨¨ !
;
¨¨! "
this
©© 
.
©© 
log2ChunkSize
©© 
=
©©  
IntegerExtensions
©©! 2
.
©©2 3
Log2
©©3 7
(
©©7 8
this
©©8 <
.
©©< =
	chunkSize
©©= F
)
©©F G
;
©©G H
this
ªª 
.
ªª 
maxSubpageAllocs
ªª !
=
ªª" #
$num
ªª$ %
;
ªª% &
}
«« 	
PoolSubpage
­­ 
<
­­ 
T
­­ 
>
­­ 
[
­­ 
]
­­ 
NewSubpageArray
­­ (
(
­­( )
int
­­) ,
size
­­- 1
)
­­1 2
=>
­­3 5
new
­­6 9
PoolSubpage
­­: E
<
­­E F
T
­­F G
>
­­G H
[
­­H I
size
­­I M
]
­­M N
;
­­N O
public
¯¯ 
int
¯¯ 
Usage
¯¯ 
{
°° 	
get
±± 
{
²² 
int
³³ 
bytes
³³ 
;
³³ 
lock
´´ 
(
´´ 
this
´´ 
.
´´ 
Arena
´´  
)
´´  !
{
µµ 
bytes
¶¶ 
=
¶¶ 
this
¶¶  
.
¶¶  !
	freeBytes
¶¶! *
;
¶¶* +
}
·· 
return
¹¹ 
this
¹¹ 
.
¹¹ 
GetUsage
¹¹ $
(
¹¹$ %
bytes
¹¹% *
)
¹¹* +
;
¹¹+ ,
}
ºº 
}
»» 	
int
½½ 
GetUsage
½½ 
(
½½ 
int
½½ 
bytes
½½ 
)
½½ 
{
¾¾ 	
if
¿¿ 
(
¿¿ 
bytes
¿¿ 
==
¿¿ 
$num
¿¿ 
)
¿¿ 
{
ÀÀ 
return
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
}
ÂÂ 
int
ÄÄ 
freePercentage
ÄÄ 
=
ÄÄ  
(
ÄÄ! "
int
ÄÄ" %
)
ÄÄ% &
(
ÄÄ& '
bytes
ÄÄ' ,
*
ÄÄ- .
$num
ÄÄ/ 3
/
ÄÄ4 5
this
ÄÄ6 :
.
ÄÄ: ;
	ChunkSize
ÄÄ; D
)
ÄÄD E
;
ÄÄE F
if
ÅÅ 
(
ÅÅ 
freePercentage
ÅÅ 
==
ÅÅ !
$num
ÅÅ" #
)
ÅÅ# $
{
ÆÆ 
return
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
}
ÈÈ 
return
ÊÊ 
$num
ÊÊ 
-
ÊÊ 
freePercentage
ÊÊ '
;
ÊÊ' (
}
ËË 	
internal
ÎÎ 
long
ÎÎ 
Allocate
ÎÎ 
(
ÎÎ 
int
ÎÎ "
normCapacity
ÎÎ# /
)
ÎÎ/ 0
{
ÏÏ 	
if
ĞĞ 
(
ĞĞ 
(
ĞĞ 
normCapacity
ĞĞ 
&
ĞĞ 
this
ĞĞ  $
.
ĞĞ$ %!
subpageOverflowMask
ĞĞ% 8
)
ĞĞ8 9
!=
ĞĞ: <
$num
ĞĞ= >
)
ĞĞ> ?
{
ÑÑ 
return
ÓÓ 
this
ÓÓ 
.
ÓÓ 
AllocateRun
ÓÓ '
(
ÓÓ' (
normCapacity
ÓÓ( 4
)
ÓÓ4 5
;
ÓÓ5 6
}
ÔÔ 
else
ÕÕ 
{
ÖÖ 
return
×× 
this
×× 
.
×× 
AllocateSubpage
×× +
(
××+ ,
normCapacity
××, 8
)
××8 9
;
××9 :
}
ØØ 
}
ÙÙ 	
void
ää  
UpdateParentsAlloc
ää 
(
ää  
int
ää  #
id
ää$ &
)
ää& '
{
åå 	
while
ææ 
(
ææ 
id
ææ 
>
ææ 
$num
ææ 
)
ææ 
{
çç 
int
èè 
parentId
èè 
=
èè 
id
èè !
.
èè! "
RightUShift
èè" -
(
èè- .
$num
èè. /
)
èè/ 0
;
èè0 1
sbyte
éé 
val1
éé 
=
éé 
this
éé !
.
éé! "
Value
éé" '
(
éé' (
id
éé( *
)
éé* +
;
éé+ ,
sbyte
êê 
val2
êê 
=
êê 
this
êê !
.
êê! "
Value
êê" '
(
êê' (
id
êê( *
^
êê+ ,
$num
êê- .
)
êê. /
;
êê/ 0
sbyte
ëë 
val
ëë 
=
ëë 
val1
ëë  
<
ëë! "
val2
ëë# '
?
ëë( )
val1
ëë* .
:
ëë/ 0
val2
ëë1 5
;
ëë5 6
this
ìì 
.
ìì 
SetValue
ìì 
(
ìì 
parentId
ìì &
,
ìì& '
val
ìì( +
)
ìì+ ,
;
ìì, -
id
íí 
=
íí 
parentId
íí 
;
íí 
}
îî 
}
ïï 	
void
ùù 
UpdateParentsFree
ùù 
(
ùù 
int
ùù "
id
ùù# %
)
ùù% &
{
úú 	
int
ûû 
logChild
ûû 
=
ûû 
this
ûû 
.
ûû  
Depth
ûû  %
(
ûû% &
id
ûû& (
)
ûû( )
+
ûû* +
$num
ûû, -
;
ûû- .
while
üü 
(
üü 
id
üü 
>
üü 
$num
üü 
)
üü 
{
ıı 
int
şş 
parentId
şş 
=
şş 
id
şş !
.
şş! "
RightUShift
şş" -
(
şş- .
$num
şş. /
)
şş/ 0
;
şş0 1
sbyte
ÿÿ 
val1
ÿÿ 
=
ÿÿ 
this
ÿÿ !
.
ÿÿ! "
Value
ÿÿ" '
(
ÿÿ' (
id
ÿÿ( *
)
ÿÿ* +
;
ÿÿ+ ,
sbyte
€€ 
val2
€€ 
=
€€ 
this
€€ !
.
€€! "
Value
€€" '
(
€€' (
id
€€( *
^
€€+ ,
$num
€€- .
)
€€. /
;
€€/ 0
logChild
 
-=
 
$num
 
;
 
if
ƒƒ 
(
ƒƒ 
val1
ƒƒ 
==
ƒƒ 
logChild
ƒƒ $
&&
ƒƒ% '
val2
ƒƒ( ,
==
ƒƒ- /
logChild
ƒƒ0 8
)
ƒƒ8 9
{
„„ 
this
…… 
.
…… 
SetValue
…… !
(
……! "
parentId
……" *
,
……* +
(
……, -
sbyte
……- 2
)
……2 3
(
……3 4
logChild
……4 <
-
……= >
$num
……? @
)
……@ A
)
……A B
;
……B C
}
†† 
else
‡‡ 
{
ˆˆ 
sbyte
‰‰ 
val
‰‰ 
=
‰‰ 
val1
‰‰  $
<
‰‰% &
val2
‰‰' +
?
‰‰, -
val1
‰‰. 2
:
‰‰3 4
val2
‰‰5 9
;
‰‰9 :
this
ŠŠ 
.
ŠŠ 
SetValue
ŠŠ !
(
ŠŠ! "
parentId
ŠŠ" *
,
ŠŠ* +
val
ŠŠ, /
)
ŠŠ/ 0
;
ŠŠ0 1
}
‹‹ 
id
 
=
 
parentId
 
;
 
}
 
}
 	
int
™™ 
AllocateNode
™™ 
(
™™ 
int
™™ 
d
™™ 
)
™™ 
{
šš 	
int
›› 
id
›› 
=
›› 
$num
›› 
;
›› 
int
œœ 
initial
œœ 
=
œœ 
-
œœ 
(
œœ 
$num
œœ 
<<
œœ  
d
œœ! "
)
œœ" #
;
œœ# $
sbyte
 
val
 
=
 
this
 
.
 
Value
 "
(
" #
id
# %
)
% &
;
& '
if
 
(
 
val
 
>
 
d
 
)
 
{
ŸŸ 
return
¡¡ 
-
¡¡ 
$num
¡¡ 
;
¡¡ 
}
¢¢ 
while
££ 
(
££ 
val
££ 
<
££ 
d
££ 
||
££ 
(
££ 
id
££ !
&
££" #
initial
££$ +
)
££+ ,
==
££- /
$num
££0 1
)
££1 2
{
¤¤ 
id
¦¦ 
<<=
¦¦ 
$num
¦¦ 
;
¦¦ 
val
§§ 
=
§§ 
this
§§ 
.
§§ 
Value
§§  
(
§§  !
id
§§! #
)
§§# $
;
§§$ %
if
¨¨ 
(
¨¨ 
val
¨¨ 
>
¨¨ 
d
¨¨ 
)
¨¨ 
{
©© 
id
ªª 
^=
ªª 
$num
ªª 
;
ªª 
val
«« 
=
«« 
this
«« 
.
«« 
Value
«« $
(
««$ %
id
««% '
)
««' (
;
««( )
}
¬¬ 
}
­­ 
sbyte
®® 
value
®® 
=
®® 
this
®® 
.
®® 
Value
®® $
(
®®$ %
id
®®% '
)
®®' (
;
®®( )
Debug
¯¯ 
.
¯¯ 
Assert
¯¯ 
(
¯¯ 
value
¯¯ 
==
¯¯ !
d
¯¯" #
&&
¯¯$ &
(
¯¯' (
id
¯¯( *
&
¯¯+ ,
initial
¯¯- 4
)
¯¯4 5
==
¯¯6 8
$num
¯¯9 :
<<
¯¯; =
d
¯¯> ?
,
¯¯? @
$"
¯¯A C
$str
¯¯C I
{
¯¯I J
value
¯¯J O
}
¯¯O P
$str
¯¯P a
{
¯¯a b
id
¯¯b d
&
¯¯e f
initial
¯¯g n
}
¯¯n o
$str
¯¯o u
{
¯¯u v
d
¯¯v w
}
¯¯w x
"
¯¯x y
)
¯¯y z
;
¯¯z {
this
°° 
.
°° 
SetValue
°° 
(
°° 
id
°° 
,
°° 
this
°° "
.
°°" #
unusable
°°# +
)
°°+ ,
;
°°, -
this
±± 
.
±±  
UpdateParentsAlloc
±± #
(
±±# $
id
±±$ &
)
±±& '
;
±±' (
return
²² 
id
²² 
;
²² 
}
³³ 	
long
¼¼ 
AllocateRun
¼¼ 
(
¼¼ 
int
¼¼ 
normCapacity
¼¼ )
)
¼¼) *
{
½½ 	
int
¾¾ 
d
¾¾ 
=
¾¾ 
this
¾¾ 
.
¾¾ 
maxOrder
¾¾ !
-
¾¾" #
(
¾¾$ %
IntegerExtensions
¾¾% 6
.
¾¾6 7
Log2
¾¾7 ;
(
¾¾; <
normCapacity
¾¾< H
)
¾¾H I
-
¾¾J K
this
¾¾L P
.
¾¾P Q

pageShifts
¾¾Q [
)
¾¾[ \
;
¾¾\ ]
int
¿¿ 
id
¿¿ 
=
¿¿ 
this
¿¿ 
.
¿¿ 
AllocateNode
¿¿ &
(
¿¿& '
d
¿¿' (
)
¿¿( )
;
¿¿) *
if
ÀÀ 
(
ÀÀ 
id
ÀÀ 
<
ÀÀ 
$num
ÀÀ 
)
ÀÀ 
{
ÁÁ 
return
ÂÂ 
id
ÂÂ 
;
ÂÂ 
}
ÃÃ 
this
ÄÄ 
.
ÄÄ 
	freeBytes
ÄÄ 
-=
ÄÄ 
this
ÄÄ "
.
ÄÄ" #
	RunLength
ÄÄ# ,
(
ÄÄ, -
id
ÄÄ- /
)
ÄÄ/ 0
;
ÄÄ0 1
return
ÅÅ 
id
ÅÅ 
;
ÅÅ 
}
ÆÆ 	
long
ĞĞ 
AllocateSubpage
ĞĞ 
(
ĞĞ 
int
ĞĞ  
normCapacity
ĞĞ! -
)
ĞĞ- .
{
ÑÑ 	
PoolSubpage
ÔÔ 
<
ÔÔ 
T
ÔÔ 
>
ÔÔ 
head
ÔÔ 
=
ÔÔ  !
this
ÔÔ" &
.
ÔÔ& '
Arena
ÔÔ' ,
.
ÔÔ, -!
FindSubpagePoolHead
ÔÔ- @
(
ÔÔ@ A
normCapacity
ÔÔA M
)
ÔÔM N
;
ÔÔN O
lock
ÕÕ 
(
ÕÕ 
head
ÕÕ 
)
ÕÕ 
{
ÖÖ 
int
×× 
d
×× 
=
×× 
this
×× 
.
×× 
maxOrder
×× %
;
××% &
int
ØØ 
id
ØØ 
=
ØØ 
this
ØØ 
.
ØØ 
AllocateNode
ØØ *
(
ØØ* +
d
ØØ+ ,
)
ØØ, -
;
ØØ- .
if
ÙÙ 
(
ÙÙ 
id
ÙÙ 
<
ÙÙ 
$num
ÙÙ 
)
ÙÙ 
{
ÚÚ 
return
ÛÛ 
id
ÛÛ 
;
ÛÛ 
}
ÜÜ 
PoolSubpage
ŞŞ 
<
ŞŞ 
T
ŞŞ 
>
ŞŞ 
[
ŞŞ 
]
ŞŞ  
subpages
ŞŞ! )
=
ŞŞ* +
this
ŞŞ, 0
.
ŞŞ0 1
subpages
ŞŞ1 9
;
ŞŞ9 :
int
ßß 
pageSize
ßß 
=
ßß 
this
ßß #
.
ßß# $
pageSize
ßß$ ,
;
ßß, -
this
áá 
.
áá 
	freeBytes
áá 
-=
áá !
pageSize
áá" *
;
áá* +
int
ãã 

subpageIdx
ãã 
=
ãã  
this
ãã! %
.
ãã% &

SubpageIdx
ãã& 0
(
ãã0 1
id
ãã1 3
)
ãã3 4
;
ãã4 5
PoolSubpage
ää 
<
ää 
T
ää 
>
ää 
subpage
ää &
=
ää' (
subpages
ää) 1
[
ää1 2

subpageIdx
ää2 <
]
ää< =
;
ää= >
if
åå 
(
åå 
subpage
åå 
==
åå 
null
åå #
)
åå# $
{
ææ 
subpage
çç 
=
çç 
new
çç !
PoolSubpage
çç" -
<
çç- .
T
çç. /
>
çç/ 0
(
çç0 1
head
çç1 5
,
çç5 6
this
çç7 ;
,
çç; <
id
çç= ?
,
çç? @
this
ççA E
.
ççE F
	RunOffset
ççF O
(
ççO P
id
ççP R
)
ççR S
,
ççS T
pageSize
ççU ]
,
çç] ^
normCapacity
çç_ k
)
ççk l
;
ççl m
subpages
èè 
[
èè 

subpageIdx
èè '
]
èè' (
=
èè) *
subpage
èè+ 2
;
èè2 3
}
éé 
else
êê 
{
ëë 
subpage
ìì 
.
ìì 
Init
ìì  
(
ìì  !
head
ìì! %
,
ìì% &
normCapacity
ìì' 3
)
ìì3 4
;
ìì4 5
}
íí 
return
ïï 
subpage
ïï 
.
ïï 
Allocate
ïï '
(
ïï' (
)
ïï( )
;
ïï) *
}
ğğ 
}
ññ 	
internal
üü 
void
üü 
Free
üü 
(
üü 
long
üü 
handle
üü  &
)
üü& '
{
ıı 	
int
şş 
memoryMapIdx
şş 
=
şş 
MemoryMapIdx
şş +
(
şş+ ,
handle
şş, 2
)
şş2 3
;
şş3 4
int
ÿÿ 
	bitmapIdx
ÿÿ 
=
ÿÿ 
	BitmapIdx
ÿÿ %
(
ÿÿ% &
handle
ÿÿ& ,
)
ÿÿ, -
;
ÿÿ- .
if
 
(
 
	bitmapIdx
 
!=
 
$num
 
)
 
{
‚‚ 
PoolSubpage
„„ 
<
„„ 
T
„„ 
>
„„ 
subpage
„„ &
=
„„' (
this
„„) -
.
„„- .
subpages
„„. 6
[
„„6 7
this
„„7 ;
.
„„; <

SubpageIdx
„„< F
(
„„F G
memoryMapIdx
„„G S
)
„„S T
]
„„T U
;
„„U V
Debug
…… 
.
…… 
Assert
…… 
(
…… 
subpage
…… $
!=
……% '
null
……( ,
&&
……- /
subpage
……0 7
.
……7 8
DoNotDestroy
……8 D
)
……D E
;
……E F
PoolSubpage
‰‰ 
<
‰‰ 
T
‰‰ 
>
‰‰ 
head
‰‰ #
=
‰‰$ %
this
‰‰& *
.
‰‰* +
Arena
‰‰+ 0
.
‰‰0 1!
FindSubpagePoolHead
‰‰1 D
(
‰‰D E
subpage
‰‰E L
.
‰‰L M
ElemSize
‰‰M U
)
‰‰U V
;
‰‰V W
lock
ŠŠ 
(
ŠŠ 
head
ŠŠ 
)
ŠŠ 
{
‹‹ 
if
ŒŒ 
(
ŒŒ 
subpage
ŒŒ 
.
ŒŒ  
Free
ŒŒ  $
(
ŒŒ$ %
head
ŒŒ% )
,
ŒŒ) *
	bitmapIdx
ŒŒ+ 4
&
ŒŒ5 6
$num
ŒŒ7 A
)
ŒŒA B
)
ŒŒB C
{
 
return
 
;
 
}
 
}
 
}
‘‘ 
this
’’ 
.
’’ 
	freeBytes
’’ 
+=
’’ 
this
’’ "
.
’’" #
	RunLength
’’# ,
(
’’, -
memoryMapIdx
’’- 9
)
’’9 :
;
’’: ;
this
““ 
.
““ 
SetValue
““ 
(
““ 
memoryMapIdx
““ &
,
““& '
this
““( ,
.
““, -
Depth
““- 2
(
““2 3
memoryMapIdx
““3 ?
)
““? @
)
““@ A
;
““A B
this
”” 
.
”” 
UpdateParentsFree
”” "
(
””" #
memoryMapIdx
””# /
)
””/ 0
;
””0 1
}
•• 	
internal
—— 
void
—— 
InitBuf
—— 
(
—— 
PooledByteBuffer
—— .
<
——. /
T
——/ 0
>
——0 1
buf
——2 5
,
——5 6
long
——7 ;
handle
——< B
,
——B C
int
——D G
reqCapacity
——H S
)
——S T
{
˜˜ 	
int
™™ 
memoryMapIdx
™™ 
=
™™ 
MemoryMapIdx
™™ +
(
™™+ ,
handle
™™, 2
)
™™2 3
;
™™3 4
int
šš 
	bitmapIdx
šš 
=
šš 
	BitmapIdx
šš %
(
šš% &
handle
šš& ,
)
šš, -
;
šš- .
if
›› 
(
›› 
	bitmapIdx
›› 
==
›› 
$num
›› 
)
›› 
{
œœ 
sbyte
 
val
 
=
 
this
  
.
  !
Value
! &
(
& '
memoryMapIdx
' 3
)
3 4
;
4 5
Debug
 
.
 
Assert
 
(
 
val
  
==
! #
this
$ (
.
( )
unusable
) 1
,
1 2
val
3 6
.
6 7
ToString
7 ?
(
? @
)
@ A
)
A B
;
B C
buf
ŸŸ 
.
ŸŸ 
Init
ŸŸ 
(
ŸŸ 
this
ŸŸ 
,
ŸŸ 
handle
ŸŸ %
,
ŸŸ% &
this
ŸŸ' +
.
ŸŸ+ ,
	RunOffset
ŸŸ, 5
(
ŸŸ5 6
memoryMapIdx
ŸŸ6 B
)
ŸŸB C
+
ŸŸD E
this
ŸŸF J
.
ŸŸJ K
Offset
ŸŸK Q
,
ŸŸQ R
reqCapacity
ŸŸS ^
,
ŸŸ^ _
this
ŸŸ` d
.
ŸŸd e
	RunLength
ŸŸe n
(
ŸŸn o
memoryMapIdx
ŸŸo {
)
ŸŸ{ |
,
ŸŸ| }
this
   
.
   
Arena
   
.
   
Parent
   %
.
  % &
ThreadCache
  & 1
<
  1 2
T
  2 3
>
  3 4
(
  4 5
)
  5 6
)
  6 7
;
  7 8
}
¡¡ 
else
¢¢ 
{
££ 
this
¤¤ 
.
¤¤  
InitBufWithSubpage
¤¤ '
(
¤¤' (
buf
¤¤( +
,
¤¤+ ,
handle
¤¤- 3
,
¤¤3 4
	bitmapIdx
¤¤5 >
,
¤¤> ?
reqCapacity
¤¤@ K
)
¤¤K L
;
¤¤L M
}
¥¥ 
}
¦¦ 	
internal
¨¨ 
void
¨¨  
InitBufWithSubpage
¨¨ (
(
¨¨( )
PooledByteBuffer
¨¨) 9
<
¨¨9 :
T
¨¨: ;
>
¨¨; <
buf
¨¨= @
,
¨¨@ A
long
¨¨B F
handle
¨¨G M
,
¨¨M N
int
¨¨O R
reqCapacity
¨¨S ^
)
¨¨^ _
=>
¨¨` b
this
©© 
.
©©  
InitBufWithSubpage
©© #
(
©©# $
buf
©©$ '
,
©©' (
handle
©©) /
,
©©/ 0
	BitmapIdx
©©1 :
(
©©: ;
handle
©©; A
)
©©A B
,
©©B C
reqCapacity
©©D O
)
©©O P
;
©©P Q
void
««  
InitBufWithSubpage
«« 
(
««  
PooledByteBuffer
««  0
<
««0 1
T
««1 2
>
««2 3
buf
««4 7
,
««7 8
long
««9 =
handle
««> D
,
««D E
int
««F I
	bitmapIdx
««J S
,
««S T
int
««U X
reqCapacity
««Y d
)
««d e
{
¬¬ 	
Contract
­­ 
.
­­ 
Assert
­­ 
(
­­ 
	bitmapIdx
­­ %
!=
­­& (
$num
­­) *
)
­­* +
;
­­+ ,
int
¯¯ 
memoryMapIdx
¯¯ 
=
¯¯ 
MemoryMapIdx
¯¯ +
(
¯¯+ ,
handle
¯¯, 2
)
¯¯2 3
;
¯¯3 4
PoolSubpage
±± 
<
±± 
T
±± 
>
±± 
subpage
±± "
=
±±# $
this
±±% )
.
±±) *
subpages
±±* 2
[
±±2 3
this
±±3 7
.
±±7 8

SubpageIdx
±±8 B
(
±±B C
memoryMapIdx
±±C O
)
±±O P
]
±±P Q
;
±±Q R
Contract
²² 
.
²² 
Assert
²² 
(
²² 
subpage
²² #
.
²²# $
DoNotDestroy
²²$ 0
)
²²0 1
;
²²1 2
Contract
³³ 
.
³³ 
Assert
³³ 
(
³³ 
reqCapacity
³³ '
<=
³³( *
subpage
³³+ 2
.
³³2 3
ElemSize
³³3 ;
)
³³; <
;
³³< =
buf
µµ 
.
µµ 
Init
µµ 
(
µµ 
this
¶¶ 
,
¶¶ 
handle
¶¶ 
,
¶¶ 
this
·· 
.
·· 
	RunOffset
·· 
(
·· 
memoryMapIdx
·· +
)
··+ ,
+
··- .
(
··/ 0
	bitmapIdx
··0 9
&
··: ;
$num
··< F
)
··F G
*
··H I
subpage
··J Q
.
··Q R
ElemSize
··R Z
+
··[ \
this
··] a
.
··a b
Offset
··b h
,
··h i
reqCapacity
¸¸ 
,
¸¸ 
subpage
¸¸ $
.
¸¸$ %
ElemSize
¸¸% -
,
¸¸- .
this
¸¸/ 3
.
¸¸3 4
Arena
¸¸4 9
.
¸¸9 :
Parent
¸¸: @
.
¸¸@ A
ThreadCache
¸¸A L
<
¸¸L M
T
¸¸M N
>
¸¸N O
(
¸¸O P
)
¸¸P Q
)
¸¸Q R
;
¸¸R S
}
¹¹ 	
sbyte
»» 
Value
»» 
(
»» 
int
»» 
id
»» 
)
»» 
=>
»» 
this
»» #
.
»»# $
	memoryMap
»»$ -
[
»»- .
id
»». 0
]
»»0 1
;
»»1 2
void
½½ 
SetValue
½½ 
(
½½ 
int
½½ 
id
½½ 
,
½½ 
sbyte
½½ #
val
½½$ '
)
½½' (
=>
½½) +
this
½½, 0
.
½½0 1
	memoryMap
½½1 :
[
½½: ;
id
½½; =
]
½½= >
=
½½? @
val
½½A D
;
½½D E
sbyte
¿¿ 
Depth
¿¿ 
(
¿¿ 
int
¿¿ 
id
¿¿ 
)
¿¿ 
=>
¿¿ 
this
¿¿ #
.
¿¿# $
depthMap
¿¿$ ,
[
¿¿, -
id
¿¿- /
]
¿¿/ 0
;
¿¿0 1
static
ÂÂ 
int
ÂÂ 
Log2
ÂÂ 
(
ÂÂ 
int
ÂÂ 
val
ÂÂ 
)
ÂÂ  
=>
ÂÂ! #!
IntegerSizeMinusOne
ÂÂ$ 7
-
ÂÂ8 9
val
ÂÂ: =
.
ÂÂ= >"
NumberOfLeadingZeros
ÂÂ> R
(
ÂÂR S
)
ÂÂS T
;
ÂÂT U
int
ÅÅ 
	RunLength
ÅÅ 
(
ÅÅ 
int
ÅÅ 
id
ÅÅ 
)
ÅÅ 
=>
ÅÅ  
$num
ÅÅ! "
<<
ÅÅ# %
this
ÅÅ& *
.
ÅÅ* +
log2ChunkSize
ÅÅ+ 8
-
ÅÅ9 :
this
ÅÅ; ?
.
ÅÅ? @
Depth
ÅÅ@ E
(
ÅÅE F
id
ÅÅF H
)
ÅÅH I
;
ÅÅI J
int
ÇÇ 
	RunOffset
ÇÇ 
(
ÇÇ 
int
ÇÇ 
id
ÇÇ 
)
ÇÇ 
{
ÈÈ 	
int
ÊÊ 
shift
ÊÊ 
=
ÊÊ 
id
ÊÊ 
^
ÊÊ 
$num
ÊÊ 
<<
ÊÊ !
this
ÊÊ" &
.
ÊÊ& '
Depth
ÊÊ' ,
(
ÊÊ, -
id
ÊÊ- /
)
ÊÊ/ 0
;
ÊÊ0 1
return
ËË 
shift
ËË 
*
ËË 
this
ËË 
.
ËË  
	RunLength
ËË  )
(
ËË) *
id
ËË* ,
)
ËË, -
;
ËË- .
}
ÌÌ 	
int
ÎÎ 

SubpageIdx
ÎÎ 
(
ÎÎ 
int
ÎÎ 
memoryMapIdx
ÎÎ '
)
ÎÎ' (
=>
ÎÎ) +
memoryMapIdx
ÎÎ, 8
^
ÎÎ9 :
this
ÎÎ; ?
.
ÎÎ? @
maxSubpageAllocs
ÎÎ@ P
;
ÎÎP Q
static
ĞĞ 
int
ĞĞ 
MemoryMapIdx
ĞĞ 
(
ĞĞ  
long
ĞĞ  $
handle
ĞĞ% +
)
ĞĞ+ ,
=>
ĞĞ- /
(
ĞĞ0 1
int
ĞĞ1 4
)
ĞĞ4 5
handle
ĞĞ5 ;
;
ĞĞ; <
static
ÒÒ 
int
ÒÒ 
	BitmapIdx
ÒÒ 
(
ÒÒ 
long
ÒÒ !
handle
ÒÒ" (
)
ÒÒ( )
=>
ÒÒ* ,
(
ÒÒ- .
int
ÒÒ. 1
)
ÒÒ1 2
handle
ÒÒ2 8
.
ÒÒ8 9
RightUShift
ÒÒ9 D
(
ÒÒD E
IntegerExtensions
ÒÒE V
.
ÒÒV W

SizeInBits
ÒÒW a
)
ÒÒa b
;
ÒÒb c
public
ÔÔ 
int
ÔÔ 
	ChunkSize
ÔÔ 
=>
ÔÔ 
this
ÔÔ  $
.
ÔÔ$ %
	chunkSize
ÔÔ% .
;
ÔÔ. /
public
ÖÖ 
int
ÖÖ 
	FreeBytes
ÖÖ 
=>
ÖÖ 
this
ÖÖ  $
.
ÖÖ$ %
	freeBytes
ÖÖ% .
;
ÖÖ. /
public
ØØ 
override
ØØ 
string
ØØ 
ToString
ØØ '
(
ØØ' (
)
ØØ( )
{
ÙÙ 	
return
ÚÚ 
new
ÚÚ 
StringBuilder
ÚÚ $
(
ÚÚ$ %
)
ÚÚ% &
.
ÛÛ 
Append
ÛÛ 
(
ÛÛ 
$str
ÛÛ  
)
ÛÛ  !
.
ÜÜ 
Append
ÜÜ 
(
ÜÜ 
RuntimeHelpers
ÜÜ &
.
ÜÜ& '
GetHashCode
ÜÜ' 2
(
ÜÜ2 3
this
ÜÜ3 7
)
ÜÜ7 8
.
ÜÜ8 9
ToString
ÜÜ9 A
(
ÜÜA B
$str
ÜÜB E
)
ÜÜE F
)
ÜÜF G
.
İİ 
Append
İİ 
(
İİ 
$str
İİ 
)
İİ 
.
ŞŞ 
Append
ŞŞ 
(
ŞŞ 
this
ŞŞ 
.
ŞŞ 
Usage
ŞŞ "
)
ŞŞ" #
.
ßß 
Append
ßß 
(
ßß 
$str
ßß 
)
ßß 
.
àà 
Append
àà 
(
àà 
this
àà 
.
àà 
	chunkSize
àà &
-
àà' (
this
àà) -
.
àà- .
	freeBytes
àà. 7
)
àà7 8
.
áá 
Append
áá 
(
áá 
$char
áá 
)
áá 
.
ââ 
Append
ââ 
(
ââ 
this
ââ 
.
ââ 
	chunkSize
ââ &
)
ââ& '
.
ãã 
Append
ãã 
(
ãã 
$char
ãã 
)
ãã 
.
ää 
ToString
ää 
(
ää 
)
ää 
;
ää 
}
åå 	
internal
çç 
void
çç 
Destroy
çç 
(
çç 
)
çç 
=>
çç  "
this
çç" &
.
çç& '
Arena
çç' ,
.
çç, -
DestroyChunk
çç- 9
(
çç9 :
this
çç: >
)
çç> ?
;
çç? @
}
èè 
}éé Û‰
`C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolChunkList.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 
PoolChunkList 
< 
T  
>  !
:" # 
IPoolChunkListMetric$ 8
{ 
readonly 
	PoolArena 
< 
T 
> 
arena #
;# $
readonly 
PoolChunkList 
< 
T  
>  !
nextList" *
;* +
readonly 
int 
minUsage 
; 
readonly 
int 
maxUsage 
; 
readonly 
int 
maxCapacity  
;  !
	PoolChunk 
< 
T 
> 
head 
; 
PoolChunkList 
< 
T 
> 
prevList !
;! "
public 
PoolChunkList 
( 
	PoolArena &
<& '
T' (
>( )
arena* /
,/ 0
PoolChunkList1 >
<> ?
T? @
>@ A
nextListB J
,J K
intL O
minUsageP X
,X Y
intZ ]
maxUsage^ f
,f g
inth k
	chunkSizel u
)u v
{ 	
Contract   
.   
Assert   
(   
minUsage   $
<=  % '
maxUsage  ( 0
)  0 1
;  1 2
this!! 
.!! 
arena!! 
=!! 
arena!! 
;!! 
this"" 
."" 
nextList"" 
="" 
nextList"" $
;""$ %
this## 
.## 
minUsage## 
=## 
minUsage## $
;##$ %
this$$ 
.$$ 
maxUsage$$ 
=$$ 
maxUsage$$ $
;$$$ %
this%% 
.%% 
maxCapacity%% 
=%%  
CalculateMaxCapacity%% 3
(%%3 4
minUsage%%4 <
,%%< =
	chunkSize%%> G
)%%G H
;%%H I
}&& 	
static** 
int**  
CalculateMaxCapacity** '
(**' (
int**( +
minUsage**, 4
,**4 5
int**6 9
	chunkSize**: C
)**C D
{++ 	
minUsage,, 
=,, 
	MinUsage0,,  
(,,  !
minUsage,,! )
),,) *
;,,* +
if.. 
(.. 
minUsage.. 
==.. 
$num.. 
)..  
{// 
return11 
$num11 
;11 
}22 
return99 
(99 
int99 
)99 
(99 
	chunkSize99 "
*99# $
(99% &
$num99& *
-99+ ,
minUsage99- 5
)995 6
/997 8
$num999 =
)99= >
;99> ?
}:: 	
internal<< 
void<< 
PrevList<< 
(<< 
PoolChunkList<< ,
<<<, -
T<<- .
><<. /
list<<0 4
)<<4 5
{== 	
Debug>> 
.>> 
Assert>> 
(>> 
this>> 
.>> 
prevList>> &
==>>' )
null>>* .
)>>. /
;>>/ 0
this?? 
.?? 
prevList?? 
=?? 
list??  
;??  !
}@@ 	
internalBB 
boolBB 
AllocateBB 
(BB 
PooledByteBufferBB /
<BB/ 0
TBB0 1
>BB1 2
bufBB3 6
,BB6 7
intBB8 ;
reqCapacityBB< G
,BBG H
intBBI L
normCapacityBBM Y
)BBY Z
{CC 	
ifDD 
(DD 
thisDD 
.DD 
headDD 
==DD 
nullDD !
||DD" $
normCapacityDD% 1
>DD2 3
thisDD4 8
.DD8 9
maxCapacityDD9 D
)DDD E
{EE 
returnHH 
falseHH 
;HH 
}II 
forKK 
(KK 
	PoolChunkKK 
<KK 
TKK 
>KK 
curKK !
=KK" #
thisKK$ (
.KK( )
headKK) -
;KK- .
;KK. /
)KK/ 0
{LL 
longMM 
handleMM 
=MM 
curMM !
.MM! "
AllocateMM" *
(MM* +
normCapacityMM+ 7
)MM7 8
;MM8 9
ifNN 
(NN 
handleNN 
<NN 
$numNN 
)NN 
{OO 
curPP 
=PP 
curPP 
.PP 
NextPP "
;PP" #
ifQQ 
(QQ 
curQQ 
==QQ 
nullQQ #
)QQ# $
{RR 
returnSS 
falseSS $
;SS$ %
}TT 
}UU 
elseVV 
{WW 
curXX 
.XX 
InitBufXX 
(XX  
bufXX  #
,XX# $
handleXX% +
,XX+ ,
reqCapacityXX- 8
)XX8 9
;XX9 :
ifYY 
(YY 
curYY 
.YY 
UsageYY !
>=YY" $
thisYY% )
.YY) *
maxUsageYY* 2
)YY2 3
{ZZ 
this[[ 
.[[ 
Remove[[ #
([[# $
cur[[$ '
)[[' (
;[[( )
this\\ 
.\\ 
nextList\\ %
.\\% &
Add\\& )
(\\) *
cur\\* -
)\\- .
;\\. /
}]] 
return^^ 
true^^ 
;^^  
}__ 
}`` 
}aa 	
internalcc 
boolcc 
Freecc 
(cc 
	PoolChunkcc $
<cc$ %
Tcc% &
>cc& '
chunkcc( -
,cc- .
longcc/ 3
handlecc4 :
)cc: ;
{dd 	
chunkee 
.ee 
Freeee 
(ee 
handleee 
)ee 
;ee 
ifff 
(ff 
chunkff 
.ff 
Usageff 
<ff 
thisff "
.ff" #
minUsageff# +
)ff+ ,
{gg 
thishh 
.hh 
Removehh 
(hh 
chunkhh !
)hh! "
;hh" #
returnjj 
thisjj 
.jj 
Move0jj !
(jj! "
chunkjj" '
)jj' (
;jj( )
}kk 
returnll 
truell 
;ll 
}mm 	
booloo 
Moveoo 
(oo 
	PoolChunkoo 
<oo 
Too 
>oo 
chunkoo $
)oo$ %
{pp 	
Contractqq 
.qq 
Assertqq 
(qq 
chunkqq !
.qq! "
Usageqq" '
<qq( )
thisqq* .
.qq. /
maxUsageqq/ 7
)qq7 8
;qq8 9
ifss 
(ss 
chunkss 
.ss 
Usagess 
<ss 
thisss "
.ss" #
minUsagess# +
)ss+ ,
{tt 
returnvv 
thisvv 
.vv 
Move0vv !
(vv! "
chunkvv" '
)vv' (
;vv( )
}ww 
thiszz 
.zz 
Add0zz 
(zz 
chunkzz 
)zz 
;zz 
return{{ 
true{{ 
;{{ 
}|| 	
bool
€€ 
Move0
€€ 
(
€€ 
	PoolChunk
€€ 
<
€€ 
T
€€ 
>
€€ 
chunk
€€  %
)
€€% &
{
 	
if
‚‚ 
(
‚‚ 
this
‚‚ 
.
‚‚ 
prevList
‚‚ 
==
‚‚  
null
‚‚! %
)
‚‚% &
{
ƒƒ 
Debug
†† 
.
†† 
Assert
†† 
(
†† 
chunk
†† "
.
††" #
Usage
††# (
==
††) +
$num
††, -
)
††- .
;
††. /
return
‡‡ 
false
‡‡ 
;
‡‡ 
}
ˆˆ 
return
‰‰ 
this
‰‰ 
.
‰‰ 
prevList
‰‰  
.
‰‰  !
Move
‰‰! %
(
‰‰% &
chunk
‰‰& +
)
‰‰+ ,
;
‰‰, -
}
ŠŠ 	
internal
ŒŒ 
void
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
	PoolChunk
ŒŒ #
<
ŒŒ# $
T
ŒŒ$ %
>
ŒŒ% &
chunk
ŒŒ' ,
)
ŒŒ, -
{
 	
if
 
(
 
chunk
 
.
 
Usage
 
>=
 
this
 #
.
# $
maxUsage
$ ,
)
, -
{
 
this
 
.
 
nextList
 
.
 
Add
 !
(
! "
chunk
" '
)
' (
;
( )
return
‘‘ 
;
‘‘ 
}
’’ 
this
““ 
.
““ 
Add0
““ 
(
““ 
chunk
““ 
)
““ 
;
““ 
}
”” 	
void
—— 
Add0
—— 
(
—— 
	PoolChunk
—— 
<
—— 
T
—— 
>
—— 
chunk
—— $
)
——$ %
{
˜˜ 	
chunk
™™ 
.
™™ 
Parent
™™ 
=
™™ 
this
™™ 
;
™™  
if
šš 
(
šš 
this
šš 
.
šš 
head
šš 
==
šš 
null
šš !
)
šš! "
{
›› 
this
œœ 
.
œœ 
head
œœ 
=
œœ 
chunk
œœ !
;
œœ! "
chunk
 
.
 
Prev
 
=
 
null
 !
;
! "
chunk
 
.
 
Next
 
=
 
null
 !
;
! "
}
ŸŸ 
else
   
{
¡¡ 
chunk
¢¢ 
.
¢¢ 
Prev
¢¢ 
=
¢¢ 
null
¢¢ !
;
¢¢! "
chunk
££ 
.
££ 
Next
££ 
=
££ 
this
££ !
.
££! "
head
££" &
;
££& '
this
¤¤ 
.
¤¤ 
head
¤¤ 
.
¤¤ 
Prev
¤¤ 
=
¤¤  
chunk
¤¤! &
;
¤¤& '
this
¥¥ 
.
¥¥ 
head
¥¥ 
=
¥¥ 
chunk
¥¥ !
;
¥¥! "
}
¦¦ 
}
§§ 	
void
©© 
Remove
©© 
(
©© 
	PoolChunk
©© 
<
©© 
T
©© 
>
©©  
cur
©©! $
)
©©$ %
{
ªª 	
if
«« 
(
«« 
cur
«« 
==
«« 
this
«« 
.
«« 
head
««  
)
««  !
{
¬¬ 
this
­­ 
.
­­ 
head
­­ 
=
­­ 
cur
­­ 
.
­­  
Next
­­  $
;
­­$ %
if
®® 
(
®® 
this
®® 
.
®® 
head
®® 
!=
®®  
null
®®! %
)
®®% &
{
¯¯ 
this
°° 
.
°° 
head
°° 
.
°° 
Prev
°° "
=
°°# $
null
°°% )
;
°°) *
}
±± 
}
²² 
else
³³ 
{
´´ 
	PoolChunk
µµ 
<
µµ 
T
µµ 
>
µµ 
next
µµ !
=
µµ" #
cur
µµ$ '
.
µµ' (
Next
µµ( ,
;
µµ, -
cur
¶¶ 
.
¶¶ 
Prev
¶¶ 
.
¶¶ 
Next
¶¶ 
=
¶¶ 
next
¶¶  $
;
¶¶$ %
if
·· 
(
·· 
next
·· 
!=
·· 
null
··  
)
··  !
{
¸¸ 
next
¹¹ 
.
¹¹ 
Prev
¹¹ 
=
¹¹ 
cur
¹¹  #
.
¹¹# $
Prev
¹¹$ (
;
¹¹( )
}
ºº 
}
»» 
}
¼¼ 	
public
¾¾ 
int
¾¾ 
MinUsage
¾¾ 
=>
¾¾ 
	MinUsage0
¾¾ (
(
¾¾( )
this
¾¾) -
.
¾¾- .
minUsage
¾¾. 6
)
¾¾6 7
;
¾¾7 8
public
ÀÀ 
int
ÀÀ 
MaxUsage
ÀÀ 
=>
ÀÀ 
Math
ÀÀ #
.
ÀÀ# $
Min
ÀÀ$ '
(
ÀÀ' (
this
ÀÀ( ,
.
ÀÀ, -
maxUsage
ÀÀ- 5
,
ÀÀ5 6
$num
ÀÀ7 :
)
ÀÀ: ;
;
ÀÀ; <
static
ÂÂ 
int
ÂÂ 
	MinUsage0
ÂÂ 
(
ÂÂ 
int
ÂÂ  
value
ÂÂ! &
)
ÂÂ& '
=>
ÂÂ( *
Math
ÂÂ+ /
.
ÂÂ/ 0
Max
ÂÂ0 3
(
ÂÂ3 4
$num
ÂÂ4 5
,
ÂÂ5 6
value
ÂÂ7 <
)
ÂÂ< =
;
ÂÂ= >
public
ÄÄ 
IEnumerator
ÄÄ 
<
ÄÄ 
IPoolChunkMetric
ÄÄ +
>
ÄÄ+ ,
GetEnumerator
ÄÄ- :
(
ÄÄ: ;
)
ÄÄ; <
=>
ÄÄ= ?
this
ÅÅ 
.
ÅÅ 
head
ÅÅ 
==
ÅÅ 
null
ÅÅ 
?
ÅÅ 

Enumerable
ÅÅ  *
.
ÅÅ* +
Empty
ÅÅ+ 0
<
ÅÅ0 1
IPoolChunkMetric
ÅÅ1 A
>
ÅÅA B
(
ÅÅB C
)
ÅÅC D
.
ÅÅD E
GetEnumerator
ÅÅE R
(
ÅÅR S
)
ÅÅS T
:
ÅÅU V
this
ÅÅW [
.
ÅÅ[ \#
GetEnumeratorInternal
ÅÅ\ q
(
ÅÅq r
)
ÅÅr s
;
ÅÅs t
IEnumerator
ÇÇ 
IEnumerable
ÇÇ 
.
ÇÇ  
GetEnumerator
ÇÇ  -
(
ÇÇ- .
)
ÇÇ. /
=>
ÇÇ0 2
this
ÇÇ3 7
.
ÇÇ7 8
GetEnumerator
ÇÇ8 E
(
ÇÇE F
)
ÇÇF G
;
ÇÇG H
IEnumerator
ÉÉ 
<
ÉÉ 
IPoolChunkMetric
ÉÉ $
>
ÉÉ$ %#
GetEnumeratorInternal
ÉÉ& ;
(
ÉÉ; <
)
ÉÉ< =
{
ÊÊ 	
lock
ËË 
(
ËË 
this
ËË 
.
ËË 
arena
ËË 
)
ËË 
{
ÌÌ 
for
ÍÍ 
(
ÍÍ 
	PoolChunk
ÍÍ 
<
ÍÍ 
T
ÍÍ  
>
ÍÍ  !
cur
ÍÍ" %
=
ÍÍ& '
this
ÍÍ( ,
.
ÍÍ, -
head
ÍÍ- 1
;
ÍÍ1 2
cur
ÍÍ3 6
!=
ÍÍ7 9
null
ÍÍ: >
;
ÍÍ> ?
)
ÍÍ? @
{
ÎÎ 
yield
ÏÏ 
return
ÏÏ  
cur
ÏÏ! $
;
ÏÏ$ %
cur
ĞĞ 
=
ĞĞ 
cur
ĞĞ 
.
ĞĞ 
Next
ĞĞ "
;
ĞĞ" #
}
ÑÑ 
}
ÒÒ 
}
ÓÓ 	
public
ÕÕ 
override
ÕÕ 
string
ÕÕ 
ToString
ÕÕ '
(
ÕÕ' (
)
ÕÕ( )
{
ÖÖ 	
var
×× 
buf
×× 
=
×× 
new
×× 
StringBuilder
×× '
(
××' (
)
××( )
;
××) *
lock
ØØ 
(
ØØ 
this
ØØ 
.
ØØ 
arena
ØØ 
)
ØØ 
{
ÙÙ 
if
ÚÚ 
(
ÚÚ 
this
ÚÚ 
.
ÚÚ 
head
ÚÚ 
==
ÚÚ  
null
ÚÚ! %
)
ÚÚ% &
{
ÛÛ 
return
ÜÜ 
$str
ÜÜ !
;
ÜÜ! "
}
İİ 
for
ßß 
(
ßß 
	PoolChunk
ßß 
<
ßß 
T
ßß  
>
ßß  !
cur
ßß" %
=
ßß& '
this
ßß( ,
.
ßß, -
head
ßß- 1
;
ßß1 2
;
ßß3 4
)
ßß4 5
{
àà 
buf
áá 
.
áá 
Append
áá 
(
áá 
cur
áá "
)
áá" #
;
áá# $
cur
ââ 
=
ââ 
cur
ââ 
.
ââ 
Next
ââ "
;
ââ" #
if
ãã 
(
ãã 
cur
ãã 
==
ãã 
null
ãã #
)
ãã# $
{
ää 
break
åå 
;
åå 
}
ææ 
buf
çç 
.
çç 
Append
çç 
(
çç 

StringUtil
çç )
.
çç) *
Newline
çç* 1
)
çç1 2
;
çç2 3
}
èè 
}
éé 
return
ëë 
buf
ëë 
.
ëë 
ToString
ëë 
(
ëë  
)
ëë  !
;
ëë! "
}
ìì 	
internal
îî 
void
îî 
Destroy
îî 
(
îî 
	PoolArena
îî '
<
îî' (
T
îî( )
>
îî) *
	poolArena
îî+ 4
)
îî4 5
{
ïï 	
	PoolChunk
ğğ 
<
ğğ 
T
ğğ 
>
ğğ 
chunk
ğğ 
=
ğğ  
this
ğğ! %
.
ğğ% &
head
ğğ& *
;
ğğ* +
while
ññ 
(
ññ 
chunk
ññ 
!=
ññ 
null
ññ  
)
ññ  !
{
òò 
	poolArena
óó 
.
óó 
DestroyChunk
óó &
(
óó& '
chunk
óó' ,
)
óó, -
;
óó- .
chunk
ôô 
=
ôô 
chunk
ôô 
.
ôô 
Next
ôô "
;
ôô" #
}
õõ 
this
÷÷ 
.
÷÷ 
head
÷÷ 
=
÷÷ 
null
÷÷ 
;
÷÷ 
}
øø 	
}
ùù 
}úú şa
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract 
class 
PooledByteBuffer #
<# $
T$ %
>% &
:' (.
"AbstractReferenceCountedByteBuffer) K
{ 
	protected 
internal 
	PoolChunk $
<$ %
T% &
>& '
Chunk( -
;- .
	protected 
internal 
long 
Handle  &
;& '
	protected 
internal 
T 
Memory #
;# $
	protected 
internal 
int 
Offset %
;% &
	protected 
internal 
int 
Length %
;% &
internal 
int 
	MaxLength 
; 
internal 
PoolThreadCache  
<  !
T! "
>" #
Cache$ )
;) *%
PooledByteBufferAllocator !
	allocator" +
;+ ,
	protected 
PooledByteBuffer "
(" #
int# &
maxCapacity' 2
)2 3
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
internal 
virtual 
void 
Init "
(" #
	PoolChunk# ,
<, -
T- .
>. /
chunk0 5
,5 6
long7 ;
handle< B
,B C
intD G
offsetH N
,N O
intP S
lengthT Z
,Z [
int\ _
	maxLength` i
,i j
PoolThreadCachek z
<z {
T{ |
>| }
cache	~ ƒ
)
ƒ „
=>
… ‡
this 
. 
Init0 
( 
chunk 
, 
handle $
,$ %
offset& ,
,, -
length. 4
,4 5
	maxLength6 ?
,? @
cacheA F
)F G
;G H
internal 
virtual 
void 
InitUnpooled *
(* +
	PoolChunk+ 4
<4 5
T5 6
>6 7
chunk8 =
,= >
int? B
lengthC I
)I J
=>K M
thisN R
.R S
Init0S X
(X Y
chunkY ^
,^ _
$num` a
,a b
$numc d
,d e
lengthf l
,l m
lengthn t
,t u
nullv z
)z {
;{ |
void   
Init0   
(   
	PoolChunk   
<   
T   
>   
chunk    %
,  % &
long  ' +
handle  , 2
,  2 3
int  4 7
offset  8 >
,  > ?
int  @ C
length  D J
,  J K
int  L O
	maxLength  P Y
,  Y Z
PoolThreadCache  [ j
<  j k
T  k l
>  l m
cache  n s
)  s t
{!! 	
Debug"" 
."" 
Assert"" 
("" 
handle"" 
>=""  "
$num""# $
)""$ %
;""% &
Debug## 
.## 
Assert## 
(## 
chunk## 
!=## !
null##" &
)##& '
;##' (
this%% 
.%% 
Chunk%% 
=%% 
chunk%% 
;%% 
this&& 
.&& 
Memory&& 
=&& 
chunk&& 
.&&  
Memory&&  &
;&&& '
this'' 
.'' 
	allocator'' 
='' 
chunk'' "
.''" #
Arena''# (
.''( )
Parent'') /
;''/ 0
this(( 
.(( 
Cache(( 
=(( 
cache(( 
;(( 
this)) 
.)) 
Handle)) 
=)) 
handle))  
;))  !
this** 
.** 
Offset** 
=** 
offset**  
;**  !
this++ 
.++ 
Length++ 
=++ 
length++  
;++  !
this,, 
.,, 
	MaxLength,, 
=,, 
	maxLength,, &
;,,& '
}-- 	
public22 
override22 
int22 
Capacity22 $
{33 	
[44 

MethodImpl44 
(44 
MethodImplOptions44 )
.44) *
AggressiveInlining44* <
)44< =
]44= >
get55 
=>55 
this55 
.55 
Length55 
;55 
}66 	
public88 
sealed88 
override88 
IByteBuffer88 *
AdjustCapacity88+ 9
(889 :
int88: =
newCapacity88> I
)88I J
{99 	
this:: 
.:: 
CheckNewCapacity:: !
(::! "
newCapacity::" -
)::- .
;::. /
if== 
(== 
this== 
.== 
Chunk== 
.== 
Unpooled== #
)==# $
{>> 
if?? 
(?? 
newCapacity?? 
==??  "
this??# '
.??' (
Length??( .
)??. /
{@@ 
returnAA 
thisAA 
;AA  
}BB 
}CC 
elseDD 
{EE 
ifFF 
(FF 
newCapacityFF 
>FF  !
thisFF" &
.FF& '
LengthFF' -
)FF- .
{GG 
ifHH 
(HH 
newCapacityHH #
<=HH$ &
thisHH' +
.HH+ ,
	MaxLengthHH, 5
)HH5 6
{II 
thisJJ 
.JJ 
LengthJJ #
=JJ$ %
newCapacityJJ& 1
;JJ1 2
returnKK 
thisKK #
;KK# $
}LL 
}MM 
elseNN 
ifNN 
(NN 
newCapacityNN $
<NN% &
thisNN' +
.NN+ ,
LengthNN, 2
)NN2 3
{OO 
ifPP 
(PP 
newCapacityPP #
>PP$ %
thisPP& *
.PP* +
	MaxLengthPP+ 4
.PP4 5
RightUShiftPP5 @
(PP@ A
$numPPA B
)PPB C
)PPC D
{QQ 
ifRR 
(RR 
thisRR  
.RR  !
	MaxLengthRR! *
<=RR+ -
$numRR. 1
)RR1 2
{SS 
ifTT 
(TT  
newCapacityTT  +
>TT, -
thisTT. 2
.TT2 3
	MaxLengthTT3 <
-TT= >
$numTT? A
)TTA B
{UU 
thisVV  $
.VV$ %
LengthVV% +
=VV, -
newCapacityVV. 9
;VV9 :
thisWW  $
.WW$ %
SetIndexWW% -
(WW- .
MathWW. 2
.WW2 3
MinWW3 6
(WW6 7
thisWW7 ;
.WW; <
ReaderIndexWW< G
,WWG H
newCapacityWWI T
)WWT U
,WWU V
MathWWW [
.WW[ \
MinWW\ _
(WW_ `
thisWW` d
.WWd e
WriterIndexWWe p
,WWp q
newCapacityWWr }
)WW} ~
)WW~ 
;	WW €
returnXX  &
thisXX' +
;XX+ ,
}YY 
}ZZ 
else[[ 
{\\ 
this^^  
.^^  !
Length^^! '
=^^( )
newCapacity^^* 5
;^^5 6
this__  
.__  !
SetIndex__! )
(__) *
Math__* .
.__. /
Min__/ 2
(__2 3
this__3 7
.__7 8
ReaderIndex__8 C
,__C D
newCapacity__E P
)__P Q
,__Q R
Math__S W
.__W X
Min__X [
(__[ \
this__\ `
.__` a
WriterIndex__a l
,__l m
newCapacity__n y
)__y z
)__z {
;__{ |
return`` "
this``# '
;``' (
}aa 
}bb 
}cc 
elsedd 
{ee 
returnff 
thisff 
;ff  
}gg 
}hh 
thiskk 
.kk 
Chunkkk 
.kk 
Arenakk 
.kk 

Reallocatekk '
(kk' (
thiskk( ,
,kk, -
newCapacitykk. 9
,kk9 :
truekk; ?
)kk? @
;kk@ A
returnll 
thisll 
;ll 
}mm 	
publicoo 
sealedoo 
overrideoo  
IByteBufferAllocatoroo 3
	Allocatoroo4 =
=>oo> @
thisooA E
.ooE F
	allocatorooF O
;ooO P
publicqq 
sealedqq 
overrideqq 
IByteBufferqq *
Unwrapqq+ 1
(qq1 2
)qq2 3
=>qq4 6
nullqq7 ;
;qq; <
publicss 
sealedss 
overridess 
IByteBufferss *
RetainedDuplicatess+ <
(ss< =
)ss= >
=>ss? A&
PooledDuplicatedByteBufferssB \
.ss\ ]
NewInstancess] h
(ssh i
thisssi m
,ssm n
thissso s
,sss t
thisssu y
.ssy z
ReaderIndex	ssz …
,
ss… †
this
ss‡ ‹
.
ss‹ Œ
WriterIndex
ssŒ —
)
ss— ˜
;
ss˜ ™
publicuu 
sealeduu 
overrideuu 
IByteBufferuu *
RetainedSliceuu+ 8
(uu8 9
)uu9 :
{vv 	
intww 
indexww 
=ww 
thisww 
.ww 
ReaderIndexww (
;ww( )
returnxx 
thisxx 
.xx 
RetainedSlicexx %
(xx% &
indexxx& +
,xx+ ,
thisxx- 1
.xx1 2
WriterIndexxx2 =
-xx> ?
indexxx@ E
)xxE F
;xxF G
}yy 	
public{{ 
sealed{{ 
override{{ 
IByteBuffer{{ *
RetainedSlice{{+ 8
({{8 9
int{{9 <
index{{= B
,{{B C
int{{D G
length{{H N
){{N O
=>{{P R"
PooledSlicedByteBuffer{{S i
.{{i j
NewInstance{{j u
({{u v
this{{v z
,{{z {
this	{{| €
,
{{€ 
index
{{‚ ‡
,
{{‡ ˆ
length
{{‰ 
)
{{ 
;
{{ ‘
	protected}} 
internal}} 
sealed}} !
override}}" *
void}}+ /

Deallocate}}0 :
(}}: ;
)}}; <
{~~ 	
if 
( 
this 
. 
Handle 
>= 
$num  
)  !
{
€€ 
long
 
handle
 
=
 
this
 "
.
" #
Handle
# )
;
) *
this
‚‚ 
.
‚‚ 
Handle
‚‚ 
=
‚‚ 
-
‚‚ 
$num
‚‚  
;
‚‚  !
this
ƒƒ 
.
ƒƒ 
Memory
ƒƒ 
=
ƒƒ 
default
ƒƒ %
(
ƒƒ% &
T
ƒƒ& '
)
ƒƒ' (
;
ƒƒ( )
this
„„ 
.
„„ 
Chunk
„„ 
.
„„ 
Arena
„„  
.
„„  !
Free
„„! %
(
„„% &
this
„„& *
.
„„* +
Chunk
„„+ 0
,
„„0 1
handle
„„2 8
,
„„8 9
this
„„: >
.
„„> ?
	MaxLength
„„? H
,
„„H I
this
„„J N
.
„„N O
Cache
„„O T
)
„„T U
;
„„U V
this
…… 
.
…… 
Chunk
…… 
=
…… 
null
…… !
;
……! "
}
†† 
}
‡‡ 	
[
‰‰ 	

MethodImpl
‰‰	 
(
‰‰ 
MethodImplOptions
‰‰ %
.
‰‰% & 
AggressiveInlining
‰‰& 8
)
‰‰8 9
]
‰‰9 :
	protected
ŠŠ 
int
ŠŠ 
Idx
ŠŠ 
(
ŠŠ 
int
ŠŠ 
index
ŠŠ #
)
ŠŠ# $
=>
ŠŠ% '
this
ŠŠ( ,
.
ŠŠ, -
Offset
ŠŠ- 3
+
ŠŠ4 5
index
ŠŠ6 ;
;
ŠŠ; <
}
‹‹ 
}ŒŒ Â³
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class %
PooledByteBufferAllocator *
:+ ,'
AbstractByteBufferAllocator- H
,H I.
"IByteBufferAllocatorMetricProviderJ l
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S%
PooledByteBufferAllocatorS l
>l m
(m n
)n o
;o p
public 
static 
readonly 
int "
DefaultNumHeapArena# 6
;6 7
public 
static 
readonly 
int "!
DefaultNumDirectArena# 8
;8 9
public 
static 
readonly 
int "
DefaultPageSize# 2
;2 3
public 
static 
readonly 
int "
DefaultMaxOrder# 2
;2 3
public 
static 
readonly 
int " 
DefaultTinyCacheSize# 7
;7 8
public 
static 
readonly 
int "!
DefaultSmallCacheSize# 8
;8 9
public 
static 
readonly 
int ""
DefaultNormalCacheSize# 9
;9 :
static 
readonly 
int *
DefaultMaxCachedBufferCapacity :
;: ;
static 
readonly 
int $
DefaultCacheTrimInterval 4
;4 5
const!! 
int!! 
MinPageSize!! 
=!! 
$num!!  $
;!!$ %
const"" 
int"" 
MaxChunkSize"" 
=""  
(""! "
int""" %
)""% &
(""& '
(""' (
(""( )
long"") -
)""- .
int"". 1
.""1 2
MaxValue""2 :
+""; <
$num""= >
)""> ?
/""@ A
$num""B C
)""C D
;""D E
static$$ %
PooledByteBufferAllocator$$ (
($$( )
)$$) *
{%% 	
int&& 
defaultPageSize&& 
=&&  !
SystemPropertyUtil&&" 4
.&&4 5
GetInt&&5 ;
(&&; <
$str&&< Y
,&&Y Z
$num&&[ _
)&&_ `
;&&` a
	Exception'' !
pageSizeFallbackCause'' +
='', -
null''. 2
;''2 3
try(( 
{)) *
ValidateAndCalculatePageShifts** .
(**. /
defaultPageSize**/ >
)**> ?
;**? @
}++ 
catch,, 
(,, 
	Exception,, 
t,, 
),, 
{-- !
pageSizeFallbackCause.. %
=..& '
t..( )
;..) *
defaultPageSize// 
=//  !
$num//" &
;//& '
}00 
DefaultPageSize11 
=11 
defaultPageSize11 -
;11- .
int33 
defaultMaxOrder33 
=33  !
SystemPropertyUtil33" 4
.334 5
GetInt335 ;
(33; <
$str33< Y
,33Y Z
$num33[ ]
)33] ^
;33^ _
	Exception44 !
maxOrderFallbackCause44 +
=44, -
null44. 2
;442 3
try55 
{66 )
ValidateAndCalculateChunkSize77 -
(77- .
DefaultPageSize77. =
,77= >
defaultMaxOrder77? N
)77N O
;77O P
}88 
catch99 
(99 
	Exception99 
t99 
)99 
{:: !
maxOrderFallbackCause;; %
=;;& '
t;;( )
;;;) *
defaultMaxOrder<< 
=<<  !
$num<<" $
;<<$ %
}== 
DefaultMaxOrder>> 
=>> 
defaultMaxOrder>> -
;>>- .
intGG 
defaultMinNumArenaGG "
=GG# $
EnvironmentGG% 0
.GG0 1
ProcessorCountGG1 ?
*GG@ A
$numGGB C
;GGC D
DefaultNumHeapArenaHH 
=HH  !
MathHH" &
.HH& '
MaxHH' *
(HH* +
$numHH+ ,
,HH, -
SystemPropertyUtilHH. @
.HH@ A
GetIntHHA G
(HHG H
$strHHH j
,HHj k
defaultMinNumArenaHHl ~
)HH~ 
)	HH €
;
HH€ !
DefaultNumDirectArenaII !
=II" #
MathII$ (
.II( )
MaxII) ,
(II, -
$numII- .
,II. /
SystemPropertyUtilII0 B
.IIB C
GetIntIIC I
(III J
$strIIJ n
,IIn o
defaultMinNumArena	IIp ‚
)
II‚ ƒ
)
IIƒ „
;
II„ … 
DefaultTinyCacheSizeLL  
=LL! "
SystemPropertyUtilLL# 5
.LL5 6
GetIntLL6 <
(LL< =
$strLL= _
,LL_ `
$numLLa d
)LLd e
;LLe f!
DefaultSmallCacheSizeMM !
=MM" #
SystemPropertyUtilMM$ 6
.MM6 7
GetIntMM7 =
(MM= >
$strMM> a
,MMa b
$numMMc f
)MMf g
;MMg h"
DefaultNormalCacheSizeNN "
=NN# $
SystemPropertyUtilNN% 7
.NN7 8
GetIntNN8 >
(NN> ?
$strNN? c
,NNc d
$numNNe g
)NNg h
;NNh i*
DefaultMaxCachedBufferCapacityRR *
=RR+ ,
SystemPropertyUtilRR- ?
.RR? @
GetIntRR@ F
(RRF G
$strRRG s
,RRs t
$numRRu w
*RRx y
$numRRz ~
)RR~ 
;	RR €$
DefaultCacheTrimIntervalUU $
=UU% &
SystemPropertyUtilUU' 9
.UU9 :
GetIntUU: @
(UU@ A
$strVV 6
,VV6 7
$numVV8 <
)VV< =
;VV= >
ifXX 
(XX 
LoggerXX 
.XX 
DebugEnabledXX #
)XX# $
{YY 
LoggerZZ 
.ZZ 
DebugZZ 
(ZZ 
$strZZ E
,ZZE F
DefaultNumHeapArenaZZG Z
)ZZZ [
;ZZ[ \
Logger[[ 
.[[ 
Debug[[ 
([[ 
$str[[ G
,[[G H!
DefaultNumDirectArena[[I ^
)[[^ _
;[[_ `
if\\ 
(\\ !
pageSizeFallbackCause\\ )
==\\* ,
null\\- 1
)\\1 2
{]] 
Logger^^ 
.^^ 
Debug^^  
(^^  !
$str^^! D
,^^D E
DefaultPageSize^^F U
)^^U V
;^^V W
}__ 
else`` 
{aa 
Loggerbb 
.bb 
Debugbb  
(bb  !
$strbb! D
,bbD E
DefaultPageSizebbF U
,bbU V!
pageSizeFallbackCausebbW l
)bbl m
;bbm n
}cc 
ifdd 
(dd !
maxOrderFallbackCausedd )
==dd* ,
nulldd- 1
)dd1 2
{ee 
Loggerff 
.ff 
Debugff  
(ff  !
$strff! D
,ffD E
DefaultMaxOrderffF U
)ffU V
;ffV W
}gg 
elsehh 
{ii 
Loggerjj 
.jj 
Debugjj  
(jj  !
$strjj! D
,jjD E
DefaultMaxOrderjjF U
,jjU V!
maxOrderFallbackCausejjW l
)jjl m
;jjm n
}kk 
Loggerll 
.ll 
Debugll 
(ll 
$strll A
,llA B
DefaultPageSizellC R
<<llS U
DefaultMaxOrderllV e
)lle f
;llf g
Loggermm 
.mm 
Debugmm 
(mm 
$strmm E
,mmE F 
DefaultTinyCacheSizemmG [
)mm[ \
;mm\ ]
Loggernn 
.nn 
Debugnn 
(nn 
$strnn F
,nnF G!
DefaultSmallCacheSizennH ]
)nn] ^
;nn^ _
Loggeroo 
.oo 
Debugoo 
(oo 
$stroo G
,ooG H"
DefaultNormalCacheSizeooI _
)oo_ `
;oo` a
Loggerpp 
.pp 
Debugpp 
(pp 
$strpp O
,ppO P*
DefaultMaxCachedBufferCapacityppQ o
)ppo p
;ppp q
Loggerqq 
.qq 
Debugqq 
(qq 
$strqq I
,qqI J$
DefaultCacheTrimIntervalqqK c
)qqc d
;qqd e
}rr 
Defaulttt 
=tt 
newtt %
PooledByteBufferAllocatortt 3
(tt3 4
PlatformDependenttt4 E
.ttE F!
DirectBufferPreferredttF [
)tt[ \
;tt\ ]
}uu 	
publicww 
staticww 
readonlyww %
PooledByteBufferAllocatorww 8
Defaultww9 @
;ww@ A
readonlyyy 
	PoolArenayy 
<yy 
byteyy 
[yy  
]yy  !
>yy! "
[yy" #
]yy# $

heapArenasyy% /
;yy/ 0
readonlyzz 
	PoolArenazz 
<zz 
bytezz 
[zz  
]zz  !
>zz! "
[zz" #
]zz# $
directArenaszz% 1
;zz1 2
readonly{{ 
int{{ 
tinyCacheSize{{ "
;{{" #
readonly|| 
int|| 
smallCacheSize|| #
;||# $
readonly}} 
int}} 
normalCacheSize}} $
;}}$ %
readonly~~ 
IReadOnlyList~~ 
<~~ 
IPoolArenaMetric~~ /
>~~/ 0
heapArenaMetrics~~1 A
;~~A B
readonly 
IReadOnlyList 
< 
IPoolArenaMetric /
>/ 0
directArenaMetrics1 C
;C D
readonly
€€ "
PoolThreadLocalCache
€€ %
threadCache
€€& 1
;
€€1 2
readonly
 
int
 
	chunkSize
 
;
 
readonly
‚‚ -
PooledByteBufferAllocatorMetric
‚‚ 0
metric
‚‚1 7
;
‚‚7 8
public
„„ '
PooledByteBufferAllocator
„„ (
(
„„( )
)
„„) *
:
„„+ ,
this
„„- 1
(
„„1 2
false
„„2 7
)
„„7 8
{
…… 	
}
†† 	
public
ˆˆ 
unsafe
ˆˆ '
PooledByteBufferAllocator
ˆˆ /
(
ˆˆ/ 0
bool
ˆˆ0 4
preferDirect
ˆˆ5 A
)
ˆˆA B
:
‰‰ 
this
‰‰ 
(
‰‰ 
preferDirect
‰‰ 
,
‰‰  !
DefaultNumHeapArena
‰‰! 4
,
‰‰4 5#
DefaultNumDirectArena
‰‰6 K
,
‰‰K L
DefaultPageSize
‰‰M \
,
‰‰\ ]
DefaultMaxOrder
‰‰^ m
)
‰‰m n
{
ŠŠ 	
}
‹‹ 	
public
 '
PooledByteBufferAllocator
 (
(
( )
int
) ,

nHeapArena
- 7
,
7 8
int
9 <
nDirectArena
= I
,
I J
int
K N
pageSize
O W
,
W X
int
Y \
maxOrder
] e
)
e f
:
 
this
 
(
 
false
 
,
 

nHeapArena
 $
,
$ %
nDirectArena
& 2
,
2 3
pageSize
4 <
,
< =
maxOrder
> F
)
F G
{
 	
}
 	
public
’’ 
unsafe
’’ '
PooledByteBufferAllocator
’’ /
(
’’/ 0
bool
’’0 4
preferDirect
’’5 A
,
’’A B
int
’’C F

nHeapArena
’’G Q
,
’’Q R
int
’’S V
nDirectArena
’’W c
,
’’c d
int
’’e h
pageSize
’’i q
,
’’q r
int
’’s v
maxOrder
’’w 
)’’ €
:
““ 
this
““ 
(
““ 
preferDirect
““ 
,
““  

nHeapArena
““! +
,
““+ ,
nDirectArena
““- 9
,
““9 :
pageSize
““; C
,
““C D
maxOrder
““E M
,
““M N"
DefaultTinyCacheSize
”” $
,
””$ %#
DefaultSmallCacheSize
””& ;
,
””; <$
DefaultNormalCacheSize
””= S
)
””S T
{
•• 	
}
–– 	
public
˜˜ '
PooledByteBufferAllocator
˜˜ (
(
˜˜( )
int
˜˜) ,

nHeapArena
˜˜- 7
,
˜˜7 8
int
˜˜9 <
nDirectArena
˜˜= I
,
˜˜I J
int
˜˜K N
pageSize
˜˜O W
,
˜˜W X
int
˜˜Y \
maxOrder
˜˜] e
,
˜˜e f
int
™™ 
tinyCacheSize
™™ 
,
™™ 
int
™™ "
smallCacheSize
™™# 1
,
™™1 2
int
™™3 6
normalCacheSize
™™7 F
)
™™F G
:
šš 
this
šš 
(
šš 
false
šš 
,
šš 

nHeapArena
šš $
,
šš$ %
nDirectArena
šš& 2
,
šš2 3
pageSize
šš4 <
,
šš< =
maxOrder
šš> F
,
ššF G
tinyCacheSize
ššH U
,
ššU V
smallCacheSize
ššW e
,
šše f
normalCacheSize
ššg v
)
ššv w
{
›› 	
}
››
 
public
 
unsafe
 '
PooledByteBufferAllocator
 /
(
/ 0
bool
0 4
preferDirect
5 A
,
A B
int
C F

nHeapArena
G Q
,
Q R
int
S V
nDirectArena
W c
,
c d
int
e h
pageSize
i q
,
q r
int
s v
maxOrder
w 
, €
int
 
tinyCacheSize
 
,
 
int
 "
smallCacheSize
# 1
,
1 2
int
3 6
normalCacheSize
7 F
)
F G
:
ŸŸ 
base
ŸŸ 
(
ŸŸ 
preferDirect
ŸŸ 
)
ŸŸ  
{
   	
Contract
¡¡ 
.
¡¡ 
Requires
¡¡ 
(
¡¡ 

nHeapArena
¡¡ (
>=
¡¡) +
$num
¡¡, -
)
¡¡- .
;
¡¡. /
Contract
¢¢ 
.
¢¢ 
Requires
¢¢ 
(
¢¢ 
nDirectArena
¢¢ *
>=
¢¢+ -
$num
¢¢. /
)
¢¢/ 0
;
¢¢0 1
this
¤¤ 
.
¤¤ 
threadCache
¤¤ 
=
¤¤ 
new
¤¤ ""
PoolThreadLocalCache
¤¤# 7
(
¤¤7 8
this
¤¤8 <
)
¤¤< =
;
¤¤= >
this
¥¥ 
.
¥¥ 
tinyCacheSize
¥¥ 
=
¥¥  
tinyCacheSize
¥¥! .
;
¥¥. /
this
¦¦ 
.
¦¦ 
smallCacheSize
¦¦ 
=
¦¦  !
smallCacheSize
¦¦" 0
;
¦¦0 1
this
§§ 
.
§§ 
normalCacheSize
§§  
=
§§! "
normalCacheSize
§§# 2
;
§§2 3
this
¨¨ 
.
¨¨ 
	chunkSize
¨¨ 
=
¨¨ +
ValidateAndCalculateChunkSize
¨¨ :
(
¨¨: ;
pageSize
¨¨; C
,
¨¨C D
maxOrder
¨¨E M
)
¨¨M N
;
¨¨N O
int
ªª 

pageShifts
ªª 
=
ªª ,
ValidateAndCalculatePageShifts
ªª ;
(
ªª; <
pageSize
ªª< D
)
ªªD E
;
ªªE F
if
¬¬ 
(
¬¬ 

nHeapArena
¬¬ 
>
¬¬ 
$num
¬¬ 
)
¬¬ 
{
­­ 
this
®® 
.
®® 

heapArenas
®® 
=
®®  !
NewArenaArray
®®" /
<
®®/ 0
byte
®®0 4
[
®®4 5
]
®®5 6
>
®®6 7
(
®®7 8

nHeapArena
®®8 B
)
®®B C
;
®®C D
var
¯¯ 
metrics
¯¯ 
=
¯¯ 
new
¯¯ !
List
¯¯" &
<
¯¯& '
IPoolArenaMetric
¯¯' 7
>
¯¯7 8
(
¯¯8 9
this
¯¯9 =
.
¯¯= >

heapArenas
¯¯> H
.
¯¯H I
Length
¯¯I O
)
¯¯O P
;
¯¯P Q
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°°  !
<
°°" #
this
°°$ (
.
°°( )

heapArenas
°°) 3
.
°°3 4
Length
°°4 :
;
°°: ;
i
°°< =
++
°°= ?
)
°°? @
{
±± 
var
²² 
arena
²² 
=
²² 
new
²²  #
	HeapArena
²²$ -
(
²²- .
this
²². 2
,
²²2 3
pageSize
²²4 <
,
²²< =
maxOrder
²²> F
,
²²F G

pageShifts
²²H R
,
²²R S
this
²²T X
.
²²X Y
	chunkSize
²²Y b
)
²²b c
;
²²c d
this
³³ 
.
³³ 

heapArenas
³³ #
[
³³# $
i
³³$ %
]
³³% &
=
³³' (
arena
³³) .
;
³³. /
metrics
´´ 
.
´´ 
Add
´´ 
(
´´  
arena
´´  %
)
´´% &
;
´´& '
}
µµ 
this
¶¶ 
.
¶¶ 
heapArenaMetrics
¶¶ %
=
¶¶& '
metrics
¶¶( /
.
¶¶/ 0

AsReadOnly
¶¶0 :
(
¶¶: ;
)
¶¶; <
;
¶¶< =
}
·· 
else
¸¸ 
{
¹¹ 
this
ºº 
.
ºº 

heapArenas
ºº 
=
ºº  !
null
ºº" &
;
ºº& '
this
»» 
.
»» 
heapArenaMetrics
»» %
=
»»& '
new
»»( +
IPoolArenaMetric
»», <
[
»»< =
$num
»»= >
]
»»> ?
;
»»? @
}
¼¼ 
if
¾¾ 
(
¾¾ 
nDirectArena
¾¾ 
>
¾¾ 
$num
¾¾  
)
¾¾  !
{
¿¿ 
this
ÀÀ 
.
ÀÀ 
directArenas
ÀÀ !
=
ÀÀ" #
NewArenaArray
ÀÀ$ 1
<
ÀÀ1 2
byte
ÀÀ2 6
[
ÀÀ6 7
]
ÀÀ7 8
>
ÀÀ8 9
(
ÀÀ9 :
nDirectArena
ÀÀ: F
)
ÀÀF G
;
ÀÀG H
var
ÁÁ 
metrics
ÁÁ 
=
ÁÁ 
new
ÁÁ !
List
ÁÁ" &
<
ÁÁ& '
IPoolArenaMetric
ÁÁ' 7
>
ÁÁ7 8
(
ÁÁ8 9
this
ÁÁ9 =
.
ÁÁ= >
directArenas
ÁÁ> J
.
ÁÁJ K
Length
ÁÁK Q
)
ÁÁQ R
;
ÁÁR S
for
ÂÂ 
(
ÂÂ 
int
ÂÂ 
i
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
i
ÂÂ  !
<
ÂÂ" #
this
ÂÂ$ (
.
ÂÂ( )
directArenas
ÂÂ) 5
.
ÂÂ5 6
Length
ÂÂ6 <
;
ÂÂ< =
i
ÂÂ> ?
++
ÂÂ? A
)
ÂÂA B
{
ÃÃ 
var
ÄÄ 
arena
ÄÄ 
=
ÄÄ 
new
ÄÄ  #
DirectArena
ÄÄ$ /
(
ÄÄ/ 0
this
ÄÄ0 4
,
ÄÄ4 5
pageSize
ÄÄ6 >
,
ÄÄ> ?
maxOrder
ÄÄ@ H
,
ÄÄH I

pageShifts
ÄÄJ T
,
ÄÄT U
this
ÄÄV Z
.
ÄÄZ [
	chunkSize
ÄÄ[ d
)
ÄÄd e
;
ÄÄe f
this
ÅÅ 
.
ÅÅ 
directArenas
ÅÅ %
[
ÅÅ% &
i
ÅÅ& '
]
ÅÅ' (
=
ÅÅ) *
arena
ÅÅ+ 0
;
ÅÅ0 1
metrics
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ  
arena
ÆÆ  %
)
ÆÆ% &
;
ÆÆ& '
}
ÇÇ 
this
ÈÈ 
.
ÈÈ  
directArenaMetrics
ÈÈ '
=
ÈÈ( )
metrics
ÈÈ* 1
.
ÈÈ1 2

AsReadOnly
ÈÈ2 <
(
ÈÈ< =
)
ÈÈ= >
;
ÈÈ> ?
}
ÉÉ 
else
ÊÊ 
{
ËË 
this
ÌÌ 
.
ÌÌ 
directArenas
ÌÌ !
=
ÌÌ" #
null
ÌÌ$ (
;
ÌÌ( )
this
ÍÍ 
.
ÍÍ  
directArenaMetrics
ÍÍ '
=
ÍÍ( )
new
ÍÍ* -
IPoolArenaMetric
ÍÍ. >
[
ÍÍ> ?
$num
ÍÍ? @
]
ÍÍ@ A
;
ÍÍA B
}
ÎÎ 
this
ĞĞ 
.
ĞĞ 
metric
ĞĞ 
=
ĞĞ 
new
ĞĞ -
PooledByteBufferAllocatorMetric
ĞĞ =
(
ĞĞ= >
this
ĞĞ> B
)
ĞĞB C
;
ĞĞC D
}
ÑÑ 	
static
ÓÓ 
	PoolArena
ÓÓ 
<
ÓÓ 
T
ÓÓ 
>
ÓÓ 
[
ÓÓ 
]
ÓÓ 
NewArenaArray
ÓÓ +
<
ÓÓ+ ,
T
ÓÓ, -
>
ÓÓ- .
(
ÓÓ. /
int
ÓÓ/ 2
size
ÓÓ3 7
)
ÓÓ7 8
=>
ÓÓ9 ;
new
ÓÓ< ?
	PoolArena
ÓÓ@ I
<
ÓÓI J
T
ÓÓJ K
>
ÓÓK L
[
ÓÓL M
size
ÓÓM Q
]
ÓÓQ R
;
ÓÓR S
static
ÕÕ 
int
ÕÕ ,
ValidateAndCalculatePageShifts
ÕÕ 1
(
ÕÕ1 2
int
ÕÕ2 5
pageSize
ÕÕ6 >
)
ÕÕ> ?
{
ÖÖ 	
Contract
×× 
.
×× 
Requires
×× 
(
×× 
pageSize
×× &
>=
××' )
MinPageSize
××* 5
)
××5 6
;
××6 7
Contract
ØØ 
.
ØØ 
Requires
ØØ 
(
ØØ 
(
ØØ 
pageSize
ØØ '
&
ØØ( )
pageSize
ØØ* 2
-
ØØ3 4
$num
ØØ5 6
)
ØØ6 7
==
ØØ8 :
$num
ØØ; <
,
ØØ< =
$str
ØØ> S
)
ØØS T
;
ØØT U
return
ÛÛ 
(
ÛÛ 
sizeof
ÛÛ 
(
ÛÛ 
int
ÛÛ 
)
ÛÛ 
*
ÛÛ  !
$num
ÛÛ" #
-
ÛÛ$ %
$num
ÛÛ& '
)
ÛÛ' (
-
ÛÛ) *
pageSize
ÛÛ+ 3
.
ÛÛ3 4"
NumberOfLeadingZeros
ÛÛ4 H
(
ÛÛH I
)
ÛÛI J
;
ÛÛJ K
}
ÜÜ 	
static
ŞŞ 
int
ŞŞ +
ValidateAndCalculateChunkSize
ŞŞ 0
(
ŞŞ0 1
int
ŞŞ1 4
pageSize
ŞŞ5 =
,
ŞŞ= >
int
ŞŞ? B
maxOrder
ŞŞC K
)
ŞŞK L
{
ßß 	
Contract
àà 
.
àà 
Requires
àà 
(
àà 
maxOrder
àà &
<=
àà' )
$num
àà* ,
)
àà, -
;
àà- .
int
ãã 
	chunkSize
ãã 
=
ãã 
pageSize
ãã $
;
ãã$ %
for
ää 
(
ää 
int
ää 
i
ää 
=
ää 
maxOrder
ää !
;
ää! "
i
ää# $
>
ää% &
$num
ää' (
;
ää( )
i
ää* +
--
ää+ -
)
ää- .
{
åå 
if
ææ 
(
ææ 
	chunkSize
ææ 
>
ææ 
MaxChunkSize
ææ  ,
>>
ææ- /
$num
ææ0 1
)
ææ1 2
{
çç 
throw
èè 
new
èè 
ArgumentException
èè /
(
èè/ 0
$"
èè0 2
$str
èè2 <
{
èè< =
pageSize
èè= E
}
èèE F
$str
èèF U
{
èèU V
maxOrder
èèV ^
}
èè^ _
$str
èè_ q
{
èèq r
MaxChunkSize
èèr ~
}
èè~ 
"èè €
)èè€ 
;èè ‚
}
éé 
	chunkSize
êê 
<<=
êê 
$num
êê 
;
êê  
}
ëë 
return
ìì 
	chunkSize
ìì 
;
ìì 
}
íí 	
	protected
ïï 
override
ïï 
IByteBuffer
ïï &
NewHeapBuffer
ïï' 4
(
ïï4 5
int
ïï5 8
initialCapacity
ïï9 H
,
ïïH I
int
ïïJ M
maxCapacity
ïïN Y
)
ïïY Z
{
ğğ 	
PoolThreadCache
ññ 
<
ññ 
byte
ññ  
[
ññ  !
]
ññ! "
>
ññ" #
cache
ññ$ )
=
ññ* +
this
ññ, 0
.
ññ0 1
threadCache
ññ1 <
.
ññ< =
Value
ññ= B
;
ññB C
	PoolArena
òò 
<
òò 
byte
òò 
[
òò 
]
òò 
>
òò 
	heapArena
òò '
=
òò( )
cache
òò* /
.
òò/ 0
	HeapArena
òò0 9
;
òò9 :
IByteBuffer
ôô 
buf
ôô 
;
ôô 
if
õõ 
(
õõ 
	heapArena
õõ 
!=
õõ 
null
õõ !
)
õõ! "
{
öö 
buf
÷÷ 
=
÷÷ 
	heapArena
÷÷ 
.
÷÷  
Allocate
÷÷  (
(
÷÷( )
cache
÷÷) .
,
÷÷. /
initialCapacity
÷÷0 ?
,
÷÷? @
maxCapacity
÷÷A L
)
÷÷L M
;
÷÷M N
}
øø 
else
ùù 
{
úú 
buf
ûû 
=
ûû 
new
ûû $
UnpooledHeapByteBuffer
ûû 0
(
ûû0 1
this
ûû1 5
,
ûû5 6
initialCapacity
ûû7 F
,
ûûF G
maxCapacity
ûûH S
)
ûûS T
;
ûûT U
}
üü 
return
şş 
ToLeakAwareBuffer
şş $
(
şş$ %
buf
şş% (
)
şş( )
;
şş) *
}
ÿÿ 	
	protected
 
unsafe
 
override
 !
IByteBuffer
" -
NewDirectBuffer
. =
(
= >
int
> A
initialCapacity
B Q
,
Q R
int
S V
maxCapacity
W b
)
b c
{
‚‚ 	
PoolThreadCache
ƒƒ 
<
ƒƒ 
byte
ƒƒ  
[
ƒƒ  !
]
ƒƒ! "
>
ƒƒ" #
cache
ƒƒ$ )
=
ƒƒ* +
this
ƒƒ, 0
.
ƒƒ0 1
threadCache
ƒƒ1 <
.
ƒƒ< =
Value
ƒƒ= B
;
ƒƒB C
	PoolArena
„„ 
<
„„ 
byte
„„ 
[
„„ 
]
„„ 
>
„„ 
directArena
„„ )
=
„„* +
cache
„„, 1
.
„„1 2
DirectArena
„„2 =
;
„„= >
IByteBuffer
†† 
buf
†† 
;
†† 
if
‡‡ 
(
‡‡ 
directArena
‡‡ 
!=
‡‡ 
null
‡‡ #
)
‡‡# $
{
ˆˆ 
buf
‰‰ 
=
‰‰ 
directArena
‰‰ !
.
‰‰! "
Allocate
‰‰" *
(
‰‰* +
cache
‰‰+ 0
,
‰‰0 1
initialCapacity
‰‰2 A
,
‰‰A B
maxCapacity
‰‰C N
)
‰‰N O
;
‰‰O P
}
ŠŠ 
else
‹‹ 
{
ŒŒ 
buf
 
=
 "
UnsafeByteBufferUtil
 *
.
* +'
NewUnsafeDirectByteBuffer
+ D
(
D E
this
E I
,
I J
initialCapacity
K Z
,
Z [
maxCapacity
\ g
)
g h
;
h i
}
 
return
 
ToLeakAwareBuffer
 $
(
$ %
buf
% (
)
( )
;
) *
}
‘‘ 	
public
““ 
static
““ 
bool
““ !
DefaultPreferDirect
““ .
=>
““/ 1
PlatformDependent
““2 C
.
““C D#
DirectBufferPreferred
““D Y
;
““Y Z
public
•• 
override
•• 
bool
•• "
IsDirectBufferPooled
•• 1
=>
••2 4
this
••5 9
.
••9 :
directArenas
••: F
!=
••G I
null
••J N
;
••N O
sealed
—— 
class
—— "
PoolThreadLocalCache
—— )
:
——* +
FastThreadLocal
——, ;
<
——; <
PoolThreadCache
——< K
<
——K L
byte
——L P
[
——P Q
]
——Q R
>
——R S
>
——S T
{
˜˜ 	
readonly
™™ '
PooledByteBufferAllocator
™™ .
owner
™™/ 4
;
™™4 5
public
›› "
PoolThreadLocalCache
›› '
(
››' ('
PooledByteBufferAllocator
››( A
owner
››B G
)
››G H
{
œœ 
this
 
.
 
owner
 
=
 
owner
 "
;
" #
}
 
	protected
   
override
   
PoolThreadCache
   .
<
  . /
byte
  / 3
[
  3 4
]
  4 5
>
  5 6
GetInitialValue
  7 F
(
  F G
)
  G H
{
¡¡ 
lock
¢¢ 
(
¢¢ 
this
¢¢ 
)
¢¢ 
{
££ 
	PoolArena
¤¤ 
<
¤¤ 
byte
¤¤ "
[
¤¤" #
]
¤¤# $
>
¤¤$ %
	heapArena
¤¤& /
=
¤¤0 1
this
¤¤2 6
.
¤¤6 7
LeastUsedArena
¤¤7 E
(
¤¤E F
this
¤¤F J
.
¤¤J K
owner
¤¤K P
.
¤¤P Q

heapArenas
¤¤Q [
)
¤¤[ \
;
¤¤\ ]
	PoolArena
¥¥ 
<
¥¥ 
byte
¥¥ "
[
¥¥" #
]
¥¥# $
>
¥¥$ %
directArena
¥¥& 1
=
¥¥2 3
this
¥¥4 8
.
¥¥8 9
LeastUsedArena
¥¥9 G
(
¥¥G H
this
¥¥H L
.
¥¥L M
owner
¥¥M R
.
¥¥R S
directArenas
¥¥S _
)
¥¥_ `
;
¥¥` a
return
§§ 
new
§§ 
PoolThreadCache
§§ .
<
§§. /
byte
§§/ 3
[
§§3 4
]
§§4 5
>
§§5 6
(
§§6 7
	heapArena
¨¨ %
,
¨¨% &
directArena
¨¨' 2
,
¨¨2 3
this
©©  
.
©©  !
owner
©©! &
.
©©& '
tinyCacheSize
©©' 4
,
©©4 5
this
©©6 :
.
©©: ;
owner
©©; @
.
©©@ A
smallCacheSize
©©A O
,
©©O P
this
©©Q U
.
©©U V
owner
©©V [
.
©©[ \
normalCacheSize
©©\ k
,
©©k l,
DefaultMaxCachedBufferCapacity
ªª :
,
ªª: ;&
DefaultCacheTrimInterval
ªª< T
)
ªªT U
;
ªªU V
}
«« 
}
¬¬ 
	protected
®® 
override
®® 
void
®® #
	OnRemoval
®®$ -
(
®®- .
PoolThreadCache
®®. =
<
®®= >
byte
®®> B
[
®®B C
]
®®C D
>
®®D E
threadCache
®®F Q
)
®®Q R
=>
®®S U
threadCache
®®V a
.
®®a b
Free
®®b f
(
®®f g
)
®®g h
;
®®h i
	PoolArena
°° 
<
°° 
T
°° 
>
°° 
LeastUsedArena
°° '
<
°°' (
T
°°( )
>
°°) *
(
°°* +
	PoolArena
°°+ 4
<
°°4 5
T
°°5 6
>
°°6 7
[
°°7 8
]
°°8 9
arenas
°°: @
)
°°@ A
{
±± 
if
²² 
(
²² 
arenas
²² 
==
²² 
null
²² "
||
²²# %
arenas
²²& ,
.
²², -
Length
²²- 3
==
²²4 6
$num
²²7 8
)
²²8 9
{
³³ 
return
´´ 
null
´´ 
;
´´  
}
µµ 
	PoolArena
·· 
<
·· 
T
·· 
>
·· 
minArena
·· %
=
··& '
arenas
··( .
[
··. /
$num
··/ 0
]
··0 1
;
··1 2
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸  !
<
¸¸" #
arenas
¸¸$ *
.
¸¸* +
Length
¸¸+ 1
;
¸¸1 2
i
¸¸3 4
++
¸¸4 6
)
¸¸6 7
{
¹¹ 
	PoolArena
ºº 
<
ºº 
T
ºº 
>
ºº  
arena
ºº! &
=
ºº' (
arenas
ºº) /
[
ºº/ 0
i
ºº0 1
]
ºº1 2
;
ºº2 3
if
»» 
(
»» 
arena
»» 
.
»» 
NumThreadCaches
»» -
<
»». /
minArena
»»0 8
.
»»8 9
NumThreadCaches
»»9 H
)
»»H I
{
¼¼ 
minArena
½½  
=
½½! "
arena
½½# (
;
½½( )
}
¾¾ 
}
¿¿ 
return
ÁÁ 
minArena
ÁÁ 
;
ÁÁ  
}
ÂÂ 
}
ÃÃ 	
internal
ÅÅ 
IReadOnlyList
ÅÅ 
<
ÅÅ 
IPoolArenaMetric
ÅÅ /
>
ÅÅ/ 0

HeapArenas
ÅÅ1 ;
(
ÅÅ; <
)
ÅÅ< =
=>
ÅÅ> @
this
ÅÅA E
.
ÅÅE F
heapArenaMetrics
ÅÅF V
;
ÅÅV W
internal
ÇÇ 
IReadOnlyList
ÇÇ 
<
ÇÇ 
IPoolArenaMetric
ÇÇ /
>
ÇÇ/ 0
DirectArenas
ÇÇ1 =
(
ÇÇ= >
)
ÇÇ> ?
=>
ÇÇ@ B
this
ÇÇC G
.
ÇÇG H 
directArenaMetrics
ÇÇH Z
;
ÇÇZ [
internal
ÉÉ 
int
ÉÉ 
TinyCacheSize
ÉÉ "
=>
ÉÉ# %
this
ÉÉ& *
.
ÉÉ* +
tinyCacheSize
ÉÉ+ 8
;
ÉÉ8 9
internal
ËË 
int
ËË 
SmallCacheSize
ËË #
=>
ËË$ &
this
ËË' +
.
ËË+ ,
smallCacheSize
ËË, :
;
ËË: ;
internal
ÍÍ 
int
ÍÍ 
NormalCacheSize
ÍÍ $
=>
ÍÍ% '
this
ÍÍ( ,
.
ÍÍ, -
normalCacheSize
ÍÍ- <
;
ÍÍ< =
internal
ÏÏ 
int
ÏÏ 
	ChunkSize
ÏÏ 
=>
ÏÏ !
this
ÏÏ" &
.
ÏÏ& '
	chunkSize
ÏÏ' 0
;
ÏÏ0 1
public
ÑÑ -
PooledByteBufferAllocatorMetric
ÑÑ .
Metric
ÑÑ/ 5
=>
ÑÑ6 8
this
ÑÑ9 =
.
ÑÑ= >
metric
ÑÑ> D
;
ÑÑD E(
IByteBufferAllocatorMetric
ÓÓ "0
"IByteBufferAllocatorMetricProvider
ÓÓ# E
.
ÓÓE F
Metric
ÓÓF L
=>
ÓÓM O
this
ÓÓP T
.
ÓÓT U
Metric
ÓÓU [
;
ÓÓ[ \
internal
ÕÕ 
long
ÕÕ 
UsedHeapMemory
ÕÕ $
=>
ÕÕ% '

UsedMemory
ÕÕ( 2
(
ÕÕ2 3
this
ÕÕ3 7
.
ÕÕ7 8

heapArenas
ÕÕ8 B
)
ÕÕB C
;
ÕÕC D
internal
×× 
long
×× 
UsedDirectMemory
×× &
=>
××' )

UsedMemory
××* 4
(
××4 5
this
××5 9
.
××9 :
directArenas
××: F
)
××F G
;
××G H
static
ÙÙ 
long
ÙÙ 

UsedMemory
ÙÙ 
(
ÙÙ 
	PoolArena
ÙÙ (
<
ÙÙ( )
byte
ÙÙ) -
[
ÙÙ- .
]
ÙÙ. /
>
ÙÙ/ 0
[
ÙÙ0 1
]
ÙÙ1 2
arenas
ÙÙ3 9
)
ÙÙ9 :
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
arenas
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
{
ÜÜ 
return
İİ 
-
İİ 
$num
İİ 
;
İİ 
}
ŞŞ 
long
ßß 
used
ßß 
=
ßß 
$num
ßß 
;
ßß 
foreach
àà 
(
àà 
	PoolArena
àà 
<
àà 
byte
àà #
[
àà# $
]
àà$ %
>
àà% &
arena
àà' ,
in
àà- /
arenas
àà0 6
)
àà6 7
{
áá 
used
ââ 
+=
ââ 
arena
ââ 
.
ââ 
NumActiveBytes
ââ ,
;
ââ, -
if
ãã 
(
ãã 
used
ãã 
<
ãã 
$num
ãã 
)
ãã 
{
ää 
return
åå 
long
åå 
.
åå  
MaxValue
åå  (
;
åå( )
}
ææ 
}
çç 
return
éé 
used
éé 
;
éé 
}
êê 	
internal
ìì 
PoolThreadCache
ìì  
<
ìì  !
T
ìì! "
>
ìì" #
ThreadCache
ìì$ /
<
ìì/ 0
T
ìì0 1
>
ìì1 2
(
ìì2 3
)
ìì3 4
=>
ìì5 7
(
ìì8 9
PoolThreadCache
ìì9 H
<
ììH I
T
ììI J
>
ììJ K
)
ììK L
(
ììL M
object
ììM S
)
ììS T
this
ììT X
.
ììX Y
threadCache
ììY d
.
ììd e
Value
ììe j
;
ììj k
public
ğğ 
string
ğğ 
	DumpStats
ğğ 
(
ğğ  
)
ğğ  !
{
ññ 	
int
òò 
heapArenasLen
òò 
=
òò 
this
òò  $
.
òò$ %

heapArenas
òò% /
?
òò/ 0
.
òò0 1
Length
òò1 7
??
òò8 :
$num
òò; <
;
òò< =
StringBuilder
óó 
buf
óó 
=
óó 
new
óó  #
StringBuilder
óó$ 1
(
óó1 2
$num
óó2 5
)
óó5 6
.
ôô 
Append
ôô 
(
ôô 
heapArenasLen
ôô )
)
ôô) *
.
õõ 
Append
õõ 
(
õõ 
$str
õõ -
)
õõ- .
.
öö 
Append
öö 
(
öö 

StringUtil
öö &
.
öö& '
Newline
öö' .
)
öö. /
;
öö/ 0
if
÷÷ 
(
÷÷ 
heapArenasLen
÷÷ 
>
÷÷ 
$num
÷÷  !
)
÷÷! "
{
øø 
foreach
úú 
(
úú 
	PoolArena
úú "
<
úú" #
byte
úú# '
[
úú' (
]
úú( )
>
úú) *
a
úú+ ,
in
úú- /
this
úú0 4
.
úú4 5

heapArenas
úú5 ?
)
úú? @
{
ûû 
buf
üü 
.
üü 
Append
üü 
(
üü 
a
üü  
)
üü  !
;
üü! "
}
ıı 
}
şş 
int
€€ 
directArenasLen
€€ 
=
€€  !
this
€€" &
.
€€& '
directArenas
€€' 3
?
€€3 4
.
€€4 5
Length
€€5 ;
??
€€< >
$num
€€? @
;
€€@ A
buf
 
.
 
Append
 
(
 
directArenasLen
 &
)
& '
.
‚‚ 
Append
‚‚ 
(
‚‚ 
$str
‚‚ +
)
‚‚+ ,
.
ƒƒ 
Append
ƒƒ 
(
ƒƒ 

StringUtil
ƒƒ "
.
ƒƒ" #
Newline
ƒƒ# *
)
ƒƒ* +
;
ƒƒ+ ,
if
„„ 
(
„„ 
directArenasLen
„„ 
>
„„  !
$num
„„" #
)
„„# $
{
…… 
foreach
‡‡ 
(
‡‡ 
	PoolArena
‡‡ "
<
‡‡" #
byte
‡‡# '
[
‡‡' (
]
‡‡( )
>
‡‡) *
a
‡‡+ ,
in
‡‡- /
this
‡‡0 4
.
‡‡4 5
directArenas
‡‡5 A
)
‡‡A B
{
ˆˆ 
buf
‰‰ 
.
‰‰ 
Append
‰‰ 
(
‰‰ 
a
‰‰  
)
‰‰  !
;
‰‰! "
}
ŠŠ 
}
‹‹ 
return
 
buf
 
.
 
ToString
 
(
  
)
  !
;
! "
}
 	
}
 
} 5
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBufferAllocatorMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public

 

sealed

 
class

 +
PooledByteBufferAllocatorMetric

 7
:

8 9&
IByteBufferAllocatorMetric

: T
{ 
readonly %
PooledByteBufferAllocator *
	allocator+ 4
;4 5
internal +
PooledByteBufferAllocatorMetric 0
(0 1%
PooledByteBufferAllocator1 J
	allocatorK T
)T U
{ 	
this 
. 
	allocator 
= 
	allocator &
;& '
} 	
public 
IReadOnlyList 
< 
IPoolArenaMetric -
>- .

HeapArenas/ 9
(9 :
): ;
=>< >
this? C
.C D
	allocatorD M
.M N

HeapArenasN X
(X Y
)Y Z
;Z [
public 
IReadOnlyList 
< 
IPoolArenaMetric -
>- .
DirectArenas/ ;
(; <
)< =
=>> @
thisA E
.E F
	allocatorF O
.O P
DirectArenasP \
(\ ]
)] ^
;^ _
public 
int 
TinyCacheSize  
=>! #
this$ (
.( )
	allocator) 2
.2 3
TinyCacheSize3 @
;@ A
public 
int 
SmallCacheSize !
=>" $
this% )
.) *
	allocator* 3
.3 4
SmallCacheSize4 B
;B C
public 
int 
NormalCacheSize "
=># %
this& *
.* +
	allocator+ 4
.4 5
NormalCacheSize5 D
;D E
public 
int 
	ChunkSize 
=> 
this  $
.$ %
	allocator% .
.. /
	ChunkSize/ 8
;8 9
public 
long 
UsedHeapMemory "
=># %
this& *
.* +
	allocator+ 4
.4 5
UsedHeapMemory5 C
;C D
public!! 
long!! 
UsedDirectMemory!! $
=>!!% '
this!!( ,
.!!, -
	allocator!!- 6
.!!6 7
UsedDirectMemory!!7 G
;!!G H
public## 
int##  
NumThreadLocalCaches## '
(##' (
)##( )
{$$ 	
int%% 
total%% 
=%% 
$num%% 
;%% 
IReadOnlyList&& 
<&& 
IPoolArenaMetric&& *
>&&* +
arenas&&, 2
=&&3 4
this&&5 9
.&&9 :

HeapArenas&&: D
(&&D E
)&&E F
;&&F G
if'' 
('' 
arenas'' 
!='' 
null'' 
)'' 
{(( 
foreach)) 
()) 
IPoolArenaMetric)) )
metric))* 0
in))1 3
arenas))4 :
))): ;
{** 
total++ 
+=++ 
metric++ #
.++# $
NumThreadCaches++$ 3
;++3 4
},, 
}-- 
arenas// 
=// 
this// 
.// 
DirectArenas// &
(//& '
)//' (
;//( )
if00 
(00 
arenas00 
!=00 
null00 
)00 
{11 
foreach22 
(22 
IPoolArenaMetric22 )
metric22* 0
in221 3
arenas224 :
)22: ;
{33 
total44 
+=44 
metric44 #
.44# $
NumThreadCaches44$ 3
;443 4
}55 
}66 
return88 
total88 
;88 
}99 	
public;; 
override;; 
string;; 
ToString;; '
(;;' (
);;( )
{<< 	
var== 
sb== 
=== 
new== 
StringBuilder== &
(==& '
$num==' *
)==* +
;==+ ,
sb>> 
.>> 
Append>> 
(>> 

StringUtil>>  
.>>  !
SimpleClassName>>! 0
(>>0 1
this>>1 5
)>>5 6
)>>6 7
.?? 
Append?? 
(?? 
$str?? +
)??+ ,
.??, -
Append??- 3
(??3 4
this??4 8
.??8 9
UsedHeapMemory??9 G
)??G H
.@@ 
Append@@ 
(@@ 
$str@@ .
)@@. /
.@@/ 0
Append@@0 6
(@@6 7
this@@7 ;
.@@; <
UsedDirectMemory@@< L
)@@L M
.AA 
AppendAA 
(AA 
$strAA +
)AA+ ,
.AA, -
AppendAA- 3
(AA3 4
thisAA4 8
.AA8 9

HeapArenasAA9 C
(AAC D
)AAD E
.AAE F
CountAAF K
)AAK L
.BB 
AppendBB 
(BB 
$strBB -
)BB- .
.BB. /
AppendBB/ 5
(BB5 6
thisBB6 :
.BB: ;
DirectArenasBB; G
(BBG H
)BBH I
.BBI J
CountBBJ O
)BBO P
.CC 
AppendCC 
(CC 
$strCC +
)CC+ ,
.CC, -
AppendCC- 3
(CC3 4
thisCC4 8
.CC8 9
TinyCacheSizeCC9 F
)CCF G
.DD 
AppendDD 
(DD 
$strDD ,
)DD, -
.DD- .
AppendDD. 4
(DD4 5
thisDD5 9
.DD9 :
SmallCacheSizeDD: H
)DDH I
.EE 
AppendEE 
(EE 
$strEE -
)EE- .
.EE. /
AppendEE/ 5
(EE5 6
thisEE6 :
.EE: ;
NormalCacheSizeEE; J
)EEJ K
.FF 
AppendFF 
(FF 
$strFF 2
)FF2 3
.FF3 4
AppendFF4 :
(FF: ;
thisFF; ?
.FF? @ 
NumThreadLocalCachesFF@ T
(FFT U
)FFU V
)FFV W
.GG 
AppendGG 
(GG 
$strGG '
)GG' (
.GG( )
AppendGG) /
(GG/ 0
thisGG0 4
.GG4 5
	ChunkSizeGG5 >
)GG> ?
.GG? @
AppendGG@ F
(GGF G
$charGGG J
)GGJ K
;GGK L
returnHH 
sbHH 
.HH 
ToStringHH 
(HH 
)HH  
;HH  !
}II 	
}JJ 
}KK Ù
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledDuplicatedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class &
PooledDuplicatedByteBuffer +
:, -+
AbstractPooledDerivedByteBuffer. M
{ 
static 
readonly 
ThreadLocalPool '
<' (&
PooledDuplicatedByteBuffer( B
>B C
RecyclerD L
=M N
newO R
ThreadLocalPoolS b
<b c&
PooledDuplicatedByteBufferc }
>} ~
(~ 
handle	 …
=>
† ˆ
new
‰ Œ(
PooledDuplicatedByteBuffer
 §
(
§ ¨
handle
¨ ®
)
® ¯
)
¯ °
;
° ±
internal 
static &
PooledDuplicatedByteBuffer 2
NewInstance3 >
(> ?
AbstractByteBuffer? Q
	unwrappedR [
,[ \
IByteBuffer] h
wrappedi p
,p q
intr u
readerIndex	v 
,
 ‚
int
ƒ †
writerIndex
‡ ’
)
’ “
{ 	&
PooledDuplicatedByteBuffer &
	duplicate' 0
=1 2
Recycler3 ;
.; <
Take< @
(@ A
)A B
;B C
	duplicate 
. 
Init 
< &
PooledDuplicatedByteBuffer 5
>5 6
(6 7
	unwrapped7 @
,@ A
wrappedB I
,I J
readerIndexK V
,V W
writerIndexX c
,c d
	unwrappede n
.n o
MaxCapacityo z
)z {
;{ |
	duplicate 
. 
MarkReaderIndex %
(% &
)& '
;' (
	duplicate 
. 
MarkWriterIndex %
(% &
)& '
;' (
return 
	duplicate 
; 
} 	
public &
PooledDuplicatedByteBuffer )
() *
ThreadLocalPool* 9
.9 :
Handle: @
recyclerHandleA O
)O P
: 
base 
( 
recyclerHandle !
)! "
{ 	
} 	
public 
override 
int 
Capacity $
=>% '
this( ,
., -
Unwrap- 3
(3 4
)4 5
.5 6
Capacity6 >
;> ?
public!! 
override!! 
IByteBuffer!! #
AdjustCapacity!!$ 2
(!!2 3
int!!3 6
newCapacity!!7 B
)!!B C
{"" 	
this## 
.## 
Unwrap## 
(## 
)## 
.## 
AdjustCapacity## (
(##( )
newCapacity##) 4
)##4 5
;##5 6
return$$ 
this$$ 
;$$ 
}%% 	
public'' 
override'' 
int'' 
ArrayOffset'' '
=>''( *
this''+ /
.''/ 0
Unwrap''0 6
(''6 7
)''7 8
.''8 9
ArrayOffset''9 D
;''D E
public)) 
override)) 
ref)) 
byte))  $
GetPinnableMemoryAddress))! 9
())9 :
))): ;
=>))< >
ref))? B
this))C G
.))G H
Unwrap))H N
())N O
)))O P
.))P Q$
GetPinnableMemoryAddress))Q i
())i j
)))j k
;))k l
public++ 
override++ 
IntPtr++ !
AddressOfPinnedMemory++ 4
(++4 5
)++5 6
=>++7 9
this++: >
.++> ?
Unwrap++? E
(++E F
)++F G
.++G H!
AddressOfPinnedMemory++H ]
(++] ^
)++^ _
;++_ `
public-- 
override-- 
ArraySegment-- $
<--$ %
byte--% )
>--) *
GetIoBuffer--+ 6
(--6 7
int--7 :
index--; @
,--@ A
int--B E
length--F L
)--L M
=>--N P
this--Q U
.--U V
Unwrap--V \
(--\ ]
)--] ^
.--^ _
GetIoBuffer--_ j
(--j k
index--k p
,--p q
length--r x
)--x y
;--y z
public// 
override// 
ArraySegment// $
<//$ %
byte//% )
>//) *
[//* +
]//+ ,
GetIoBuffers//- 9
(//9 :
int//: =
index//> C
,//C D
int//E H
length//I O
)//O P
=>//Q S
this//T X
.//X Y
Unwrap//Y _
(//_ `
)//` a
.//a b
GetIoBuffers//b n
(//n o
index//o t
,//t u
length//v |
)//| }
;//} ~
public11 
override11 
IByteBuffer11 #
Copy11$ (
(11( )
int11) ,
index11- 2
,112 3
int114 7
length118 >
)11> ?
=>11@ B
this11C G
.11G H
Unwrap11H N
(11N O
)11O P
.11P Q
Copy11Q U
(11U V
index11V [
,11[ \
length11] c
)11c d
;11d e
public33 
override33 
IByteBuffer33 #
RetainedSlice33$ 1
(331 2
int332 5
index336 ;
,33; <
int33= @
length33A G
)33G H
=>33I K"
PooledSlicedByteBuffer33L b
.33b c
NewInstance33c n
(33n o
this33o s
.33s t

UnwrapCore33t ~
(33~ 
)	33 €
,
33€ 
this
33‚ †
,
33† ‡
index
33ˆ 
,
33 
length
33 •
)
33• –
;
33– —
public55 
override55 
IByteBuffer55 #
	Duplicate55$ -
(55- .
)55. /
=>550 2
this553 7
.557 8

Duplicate0558 B
(55B C
)55C D
.55D E
SetIndex55E M
(55M N
this55N R
.55R S
ReaderIndex55S ^
,55^ _
this55` d
.55d e
WriterIndex55e p
)55p q
;55q r
public77 
override77 
IByteBuffer77 #
RetainedDuplicate77$ 5
(775 6
)776 7
=>778 :
NewInstance77; F
(77F G
this77G K
.77K L

UnwrapCore77L V
(77V W
)77W X
,77X Y
this77Z ^
,77^ _
this77` d
.77d e
ReaderIndex77e p
,77p q
this77r v
.77v w
WriterIndex	77w ‚
)
77‚ ƒ
;
77ƒ „
	protected99 
internal99 
override99 #
byte99$ (
_GetByte99) 1
(991 2
int992 5
index996 ;
)99; <
=>99= ?
this99@ D
.99D E

UnwrapCore99E O
(99O P
)99P Q
.99Q R
_GetByte99R Z
(99Z [
index99[ `
)99` a
;99a b
	protected;; 
internal;; 
override;; #
short;;$ )
	_GetShort;;* 3
(;;3 4
int;;4 7
index;;8 =
);;= >
=>;;? A
this;;B F
.;;F G

UnwrapCore;;G Q
(;;Q R
);;R S
.;;S T
	_GetShort;;T ]
(;;] ^
index;;^ c
);;c d
;;;d e
	protected== 
internal== 
override== #
short==$ )
_GetShortLE==* 5
(==5 6
int==6 9
index==: ?
)==? @
=>==A C
this==D H
.==H I

UnwrapCore==I S
(==S T
)==T U
.==U V
_GetShortLE==V a
(==a b
index==b g
)==g h
;==h i
	protected?? 
internal?? 
override?? #
int??$ '
_GetUnsignedMedium??( :
(??: ;
int??; >
index??? D
)??D E
=>??F H
this??I M
.??M N

UnwrapCore??N X
(??X Y
)??Y Z
.??Z [
_GetUnsignedMedium??[ m
(??m n
index??n s
)??s t
;??t u
	protectedAA 
internalAA 
overrideAA #
intAA$ ' 
_GetUnsignedMediumLEAA( <
(AA< =
intAA= @
indexAAA F
)AAF G
=>AAH J
thisAAK O
.AAO P

UnwrapCoreAAP Z
(AAZ [
)AA[ \
.AA\ ] 
_GetUnsignedMediumLEAA] q
(AAq r
indexAAr w
)AAw x
;AAx y
	protectedCC 
internalCC 
overrideCC #
intCC$ '
_GetIntCC( /
(CC/ 0
intCC0 3
indexCC4 9
)CC9 :
=>CC; =
thisCC> B
.CCB C

UnwrapCoreCCC M
(CCM N
)CCN O
.CCO P
_GetIntCCP W
(CCW X
indexCCX ]
)CC] ^
;CC^ _
	protectedEE 
internalEE 
overrideEE #
intEE$ '
	_GetIntLEEE( 1
(EE1 2
intEE2 5
indexEE6 ;
)EE; <
=>EE= ?
thisEE@ D
.EED E

UnwrapCoreEEE O
(EEO P
)EEP Q
.EEQ R
	_GetIntLEEER [
(EE[ \
indexEE\ a
)EEa b
;EEb c
	protectedGG 
internalGG 
overrideGG #
longGG$ (
_GetLongGG) 1
(GG1 2
intGG2 5
indexGG6 ;
)GG; <
=>GG= ?
thisGG@ D
.GGD E

UnwrapCoreGGE O
(GGO P
)GGP Q
.GGQ R
_GetLongGGR Z
(GGZ [
indexGG[ `
)GG` a
;GGa b
	protectedII 
internalII 
overrideII #
longII$ (

_GetLongLEII) 3
(II3 4
intII4 7
indexII8 =
)II= >
=>II? A
thisIIB F
.IIF G

UnwrapCoreIIG Q
(IIQ R
)IIR S
.IIS T

_GetLongLEIIT ^
(II^ _
indexII_ d
)IId e
;IIe f
publicKK 
overrideKK 
IByteBufferKK #
GetBytesKK$ ,
(KK, -
intKK- 0
indexKK1 6
,KK6 7
IByteBufferKK8 C
destinationKKD O
,KKO P
intKKQ T
dstIndexKKU ]
,KK] ^
intKK_ b
lengthKKc i
)KKi j
=>KKk m
thisKKn r
.KKr s
UnwrapKKs y
(KKy z
)KKz {
.KK{ |
GetBytes	KK| „
(
KK„ …
index
KK… Š
,
KKŠ ‹
destination
KKŒ —
,
KK— ˜
dstIndex
KK™ ¡
,
KK¡ ¢
length
KK£ ©
)
KK© ª
;
KKª «
publicMM 
overrideMM 
IByteBufferMM #
GetBytesMM$ ,
(MM, -
intMM- 0
indexMM1 6
,MM6 7
byteMM8 <
[MM< =
]MM= >
destinationMM? J
,MMJ K
intMML O
dstIndexMMP X
,MMX Y
intMMZ ]
lengthMM^ d
)MMd e
=>MMf h
thisMMi m
.MMm n
UnwrapMMn t
(MMt u
)MMu v
.MMv w
GetBytesMMw 
(	MM €
index
MM€ …
,
MM… †
destination
MM‡ ’
,
MM’ “
dstIndex
MM” œ
,
MMœ 
length
MM ¤
)
MM¤ ¥
;
MM¥ ¦
publicOO 
overrideOO 
IByteBufferOO #
GetBytesOO$ ,
(OO, -
intOO- 0
indexOO1 6
,OO6 7
StreamOO8 >
destinationOO? J
,OOJ K
intOOL O
lengthOOP V
)OOV W
=>OOX Z
thisOO[ _
.OO_ `
UnwrapOO` f
(OOf g
)OOg h
.OOh i
GetBytesOOi q
(OOq r
indexOOr w
,OOw x
destination	OOy „
,
OO„ …
length
OO† Œ
)
OOŒ 
;
OO 
	protectedQQ 
internalQQ 
overrideQQ #
voidQQ$ (
_SetByteQQ) 1
(QQ1 2
intQQ2 5
indexQQ6 ;
,QQ; <
intQQ= @
valueQQA F
)QQF G
=>QQH J
thisQQK O
.QQO P

UnwrapCoreQQP Z
(QQZ [
)QQ[ \
.QQ\ ]
_SetByteQQ] e
(QQe f
indexQQf k
,QQk l
valueQQm r
)QQr s
;QQs t
	protectedSS 
internalSS 
overrideSS #
voidSS$ (
	_SetShortSS) 2
(SS2 3
intSS3 6
indexSS7 <
,SS< =
intSS> A
valueSSB G
)SSG H
=>SSI K
thisSSL P
.SSP Q

UnwrapCoreSSQ [
(SS[ \
)SS\ ]
.SS] ^
	_SetShortSS^ g
(SSg h
indexSSh m
,SSm n
valueSSo t
)SSt u
;SSu v
	protectedUU 
internalUU 
overrideUU #
voidUU$ (
_SetShortLEUU) 4
(UU4 5
intUU5 8
indexUU9 >
,UU> ?
intUU@ C
valueUUD I
)UUI J
=>UUK M
thisUUN R
.UUR S

UnwrapCoreUUS ]
(UU] ^
)UU^ _
.UU_ `
_SetShortLEUU` k
(UUk l
indexUUl q
,UUq r
valueUUs x
)UUx y
;UUy z
	protectedWW 
internalWW 
overrideWW #
voidWW$ (

_SetMediumWW) 3
(WW3 4
intWW4 7
indexWW8 =
,WW= >
intWW? B
valueWWC H
)WWH I
=>WWJ L
thisWWM Q
.WWQ R

UnwrapCoreWWR \
(WW\ ]
)WW] ^
.WW^ _

_SetMediumWW_ i
(WWi j
indexWWj o
,WWo p
valueWWq v
)WWv w
;WWw x
	protectedYY 
internalYY 
overrideYY #
voidYY$ (
_SetMediumLEYY) 5
(YY5 6
intYY6 9
indexYY: ?
,YY? @
intYYA D
valueYYE J
)YYJ K
=>YYL N
thisYYO S
.YYS T

UnwrapCoreYYT ^
(YY^ _
)YY_ `
.YY` a
_SetMediumLEYYa m
(YYm n
indexYYn s
,YYs t
valueYYu z
)YYz {
;YY{ |
public[[ 
override[[ 
IByteBuffer[[ #
SetBytes[[$ ,
([[, -
int[[- 0
index[[1 6
,[[6 7
IByteBuffer[[8 C
src[[D G
,[[G H
int[[I L
srcIndex[[M U
,[[U V
int[[W Z
length[[[ a
)[[a b
=>[[c e
this[[f j
.[[j k
Unwrap[[k q
([[q r
)[[r s
.[[s t
SetBytes[[t |
([[| }
index	[[} ‚
,
[[‚ ƒ
src
[[„ ‡
,
[[‡ ˆ
srcIndex
[[‰ ‘
,
[[‘ ’
length
[[“ ™
)
[[™ š
;
[[š ›
public]] 
override]] 
Task]] 
<]] 
int]]  
>]]  !
SetBytesAsync]]" /
(]]/ 0
int]]0 3
index]]4 9
,]]9 :
Stream]]; A
src]]B E
,]]E F
int]]G J
length]]K Q
,]]Q R
CancellationToken]]S d
cancellationToken]]e v
)]]v w
=>]]x z
this]]{ 
.	]] €
Unwrap
]]€ †
(
]]† ‡
)
]]‡ ˆ
.
]]ˆ ‰
SetBytesAsync
]]‰ –
(
]]– —
index
]]— œ
,
]]œ 
src
]] ¡
,
]]¡ ¢
length
]]£ ©
,
]]© ª
cancellationToken
]]« ¼
)
]]¼ ½
;
]]½ ¾
public__ 
override__ 
IByteBuffer__ #
SetBytes__$ ,
(__, -
int__- 0
index__1 6
,__6 7
byte__8 <
[__< =
]__= >
src__? B
,__B C
int__D G
srcIndex__H P
,__P Q
int__R U
length__V \
)__\ ]
=>__^ `
this__a e
.__e f
Unwrap__f l
(__l m
)__m n
.__n o
SetBytes__o w
(__w x
index__x }
,__} ~
src	__ ‚
,
__‚ ƒ
srcIndex
__„ Œ
,
__Œ 
length
__ ”
)
__” •
;
__• –
	protectedaa 
internalaa 
overrideaa #
voidaa$ (
_SetIntaa) 0
(aa0 1
intaa1 4
indexaa5 :
,aa: ;
intaa< ?
valueaa@ E
)aaE F
=>aaG I
thisaaJ N
.aaN O

UnwrapCoreaaO Y
(aaY Z
)aaZ [
.aa[ \
_SetIntaa\ c
(aac d
indexaad i
,aai j
valueaak p
)aap q
;aaq r
	protectedcc 
internalcc 
overridecc #
voidcc$ (
	_SetIntLEcc) 2
(cc2 3
intcc3 6
indexcc7 <
,cc< =
intcc> A
valueccB G
)ccG H
=>ccI K
thisccL P
.ccP Q

UnwrapCoreccQ [
(cc[ \
)cc\ ]
.cc] ^
	_SetIntLEcc^ g
(ccg h
indexcch m
,ccm n
valuecco t
)cct u
;ccu v
	protectedee 
internalee 
overrideee #
voidee$ (
_SetLongee) 1
(ee1 2
intee2 5
indexee6 ;
,ee; <
longee= A
valueeeB G
)eeG H
=>eeI K
thiseeL P
.eeP Q

UnwrapCoreeeQ [
(ee[ \
)ee\ ]
.ee] ^
_SetLongee^ f
(eef g
indexeeg l
,eel m
valueeen s
)ees t
;eet u
	protectedgg 
internalgg 
overridegg #
voidgg$ (

_SetLongLEgg) 3
(gg3 4
intgg4 7
indexgg8 =
,gg= >
longgg? C
valueggD I
)ggI J
=>ggK M
thisggN R
.ggR S

UnwrapCoreggS ]
(gg] ^
)gg^ _
.gg_ `

_SetLongLEgg` j
(ggj k
indexggk p
,ggp q
valueggr w
)ggw x
;ggx y
}ii 
}jj Æ¸
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledHeapByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class  
PooledHeapByteBuffer %
:& '
PooledByteBuffer( 8
<8 9
byte9 =
[= >
]> ?
>? @
{ 
internal 
static  
PooledHeapByteBuffer ,
NewInstance- 8
(8 9
int9 <
maxCapacity= H
)H I
{ 	
return 
new  
PooledHeapByteBuffer +
(+ ,
maxCapacity, 7
)7 8
;8 9
} 	
internal  
PooledHeapByteBuffer %
(% &
int& )
maxCapacity* 5
)5 6
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
override 
bool 
IsDirect %
=>& (
false) .
;. /
	protected 
internal 
override #
byte$ (
_GetByte) 1
(1 2
int2 5
index6 ;
); <
=>= ?
HeapByteBufferUtil@ R
.R S
GetByteS Z
(Z [
this[ _
._ `
Memory` f
,f g
thish l
.l m
Idxm p
(p q
indexq v
)v w
)w x
;x y
	protected 
internal 
override #
short$ )
	_GetShort* 3
(3 4
int4 7
index8 =
)= >
=>? A
HeapByteBufferUtilB T
.T U
GetShortU ]
(] ^
this^ b
.b c
Memoryc i
,i j
thisk o
.o p
Idxp s
(s t
indext y
)y z
)z {
;{ |
	protected 
internal 
override #
short$ )
_GetShortLE* 5
(5 6
int6 9
index: ?
)? @
=>A C
HeapByteBufferUtilD V
.V W

GetShortLEW a
(a b
thisb f
.f g
Memoryg m
,m n
thiso s
.s t
Idxt w
(w x
indexx }
)} ~
)~ 
;	 €
	protected   
internal   
override   #
int  $ '
_GetUnsignedMedium  ( :
(  : ;
int  ; >
index  ? D
)  D E
=>  F H
HeapByteBufferUtil  I [
.  [ \
GetUnsignedMedium  \ m
(  m n
this  n r
.  r s
Memory  s y
,  y z
this  { 
.	   €
Idx
  € ƒ
(
  ƒ „
index
  „ ‰
)
  ‰ Š
)
  Š ‹
;
  ‹ Œ
	protected"" 
internal"" 
override"" #
int""$ ' 
_GetUnsignedMediumLE""( <
(""< =
int""= @
index""A F
)""F G
=>""H J
HeapByteBufferUtil""K ]
.""] ^
GetUnsignedMediumLE""^ q
(""q r
this""r v
.""v w
Memory""w }
,""} ~
this	"" ƒ
.
""ƒ „
Idx
""„ ‡
(
""‡ ˆ
index
""ˆ 
)
"" 
)
"" 
;
"" 
	protected$$ 
internal$$ 
override$$ #
int$$$ '
_GetInt$$( /
($$/ 0
int$$0 3
index$$4 9
)$$9 :
=>$$; =
HeapByteBufferUtil$$> P
.$$P Q
GetInt$$Q W
($$W X
this$$X \
.$$\ ]
Memory$$] c
,$$c d
this$$e i
.$$i j
Idx$$j m
($$m n
index$$n s
)$$s t
)$$t u
;$$u v
	protected&& 
internal&& 
override&& #
int&&$ '
	_GetIntLE&&( 1
(&&1 2
int&&2 5
index&&6 ;
)&&; <
=>&&= ?
HeapByteBufferUtil&&@ R
.&&R S
GetIntLE&&S [
(&&[ \
this&&\ `
.&&` a
Memory&&a g
,&&g h
this&&i m
.&&m n
Idx&&n q
(&&q r
index&&r w
)&&w x
)&&x y
;&&y z
	protected(( 
internal(( 
override(( #
long(($ (
_GetLong(() 1
(((1 2
int((2 5
index((6 ;
)((; <
=>((= ?
HeapByteBufferUtil((@ R
.((R S
GetLong((S Z
(((Z [
this(([ _
.((_ `
Memory((` f
,((f g
this((h l
.((l m
Idx((m p
(((p q
index((q v
)((v w
)((w x
;((x y
	protected** 
internal** 
override** #
long**$ (

_GetLongLE**) 3
(**3 4
int**4 7
index**8 =
)**= >
=>**? A
HeapByteBufferUtil**B T
.**T U
	GetLongLE**U ^
(**^ _
this**_ c
.**c d
Memory**d j
,**j k
this**l p
.**p q
Idx**q t
(**t u
index**u z
)**z {
)**{ |
;**| }
public,, 
override,, 
IByteBuffer,, #
GetBytes,,$ ,
(,,, -
int,,- 0
index,,1 6
,,,6 7
IByteBuffer,,8 C
dst,,D G
,,,G H
int,,I L
dstIndex,,M U
,,,U V
int,,W Z
length,,[ a
),,a b
{-- 	
this.. 
... 
CheckDstIndex.. 
(.. 
index.. $
,..$ %
length..& ,
,.., -
dstIndex... 6
,..6 7
dst..8 ;
...; <
Capacity..< D
)..D E
;..E F
if// 
(// 
dst// 
.// 
HasArray// 
)// 
{00 
this11 
.11 
GetBytes11 
(11 
index11 #
,11# $
dst11% (
.11( )
Array11) .
,11. /
dst110 3
.113 4
ArrayOffset114 ?
+11@ A
dstIndex11B J
,11J K
length11L R
)11R S
;11S T
}22 
else33 
{44 
dst55 
.55 
SetBytes55 
(55 
dstIndex55 %
,55% &
this55' +
.55+ ,
Memory55, 2
,552 3
this554 8
.558 9
Idx559 <
(55< =
index55= B
)55B C
,55C D
length55E K
)55K L
;55L M
}66 
return77 
this77 
;77 
}88 	
public:: 
override:: 
IByteBuffer:: #
GetBytes::$ ,
(::, -
int::- 0
index::1 6
,::6 7
byte::8 <
[::< =
]::= >
dst::? B
,::B C
int::D G
dstIndex::H P
,::P Q
int::R U
length::V \
)::\ ]
{;; 	
this<< 
.<< 
CheckDstIndex<< 
(<< 
index<< $
,<<$ %
length<<& ,
,<<, -
dstIndex<<. 6
,<<6 7
dst<<8 ;
.<<; <
Length<<< B
)<<B C
;<<C D
PlatformDependent== 
.== 

CopyMemory== (
(==( )
this==) -
.==- .
Memory==. 4
,==4 5
this==6 :
.==: ;
Idx==; >
(==> ?
index==? D
)==D E
,==E F
dst==G J
,==J K
dstIndex==L T
,==T U
length==V \
)==\ ]
;==] ^
return>> 
this>> 
;>> 
}?? 	
publicAA 
overrideAA 
IByteBufferAA #
GetBytesAA$ ,
(AA, -
intAA- 0
indexAA1 6
,AA6 7
StreamAA8 >
destinationAA? J
,AAJ K
intAAL O
lengthAAP V
)AAV W
{BB 	
thisCC 
.CC 

CheckIndexCC 
(CC 
indexCC !
,CC! "
lengthCC# )
)CC) *
;CC* +
destinationDD 
.DD 
WriteDD 
(DD 
thisDD "
.DD" #
MemoryDD# )
,DD) *
thisDD+ /
.DD/ 0
IdxDD0 3
(DD3 4
indexDD4 9
)DD9 :
,DD: ;
lengthDD< B
)DDB C
;DDC D
returnEE 
thisEE 
;EE 
}FF 	
	protectedHH 
internalHH 
overrideHH #
voidHH$ (
_SetByteHH) 1
(HH1 2
intHH2 5
indexHH6 ;
,HH; <
intHH= @
valueHHA F
)HHF G
=>HHH J
HeapByteBufferUtilHHK ]
.HH] ^
SetByteHH^ e
(HHe f
thisHHf j
.HHj k
MemoryHHk q
,HHq r
thisHHs w
.HHw x
IdxHHx {
(HH{ |
index	HH| 
)
HH ‚
,
HH‚ ƒ
value
HH„ ‰
)
HH‰ Š
;
HHŠ ‹
	protectedJJ 
internalJJ 
overrideJJ #
voidJJ$ (
	_SetShortJJ) 2
(JJ2 3
intJJ3 6
indexJJ7 <
,JJ< =
intJJ> A
valueJJB G
)JJG H
=>JJI K
HeapByteBufferUtilJJL ^
.JJ^ _
SetShortJJ_ g
(JJg h
thisJJh l
.JJl m
MemoryJJm s
,JJs t
thisJJu y
.JJy z
IdxJJz }
(JJ} ~
index	JJ~ ƒ
)
JJƒ „
,
JJ„ …
value
JJ† ‹
)
JJ‹ Œ
;
JJŒ 
	protectedLL 
internalLL 
overrideLL #
voidLL$ (
_SetShortLELL) 4
(LL4 5
intLL5 8
indexLL9 >
,LL> ?
intLL@ C
valueLLD I
)LLI J
=>LLK M
HeapByteBufferUtilLLN `
.LL` a

SetShortLELLa k
(LLk l
thisLLl p
.LLp q
MemoryLLq w
,LLw x
thisLLy }
.LL} ~
Idx	LL~ 
(
LL ‚
index
LL‚ ‡
)
LL‡ ˆ
,
LLˆ ‰
value
LLŠ 
)
LL 
;
LL ‘
	protectedNN 
internalNN 
overrideNN #
voidNN$ (

_SetMediumNN) 3
(NN3 4
intNN4 7
indexNN8 =
,NN= >
intNN? B
valueNNC H
)NNH I
=>NNJ L
HeapByteBufferUtilNNM _
.NN_ `
	SetMediumNN` i
(NNi j
thisNNj n
.NNn o
MemoryNNo u
,NNu v
thisNNw {
.NN{ |
IdxNN| 
(	NN €
index
NN€ …
)
NN… †
,
NN† ‡
value
NNˆ 
)
NN 
;
NN 
	protectedPP 
internalPP 
overridePP #
voidPP$ (
_SetMediumLEPP) 5
(PP5 6
intPP6 9
indexPP: ?
,PP? @
intPPA D
valuePPE J
)PPJ K
=>PPL N
HeapByteBufferUtilPPO a
.PPa b
SetMediumLEPPb m
(PPm n
thisPPn r
.PPr s
MemoryPPs y
,PPy z
thisPP{ 
.	PP €
Idx
PP€ ƒ
(
PPƒ „
index
PP„ ‰
)
PP‰ Š
,
PPŠ ‹
value
PPŒ ‘
)
PP‘ ’
;
PP’ “
	protectedRR 
internalRR 
overrideRR #
voidRR$ (
_SetIntRR) 0
(RR0 1
intRR1 4
indexRR5 :
,RR: ;
intRR< ?
valueRR@ E
)RRE F
=>RRG I
HeapByteBufferUtilRRJ \
.RR\ ]
SetIntRR] c
(RRc d
thisRRd h
.RRh i
MemoryRRi o
,RRo p
thisRRq u
.RRu v
IdxRRv y
(RRy z
indexRRz 
)	RR €
,
RR€ 
value
RR‚ ‡
)
RR‡ ˆ
;
RRˆ ‰
	protectedTT 
internalTT 
overrideTT #
voidTT$ (
	_SetIntLETT) 2
(TT2 3
intTT3 6
indexTT7 <
,TT< =
intTT> A
valueTTB G
)TTG H
=>TTI K
HeapByteBufferUtilTTL ^
.TT^ _
SetIntLETT_ g
(TTg h
thisTTh l
.TTl m
MemoryTTm s
,TTs t
thisTTu y
.TTy z
IdxTTz }
(TT} ~
index	TT~ ƒ
)
TTƒ „
,
TT„ …
value
TT† ‹
)
TT‹ Œ
;
TTŒ 
	protectedVV 
internalVV 
overrideVV #
voidVV$ (
_SetLongVV) 1
(VV1 2
intVV2 5
indexVV6 ;
,VV; <
longVV= A
valueVVB G
)VVG H
=>VVI K
HeapByteBufferUtilVVL ^
.VV^ _
SetLongVV_ f
(VVf g
thisVVg k
.VVk l
MemoryVVl r
,VVr s
thisVVt x
.VVx y
IdxVVy |
(VV| }
index	VV} ‚
)
VV‚ ƒ
,
VVƒ „
value
VV… Š
)
VVŠ ‹
;
VV‹ Œ
	protectedXX 
internalXX 
overrideXX #
voidXX$ (

_SetLongLEXX) 3
(XX3 4
intXX4 7
indexXX8 =
,XX= >
longXX? C
valueXXD I
)XXI J
=>XXK M
HeapByteBufferUtilXXN `
.XX` a
	SetLongLEXXa j
(XXj k
thisXXk o
.XXo p
MemoryXXp v
,XXv w
thisXXx |
.XX| }
Idx	XX} €
(
XX€ 
index
XX †
)
XX† ‡
,
XX‡ ˆ
value
XX‰ 
)
XX 
;
XX 
publicZZ 
overrideZZ 
IByteBufferZZ #
SetBytesZZ$ ,
(ZZ, -
intZZ- 0
indexZZ1 6
,ZZ6 7
IByteBufferZZ8 C
srcZZD G
,ZZG H
intZZI L
srcIndexZZM U
,ZZU V
intZZW Z
lengthZZ[ a
)ZZa b
{[[ 	
this\\ 
.\\ 
CheckSrcIndex\\ 
(\\ 
index\\ $
,\\$ %
length\\& ,
,\\, -
srcIndex\\. 6
,\\6 7
src\\8 ;
.\\; <
Capacity\\< D
)\\D E
;\\E F
if]] 
(]] 
src]] 
.]] 
HasArray]] 
)]] 
{^^ 
this__ 
.__ 
SetBytes__ 
(__ 
index__ #
,__# $
src__% (
.__( )
Array__) .
,__. /
src__0 3
.__3 4
ArrayOffset__4 ?
+__@ A
srcIndex__B J
,__J K
length__L R
)__R S
;__S T
}`` 
elseaa 
{bb 
srccc 
.cc 
GetBytescc 
(cc 
srcIndexcc %
,cc% &
thiscc' +
.cc+ ,
Memorycc, 2
,cc2 3
thiscc4 8
.cc8 9
Idxcc9 <
(cc< =
indexcc= B
)ccB C
,ccC D
lengthccE K
)ccK L
;ccL M
}dd 
returnee 
thisee 
;ee 
}ff 	
publichh 
overridehh 
asynchh 
Taskhh "
<hh" #
inthh# &
>hh& '
SetBytesAsynchh( 5
(hh5 6
inthh6 9
indexhh: ?
,hh? @
StreamhhA G
srchhH K
,hhK L
inthhM P
lengthhhQ W
,hhW X
CancellationTokenhhY j
cancellationTokenhhk |
)hh| }
{ii 	
ifjj 
(jj 
lengthjj 
==jj 
$numjj 
)jj 
{kk 
returnll 
$numll 
;ll 
}mm 
intoo 
	readTotaloo 
=oo 
$numoo 
;oo 
intpp 
readpp 
;pp 
intqq 
offsetqq 
=qq 
thisqq 
.qq 
ArrayOffsetqq )
+qq* +
indexqq, 1
;qq1 2
dorr 
{ss 
readtt 
=tt 
awaittt 
srctt  
.tt  !
	ReadAsynctt! *
(tt* +
thistt+ /
.tt/ 0
Arraytt0 5
,tt5 6
offsettt7 =
+tt> ?
	readTotaltt@ I
,ttI J
lengthttK Q
-ttR S
	readTotalttT ]
,tt] ^
cancellationTokentt_ p
)ttp q
;ttq r
	readTotaluu 
+=uu 
readuu !
;uu! "
}vv 
whileww 
(ww 
readww 
>ww 
$numww 
&&ww 
	readTotalww (
<ww) *
lengthww+ 1
)ww1 2
;ww2 3
returnyy 
	readTotalyy 
;yy 
}zz 	
public|| 
override|| 
IByteBuffer|| #
SetBytes||$ ,
(||, -
int||- 0
index||1 6
,||6 7
byte||8 <
[||< =
]||= >
src||? B
,||B C
int||D G
srcIndex||H P
,||P Q
int||R U
length||V \
)||\ ]
{}} 	
this~~ 
.~~ 
CheckSrcIndex~~ 
(~~ 
index~~ $
,~~$ %
length~~& ,
,~~, -
srcIndex~~. 6
,~~6 7
src~~8 ;
.~~; <
Length~~< B
)~~B C
;~~C D
PlatformDependent 
. 

CopyMemory (
(( )
src) ,
,, -
srcIndex. 6
,6 7
this8 <
.< =
Memory= C
,C D
thisE I
.I J
IdxJ M
(M N
indexN S
)S T
,T U
lengthV \
)\ ]
;] ^
return
€€ 
this
€€ 
;
€€ 
}
 	
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #
Copy
ƒƒ$ (
(
ƒƒ( )
int
ƒƒ) ,
index
ƒƒ- 2
,
ƒƒ2 3
int
ƒƒ4 7
length
ƒƒ8 >
)
ƒƒ> ?
{
„„ 	
this
…… 
.
…… 

CheckIndex
…… 
(
…… 
index
…… !
,
……! "
length
……# )
)
……) *
;
……* +
IByteBuffer
†† 
copy
†† 
=
†† 
this
†† #
.
††# $
	Allocator
††$ -
.
††- .

HeapBuffer
††. 8
(
††8 9
length
††9 ?
,
††? @
this
††A E
.
††E F
MaxCapacity
††F Q
)
††Q R
;
††R S
copy
‡‡ 
.
‡‡ 

WriteBytes
‡‡ 
(
‡‡ 
this
‡‡  
.
‡‡  !
Memory
‡‡! '
,
‡‡' (
this
‡‡) -
.
‡‡- .
Idx
‡‡. 1
(
‡‡1 2
index
‡‡2 7
)
‡‡7 8
,
‡‡8 9
length
‡‡: @
)
‡‡@ A
;
‡‡A B
return
ˆˆ 
copy
ˆˆ 
;
ˆˆ 
}
‰‰ 	
public
ŒŒ 
override
ŒŒ 
IByteBuffer
ŒŒ #
SetZero
ŒŒ$ +
(
ŒŒ+ ,
int
ŒŒ, /
index
ŒŒ0 5
,
ŒŒ5 6
int
ŒŒ7 :
length
ŒŒ; A
)
ŒŒA B
{
 	
this
 
.
 

CheckIndex
 
(
 
index
 !
,
! "
length
# )
)
) *
;
* +
PlatformDependent
 
.
 
Clear
 #
(
# $
this
$ (
.
( )
Memory
) /
,
/ 0
this
1 5
.
5 6
Idx
6 9
(
9 :
index
: ?
)
? @
,
@ A
length
B H
)
H I
;
I J
return
 
this
 
;
 
}
‘‘ 	
public
““ 
override
““ 
int
““ 
IoBufferCount
““ )
=>
““* ,
$num
““- .
;
““. /
public
•• 
override
•• 
ArraySegment
•• $
<
••$ %
byte
••% )
>
••) *
GetIoBuffer
••+ 6
(
••6 7
int
••7 :
index
••; @
,
••@ A
int
••B E
length
••F L
)
••L M
{
–– 	
this
—— 
.
—— 

CheckIndex
—— 
(
—— 
index
—— !
,
——! "
length
——# )
)
——) *
;
——* +
index
˜˜ 
=
˜˜ 
index
˜˜ 
+
˜˜ 
this
˜˜  
.
˜˜  !
Offset
˜˜! '
;
˜˜' (
return
™™ 
new
™™ 
ArraySegment
™™ #
<
™™# $
byte
™™$ (
>
™™( )
(
™™) *
this
™™* .
.
™™. /
Memory
™™/ 5
,
™™5 6
index
™™7 <
,
™™< =
length
™™> D
)
™™D E
;
™™E F
}
šš 	
public
œœ 
override
œœ 
ArraySegment
œœ $
<
œœ$ %
byte
œœ% )
>
œœ) *
[
œœ* +
]
œœ+ ,
GetIoBuffers
œœ- 9
(
œœ9 :
int
œœ: =
index
œœ> C
,
œœC D
int
œœE H
length
œœI O
)
œœO P
=>
œœQ S
new
œœT W
[
œœW X
]
œœX Y
{
œœZ [
this
œœ\ `
.
œœ` a
GetIoBuffer
œœa l
(
œœl m
index
œœm r
,
œœr s
length
œœt z
)
œœz {
}
œœ| }
;
œœ} ~
public
 
override
 
bool
 
HasArray
 %
=>
& (
true
) -
;
- .
public
   
override
   
byte
   
[
   
]
   
Array
   $
{
¡¡ 	
get
¢¢ 
{
££ 
this
¤¤ 
.
¤¤ 
EnsureAccessible
¤¤ %
(
¤¤% &
)
¤¤& '
;
¤¤' (
return
¥¥ 
this
¥¥ 
.
¥¥ 
Memory
¥¥ "
;
¥¥" #
}
¦¦ 
}
§§ 	
public
©© 
override
©© 
int
©© 
ArrayOffset
©© '
=>
©©( *
this
©©+ /
.
©©/ 0
Offset
©©0 6
;
©©6 7
public
«« 
override
«« 
bool
«« 
HasMemoryAddress
«« -
=>
««. 0
true
««1 5
;
««5 6
public
­­ 
override
­­ 
ref
­­ 
byte
­­  &
GetPinnableMemoryAddress
­­! 9
(
­­9 :
)
­­: ;
{
®® 	
this
¯¯ 
.
¯¯ 
EnsureAccessible
¯¯ !
(
¯¯! "
)
¯¯" #
;
¯¯# $
return
°° 
ref
°° 
this
°° 
.
°° 
Memory
°° "
[
°°" #
this
°°# '
.
°°' (
Offset
°°( .
]
°°. /
;
°°/ 0
}
±± 	
public
³³ 
override
³³ 
IntPtr
³³ #
AddressOfPinnedMemory
³³ 4
(
³³4 5
)
³³5 6
=>
³³7 9
IntPtr
³³: @
.
³³@ A
Zero
³³A E
;
³³E F
}
´´ 
}µµ ÔÌ
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class "
PooledSlicedByteBuffer '
:( )+
AbstractPooledDerivedByteBuffer* I
{ 
static 
readonly 
ThreadLocalPool '
<' ("
PooledSlicedByteBuffer( >
>> ?
Recycler@ H
=I J
newK N
ThreadLocalPoolO ^
<^ _"
PooledSlicedByteBuffer_ u
>u v
(v w
handlew }
=>	~ €
new
 „$
PooledSlicedByteBuffer
… ›
(
› œ
handle
œ ¢
)
¢ £
)
£ ¤
;
¤ ¥
internal 
static "
PooledSlicedByteBuffer .
NewInstance/ :
(: ;
AbstractByteBuffer; M
	unwrappedN W
,W X
IByteBufferY d
wrappede l
,l m
intn q
indexr w
,w x
inty |
length	} ƒ
)
ƒ „
{ 	!
CheckSliceOutOfBounds !
(! "
index" '
,' (
length) /
,/ 0
	unwrapped1 :
): ;
;; <
return 
NewInstance0 
(  
	unwrapped  )
,) *
wrapped+ 2
,2 3
index4 9
,9 :
length; A
)A B
;B C
} 	
static "
PooledSlicedByteBuffer %
NewInstance0& 2
(2 3
AbstractByteBuffer3 E
	unwrappedF O
,O P
IByteBufferQ \
wrapped] d
,d e
intf i

adjustmentj t
,t u
intv y
length	z €
)
€ 
{ 	"
PooledSlicedByteBuffer "
slice# (
=) *
Recycler+ 3
.3 4
Take4 8
(8 9
)9 :
;: ;
slice 
. 
Init 
< "
PooledSlicedByteBuffer -
>- .
(. /
	unwrapped/ 8
,8 9
wrapped: A
,A B
$numC D
,D E
lengthF L
,L M
lengthN T
)T U
;U V
slice 
. 
DiscardMarks 
( 
)  
;  !
slice 
. 

adjustment 
= 

adjustment )
;) *
return   
slice   
;   
}!! 	
int## 

adjustment## 
;## "
PooledSlicedByteBuffer%% 
(%% 
ThreadLocalPool%% .
.%%. /
Handle%%/ 5
handle%%6 <
)%%< =
:&& 
base&& 
(&& 
handle&& 
)&& 
{'' 	
}(( 	
public** 
override** 
int** 
Capacity** $
=>**% '
this**( ,
.**, -
MaxCapacity**- 8
;**8 9
public,, 
override,, 
IByteBuffer,, #
AdjustCapacity,,$ 2
(,,2 3
int,,3 6
newCapacity,,7 B
),,B C
=>,,D F
throw,,G L
new,,M P!
NotSupportedException,,Q f
(,,f g
$str,,g v
),,v w
;,,w x
public.. 
override.. 
int.. 
ArrayOffset.. '
=>..( *
this..+ /
.../ 0
Idx..0 3
(..3 4
this..4 8
...8 9
Unwrap..9 ?
(..? @
)..@ A
...A B
ArrayOffset..B M
)..M N
;..N O
public00 
override00 
ref00 
byte00  $
GetPinnableMemoryAddress00! 9
(009 :
)00: ;
=>00< >
ref00? B
Unsafe00C I
.00I J
Add00J M
(00M N
ref00N Q
this00R V
.00V W
Unwrap00W ]
(00] ^
)00^ _
.00_ `$
GetPinnableMemoryAddress00` x
(00x y
)00y z
,00z {
this	00| €
.
00€ 

adjustment
00 ‹
)
00‹ Œ
;
00Œ 
public22 
override22 
IntPtr22 !
AddressOfPinnedMemory22 4
(224 5
)225 6
{33 	
IntPtr44 
ptr44 
=44 
this44 
.44 
Unwrap44 $
(44$ %
)44% &
.44& '!
AddressOfPinnedMemory44' <
(44< =
)44= >
;44> ?
if55 
(55 
ptr55 
==55 
IntPtr55 
.55 
Zero55 "
)55" #
{66 
return77 
ptr77 
;77 
}88 
return99 
ptr99 
+99 
this99 
.99 

adjustment99 (
;99( )
}:: 	
public<< 
override<< 
ArraySegment<< $
<<<$ %
byte<<% )
><<) *
GetIoBuffer<<+ 6
(<<6 7
int<<7 :
index<<; @
,<<@ A
int<<B E
length<<F L
)<<L M
{== 	
this>> 
.>> 
CheckIndex0>> 
(>> 
index>> "
,>>" #
length>>$ *
)>>* +
;>>+ ,
return?? 
this?? 
.?? 
Unwrap?? 
(?? 
)??  
.??  !
GetIoBuffer??! ,
(??, -
this??- 1
.??1 2
Idx??2 5
(??5 6
index??6 ;
)??; <
,??< =
length??> D
)??D E
;??E F
}@@ 	
publicBB 
overrideBB 
ArraySegmentBB $
<BB$ %
byteBB% )
>BB) *
[BB* +
]BB+ ,
GetIoBuffersBB- 9
(BB9 :
intBB: =
indexBB> C
,BBC D
intBBE H
lengthBBI O
)BBO P
{CC 	
thisDD 
.DD 
CheckIndex0DD 
(DD 
indexDD "
,DD" #
lengthDD$ *
)DD* +
;DD+ ,
returnEE 
thisEE 
.EE 
UnwrapEE 
(EE 
)EE  
.EE  !
GetIoBuffersEE! -
(EE- .
thisEE. 2
.EE2 3
IdxEE3 6
(EE6 7
indexEE7 <
)EE< =
,EE= >
lengthEE? E
)EEE F
;EEF G
}FF 	
publicHH 
overrideHH 
IByteBufferHH #
CopyHH$ (
(HH( )
intHH) ,
indexHH- 2
,HH2 3
intHH4 7
lengthHH8 >
)HH> ?
{II 	
thisJJ 
.JJ 
CheckIndex0JJ 
(JJ 
indexJJ "
,JJ" #
lengthJJ$ *
)JJ* +
;JJ+ ,
returnKK 
thisKK 
.KK 
UnwrapKK 
(KK 
)KK  
.KK  !
CopyKK! %
(KK% &
thisKK& *
.KK* +
IdxKK+ .
(KK. /
indexKK/ 4
)KK4 5
,KK5 6
lengthKK7 =
)KK= >
;KK> ?
}LL 	
publicNN 
overrideNN 
IByteBufferNN #
SliceNN$ )
(NN) *
intNN* -
indexNN. 3
,NN3 4
intNN5 8
lengthNN9 ?
)NN? @
{OO 	
thisPP 
.PP 
CheckIndex0PP 
(PP 
indexPP "
,PP" #
lengthPP$ *
)PP* +
;PP+ ,
returnQQ 
baseQQ 
.QQ 
SliceQQ 
(QQ 
thisQQ "
.QQ" #
IdxQQ# &
(QQ& '
indexQQ' ,
)QQ, -
,QQ- .
lengthQQ/ 5
)QQ5 6
;QQ6 7
}RR 	
publicTT 
overrideTT 
IByteBufferTT #
RetainedSliceTT$ 1
(TT1 2
intTT2 5
indexTT6 ;
,TT; <
intTT= @
lengthTTA G
)TTG H
{UU 	
thisVV 
.VV 
CheckIndex0VV 
(VV 
indexVV "
,VV" #
lengthVV$ *
)VV* +
;VV+ ,
returnWW 
NewInstance0WW 
(WW  
thisWW  $
.WW$ %

UnwrapCoreWW% /
(WW/ 0
)WW0 1
,WW1 2
thisWW3 7
,WW7 8
thisWW9 =
.WW= >
IdxWW> A
(WWA B
indexWWB G
)WWG H
,WWH I
lengthWWJ P
)WWP Q
;WWQ R
}XX 	
publicZZ 
overrideZZ 
IByteBufferZZ #
	DuplicateZZ$ -
(ZZ- .
)ZZ. /
=>ZZ0 2
thisZZ3 7
.ZZ7 8

Duplicate0ZZ8 B
(ZZB C
)ZZC D
.ZZD E
SetIndexZZE M
(ZZM N
thisZZN R
.ZZR S
IdxZZS V
(ZZV W
thisZZW [
.ZZ[ \
ReaderIndexZZ\ g
)ZZg h
,ZZh i
thisZZj n
.ZZn o
IdxZZo r
(ZZr s
thisZZs w
.ZZw x
WriterIndex	ZZx ƒ
)
ZZƒ „
)
ZZ„ …
;
ZZ… †
public\\ 
override\\ 
IByteBuffer\\ #
RetainedDuplicate\\$ 5
(\\5 6
)\\6 7
=>\\8 :&
PooledDuplicatedByteBuffer\\; U
.\\U V
NewInstance\\V a
(\\a b
this\\b f
.\\f g

UnwrapCore\\g q
(\\q r
)\\r s
,\\s t
this\\u y
,\\y z
this\\{ 
.	\\ €
Idx
\\€ ƒ
(
\\ƒ „
this
\\„ ˆ
.
\\ˆ ‰
ReaderIndex
\\‰ ”
)
\\” •
,
\\• –
this
\\— ›
.
\\› œ
Idx
\\œ Ÿ
(
\\Ÿ  
this
\\  ¤
.
\\¤ ¥
WriterIndex
\\¥ °
)
\\° ±
)
\\± ²
;
\\² ³
public^^ 
override^^ 
byte^^ 
GetByte^^ $
(^^$ %
int^^% (
index^^) .
)^^. /
{__ 	
this`` 
.`` 
CheckIndex0`` 
(`` 
index`` "
,``" #
$num``$ %
)``% &
;``& '
returnaa 
thisaa 
.aa 
Unwrapaa 
(aa 
)aa  
.aa  !
GetByteaa! (
(aa( )
thisaa) -
.aa- .
Idxaa. 1
(aa1 2
indexaa2 7
)aa7 8
)aa8 9
;aa9 :
}bb 	
	protecteddd 
internaldd 
overridedd #
bytedd$ (
_GetBytedd) 1
(dd1 2
intdd2 5
indexdd6 ;
)dd; <
=>dd= ?
thisdd@ D
.ddD E

UnwrapCoreddE O
(ddO P
)ddP Q
.ddQ R
_GetByteddR Z
(ddZ [
thisdd[ _
.dd_ `
Idxdd` c
(ddc d
indexddd i
)ddi j
)ddj k
;ddk l
publicff 
overrideff 
shortff 
GetShortff &
(ff& '
intff' *
indexff+ 0
)ff0 1
{gg 	
thishh 
.hh 
CheckIndex0hh 
(hh 
indexhh "
,hh" #
$numhh$ %
)hh% &
;hh& '
returnii 
thisii 
.ii 
Unwrapii 
(ii 
)ii  
.ii  !
GetShortii! )
(ii) *
thisii* .
.ii. /
Idxii/ 2
(ii2 3
indexii3 8
)ii8 9
)ii9 :
;ii: ;
}jj 	
	protectedll 
internalll 
overridell #
shortll$ )
	_GetShortll* 3
(ll3 4
intll4 7
indexll8 =
)ll= >
=>ll? A
thisllB F
.llF G

UnwrapCorellG Q
(llQ R
)llR S
.llS T
	_GetShortllT ]
(ll] ^
thisll^ b
.llb c
Idxllc f
(llf g
indexllg l
)lll m
)llm n
;lln o
publicnn 
overridenn 
shortnn 

GetShortLEnn (
(nn( )
intnn) ,
indexnn- 2
)nn2 3
{oo 	
thispp 
.pp 
CheckIndex0pp 
(pp 
indexpp "
,pp" #
$numpp$ %
)pp% &
;pp& '
returnqq 
thisqq 
.qq 
Unwrapqq 
(qq 
)qq  
.qq  !

GetShortLEqq! +
(qq+ ,
thisqq, 0
.qq0 1
Idxqq1 4
(qq4 5
indexqq5 :
)qq: ;
)qq; <
;qq< =
}rr 	
	protectedtt 
internaltt 
overridett #
shorttt$ )
_GetShortLEtt* 5
(tt5 6
inttt6 9
indextt: ?
)tt? @
=>ttA C
thisttD H
.ttH I

UnwrapCorettI S
(ttS T
)ttT U
.ttU V
_GetShortLEttV a
(tta b
thisttb f
.ttf g
Idxttg j
(ttj k
indexttk p
)ttp q
)ttq r
;ttr s
publicvv 
overridevv 
intvv 
GetUnsignedMediumvv -
(vv- .
intvv. 1
indexvv2 7
)vv7 8
{ww 	
thisxx 
.xx 
CheckIndex0xx 
(xx 
indexxx "
,xx" #
$numxx$ %
)xx% &
;xx& '
returnyy 
thisyy 
.yy 
Unwrapyy 
(yy 
)yy  
.yy  !
GetUnsignedMediumyy! 2
(yy2 3
thisyy3 7
.yy7 8
Idxyy8 ;
(yy; <
indexyy< A
)yyA B
)yyB C
;yyC D
}zz 	
	protected|| 
internal|| 
override|| #
int||$ '
_GetUnsignedMedium||( :
(||: ;
int||; >
index||? D
)||D E
=>||F H
this||I M
.||M N

UnwrapCore||N X
(||X Y
)||Y Z
.||Z [
_GetUnsignedMedium||[ m
(||m n
this||n r
.||r s
Idx||s v
(||v w
index||w |
)||| }
)||} ~
;||~ 
public~~ 
override~~ 
int~~ 
GetUnsignedMediumLE~~ /
(~~/ 0
int~~0 3
index~~4 9
)~~9 :
{ 	
this
€€ 
.
€€ 
CheckIndex0
€€ 
(
€€ 
index
€€ "
,
€€" #
$num
€€$ %
)
€€% &
;
€€& '
return
 
this
 
.
 
Unwrap
 
(
 
)
  
.
  !!
GetUnsignedMediumLE
! 4
(
4 5
this
5 9
.
9 :
Idx
: =
(
= >
index
> C
)
C D
)
D E
;
E F
}
‚‚ 	
	protected
„„ 
internal
„„ 
override
„„ #
int
„„$ '"
_GetUnsignedMediumLE
„„( <
(
„„< =
int
„„= @
index
„„A F
)
„„F G
=>
„„H J
this
„„K O
.
„„O P

UnwrapCore
„„P Z
(
„„Z [
)
„„[ \
.
„„\ ]"
_GetUnsignedMediumLE
„„] q
(
„„q r
this
„„r v
.
„„v w
Idx
„„w z
(
„„z {
index„„{ €
)„„€ 
)„„ ‚
;„„‚ ƒ
public
†† 
override
†† 
int
†† 
GetInt
†† "
(
††" #
int
††# &
index
††' ,
)
††, -
{
‡‡ 	
this
ˆˆ 
.
ˆˆ 
CheckIndex0
ˆˆ 
(
ˆˆ 
index
ˆˆ "
,
ˆˆ" #
$num
ˆˆ$ %
)
ˆˆ% &
;
ˆˆ& '
return
‰‰ 
this
‰‰ 
.
‰‰ 
Unwrap
‰‰ 
(
‰‰ 
)
‰‰  
.
‰‰  !
GetInt
‰‰! '
(
‰‰' (
this
‰‰( ,
.
‰‰, -
Idx
‰‰- 0
(
‰‰0 1
index
‰‰1 6
)
‰‰6 7
)
‰‰7 8
;
‰‰8 9
}
ŠŠ 	
	protected
ŒŒ 
internal
ŒŒ 
override
ŒŒ #
int
ŒŒ$ '
_GetInt
ŒŒ( /
(
ŒŒ/ 0
int
ŒŒ0 3
index
ŒŒ4 9
)
ŒŒ9 :
=>
ŒŒ; =
this
ŒŒ> B
.
ŒŒB C

UnwrapCore
ŒŒC M
(
ŒŒM N
)
ŒŒN O
.
ŒŒO P
_GetInt
ŒŒP W
(
ŒŒW X
this
ŒŒX \
.
ŒŒ\ ]
Idx
ŒŒ] `
(
ŒŒ` a
index
ŒŒa f
)
ŒŒf g
)
ŒŒg h
;
ŒŒh i
public
 
override
 
int
 
GetIntLE
 $
(
$ %
int
% (
index
) .
)
. /
{
 	
this
 
.
 
CheckIndex0
 
(
 
index
 "
,
" #
$num
$ %
)
% &
;
& '
return
‘‘ 
this
‘‘ 
.
‘‘ 
Unwrap
‘‘ 
(
‘‘ 
)
‘‘  
.
‘‘  !
GetIntLE
‘‘! )
(
‘‘) *
this
‘‘* .
.
‘‘. /
Idx
‘‘/ 2
(
‘‘2 3
index
‘‘3 8
)
‘‘8 9
)
‘‘9 :
;
‘‘: ;
}
’’ 	
	protected
”” 
internal
”” 
override
”” #
int
””$ '
	_GetIntLE
””( 1
(
””1 2
int
””2 5
index
””6 ;
)
””; <
=>
””= ?
this
””@ D
.
””D E

UnwrapCore
””E O
(
””O P
)
””P Q
.
””Q R
	_GetIntLE
””R [
(
””[ \
this
””\ `
.
””` a
Idx
””a d
(
””d e
index
””e j
)
””j k
)
””k l
;
””l m
public
–– 
override
–– 
long
–– 
GetLong
–– $
(
––$ %
int
––% (
index
––) .
)
––. /
{
—— 	
this
˜˜ 
.
˜˜ 
CheckIndex0
˜˜ 
(
˜˜ 
index
˜˜ "
,
˜˜" #
$num
˜˜$ %
)
˜˜% &
;
˜˜& '
return
™™ 
this
™™ 
.
™™ 
Unwrap
™™ 
(
™™ 
)
™™  
.
™™  !
GetLong
™™! (
(
™™( )
this
™™) -
.
™™- .
Idx
™™. 1
(
™™1 2
index
™™2 7
)
™™7 8
)
™™8 9
;
™™9 :
}
šš 	
	protected
œœ 
internal
œœ 
override
œœ #
long
œœ$ (
_GetLong
œœ) 1
(
œœ1 2
int
œœ2 5
index
œœ6 ;
)
œœ; <
=>
œœ= ?
this
œœ@ D
.
œœD E

UnwrapCore
œœE O
(
œœO P
)
œœP Q
.
œœQ R
_GetLong
œœR Z
(
œœZ [
this
œœ[ _
.
œœ_ `
Idx
œœ` c
(
œœc d
index
œœd i
)
œœi j
)
œœj k
;
œœk l
public
 
override
 
long
 
	GetLongLE
 &
(
& '
int
' *
index
+ 0
)
0 1
{
ŸŸ 	
this
   
.
   
CheckIndex0
   
(
   
index
   "
,
  " #
$num
  $ %
)
  % &
;
  & '
return
¡¡ 
this
¡¡ 
.
¡¡ 
Unwrap
¡¡ 
(
¡¡ 
)
¡¡  
.
¡¡  !
	GetLongLE
¡¡! *
(
¡¡* +
this
¡¡+ /
.
¡¡/ 0
Idx
¡¡0 3
(
¡¡3 4
index
¡¡4 9
)
¡¡9 :
)
¡¡: ;
;
¡¡; <
}
¢¢ 	
	protected
¤¤ 
internal
¤¤ 
override
¤¤ #
long
¤¤$ (

_GetLongLE
¤¤) 3
(
¤¤3 4
int
¤¤4 7
index
¤¤8 =
)
¤¤= >
=>
¤¤? A
this
¤¤B F
.
¤¤F G

UnwrapCore
¤¤G Q
(
¤¤Q R
)
¤¤R S
.
¤¤S T

_GetLongLE
¤¤T ^
(
¤¤^ _
this
¤¤_ c
.
¤¤c d
Idx
¤¤d g
(
¤¤g h
index
¤¤h m
)
¤¤m n
)
¤¤n o
;
¤¤o p
public
¦¦ 
override
¦¦ 
IByteBuffer
¦¦ #
GetBytes
¦¦$ ,
(
¦¦, -
int
¦¦- 0
index
¦¦1 6
,
¦¦6 7
IByteBuffer
¦¦8 C
dst
¦¦D G
,
¦¦G H
int
¦¦I L
dstIndex
¦¦M U
,
¦¦U V
int
¦¦W Z
length
¦¦[ a
)
¦¦a b
{
§§ 	
this
¨¨ 
.
¨¨ 
CheckIndex0
¨¨ 
(
¨¨ 
index
¨¨ "
,
¨¨" #
length
¨¨$ *
)
¨¨* +
;
¨¨+ ,
this
©© 
.
©© 
Unwrap
©© 
(
©© 
)
©© 
.
©© 
GetBytes
©© "
(
©©" #
this
©©# '
.
©©' (
Idx
©©( +
(
©©+ ,
index
©©, 1
)
©©1 2
,
©©2 3
dst
©©4 7
,
©©7 8
dstIndex
©©9 A
,
©©A B
length
©©C I
)
©©I J
;
©©J K
return
ªª 
this
ªª 
;
ªª 
}
«« 	
public
­­ 
override
­­ 
IByteBuffer
­­ #
GetBytes
­­$ ,
(
­­, -
int
­­- 0
index
­­1 6
,
­­6 7
byte
­­8 <
[
­­< =
]
­­= >
dst
­­? B
,
­­B C
int
­­D G
dstIndex
­­H P
,
­­P Q
int
­­R U
length
­­V \
)
­­\ ]
{
®® 	
this
¯¯ 
.
¯¯ 
CheckIndex0
¯¯ 
(
¯¯ 
index
¯¯ "
,
¯¯" #
length
¯¯$ *
)
¯¯* +
;
¯¯+ ,
this
°° 
.
°° 
Unwrap
°° 
(
°° 
)
°° 
.
°° 
GetBytes
°° "
(
°°" #
this
°°# '
.
°°' (
Idx
°°( +
(
°°+ ,
index
°°, 1
)
°°1 2
,
°°2 3
dst
°°4 7
,
°°7 8
dstIndex
°°9 A
,
°°A B
length
°°C I
)
°°I J
;
°°J K
return
±± 
this
±± 
;
±± 
}
²² 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
SetByte
´´$ +
(
´´+ ,
int
´´, /
index
´´0 5
,
´´5 6
int
´´7 :
value
´´; @
)
´´@ A
{
µµ 	
this
¶¶ 
.
¶¶ 
CheckIndex0
¶¶ 
(
¶¶ 
index
¶¶ "
,
¶¶" #
$num
¶¶$ %
)
¶¶% &
;
¶¶& '
this
·· 
.
·· 
Unwrap
·· 
(
·· 
)
·· 
.
·· 
SetByte
·· !
(
··! "
this
··" &
.
··& '
Idx
··' *
(
··* +
index
··+ 0
)
··0 1
,
··1 2
value
··3 8
)
··8 9
;
··9 :
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
	protected
»» 
internal
»» 
override
»» #
void
»»$ (
_SetByte
»») 1
(
»»1 2
int
»»2 5
index
»»6 ;
,
»»; <
int
»»= @
value
»»A F
)
»»F G
=>
»»H J
this
»»K O
.
»»O P

UnwrapCore
»»P Z
(
»»Z [
)
»»[ \
.
»»\ ]
_SetByte
»»] e
(
»»e f
this
»»f j
.
»»j k
Idx
»»k n
(
»»n o
index
»»o t
)
»»t u
,
»»u v
value
»»w |
)
»»| }
;
»»} ~
public
½½ 
override
½½ 
IByteBuffer
½½ #
SetShort
½½$ ,
(
½½, -
int
½½- 0
index
½½1 6
,
½½6 7
int
½½8 ;
value
½½< A
)
½½A B
{
¾¾ 	
this
¿¿ 
.
¿¿ 
CheckIndex0
¿¿ 
(
¿¿ 
index
¿¿ "
,
¿¿" #
$num
¿¿$ %
)
¿¿% &
;
¿¿& '
this
ÀÀ 
.
ÀÀ 
Unwrap
ÀÀ 
(
ÀÀ 
)
ÀÀ 
.
ÀÀ 
SetShort
ÀÀ "
(
ÀÀ" #
this
ÀÀ# '
.
ÀÀ' (
Idx
ÀÀ( +
(
ÀÀ+ ,
index
ÀÀ, 1
)
ÀÀ1 2
,
ÀÀ2 3
value
ÀÀ4 9
)
ÀÀ9 :
;
ÀÀ: ;
return
ÁÁ 
this
ÁÁ 
;
ÁÁ 
}
ÂÂ 	
	protected
ÄÄ 
internal
ÄÄ 
override
ÄÄ #
void
ÄÄ$ (
	_SetShort
ÄÄ) 2
(
ÄÄ2 3
int
ÄÄ3 6
index
ÄÄ7 <
,
ÄÄ< =
int
ÄÄ> A
value
ÄÄB G
)
ÄÄG H
=>
ÄÄI K
this
ÄÄL P
.
ÄÄP Q

UnwrapCore
ÄÄQ [
(
ÄÄ[ \
)
ÄÄ\ ]
.
ÄÄ] ^
	_SetShort
ÄÄ^ g
(
ÄÄg h
this
ÄÄh l
.
ÄÄl m
Idx
ÄÄm p
(
ÄÄp q
index
ÄÄq v
)
ÄÄv w
,
ÄÄw x
value
ÄÄy ~
)
ÄÄ~ 
;ÄÄ €
public
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ #

SetShortLE
ÆÆ$ .
(
ÆÆ. /
int
ÆÆ/ 2
index
ÆÆ3 8
,
ÆÆ8 9
int
ÆÆ: =
value
ÆÆ> C
)
ÆÆC D
{
ÇÇ 	
this
ÈÈ 
.
ÈÈ 
CheckIndex0
ÈÈ 
(
ÈÈ 
index
ÈÈ "
,
ÈÈ" #
$num
ÈÈ$ %
)
ÈÈ% &
;
ÈÈ& '
this
ÉÉ 
.
ÉÉ 
Unwrap
ÉÉ 
(
ÉÉ 
)
ÉÉ 
.
ÉÉ 

SetShortLE
ÉÉ $
(
ÉÉ$ %
this
ÉÉ% )
.
ÉÉ) *
Idx
ÉÉ* -
(
ÉÉ- .
index
ÉÉ. 3
)
ÉÉ3 4
,
ÉÉ4 5
value
ÉÉ6 ;
)
ÉÉ; <
;
ÉÉ< =
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ËË 	
	protected
ÍÍ 
internal
ÍÍ 
override
ÍÍ #
void
ÍÍ$ (
_SetShortLE
ÍÍ) 4
(
ÍÍ4 5
int
ÍÍ5 8
index
ÍÍ9 >
,
ÍÍ> ?
int
ÍÍ@ C
value
ÍÍD I
)
ÍÍI J
=>
ÍÍK M
this
ÍÍN R
.
ÍÍR S

UnwrapCore
ÍÍS ]
(
ÍÍ] ^
)
ÍÍ^ _
.
ÍÍ_ `
_SetShortLE
ÍÍ` k
(
ÍÍk l
this
ÍÍl p
.
ÍÍp q
Idx
ÍÍq t
(
ÍÍt u
index
ÍÍu z
)
ÍÍz {
,
ÍÍ{ |
valueÍÍ} ‚
)ÍÍ‚ ƒ
;ÍÍƒ „
public
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ #
	SetMedium
ÏÏ$ -
(
ÏÏ- .
int
ÏÏ. 1
index
ÏÏ2 7
,
ÏÏ7 8
int
ÏÏ9 <
value
ÏÏ= B
)
ÏÏB C
{
ĞĞ 	
this
ÑÑ 
.
ÑÑ 
CheckIndex0
ÑÑ 
(
ÑÑ 
index
ÑÑ "
,
ÑÑ" #
$num
ÑÑ$ %
)
ÑÑ% &
;
ÑÑ& '
this
ÒÒ 
.
ÒÒ 
Unwrap
ÒÒ 
(
ÒÒ 
)
ÒÒ 
.
ÒÒ 
	SetMedium
ÒÒ #
(
ÒÒ# $
this
ÒÒ$ (
.
ÒÒ( )
Idx
ÒÒ) ,
(
ÒÒ, -
index
ÒÒ- 2
)
ÒÒ2 3
,
ÒÒ3 4
value
ÒÒ5 :
)
ÒÒ: ;
;
ÒÒ; <
return
ÓÓ 
this
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
	protected
ÖÖ 
internal
ÖÖ 
override
ÖÖ #
void
ÖÖ$ (

_SetMedium
ÖÖ) 3
(
ÖÖ3 4
int
ÖÖ4 7
index
ÖÖ8 =
,
ÖÖ= >
int
ÖÖ? B
value
ÖÖC H
)
ÖÖH I
=>
ÖÖJ L
this
ÖÖM Q
.
ÖÖQ R

UnwrapCore
ÖÖR \
(
ÖÖ\ ]
)
ÖÖ] ^
.
ÖÖ^ _

_SetMedium
ÖÖ_ i
(
ÖÖi j
this
ÖÖj n
.
ÖÖn o
Idx
ÖÖo r
(
ÖÖr s
index
ÖÖs x
)
ÖÖx y
,
ÖÖy z
valueÖÖ{ €
)ÖÖ€ 
;ÖÖ ‚
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
SetMediumLE
ØØ$ /
(
ØØ/ 0
int
ØØ0 3
index
ØØ4 9
,
ØØ9 :
int
ØØ; >
value
ØØ? D
)
ØØD E
{
ÙÙ 	
this
ÚÚ 
.
ÚÚ 
CheckIndex0
ÚÚ 
(
ÚÚ 
index
ÚÚ "
,
ÚÚ" #
$num
ÚÚ$ %
)
ÚÚ% &
;
ÚÚ& '
this
ÛÛ 
.
ÛÛ 
Unwrap
ÛÛ 
(
ÛÛ 
)
ÛÛ 
.
ÛÛ 
SetMediumLE
ÛÛ %
(
ÛÛ% &
this
ÛÛ& *
.
ÛÛ* +
Idx
ÛÛ+ .
(
ÛÛ. /
index
ÛÛ/ 4
)
ÛÛ4 5
,
ÛÛ5 6
value
ÛÛ7 <
)
ÛÛ< =
;
ÛÛ= >
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
İİ 	
	protected
ßß 
internal
ßß 
override
ßß #
void
ßß$ (
_SetMediumLE
ßß) 5
(
ßß5 6
int
ßß6 9
index
ßß: ?
,
ßß? @
int
ßßA D
value
ßßE J
)
ßßJ K
=>
ßßL N
this
ßßO S
.
ßßS T

UnwrapCore
ßßT ^
(
ßß^ _
)
ßß_ `
.
ßß` a
_SetMediumLE
ßßa m
(
ßßm n
this
ßßn r
.
ßßr s
Idx
ßßs v
(
ßßv w
index
ßßw |
)
ßß| }
,
ßß} ~
valueßß „
)ßß„ …
;ßß… †
public
áá 
override
áá 
IByteBuffer
áá #
SetInt
áá$ *
(
áá* +
int
áá+ .
index
áá/ 4
,
áá4 5
int
áá6 9
value
áá: ?
)
áá? @
{
ââ 	
this
ãã 
.
ãã 
CheckIndex0
ãã 
(
ãã 
index
ãã "
,
ãã" #
$num
ãã$ %
)
ãã% &
;
ãã& '
this
ää 
.
ää 
Unwrap
ää 
(
ää 
)
ää 
.
ää 
SetInt
ää  
(
ää  !
this
ää! %
.
ää% &
Idx
ää& )
(
ää) *
index
ää* /
)
ää/ 0
,
ää0 1
value
ää2 7
)
ää7 8
;
ää8 9
return
åå 
this
åå 
;
åå 
}
ææ 	
	protected
èè 
internal
èè 
override
èè #
void
èè$ (
_SetInt
èè) 0
(
èè0 1
int
èè1 4
index
èè5 :
,
èè: ;
int
èè< ?
value
èè@ E
)
èèE F
=>
èèG I
this
èèJ N
.
èèN O

UnwrapCore
èèO Y
(
èèY Z
)
èèZ [
.
èè[ \
_SetInt
èè\ c
(
èèc d
this
èèd h
.
èèh i
Idx
èèi l
(
èèl m
index
èèm r
)
èèr s
,
èès t
value
èèu z
)
èèz {
;
èè{ |
public
êê 
override
êê 
IByteBuffer
êê #
SetIntLE
êê$ ,
(
êê, -
int
êê- 0
index
êê1 6
,
êê6 7
int
êê8 ;
value
êê< A
)
êêA B
{
ëë 	
this
ìì 
.
ìì 
CheckIndex0
ìì 
(
ìì 
index
ìì "
,
ìì" #
$num
ìì$ %
)
ìì% &
;
ìì& '
this
íí 
.
íí 
Unwrap
íí 
(
íí 
)
íí 
.
íí 
SetIntLE
íí "
(
íí" #
this
íí# '
.
íí' (
Idx
íí( +
(
íí+ ,
index
íí, 1
)
íí1 2
,
íí2 3
value
íí4 9
)
íí9 :
;
íí: ;
return
îî 
this
îî 
;
îî 
}
ïï 	
	protected
ññ 
internal
ññ 
override
ññ #
void
ññ$ (
	_SetIntLE
ññ) 2
(
ññ2 3
int
ññ3 6
index
ññ7 <
,
ññ< =
int
ññ> A
value
ññB G
)
ññG H
=>
ññI K
this
ññL P
.
ññP Q

UnwrapCore
ññQ [
(
ññ[ \
)
ññ\ ]
.
ññ] ^
	_SetIntLE
ññ^ g
(
ññg h
this
ññh l
.
ññl m
Idx
ññm p
(
ññp q
index
ññq v
)
ññv w
,
ññw x
value
ññy ~
)
ññ~ 
;ññ €
public
óó 
override
óó 
IByteBuffer
óó #
SetLong
óó$ +
(
óó+ ,
int
óó, /
index
óó0 5
,
óó5 6
long
óó7 ;
value
óó< A
)
óóA B
{
ôô 	
this
õõ 
.
õõ 
CheckIndex0
õõ 
(
õõ 
index
õõ "
,
õõ" #
$num
õõ$ %
)
õõ% &
;
õõ& '
this
öö 
.
öö 
Unwrap
öö 
(
öö 
)
öö 
.
öö 
SetLong
öö !
(
öö! "
this
öö" &
.
öö& '
Idx
öö' *
(
öö* +
index
öö+ 0
)
öö0 1
,
öö1 2
value
öö3 8
)
öö8 9
;
öö9 :
return
÷÷ 
this
÷÷ 
;
÷÷ 
}
øø 	
	protected
úú 
internal
úú 
override
úú #
void
úú$ (
_SetLong
úú) 1
(
úú1 2
int
úú2 5
index
úú6 ;
,
úú; <
long
úú= A
value
úúB G
)
úúG H
=>
úúI K
this
úúL P
.
úúP Q

UnwrapCore
úúQ [
(
úú[ \
)
úú\ ]
.
úú] ^
_SetLong
úú^ f
(
úúf g
this
úúg k
.
úúk l
Idx
úúl o
(
úúo p
index
úúp u
)
úúu v
,
úúv w
value
úúx }
)
úú} ~
;
úú~ 
public
üü 
override
üü 
IByteBuffer
üü #
	SetLongLE
üü$ -
(
üü- .
int
üü. 1
index
üü2 7
,
üü7 8
long
üü9 =
value
üü> C
)
üüC D
{
ıı 	
this
şş 
.
şş 
CheckIndex0
şş 
(
şş 
index
şş "
,
şş" #
$num
şş$ %
)
şş% &
;
şş& '
this
ÿÿ 
.
ÿÿ 
Unwrap
ÿÿ 
(
ÿÿ 
)
ÿÿ 
.
ÿÿ 
	SetLongLE
ÿÿ #
(
ÿÿ# $
this
ÿÿ$ (
.
ÿÿ( )
Idx
ÿÿ) ,
(
ÿÿ, -
index
ÿÿ- 2
)
ÿÿ2 3
,
ÿÿ3 4
value
ÿÿ5 :
)
ÿÿ: ;
;
ÿÿ; <
return
€€ 
this
€€ 
;
€€ 
}
 	
	protected
ƒƒ 
internal
ƒƒ 
override
ƒƒ #
void
ƒƒ$ (

_SetLongLE
ƒƒ) 3
(
ƒƒ3 4
int
ƒƒ4 7
index
ƒƒ8 =
,
ƒƒ= >
long
ƒƒ? C
value
ƒƒD I
)
ƒƒI J
=>
ƒƒK M
this
ƒƒN R
.
ƒƒR S

UnwrapCore
ƒƒS ]
(
ƒƒ] ^
)
ƒƒ^ _
.
ƒƒ_ `

_SetLongLE
ƒƒ` j
(
ƒƒj k
this
ƒƒk o
.
ƒƒo p
Idx
ƒƒp s
(
ƒƒs t
index
ƒƒt y
)
ƒƒy z
,
ƒƒz {
valueƒƒ| 
)ƒƒ ‚
;ƒƒ‚ ƒ
public
…… 
override
…… 
IByteBuffer
…… #
SetBytes
……$ ,
(
……, -
int
……- 0
index
……1 6
,
……6 7
byte
……8 <
[
……< =
]
……= >
src
……? B
,
……B C
int
……D G
srcIndex
……H P
,
……P Q
int
……R U
length
……V \
)
……\ ]
{
†† 	
this
‡‡ 
.
‡‡ 
CheckIndex0
‡‡ 
(
‡‡ 
index
‡‡ "
,
‡‡" #
length
‡‡$ *
)
‡‡* +
;
‡‡+ ,
this
ˆˆ 
.
ˆˆ 
Unwrap
ˆˆ 
(
ˆˆ 
)
ˆˆ 
.
ˆˆ 
SetBytes
ˆˆ "
(
ˆˆ" #
this
ˆˆ# '
.
ˆˆ' (
Idx
ˆˆ( +
(
ˆˆ+ ,
index
ˆˆ, 1
)
ˆˆ1 2
,
ˆˆ2 3
src
ˆˆ4 7
,
ˆˆ7 8
srcIndex
ˆˆ9 A
,
ˆˆA B
length
ˆˆC I
)
ˆˆI J
;
ˆˆJ K
return
‰‰ 
this
‰‰ 
;
‰‰ 
}
ŠŠ 	
public
ŒŒ 
override
ŒŒ 
IByteBuffer
ŒŒ #
SetBytes
ŒŒ$ ,
(
ŒŒ, -
int
ŒŒ- 0
index
ŒŒ1 6
,
ŒŒ6 7
IByteBuffer
ŒŒ8 C
src
ŒŒD G
,
ŒŒG H
int
ŒŒI L
srcIndex
ŒŒM U
,
ŒŒU V
int
ŒŒW Z
length
ŒŒ[ a
)
ŒŒa b
{
 	
this
 
.
 
CheckIndex0
 
(
 
index
 "
,
" #
length
$ *
)
* +
;
+ ,
this
 
.
 
Unwrap
 
(
 
)
 
.
 
SetBytes
 "
(
" #
this
# '
.
' (
Idx
( +
(
+ ,
index
, 1
)
1 2
,
2 3
src
4 7
,
7 8
srcIndex
9 A
,
A B
length
C I
)
I J
;
J K
return
 
this
 
;
 
}
‘‘ 	
public
““ 
override
““ 
IByteBuffer
““ #
GetBytes
““$ ,
(
““, -
int
““- 0
index
““1 6
,
““6 7
Stream
““8 >
destination
““? J
,
““J K
int
““L O
length
““P V
)
““V W
{
”” 	
this
•• 
.
•• 
CheckIndex0
•• 
(
•• 
index
•• "
,
••" #
length
••$ *
)
••* +
;
••+ ,
return
–– 
this
–– 
.
–– 
Unwrap
–– 
(
–– 
)
––  
.
––  !
GetBytes
––! )
(
––) *
this
––* .
.
––. /
Idx
––/ 2
(
––2 3
index
––3 8
)
––8 9
,
––9 :
destination
––; F
,
––F G
length
––H N
)
––N O
;
––O P
}
—— 	
public
™™ 
override
™™ 
Task
™™ 
<
™™ 
int
™™  
>
™™  !
SetBytesAsync
™™" /
(
™™/ 0
int
™™0 3
index
™™4 9
,
™™9 :
Stream
™™; A
src
™™B E
,
™™E F
int
™™G J
length
™™K Q
,
™™Q R
CancellationToken
™™S d
cancellationToken
™™e v
)
™™v w
{
šš 	
this
›› 
.
›› 
CheckIndex0
›› 
(
›› 
index
›› "
,
››" #
length
››$ *
)
››* +
;
››+ ,
return
œœ 
this
œœ 
.
œœ 
Unwrap
œœ 
(
œœ 
)
œœ  
.
œœ  !
SetBytesAsync
œœ! .
(
œœ. /
this
œœ/ 3
.
œœ3 4
Idx
œœ4 7
(
œœ7 8
index
œœ8 =
)
œœ= >
,
œœ> ?
src
œœ@ C
,
œœC D
length
œœE K
,
œœK L
cancellationToken
œœM ^
)
œœ^ _
;
œœ_ `
}
 	
public
ŸŸ 
override
ŸŸ 
int
ŸŸ 
ForEachByte
ŸŸ '
(
ŸŸ' (
int
ŸŸ( +
index
ŸŸ, 1
,
ŸŸ1 2
int
ŸŸ3 6
length
ŸŸ7 =
,
ŸŸ= >
IByteProcessor
ŸŸ? M
	processor
ŸŸN W
)
ŸŸW X
{
   	
this
¡¡ 
.
¡¡ 
CheckIndex0
¡¡ 
(
¡¡ 
index
¡¡ "
,
¡¡" #
length
¡¡$ *
)
¡¡* +
;
¡¡+ ,
int
¢¢ 
ret
¢¢ 
=
¢¢ 
this
¢¢ 
.
¢¢ 
Unwrap
¢¢ !
(
¢¢! "
)
¢¢" #
.
¢¢# $
ForEachByte
¢¢$ /
(
¢¢/ 0
this
¢¢0 4
.
¢¢4 5
Idx
¢¢5 8
(
¢¢8 9
index
¢¢9 >
)
¢¢> ?
,
¢¢? @
length
¢¢A G
,
¢¢G H
	processor
¢¢I R
)
¢¢R S
;
¢¢S T
if
££ 
(
££ 
ret
££ 
<
££ 
this
££ 
.
££ 

adjustment
££ %
)
££% &
{
¤¤ 
return
¥¥ 
-
¥¥ 
$num
¥¥ 
;
¥¥ 
}
¦¦ 
return
§§ 
ret
§§ 
-
§§ 
this
§§ 
.
§§ 

adjustment
§§ (
;
§§( )
}
¨¨ 	
public
ªª 
override
ªª 
int
ªª 
ForEachByteDesc
ªª +
(
ªª+ ,
int
ªª, /
index
ªª0 5
,
ªª5 6
int
ªª7 :
length
ªª; A
,
ªªA B
IByteProcessor
ªªC Q
	processor
ªªR [
)
ªª[ \
{
«« 	
this
¬¬ 
.
¬¬ 
CheckIndex0
¬¬ 
(
¬¬ 
index
¬¬ "
,
¬¬" #
length
¬¬$ *
)
¬¬* +
;
¬¬+ ,
int
­­ 
ret
­­ 
=
­­ 
this
­­ 
.
­­ 
Unwrap
­­ !
(
­­! "
)
­­" #
.
­­# $
ForEachByteDesc
­­$ 3
(
­­3 4
this
­­4 8
.
­­8 9
Idx
­­9 <
(
­­< =
index
­­= B
)
­­B C
,
­­C D
length
­­E K
,
­­K L
	processor
­­M V
)
­­V W
;
­­W X
if
®® 
(
®® 
ret
®® 
<
®® 
this
®® 
.
®® 

adjustment
®® %
)
®®% &
{
¯¯ 
return
°° 
-
°° 
$num
°° 
;
°° 
}
±± 
return
²² 
ret
²² 
-
²² 
this
²² 
.
²² 

adjustment
²² (
;
²²( )
}
³³ 	
int
µµ 
Idx
µµ 
(
µµ 
int
µµ 
index
µµ 
)
µµ 
=>
µµ 
index
µµ #
+
µµ$ %
this
µµ& *
.
µµ* +

adjustment
µµ+ 5
;
µµ5 6
}
¶¶ 
}·· „½
oC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledUnsafeDirectByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

unsafe 
class (
PooledUnsafeDirectByteBuffer 4
:5 6
PooledByteBuffer7 G
<G H
byteH L
[L M
]M N
>N O
{ 
byte 
* 
memoryAddress 
; 
internal 
static (
PooledUnsafeDirectByteBuffer 4
NewInstance5 @
(@ A
intA D
maxCapacityE P
)P Q
{ 	
return 
new (
PooledUnsafeDirectByteBuffer 3
(3 4
maxCapacity4 ?
)? @
;@ A
} 	(
PooledUnsafeDirectByteBuffer $
($ %
int% (
maxCapacity) 4
)4 5
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
internal 
override 
void 
Init #
(# $
	PoolChunk$ -
<- .
byte. 2
[2 3
]3 4
>4 5
chunk6 ;
,; <
long= A
handleB H
,H I
intJ M
offsetN T
,T U
intV Y
lengthZ `
,` a
intb e
	maxLengthf o
,o p
PoolThreadCache 
< 
byte  
[  !
]! "
>" #
cache$ )
)) *
{ 	
base 
. 
Init 
( 
chunk 
, 
handle #
,# $
offset% +
,+ ,
length- 3
,3 4
	maxLength5 >
,> ?
cache@ E
)E F
;F G
this 
. 
InitMemoryAddress "
(" #
)# $
;$ %
} 	
internal!! 
override!! 
void!! 
InitUnpooled!! +
(!!+ ,
	PoolChunk!!, 5
<!!5 6
byte!!6 :
[!!: ;
]!!; <
>!!< =
chunk!!> C
,!!C D
int!!E H
length!!I O
)!!O P
{"" 	
base## 
.## 
InitUnpooled## 
(## 
chunk## #
,### $
length##% +
)##+ ,
;##, -
this$$ 
.$$ 
InitMemoryAddress$$ "
($$" #
)$$# $
;$$$ %
}%% 	
void'' 
InitMemoryAddress'' 
('' 
)''  
{(( 	
this)) 
.)) 
memoryAddress)) 
=))  
())! "
byte))" &
*))& '
)))' (
Unsafe))( .
.)). /
	AsPointer))/ 8
())8 9
ref))9 <
this))= A
.))A B
Memory))B H
[))H I
this))I M
.))M N
Offset))N T
]))T U
)))U V
;))V W
}** 	
public,, 
override,, 
bool,, 
IsDirect,, %
=>,,& (
true,,) -
;,,- .
internal.. 
void.. 
Reuse.. 
(.. 
int.. 
maxCapacity..  +
)..+ ,
{// 	
this00 
.00 
SetMaxCapacity00 
(00  
maxCapacity00  +
)00+ ,
;00, -
this11 
.11 
SetReferenceCount11 "
(11" #
$num11# $
)11$ %
;11% &
this22 
.22 
	SetIndex022 
(22 
$num22 
,22 
$num22 
)22  
;22  !
this33 
.33 
DiscardMarks33 
(33 
)33 
;33  
}44 	
	protected66 
internal66 
override66 #
byte66$ (
_GetByte66) 1
(661 2
int662 5
index666 ;
)66; <
=>66= ?
*66@ A
(66A B
this66B F
.66F G
memoryAddress66G T
+66U V
index66W \
)66\ ]
;66] ^
	protected88 
internal88 
override88 #
short88$ )
	_GetShort88* 3
(883 4
int884 7
index888 =
)88= >
=>88? A 
UnsafeByteBufferUtil88B V
.88V W
GetShort88W _
(88_ `
this88` d
.88d e
Addr88e i
(88i j
index88j o
)88o p
)88p q
;88q r
	protected:: 
internal:: 
override:: #
short::$ )
_GetShortLE::* 5
(::5 6
int::6 9
index::: ?
)::? @
=>::A C 
UnsafeByteBufferUtil::D X
.::X Y

GetShortLE::Y c
(::c d
this::d h
.::h i
Addr::i m
(::m n
index::n s
)::s t
)::t u
;::u v
	protected<< 
internal<< 
override<< #
int<<$ '
_GetUnsignedMedium<<( :
(<<: ;
int<<; >
index<<? D
)<<D E
=><<F H 
UnsafeByteBufferUtil<<I ]
.<<] ^
GetUnsignedMedium<<^ o
(<<o p
this<<p t
.<<t u
Addr<<u y
(<<y z
index<<z 
)	<< €
)
<<€ 
;
<< ‚
	protected>> 
internal>> 
override>> #
int>>$ ' 
_GetUnsignedMediumLE>>( <
(>>< =
int>>= @
index>>A F
)>>F G
=>>>H J 
UnsafeByteBufferUtil>>K _
.>>_ `
GetUnsignedMediumLE>>` s
(>>s t
this>>t x
.>>x y
Addr>>y }
(>>} ~
index	>>~ ƒ
)
>>ƒ „
)
>>„ …
;
>>… †
	protected@@ 
internal@@ 
override@@ #
int@@$ '
_GetInt@@( /
(@@/ 0
int@@0 3
index@@4 9
)@@9 :
=>@@; = 
UnsafeByteBufferUtil@@> R
.@@R S
GetInt@@S Y
(@@Y Z
this@@Z ^
.@@^ _
Addr@@_ c
(@@c d
index@@d i
)@@i j
)@@j k
;@@k l
	protectedBB 
internalBB 
overrideBB #
intBB$ '
	_GetIntLEBB( 1
(BB1 2
intBB2 5
indexBB6 ;
)BB; <
=>BB= ? 
UnsafeByteBufferUtilBB@ T
.BBT U
GetIntLEBBU ]
(BB] ^
thisBB^ b
.BBb c
AddrBBc g
(BBg h
indexBBh m
)BBm n
)BBn o
;BBo p
	protectedDD 
internalDD 
overrideDD #
longDD$ (
_GetLongDD) 1
(DD1 2
intDD2 5
indexDD6 ;
)DD; <
=>DD= ? 
UnsafeByteBufferUtilDD@ T
.DDT U
GetLongDDU \
(DD\ ]
thisDD] a
.DDa b
AddrDDb f
(DDf g
indexDDg l
)DDl m
)DDm n
;DDn o
	protectedFF 
internalFF 
overrideFF #
longFF$ (

_GetLongLEFF) 3
(FF3 4
intFF4 7
indexFF8 =
)FF= >
=>FF? A 
UnsafeByteBufferUtilFFB V
.FFV W
	GetLongLEFFW `
(FF` a
thisFFa e
.FFe f
AddrFFf j
(FFj k
indexFFk p
)FFp q
)FFq r
;FFr s
publicHH 
overrideHH 
IByteBufferHH #
GetBytesHH$ ,
(HH, -
intHH- 0
indexHH1 6
,HH6 7
IByteBufferHH8 C
dstHHD G
,HHG H
intHHI L
dstIndexHHM U
,HHU V
intHHW Z
lengthHH[ a
)HHa b
{II 	
thisJJ 
.JJ 

CheckIndexJJ 
(JJ 
indexJJ !
,JJ! "
lengthJJ# )
)JJ) *
;JJ* + 
UnsafeByteBufferUtilKK  
.KK  !
GetBytesKK! )
(KK) *
thisKK* .
,KK. /
thisKK0 4
.KK4 5
AddrKK5 9
(KK9 :
indexKK: ?
)KK? @
,KK@ A
indexKKB G
,KKG H
dstKKI L
,KKL M
dstIndexKKN V
,KKV W
lengthKKX ^
)KK^ _
;KK_ `
returnLL 
thisLL 
;LL 
}MM 	
publicOO 
overrideOO 
IByteBufferOO #
GetBytesOO$ ,
(OO, -
intOO- 0
indexOO1 6
,OO6 7
byteOO8 <
[OO< =
]OO= >
dstOO? B
,OOB C
intOOD G
dstIndexOOH P
,OOP Q
intOOR U
lengthOOV \
)OO\ ]
{PP 	
thisQQ 
.QQ 

CheckIndexQQ 
(QQ 
indexQQ !
,QQ! "
lengthQQ# )
)QQ) *
;QQ* + 
UnsafeByteBufferUtilRR  
.RR  !
GetBytesRR! )
(RR) *
thisRR* .
,RR. /
thisRR0 4
.RR4 5
AddrRR5 9
(RR9 :
indexRR: ?
)RR? @
,RR@ A
indexRRB G
,RRG H
dstRRI L
,RRL M
dstIndexRRN V
,RRV W
lengthRRX ^
)RR^ _
;RR_ `
returnSS 
thisSS 
;SS 
}TT 	
publicVV 
overrideVV 
IByteBufferVV #
GetBytesVV$ ,
(VV, -
intVV- 0
indexVV1 6
,VV6 7
StreamVV8 >
outputVV? E
,VVE F
intVVG J
lengthVVK Q
)VVQ R
{WW 	 
UnsafeByteBufferUtilXX  
.XX  !
GetBytesXX! )
(XX) *
thisXX* .
,XX. /
thisXX0 4
.XX4 5
AddrXX5 9
(XX9 :
indexXX: ?
)XX? @
,XX@ A
indexXXB G
,XXG H
outputXXI O
,XXO P
lengthXXQ W
)XXW X
;XXX Y
returnYY 
thisYY 
;YY 
}ZZ 	
	protected\\ 
internal\\ 
override\\ #
void\\$ (
_SetByte\\) 1
(\\1 2
int\\2 5
index\\6 ;
,\\; <
int\\= @
value\\A F
)\\F G
=>\\H J
*\\K L
(\\L M
this\\M Q
.\\Q R
memoryAddress\\R _
+\\` a
index\\b g
)\\g h
=\\i j
	unchecked\\k t
(\\t u
(\\u v
byte\\v z
)\\z {
value	\\{ €
)
\\€ 
;
\\ ‚
	protected^^ 
internal^^ 
override^^ #
void^^$ (
	_SetShort^^) 2
(^^2 3
int^^3 6
index^^7 <
,^^< =
int^^> A
value^^B G
)^^G H
=>^^I K 
UnsafeByteBufferUtil^^L `
.^^` a
SetShort^^a i
(^^i j
this^^j n
.^^n o
Addr^^o s
(^^s t
index^^t y
)^^y z
,^^z {
value	^^| 
)
^^ ‚
;
^^‚ ƒ
	protected`` 
internal`` 
override`` #
void``$ (
_SetShortLE``) 4
(``4 5
int``5 8
index``9 >
,``> ?
int``@ C
value``D I
)``I J
=>``K M 
UnsafeByteBufferUtil``N b
.``b c

SetShortLE``c m
(``m n
this``n r
.``r s
Addr``s w
(``w x
index``x }
)``} ~
,``~ 
value
``€ …
)
``… †
;
``† ‡
	protectedbb 
internalbb 
overridebb #
voidbb$ (

_SetMediumbb) 3
(bb3 4
intbb4 7
indexbb8 =
,bb= >
intbb? B
valuebbC H
)bbH I
=>bbJ L 
UnsafeByteBufferUtilbbM a
.bba b
	SetMediumbbb k
(bbk l
thisbbl p
.bbp q
Addrbbq u
(bbu v
indexbbv {
)bb{ |
,bb| }
value	bb~ ƒ
)
bbƒ „
;
bb„ …
	protecteddd 
internaldd 
overridedd #
voiddd$ (
_SetMediumLEdd) 5
(dd5 6
intdd6 9
indexdd: ?
,dd? @
intddA D
valueddE J
)ddJ K
=>ddL N 
UnsafeByteBufferUtilddO c
.ddc d
SetMediumLEddd o
(ddo p
thisddp t
.ddt u
Addrddu y
(ddy z
indexddz 
)	dd €
,
dd€ 
value
dd‚ ‡
)
dd‡ ˆ
;
ddˆ ‰
	protectedff 
internalff 
overrideff #
voidff$ (
_SetIntff) 0
(ff0 1
intff1 4
indexff5 :
,ff: ;
intff< ?
valueff@ E
)ffE F
=>ffG I 
UnsafeByteBufferUtilffJ ^
.ff^ _
SetIntff_ e
(ffe f
thisfff j
.ffj k
Addrffk o
(ffo p
indexffp u
)ffu v
,ffv w
valueffx }
)ff} ~
;ff~ 
	protectedhh 
internalhh 
overridehh #
voidhh$ (
	_SetIntLEhh) 2
(hh2 3
inthh3 6
indexhh7 <
,hh< =
inthh> A
valuehhB G
)hhG H
=>hhI K 
UnsafeByteBufferUtilhhL `
.hh` a
SetIntLEhha i
(hhi j
thishhj n
.hhn o
Addrhho s
(hhs t
indexhht y
)hhy z
,hhz {
value	hh| 
)
hh ‚
;
hh‚ ƒ
	protectedjj 
internaljj 
overridejj #
voidjj$ (
_SetLongjj) 1
(jj1 2
intjj2 5
indexjj6 ;
,jj; <
longjj= A
valuejjB G
)jjG H
=>jjI K 
UnsafeByteBufferUtiljjL `
.jj` a
SetLongjja h
(jjh i
thisjji m
.jjm n
Addrjjn r
(jjr s
indexjjs x
)jjx y
,jjy z
value	jj{ €
)
jj€ 
;
jj ‚
	protectedll 
internalll 
overridell #
voidll$ (

_SetLongLEll) 3
(ll3 4
intll4 7
indexll8 =
,ll= >
longll? C
valuellD I
)llI J
=>llK M 
UnsafeByteBufferUtilllN b
.llb c
	SetLongLEllc l
(lll m
thisllm q
.llq r
Addrllr v
(llv w
indexllw |
)ll| }
,ll} ~
value	ll „
)
ll„ …
;
ll… †
publicnn 
overridenn 
IByteBuffernn #
SetBytesnn$ ,
(nn, -
intnn- 0
indexnn1 6
,nn6 7
IByteBuffernn8 C
srcnnD G
,nnG H
intnnI L
srcIndexnnM U
,nnU V
intnnW Z
lengthnn[ a
)nna b
{oo 	
thispp 
.pp 

CheckIndexpp 
(pp 
indexpp !
,pp! "
lengthpp# )
)pp) *
;pp* + 
UnsafeByteBufferUtilqq  
.qq  !
SetBytesqq! )
(qq) *
thisqq* .
,qq. /
thisqq0 4
.qq4 5
Addrqq5 9
(qq9 :
indexqq: ?
)qq? @
,qq@ A
indexqqB G
,qqG H
srcqqI L
,qqL M
srcIndexqqN V
,qqV W
lengthqqX ^
)qq^ _
;qq_ `
returnrr 
thisrr 
;rr 
}ss 	
publicuu 
overrideuu 
IByteBufferuu #
SetBytesuu$ ,
(uu, -
intuu- 0
indexuu1 6
,uu6 7
byteuu8 <
[uu< =
]uu= >
srcuu? B
,uuB C
intuuD G
srcIndexuuH P
,uuP Q
intuuR U
lengthuuV \
)uu\ ]
{vv 	
thisww 
.ww 

CheckIndexww 
(ww 
indexww !
,ww! "
lengthww# )
)ww) *
;ww* + 
UnsafeByteBufferUtilxx  
.xx  !
SetBytesxx! )
(xx) *
thisxx* .
,xx. /
thisxx0 4
.xx4 5
Addrxx5 9
(xx9 :
indexxx: ?
)xx? @
,xx@ A
indexxxB G
,xxG H
srcxxI L
,xxL M
srcIndexxxN V
,xxV W
lengthxxX ^
)xx^ _
;xx_ `
returnyy 
thisyy 
;yy 
}zz 	
public|| 
override|| 
Task|| 
<|| 
int||  
>||  !
SetBytesAsync||" /
(||/ 0
int||0 3
index||4 9
,||9 :
Stream||; A
src||B E
,||E F
int||G J
length||K Q
,||Q R
CancellationToken||S d
cancellationToken||e v
)||v w
{}} 	
this~~ 
.~~ 

CheckIndex~~ 
(~~ 
index~~ !
,~~! "
length~~# )
)~~) *
;~~* +
return  
UnsafeByteBufferUtil '
.' (
SetBytesAsync( 5
(5 6
this6 :
,: ;
this< @
.@ A
AddrA E
(E F
indexF K
)K L
,L M
indexN S
,S T
srcU X
,X Y
lengthZ `
,` a
cancellationTokenb s
)s t
;t u
}
€€ 	
public
‚‚ 
override
‚‚ 
IByteBuffer
‚‚ #
Copy
‚‚$ (
(
‚‚( )
int
‚‚) ,
index
‚‚- 2
,
‚‚2 3
int
‚‚4 7
length
‚‚8 >
)
‚‚> ?
{
ƒƒ 	
this
„„ 
.
„„ 

CheckIndex
„„ 
(
„„ 
index
„„ !
,
„„! "
length
„„# )
)
„„) *
;
„„* +
return
…… "
UnsafeByteBufferUtil
…… '
.
……' (
Copy
……( ,
(
……, -
this
……- 1
,
……1 2
this
……3 7
.
……7 8
Addr
……8 <
(
……< =
index
……= B
)
……B C
,
……C D
index
……E J
,
……J K
length
……L R
)
……R S
;
……S T
}
†† 	
public
ˆˆ 
override
ˆˆ 
int
ˆˆ 
IoBufferCount
ˆˆ )
=>
ˆˆ* ,
$num
ˆˆ- .
;
ˆˆ. /
public
ŠŠ 
override
ŠŠ 
ArraySegment
ŠŠ $
<
ŠŠ$ %
byte
ŠŠ% )
>
ŠŠ) *
GetIoBuffer
ŠŠ+ 6
(
ŠŠ6 7
int
ŠŠ7 :
index
ŠŠ; @
,
ŠŠ@ A
int
ŠŠB E
length
ŠŠF L
)
ŠŠL M
{
‹‹ 	
this
ŒŒ 
.
ŒŒ 

CheckIndex
ŒŒ 
(
ŒŒ 
index
ŒŒ !
,
ŒŒ! "
length
ŒŒ# )
)
ŒŒ) *
;
ŒŒ* +
index
 
=
 
this
 
.
 
Idx
 
(
 
index
 "
)
" #
;
# $
return
 
new
 
ArraySegment
 #
<
# $
byte
$ (
>
( )
(
) *
this
* .
.
. /
Memory
/ 5
,
5 6
index
7 <
,
< =
length
> D
)
D E
;
E F
}
 	
public
‘‘ 
override
‘‘ 
ArraySegment
‘‘ $
<
‘‘$ %
byte
‘‘% )
>
‘‘) *
[
‘‘* +
]
‘‘+ ,
GetIoBuffers
‘‘- 9
(
‘‘9 :
int
‘‘: =
index
‘‘> C
,
‘‘C D
int
‘‘E H
length
‘‘I O
)
‘‘O P
=>
‘‘Q S
new
‘‘T W
[
‘‘W X
]
‘‘X Y
{
‘‘Z [
this
‘‘\ `
.
‘‘` a
GetIoBuffer
‘‘a l
(
‘‘l m
index
‘‘m r
,
‘‘r s
length
‘‘t z
)
‘‘z {
}
‘‘| }
;
‘‘} ~
public
““ 
override
““ 
bool
““ 
HasArray
““ %
=>
““& (
true
““) -
;
““- .
public
•• 
override
•• 
byte
•• 
[
•• 
]
•• 
Array
•• $
{
–– 	
get
—— 
{
˜˜ 
this
™™ 
.
™™ 
EnsureAccessible
™™ %
(
™™% &
)
™™& '
;
™™' (
return
šš 
this
šš 
.
šš 
Memory
šš "
;
šš" #
}
›› 
}
œœ 	
public
 
override
 
int
 
ArrayOffset
 '
=>
( *
this
+ /
.
/ 0
Offset
0 6
;
6 7
public
   
override
   
bool
   
HasMemoryAddress
   -
=>
  . 0
true
  1 5
;
  5 6
public
¢¢ 
override
¢¢ 
ref
¢¢ 
byte
¢¢  &
GetPinnableMemoryAddress
¢¢! 9
(
¢¢9 :
)
¢¢: ;
{
££ 	
this
¤¤ 
.
¤¤ 
EnsureAccessible
¤¤ !
(
¤¤! "
)
¤¤" #
;
¤¤# $
return
¥¥ 
ref
¥¥ 
this
¥¥ 
.
¥¥ 
Memory
¥¥ "
[
¥¥" #
this
¥¥# '
.
¥¥' (
Offset
¥¥( .
]
¥¥. /
;
¥¥/ 0
}
¦¦ 	
public
¨¨ 
override
¨¨ 
IntPtr
¨¨ #
AddressOfPinnedMemory
¨¨ 4
(
¨¨4 5
)
¨¨5 6
=>
¨¨7 9
(
¨¨: ;
IntPtr
¨¨; A
)
¨¨A B
this
¨¨B F
.
¨¨F G
memoryAddress
¨¨G T
;
¨¨T U
[
ªª 	

MethodImpl
ªª	 
(
ªª 
MethodImplOptions
ªª %
.
ªª% & 
AggressiveInlining
ªª& 8
)
ªª8 9
]
ªª9 :
byte
«« 
*
«« 
Addr
«« 
(
«« 
int
«« 
index
«« 
)
«« 
=>
««  
this
««! %
.
««% &
memoryAddress
««& 3
+
««4 5
index
««6 ;
;
««; <
public
­­ 
override
­­ 
IByteBuffer
­­ #
SetZero
­­$ +
(
­­+ ,
int
­­, /
index
­­0 5
,
­­5 6
int
­­7 :
length
­­; A
)
­­A B
{
®® 	
this
¯¯ 
.
¯¯ 

CheckIndex
¯¯ 
(
¯¯ 
index
¯¯ !
,
¯¯! "
length
¯¯# )
)
¯¯) *
;
¯¯* +"
UnsafeByteBufferUtil
°°  
.
°°  !
SetZero
°°! (
(
°°( )
this
°°) -
.
°°- .
Addr
°°. 2
(
°°2 3
index
°°3 8
)
°°8 9
,
°°9 :
length
°°; A
)
°°A B
;
°°B C
return
±± 
this
±± 
;
±± 
}
²² 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
	WriteZero
´´$ -
(
´´- .
int
´´. 1
length
´´2 8
)
´´8 9
{
µµ 	
this
¶¶ 
.
¶¶ 
EnsureWritable
¶¶ 
(
¶¶  
length
¶¶  &
)
¶¶& '
;
¶¶' (
int
·· 
wIndex
·· 
=
·· 
this
·· 
.
·· 
WriterIndex
·· )
;
··) *"
UnsafeByteBufferUtil
¸¸  
.
¸¸  !
SetZero
¸¸! (
(
¸¸( )
this
¸¸) -
.
¸¸- .
Addr
¸¸. 2
(
¸¸2 3
wIndex
¸¸3 9
)
¸¸9 :
,
¸¸: ;
length
¸¸< B
)
¸¸B C
;
¸¸C D
this
¹¹ 
.
¹¹ 
SetWriterIndex
¹¹ 
(
¹¹  
wIndex
¹¹  &
+
¹¹' (
length
¹¹) /
)
¹¹/ 0
;
¹¹0 1
return
ºº 
this
ºº 
;
ºº 
}
»» 	
}
¼¼ 
}½½ é§
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolSubpage.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed

 

class

 
PoolSubpage

 
<

 
T

 
>

 
:

  !
IPoolSubpageMetric

" 4
{ 
internal 
readonly 
	PoolChunk #
<# $
T$ %
>% &
Chunk' ,
;, -
readonly 
int 
memoryMapIdx !
;! "
readonly 
int 
	runOffset 
; 
readonly 
int 
pageSize 
; 
readonly 
long 
[ 
] 
bitmap 
; 
internal 
PoolSubpage 
< 
T 
> 
Prev  $
;$ %
internal 
PoolSubpage 
< 
T 
> 
Next  $
;$ %
internal 
bool 
DoNotDestroy "
;" #
internal 
int 
ElemSize 
; 
int 
maxNumElems 
; 
int 
bitmapLength 
; 
int 
	nextAvail 
; 
int 
numAvail 
; 
public!! 
PoolSubpage!! 
(!! 
int!! 
pageSize!! '
)!!' (
{"" 	
this## 
.## 
Chunk## 
=## 
null## 
;## 
this$$ 
.$$ 
memoryMapIdx$$ 
=$$ 
-$$  !
$num$$! "
;$$" #
this%% 
.%% 
	runOffset%% 
=%% 
-%% 
$num%% 
;%%  
this&& 
.&& 
ElemSize&& 
=&& 
-&& 
$num&& 
;&& 
this'' 
.'' 
pageSize'' 
='' 
pageSize'' $
;''$ %
this(( 
.(( 
bitmap(( 
=(( 
null(( 
;(( 
})) 	
public++ 
PoolSubpage++ 
(++ 
PoolSubpage++ &
<++& '
T++' (
>++( )
head++* .
,++. /
	PoolChunk++0 9
<++9 :
T++: ;
>++; <
chunk++= B
,++B C
int++D G
memoryMapIdx++H T
,++T U
int++V Y
	runOffset++Z c
,++c d
int++e h
pageSize++i q
,++q r
int++s v
elemSize++w 
)	++ €
{,, 	
this-- 
.-- 
Chunk-- 
=-- 
chunk-- 
;-- 
this.. 
... 
memoryMapIdx.. 
=.. 
memoryMapIdx..  ,
;.., -
this// 
.// 
	runOffset// 
=// 
	runOffset// &
;//& '
this00 
.00 
pageSize00 
=00 
pageSize00 $
;00$ %
this11 
.11 
bitmap11 
=11 
new11 
long11 "
[11" #
pageSize11# +
.11+ ,
RightUShift11, 7
(117 8
$num118 :
)11: ;
]11; <
;11< =
this22 
.22 
Init22 
(22 
head22 
,22 
elemSize22 $
)22$ %
;22% &
}33 	
public55 
void55 
Init55 
(55 
PoolSubpage55 $
<55$ %
T55% &
>55& '
head55( ,
,55, -
int55. 1
elemSize552 :
)55: ;
{66 	
this77 
.77 
DoNotDestroy77 
=77 
true77  $
;77$ %
this88 
.88 
ElemSize88 
=88 
elemSize88 $
;88$ %
if99 
(99 
elemSize99 
!=99 
$num99 
)99 
{:: 
this;; 
.;; 
maxNumElems;;  
=;;! "
this;;# '
.;;' (
numAvail;;( 0
=;;1 2
this;;3 7
.;;7 8
pageSize;;8 @
/;;A B
elemSize;;C K
;;;K L
this<< 
.<< 
	nextAvail<< 
=<<  
$num<<! "
;<<" #
this== 
.== 
bitmapLength== !
===" #
this==$ (
.==( )
maxNumElems==) 4
.==4 5
RightUShift==5 @
(==@ A
$num==A B
)==B C
;==C D
if>> 
(>> 
(>> 
this>> 
.>> 
maxNumElems>> %
&>>& '
$num>>( *
)>>* +
!=>>, .
$num>>/ 0
)>>0 1
{?? 
this@@ 
.@@ 
bitmapLength@@ %
++@@% '
;@@' (
}AA 
forCC 
(CC 
intCC 
iCC 
=CC 
$numCC 
;CC 
iCC  !
<CC" #
thisCC$ (
.CC( )
bitmapLengthCC) 5
;CC5 6
iCC7 8
++CC8 :
)CC: ;
{DD 
thisEE 
.EE 
bitmapEE 
[EE  
iEE  !
]EE! "
=EE# $
$numEE% &
;EE& '
}FF 
}GG 
thisII 
.II 
	AddToPoolII 
(II 
headII 
)II  
;II  !
}JJ 	
internalPP 
longPP 
AllocatePP 
(PP 
)PP  
{QQ 	
ifRR 
(RR 
thisRR 
.RR 
ElemSizeRR 
==RR  
$numRR! "
)RR" #
{SS 
returnTT 
thisTT 
.TT 
ToHandleTT $
(TT$ %
$numTT% &
)TT& '
;TT' (
}UU 
ifWW 
(WW 
thisWW 
.WW 
numAvailWW 
==WW  
$numWW! "
||WW# %
!WW& '
thisWW' +
.WW+ ,
DoNotDestroyWW, 8
)WW8 9
{XX 
returnYY 
-YY 
$numYY 
;YY 
}ZZ 
int\\ 
	bitmapIdx\\ 
=\\ 
this\\  
.\\  !
GetNextAvail\\! -
(\\- .
)\\. /
;\\/ 0
int]] 
q]] 
=]] 
	bitmapIdx]] 
.]] 
RightUShift]] )
(]]) *
$num]]* +
)]]+ ,
;]], -
int^^ 
r^^ 
=^^ 
	bitmapIdx^^ 
&^^ 
$num^^  "
;^^" #
Contract__ 
.__ 
Assert__ 
(__ 
(__ 
this__ !
.__! "
bitmap__" (
[__( )
q__) *
]__* +
.__+ ,
RightUShift__, 7
(__7 8
r__8 9
)__9 :
&__; <
$num__= >
)__> ?
==__@ B
$num__C D
)__D E
;__E F
this`` 
.`` 
bitmap`` 
[`` 
q`` 
]`` 
|=`` 
$num``  
<<``! #
r``$ %
;``% &
ifbb 
(bb 
--bb 
thisbb 
.bb 
numAvailbb 
==bb  "
$numbb# $
)bb$ %
{cc 
thisdd 
.dd 
RemoveFromPooldd #
(dd# $
)dd$ %
;dd% &
}ee 
returngg 
thisgg 
.gg 
ToHandlegg  
(gg  !
	bitmapIdxgg! *
)gg* +
;gg+ ,
}hh 	
internaloo 
booloo 
Freeoo 
(oo 
PoolSubpageoo &
<oo& '
Too' (
>oo( )
headoo* .
,oo. /
intoo0 3
	bitmapIdxoo4 =
)oo= >
{pp 	
ifqq 
(qq 
thisqq 
.qq 
ElemSizeqq 
==qq  
$numqq! "
)qq" #
{rr 
returnss 
truess 
;ss 
}tt 
intvv 
qvv 
=vv 
	bitmapIdxvv 
.vv 
RightUShiftvv )
(vv) *
$numvv* +
)vv+ ,
;vv, -
intww 
rww 
=ww 
	bitmapIdxww 
&ww 
$numww  "
;ww" #
Debugxx 
.xx 
Assertxx 
(xx 
(xx 
thisxx 
.xx 
bitmapxx %
[xx% &
qxx& '
]xx' (
.xx( )
RightUShiftxx) 4
(xx4 5
rxx5 6
)xx6 7
&xx8 9
$numxx: ;
)xx; <
!=xx= ?
$numxx@ A
)xxA B
;xxB C
thisyy 
.yy 
bitmapyy 
[yy 
qyy 
]yy 
^=yy 
$numyy  
<<yy! #
ryy$ %
;yy% &
this{{ 
.{{ 
SetNextAvail{{ 
({{ 
	bitmapIdx{{ '
){{' (
;{{( )
if}} 
(}} 
this}} 
.}} 
numAvail}} 
++}} 
==}}  "
$num}}# $
)}}$ %
{~~ 
this 
. 
	AddToPool 
( 
head #
)# $
;$ %
return
€€ 
true
€€ 
;
€€ 
}
 
if
ƒƒ 
(
ƒƒ 
this
ƒƒ 
.
ƒƒ 
numAvail
ƒƒ 
!=
ƒƒ  
this
ƒƒ! %
.
ƒƒ% &
maxNumElems
ƒƒ& 1
)
ƒƒ1 2
{
„„ 
return
…… 
true
…… 
;
…… 
}
†† 
else
‡‡ 
{
ˆˆ 
if
ŠŠ 
(
ŠŠ 
this
ŠŠ 
.
ŠŠ 
Prev
ŠŠ 
==
ŠŠ  
this
ŠŠ! %
.
ŠŠ% &
Next
ŠŠ& *
)
ŠŠ* +
{
‹‹ 
return
 
true
 
;
  
}
 
this
‘‘ 
.
‘‘ 
DoNotDestroy
‘‘ !
=
‘‘" #
false
‘‘$ )
;
‘‘) *
this
’’ 
.
’’ 
RemoveFromPool
’’ #
(
’’# $
)
’’$ %
;
’’% &
return
““ 
false
““ 
;
““ 
}
”” 
}
•• 	
void
—— 
	AddToPool
—— 
(
—— 
PoolSubpage
—— "
<
——" #
T
——# $
>
——$ %
head
——& *
)
——* +
{
˜˜ 	
Debug
™™ 
.
™™ 
Assert
™™ 
(
™™ 
this
™™ 
.
™™ 
Prev
™™ "
==
™™# %
null
™™& *
&&
™™+ -
this
™™. 2
.
™™2 3
Next
™™3 7
==
™™8 :
null
™™; ?
)
™™? @
;
™™@ A
this
›› 
.
›› 
Prev
›› 
=
›› 
head
›› 
;
›› 
this
œœ 
.
œœ 
Next
œœ 
=
œœ 
head
œœ 
.
œœ 
Next
œœ !
;
œœ! "
this
 
.
 
Next
 
.
 
Prev
 
=
 
this
 !
;
! "
head
 
.
 
Next
 
=
 
this
 
;
 
}
ŸŸ 	
void
¡¡ 
RemoveFromPool
¡¡ 
(
¡¡ 
)
¡¡ 
{
¢¢ 	
Debug
££ 
.
££ 
Assert
££ 
(
££ 
this
££ 
.
££ 
Prev
££ "
!=
££# %
null
££& *
&&
££+ -
this
££. 2
.
££2 3
Next
££3 7
!=
££8 :
null
££; ?
)
££? @
;
££@ A
this
¥¥ 
.
¥¥ 
Prev
¥¥ 
.
¥¥ 
Next
¥¥ 
=
¥¥ 
this
¥¥ !
.
¥¥! "
Next
¥¥" &
;
¥¥& '
this
¦¦ 
.
¦¦ 
Next
¦¦ 
.
¦¦ 
Prev
¦¦ 
=
¦¦ 
this
¦¦ !
.
¦¦! "
Prev
¦¦" &
;
¦¦& '
this
§§ 
.
§§ 
Next
§§ 
=
§§ 
null
§§ 
;
§§ 
this
¨¨ 
.
¨¨ 
Prev
¨¨ 
=
¨¨ 
null
¨¨ 
;
¨¨ 
}
©© 	
void
«« 
SetNextAvail
«« 
(
«« 
int
«« 
	bitmapIdx
«« '
)
««' (
=>
««) +
this
««, 0
.
««0 1
	nextAvail
««1 :
=
««; <
	bitmapIdx
««= F
;
««F G
int
­­ 
GetNextAvail
­­ 
(
­­ 
)
­­ 
{
®® 	
int
¯¯ 
	nextAvail
¯¯ 
=
¯¯ 
this
¯¯  
.
¯¯  !
	nextAvail
¯¯! *
;
¯¯* +
if
°° 
(
°° 
	nextAvail
°° 
>=
°° 
$num
°° 
)
°° 
{
±± 
this
²² 
.
²² 
	nextAvail
²² 
=
²²  
-
²²! "
$num
²²" #
;
²²# $
return
³³ 
	nextAvail
³³  
;
³³  !
}
´´ 
return
µµ 
this
µµ 
.
µµ 
FindNextAvail
µµ %
(
µµ% &
)
µµ& '
;
µµ' (
}
¶¶ 	
int
¸¸ 
FindNextAvail
¸¸ 
(
¸¸ 
)
¸¸ 
{
¹¹ 	
long
ºº 
[
ºº 
]
ºº 
bitmap
ºº 
=
ºº 
this
ºº  
.
ºº  !
bitmap
ºº! '
;
ºº' (
int
»» 
bitmapLength
»» 
=
»» 
this
»» #
.
»»# $
bitmapLength
»»$ 0
;
»»0 1
for
¼¼ 
(
¼¼ 
int
¼¼ 
i
¼¼ 
=
¼¼ 
$num
¼¼ 
;
¼¼ 
i
¼¼ 
<
¼¼ 
bitmapLength
¼¼  ,
;
¼¼, -
i
¼¼. /
++
¼¼/ 1
)
¼¼1 2
{
½½ 
long
¾¾ 
bits
¾¾ 
=
¾¾ 
bitmap
¾¾ "
[
¾¾" #
i
¾¾# $
]
¾¾$ %
;
¾¾% &
if
¿¿ 
(
¿¿ 
~
¿¿ 
bits
¿¿ 
!=
¿¿ 
$num
¿¿ 
)
¿¿ 
{
ÀÀ 
return
ÁÁ 
this
ÁÁ 
.
ÁÁ  
FindNextAvail0
ÁÁ  .
(
ÁÁ. /
i
ÁÁ/ 0
,
ÁÁ0 1
bits
ÁÁ2 6
)
ÁÁ6 7
;
ÁÁ7 8
}
ÂÂ 
}
ÃÃ 
return
ÄÄ 
-
ÄÄ 
$num
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
int
ÇÇ 
FindNextAvail0
ÇÇ 
(
ÇÇ 
int
ÇÇ 
i
ÇÇ  
,
ÇÇ  !
long
ÇÇ" &
bits
ÇÇ' +
)
ÇÇ+ ,
{
ÈÈ 	
int
ÉÉ 
maxNumElems
ÉÉ 
=
ÉÉ 
this
ÉÉ "
.
ÉÉ" #
maxNumElems
ÉÉ# .
;
ÉÉ. /
int
ÊÊ 
baseVal
ÊÊ 
=
ÊÊ 
i
ÊÊ 
<<
ÊÊ 
$num
ÊÊ  
;
ÊÊ  !
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
j
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
j
ÌÌ 
<
ÌÌ 
$num
ÌÌ  "
;
ÌÌ" #
j
ÌÌ$ %
++
ÌÌ% '
)
ÌÌ' (
{
ÍÍ 
if
ÎÎ 
(
ÎÎ 
(
ÎÎ 
bits
ÎÎ 
&
ÎÎ 
$num
ÎÎ 
)
ÎÎ 
==
ÎÎ !
$num
ÎÎ" #
)
ÎÎ# $
{
ÏÏ 
int
ĞĞ 
val
ĞĞ 
=
ĞĞ 
baseVal
ĞĞ %
|
ĞĞ& '
j
ĞĞ( )
;
ĞĞ) *
if
ÑÑ 
(
ÑÑ 
val
ÑÑ 
<
ÑÑ 
maxNumElems
ÑÑ )
)
ÑÑ) *
{
ÒÒ 
return
ÓÓ 
val
ÓÓ "
;
ÓÓ" #
}
ÔÔ 
else
ÕÕ 
{
ÖÖ 
break
×× 
;
×× 
}
ØØ 
}
ÙÙ 
bits
ÚÚ 
=
ÚÚ 
bits
ÚÚ 
.
ÚÚ 
RightUShift
ÚÚ '
(
ÚÚ' (
$num
ÚÚ( )
)
ÚÚ) *
;
ÚÚ* +
}
ÛÛ 
return
ÜÜ 
-
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
}
İİ 	
long
ßß 
ToHandle
ßß 
(
ßß 
int
ßß 
	bitmapIdx
ßß #
)
ßß# $
=>
ßß% '
$num
ßß( ;
|
ßß< =
(
ßß> ?
long
ßß? C
)
ßßC D
	bitmapIdx
ßßD M
<<
ßßN P
$num
ßßQ S
|
ßßT U
(
ßßV W
uint
ßßW [
)
ßß[ \
this
ßß\ `
.
ßß` a
memoryMapIdx
ßßa m
;
ßßm n
public
áá 
override
áá 
string
áá 
ToString
áá '
(
áá' (
)
áá( )
{
ââ 	
bool
ãã 
doNotDestroy
ãã 
;
ãã 
int
ää 
maxNumElems
ää 
;
ää 
int
åå 
numAvail
åå 
;
åå 
int
ææ 
elemSize
ææ 
;
ææ 
lock
çç 
(
çç 
this
çç 
.
çç 
Chunk
çç 
.
çç 
Arena
çç "
)
çç" #
{
èè 
if
éé 
(
éé 
!
éé 
this
éé 
.
éé 
DoNotDestroy
éé &
)
éé& '
{
êê 
doNotDestroy
ëë  
=
ëë! "
false
ëë# (
;
ëë( )
maxNumElems
íí 
=
íí  !
numAvail
íí" *
=
íí+ ,
elemSize
íí- 5
=
íí6 7
-
íí8 9
$num
íí9 :
;
íí: ;
}
îî 
else
ïï 
{
ğğ 
doNotDestroy
ññ  
=
ññ! "
true
ññ# '
;
ññ' (
maxNumElems
òò 
=
òò  !
this
òò" &
.
òò& '
maxNumElems
òò' 2
;
òò2 3
numAvail
óó 
=
óó 
this
óó #
.
óó# $
numAvail
óó$ ,
;
óó, -
elemSize
ôô 
=
ôô 
this
ôô #
.
ôô# $
ElemSize
ôô$ ,
;
ôô, -
}
õõ 
}
öö 
if
øø 
(
øø 
!
øø 
doNotDestroy
øø 
)
øø 
{
ùù 
return
úú 
$str
úú 
+
úú 
this
úú !
.
úú! "
memoryMapIdx
úú" .
+
úú/ 0
$str
úú1 @
;
úú@ A
}
ûû 
return
ıı 
$str
ıı 
+
ıı 
this
ıı 
.
ıı 
memoryMapIdx
ıı *
+
ıı+ ,
$str
ıı- 1
+
ıı2 3
(
ıı4 5
maxNumElems
ıı5 @
-
ııA B
numAvail
ııC K
)
ııK L
+
ııM N
$str
ııO R
+
ııS T
maxNumElems
ııU `
+
ııa b
$str
şş 
+
şş 
this
şş #
.
şş# $
	runOffset
şş$ -
+
şş. /
$str
şş0 <
+
şş= >
this
şş? C
.
şşC D
pageSize
şşD L
+
şşM N
$str
şşO ]
+
şş^ _
elemSize
şş` h
+
şşi j
$str
şşk n
;
şşn o
}
ÿÿ 	
public
 
int
 
MaxNumElements
 !
{
‚‚ 	
get
ƒƒ 
{
„„ 
lock
…… 
(
…… 
this
…… 
.
…… 
Chunk
……  
.
……  !
Arena
……! &
)
……& '
{
†† 
return
‡‡ 
this
‡‡ 
.
‡‡  
maxNumElems
‡‡  +
;
‡‡+ ,
}
ˆˆ 
}
‰‰ 
}
ŠŠ 	
public
ŒŒ 
int
ŒŒ 
NumAvailable
ŒŒ 
{
 	
get
 
{
 
lock
 
(
 
this
 
.
 
Chunk
  
.
  !
Arena
! &
)
& '
{
‘‘ 
return
’’ 
this
’’ 
.
’’  
numAvail
’’  (
;
’’( )
}
““ 
}
”” 
}
•• 	
public
—— 
int
—— 
ElementSize
—— 
{
˜˜ 	
get
™™ 
{
šš 
lock
›› 
(
›› 
this
›› 
.
›› 
Chunk
››  
.
››  !
Arena
››! &
)
››& '
{
œœ 
return
 
this
 
.
  
ElemSize
  (
;
( )
}
 
}
ŸŸ 
}
   	
public
¢¢ 
int
¢¢ 
PageSize
¢¢ 
=>
¢¢ 
this
¢¢ #
.
¢¢# $
pageSize
¢¢$ ,
;
¢¢, -
internal
¤¤ 
void
¤¤ 
Destroy
¤¤ 
(
¤¤ 
)
¤¤ 
=>
¤¤  "
this
¤¤# '
.
¤¤' (
Chunk
¤¤( -
?
¤¤- .
.
¤¤. /
Destroy
¤¤/ 6
(
¤¤6 7
)
¤¤7 8
;
¤¤8 9
}
¥¥ 
}¦¦ ¨Ê
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolThreadCache.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 
PoolThreadCache  
<  !
T! "
>" #
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S
PoolThreadCacheS b
<b c
Tc d
>d e
>e f
(f g
)g h
;h i
internal 
readonly 
	PoolArena #
<# $
T$ %
>% &
	HeapArena' 0
;0 1
internal 
readonly 
	PoolArena #
<# $
T$ %
>% &
DirectArena' 2
;2 3
readonly"" 
MemoryRegionCache"" "
[""" #
]""# $!
tinySubPageHeapCaches""% :
;"": ;
readonly## 
MemoryRegionCache## "
[##" #
]### $"
smallSubPageHeapCaches##% ;
;##; <
readonly$$ 
MemoryRegionCache$$ "
[$$" #
]$$# $#
tinySubPageDirectCaches$$% <
;$$< =
readonly%% 
MemoryRegionCache%% "
[%%" #
]%%# $$
smallSubPageDirectCaches%%% =
;%%= >
readonly&& 
MemoryRegionCache&& "
[&&" #
]&&# $
normalHeapCaches&&% 5
;&&5 6
readonly'' 
MemoryRegionCache'' "
[''" #
]''# $
normalDirectCaches''% 7
;''7 8
readonly** 
int** !
numShiftsNormalDirect** *
;*** +
readonly++ 
int++ 
numShiftsNormalHeap++ (
;++( )
readonly,, 
int,, (
freeSweepAllocationThreshold,, 1
;,,1 2
int.. 
allocations.. 
;.. 
readonly00 
Thread00 
deathWatchThread00 (
;00( )
readonly11 
Action11 
freeTask11  
;11  !
internal66 
PoolThreadCache66  
(66  !
	PoolArena66! *
<66* +
T66+ ,
>66, -
	heapArena66. 7
,667 8
	PoolArena669 B
<66B C
T66C D
>66D E
directArena66F Q
,66Q R
int77 
tinyCacheSize77 
,77 
int77 "
smallCacheSize77# 1
,771 2
int773 6
normalCacheSize777 F
,77F G
int88 #
maxCachedBufferCapacity88 '
,88' (
int88) ,(
freeSweepAllocationThreshold88- I
)88I J
{99 	
Contract:: 
.:: 
Requires:: 
(:: #
maxCachedBufferCapacity:: 5
>=::6 8
$num::9 :
)::: ;
;::; <
Contract;; 
.;; 
Requires;; 
(;; (
freeSweepAllocationThreshold;; :
>;;; <
$num;;= >
);;> ?
;;;? @
this== 
.== (
freeSweepAllocationThreshold== -
===. /(
freeSweepAllocationThreshold==0 L
;==L M
this>> 
.>> 
	HeapArena>> 
=>> 
	heapArena>> &
;>>& '
this?? 
.?? 
DirectArena?? 
=?? 
directArena?? *
;??* +
if@@ 
(@@ 
directArena@@ 
!=@@ 
null@@ #
)@@# $
{AA 
thisBB 
.BB #
tinySubPageDirectCachesBB ,
=BB- .
CreateSubPageCachesBB/ B
(BBB C
tinyCacheSizeCC !
,CC! "
	PoolArenaCC# ,
<CC, -
TCC- .
>CC. /
.CC/ 0
NumTinySubpagePoolsCC0 C
,CCC D
	SizeClassCCE N
.CCN O
TinyCCO S
)CCS T
;CCT U
thisDD 
.DD $
smallSubPageDirectCachesDD -
=DD. /
CreateSubPageCachesDD0 C
(DDC D
smallCacheSizeEE "
,EE" #
directArenaEE$ /
.EE/ 0 
NumSmallSubpagePoolsEE0 D
,EED E
	SizeClassEEF O
.EEO P
SmallEEP U
)EEU V
;EEV W
thisGG 
.GG !
numShiftsNormalDirectGG *
=GG+ ,
Log2GG- 1
(GG1 2
directArenaGG2 =
.GG= >
PageSizeGG> F
)GGF G
;GGG H
thisHH 
.HH 
normalDirectCachesHH '
=HH( )
CreateNormalCachesHH* <
(HH< =
normalCacheSizeII #
,II# $#
maxCachedBufferCapacityII% <
,II< =
directArenaII> I
)III J
;IIJ K
directArenaKK 
.KK $
IncrementNumThreadCachesKK 4
(KK4 5
)KK5 6
;KK6 7
}LL 
elseMM 
{NN 
thisPP 
.PP #
tinySubPageDirectCachesPP ,
=PP- .
nullPP/ 3
;PP3 4
thisQQ 
.QQ $
smallSubPageDirectCachesQQ -
=QQ. /
nullQQ0 4
;QQ4 5
thisRR 
.RR 
normalDirectCachesRR '
=RR( )
nullRR* .
;RR. /
thisSS 
.SS !
numShiftsNormalDirectSS *
=SS+ ,
-SS- .
$numSS. /
;SS/ 0
}TT 
ifUU 
(UU 
	heapArenaUU 
!=UU 
nullUU !
)UU! "
{VV 
thisXX 
.XX !
tinySubPageHeapCachesXX *
=XX+ ,
CreateSubPageCachesXX- @
(XX@ A
tinyCacheSizeYY !
,YY! "
	PoolArenaYY# ,
<YY, -
TYY- .
>YY. /
.YY/ 0
NumTinySubpagePoolsYY0 C
,YYC D
	SizeClassYYE N
.YYN O
TinyYYO S
)YYS T
;YYT U
thisZZ 
.ZZ "
smallSubPageHeapCachesZZ +
=ZZ, -
CreateSubPageCachesZZ. A
(ZZA B
smallCacheSize[[ "
,[[" #
	heapArena[[$ -
.[[- . 
NumSmallSubpagePools[[. B
,[[B C
	SizeClass[[D M
.[[M N
Small[[N S
)[[S T
;[[T U
this]] 
.]] 
numShiftsNormalHeap]] (
=]]) *
Log2]]+ /
(]]/ 0
	heapArena]]0 9
.]]9 :
PageSize]]: B
)]]B C
;]]C D
this^^ 
.^^ 
normalHeapCaches^^ %
=^^& '
CreateNormalCaches^^( :
(^^: ;
normalCacheSize__ #
,__# $#
maxCachedBufferCapacity__% <
,__< =
	heapArena__> G
)__G H
;__H I
	heapArenaaa 
.aa $
IncrementNumThreadCachesaa 2
(aa2 3
)aa3 4
;aa4 5
}bb 
elsecc 
{dd 
thisff 
.ff !
tinySubPageHeapCachesff *
=ff+ ,
nullff- 1
;ff1 2
thisgg 
.gg "
smallSubPageHeapCachesgg +
=gg, -
nullgg. 2
;gg2 3
thishh 
.hh 
normalHeapCacheshh %
=hh& '
nullhh( ,
;hh, -
thisii 
.ii 
numShiftsNormalHeapii (
=ii) *
-ii+ ,
$numii, -
;ii- .
}jj 
ifmm 
(mm 
thismm 
.mm #
tinySubPageDirectCachesmm ,
!=mm- /
nullmm0 4
||mm5 7
thismm8 <
.mm< =$
smallSubPageDirectCachesmm= U
!=mmV X
nullmmY ]
||mm^ `
thismma e
.mme f
normalDirectCachesmmf x
!=mmy {
null	mm| €
||nn 
thisnn 
.nn !
tinySubPageHeapCachesnn -
!=nn. 0
nullnn1 5
||nn6 8
thisnn9 =
.nn= >"
smallSubPageHeapCachesnn> T
!=nnU W
nullnnX \
||nn] _
thisnn` d
.nnd e
normalHeapCachesnne u
!=nnv x
nullnny }
)nn} ~
{oo 
thispp 
.pp 
freeTaskpp 
=pp 
thispp  $
.pp$ %
Free0pp% *
;pp* +
thisqq 
.qq 
deathWatchThreadqq %
=qq& '
Threadqq( .
.qq. /
CurrentThreadqq/ <
;qq< =
ThreadDeathWatcheruu "
.uu" #
Watchuu# (
(uu( )
thisuu) -
.uu- .
deathWatchThreaduu. >
,uu> ?
thisuu@ D
.uuD E
freeTaskuuE M
)uuM N
;uuN O
}vv 
elseww 
{xx 
thisyy 
.yy 
freeTaskyy 
=yy 
nullyy  $
;yy$ %
thiszz 
.zz 
deathWatchThreadzz %
=zz& '
nullzz( ,
;zz, -
}{{ 
}|| 	
static~~ 
MemoryRegionCache~~  
[~~  !
]~~! "
CreateSubPageCaches~~# 6
(~~6 7
int 
	cacheSize 
, 
int 
	numCaches (
,( )
	SizeClass* 3
	sizeClass4 =
)= >
{
€€ 	
if
 
(
 
	cacheSize
 
>
 
$num
 
)
 
{
‚‚ 
var
ƒƒ 
cache
ƒƒ 
=
ƒƒ 
new
ƒƒ 
MemoryRegionCache
ƒƒ  1
[
ƒƒ1 2
	numCaches
ƒƒ2 ;
]
ƒƒ; <
;
ƒƒ< =
for
„„ 
(
„„ 
int
„„ 
i
„„ 
=
„„ 
$num
„„ 
;
„„ 
i
„„  !
<
„„" #
cache
„„$ )
.
„„) *
Length
„„* 0
;
„„0 1
i
„„2 3
++
„„3 5
)
„„5 6
{
…… 
cache
‡‡ 
[
‡‡ 
i
‡‡ 
]
‡‡ 
=
‡‡ 
new
‡‡ "&
SubPageMemoryRegionCache
‡‡# ;
(
‡‡; <
	cacheSize
‡‡< E
,
‡‡E F
	sizeClass
‡‡G P
)
‡‡P Q
;
‡‡Q R
}
ˆˆ 
return
‰‰ 
cache
‰‰ 
;
‰‰ 
}
ŠŠ 
else
‹‹ 
{
ŒŒ 
return
 
null
 
;
 
}
 
}
 	
static
‘‘ 
MemoryRegionCache
‘‘  
[
‘‘  !
]
‘‘! " 
CreateNormalCaches
‘‘# 5
(
‘‘5 6
int
’’ 
	cacheSize
’’ 
,
’’ 
int
’’ %
maxCachedBufferCapacity
’’ 6
,
’’6 7
	PoolArena
’’8 A
<
’’A B
T
’’B C
>
’’C D
area
’’E I
)
’’I J
{
““ 	
if
”” 
(
”” 
	cacheSize
”” 
>
”” 
$num
”” 
)
”” 
{
•• 
int
–– 
max
–– 
=
–– 
Math
–– 
.
–– 
Min
–– "
(
––" #
area
––# '
.
––' (
	ChunkSize
––( 1
,
––1 2%
maxCachedBufferCapacity
––3 J
)
––J K
;
––K L
int
—— 
	arraySize
—— 
=
—— 
Math
——  $
.
——$ %
Max
——% (
(
——( )
$num
——) *
,
——* +
Log2
——, 0
(
——0 1
max
——1 4
/
——5 6
area
——7 ;
.
——; <
PageSize
——< D
)
——D E
+
——F G
$num
——H I
)
——I J
;
——J K
var
™™ 
cache
™™ 
=
™™ 
new
™™ 
MemoryRegionCache
™™  1
[
™™1 2
	arraySize
™™2 ;
]
™™; <
;
™™< =
for
šš 
(
šš 
int
šš 
i
šš 
=
šš 
$num
šš 
;
šš 
i
šš  !
<
šš" #
cache
šš$ )
.
šš) *
Length
šš* 0
;
šš0 1
i
šš2 3
++
šš3 5
)
šš5 6
{
›› 
cache
œœ 
[
œœ 
i
œœ 
]
œœ 
=
œœ 
new
œœ "%
NormalMemoryRegionCache
œœ# :
(
œœ: ;
	cacheSize
œœ; D
)
œœD E
;
œœE F
}
 
return
 
cache
 
;
 
}
ŸŸ 
else
   
{
¡¡ 
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 
}
¤¤ 	
static
¦¦ 
int
¦¦ 
Log2
¦¦ 
(
¦¦ 
int
¦¦ 
val
¦¦ 
)
¦¦  
{
§§ 	
int
©© 
res
©© 
=
©© 
$num
©© 
;
©© 
while
ªª 
(
ªª 
val
ªª 
>
ªª 
$num
ªª 
)
ªª 
{
«« 
val
¬¬ 
>>=
¬¬ 
$num
¬¬ 
;
¬¬ 
res
­­ 
++
­­ 
;
­­ 
}
®® 
return
¯¯ 
res
¯¯ 
;
¯¯ 
}
°° 	
internal
µµ 
bool
µµ 
AllocateTiny
µµ "
(
µµ" #
	PoolArena
µµ# ,
<
µµ, -
T
µµ- .
>
µµ. /
area
µµ0 4
,
µµ4 5
PooledByteBuffer
µµ6 F
<
µµF G
T
µµG H
>
µµH I
buf
µµJ M
,
µµM N
int
µµO R
reqCapacity
µµS ^
,
µµ^ _
int
µµ` c
normCapacity
µµd p
)
µµp q
=>
µµr t
this
¶¶ 
.
¶¶ 
Allocate
¶¶ 
(
¶¶ 
this
¶¶ 
.
¶¶ 
CacheForTiny
¶¶ +
(
¶¶+ ,
area
¶¶, 0
,
¶¶0 1
normCapacity
¶¶2 >
)
¶¶> ?
,
¶¶? @
buf
¶¶A D
,
¶¶D E
reqCapacity
¶¶F Q
)
¶¶Q R
;
¶¶R S
internal
»» 
bool
»» 
AllocateSmall
»» #
(
»»# $
	PoolArena
»»$ -
<
»»- .
T
»». /
>
»»/ 0
area
»»1 5
,
»»5 6
PooledByteBuffer
»»7 G
<
»»G H
T
»»H I
>
»»I J
buf
»»K N
,
»»N O
int
»»P S
reqCapacity
»»T _
,
»»_ `
int
»»a d
normCapacity
»»e q
)
»»q r
=>
»»s u
this
¼¼ 
.
¼¼ 
Allocate
¼¼ 
(
¼¼ 
this
¼¼ 
.
¼¼ 
CacheForSmall
¼¼ ,
(
¼¼, -
area
¼¼- 1
,
¼¼1 2
normCapacity
¼¼3 ?
)
¼¼? @
,
¼¼@ A
buf
¼¼B E
,
¼¼E F
reqCapacity
¼¼G R
)
¼¼R S
;
¼¼S T
internal
ÁÁ 
bool
ÁÁ 
AllocateNormal
ÁÁ $
(
ÁÁ$ %
	PoolArena
ÁÁ% .
<
ÁÁ. /
T
ÁÁ/ 0
>
ÁÁ0 1
area
ÁÁ2 6
,
ÁÁ6 7
PooledByteBuffer
ÁÁ8 H
<
ÁÁH I
T
ÁÁI J
>
ÁÁJ K
buf
ÁÁL O
,
ÁÁO P
int
ÁÁQ T
reqCapacity
ÁÁU `
,
ÁÁ` a
int
ÁÁb e
normCapacity
ÁÁf r
)
ÁÁr s
=>
ÁÁt v
this
ÂÂ 
.
ÂÂ 
Allocate
ÂÂ 
(
ÂÂ 
this
ÂÂ 
.
ÂÂ 
CacheForNormal
ÂÂ -
(
ÂÂ- .
area
ÂÂ. 2
,
ÂÂ2 3
normCapacity
ÂÂ4 @
)
ÂÂ@ A
,
ÂÂA B
buf
ÂÂC F
,
ÂÂF G
reqCapacity
ÂÂH S
)
ÂÂS T
;
ÂÂT U
bool
ÄÄ 
Allocate
ÄÄ 
(
ÄÄ 
MemoryRegionCache
ÄÄ '
cache
ÄÄ( -
,
ÄÄ- .
PooledByteBuffer
ÄÄ/ ?
<
ÄÄ? @
T
ÄÄ@ A
>
ÄÄA B
buf
ÄÄC F
,
ÄÄF G
int
ÄÄH K
reqCapacity
ÄÄL W
)
ÄÄW X
{
ÅÅ 	
if
ÆÆ 
(
ÆÆ 
cache
ÆÆ 
==
ÆÆ 
null
ÆÆ 
)
ÆÆ 
{
ÇÇ 
return
ÉÉ 
false
ÉÉ 
;
ÉÉ 
}
ÊÊ 
bool
ËË 
	allocated
ËË 
=
ËË 
cache
ËË "
.
ËË" #
Allocate
ËË# +
(
ËË+ ,
buf
ËË, /
,
ËË/ 0
reqCapacity
ËË1 <
)
ËË< =
;
ËË= >
if
ÌÌ 
(
ÌÌ 
++
ÌÌ 
this
ÌÌ 
.
ÌÌ 
allocations
ÌÌ "
>=
ÌÌ# %
this
ÌÌ& *
.
ÌÌ* +*
freeSweepAllocationThreshold
ÌÌ+ G
)
ÌÌG H
{
ÍÍ 
this
ÎÎ 
.
ÎÎ 
allocations
ÎÎ  
=
ÎÎ! "
$num
ÎÎ# $
;
ÎÎ$ %
this
ÏÏ 
.
ÏÏ 
Trim
ÏÏ 
(
ÏÏ 
)
ÏÏ 
;
ÏÏ 
}
ĞĞ 
return
ÑÑ 
	allocated
ÑÑ 
;
ÑÑ 
}
ÒÒ 	
internal
ØØ 
bool
ØØ 
Add
ØØ 
(
ØØ 
	PoolArena
ØØ #
<
ØØ# $
T
ØØ$ %
>
ØØ% &
area
ØØ' +
,
ØØ+ ,
	PoolChunk
ØØ- 6
<
ØØ6 7
T
ØØ7 8
>
ØØ8 9
chunk
ØØ: ?
,
ØØ? @
long
ØØA E
handle
ØØF L
,
ØØL M
int
ØØN Q
normCapacity
ØØR ^
,
ØØ^ _
	SizeClass
ØØ` i
	sizeClass
ØØj s
)
ØØs t
{
ÙÙ 	
MemoryRegionCache
ÚÚ 
cache
ÚÚ #
=
ÚÚ$ %
this
ÚÚ& *
.
ÚÚ* +
Cache
ÚÚ+ 0
(
ÚÚ0 1
area
ÚÚ1 5
,
ÚÚ5 6
normCapacity
ÚÚ7 C
,
ÚÚC D
	sizeClass
ÚÚE N
)
ÚÚN O
;
ÚÚO P
if
ÛÛ 
(
ÛÛ 
cache
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
{
ÜÜ 
return
İİ 
false
İİ 
;
İİ 
}
ŞŞ 
return
ßß 
cache
ßß 
.
ßß 
Add
ßß 
(
ßß 
chunk
ßß "
,
ßß" #
handle
ßß$ *
)
ßß* +
;
ßß+ ,
}
àà 	
MemoryRegionCache
ââ 
Cache
ââ 
(
ââ  
	PoolArena
ââ  )
<
ââ) *
T
ââ* +
>
ââ+ ,
area
ââ- 1
,
ââ1 2
int
ââ3 6
normCapacity
ââ7 C
,
ââC D
	SizeClass
ââE N
	sizeClass
ââO X
)
ââX Y
{
ãã 	
switch
ää 
(
ää 
	sizeClass
ää 
)
ää 
{
åå 
case
ææ 
	SizeClass
ææ 
.
ææ 
Normal
ææ %
:
ææ% &
return
çç 
this
çç 
.
çç  
CacheForNormal
çç  .
(
çç. /
area
çç/ 3
,
çç3 4
normCapacity
çç5 A
)
ççA B
;
ççB C
case
èè 
	SizeClass
èè 
.
èè 
Small
èè $
:
èè$ %
return
éé 
this
éé 
.
éé  
CacheForSmall
éé  -
(
éé- .
area
éé. 2
,
éé2 3
normCapacity
éé4 @
)
éé@ A
;
ééA B
case
êê 
	SizeClass
êê 
.
êê 
Tiny
êê #
:
êê# $
return
ëë 
this
ëë 
.
ëë  
CacheForTiny
ëë  ,
(
ëë, -
area
ëë- 1
,
ëë1 2
normCapacity
ëë3 ?
)
ëë? @
;
ëë@ A
default
ìì 
:
ìì 
throw
íí 
new
íí )
ArgumentOutOfRangeException
íí 9
(
íí9 :
)
íí: ;
;
íí; <
}
îî 
}
ïï 	
internal
ôô 
void
ôô 
Free
ôô 
(
ôô 
)
ôô 
{
õõ 	
if
öö 
(
öö 
this
öö 
.
öö 
freeTask
öö 
!=
öö  
null
öö! %
)
öö% &
{
÷÷ 
Debug
øø 
.
øø 
Assert
øø 
(
øø 
this
øø !
.
øø! "
deathWatchThread
øø" 2
!=
øø3 5
null
øø6 :
)
øø: ;
;
øø; < 
ThreadDeathWatcher
ùù "
.
ùù" #
Unwatch
ùù# *
(
ùù* +
this
ùù+ /
.
ùù/ 0
deathWatchThread
ùù0 @
,
ùù@ A
this
ùùB F
.
ùùF G
freeTask
ùùG O
)
ùùO P
;
ùùP Q
}
úú 
this
üü 
.
üü 
Free0
üü 
(
üü 
)
üü 
;
üü 
}
ıı 	
void
ÿÿ 
Free0
ÿÿ 
(
ÿÿ 
)
ÿÿ 
{
€€ 	
int
 
numFreed
 
=
 
Free
 
(
  
this
  $
.
$ %%
tinySubPageDirectCaches
% <
)
< =
+
> ?
Free
‚‚ 
(
‚‚ 
this
‚‚ 
.
‚‚ &
smallSubPageDirectCaches
‚‚ 2
)
‚‚2 3
+
‚‚4 5
Free
ƒƒ 
(
ƒƒ 
this
ƒƒ 
.
ƒƒ  
normalDirectCaches
ƒƒ ,
)
ƒƒ, -
+
ƒƒ. /
Free
„„ 
(
„„ 
this
„„ 
.
„„ #
tinySubPageHeapCaches
„„ /
)
„„/ 0
+
„„1 2
Free
…… 
(
…… 
this
…… 
.
…… $
smallSubPageHeapCaches
…… 0
)
……0 1
+
……2 3
Free
†† 
(
†† 
this
†† 
.
†† 
normalHeapCaches
†† *
)
††* +
;
††+ ,
if
ˆˆ 
(
ˆˆ 
numFreed
ˆˆ 
>
ˆˆ 
$num
ˆˆ 
&&
ˆˆ 
Logger
ˆˆ  &
.
ˆˆ& '
DebugEnabled
ˆˆ' 3
)
ˆˆ3 4
{
‰‰ 
Logger
ŠŠ 
.
ŠŠ 
Debug
ŠŠ 
(
ŠŠ 
$str
ŠŠ N
,
ŠŠN O
numFreed
ŠŠP X
,
ŠŠX Y
this
ŠŠZ ^
.
ŠŠ^ _
deathWatchThread
ŠŠ_ o
.
ŠŠo p
Name
ŠŠp t
)
ŠŠt u
;
ŠŠu v
}
‹‹ 
this
 
.
 
DirectArena
 
?
 
.
 &
DecrementNumThreadCaches
 6
(
6 7
)
7 8
;
8 9
this
 
.
 
	HeapArena
 
?
 
.
 &
DecrementNumThreadCaches
 4
(
4 5
)
5 6
;
6 7
}
 	
static
‘‘ 
int
‘‘ 
Free
‘‘ 
(
‘‘ 
MemoryRegionCache
‘‘ )
[
‘‘) *
]
‘‘* +
caches
‘‘, 2
)
‘‘2 3
{
’’ 	
if
““ 
(
““ 
caches
““ 
==
““ 
null
““ 
)
““ 
{
”” 
return
•• 
$num
•• 
;
•• 
}
–– 
int
˜˜ 
numFreed
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
foreach
™™ 
(
™™ 
MemoryRegionCache
™™ &
c
™™' (
in
™™) +
caches
™™, 2
)
™™2 3
{
šš 
numFreed
›› 
+=
›› 
Free
››  
(
››  !
c
››! "
)
››" #
;
››# $
}
œœ 
return
 
numFreed
 
;
 
}
 	
static
   
int
   
Free
   
(
   
MemoryRegionCache
   )
cache
  * /
)
  / 0
{
¡¡ 	
if
¢¢ 
(
¢¢ 
cache
¢¢ 
==
¢¢ 
null
¢¢ 
)
¢¢ 
{
££ 
return
¤¤ 
$num
¤¤ 
;
¤¤ 
}
¥¥ 
return
¦¦ 
cache
¦¦ 
.
¦¦ 
Free
¦¦ 
(
¦¦ 
)
¦¦ 
;
¦¦  
}
§§ 	
internal
©© 
void
©© 
Trim
©© 
(
©© 
)
©© 
{
ªª 	
Trim
«« 
(
«« 
this
«« 
.
«« %
tinySubPageDirectCaches
«« -
)
««- .
;
««. /
Trim
¬¬ 
(
¬¬ 
this
¬¬ 
.
¬¬ &
smallSubPageDirectCaches
¬¬ .
)
¬¬. /
;
¬¬/ 0
Trim
­­ 
(
­­ 
this
­­ 
.
­­  
normalDirectCaches
­­ (
)
­­( )
;
­­) *
Trim
®® 
(
®® 
this
®® 
.
®® #
tinySubPageHeapCaches
®® +
)
®®+ ,
;
®®, -
Trim
¯¯ 
(
¯¯ 
this
¯¯ 
.
¯¯ $
smallSubPageHeapCaches
¯¯ ,
)
¯¯, -
;
¯¯- .
Trim
°° 
(
°° 
this
°° 
.
°° 
normalHeapCaches
°° &
)
°°& '
;
°°' (
}
±± 	
static
³³ 
void
³³ 
Trim
³³ 
(
³³ 
MemoryRegionCache
³³ *
[
³³* +
]
³³+ ,
caches
³³- 3
)
³³3 4
{
´´ 	
if
µµ 
(
µµ 
caches
µµ 
==
µµ 
null
µµ 
)
µµ 
{
¶¶ 
return
·· 
;
·· 
}
¸¸ 
foreach
¹¹ 
(
¹¹ 
MemoryRegionCache
¹¹ &
c
¹¹' (
in
¹¹) +
caches
¹¹, 2
)
¹¹2 3
{
ºº 
Trim
»» 
(
»» 
c
»» 
)
»» 
;
»» 
}
¼¼ 
}
½½ 	
static
¿¿ 
void
¿¿ 
Trim
¿¿ 
(
¿¿ 
MemoryRegionCache
¿¿ *
cache
¿¿+ 0
)
¿¿0 1
=>
¿¿2 4
cache
¿¿5 :
?
¿¿: ;
.
¿¿; <
Trim
¿¿< @
(
¿¿@ A
)
¿¿A B
;
¿¿B C
MemoryRegionCache
ÁÁ 
CacheForTiny
ÁÁ &
(
ÁÁ& '
	PoolArena
ÁÁ' 0
<
ÁÁ0 1
T
ÁÁ1 2
>
ÁÁ2 3
area
ÁÁ4 8
,
ÁÁ8 9
int
ÁÁ: =
normCapacity
ÁÁ> J
)
ÁÁJ K
{
ÂÂ 	
int
ÃÃ 
idx
ÃÃ 
=
ÃÃ 
	PoolArena
ÃÃ 
<
ÃÃ  
T
ÃÃ  !
>
ÃÃ! "
.
ÃÃ" #
TinyIdx
ÃÃ# *
(
ÃÃ* +
normCapacity
ÃÃ+ 7
)
ÃÃ7 8
;
ÃÃ8 9
return
ÄÄ 
Cache
ÄÄ 
(
ÄÄ 
area
ÄÄ 
.
ÄÄ 
IsDirect
ÄÄ &
?
ÄÄ' (
this
ÄÄ) -
.
ÄÄ- .%
tinySubPageDirectCaches
ÄÄ. E
:
ÄÄF G
this
ÄÄH L
.
ÄÄL M#
tinySubPageHeapCaches
ÄÄM b
,
ÄÄb c
idx
ÄÄd g
)
ÄÄg h
;
ÄÄh i
}
ÅÅ 	
MemoryRegionCache
ÇÇ 
CacheForSmall
ÇÇ '
(
ÇÇ' (
	PoolArena
ÇÇ( 1
<
ÇÇ1 2
T
ÇÇ2 3
>
ÇÇ3 4
area
ÇÇ5 9
,
ÇÇ9 :
int
ÇÇ; >
normCapacity
ÇÇ? K
)
ÇÇK L
{
ÈÈ 	
int
ÉÉ 
idx
ÉÉ 
=
ÉÉ 
	PoolArena
ÉÉ 
<
ÉÉ  
T
ÉÉ  !
>
ÉÉ! "
.
ÉÉ" #
SmallIdx
ÉÉ# +
(
ÉÉ+ ,
normCapacity
ÉÉ, 8
)
ÉÉ8 9
;
ÉÉ9 :
return
ÊÊ 
Cache
ÊÊ 
(
ÊÊ 
area
ÊÊ 
.
ÊÊ 
IsDirect
ÊÊ &
?
ÊÊ' (
this
ÊÊ) -
.
ÊÊ- .&
smallSubPageDirectCaches
ÊÊ. F
:
ÊÊG H
this
ÊÊI M
.
ÊÊM N$
smallSubPageHeapCaches
ÊÊN d
,
ÊÊd e
idx
ÊÊf i
)
ÊÊi j
;
ÊÊj k
}
ËË 	
MemoryRegionCache
ÍÍ 
CacheForNormal
ÍÍ (
(
ÍÍ( )
	PoolArena
ÍÍ) 2
<
ÍÍ2 3
T
ÍÍ3 4
>
ÍÍ4 5
area
ÍÍ6 :
,
ÍÍ: ;
int
ÍÍ< ?
normCapacity
ÍÍ@ L
)
ÍÍL M
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
area
ÏÏ 
.
ÏÏ 
IsDirect
ÏÏ 
)
ÏÏ 
{
ĞĞ 
int
ÑÑ 
idx
ÑÑ 
=
ÑÑ 
Log2
ÑÑ 
(
ÑÑ 
normCapacity
ÑÑ +
>>
ÑÑ, .
this
ÑÑ/ 3
.
ÑÑ3 4#
numShiftsNormalDirect
ÑÑ4 I
)
ÑÑI J
;
ÑÑJ K
return
ÒÒ 
Cache
ÒÒ 
(
ÒÒ 
this
ÒÒ !
.
ÒÒ! " 
normalDirectCaches
ÒÒ" 4
,
ÒÒ4 5
idx
ÒÒ6 9
)
ÒÒ9 :
;
ÒÒ: ;
}
ÓÓ 
int
ÔÔ 
idx1
ÔÔ 
=
ÔÔ 
Log2
ÔÔ 
(
ÔÔ 
normCapacity
ÔÔ (
>>
ÔÔ) +
this
ÔÔ, 0
.
ÔÔ0 1!
numShiftsNormalHeap
ÔÔ1 D
)
ÔÔD E
;
ÔÔE F
return
ÕÕ 
Cache
ÕÕ 
(
ÕÕ 
this
ÕÕ 
.
ÕÕ 
normalHeapCaches
ÕÕ .
,
ÕÕ. /
idx1
ÕÕ0 4
)
ÕÕ4 5
;
ÕÕ5 6
}
ÖÖ 	
static
ØØ 
MemoryRegionCache
ØØ  
Cache
ØØ! &
(
ØØ& '
MemoryRegionCache
ØØ' 8
[
ØØ8 9
]
ØØ9 :
cache
ØØ; @
,
ØØ@ A
int
ØØB E
idx
ØØF I
)
ØØI J
{
ÙÙ 	
if
ÚÚ 
(
ÚÚ 
cache
ÚÚ 
==
ÚÚ 
null
ÚÚ 
||
ÚÚ  
idx
ÚÚ! $
>
ÚÚ% &
cache
ÚÚ' ,
.
ÚÚ, -
Length
ÚÚ- 3
-
ÚÚ4 5
$num
ÚÚ6 7
)
ÚÚ7 8
{
ÛÛ 
return
ÜÜ 
null
ÜÜ 
;
ÜÜ 
}
İİ 
return
ŞŞ 
cache
ŞŞ 
[
ŞŞ 
idx
ŞŞ 
]
ŞŞ 
;
ŞŞ 
}
ßß 	
sealed
ää 
class
ää &
SubPageMemoryRegionCache
ää -
:
ää. /
MemoryRegionCache
ää0 A
{
åå 	
internal
ææ &
SubPageMemoryRegionCache
ææ -
(
ææ- .
int
ææ. 1
size
ææ2 6
,
ææ6 7
	SizeClass
ææ8 A
	sizeClass
ææB K
)
ææK L
:
çç 
base
çç 
(
çç 
size
çç 
,
çç 
	sizeClass
çç &
)
çç& '
{
èè 
}
éé 
	protected
ëë 
override
ëë 
void
ëë #
InitBuf
ëë$ +
(
ëë+ ,
	PoolChunk
ìì 
<
ìì 
T
ìì 
>
ìì 
chunk
ìì "
,
ìì" #
long
ìì$ (
handle
ìì) /
,
ìì/ 0
PooledByteBuffer
ìì1 A
<
ììA B
T
ììB C
>
ììC D
buf
ììE H
,
ììH I
int
ììJ M
reqCapacity
ììN Y
)
ììY Z
=>
ìì[ ]
chunk
íí 
.
íí  
InitBufWithSubpage
íí (
(
íí( )
buf
íí) ,
,
íí, -
handle
íí. 4
,
íí4 5
reqCapacity
íí6 A
)
ííA B
;
ííB C
}
îî 	
sealed
óó 
class
óó %
NormalMemoryRegionCache
óó ,
:
óó- .
MemoryRegionCache
óó/ @
{
ôô 	
internal
õõ %
NormalMemoryRegionCache
õõ ,
(
õõ, -
int
õõ- 0
size
õõ1 5
)
õõ5 6
:
öö 
base
öö 
(
öö 
size
öö 
,
öö 
	SizeClass
öö &
.
öö& '
Normal
öö' -
)
öö- .
{
÷÷ 
}
øø 
	protected
úú 
override
úú 
void
úú #
InitBuf
úú$ +
(
úú+ ,
	PoolChunk
ûû 
<
ûû 
T
ûû 
>
ûû 
chunk
ûû "
,
ûû" #
long
ûû$ (
handle
ûû) /
,
ûû/ 0
PooledByteBuffer
ûû1 A
<
ûûA B
T
ûûB C
>
ûûC D
buf
ûûE H
,
ûûH I
int
ûûJ M
reqCapacity
ûûN Y
)
ûûY Z
=>
ûû[ ]
chunk
üü 
.
üü 
InitBuf
üü 
(
üü 
buf
üü !
,
üü! "
handle
üü# )
,
üü) *
reqCapacity
üü+ 6
)
üü6 7
;
üü7 8
}
ıı 	
abstract
ÿÿ 
class
ÿÿ 
MemoryRegionCache
ÿÿ (
{
€€ 	
readonly
 
int
 
size
 
;
 
readonly
‚‚ 
IQueue
‚‚ 
<
‚‚ 
Entry
‚‚ !
>
‚‚! "
queue
‚‚# (
;
‚‚( )
readonly
ƒƒ 
	SizeClass
ƒƒ 
	sizeClass
ƒƒ (
;
ƒƒ( )
int
„„ 
allocations
„„ 
;
„„ 
	protected
†† 
MemoryRegionCache
†† '
(
††' (
int
††( +
size
††, 0
,
††0 1
	SizeClass
††2 ;
	sizeClass
††< E
)
††E F
{
‡‡ 
this
ˆˆ 
.
ˆˆ 
size
ˆˆ 
=
ˆˆ 
MathUtil
ˆˆ $
.
ˆˆ$ %,
SafeFindNextPositivePowerOfTwo
ˆˆ% C
(
ˆˆC D
size
ˆˆD H
)
ˆˆH I
;
ˆˆI J
this
‰‰ 
.
‰‰ 
queue
‰‰ 
=
‰‰ 
PlatformDependent
‰‰ .
.
‰‰. /
NewFixedMpscQueue
‰‰/ @
<
‰‰@ A
Entry
‰‰A F
>
‰‰F G
(
‰‰G H
this
‰‰H L
.
‰‰L M
size
‰‰M Q
)
‰‰Q R
;
‰‰R S
this
ŠŠ 
.
ŠŠ 
	sizeClass
ŠŠ 
=
ŠŠ  
	sizeClass
ŠŠ! *
;
ŠŠ* +
}
‹‹ 
	protected
 
abstract
 
void
 #
InitBuf
$ +
(
+ ,
	PoolChunk
, 5
<
5 6
T
6 7
>
7 8
chunk
9 >
,
> ?
long
@ D
handle
E K
,
K L
PooledByteBuffer
‘‘  
<
‘‘  !
T
‘‘! "
>
‘‘" #
buf
‘‘$ '
,
‘‘' (
int
‘‘) ,
reqCapacity
‘‘- 8
)
‘‘8 9
;
‘‘9 :
public
–– 
bool
–– 
Add
–– 
(
–– 
	PoolChunk
–– %
<
––% &
T
––& '
>
––' (
chunk
––) .
,
––. /
long
––0 4
handle
––5 ;
)
––; <
{
—— 
Entry
˜˜ 
entry
˜˜ 
=
˜˜ 
NewEntry
˜˜ &
(
˜˜& '
chunk
˜˜' ,
,
˜˜, -
handle
˜˜. 4
)
˜˜4 5
;
˜˜5 6
bool
™™ 
queued
™™ 
=
™™ 
this
™™ "
.
™™" #
queue
™™# (
.
™™( )

TryEnqueue
™™) 3
(
™™3 4
entry
™™4 9
)
™™9 :
;
™™: ;
if
šš 
(
šš 
!
šš 
queued
šš 
)
šš 
{
›› 
entry
 
.
 
Recycle
 !
(
! "
)
" #
;
# $
}
 
return
   
queued
   
;
   
}
¡¡ 
public
¦¦ 
bool
¦¦ 
Allocate
¦¦  
(
¦¦  !
PooledByteBuffer
¦¦! 1
<
¦¦1 2
T
¦¦2 3
>
¦¦3 4
buf
¦¦5 8
,
¦¦8 9
int
¦¦: =
reqCapacity
¦¦> I
)
¦¦I J
{
§§ 
if
¨¨ 
(
¨¨ 
!
¨¨ 
this
¨¨ 
.
¨¨ 
queue
¨¨ 
.
¨¨  

TryDequeue
¨¨  *
(
¨¨* +
out
¨¨+ .
Entry
¨¨/ 4
entry
¨¨5 :
)
¨¨: ;
)
¨¨; <
{
©© 
return
ªª 
false
ªª  
;
ªª  !
}
«« 
this
¬¬ 
.
¬¬ 
InitBuf
¬¬ 
(
¬¬ 
entry
¬¬ "
.
¬¬" #
Chunk
¬¬# (
,
¬¬( )
entry
¬¬* /
.
¬¬/ 0
Handle
¬¬0 6
,
¬¬6 7
buf
¬¬8 ;
,
¬¬; <
reqCapacity
¬¬= H
)
¬¬H I
;
¬¬I J
entry
­­ 
.
­­ 
Recycle
­­ 
(
­­ 
)
­­ 
;
­­  
++
°° 
this
°° 
.
°° 
allocations
°° "
;
°°" #
return
±± 
true
±± 
;
±± 
}
²² 
public
·· 
int
·· 
Free
·· 
(
·· 
)
·· 
=>
··  
this
··! %
.
··% &
Free
··& *
(
··* +
int
··+ .
.
··. /
MaxValue
··/ 7
)
··7 8
;
··8 9
int
¹¹ 
Free
¹¹ 
(
¹¹ 
int
¹¹ 
max
¹¹ 
)
¹¹ 
{
ºº 
int
»» 
numFreed
»» 
=
»» 
$num
»»  
;
»»  !
for
¼¼ 
(
¼¼ 
;
¼¼ 
numFreed
¼¼ 
<
¼¼  !
max
¼¼" %
;
¼¼% &
numFreed
¼¼' /
++
¼¼/ 1
)
¼¼1 2
{
½½ 
if
¾¾ 
(
¾¾ 
this
¾¾ 
.
¾¾ 
queue
¾¾ "
.
¾¾" #

TryDequeue
¾¾# -
(
¾¾- .
out
¾¾. 1
Entry
¾¾2 7
entry
¾¾8 =
)
¾¾= >
)
¾¾> ?
{
¿¿ 
this
ÀÀ 
.
ÀÀ 
	FreeEntry
ÀÀ &
(
ÀÀ& '
entry
ÀÀ' ,
)
ÀÀ, -
;
ÀÀ- .
}
ÁÁ 
else
ÂÂ 
{
ÃÃ 
return
ÅÅ 
numFreed
ÅÅ '
;
ÅÅ' (
}
ÆÆ 
}
ÇÇ 
return
ÈÈ 
numFreed
ÈÈ 
;
ÈÈ  
}
ÉÉ 
public
ÎÎ 
void
ÎÎ 
Trim
ÎÎ 
(
ÎÎ 
)
ÎÎ 
{
ÏÏ 
int
ĞĞ 
toFree
ĞĞ 
=
ĞĞ 
this
ĞĞ !
.
ĞĞ! "
size
ĞĞ" &
-
ĞĞ' (
this
ĞĞ) -
.
ĞĞ- .
allocations
ĞĞ. 9
;
ĞĞ9 :
this
ÑÑ 
.
ÑÑ 
allocations
ÑÑ  
=
ÑÑ! "
$num
ÑÑ# $
;
ÑÑ$ %
if
ÔÔ 
(
ÔÔ 
toFree
ÔÔ 
>
ÔÔ 
$num
ÔÔ 
)
ÔÔ 
{
ÕÕ 
this
ÖÖ 
.
ÖÖ 
Free
ÖÖ 
(
ÖÖ 
toFree
ÖÖ $
)
ÖÖ$ %
;
ÖÖ% &
}
×× 
}
ØØ 
void
ÚÚ 
	FreeEntry
ÚÚ 
(
ÚÚ 
Entry
ÚÚ  
entry
ÚÚ! &
)
ÚÚ& '
{
ÛÛ 
	PoolChunk
ÜÜ 
<
ÜÜ 
T
ÜÜ 
>
ÜÜ 
chunk
ÜÜ "
=
ÜÜ# $
entry
ÜÜ% *
.
ÜÜ* +
Chunk
ÜÜ+ 0
;
ÜÜ0 1
long
İİ 
handle
İİ 
=
İİ 
entry
İİ #
.
İİ# $
Handle
İİ$ *
;
İİ* +
entry
àà 
.
àà 
Recycle
àà 
(
àà 
)
àà 
;
àà  
chunk
ââ 
.
ââ 
Arena
ââ 
.
ââ 
	FreeChunk
ââ %
(
ââ% &
chunk
ââ& +
,
ââ+ ,
handle
ââ- 3
,
ââ3 4
this
ââ5 9
.
ââ9 :
	sizeClass
ââ: C
)
ââC D
;
ââD E
}
ãã 
sealed
åå 
class
åå 
Entry
åå 
{
ææ 
readonly
çç 
ThreadLocalPool
çç (
.
çç( )
Handle
çç) /
recyclerHandle
çç0 >
;
çç> ?
public
èè 
	PoolChunk
èè  
<
èè  !
T
èè! "
>
èè" #
Chunk
èè$ )
;
èè) *
public
éé 
long
éé 
Handle
éé "
=
éé# $
-
éé% &
$num
éé& '
;
éé' (
public
ëë 
Entry
ëë 
(
ëë 
ThreadLocalPool
ëë ,
.
ëë, -
Handle
ëë- 3
recyclerHandle
ëë4 B
)
ëëB C
{
ìì 
this
íí 
.
íí 
recyclerHandle
íí '
=
íí( )
recyclerHandle
íí* 8
;
íí8 9
}
îî 
internal
ğğ 
void
ğğ 
Recycle
ğğ %
(
ğğ% &
)
ğğ& '
{
ññ 
this
òò 
.
òò 
Chunk
òò 
=
òò  
null
òò! %
;
òò% &
this
óó 
.
óó 
Handle
óó 
=
óó  !
-
óó" #
$num
óó# $
;
óó$ %
this
ôô 
.
ôô 
recyclerHandle
ôô '
.
ôô' (
Release
ôô( /
(
ôô/ 0
this
ôô0 4
)
ôô4 5
;
ôô5 6
}
õõ 
}
öö 
static
øø 
Entry
øø 
NewEntry
øø !
(
øø! "
	PoolChunk
øø" +
<
øø+ ,
T
øø, -
>
øø- .
chunk
øø/ 4
,
øø4 5
long
øø6 :
handle
øø; A
)
øøA B
{
ùù 
Entry
úú 
entry
úú 
=
úú 
Recycler
úú &
.
úú& '
Take
úú' +
(
úú+ ,
)
úú, -
;
úú- .
entry
ûû 
.
ûû 
Chunk
ûû 
=
ûû 
chunk
ûû #
;
ûû# $
entry
üü 
.
üü 
Handle
üü 
=
üü 
handle
üü %
;
üü% &
return
ıı 
entry
ıı 
;
ıı 
}
şş 
static
€€ 
readonly
€€ 
ThreadLocalPool
€€ +
<
€€+ ,
Entry
€€, 1
>
€€1 2
Recycler
€€3 ;
=
€€< =
new
€€> A
ThreadLocalPool
€€B Q
<
€€Q R
Entry
€€R W
>
€€W X
(
€€X Y
handle
€€Y _
=>
€€` b
new
€€c f
Entry
€€g l
(
€€l m
handle
€€m s
)
€€s t
)
€€t u
;
€€u v
}
 	
}
‚‚ 
}ƒƒ ³
jC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 
$
NeutralResourcesLanguage #
(# $
$str$ +
)+ ,
], -
[ 
assembly 	
:	 

AssemblyMetadata 
( 
$str )
,) *
$str+ 1
)1 2
]2 3“
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Properties\Friends.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str	 ‚
)
‚ ƒ
]
ƒ „
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str	 ÿ
)
ÿ €
]
€ «3
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ReadOnlyByteBufferStream.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class $
ReadOnlyByteBufferStream 0
:1 2
Stream3 9
{ 
readonly 
IByteBuffer 
buffer #
;# $
bool %
releaseReferenceOnClosure &
;& '
public $
ReadOnlyByteBufferStream '
(' (
IByteBuffer( 3
buffer4 :
,: ;
bool< @%
releaseReferenceOnClosureA Z
)Z [
{ 	
Contract 
. 
Requires 
( 
buffer $
!=% '
null( ,
), -
;- .
this 
. 
buffer 
= 
buffer  
;  !
this 
. %
releaseReferenceOnClosure *
=+ ,%
releaseReferenceOnClosure- F
;F G
} 	
public 
override 
bool 
CanRead $
=>% '
true( ,
;, -
public 
override 
bool 
CanSeek $
=>% '
true( ,
;, -
public 
override 
bool 
CanWrite %
=>& (
false) .
;. /
public 
override 
long 
Length #
=>$ &
this' +
.+ ,
buffer, 2
.2 3
WriterIndex3 >
;> ?
public   
override   
long   
Position   %
{!! 	
get"" 
=>"" 
this"" 
."" 
buffer"" 
."" 
ReaderIndex"" *
;""* +
set## 
=>## 
this## 
.## 
buffer## 
.## 
SetReaderIndex## -
(##- .
(##. /
int##/ 2
)##2 3
value##3 8
)##8 9
;##9 :
}$$ 	
public&& 
override&& 
int&& 
Read&&  
(&&  !
byte&&! %
[&&% &
]&&& '
output&&( .
,&&. /
int&&0 3
offset&&4 :
,&&: ;
int&&< ?
count&&@ E
)&&E F
{'' 	
if(( 
((( 
offset(( 
+(( 
count(( 
>((  
output((! '
.((' (
Length((( .
)((. /
{)) 
throw** 
new** 
ArgumentException** +
(**+ ,
$"**, .
$str**. 9
{**9 :
nameof**: @
(**@ A
offset**A G
)**G H
}**H I
$str**I N
{**N O
nameof**O U
(**U V
count**V [
)**[ \
}**\ ]
$str**] q
{**q r
nameof**r x
(**x y
output**y 
)	** €
}
**€ 
$str
** ˆ
"
**ˆ ‰
)
**‰ Š
;
**Š ‹
}++ 
int-- 
read-- 
=-- 
Math-- 
.-- 
Min-- 
(--  
count--  %
,--% &
this--' +
.--+ ,
buffer--, 2
.--2 3
ReadableBytes--3 @
)--@ A
;--A B
this.. 
... 
buffer.. 
... 
	ReadBytes.. !
(..! "
output.." (
,..( )
offset..* 0
,..0 1
read..2 6
)..6 7
;..7 8
return// 
read// 
;// 
}00 	
public22 
override22 
void22 
Flush22 "
(22" #
)22# $
{33 	
}44 	
	protected66 
override66 
void66 
Dispose66  '
(66' (
bool66( ,
	disposing66- 6
)666 7
{77 	
if88 
(88 
this88 
.88 %
releaseReferenceOnClosure88 .
)88. /
{99 
this:: 
.:: %
releaseReferenceOnClosure:: .
=::/ 0
false::1 6
;::6 7
if;; 
(;; 
	disposing;; 
);; 
{<< 
this== 
.== 
buffer== 
.==  
Release==  '
(==' (
)==( )
;==) *
}>> 
else?? 
{@@ 
thisAA 
.AA 
bufferAA 
.AA  
SafeReleaseAA  +
(AA+ ,
)AA, -
;AA- .
}BB 
}CC 
}DD 	
publicFF 
overrideFF 
longFF 
SeekFF !
(FF! "
longFF" &
offsetFF' -
,FF- .

SeekOriginFF/ 9
originFF: @
)FF@ A
{GG 	
ifHH 
(HH 
originHH 
==HH 

SeekOriginHH $
.HH$ %
CurrentHH% ,
)HH, -
{II 
offsetJJ 
+=JJ 
thisJJ 
.JJ 
PositionJJ '
;JJ' (
}KK 
elseLL 
ifLL 
(LL 
originLL 
==LL 

SeekOriginLL )
.LL) *
EndLL* -
)LL- .
{MM 
offsetNN 
+=NN 
thisNN 
.NN 
LengthNN %
;NN% &
}OO 
thisQQ 
.QQ 
PositionQQ 
=QQ 
offsetQQ "
;QQ" #
returnRR 
thisRR 
.RR 
PositionRR  
;RR  !
}SS 	
publicUU 
overrideUU 
voidUU 
	SetLengthUU &
(UU& '
longUU' +
valueUU, 1
)UU1 2
{VV 	
throwWW 
newWW !
NotSupportedExceptionWW +
(WW+ ,
)WW, -
;WW- .
}XX 	
publicZZ 
overrideZZ 
voidZZ 
WriteZZ "
(ZZ" #
byteZZ# '
[ZZ' (
]ZZ( )
inputZZ* /
,ZZ/ 0
intZZ1 4
offsetZZ5 ;
,ZZ; <
intZZ= @
countZZA F
)ZZF G
{[[ 	
throw\\ 
new\\ !
NotSupportedException\\ +
(\\+ ,
)\\, -
;\\- .
}]] 	
}^^ 
}__ §K
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\SimpleLeakAwareByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class

 	%
SimpleLeakAwareByteBuffer


 #
:

$ %
WrappedByteBuffer

& 7
{ 
	protected 
readonly  
IResourceLeakTracker /
Leak0 4
;4 5
readonly 
IByteBuffer 
trackedByteBuf +
;+ ,
internal %
SimpleLeakAwareByteBuffer *
(* +
IByteBuffer+ 6
wrapped7 >
,> ?
IByteBuffer@ K
trackedByteBufL Z
,Z [ 
IResourceLeakTracker\ p
leakq u
)u v
: 
base 
( 
wrapped 
) 
{ 	
Contract 
. 
Requires 
( 
trackedByteBuf ,
!=- /
null0 4
)4 5
;5 6
Contract 
. 
Requires 
( 
leak "
!=# %
null& *
)* +
;+ ,
this 
. 
trackedByteBuf 
=  !
trackedByteBuf" 0
;0 1
this 
. 
Leak 
= 
leak 
; 
} 	
internal %
SimpleLeakAwareByteBuffer *
(* +
IByteBuffer+ 6
wrapped7 >
,> ? 
IResourceLeakTracker@ T
leakU Y
)Y Z
: 
this 
( 
wrapped 
, 
wrapped #
,# $
leak% )
)) *
{ 	
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
=>, .
this/ 3
.3 4(
NewSharedLeakAwareByteBuffer4 P
(P Q
baseQ U
.U V
SliceV [
([ \
)\ ]
)] ^
;^ _
public   
override   
IByteBuffer   #
RetainedSlice  $ 1
(  1 2
)  2 3
=>  4 6
this  7 ;
.  ; <
UnwrappedDerived  < L
(  L M
base  M Q
.  Q R
RetainedSlice  R _
(  _ `
)  ` a
)  a b
;  b c
public"" 
override"" 
IByteBuffer"" #
RetainedSlice""$ 1
(""1 2
int""2 5
index""6 ;
,""; <
int""= @
length""A G
)""G H
=>""I K
this""L P
.""P Q
UnwrappedDerived""Q a
(""a b
base""b f
.""f g
RetainedSlice""g t
(""t u
index""u z
,""z {
length	""| ‚
)
""‚ ƒ
)
""ƒ „
;
""„ …
public$$ 
override$$ 
IByteBuffer$$ #
RetainedDuplicate$$$ 5
($$5 6
)$$6 7
=>$$8 :
this$$; ?
.$$? @
UnwrappedDerived$$@ P
($$P Q
base$$Q U
.$$U V
RetainedDuplicate$$V g
($$g h
)$$h i
)$$i j
;$$j k
public&& 
override&& 
IByteBuffer&& #
ReadRetainedSlice&&$ 5
(&&5 6
int&&6 9
length&&: @
)&&@ A
=>&&B D
this&&E I
.&&I J
UnwrappedDerived&&J Z
(&&Z [
base&&[ _
.&&_ `
ReadRetainedSlice&&` q
(&&q r
length&&r x
)&&x y
)&&y z
;&&z {
public(( 
override(( 
IByteBuffer(( #
Slice(($ )
((() *
int((* -
index((. 3
,((3 4
int((5 8
length((9 ?
)((? @
=>((A C
this((D H
.((H I(
NewSharedLeakAwareByteBuffer((I e
(((e f
base((f j
.((j k
Slice((k p
(((p q
index((q v
,((v w
length((x ~
)((~ 
)	(( €
;
((€ 
public** 
override** 
IByteBuffer** #
	Duplicate**$ -
(**- .
)**. /
=>**0 2
this**3 7
.**7 8(
NewSharedLeakAwareByteBuffer**8 T
(**T U
base**U Y
.**Y Z
	Duplicate**Z c
(**c d
)**d e
)**e f
;**f g
public,, 
override,, 
IByteBuffer,, #
	ReadSlice,,$ -
(,,- .
int,,. 1
length,,2 8
),,8 9
=>,,: <
this,,= A
.,,A B(
NewSharedLeakAwareByteBuffer,,B ^
(,,^ _
base,,_ c
.,,c d
	ReadSlice,,d m
(,,m n
length,,n t
),,t u
),,u v
;,,v w
public.. 
override.. 
IReferenceCounted.. )
Touch..* /
(../ 0
)..0 1
=>..2 4
this..5 9
;..9 :
public00 
override00 
IReferenceCounted00 )
Touch00* /
(00/ 0
object000 6
hint007 ;
)00; <
=>00= ?
this00@ D
;00D E
public22 
override22 
bool22 
Release22 $
(22$ %
)22% &
{33 	
if44 
(44 
base44 
.44 
Release44 
(44 
)44 
)44 
{55 
this66 
.66 
	CloseLeak66 
(66 
)66  
;66  !
return77 
true77 
;77 
}88 
return:: 
false:: 
;:: 
};; 	
public== 
override== 
bool== 
Release== $
(==$ %
int==% (
	decrement==) 2
)==2 3
{>> 	
if?? 
(?? 
base?? 
.?? 
Release?? 
(?? 
	decrement?? &
)??& '
)??' (
{@@ 
thisAA 
.AA 
	CloseLeakAA 
(AA 
)AA  
;AA  !
returnBB 
trueBB 
;BB 
}CC 
returnDD 
falseDD 
;DD 
}EE 	
voidGG 
	CloseLeakGG 
(GG 
)GG 
{HH 	
boolKK 
closedKK 
=KK 
thisKK 
.KK 
LeakKK #
.KK# $
CloseKK$ )
(KK) *
thisKK* .
.KK. /
trackedByteBufKK/ =
)KK= >
;KK> ?
DebugLL 
.LL 
AssertLL 
(LL 
closedLL 
)LL  
;LL  !
}MM 	
IByteBufferOO 
UnwrappedDerivedOO $
(OO$ %
IByteBufferOO% 0
derivedOO1 8
)OO8 9
{PP 	
ifQQ 
(QQ 
derivedQQ 
isQQ +
AbstractPooledDerivedByteBufferQQ :
bufferQQ; A
)QQA B
{QQC D
bufferSS 
.SS 
ParentSS 
(SS 
thisSS "
)SS" #
;SS# $ 
IResourceLeakTrackerUU $
newLeakUU% ,
=UU- .
AbstractByteBufferUU/ A
.UUA B
LeakDetectorUUB N
.UUN O
TrackUUO T
(UUT U
bufferUUU [
)UU[ \
;UU\ ]
ifVV 
(VV 
newLeakVV 
==VV 
nullVV #
)VV# $
{WW 
returnYY 
derivedYY "
;YY" #
}ZZ 
return\\ 
this\\ 
.\\ "
NewLeakAwareByteBuffer\\ 2
(\\2 3
buffer\\3 9
,\\9 :
newLeak\\; B
)\\B C
;\\C D
}]] 
return__ 
this__ 
.__ (
NewSharedLeakAwareByteBuffer__ 4
(__4 5
derived__5 <
)__< =
;__= >
}`` 	%
SimpleLeakAwareByteBufferbb !(
NewSharedLeakAwareByteBufferbb" >
(bb> ?
IByteBufferbb? J
wrappedbbK R
)bbR S
=>bbT V
thisbbW [
.bb[ \"
NewLeakAwareByteBufferbb\ r
(bbr s
wrappedbbs z
,bbz {
this	bb| €
.
bb€ 
trackedByteBuf
bb 
,
bb 
this
bb‘ •
.
bb• –
Leak
bb– š
)
bbš ›
;
bb› œ%
SimpleLeakAwareByteBufferdd !"
NewLeakAwareByteBufferdd" 8
(dd8 9
IByteBufferdd9 D
wrappedddE L
,ddL M 
IResourceLeakTrackerddN b
leakTrackerddc n
)ddn o
=>ddp r
thisdds w
.ddw x#
NewLeakAwareByteBuffer	ddx 
(
dd 
wrapped
dd –
,
dd– —
wrapped
dd˜ Ÿ
,
ddŸ  
leakTracker
dd¡ ¬
)
dd¬ ­
;
dd­ ®
	protectedff 
virtualff %
SimpleLeakAwareByteBufferff 3"
NewLeakAwareByteBufferff4 J
(ffJ K
IByteBufferffK V
bufffW Z
,ffZ [
IByteBufferff\ g

trackedBufffh r
,ffr s!
IResourceLeakTracker	fft ˆ
leakTracker
ff‰ ”
)
ff” •
=>
ff– ˜
newgg %
SimpleLeakAwareByteBuffergg )
(gg) *
bufgg* -
,gg- .

trackedBufgg/ 9
,gg9 :
leakTrackergg; F
)ggF G
;ggG H
}hh 
}ii —8
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\SimpleLeakAwareCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class

 	.
"SimpleLeakAwareCompositeByteBuffer


 ,
:

- .&
WrappedCompositeByteBuffer

/ I
{ 
	protected 
readonly  
IResourceLeakTracker /
Leak0 4
;4 5
internal .
"SimpleLeakAwareCompositeByteBuffer 3
(3 4
CompositeByteBuffer4 G
wrappedH O
,O P 
IResourceLeakTrackerQ e
leakf j
)j k
:l m
basen r
(r s
wrappeds z
)z {
{ 	
Contract 
. 
Requires 
( 
leak "
!=# %
null& *
)* +
;+ ,
this 
. 
Leak 
= 
leak 
; 
} 	
public 
override 
bool 
Release $
($ %
)% &
{ 	
IByteBuffer 
	unwrapped !
=" #
this$ (
.( )
Unwrap) /
(/ 0
)0 1
;1 2
if 
( 
base 
. 
Release 
( 
) 
) 
{ 
this 
. 
	CloseLeak 
( 
	unwrapped (
)( )
;) *
return 
true 
; 
} 
return 
false 
; 
}   	
public"" 
override"" 
bool"" 
Release"" $
(""$ %
int""% (
	decrement"") 2
)""2 3
{## 	
IByteBuffer&& 
	unwrapped&& !
=&&" #
this&&$ (
.&&( )
Unwrap&&) /
(&&/ 0
)&&0 1
;&&1 2
if'' 
('' 
base'' 
.'' 
Release'' 
('' 
	decrement'' &
)''& '
)''' (
{(( 
this)) 
.)) 
	CloseLeak)) 
()) 
	unwrapped)) (
)))( )
;))) *
return** 
true** 
;** 
}++ 
return-- 
false-- 
;-- 
}.. 	
void00 
	CloseLeak00 
(00 
IByteBuffer00 "
trackedByteBuf00# 1
)001 2
{11 	
bool44 
closed44 
=44 
this44 
.44 
Leak44 #
.44# $
Close44$ )
(44) *
trackedByteBuf44* 8
)448 9
;449 :
Debug55 
.55 
Assert55 
(55 
closed55 
)55  
;55  !
}66 	
public88 
override88 
IByteBuffer88 #
Slice88$ )
(88) *
)88* +
=>88, .
this88/ 3
.883 4"
NewLeakAwareByteBuffer884 J
(88J K
base88K O
.88O P
Slice88P U
(88U V
)88V W
)88W X
;88X Y
public:: 
override:: 
IByteBuffer:: #
Slice::$ )
(::) *
int::* -
index::. 3
,::3 4
int::5 8
length::9 ?
)::? @
=>::A C
this::D H
.::H I"
NewLeakAwareByteBuffer::I _
(::_ `
base::` d
.::d e
Slice::e j
(::j k
index::k p
,::p q
length::r x
)::x y
)::y z
;::z {
public<< 
override<< 
IByteBuffer<< #
	Duplicate<<$ -
(<<- .
)<<. /
=><<0 2
this<<3 7
.<<7 8"
NewLeakAwareByteBuffer<<8 N
(<<N O
base<<O S
.<<S T
	Duplicate<<T ]
(<<] ^
)<<^ _
)<<_ `
;<<` a
public>> 
override>> 
IByteBuffer>> #
	ReadSlice>>$ -
(>>- .
int>>. 1
length>>2 8
)>>8 9
=>>>: <
this>>= A
.>>A B"
NewLeakAwareByteBuffer>>B X
(>>X Y
base>>Y ]
.>>] ^
	ReadSlice>>^ g
(>>g h
length>>h n
)>>n o
)>>o p
;>>p q
public@@ 
override@@ 
IByteBuffer@@ #
RetainedSlice@@$ 1
(@@1 2
)@@2 3
=>@@4 6
this@@7 ;
.@@; <"
NewLeakAwareByteBuffer@@< R
(@@R S
base@@S W
.@@W X
RetainedSlice@@X e
(@@e f
)@@f g
)@@g h
;@@h i
publicBB 
overrideBB 
IByteBufferBB #
RetainedSliceBB$ 1
(BB1 2
intBB2 5
indexBB6 ;
,BB; <
intBB= @
lengthBBA G
)BBG H
=>BBI K
thisBBL P
.BBP Q"
NewLeakAwareByteBufferBBQ g
(BBg h
baseBBh l
.BBl m
RetainedSliceBBm z
(BBz {
index	BB{ €
,
BB€ 
length
BB‚ ˆ
)
BBˆ ‰
)
BB‰ Š
;
BBŠ ‹
publicDD 
overrideDD 
IByteBufferDD #
RetainedDuplicateDD$ 5
(DD5 6
)DD6 7
=>DD8 :
thisDD; ?
.DD? @"
NewLeakAwareByteBufferDD@ V
(DDV W
baseDDW [
.DD[ \
RetainedDuplicateDD\ m
(DDm n
)DDn o
)DDo p
;DDp q
publicFF 
overrideFF 
IByteBufferFF #
ReadRetainedSliceFF$ 5
(FF5 6
intFF6 9
lengthFF: @
)FF@ A
=>FFB D
thisFFE I
.FFI J"
NewLeakAwareByteBufferFFJ `
(FF` a
baseFFa e
.FFe f
ReadRetainedSliceFFf w
(FFw x
lengthFFx ~
)FF~ 
)	FF €
;
FF€ %
SimpleLeakAwareByteBufferHH !"
NewLeakAwareByteBufferHH" 8
(HH8 9
IByteBufferHH9 D
wrappedHHE L
)HHL M
=>HHN P
thisHHQ U
.HHU V"
NewLeakAwareByteBufferHHV l
(HHl m
wrappedHHm t
,HHt u
thisHHv z
.HHz {
Unwrap	HH{ 
(
HH ‚
)
HH‚ ƒ
,
HHƒ „
this
HH… ‰
.
HH‰ Š
Leak
HHŠ 
)
HH 
;
HH 
	protectedJJ 
virtualJJ %
SimpleLeakAwareByteBufferJJ 3"
NewLeakAwareByteBufferJJ4 J
(JJJ K
IByteBufferJJK V
wrappedJJW ^
,JJ^ _
IByteBufferJJ` k
trackedByteBufJJl z
,JJz {!
IResourceLeakTracker	JJ| 
leakTracker
JJ‘ œ
)
JJœ 
=>
JJ  
newKK %
SimpleLeakAwareByteBufferKK )
(KK) *
wrappedKK* 1
,KK1 2
trackedByteBufKK3 A
,KKA B
leakTrackerKKC N
)KKN O
;KKO P
}LL 
}MM Æ·
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ThrowHelper.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

class 
ThrowHelper 
{ 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &

NoInlining& 0
)0 1
]1 2
internal 
static 
void /
#ThrowIndexOutOfRangeException_Index @
(@ A
intA D
indexE J
,J K
intL O
lengthP V
,V W
intX [
capacity\ d
)d e
{ 	
throw '
GetIndexOutOfRangeException -
(- .
). /
;/ 0$
IndexOutOfRangeException $'
GetIndexOutOfRangeException% @
(@ A
)A B
{ 
return 
new $
IndexOutOfRangeException 3
(3 4
string4 :
.: ;
Format; A
(A B
$strB u
,u v
indexw |
,| }
length	~ „
,
„ …
capacity
† 
)
 
)
 
;
 ‘
} 
} 	
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &

NoInlining& 0
)0 1
]1 2
internal 
static 
void 2
&ThrowIndexOutOfRangeException_SrcIndex C
(C D
intD G
srcIndexH P
)P Q
{ 	
throw '
GetIndexOutOfRangeException -
(- .
). /
;/ 0$
IndexOutOfRangeException $'
GetIndexOutOfRangeException% @
(@ A
)A B
{   
return!! 
new!! $
IndexOutOfRangeException!! 3
(!!3 4
string!!4 :
.!!: ;
Format!!; A
(!!A B
$str!!B Q
,!!Q R
srcIndex!!S [
)!![ \
)!!\ ]
;!!] ^
}"" 
}## 	
[%% 	

MethodImpl%%	 
(%% 
MethodImplOptions%% %
.%%% &

NoInlining%%& 0
)%%0 1
]%%1 2
internal&& 
static&& 
void&& 2
&ThrowIndexOutOfRangeException_SrcIndex&& C
(&&C D
int&&D G
srcIndex&&H P
,&&P Q
int&&R U
length&&V \
,&&\ ]
int&&^ a
srcCapacity&&b m
)&&m n
{'' 	
throw(( '
GetIndexOutOfRangeException(( -
(((- .
)((. /
;((/ 0$
IndexOutOfRangeException** $'
GetIndexOutOfRangeException**% @
(**@ A
)**A B
{++ 
return,, 
new,, $
IndexOutOfRangeException,, 3
(,,3 4
string,,4 :
.,,: ;
Format,,; A
(,,A B
$str,,B x
,,,x y
srcIndex	,,z ‚
,
,,‚ ƒ
length
,,„ Š
,
,,Š ‹
srcCapacity
,,Œ —
)
,,— ˜
)
,,˜ ™
;
,,™ š
}-- 
}.. 	
[00 	

MethodImpl00	 
(00 
MethodImplOptions00 %
.00% &

NoInlining00& 0
)000 1
]001 2
internal11 
static11 
void11 2
&ThrowIndexOutOfRangeException_DstIndex11 C
(11C D
int11D G
dstIndex11H P
)11P Q
{22 	
throw33 '
GetIndexOutOfRangeException33 -
(33- .
)33. /
;33/ 0$
IndexOutOfRangeException55 $'
GetIndexOutOfRangeException55% @
(55@ A
)55A B
{66 
return77 
new77 $
IndexOutOfRangeException77 3
(773 4
string774 :
.77: ;
Format77; A
(77A B
$str77B Q
,77Q R
dstIndex77S [
)77[ \
)77\ ]
;77] ^
}88 
}99 	
[;; 	

MethodImpl;;	 
(;; 
MethodImplOptions;; %
.;;% &

NoInlining;;& 0
);;0 1
];;1 2
internal<< 
static<< 
void<< 2
&ThrowIndexOutOfRangeException_DstIndex<< C
(<<C D
int<<D G
dstIndex<<H P
,<<P Q
int<<R U
length<<V \
,<<\ ]
int<<_ b
dstCapacity<<c n
)<<n o
{== 	
throw>> '
GetIndexOutOfRangeException>> -
(>>- .
)>>. /
;>>/ 0$
IndexOutOfRangeException@@ $'
GetIndexOutOfRangeException@@% @
(@@@ A
)@@A B
{AA 
returnBB 
newBB $
IndexOutOfRangeExceptionBB 3
(BB3 4
stringBB4 :
.BB: ;
FormatBB; A
(BBA B
$strBBB x
,BBx y
dstIndex	BBz ‚
,
BB‚ ƒ
length
BB„ Š
,
BBŠ ‹
dstCapacity
BBŒ —
)
BB— ˜
)
BB˜ ™
;
BB™ š
}CC 
}DD 	
[FF 	

MethodImplFF	 
(FF 
MethodImplOptionsFF %
.FF% &

NoInliningFF& 0
)FF0 1
]FF1 2
internalGG 
staticGG 
voidGG 5
)ThrowIndexOutOfRangeException_ReaderIndexGG F
(GGF G
intGGG J
indexGGK P
,GGP Q
intGGR U
writerIndexGGV a
)GGa b
{HH 	
throwII '
GetIndexOutOfRangeExceptionII -
(II- .
)II. /
;II/ 0$
IndexOutOfRangeExceptionKK $'
GetIndexOutOfRangeExceptionKK% @
(KK@ A
)KKA B
{LL 
returnMM 
newMM $
IndexOutOfRangeExceptionMM 3
(MM3 4
stringMM4 :
.MM: ;
FormatMM; A
(MMA B
$str	MMB „
,
MM„ …
index
MM† ‹
,
MM‹ Œ
writerIndex
MM ˜
)
MM˜ ™
)
MM™ š
;
MMš ›
}NN 
}OO 	
[QQ 	

MethodImplQQ	 
(QQ 
MethodImplOptionsQQ %
.QQ% &

NoInliningQQ& 0
)QQ0 1
]QQ1 2
internalRR 
staticRR 
voidRR 5
)ThrowIndexOutOfRangeException_ReaderIndexRR F
(RRF G
intRRG J 
minimumReadableBytesRRK _
,RR_ `
intRRa d
readerIndexRRe p
,RRp q
intRRr u
writerIndex	RRv 
,
RR ‚ 
AbstractByteBuffer
RRƒ •
buf
RR– ™
)
RR™ š
{SS 	
throwTT '
GetIndexOutOfRangeExceptionTT -
(TT- .
)TT. /
;TT/ 0$
IndexOutOfRangeExceptionVV $'
GetIndexOutOfRangeExceptionVV% @
(VV@ A
)VVA B
{WW 
returnXX 
newXX $
IndexOutOfRangeExceptionXX 3
(XX3 4
stringXX4 :
.XX: ;
FormatXX; A
(XXA B
$str	XXB €
,
XX€ 
readerIndex
XX‚ 
,
XX "
minimumReadableBytes
XX £
,
XX£ ¤
writerIndex
XX¥ °
,
XX° ±
buf
XX² µ
)
XXµ ¶
)
XX¶ ·
;
XX· ¸
}YY 
}ZZ 	
[\\ 	

MethodImpl\\	 
(\\ 
MethodImplOptions\\ %
.\\% &

NoInlining\\& 0
)\\0 1
]\\1 2
internal]] 
static]] 
void]] 5
)ThrowIndexOutOfRangeException_WriterIndex]] F
(]]F G
int]]G J
index]]K P
,]]P Q
int]]R U
readerIndex]]V a
,]]a b
int]]c f
capacity]]g o
)]]o p
{^^ 	
throw__ '
GetIndexOutOfRangeException__ -
(__- .
)__. /
;__/ 0$
IndexOutOfRangeExceptionaa $'
GetIndexOutOfRangeExceptionaa% @
(aa@ A
)aaA B
{bb 
returncc 
newcc $
IndexOutOfRangeExceptioncc 3
(cc3 4
stringcc4 :
.cc: ;
Formatcc; A
(ccA B
$str	ccB –
,
cc– —
index
cc˜ 
,
cc 
readerIndex
ccŸ ª
,
ccª «
capacity
cc¬ ´
)
cc´ µ
)
ccµ ¶
;
cc¶ ·
}dd 
}ee 	
[gg 	

MethodImplgg	 
(gg 
MethodImplOptionsgg %
.gg% &

NoInlininggg& 0
)gg0 1
]gg1 2
internalhh 
statichh 
voidhh 5
)ThrowIndexOutOfRangeException_WriterIndexhh F
(hhF G
inthhG J
minWritableByteshhK [
,hh[ \
inthh] `
writerIndexhha l
,hhl m
inthhn q
maxCapacityhhr }
,hh} ~
AbstractByteBuffer	hh ‘
buf
hh’ •
)
hh• –
{ii 	
throwjj '
GetIndexOutOfRangeExceptionjj -
(jj- .
)jj. /
;jj/ 0$
IndexOutOfRangeExceptionll $'
GetIndexOutOfRangeExceptionll% @
(ll@ A
)llA B
{mm 
returnnn 
newnn $
IndexOutOfRangeExceptionnn 3
(nn3 4
stringnn4 :
.nn: ;
Formatnn; A
(nnA B
$"nnB D
$strnnD P
{nnP Q
$numnnQ R
}nnR S
$strnnS h
{nnh i
$numnni j
}nnj k
$str	nnk 
{
nn ‚
$num
nn‚ ƒ
}
nnƒ „
$str
nn„ ‡
{
nn‡ ˆ
$num
nnˆ ‰
}
nn‰ Š
"
nnŠ ‹
,
nn‹ Œ
writerIndex
nn ˜
,
nn˜ ™
minWritableBytes
nnš ª
,
nnª «
maxCapacity
nn¬ ·
,
nn· ¸
buf
nn¹ ¼
)
nn¼ ½
)
nn½ ¾
;
nn¾ ¿
}oo 
}pp 	
[rr 	

MethodImplrr	 
(rr 
MethodImplOptionsrr %
.rr% &

NoInliningrr& 0
)rr0 1
]rr1 2
internalss 
staticss 
voidss ;
/ThrowIndexOutOfRangeException_ReaderWriterIndexss L
(ssL M
intssM P
readerIndexssQ \
,ss\ ]
intss^ a
writerIndexssb m
,ssm n
intsso r
capacitysss {
)ss{ |
{tt 	
throwuu '
GetIndexOutOfRangeExceptionuu -
(uu- .
)uu. /
;uu/ 0$
IndexOutOfRangeExceptionww $'
GetIndexOutOfRangeExceptionww% @
(ww@ A
)wwA B
{xx 
returnyy 
newyy $
IndexOutOfRangeExceptionyy 3
(yy3 4
stringyy4 :
.yy: ;
Formatyy; A
(yyA B
$str	yyB £
,
yy£ ¤
readerIndex
yy¥ °
,
yy° ±
writerIndex
yy² ½
,
yy½ ¾
capacity
yy¿ Ç
)
yyÇ È
)
yyÈ É
;
yyÉ Ê
}zz 
}{{ 	
[}} 	

MethodImpl}}	 
(}} 
MethodImplOptions}} %
.}}% &

NoInlining}}& 0
)}}0 1
]}}1 2
internal~~ 
static~~ 
void~~ 7
+ThrowIndexOutOfRangeException_ReadableBytes~~ H
(~~H I
int~~I L
length~~M S
,~~S T
IByteBuffer~~U `
src~~a d
)~~d e
{ 	
throw
€€ )
GetIndexOutOfRangeException
€€ -
(
€€- .
)
€€. /
;
€€/ 0&
IndexOutOfRangeException
‚‚ $)
GetIndexOutOfRangeException
‚‚% @
(
‚‚@ A
)
‚‚A B
{
ƒƒ 
return
„„ 
new
„„ &
IndexOutOfRangeException
„„ 3
(
„„3 4
string
„„4 :
.
„„: ;
Format
„„; A
(
„„A B
$str„„B €
,„„€ 
length„„‚ ˆ
,„„ˆ ‰
src„„Š 
.„„ 
ReadableBytes„„ ›
,„„› œ
src„„  
)„„  ¡
)„„¡ ¢
;„„¢ £
}
…… 
}
†† 	
[
ˆˆ 	

MethodImpl
ˆˆ	 
(
ˆˆ 
MethodImplOptions
ˆˆ %
.
ˆˆ% &

NoInlining
ˆˆ& 0
)
ˆˆ0 1
]
ˆˆ1 2
internal
‰‰ 
static
‰‰ 
void
‰‰ 9
+ThrowIndexOutOfRangeException_WritableBytes
‰‰ H
(
‰‰H I
int
‰‰I L
length
‰‰M S
,
‰‰S T
IByteBuffer
‰‰U `
dst
‰‰a d
)
‰‰d e
{
ŠŠ 	
throw
‹‹ )
GetIndexOutOfRangeException
‹‹ -
(
‹‹- .
)
‹‹. /
;
‹‹/ 0&
IndexOutOfRangeException
 $)
GetIndexOutOfRangeException
% @
(
@ A
)
A B
{
 
return
 
new
 &
IndexOutOfRangeException
 3
(
3 4
string
4 :
.
: ;
Format
; A
(
A B
$strB 
, ‘
length’ ˜
,˜ ™
dstš 
. 
WritableBytes «
,« ¬
dst­ °
)° ±
)± ²
;² ³
}
 
}
‘‘ 	
[
““ 	

MethodImpl
““	 
(
““ 
MethodImplOptions
““ %
.
““% &

NoInlining
““& 0
)
““0 1
]
““1 2
internal
”” 
static
”” 
void
”” /
!ThrowIndexOutOfRangeException_Src
”” >
(
””> ?
int
””? B
srcIndex
””C K
,
””K L
int
””M P
length
””Q W
,
””W X
int
””Y \
count
””] b
)
””b c
{
•• 	
throw
–– )
GetIndexOutOfRangeException
–– -
(
––- .
)
––. /
;
––/ 0&
IndexOutOfRangeException
˜˜ $)
GetIndexOutOfRangeException
˜˜% @
(
˜˜@ A
)
˜˜A B
{
™™ 
return
šš 
new
šš &
IndexOutOfRangeException
šš 3
(
šš3 4
string
šš4 :
.
šš: ;
Format
šš; A
(
ššA B
$strššB …
,šš… †
srcIndexšš‡ 
,šš 
lengthšš‘ —
,šš— ˜
countšš™ 
)šš Ÿ
)ššŸ  
;šš  ¡
}
›› 
}
œœ 	
[
 	

MethodImpl
	 
(
 
MethodImplOptions
 %
.
% &

NoInlining
& 0
)
0 1
]
1 2
internal
ŸŸ 
static
ŸŸ 
void
ŸŸ 1
#ThrowIllegalReferenceCountException
ŸŸ @
(
ŸŸ@ A
int
ŸŸA D
count
ŸŸE J
)
ŸŸJ K
{
   	
throw
¡¡ /
!GetIllegalReferenceCountException
¡¡ 3
(
¡¡3 4
)
¡¡4 5
;
¡¡5 6,
IllegalReferenceCountException
££ */
!GetIllegalReferenceCountException
££+ L
(
££L M
)
££M N
{
¤¤ 
return
¥¥ 
new
¥¥ ,
IllegalReferenceCountException
¥¥ 9
(
¥¥9 :
count
¥¥: ?
)
¥¥? @
;
¥¥@ A
}
¦¦ 
}
§§ 	
[
©© 	

MethodImpl
©©	 
(
©© 
MethodImplOptions
©© %
.
©©% &

NoInlining
©©& 0
)
©©0 1
]
©©1 2
internal
ªª 
static
ªª 
void
ªª C
5ThrowArgumentOutOfRangeException_MinimumReadableBytes
ªª R
(
ªªR S
int
ªªS V"
minimumReadableBytes
ªªW k
)
ªªk l
{
«« 	
throw
¬¬ ,
GetArgumentOutOfRangeException
¬¬ 0
(
¬¬0 1
)
¬¬1 2
;
¬¬2 3)
ArgumentOutOfRangeException
®® ',
GetArgumentOutOfRangeException
®®( F
(
®®F G
)
®®G H
{
¯¯ 
return
°° 
new
°° )
ArgumentOutOfRangeException
°° 6
(
°°6 7
$str
°°7 M
,
°°M N
string
°°O U
.
°°U V
Format
°°V \
(
°°\ ]
$str°°] ‰
,°°‰ Š$
minimumReadableBytes°°‹ Ÿ
)°°Ÿ  
)°°  ¡
;°°¡ ¢
}
±± 
}
²² 	
[
´´ 	

MethodImpl
´´	 
(
´´ 
MethodImplOptions
´´ %
.
´´% &

NoInlining
´´& 0
)
´´0 1
]
´´1 2
internal
µµ 
static
µµ 
void
µµ >
0ThrowArgumentOutOfRangeException_InitialCapacity
µµ M
(
µµM N
)
µµN O
{
¶¶ 	
throw
·· ,
GetArgumentOutOfRangeException
·· 0
(
··0 1
)
··1 2
;
··2 3)
ArgumentOutOfRangeException
¹¹ ',
GetArgumentOutOfRangeException
¹¹( F
(
¹¹F G
)
¹¹G H
{
ºº 
return
»» 
new
»» )
ArgumentOutOfRangeException
»» 6
(
»»6 7
$str
»»7 H
,
»»H I
$str
»»J u
)
»»u v
;
»»v w
}
¼¼ 
}
½½ 	
[
¿¿ 	

MethodImpl
¿¿	 
(
¿¿ 
MethodImplOptions
¿¿ %
.
¿¿% &

NoInlining
¿¿& 0
)
¿¿0 1
]
¿¿1 2
internal
ÀÀ 
static
ÀÀ 
void
ÀÀ >
0ThrowArgumentOutOfRangeException_InitialCapacity
ÀÀ M
(
ÀÀM N
int
ÀÀN Q
initialCapacity
ÀÀR a
,
ÀÀa b
int
ÀÀc f
maxCapacity
ÀÀg r
)
ÀÀr s
{
ÁÁ 	
throw
ÂÂ ,
GetArgumentOutOfRangeException
ÂÂ 0
(
ÂÂ0 1
)
ÂÂ1 2
;
ÂÂ2 3)
ArgumentOutOfRangeException
ÄÄ ',
GetArgumentOutOfRangeException
ÄÄ( F
(
ÄÄF G
)
ÄÄG H
{
ÅÅ 
return
ÆÆ 
new
ÆÆ )
ArgumentOutOfRangeException
ÆÆ 6
(
ÆÆ6 7
$str
ÆÆ7 H
,
ÆÆH I
string
ÆÆJ P
.
ÆÆP Q
Format
ÆÆQ W
(
ÆÆW X
$strÆÆX –
,ÆÆ– —
initialCapacityÆÆ˜ §
,ÆÆ§ ¨
maxCapacityÆÆ© ´
)ÆÆ´ µ
)ÆÆµ ¶
;ÆÆ¶ ·
}
ÇÇ 
}
ÈÈ 	
[
ÊÊ 	

MethodImpl
ÊÊ	 
(
ÊÊ 
MethodImplOptions
ÊÊ %
.
ÊÊ% &

NoInlining
ÊÊ& 0
)
ÊÊ0 1
]
ÊÊ1 2
internal
ËË 
static
ËË 
void
ËË ?
1ThrowArgumentOutOfRangeException_MinWritableBytes
ËË N
(
ËËN O
)
ËËO P
{
ÌÌ 	
throw
ÍÍ ,
GetArgumentOutOfRangeException
ÍÍ 0
(
ÍÍ0 1
)
ÍÍ1 2
;
ÍÍ2 3)
ArgumentOutOfRangeException
ÏÏ ',
GetArgumentOutOfRangeException
ÏÏ( F
(
ÏÏF G
)
ÏÏG H
{
ĞĞ 
return
ÑÑ 
new
ÑÑ )
ArgumentOutOfRangeException
ÑÑ 6
(
ÑÑ6 7
$str
ÑÑ7 I
,
ÑÑI J
$str
ÑÑK ~
)
ÑÑ~ 
;ÑÑ €
}
ÒÒ 
}
ÓÓ 	
[
ÕÕ 	

MethodImpl
ÕÕ	 
(
ÕÕ 
MethodImplOptions
ÕÕ %
.
ÕÕ% &

NoInlining
ÕÕ& 0
)
ÕÕ0 1
]
ÕÕ1 2
internal
ÖÖ 
static
ÖÖ 
void
ÖÖ =
/ThrowArgumentOutOfRangeException_MinNewCapacity
ÖÖ L
(
ÖÖL M
int
ÖÖM P
minNewCapacity
ÖÖQ _
)
ÖÖ_ `
{
×× 	
throw
ØØ ,
GetArgumentOutOfRangeException
ØØ 0
(
ØØ0 1
)
ØØ1 2
;
ØØ2 3)
ArgumentOutOfRangeException
ÚÚ ',
GetArgumentOutOfRangeException
ÚÚ( F
(
ÚÚF G
)
ÚÚG H
{
ÛÛ 
return
ÜÜ 
new
ÜÜ )
ArgumentOutOfRangeException
ÜÜ 6
(
ÜÜ6 7
$str
ÜÜ7 G
,
ÜÜG H
string
ÜÜI O
.
ÜÜO P
Format
ÜÜP V
(
ÜÜV W
$str
ÜÜW {
,
ÜÜ{ |
minNewCapacityÜÜ} ‹
)ÜÜ‹ Œ
)ÜÜŒ 
;ÜÜ 
}
İİ 
}
ŞŞ 	
[
àà 	

MethodImpl
àà	 
(
àà 
MethodImplOptions
àà %
.
àà% &

NoInlining
àà& 0
)
àà0 1
]
àà1 2
internal
áá 
static
áá 
void
áá :
,ThrowArgumentOutOfRangeException_MaxCapacity
áá I
(
ááI J
int
ááJ M
minNewCapacity
ááN \
,
áá\ ]
int
áá^ a
maxCapacity
ááb m
)
áám n
{
ââ 	
throw
ãã ,
GetArgumentOutOfRangeException
ãã 0
(
ãã0 1
)
ãã1 2
;
ãã2 3)
ArgumentOutOfRangeException
åå ',
GetArgumentOutOfRangeException
åå( F
(
ååF G
)
ååG H
{
ææ 
return
çç 
new
çç )
ArgumentOutOfRangeException
çç 6
(
çç6 7
$str
çç7 D
,
ççD E
string
ççF L
.
ççL M
Format
ççM S
(
ççS T
$strççT –
,çç– —
minNewCapacityçç˜ ¦
,çç¦ §
maxCapacityçç¨ ³
)çç³ ´
)çç´ µ
;ççµ ¶
}
èè 
}
éé 	
[
ëë 	

MethodImpl
ëë	 
(
ëë 
MethodImplOptions
ëë %
.
ëë% &

NoInlining
ëë& 0
)
ëë0 1
]
ëë1 2
internal
ìì 
static
ìì 
void
ìì 7
)ThrowArgumentOutOfRangeException_Capacity
ìì F
(
ììF G
int
ììG J
newCapacity
ììK V
,
ììV W
int
ììX [
maxCapacity
ìì\ g
)
ììg h
{
íí 	
throw
îî ,
GetArgumentOutOfRangeException
îî 0
(
îî0 1
)
îî1 2
;
îî2 3)
ArgumentOutOfRangeException
ğğ ',
GetArgumentOutOfRangeException
ğğ( F
(
ğğF G
)
ğğG H
{
ññ 
return
òò 
new
òò )
ArgumentOutOfRangeException
òò 6
(
òò6 7
$str
òò7 D
,
òòD E
string
òòF L
.
òòL M
Format
òòM S
(
òòS T
$"
òòT V
$str
òòV c
{
òòc d
$num
òòd e
}
òòe f
$str
òòf t
{
òòt u
$num
òòu v
}
òòv w
$str
òòw x
"
òòx y
,
òòy z
newCapacityòò{ †
,òò† ‡
maxCapacityòòˆ “
)òò“ ”
)òò” •
;òò• –
}
óó 
}
ôô 	
[
öö 	

MethodImpl
öö	 
(
öö 
MethodImplOptions
öö %
.
öö% &

NoInlining
öö& 0
)
öö0 1
]
öö1 2
internal
÷÷ 
static
÷÷ 
void
÷÷ ,
ThrowArgumentNullException_Dst
÷÷ ;
(
÷÷; <
)
÷÷< =
{
øø 	
throw
ùù ,
GetArgumentOutOfRangeException
ùù 0
(
ùù0 1
)
ùù1 2
;
ùù2 3#
ArgumentNullException
ûû !,
GetArgumentOutOfRangeException
ûû" @
(
ûû@ A
)
ûûA B
{
üü 
return
ıı 
new
ıı #
ArgumentNullException
ıı 0
(
ıı0 1
$str
ıı1 6
)
ıı6 7
;
ıı7 8
}
şş 
}
ÿÿ 	
}
€€ 
} Ş¢
[C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Unpooled.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

static 
class 
Unpooled  
{ 
static 
readonly '
UnpooledByteBufferAllocator 3
	Allocator4 =
=> ?'
UnpooledByteBufferAllocator@ [
.[ \
Default\ c
;c d
public 
static 
readonly 
IByteBuffer *
Empty+ 0
=1 2
	Allocator3 <
.< =
Buffer= C
(C D
$numD E
,E F
$numG H
)H I
;I J
public 
static 
IByteBuffer !
Buffer" (
(( )
)) *
=>+ -
	Allocator. 7
.7 8

HeapBuffer8 B
(B C
)C D
;D E
public 
static 
IByteBuffer !
DirectBuffer" .
(. /
)/ 0
=>1 3
	Allocator4 =
.= >
DirectBuffer> J
(J K
)K L
;L M
public 
static 
IByteBuffer !
Buffer" (
(( )
int) ,
initialCapacity- <
)< =
=>> @
	AllocatorA J
.J K

HeapBufferK U
(U V
initialCapacityV e
)e f
;f g
public 
static 
IByteBuffer !
DirectBuffer" .
(. /
int/ 2
initialCapacity3 B
)B C
=>D F
	AllocatorG P
.P Q
DirectBufferQ ]
(] ^
initialCapacity^ m
)m n
;n o
public 
static 
IByteBuffer !
Buffer" (
(( )
int) ,
initialCapacity- <
,< =
int> A
maxCapacityB M
)M N
=>O Q
	Allocator 
. 

HeapBuffer  
(  !
initialCapacity! 0
,0 1
maxCapacity2 =
)= >
;> ?
public   
static   
IByteBuffer   !
DirectBuffer  " .
(  . /
int  / 2
initialCapacity  3 B
,  B C
int  D G
maxCapacity  H S
)  S T
=>  U W
	Allocator!! 
.!! 
DirectBuffer!! "
(!!" #
initialCapacity!!# 2
,!!2 3
maxCapacity!!4 ?
)!!? @
;!!@ A
public'' 
static'' 
IByteBuffer'' !
WrappedBuffer''" /
(''/ 0
byte''0 4
[''4 5
]''5 6
array''7 <
)''< =
=>''> @
array(( 
.(( 
Length(( 
==(( 
$num(( 
?(( 
Empty((  %
:((' (
new(() ,"
UnpooledHeapByteBuffer((- C
(((C D
	Allocator((D M
,((M N
array((O T
,((T U
array((V [
.(([ \
Length((\ b
)((b c
;((c d
public// 
static// 
IByteBuffer// !
WrappedBuffer//" /
(/// 0
byte//0 4
[//4 5
]//5 6
array//7 <
,//< =
int//> A
offset//B H
,//H I
int//J M
length//N T
)//T U
{00 	
if11 
(11 
length11 
==11 
$num11 
)11 
{22 
return33 
Empty33 
;33 
}44 
if66 
(66 
offset66 
==66 
$num66 
&&66 
length66 %
==66& (
array66) .
.66. /
Length66/ 5
)665 6
{77 
return88 
WrappedBuffer88 $
(88$ %
array88% *
)88* +
;88+ ,
}99 
return;; 
WrappedBuffer;;  
(;;  !
array;;! &
);;& '
.;;' (
Slice;;( -
(;;- .
offset;;. 4
,;;4 5
length;;6 <
);;< =
;;;= >
}<< 	
publicDD 
staticDD 
IByteBufferDD !
WrappedBufferDD" /
(DD/ 0
IByteBufferDD0 ;
bufferDD< B
)DDB C
{EE 	
ifFF 
(FF 
bufferFF 
.FF 

IsReadableFF !
(FF! "
)FF" #
)FF# $
{GG 
returnHH 
bufferHH 
.HH 
SliceHH #
(HH# $
)HH$ %
;HH% &
}II 
elseJJ 
{KK 
bufferLL 
.LL 
ReleaseLL 
(LL 
)LL  
;LL  !
returnMM 
EmptyMM 
;MM 
}NN 
}OO 	
publicUU 
staticUU 
IByteBufferUU !
WrappedBufferUU" /
(UU/ 0
paramsUU0 6
byteUU7 ;
[UU; <
]UU< =
[UU= >
]UU> ?
arraysUU@ F
)UUF G
=>UUH J
WrappedBufferUUK X
(UUX Y'
AbstractByteBufferAllocatorUUY t
.UUt u!
DefaultMaxComponents	UUu ‰
,
UU‰ Š
arrays
UU‹ ‘
)
UU‘ ’
;
UU’ “
public]] 
static]] 
IByteBuffer]] !
WrappedBuffer]]" /
(]]/ 0
params]]0 6
IByteBuffer]]7 B
[]]B C
]]]C D
buffers]]E L
)]]L M
=>]]N P
WrappedBuffer]]Q ^
(]]^ _'
AbstractByteBufferAllocator]]_ z
.]]z {!
DefaultMaxComponents	]]{ 
,
]] 
buffers
]]‘ ˜
)
]]˜ ™
;
]]™ š
publiccc 
staticcc 
IByteBuffercc !
WrappedBuffercc" /
(cc/ 0
intcc0 3
maxNumComponentscc4 D
,ccD E
paramsccF L
byteccM Q
[ccQ R
]ccR S
[ccS T
]ccT U
arraysccV \
)cc\ ]
{dd 	
switchee 
(ee 
arraysee 
.ee 
Lengthee !
)ee! "
{ff 
casegg 
$numgg 
:gg 
breakhh 
;hh 
caseii 
$numii 
:ii 
ifjj 
(jj 
arraysjj 
[jj 
$numjj  
]jj  !
.jj! "
Lengthjj" (
!=jj) +
$numjj, -
)jj- .
{kk 
returnll 
WrappedBufferll ,
(ll, -
arraysll- 3
[ll3 4
$numll4 5
]ll5 6
)ll6 7
;ll7 8
}mm 
breaknn 
;nn 
defaultoo 
:oo 
varqq 

componentsqq "
=qq# $
newqq% (
Listqq) -
<qq- .
IByteBufferqq. 9
>qq9 :
(qq: ;
arraysqq; A
.qqA B
LengthqqB H
)qqH I
;qqI J
foreachrr 
(rr 
byterr !
[rr! "
]rr" #
arrayrr$ )
inrr* ,
arraysrr- 3
)rr3 4
{ss 
iftt 
(tt 
arraytt !
==tt" $
nulltt% )
)tt) *
{uu 
breakvv !
;vv! "
}ww 
ifxx 
(xx 
arrayxx !
.xx! "
Lengthxx" (
>xx) *
$numxx+ ,
)xx, -
{yy 

componentszz &
.zz& '
Addzz' *
(zz* +
WrappedBufferzz+ 8
(zz8 9
arrayzz9 >
)zz> ?
)zz? @
;zz@ A
}{{ 
}|| 
if~~ 
(~~ 

components~~ "
.~~" #
Count~~# (
>~~) *
$num~~+ ,
)~~, -
{ 
return
€€ 
new
€€ "!
CompositeByteBuffer
€€# 6
(
€€6 7
	Allocator
€€7 @
,
€€@ A
false
€€B G
,
€€G H
maxNumComponents
€€I Y
,
€€Y Z

components
€€[ e
)
€€e f
;
€€f g
}
 
break
‚‚ 
;
‚‚ 
}
ƒƒ 
return
…… 
Empty
…… 
;
…… 
}
†† 	
public
 
static
 
IByteBuffer
 !
WrappedBuffer
" /
(
/ 0
int
0 3
maxNumComponents
4 D
,
D E
params
F L
IByteBuffer
M X
[
X Y
]
Y Z
buffers
[ b
)
b c
{
 	
switch
‘‘ 
(
‘‘ 
buffers
‘‘ 
.
‘‘ 
Length
‘‘ "
)
‘‘" #
{
’’ 
case
““ 
$num
““ 
:
““ 
break
”” 
;
”” 
case
•• 
$num
•• 
:
•• 
IByteBuffer
–– 
buffer
––  &
=
––' (
buffers
––) 0
[
––0 1
$num
––1 2
]
––2 3
;
––3 4
if
—— 
(
—— 
buffer
—— 
.
—— 

IsReadable
—— )
(
——) *
)
——* +
)
——+ ,
return
˜˜ 
WrappedBuffer
˜˜ ,
(
˜˜, -
buffer
˜˜- 3
)
˜˜3 4
;
˜˜4 5
else
™™ 
buffer
šš 
.
šš 
Release
šš &
(
šš& '
)
šš' (
;
šš( )
break
›› 
;
›› 
default
œœ 
:
œœ 
for
 
(
 
int
 
i
 
=
  
$num
! "
;
" #
i
$ %
<
& '
buffers
( /
.
/ 0
Length
0 6
;
6 7
i
8 9
++
9 ;
)
; <
{
 
IByteBuffer
ŸŸ #
buf
ŸŸ$ '
=
ŸŸ( )
buffers
ŸŸ* 1
[
ŸŸ1 2
i
ŸŸ2 3
]
ŸŸ3 4
;
ŸŸ4 5
if
   
(
   
buf
   
.
    

IsReadable
    *
(
  * +
)
  + ,
)
  , -
return
¡¡ "
new
¡¡# &!
CompositeByteBuffer
¡¡' :
(
¡¡: ;
	Allocator
¡¡; D
,
¡¡D E
false
¡¡F K
,
¡¡K L
maxNumComponents
¡¡M ]
,
¡¡] ^
buffers
¡¡_ f
,
¡¡f g
i
¡¡h i
,
¡¡i j
buffers
¡¡k r
.
¡¡r s
Length
¡¡s y
)
¡¡y z
;
¡¡z {
else
¢¢ 
buf
££ 
.
££  
Release
££  '
(
££' (
)
££( )
;
££) *
}
¤¤ 
break
¥¥ 
;
¥¥ 
}
¦¦ 
return
¨¨ 
Empty
¨¨ 
;
¨¨ 
}
©© 	
public
«« 
static
«« !
CompositeByteBuffer
«« )
CompositeBuffer
««* 9
(
««9 :
)
««: ;
=>
««< >
CompositeBuffer
««? N
(
««N O)
AbstractByteBufferAllocator
««O j
.
««j k"
DefaultMaxComponents
««k 
)«« €
;««€ 
public
­­ 
static
­­ !
CompositeByteBuffer
­­ )
CompositeBuffer
­­* 9
(
­­9 :
int
­­: =
maxNumComponents
­­> N
)
­­N O
=>
­­P R
new
­­S V!
CompositeByteBuffer
­­W j
(
­­j k
	Allocator
­­k t
,
­­t u
false
­­v {
,
­­{ |
maxNumComponents­­} 
)­­ 
;­­ 
public
¶¶ 
static
¶¶ 
IByteBuffer
¶¶ !
CopiedBuffer
¶¶" .
(
¶¶. /
byte
¶¶/ 3
[
¶¶3 4
]
¶¶4 5
array
¶¶6 ;
)
¶¶; <
{
·· 	
if
¸¸ 
(
¸¸ 
array
¸¸ 
.
¸¸ 
Length
¸¸ 
==
¸¸ 
$num
¸¸  !
)
¸¸! "
{
¹¹ 
return
ºº 
Empty
ºº 
;
ºº 
}
»» 
var
½½ 
newArray
½½ 
=
½½ 
new
½½ 
byte
½½ #
[
½½# $
array
½½$ )
.
½½) *
Length
½½* 0
]
½½0 1
;
½½1 2
PlatformDependent
¾¾ 
.
¾¾ 

CopyMemory
¾¾ (
(
¾¾( )
array
¾¾) .
,
¾¾. /
$num
¾¾0 1
,
¾¾1 2
newArray
¾¾3 ;
,
¾¾; <
$num
¾¾= >
,
¾¾> ?
array
¾¾@ E
.
¾¾E F
Length
¾¾F L
)
¾¾L M
;
¾¾M N
return
ÀÀ 
WrappedBuffer
ÀÀ  
(
ÀÀ  !
newArray
ÀÀ! )
)
ÀÀ) *
;
ÀÀ* +
}
ÁÁ 	
public
ÎÎ 
static
ÎÎ 
IByteBuffer
ÎÎ !
CopiedBuffer
ÎÎ" .
(
ÎÎ. /
byte
ÎÎ/ 3
[
ÎÎ3 4
]
ÎÎ4 5
array
ÎÎ6 ;
,
ÎÎ; <
int
ÎÎ= @
offset
ÎÎA G
,
ÎÎG H
int
ÎÎI L
length
ÎÎM S
)
ÎÎS T
{
ÏÏ 	
if
ĞĞ 
(
ĞĞ 
length
ĞĞ 
==
ĞĞ 
$num
ĞĞ 
)
ĞĞ 
{
ÑÑ 
return
ÒÒ 
Empty
ÒÒ 
;
ÒÒ 
}
ÓÓ 
var
ÕÕ 
copy
ÕÕ 
=
ÕÕ 
new
ÕÕ 
byte
ÕÕ 
[
ÕÕ  
length
ÕÕ  &
]
ÕÕ& '
;
ÕÕ' (
PlatformDependent
ÖÖ 
.
ÖÖ 

CopyMemory
ÖÖ (
(
ÖÖ( )
array
ÖÖ) .
,
ÖÖ. /
offset
ÖÖ0 6
,
ÖÖ6 7
copy
ÖÖ8 <
,
ÖÖ< =
$num
ÖÖ> ?
,
ÖÖ? @
length
ÖÖA G
)
ÖÖG H
;
ÖÖH I
return
×× 
WrappedBuffer
××  
(
××  !
copy
××! %
)
××% &
;
××& '
}
ØØ 	
public
áá 
static
áá 
IByteBuffer
áá !
CopiedBuffer
áá" .
(
áá. /
IByteBuffer
áá/ :
buffer
áá; A
)
ááA B
{
ââ 	
int
ãã 
readable
ãã 
=
ãã 
buffer
ãã !
.
ãã! "
ReadableBytes
ãã" /
;
ãã/ 0
if
ää 
(
ää 
readable
ää 
>
ää 
$num
ää 
)
ää 
{
åå 
IByteBuffer
ææ 
copy
ææ  
=
ææ! "
Buffer
ææ# )
(
ææ) *
readable
ææ* 2
)
ææ2 3
;
ææ3 4
copy
çç 
.
çç 

WriteBytes
çç 
(
çç  
buffer
çç  &
,
çç& '
buffer
çç( .
.
çç. /
ReaderIndex
çç/ :
,
çç: ;
readable
çç< D
)
ççD E
;
ççE F
return
èè 
copy
èè 
;
èè 
}
éé 
else
êê 
{
ëë 
return
ìì 
Empty
ìì 
;
ìì 
}
íí 
}
îî 	
public
÷÷ 
static
÷÷ 
IByteBuffer
÷÷ !
CopiedBuffer
÷÷" .
(
÷÷. /
params
÷÷/ 5
byte
÷÷6 :
[
÷÷: ;
]
÷÷; <
[
÷÷< =
]
÷÷= >
arrays
÷÷? E
)
÷÷E F
{
øø 	
switch
ùù 
(
ùù 
arrays
ùù 
.
ùù 
Length
ùù !
)
ùù! "
{
úú 
case
ûû 
$num
ûû 
:
ûû 
return
üü 
Empty
üü  
;
üü  !
case
ıı 
$num
ıı 
:
ıı 
return
şş 
arrays
şş !
[
şş! "
$num
şş" #
]
şş# $
.
şş$ %
Length
şş% +
==
şş, .
$num
şş/ 0
?
şş1 2
Empty
şş3 8
:
şş9 :
CopiedBuffer
şş; G
(
şşG H
arrays
şşH N
[
şşN O
$num
şşO P
]
şşP Q
)
şşQ R
;
şşR S
}
ÿÿ 
int
‚‚ 
length
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
foreach
ƒƒ 
(
ƒƒ 
byte
ƒƒ 
[
ƒƒ 
]
ƒƒ 
a
ƒƒ 
in
ƒƒ  
arrays
ƒƒ! '
)
ƒƒ' (
{
„„ 
if
…… 
(
…… 
int
…… 
.
…… 
MaxValue
……  
-
……! "
length
……# )
<
……* +
a
……, -
.
……- .
Length
……. 4
)
……4 5
{
†† 
throw
‡‡ 
new
‡‡ 
ArgumentException
‡‡ /
(
‡‡/ 0
$str
‡‡0 f
)
‡‡f g
;
‡‡g h
}
ˆˆ 
length
‰‰ 
+=
‰‰ 
a
‰‰ 
.
‰‰ 
Length
‰‰ "
;
‰‰" #
}
ŠŠ 
if
ŒŒ 
(
ŒŒ 
length
ŒŒ 
==
ŒŒ 
$num
ŒŒ 
)
ŒŒ 
{
 
return
 
Empty
 
;
 
}
 
var
‘‘ 
mergedArray
‘‘ 
=
‘‘ 
new
‘‘ !
byte
‘‘" &
[
‘‘& '
length
‘‘' -
]
‘‘- .
;
‘‘. /
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
,
’’ 
j
’’ 
=
’’ 
$num
’’  !
;
’’! "
i
’’# $
<
’’% &
arrays
’’' -
.
’’- .
Length
’’. 4
;
’’4 5
i
’’6 7
++
’’7 9
)
’’9 :
{
““ 
byte
”” 
[
”” 
]
”” 
a
”” 
=
”” 
arrays
”” !
[
””! "
i
””" #
]
””# $
;
””$ %
PlatformDependent
•• !
.
••! "

CopyMemory
••" ,
(
••, -
a
••- .
,
••. /
$num
••0 1
,
••1 2
mergedArray
••3 >
,
••> ?
j
••@ A
,
••A B
a
••C D
.
••D E
Length
••E K
)
••K L
;
••L M
j
–– 
+=
–– 
a
–– 
.
–– 
Length
–– 
;
–– 
}
—— 
return
™™ 
WrappedBuffer
™™  
(
™™  !
mergedArray
™™! ,
)
™™, -
;
™™- .
}
šš 	
public
££ 
static
££ 
IByteBuffer
££ !
CopiedBuffer
££" .
(
££. /
params
££/ 5
IByteBuffer
££6 A
[
££A B
]
££B C
buffers
££D K
)
££K L
{
¤¤ 	
switch
¥¥ 
(
¥¥ 
buffers
¥¥ 
.
¥¥ 
Length
¥¥ "
)
¥¥" #
{
¦¦ 
case
§§ 
$num
§§ 
:
§§ 
return
¨¨ 
Empty
¨¨  
;
¨¨  !
case
©© 
$num
©© 
:
©© 
return
ªª 
CopiedBuffer
ªª '
(
ªª' (
buffers
ªª( /
[
ªª/ 0
$num
ªª0 1
]
ªª1 2
)
ªª2 3
;
ªª3 4
}
«« 
int
®® 
length
®® 
=
®® 
$num
®® 
;
®® 
foreach
¯¯ 
(
¯¯ 
IByteBuffer
¯¯  
b
¯¯! "
in
¯¯# %
buffers
¯¯& -
)
¯¯- .
{
°° 
int
±± 
bLen
±± 
=
±± 
b
±± 
.
±± 
ReadableBytes
±± *
;
±±* +
if
²² 
(
²² 
bLen
²² 
<=
²² 
$num
²² 
)
²² 
{
³³ 
continue
´´ 
;
´´ 
}
µµ 
if
¶¶ 
(
¶¶ 
int
¶¶ 
.
¶¶ 
MaxValue
¶¶  
-
¶¶! "
length
¶¶# )
<
¶¶* +
bLen
¶¶, 0
)
¶¶0 1
{
·· 
throw
¸¸ 
new
¸¸ 
ArgumentException
¸¸ /
(
¸¸/ 0
$str
¸¸0 g
)
¸¸g h
;
¸¸h i
}
¹¹ 
length
»» 
+=
»» 
bLen
»» 
;
»» 
}
¼¼ 
if
¾¾ 
(
¾¾ 
length
¾¾ 
==
¾¾ 
$num
¾¾ 
)
¾¾ 
{
¿¿ 
return
ÀÀ 
Empty
ÀÀ 
;
ÀÀ 
}
ÁÁ 
var
ÃÃ 
mergedArray
ÃÃ 
=
ÃÃ 
new
ÃÃ !
byte
ÃÃ" &
[
ÃÃ& '
length
ÃÃ' -
]
ÃÃ- .
;
ÃÃ. /
for
ÄÄ 
(
ÄÄ 
int
ÄÄ 
i
ÄÄ 
=
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
j
ÄÄ 
=
ÄÄ 
$num
ÄÄ  !
;
ÄÄ! "
i
ÄÄ# $
<
ÄÄ% &
buffers
ÄÄ' .
.
ÄÄ. /
Length
ÄÄ/ 5
;
ÄÄ5 6
i
ÄÄ7 8
++
ÄÄ8 :
)
ÄÄ: ;
{
ÅÅ 
IByteBuffer
ÆÆ 
b
ÆÆ 
=
ÆÆ 
buffers
ÆÆ  '
[
ÆÆ' (
i
ÆÆ( )
]
ÆÆ) *
;
ÆÆ* +
int
ÇÇ 
bLen
ÇÇ 
=
ÇÇ 
b
ÇÇ 
.
ÇÇ 
ReadableBytes
ÇÇ *
;
ÇÇ* +
b
ÈÈ 
.
ÈÈ 
GetBytes
ÈÈ 
(
ÈÈ 
b
ÈÈ 
.
ÈÈ 
ReaderIndex
ÈÈ (
,
ÈÈ( )
mergedArray
ÈÈ* 5
,
ÈÈ5 6
j
ÈÈ7 8
,
ÈÈ8 9
bLen
ÈÈ: >
)
ÈÈ> ?
;
ÈÈ? @
j
ÉÉ 
+=
ÉÉ 
bLen
ÉÉ 
;
ÉÉ 
}
ÊÊ 
return
ÌÌ 
WrappedBuffer
ÌÌ  
(
ÌÌ  !
mergedArray
ÌÌ! ,
)
ÌÌ, -
;
ÌÌ- .
}
ÍÍ 	
public
ÏÏ 
static
ÏÏ 
IByteBuffer
ÏÏ !
CopiedBuffer
ÏÏ" .
(
ÏÏ. /
char
ÏÏ/ 3
[
ÏÏ3 4
]
ÏÏ4 5
array
ÏÏ6 ;
,
ÏÏ; <
int
ÏÏ= @
offset
ÏÏA G
,
ÏÏG H
int
ÏÏI L
length
ÏÏM S
,
ÏÏS T
Encoding
ÏÏU ]
encoding
ÏÏ^ f
)
ÏÏf g
{
ĞĞ 	
Contract
ÑÑ 
.
ÑÑ 
Requires
ÑÑ 
(
ÑÑ 
array
ÑÑ #
!=
ÑÑ$ &
null
ÑÑ' +
)
ÑÑ+ ,
;
ÑÑ, -
return
ÒÒ 
length
ÒÒ 
==
ÒÒ 
$num
ÒÒ 
?
ÒÒ  
Empty
ÒÒ! &
:
ÒÒ' (
CopiedBuffer
ÒÒ) 5
(
ÒÒ5 6
new
ÒÒ6 9
string
ÒÒ: @
(
ÒÒ@ A
array
ÒÒA F
,
ÒÒF G
offset
ÒÒH N
,
ÒÒN O
length
ÒÒP V
)
ÒÒV W
,
ÒÒW X
encoding
ÒÒY a
)
ÒÒa b
;
ÒÒb c
}
ÓÓ 	
public
ÕÕ 
static
ÕÕ 
IByteBuffer
ÕÕ !
CopiedBuffer
ÕÕ" .
(
ÕÕ. /
string
ÕÕ/ 5
value
ÕÕ6 ;
,
ÕÕ; <
Encoding
ÕÕ= E
encoding
ÕÕF N
)
ÕÕN O
=>
ÕÕP R
ByteBufferUtil
ÕÕS a
.
ÕÕa b
EncodeString0
ÕÕb o
(
ÕÕo p
	Allocator
ÕÕp y
,
ÕÕy z
true
ÕÕ{ 
,ÕÕ €
valueÕÕ †
,ÕÕ† ‡
encodingÕÕˆ 
,ÕÕ ‘
$numÕÕ’ “
)ÕÕ“ ”
;ÕÕ” •
public
ÚÚ 
static
ÚÚ 
IByteBuffer
ÚÚ !
CopyInt
ÚÚ" )
(
ÚÚ) *
int
ÚÚ* -
value
ÚÚ. 3
)
ÚÚ3 4
{
ÛÛ 	
IByteBuffer
ÜÜ 
buf
ÜÜ 
=
ÜÜ 
Buffer
ÜÜ $
(
ÜÜ$ %
$num
ÜÜ% &
)
ÜÜ& '
;
ÜÜ' (
buf
İİ 
.
İİ 
WriteInt
İİ 
(
İİ 
value
İİ 
)
İİ 
;
İİ  
return
ŞŞ 
buf
ŞŞ 
;
ŞŞ 
}
ßß 	
public
ää 
static
ää 
IByteBuffer
ää !
CopyInt
ää" )
(
ää) *
params
ää* 0
int
ää1 4
[
ää4 5
]
ää5 6
values
ää7 =
)
ää= >
{
åå 	
if
ææ 
(
ææ 
values
ææ 
==
ææ 
null
ææ 
||
ææ !
values
ææ" (
.
ææ( )
Length
ææ) /
==
ææ0 2
$num
ææ3 4
)
ææ4 5
{
çç 
return
èè 
Empty
èè 
;
èè 
}
éé 
IByteBuffer
ëë 
buffer
ëë 
=
ëë  
Buffer
ëë! '
(
ëë' (
values
ëë( .
.
ëë. /
Length
ëë/ 5
*
ëë6 7
$num
ëë8 9
)
ëë9 :
;
ëë: ;
foreach
ìì 
(
ìì 
int
ìì 
v
ìì 
in
ìì 
values
ìì $
)
ìì$ %
{
íí 
buffer
îî 
.
îî 
WriteInt
îî 
(
îî  
v
îî  !
)
îî! "
;
îî" #
}
ïï 
return
ññ 
buffer
ññ 
;
ññ 
}
òò 	
public
÷÷ 
static
÷÷ 
IByteBuffer
÷÷ !
	CopyShort
÷÷" +
(
÷÷+ ,
int
÷÷, /
value
÷÷0 5
)
÷÷5 6
{
øø 	
IByteBuffer
ùù 
buf
ùù 
=
ùù 
Buffer
ùù $
(
ùù$ %
$num
ùù% &
)
ùù& '
;
ùù' (
buf
úú 
.
úú 

WriteShort
úú 
(
úú 
value
úú  
)
úú  !
;
úú! "
return
ûû 
buf
ûû 
;
ûû 
}
üü 	
public
 
static
 
IByteBuffer
 !
	CopyShort
" +
(
+ ,
params
, 2
short
3 8
[
8 9
]
9 :
values
; A
)
A B
{
‚‚ 	
if
ƒƒ 
(
ƒƒ 
values
ƒƒ 
==
ƒƒ 
null
ƒƒ 
||
ƒƒ !
values
ƒƒ" (
.
ƒƒ( )
Length
ƒƒ) /
==
ƒƒ0 2
$num
ƒƒ3 4
)
ƒƒ4 5
{
„„ 
return
…… 
Empty
…… 
;
…… 
}
†† 
IByteBuffer
ˆˆ 
buffer
ˆˆ 
=
ˆˆ  
Buffer
ˆˆ! '
(
ˆˆ' (
values
ˆˆ( .
.
ˆˆ. /
Length
ˆˆ/ 5
*
ˆˆ6 7
$num
ˆˆ8 9
)
ˆˆ9 :
;
ˆˆ: ;
foreach
‰‰ 
(
‰‰ 
short
‰‰ 
v
‰‰ 
in
‰‰ 
values
‰‰  &
)
‰‰& '
{
ŠŠ 
buffer
‹‹ 
.
‹‹ 

WriteShort
‹‹ !
(
‹‹! "
v
‹‹" #
)
‹‹# $
;
‹‹$ %
}
ŒŒ 
return
 
buffer
 
;
 
}
 	
public
”” 
static
”” 
IByteBuffer
”” !
	CopyShort
””" +
(
””+ ,
params
””, 2
int
””3 6
[
””6 7
]
””7 8
values
””9 ?
)
””? @
{
•• 	
if
–– 
(
–– 
values
–– 
==
–– 
null
–– 
||
–– !
values
––" (
.
––( )
Length
––) /
==
––0 2
$num
––3 4
)
––4 5
{
—— 
return
˜˜ 
Empty
˜˜ 
;
˜˜ 
}
™™ 
IByteBuffer
›› 
buffer
›› 
=
››  
Buffer
››! '
(
››' (
values
››( .
.
››. /
Length
››/ 5
*
››6 7
$num
››8 9
)
››9 :
;
››: ;
foreach
œœ 
(
œœ 
int
œœ 
v
œœ 
in
œœ 
values
œœ $
)
œœ$ %
{
 
buffer
 
.
 

WriteShort
 !
(
! "
v
" #
)
# $
;
$ %
}
ŸŸ 
return
   
buffer
   
;
   
}
¡¡ 	
public
¦¦ 
static
¦¦ 
IByteBuffer
¦¦ !

CopyMedium
¦¦" ,
(
¦¦, -
int
¦¦- 0
value
¦¦1 6
)
¦¦6 7
{
§§ 	
IByteBuffer
¨¨ 
buf
¨¨ 
=
¨¨ 
Buffer
¨¨ $
(
¨¨$ %
$num
¨¨% &
)
¨¨& '
;
¨¨' (
buf
©© 
.
©© 
WriteMedium
©© 
(
©© 
value
©© !
)
©©! "
;
©©" #
return
ªª 
buf
ªª 
;
ªª 
}
«« 	
public
°° 
static
°° 
IByteBuffer
°° !

CopyMedium
°°" ,
(
°°, -
params
°°- 3
int
°°4 7
[
°°7 8
]
°°8 9
values
°°: @
)
°°@ A
{
±± 	
if
²² 
(
²² 
values
²² 
==
²² 
null
²² 
||
²² !
values
²²" (
.
²²( )
Length
²²) /
==
²²0 2
$num
²²3 4
)
²²4 5
{
³³ 
return
´´ 
Empty
´´ 
;
´´ 
}
µµ 
IByteBuffer
·· 
buffer
·· 
=
··  
Buffer
··! '
(
··' (
values
··( .
.
··. /
Length
··/ 5
*
··6 7
$num
··8 9
)
··9 :
;
··: ;
foreach
¸¸ 
(
¸¸ 
int
¸¸ 
v
¸¸ 
in
¸¸ 
values
¸¸ $
)
¸¸$ %
{
¹¹ 
buffer
ºº 
.
ºº 
WriteMedium
ºº "
(
ºº" #
v
ºº# $
)
ºº$ %
;
ºº% &
}
»» 
return
½½ 
buffer
½½ 
;
½½ 
}
¾¾ 	
public
ÃÃ 
static
ÃÃ 
IByteBuffer
ÃÃ !
CopyLong
ÃÃ" *
(
ÃÃ* +
long
ÃÃ+ /
value
ÃÃ0 5
)
ÃÃ5 6
{
ÄÄ 	
IByteBuffer
ÅÅ 
buf
ÅÅ 
=
ÅÅ 
Buffer
ÅÅ $
(
ÅÅ$ %
$num
ÅÅ% &
)
ÅÅ& '
;
ÅÅ' (
buf
ÆÆ 
.
ÆÆ 
	WriteLong
ÆÆ 
(
ÆÆ 
value
ÆÆ 
)
ÆÆ  
;
ÆÆ  !
return
ÇÇ 
buf
ÇÇ 
;
ÇÇ 
}
ÈÈ 	
public
ÍÍ 
static
ÍÍ 
IByteBuffer
ÍÍ !
CopyLong
ÍÍ" *
(
ÍÍ* +
params
ÍÍ+ 1
long
ÍÍ2 6
[
ÍÍ6 7
]
ÍÍ7 8
values
ÍÍ9 ?
)
ÍÍ? @
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
values
ÏÏ 
==
ÏÏ 
null
ÏÏ 
||
ÏÏ !
values
ÏÏ" (
.
ÏÏ( )
Length
ÏÏ) /
==
ÏÏ0 2
$num
ÏÏ3 4
)
ÏÏ4 5
{
ĞĞ 
return
ÑÑ 
Empty
ÑÑ 
;
ÑÑ 
}
ÒÒ 
IByteBuffer
ÔÔ 
buffer
ÔÔ 
=
ÔÔ  
Buffer
ÔÔ! '
(
ÔÔ' (
values
ÔÔ( .
.
ÔÔ. /
Length
ÔÔ/ 5
*
ÔÔ6 7
$num
ÔÔ8 9
)
ÔÔ9 :
;
ÔÔ: ;
foreach
ÕÕ 
(
ÕÕ 
long
ÕÕ 
v
ÕÕ 
in
ÕÕ 
values
ÕÕ %
)
ÕÕ% &
{
ÖÖ 
buffer
×× 
.
×× 
	WriteLong
××  
(
××  !
v
××! "
)
××" #
;
××# $
}
ØØ 
return
ÚÚ 
buffer
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
àà 
static
àà 
IByteBuffer
àà !
CopyBoolean
àà" -
(
àà- .
bool
àà. 2
value
àà3 8
)
àà8 9
{
áá 	
IByteBuffer
ââ 
buf
ââ 
=
ââ 
Buffer
ââ $
(
ââ$ %
$num
ââ% &
)
ââ& '
;
ââ' (
buf
ãã 
.
ãã 
WriteBoolean
ãã 
(
ãã 
value
ãã "
)
ãã" #
;
ãã# $
return
ää 
buf
ää 
;
ää 
}
åå 	
public
êê 
static
êê 
IByteBuffer
êê !
CopyBoolean
êê" -
(
êê- .
params
êê. 4
bool
êê5 9
[
êê9 :
]
êê: ;
values
êê< B
)
êêB C
{
ëë 	
if
ìì 
(
ìì 
values
ìì 
==
ìì 
null
ìì 
||
ìì !
values
ìì" (
.
ìì( )
Length
ìì) /
==
ìì0 2
$num
ìì3 4
)
ìì4 5
{
íí 
return
îî 
Empty
îî 
;
îî 
}
ïï 
IByteBuffer
ññ 
buffer
ññ 
=
ññ  
Buffer
ññ! '
(
ññ' (
values
ññ( .
.
ññ. /
Length
ññ/ 5
)
ññ5 6
;
ññ6 7
foreach
òò 
(
òò 
bool
òò 
v
òò 
in
òò 
values
òò %
)
òò% &
{
óó 
buffer
ôô 
.
ôô 
WriteBoolean
ôô #
(
ôô# $
v
ôô$ %
)
ôô% &
;
ôô& '
}
õõ 
return
÷÷ 
buffer
÷÷ 
;
÷÷ 
}
øø 	
public
ıı 
static
ıı 
IByteBuffer
ıı !
	CopyFloat
ıı" +
(
ıı+ ,
float
ıı, 1
value
ıı2 7
)
ıı7 8
{
şş 	
IByteBuffer
ÿÿ 
buf
ÿÿ 
=
ÿÿ 
Buffer
ÿÿ $
(
ÿÿ$ %
$num
ÿÿ% &
)
ÿÿ& '
;
ÿÿ' (
buf
€€ 
.
€€ 

WriteFloat
€€ 
(
€€ 
value
€€  
)
€€  !
;
€€! "
return
 
buf
 
;
 
}
‚‚ 	
public
‡‡ 
static
‡‡ 
IByteBuffer
‡‡ !
	CopyFloat
‡‡" +
(
‡‡+ ,
params
‡‡, 2
float
‡‡3 8
[
‡‡8 9
]
‡‡9 :
values
‡‡; A
)
‡‡A B
{
ˆˆ 	
if
‰‰ 
(
‰‰ 
values
‰‰ 
==
‰‰ 
null
‰‰ 
||
‰‰ !
values
‰‰" (
.
‰‰( )
Length
‰‰) /
==
‰‰0 2
$num
‰‰3 4
)
‰‰4 5
{
ŠŠ 
return
‹‹ 
Empty
‹‹ 
;
‹‹ 
}
ŒŒ 
IByteBuffer
 
buffer
 
=
  
Buffer
! '
(
' (
values
( .
.
. /
Length
/ 5
*
6 7
$num
8 9
)
9 :
;
: ;
foreach
 
(
 
float
 
v
 
in
 
values
  &
)
& '
{
 
buffer
‘‘ 
.
‘‘ 

WriteFloat
‘‘ !
(
‘‘! "
v
‘‘" #
)
‘‘# $
;
‘‘$ %
}
’’ 
return
”” 
buffer
”” 
;
”” 
}
•• 	
public
šš 
static
šš 
IByteBuffer
šš !

CopyDouble
šš" ,
(
šš, -
double
šš- 3
value
šš4 9
)
šš9 :
{
›› 	
IByteBuffer
œœ 
buf
œœ 
=
œœ 
Buffer
œœ $
(
œœ$ %
$num
œœ% &
)
œœ& '
;
œœ' (
buf
 
.
 
WriteDouble
 
(
 
value
 !
)
! "
;
" #
return
 
buf
 
;
 
}
ŸŸ 	
public
¤¤ 
static
¤¤ 
IByteBuffer
¤¤ !

CopyDouble
¤¤" ,
(
¤¤, -
params
¤¤- 3
double
¤¤4 :
[
¤¤: ;
]
¤¤; <
values
¤¤= C
)
¤¤C D
{
¥¥ 	
if
¦¦ 
(
¦¦ 
values
¦¦ 
==
¦¦ 
null
¦¦ 
||
¦¦ !
values
¦¦" (
.
¦¦( )
Length
¦¦) /
==
¦¦0 2
$num
¦¦3 4
)
¦¦4 5
{
§§ 
return
¨¨ 
Empty
¨¨ 
;
¨¨ 
}
©© 
IByteBuffer
«« 
buffer
«« 
=
««  
Buffer
««! '
(
««' (
values
««( .
.
««. /
Length
««/ 5
*
««6 7
$num
««8 9
)
««9 :
;
««: ;
foreach
¬¬ 
(
¬¬ 
double
¬¬ 
v
¬¬ 
in
¬¬  
values
¬¬! '
)
¬¬' (
{
­­ 
buffer
®® 
.
®® 
WriteDouble
®® "
(
®®" #
v
®®# $
)
®®$ %
;
®®% &
}
¯¯ 
return
±± 
buffer
±± 
;
±± 
}
²² 	
public
·· 
static
·· 
IByteBuffer
·· ! 
UnreleasableBuffer
··" 4
(
··4 5
IByteBuffer
··5 @
buffer
··A G
)
··G H
=>
··I K
new
··L O$
UnreleasableByteBuffer
··P f
(
··f g
buffer
··g m
)
··m n
;
··n o
}
¸¸ 
}¹¹ øh
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class '
UnpooledByteBufferAllocator 3
:4 5'
AbstractByteBufferAllocator6 Q
,Q R.
"IByteBufferAllocatorMetricProviderS u
{ 
readonly -
!UnpooledByteBufferAllocatorMetric 2
metric3 9
=: ;
new< ?-
!UnpooledByteBufferAllocatorMetric@ a
(a b
)b c
;c d
readonly 
bool 
disableLeakDetector )
;) *
public 
static 
readonly '
UnpooledByteBufferAllocator :
Default; B
=C D
new '
UnpooledByteBufferAllocator +
(+ ,
PlatformDependent, =
.= >!
DirectBufferPreferred> S
)S T
;T U
public '
UnpooledByteBufferAllocator *
(* +
)+ ,
: 
this 
( 
false 
, 
false 
)  
{ 	
} 	
public 
unsafe '
UnpooledByteBufferAllocator 1
(1 2
bool2 6
preferDirect7 C
)C D
: 
this 
( 
preferDirect 
,  
false! &
)& '
{ 	
} 	
public 
unsafe '
UnpooledByteBufferAllocator 1
(1 2
bool2 6
preferDirect7 C
,C D
boolE I
disableLeakDetectorJ ]
)] ^
:   
base   
(   
preferDirect   
)    
{!! 	
this"" 
."" 
disableLeakDetector"" $
=""% &
disableLeakDetector""' :
;"": ;
}## 	
	protected%% 
override%% 
IByteBuffer%% &
NewHeapBuffer%%' 4
(%%4 5
int%%5 8
initialCapacity%%9 H
,%%H I
int%%J M
maxCapacity%%N Y
)%%Y Z
=>%%[ ]
new&& .
"InstrumentedUnpooledHeapByteBuffer&& 2
(&&2 3
this&&3 7
,&&7 8
initialCapacity&&9 H
,&&H I
maxCapacity&&J U
)&&U V
;&&V W
	protected(( 
unsafe(( 
override(( !
IByteBuffer((" -
NewDirectBuffer((. =
(((= >
int((> A
initialCapacity((B Q
,((Q R
int((S V
maxCapacity((W b
)((b c
{)) 	
IByteBuffer** 
buf** 
=** 
new** !6
*InstrumentedUnpooledUnsafeDirectByteBuffer**" L
(**L M
this**M Q
,**Q R
initialCapacity**S b
,**b c
maxCapacity**d o
)**o p
;**p q
return++ 
this++ 
.++ 
disableLeakDetector++ +
?++, -
buf++. 1
:++2 3
ToLeakAwareBuffer++4 E
(++E F
buf++F I
)++I J
;++J K
},, 	
public.. 
override.. 
CompositeByteBuffer.. +
CompositeHeapBuffer.., ?
(..? @
int..@ C
maxNumComponents..D T
)..T U
{// 	
var00 
buf00 
=00 
new00 
CompositeByteBuffer00 -
(00- .
this00. 2
,002 3
false004 9
,009 :
maxNumComponents00; K
)00K L
;00L M
return11 
this11 
.11 
disableLeakDetector11 +
?11, -
buf11. 1
:112 3
ToLeakAwareBuffer114 E
(11E F
buf11F I
)11I J
;11J K
}22 	
public44 
unsafe44 
override44 
CompositeByteBuffer44 2!
CompositeDirectBuffer443 H
(44H I
int44I L
maxNumComponents44M ]
)44] ^
{55 	
var66 
buf66 
=66 
new66 
CompositeByteBuffer66 -
(66- .
this66. 2
,662 3
true664 8
,668 9
maxNumComponents66: J
)66J K
;66K L
return77 
this77 
.77 
disableLeakDetector77 +
?77, -
buf77. 1
:772 3
ToLeakAwareBuffer774 E
(77E F
buf77F I
)77I J
;77J K
}88 	
public:: 
override:: 
bool::  
IsDirectBufferPooled:: 1
=>::2 4
false::5 :
;::: ;
public<< &
IByteBufferAllocatorMetric<< )
Metric<<* 0
=><<1 3
this<<4 8
.<<8 9
metric<<9 ?
;<<? @
internal>> 
void>> 
IncrementDirect>> %
(>>% &
int>>& )
amount>>* 0
)>>0 1
=>>>2 4
this>>5 9
.>>9 :
metric>>: @
.>>@ A
DirectCounter>>A N
(>>N O
amount>>O U
)>>U V
;>>V W
internal@@ 
void@@ 
DecrementDirect@@ %
(@@% &
int@@& )
amount@@* 0
)@@0 1
=>@@2 4
this@@5 9
.@@9 :
metric@@: @
.@@@ A
DirectCounter@@A N
(@@N O
-@@O P
amount@@P V
)@@V W
;@@W X
internalBB 
voidBB 
IncrementHeapBB #
(BB# $
intBB$ '
amountBB( .
)BB. /
=>BB0 2
thisBB3 7
.BB7 8
metricBB8 >
.BB> ?
HeapCounterBB? J
(BBJ K
amountBBK Q
)BBQ R
;BBR S
internalDD 
voidDD 
DecrementHeapDD #
(DD# $
intDD$ '
amountDD( .
)DD. /
=>DD0 2
thisDD3 7
.DD7 8
metricDD8 >
.DD> ?
HeapCounterDD? J
(DDJ K
-DDK L
amountDDL R
)DDR S
;DDS T
sealedFF 
classFF .
"InstrumentedUnpooledHeapByteBufferFF 7
:FF8 9"
UnpooledHeapByteBufferFF: P
{GG 	
internalHH .
"InstrumentedUnpooledHeapByteBufferHH 7
(HH7 8'
UnpooledByteBufferAllocatorII +
allocII, 1
,II1 2
intII3 6
initialCapacityII7 F
,IIF G
intIIH K
maxCapacityIIL W
)IIW X
:JJ 
baseJJ 
(JJ 
allocJJ 
,JJ 
initialCapacityJJ -
,JJ- .
maxCapacityJJ/ :
)JJ: ;
{KK 
(LL 
(LL '
UnpooledByteBufferAllocatorLL -
)LL- .
thisLL. 2
.LL2 3
	AllocatorLL3 <
)LL< =
.LL= >
IncrementHeapLL> K
(LLK L
initialCapacityLLL [
)LL[ \
;LL\ ]
}MM 
	protectedOO 
overrideOO 
byteOO #
[OO# $
]OO$ %
AllocateArrayOO& 3
(OO3 4
intOO4 7
initialCapacityOO8 G
)OOG H
{PP 
byteQQ 
[QQ 
]QQ 
bytesQQ 
=QQ 
baseQQ #
.QQ# $
AllocateArrayQQ$ 1
(QQ1 2
initialCapacityQQ2 A
)QQA B
;QQB C
(RR 
(RR '
UnpooledByteBufferAllocatorRR -
)RR- .
thisRR. 2
.RR2 3
	AllocatorRR3 <
)RR< =
.RR= >
IncrementHeapRR> K
(RRK L
bytesRRL Q
.RRQ R
LengthRRR X
)RRX Y
;RRY Z
returnSS 
bytesSS 
;SS 
}TT 
	protectedVV 
overrideVV 
voidVV #
	FreeArrayVV$ -
(VV- .
byteVV. 2
[VV2 3
]VV3 4
bytesVV5 :
)VV: ;
{WW 
intXX 
lengthXX 
=XX 
bytesXX "
.XX" #
LengthXX# )
;XX) *
baseYY 
.YY 
	FreeArrayYY 
(YY 
bytesYY $
)YY$ %
;YY% &
(ZZ 
(ZZ '
UnpooledByteBufferAllocatorZZ -
)ZZ- .
thisZZ. 2
.ZZ2 3
	AllocatorZZ3 <
)ZZ< =
.ZZ= >
DecrementHeapZZ> K
(ZZK L
lengthZZL R
)ZZR S
;ZZS T
}[[ 
}\\ 	
sealed^^ 
class^^ 6
*InstrumentedUnpooledUnsafeDirectByteBuffer^^ ?
:^^@ A*
UnpooledUnsafeDirectByteBuffer^^B `
{__ 	
internal`` 6
*InstrumentedUnpooledUnsafeDirectByteBuffer`` ?
(``? @'
UnpooledByteBufferAllocatoraa +
allocaa, 1
,aa1 2
intaa3 6
initialCapacityaa7 F
,aaF G
intaaH K
maxCapacityaaL W
)aaW X
:bb 
basebb 
(bb 
allocbb 
,bb 
initialCapacitybb -
,bb- .
maxCapacitybb/ :
)bb: ;
{cc 
(dd 
(dd '
UnpooledByteBufferAllocatordd -
)dd- .
thisdd. 2
.dd2 3
	Allocatordd3 <
)dd< =
.dd= >
IncrementDirectdd> M
(ddM N
initialCapacityddN ]
)dd] ^
;dd^ _
}ee 
	protectedgg 
overridegg 
bytegg #
[gg# $
]gg$ %
AllocateDirectgg& 4
(gg4 5
intgg5 8
initialCapacitygg9 H
)ggH I
{hh 
byteii 
[ii 
]ii 
bytesii 
=ii 
baseii #
.ii# $
AllocateDirectii$ 2
(ii2 3
initialCapacityii3 B
)iiB C
;iiC D
(jj 
(jj '
UnpooledByteBufferAllocatorjj -
)jj- .
thisjj. 2
.jj2 3
	Allocatorjj3 <
)jj< =
.jj= >
IncrementDirectjj> M
(jjM N
bytesjjN S
.jjS T
LengthjjT Z
)jjZ [
;jj[ \
returnkk 
byteskk 
;kk 
}ll 
	protectednn 
overridenn 
voidnn #

FreeDirectnn$ .
(nn. /
bytenn/ 3
[nn3 4
]nn4 5
arraynn6 ;
)nn; <
{oo 
intpp 
capacitypp 
=pp 
arraypp $
.pp$ %
Lengthpp% +
;pp+ ,
baseqq 
.qq 

FreeDirectqq 
(qq  
arrayqq  %
)qq% &
;qq& '
(rr 
(rr '
UnpooledByteBufferAllocatorrr -
)rr- .
thisrr. 2
.rr2 3
	Allocatorrr3 <
)rr< =
.rr= >
DecrementDirectrr> M
(rrM N
capacityrrN V
)rrV W
;rrW X
}ss 
}tt 	
sealedvv 
classvv -
!UnpooledByteBufferAllocatorMetricvv 6
:vv7 8&
IByteBufferAllocatorMetricvv9 S
{ww 	
longxx 
usedHeapMemoryxx 
;xx  
longyy 
userDirectMemoryyy !
;yy! "
public{{ 
long{{ 
UsedHeapMemory{{ &
=>{{' )
Volatile{{* 2
.{{2 3
Read{{3 7
({{7 8
ref{{8 ;
this{{< @
.{{@ A
usedHeapMemory{{A O
){{O P
;{{P Q
public}} 
long}} 
UsedDirectMemory}} (
=>}}) +
Volatile}}, 4
.}}4 5
Read}}5 9
(}}9 :
ref}}: =
this}}> B
.}}B C
userDirectMemory}}C S
)}}S T
;}}T U
public 
void 
HeapCounter #
(# $
int$ '
amount( .
). /
=>0 2
Interlocked3 >
.> ?
Add? B
(B C
refC F
thisG K
.K L
usedHeapMemoryL Z
,Z [
amount\ b
)b c
;c d
public
 
void
 
DirectCounter
 %
(
% &
int
& )
amount
* 0
)
0 1
=>
2 4
Interlocked
5 @
.
@ A
Add
A D
(
D E
ref
E H
this
I M
.
M N
userDirectMemory
N ^
,
^ _
amount
` f
)
f g
;
g h
public
ƒƒ 
override
ƒƒ 
string
ƒƒ "
ToString
ƒƒ# +
(
ƒƒ+ ,
)
ƒƒ, -
=>
ƒƒ. 0
$"
ƒƒ1 3
{
ƒƒ3 4

StringUtil
ƒƒ4 >
.
ƒƒ> ?
SimpleClassName
ƒƒ? N
(
ƒƒN O
this
ƒƒO S
)
ƒƒS T
}
ƒƒT U
$str
ƒƒU g
{
ƒƒg h
this
ƒƒh l
.
ƒƒl m
UsedHeapMemory
ƒƒm {
}
ƒƒ{ |
$strƒƒ| 
{ƒƒ ‘
thisƒƒ‘ •
.ƒƒ• – 
UsedDirectMemoryƒƒ– ¦
}ƒƒ¦ §
$strƒƒ§ ¨
"ƒƒ¨ ©
;ƒƒ© ª
}
„„ 	
}
…… 
}†† ù“
oC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledDuplicatedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	(
UnpooledDuplicatedByteBuffer
 &
:' (%
AbstractDerivedByteBuffer) B
{ 
readonly 
AbstractByteBuffer #
buffer$ *
;* +
public (
UnpooledDuplicatedByteBuffer +
(+ ,
AbstractByteBuffer, >
buffer? E
)E F
: 
this 
( 
buffer 
, 
buffer !
.! "
ReaderIndex" -
,- .
buffer/ 5
.5 6
WriterIndex6 A
)A B
{ 	
} 	
internal (
UnpooledDuplicatedByteBuffer -
(- .
AbstractByteBuffer. @
bufferA G
,G H
intI L
readerIndexM X
,X Y
intZ ]
writerIndex^ i
)i j
: 
base 
( 
buffer 
. 
MaxCapacity %
)% &
{ 	
if 
( 
buffer 
is (
UnpooledDuplicatedByteBuffer 6

duplicated7 A
)A B
{ 
this 
. 
buffer 
= 

duplicated (
.( )
buffer) /
;/ 0
} 
else 
if 
( 
buffer 
is +
AbstractPooledDerivedByteBuffer >
)> ?
{ 
this 
. 
buffer 
= 
( 
AbstractByteBuffer 1
)1 2
buffer2 8
.8 9
Unwrap9 ?
(? @
)@ A
;A B
} 
else   
{!! 
this"" 
."" 
buffer"" 
="" 
buffer"" $
;""$ %
}## 
this%% 
.%% 
	SetIndex0%% 
(%% 
readerIndex%% &
,%%& '
writerIndex%%( 3
)%%3 4
;%%4 5
this&& 
.&& 
	MarkIndex&& 
(&& 
)&& 
;&& 
}'' 	
public)) 
override)) 
IByteBuffer)) #
Unwrap))$ *
())* +
)))+ ,
=>))- /
this))0 4
.))4 5

UnwrapCore))5 ?
())? @
)))@ A
;))A B
public++ 
override++ 
IByteBuffer++ #
Copy++$ (
(++( )
int++) ,
index++- 2
,++2 3
int++4 7
length++8 >
)++> ?
=>++@ B
this++C G
.++G H
Unwrap++H N
(++N O
)++O P
.++P Q
Copy++Q U
(++U V
index++V [
,++[ \
length++] c
)++c d
;++d e
	protected-- 
AbstractByteBuffer-- $

UnwrapCore--% /
(--/ 0
)--0 1
=>--2 4
this--5 9
.--9 :
buffer--: @
;--@ A
public// 
override//  
IByteBufferAllocator// ,
	Allocator//- 6
=>//7 9
this//: >
.//> ?
Unwrap//? E
(//E F
)//F G
.//G H
	Allocator//H Q
;//Q R
public11 
override11 
bool11 
IsDirect11 %
=>11& (
this11) -
.11- .
Unwrap11. 4
(114 5
)115 6
.116 7
IsDirect117 ?
;11? @
public33 
override33 
int33 
Capacity33 $
=>33% '
this33( ,
.33, -
Unwrap33- 3
(333 4
)334 5
.335 6
Capacity336 >
;33> ?
public55 
override55 
IByteBuffer55 #
AdjustCapacity55$ 2
(552 3
int553 6
newCapacity557 B
)55B C
=>55D F
this55G K
.55K L
Unwrap55L R
(55R S
)55S T
.55T U
AdjustCapacity55U c
(55c d
newCapacity55d o
)55o p
;55p q
public77 
override77 
int77 
IoBufferCount77 )
=>77* ,
this77- 1
.771 2
Unwrap772 8
(778 9
)779 :
.77: ;
IoBufferCount77; H
;77H I
public99 
override99 
bool99 
HasArray99 %
=>99& (
this99) -
.99- .
Unwrap99. 4
(994 5
)995 6
.996 7
HasArray997 ?
;99? @
public;; 
override;; 
byte;; 
[;; 
];; 
Array;; $
=>;;% '
this;;( ,
.;;, -
Unwrap;;- 3
(;;3 4
);;4 5
.;;5 6
Array;;6 ;
;;;; <
public== 
override== 
int== 
ArrayOffset== '
=>==( *
this==+ /
.==/ 0
Unwrap==0 6
(==6 7
)==7 8
.==8 9
ArrayOffset==9 D
;==D E
public?? 
override?? 
bool?? 
HasMemoryAddress?? -
=>??. 0
this??1 5
.??5 6
Unwrap??6 <
(??< =
)??= >
.??> ?
HasMemoryAddress??? O
;??O P
publicAA 
overrideAA 
refAA 
byteAA  $
GetPinnableMemoryAddressAA! 9
(AA9 :
)AA: ;
=>AA< >
refAA? B
thisAAC G
.AAG H
UnwrapAAH N
(AAN O
)AAO P
.AAP Q$
GetPinnableMemoryAddressAAQ i
(AAi j
)AAj k
;AAk l
publicCC 
overrideCC 
IntPtrCC !
AddressOfPinnedMemoryCC 4
(CC4 5
)CC5 6
=>CC7 9
thisCC: >
.CC> ?
UnwrapCC? E
(CCE F
)CCF G
.CCG H!
AddressOfPinnedMemoryCCH ]
(CC] ^
)CC^ _
;CC_ `
	protectedEE 
internalEE 
overrideEE #
byteEE$ (
_GetByteEE) 1
(EE1 2
intEE2 5
indexEE6 ;
)EE; <
=>EE= ?
thisEE@ D
.EED E

UnwrapCoreEEE O
(EEO P
)EEP Q
.EEQ R
_GetByteEER Z
(EEZ [
indexEE[ `
)EE` a
;EEa b
	protectedGG 
internalGG 
overrideGG #
shortGG$ )
	_GetShortGG* 3
(GG3 4
intGG4 7
indexGG8 =
)GG= >
=>GG? A
thisGGB F
.GGF G

UnwrapCoreGGG Q
(GGQ R
)GGR S
.GGS T
	_GetShortGGT ]
(GG] ^
indexGG^ c
)GGc d
;GGd e
	protectedII 
internalII 
overrideII #
shortII$ )
_GetShortLEII* 5
(II5 6
intII6 9
indexII: ?
)II? @
=>IIA C
thisIID H
.IIH I

UnwrapCoreIII S
(IIS T
)IIT U
.IIU V
_GetShortLEIIV a
(IIa b
indexIIb g
)IIg h
;IIh i
	protectedKK 
internalKK 
overrideKK #
intKK$ '
_GetUnsignedMediumKK( :
(KK: ;
intKK; >
indexKK? D
)KKD E
=>KKF H
thisKKI M
.KKM N

UnwrapCoreKKN X
(KKX Y
)KKY Z
.KKZ [
_GetUnsignedMediumKK[ m
(KKm n
indexKKn s
)KKs t
;KKt u
	protectedMM 
internalMM 
overrideMM #
intMM$ ' 
_GetUnsignedMediumLEMM( <
(MM< =
intMM= @
indexMMA F
)MMF G
=>MMH J
thisMMK O
.MMO P

UnwrapCoreMMP Z
(MMZ [
)MM[ \
.MM\ ] 
_GetUnsignedMediumLEMM] q
(MMq r
indexMMr w
)MMw x
;MMx y
	protectedOO 
internalOO 
overrideOO #
intOO$ '
_GetIntOO( /
(OO/ 0
intOO0 3
indexOO4 9
)OO9 :
=>OO; =
thisOO> B
.OOB C

UnwrapCoreOOC M
(OOM N
)OON O
.OOO P
_GetIntOOP W
(OOW X
indexOOX ]
)OO] ^
;OO^ _
	protectedQQ 
internalQQ 
overrideQQ #
intQQ$ '
	_GetIntLEQQ( 1
(QQ1 2
intQQ2 5
indexQQ6 ;
)QQ; <
=>QQ= ?
thisQQ@ D
.QQD E

UnwrapCoreQQE O
(QQO P
)QQP Q
.QQQ R
	_GetIntLEQQR [
(QQ[ \
indexQQ\ a
)QQa b
;QQb c
	protectedSS 
internalSS 
overrideSS #
longSS$ (
_GetLongSS) 1
(SS1 2
intSS2 5
indexSS6 ;
)SS; <
=>SS= ?
thisSS@ D
.SSD E

UnwrapCoreSSE O
(SSO P
)SSP Q
.SSQ R
_GetLongSSR Z
(SSZ [
indexSS[ `
)SS` a
;SSa b
	protectedUU 
internalUU 
overrideUU #
longUU$ (

_GetLongLEUU) 3
(UU3 4
intUU4 7
indexUU8 =
)UU= >
=>UU? A
thisUUB F
.UUF G

UnwrapCoreUUG Q
(UUQ R
)UUR S
.UUS T

_GetLongLEUUT ^
(UU^ _
indexUU_ d
)UUd e
;UUe f
publicWW 
overrideWW 
IByteBufferWW #
GetBytesWW$ ,
(WW, -
intWW- 0
indexWW1 6
,WW6 7
IByteBufferWW8 C
destinationWWD O
,WWO P
intWWQ T
dstIndexWWU ]
,WW] ^
intWW_ b
lengthWWc i
)WWi j
=>WWk m
thisWWn r
.WWr s
UnwrapWWs y
(WWy z
)WWz {
.WW{ |
GetBytes	WW| „
(
WW„ …
index
WW… Š
,
WWŠ ‹
destination
WWŒ —
,
WW— ˜
dstIndex
WW™ ¡
,
WW¡ ¢
length
WW£ ©
)
WW© ª
;
WWª «
publicYY 
overrideYY 
IByteBufferYY #
GetBytesYY$ ,
(YY, -
intYY- 0
indexYY1 6
,YY6 7
byteYY8 <
[YY< =
]YY= >
destinationYY? J
,YYJ K
intYYL O
dstIndexYYP X
,YYX Y
intYYZ ]
lengthYY^ d
)YYd e
=>YYf h
thisYYi m
.YYm n
UnwrapYYn t
(YYt u
)YYu v
.YYv w
GetBytesYYw 
(	YY €
index
YY€ …
,
YY… †
destination
YY‡ ’
,
YY’ “
dstIndex
YY” œ
,
YYœ 
length
YY ¤
)
YY¤ ¥
;
YY¥ ¦
public[[ 
override[[ 
IByteBuffer[[ #
GetBytes[[$ ,
([[, -
int[[- 0
index[[1 6
,[[6 7
Stream[[8 >
destination[[? J
,[[J K
int[[L O
length[[P V
)[[V W
=>[[X Z
this[[[ _
.[[_ `
Unwrap[[` f
([[f g
)[[g h
.[[h i
GetBytes[[i q
([[q r
index[[r w
,[[w x
destination	[[y „
,
[[„ …
length
[[† Œ
)
[[Œ 
;
[[ 
	protected]] 
internal]] 
override]] #
void]]$ (
_SetByte]]) 1
(]]1 2
int]]2 5
index]]6 ;
,]]; <
int]]= @
value]]A F
)]]F G
=>]]H J
this]]K O
.]]O P

UnwrapCore]]P Z
(]]Z [
)]][ \
.]]\ ]
_SetByte]]] e
(]]e f
index]]f k
,]]k l
value]]m r
)]]r s
;]]s t
	protected__ 
internal__ 
override__ #
void__$ (
	_SetShort__) 2
(__2 3
int__3 6
index__7 <
,__< =
int__> A
value__B G
)__G H
=>__I K
this__L P
.__P Q

UnwrapCore__Q [
(__[ \
)__\ ]
.__] ^
	_SetShort__^ g
(__g h
index__h m
,__m n
value__o t
)__t u
;__u v
	protectedaa 
internalaa 
overrideaa #
voidaa$ (
_SetShortLEaa) 4
(aa4 5
intaa5 8
indexaa9 >
,aa> ?
intaa@ C
valueaaD I
)aaI J
=>aaK M
thisaaN R
.aaR S

UnwrapCoreaaS ]
(aa] ^
)aa^ _
.aa_ `
_SetShortLEaa` k
(aak l
indexaal q
,aaq r
valueaas x
)aax y
;aay z
	protectedcc 
internalcc 
overridecc #
voidcc$ (

_SetMediumcc) 3
(cc3 4
intcc4 7
indexcc8 =
,cc= >
intcc? B
valueccC H
)ccH I
=>ccJ L
thisccM Q
.ccQ R

UnwrapCoreccR \
(cc\ ]
)cc] ^
.cc^ _

_SetMediumcc_ i
(cci j
indexccj o
,cco p
valueccq v
)ccv w
;ccw x
	protectedee 
internalee 
overrideee #
voidee$ (
_SetMediumLEee) 5
(ee5 6
intee6 9
indexee: ?
,ee? @
inteeA D
valueeeE J
)eeJ K
=>eeL N
thiseeO S
.eeS T

UnwrapCoreeeT ^
(ee^ _
)ee_ `
.ee` a
_SetMediumLEeea m
(eem n
indexeen s
,ees t
valueeeu z
)eez {
;ee{ |
publicgg 
overridegg 
IByteBuffergg #
SetBytesgg$ ,
(gg, -
intgg- 0
indexgg1 6
,gg6 7
IByteBuffergg8 C
srcggD G
,ggG H
intggI L
srcIndexggM U
,ggU V
intggW Z
lengthgg[ a
)gga b
=>ggc e
thisggf j
.ggj k
Unwrapggk q
(ggq r
)ggr s
.ggs t
SetBytesggt |
(gg| }
index	gg} ‚
,
gg‚ ƒ
src
gg„ ‡
,
gg‡ ˆ
srcIndex
gg‰ ‘
,
gg‘ ’
length
gg“ ™
)
gg™ š
;
ggš ›
publicii 
overrideii 
Taskii 
<ii 
intii  
>ii  !
SetBytesAsyncii" /
(ii/ 0
intii0 3
indexii4 9
,ii9 :
Streamii; A
srciiB E
,iiE F
intiiG J
lengthiiK Q
,iiQ R
CancellationTokeniiS d
cancellationTokeniie v
)iiv w
=>iix z
thisii{ 
.	ii €
Unwrap
ii€ †
(
ii† ‡
)
ii‡ ˆ
.
iiˆ ‰
SetBytesAsync
ii‰ –
(
ii– —
index
ii— œ
,
iiœ 
src
ii ¡
,
ii¡ ¢
length
ii£ ©
,
ii© ª
cancellationToken
ii« ¼
)
ii¼ ½
;
ii½ ¾
publickk 
overridekk 
IByteBufferkk #
SetByteskk$ ,
(kk, -
intkk- 0
indexkk1 6
,kk6 7
bytekk8 <
[kk< =
]kk= >
srckk? B
,kkB C
intkkD G
srcIndexkkH P
,kkP Q
intkkR U
lengthkkV \
)kk\ ]
=>kk^ `
thiskka e
.kke f
Unwrapkkf l
(kkl m
)kkm n
.kkn o
SetByteskko w
(kkw x
indexkkx }
,kk} ~
src	kk ‚
,
kk‚ ƒ
srcIndex
kk„ Œ
,
kkŒ 
length
kk ”
)
kk” •
;
kk• –
	protectedmm 
internalmm 
overridemm #
voidmm$ (
_SetIntmm) 0
(mm0 1
intmm1 4
indexmm5 :
,mm: ;
intmm< ?
valuemm@ E
)mmE F
=>mmG I
thismmJ N
.mmN O

UnwrapCoremmO Y
(mmY Z
)mmZ [
.mm[ \
_SetIntmm\ c
(mmc d
indexmmd i
,mmi j
valuemmk p
)mmp q
;mmq r
	protectedoo 
internaloo 
overrideoo #
voidoo$ (
	_SetIntLEoo) 2
(oo2 3
intoo3 6
indexoo7 <
,oo< =
intoo> A
valueooB G
)ooG H
=>ooI K
thisooL P
.ooP Q

UnwrapCoreooQ [
(oo[ \
)oo\ ]
.oo] ^
	_SetIntLEoo^ g
(oog h
indexooh m
,oom n
valueooo t
)oot u
;oou v
	protectedqq 
internalqq 
overrideqq #
voidqq$ (
_SetLongqq) 1
(qq1 2
intqq2 5
indexqq6 ;
,qq; <
longqq= A
valueqqB G
)qqG H
=>qqI K
thisqqL P
.qqP Q

UnwrapCoreqqQ [
(qq[ \
)qq\ ]
.qq] ^
_SetLongqq^ f
(qqf g
indexqqg l
,qql m
valueqqn s
)qqs t
;qqt u
	protectedss 
internalss 
overridess #
voidss$ (

_SetLongLEss) 3
(ss3 4
intss4 7
indexss8 =
,ss= >
longss? C
valuessD I
)ssI J
=>ssK M
thisssN R
.ssR S

UnwrapCoressS ]
(ss] ^
)ss^ _
.ss_ `

_SetLongLEss` j
(ssj k
indexssk p
,ssp q
valuessr w
)ssw x
;ssx y
publicuu 
overrideuu 
intuu 
ForEachByteuu '
(uu' (
intuu( +
indexuu, 1
,uu1 2
intuu3 6
lengthuu7 =
,uu= >
IByteProcessoruu? M
	processoruuN W
)uuW X
=>uuY [
thisuu\ `
.uu` a
Unwrapuua g
(uug h
)uuh i
.uui j
ForEachByteuuj u
(uuu v
indexuuv {
,uu{ |
length	uu} ƒ
,
uuƒ „
	processor
uu… 
)
uu 
;
uu 
publicww 
overrideww 
intww 
ForEachByteDescww +
(ww+ ,
intww, /
indexww0 5
,ww5 6
intww7 :
lengthww; A
,wwA B
IByteProcessorwwC Q
	processorwwR [
)ww[ \
=>ww] _
thisww` d
.wwd e
Unwrapwwe k
(wwk l
)wwl m
.wwm n
ForEachByteDescwwn }
(ww} ~
index	ww~ ƒ
,
wwƒ „
length
ww… ‹
,
ww‹ Œ
	processor
ww –
)
ww– —
;
ww— ˜
}xx 
}yy ¡À
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledHeapByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class "
UnpooledHeapByteBuffer '
:( ).
"AbstractReferenceCountedByteBuffer* L
{ 
readonly  
IByteBufferAllocator %
	allocator& /
;/ 0
byte 
[ 
] 
array 
; 
	protected 
internal "
UnpooledHeapByteBuffer 1
(1 2 
IByteBufferAllocator2 F
allocG L
,L M
intN Q
initialCapacityR a
,a b
intc f
maxCapacityg r
)r s
: 
base 
( 
maxCapacity 
) 
{ 	
Contract 
. 
Requires 
( 
alloc #
!=$ &
null' +
)+ ,
;, -
Contract 
. 
Requires 
( 
initialCapacity -
<=. 0
maxCapacity1 <
)< =
;= >
this 
. 
	allocator 
= 
alloc "
;" #
this 
. 
SetArray 
( 
this 
. 
NewArray '
(' (
initialCapacity( 7
)7 8
)8 9
;9 :
this 
. 
	SetIndex0 
( 
$num 
, 
$num 
)  
;  !
} 	
	protected 
internal "
UnpooledHeapByteBuffer 1
(1 2 
IByteBufferAllocator2 F
allocG L
,L M
byteN R
[R S
]S T
initialArrayU a
,a b
intc f
maxCapacityg r
)r s
: 
base 
( 
maxCapacity 
) 
{   	
Contract!! 
.!! 
Requires!! 
(!! 
alloc!! #
!=!!$ &
null!!' +
)!!+ ,
;!!, -
Contract"" 
."" 
Requires"" 
("" 
initialArray"" *
!=""+ -
null"". 2
)""2 3
;""3 4
if$$ 
($$ 
initialArray$$ 
.$$ 
Length$$ #
>$$$ %
maxCapacity$$& 1
)$$1 2
{%% 
throw&& 
new&& 
ArgumentException&& +
(&&+ ,
$"&&, .
$str&&. >
{&&> ?
initialArray&&? K
.&&K L
Length&&L R
}&&R S
$str&&S c
{&&c d
maxCapacity&&d o
}&&o p
$str&&p q
"&&q r
)&&r s
;&&s t
}'' 
this)) 
.)) 
	allocator)) 
=)) 
alloc)) "
;))" #
this** 
.** 
SetArray** 
(** 
initialArray** &
)**& '
;**' (
this++ 
.++ 
	SetIndex0++ 
(++ 
$num++ 
,++ 
initialArray++ *
.++* +
Length+++ 1
)++1 2
;++2 3
},, 	
	protected.. 
virtual.. 
byte.. 
[.. 
]..  
AllocateArray..! .
(... /
int../ 2
initialCapacity..3 B
)..B C
=>..D F
this..G K
...K L
NewArray..L T
(..T U
initialCapacity..U d
)..d e
;..e f
	protected00 
byte00 
[00 
]00 
NewArray00 !
(00! "
int00" %
initialCapacity00& 5
)005 6
=>007 9
new00: =
byte00> B
[00B C
initialCapacity00C R
]00R S
;00S T
	protected22 
virtual22 
void22 
	FreeArray22 (
(22( )
byte22) -
[22- .
]22. /
bytes220 5
)225 6
{33 	
}55 	
	protected77 
void77 
SetArray77 
(77  
byte77  $
[77$ %
]77% &
initialArray77' 3
)773 4
=>775 7
this778 <
.77< =
array77= B
=77C D
initialArray77E Q
;77Q R
public99 
override99  
IByteBufferAllocator99 ,
	Allocator99- 6
=>997 9
this99: >
.99> ?
	allocator99? H
;99H I
public;; 
override;; 
bool;; 
IsDirect;; %
=>;;& (
false;;) .
;;;. /
public== 
override== 
int== 
Capacity== $
{>> 	
get?? 
{@@ 
thisAA 
.AA 
EnsureAccessibleAA %
(AA% &
)AA& '
;AA' (
returnBB 
thisBB 
.BB 
arrayBB !
.BB! "
LengthBB" (
;BB( )
}CC 
}DD 	
publicFF 
overrideFF 
IByteBufferFF #
AdjustCapacityFF$ 2
(FF2 3
intFF3 6
newCapacityFF7 B
)FFB C
{GG 	
thisHH 
.HH 
CheckNewCapacityHH !
(HH! "
newCapacityHH" -
)HH- .
;HH. /
intJJ 
oldCapacityJJ 
=JJ 
thisJJ "
.JJ" #
arrayJJ# (
.JJ( )
LengthJJ) /
;JJ/ 0
byteKK 
[KK 
]KK 
oldArrayKK 
=KK 
thisKK "
.KK" #
arrayKK# (
;KK( )
ifLL 
(LL 
newCapacityLL 
>LL 
oldCapacityLL )
)LL) *
{MM 
byteNN 
[NN 
]NN 
newArrayNN 
=NN  !
thisNN" &
.NN& '
AllocateArrayNN' 4
(NN4 5
newCapacityNN5 @
)NN@ A
;NNA B
PlatformDependentOO !
.OO! "

CopyMemoryOO" ,
(OO, -
thisOO- 1
.OO1 2
arrayOO2 7
,OO7 8
$numOO9 :
,OO: ;
newArrayOO< D
,OOD E
$numOOF G
,OOG H
oldCapacityOOI T
)OOT U
;OOU V
thisQQ 
.QQ 
SetArrayQQ 
(QQ 
newArrayQQ &
)QQ& '
;QQ' (
thisRR 
.RR 
	FreeArrayRR 
(RR 
oldArrayRR '
)RR' (
;RR( )
}SS 
elseTT 
ifTT 
(TT 
newCapacityTT  
<TT! "
oldCapacityTT# .
)TT. /
{UU 
byteVV 
[VV 
]VV 
newArrayVV 
=VV  !
thisVV" &
.VV& '
AllocateArrayVV' 4
(VV4 5
newCapacityVV5 @
)VV@ A
;VVA B
intWW 
readerIndexWW 
=WW  !
thisWW" &
.WW& '
ReaderIndexWW' 2
;WW2 3
ifXX 
(XX 
readerIndexXX 
<XX  !
newCapacityXX" -
)XX- .
{YY 
intZZ 
writerIndexZZ #
=ZZ$ %
thisZZ& *
.ZZ* +
WriterIndexZZ+ 6
;ZZ6 7
if[[ 
([[ 
writerIndex[[ #
>[[$ %
newCapacity[[& 1
)[[1 2
{\\ 
this]] 
.]] 
SetWriterIndex0]] ,
(]], -
writerIndex]]- 8
=]]9 :
newCapacity]]; F
)]]F G
;]]G H
}^^ 
PlatformDependent`` %
.``% &

CopyMemory``& 0
(``0 1
this``1 5
.``5 6
array``6 ;
,``; <
readerIndex``= H
,``H I
newArray``J R
,``R S
$num``T U
,``U V
writerIndex``W b
-``c d
readerIndex``e p
)``p q
;``q r
}aa 
elsebb 
{cc 
thisdd 
.dd 
SetIndexdd !
(dd! "
newCapacitydd" -
,dd- .
newCapacitydd/ :
)dd: ;
;dd; <
}ee 
thisgg 
.gg 
SetArraygg 
(gg 
newArraygg &
)gg& '
;gg' (
thishh 
.hh 
	FreeArrayhh 
(hh 
oldArrayhh '
)hh' (
;hh( )
}ii 
returnjj 
thisjj 
;jj 
}kk 	
publicmm 
overridemm 
boolmm 
HasArraymm %
=>mm& (
truemm) -
;mm- .
publicoo 
overrideoo 
byteoo 
[oo 
]oo 
Arrayoo $
{pp 	
getqq 
{rr 
thisss 
.ss 
EnsureAccessibless %
(ss% &
)ss& '
;ss' (
returntt 
thistt 
.tt 
arraytt !
;tt! "
}uu 
}vv 	
publicxx 
overridexx 
intxx 
ArrayOffsetxx '
=>xx( *
$numxx+ ,
;xx, -
publiczz 
overridezz 
boolzz 
HasMemoryAddresszz -
=>zz. 0
truezz1 5
;zz5 6
public|| 
override|| 
ref|| 
byte||  $
GetPinnableMemoryAddress||! 9
(||9 :
)||: ;
{}} 	
this~~ 
.~~ 
EnsureAccessible~~ !
(~~! "
)~~" #
;~~# $
return 
ref 
this 
. 
array !
[! "
$num" #
]# $
;$ %
}
€€ 	
public
‚‚ 
override
‚‚ 
IntPtr
‚‚ #
AddressOfPinnedMemory
‚‚ 4
(
‚‚4 5
)
‚‚5 6
=>
‚‚7 9
IntPtr
‚‚: @
.
‚‚@ A
Zero
‚‚A E
;
‚‚E F
public
„„ 
override
„„ 
IByteBuffer
„„ #
GetBytes
„„$ ,
(
„„, -
int
„„- 0
index
„„1 6
,
„„6 7
IByteBuffer
„„8 C
dst
„„D G
,
„„G H
int
„„I L
dstIndex
„„M U
,
„„U V
int
„„W Z
length
„„[ a
)
„„a b
{
…… 	
this
†† 
.
†† 
CheckDstIndex
†† 
(
†† 
index
†† $
,
††$ %
length
††& ,
,
††, -
dstIndex
††. 6
,
††6 7
dst
††8 ;
.
††; <
Capacity
††< D
)
††D E
;
††E F
if
‡‡ 
(
‡‡ 
dst
‡‡ 
.
‡‡ 
HasArray
‡‡ 
)
‡‡ 
{
ˆˆ 
this
‰‰ 
.
‰‰ 
GetBytes
‰‰ 
(
‰‰ 
index
‰‰ #
,
‰‰# $
dst
‰‰% (
.
‰‰( )
Array
‰‰) .
,
‰‰. /
dst
‰‰0 3
.
‰‰3 4
ArrayOffset
‰‰4 ?
+
‰‰@ A
dstIndex
‰‰B J
,
‰‰J K
length
‰‰L R
)
‰‰R S
;
‰‰S T
}
ŠŠ 
else
‹‹ 
{
ŒŒ 
dst
 
.
 
SetBytes
 
(
 
dstIndex
 %
,
% &
this
' +
.
+ ,
array
, 1
,
1 2
index
3 8
,
8 9
length
: @
)
@ A
;
A B
}
 
return
 
this
 
;
 
}
‘‘ 	
public
““ 
override
““ 
IByteBuffer
““ #
GetBytes
““$ ,
(
““, -
int
““- 0
index
““1 6
,
““6 7
byte
““8 <
[
““< =
]
““= >
dst
““? B
,
““B C
int
““D G
dstIndex
““H P
,
““P Q
int
““R U
length
““V \
)
““\ ]
{
”” 	
this
•• 
.
•• 
CheckDstIndex
•• 
(
•• 
index
•• $
,
••$ %
length
••& ,
,
••, -
dstIndex
••. 6
,
••6 7
dst
••8 ;
.
••; <
Length
••< B
)
••B C
;
••C D
PlatformDependent
–– 
.
–– 

CopyMemory
–– (
(
––( )
this
––) -
.
––- .
array
––. 3
,
––3 4
index
––5 :
,
––: ;
dst
––< ?
,
––? @
dstIndex
––A I
,
––I J
length
––K Q
)
––Q R
;
––R S
return
—— 
this
—— 
;
—— 
}
˜˜ 	
public
šš 
override
šš 
IByteBuffer
šš #
GetBytes
šš$ ,
(
šš, -
int
šš- 0
index
šš1 6
,
šš6 7
Stream
šš8 >
destination
šš? J
,
ššJ K
int
ššL O
length
ššP V
)
ššV W
{
›› 	
this
œœ 
.
œœ 
EnsureAccessible
œœ !
(
œœ! "
)
œœ" #
;
œœ# $
destination
 
.
 
Write
 
(
 
this
 "
.
" #
Array
# (
,
( )
this
* .
.
. /
ArrayOffset
/ :
+
; <
index
= B
,
B C
length
D J
)
J K
;
K L
return
 
this
 
;
 
}
ŸŸ 	
public
¡¡ 
override
¡¡ 
IByteBuffer
¡¡ #
SetBytes
¡¡$ ,
(
¡¡, -
int
¡¡- 0
index
¡¡1 6
,
¡¡6 7
IByteBuffer
¡¡8 C
src
¡¡D G
,
¡¡G H
int
¡¡I L
srcIndex
¡¡M U
,
¡¡U V
int
¡¡W Z
length
¡¡[ a
)
¡¡a b
{
¢¢ 	
this
££ 
.
££ 
CheckSrcIndex
££ 
(
££ 
index
££ $
,
££$ %
length
££& ,
,
££, -
srcIndex
££. 6
,
££6 7
src
££8 ;
.
££; <
Capacity
££< D
)
££D E
;
££E F
if
¤¤ 
(
¤¤ 
src
¤¤ 
.
¤¤ 
HasArray
¤¤ 
)
¤¤ 
{
¥¥ 
this
¦¦ 
.
¦¦ 
SetBytes
¦¦ 
(
¦¦ 
index
¦¦ #
,
¦¦# $
src
¦¦% (
.
¦¦( )
Array
¦¦) .
,
¦¦. /
src
¦¦0 3
.
¦¦3 4
ArrayOffset
¦¦4 ?
+
¦¦@ A
srcIndex
¦¦B J
,
¦¦J K
length
¦¦L R
)
¦¦R S
;
¦¦S T
}
§§ 
else
¨¨ 
{
©© 
src
ªª 
.
ªª 
GetBytes
ªª 
(
ªª 
srcIndex
ªª %
,
ªª% &
this
ªª' +
.
ªª+ ,
array
ªª, 1
,
ªª1 2
index
ªª3 8
,
ªª8 9
length
ªª: @
)
ªª@ A
;
ªªA B
}
«« 
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
public
¯¯ 
override
¯¯ 
IByteBuffer
¯¯ #
SetBytes
¯¯$ ,
(
¯¯, -
int
¯¯- 0
index
¯¯1 6
,
¯¯6 7
byte
¯¯8 <
[
¯¯< =
]
¯¯= >
src
¯¯? B
,
¯¯B C
int
¯¯D G
srcIndex
¯¯H P
,
¯¯P Q
int
¯¯R U
length
¯¯V \
)
¯¯\ ]
{
°° 	
this
±± 
.
±± 
CheckSrcIndex
±± 
(
±± 
index
±± $
,
±±$ %
length
±±& ,
,
±±, -
srcIndex
±±. 6
,
±±6 7
src
±±8 ;
.
±±; <
Length
±±< B
)
±±B C
;
±±C D
PlatformDependent
²² 
.
²² 

CopyMemory
²² (
(
²²( )
src
²²) ,
,
²², -
srcIndex
²². 6
,
²²6 7
this
²²8 <
.
²²< =
array
²²= B
,
²²B C
index
²²D I
,
²²I J
length
²²K Q
)
²²Q R
;
²²R S
return
³³ 
this
³³ 
;
³³ 
}
´´ 	
public
¶¶ 
override
¶¶ 
async
¶¶ 
Task
¶¶ "
<
¶¶" #
int
¶¶# &
>
¶¶& '
SetBytesAsync
¶¶( 5
(
¶¶5 6
int
¶¶6 9
index
¶¶: ?
,
¶¶? @
Stream
¶¶A G
src
¶¶H K
,
¶¶K L
int
¶¶M P
length
¶¶Q W
,
¶¶W X
CancellationToken
¶¶Y j
cancellationToken
¶¶k |
)
¶¶| }
{
·· 	
this
¸¸ 
.
¸¸ 
EnsureAccessible
¸¸ !
(
¸¸! "
)
¸¸" #
;
¸¸# $
int
¹¹ 
	readTotal
¹¹ 
=
¹¹ 
$num
¹¹ 
;
¹¹ 
int
ºº 
read
ºº 
;
ºº 
int
»» 
offset
»» 
=
»» 
this
»» 
.
»» 
ArrayOffset
»» )
+
»»* +
index
»», 1
;
»»1 2
do
¼¼ 
{
½½ 
read
¾¾ 
=
¾¾ 
await
¾¾ 
src
¾¾  
.
¾¾  !
	ReadAsync
¾¾! *
(
¾¾* +
this
¾¾+ /
.
¾¾/ 0
Array
¾¾0 5
,
¾¾5 6
offset
¾¾7 =
+
¾¾> ?
	readTotal
¾¾@ I
,
¾¾I J
length
¾¾K Q
-
¾¾R S
	readTotal
¾¾T ]
,
¾¾] ^
cancellationToken
¾¾_ p
)
¾¾p q
;
¾¾q r
	readTotal
¿¿ 
+=
¿¿ 
read
¿¿ !
;
¿¿! "
}
ÀÀ 
while
ÁÁ 
(
ÁÁ 
read
ÁÁ 
>
ÁÁ 
$num
ÁÁ 
&&
ÁÁ 
	readTotal
ÁÁ (
<
ÁÁ) *
length
ÁÁ+ 1
)
ÁÁ1 2
;
ÁÁ2 3
return
ÃÃ 
	readTotal
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
public
ÆÆ 
override
ÆÆ 
int
ÆÆ 
IoBufferCount
ÆÆ )
=>
ÆÆ* ,
$num
ÆÆ- .
;
ÆÆ. /
public
ÈÈ 
override
ÈÈ 
ArraySegment
ÈÈ $
<
ÈÈ$ %
byte
ÈÈ% )
>
ÈÈ) *
GetIoBuffer
ÈÈ+ 6
(
ÈÈ6 7
int
ÈÈ7 :
index
ÈÈ; @
,
ÈÈ@ A
int
ÈÈB E
length
ÈÈF L
)
ÈÈL M
{
ÉÉ 	
this
ÊÊ 
.
ÊÊ 
EnsureAccessible
ÊÊ !
(
ÊÊ! "
)
ÊÊ" #
;
ÊÊ# $
return
ËË 
new
ËË 
ArraySegment
ËË #
<
ËË# $
byte
ËË$ (
>
ËË( )
(
ËË) *
this
ËË* .
.
ËË. /
array
ËË/ 4
,
ËË4 5
index
ËË6 ;
,
ËË; <
length
ËË= C
)
ËËC D
;
ËËD E
}
ÌÌ 	
public
ÎÎ 
override
ÎÎ 
ArraySegment
ÎÎ $
<
ÎÎ$ %
byte
ÎÎ% )
>
ÎÎ) *
[
ÎÎ* +
]
ÎÎ+ ,
GetIoBuffers
ÎÎ- 9
(
ÎÎ9 :
int
ÎÎ: =
index
ÎÎ> C
,
ÎÎC D
int
ÎÎE H
length
ÎÎI O
)
ÎÎO P
=>
ÎÎQ S
new
ÎÎT W
[
ÎÎW X
]
ÎÎX Y
{
ÎÎZ [
this
ÎÎ\ `
.
ÎÎ` a
GetIoBuffer
ÎÎa l
(
ÎÎl m
index
ÎÎm r
,
ÎÎr s
length
ÎÎt z
)
ÎÎz {
}
ÎÎ| }
;
ÎÎ} ~
public
ĞĞ 
override
ĞĞ 
byte
ĞĞ 
GetByte
ĞĞ $
(
ĞĞ$ %
int
ĞĞ% (
index
ĞĞ) .
)
ĞĞ. /
{
ÑÑ 	
this
ÒÒ 
.
ÒÒ 
EnsureAccessible
ÒÒ !
(
ÒÒ! "
)
ÒÒ" #
;
ÒÒ# $
return
ÓÓ 
this
ÓÓ 
.
ÓÓ 
_GetByte
ÓÓ  
(
ÓÓ  !
index
ÓÓ! &
)
ÓÓ& '
;
ÓÓ' (
}
ÔÔ 	
	protected
ÖÖ 
internal
ÖÖ 
override
ÖÖ #
byte
ÖÖ$ (
_GetByte
ÖÖ) 1
(
ÖÖ1 2
int
ÖÖ2 5
index
ÖÖ6 ;
)
ÖÖ; <
=>
ÖÖ= ? 
HeapByteBufferUtil
ÖÖ@ R
.
ÖÖR S
GetByte
ÖÖS Z
(
ÖÖZ [
this
ÖÖ[ _
.
ÖÖ_ `
array
ÖÖ` e
,
ÖÖe f
index
ÖÖg l
)
ÖÖl m
;
ÖÖm n
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
SetZero
ØØ$ +
(
ØØ+ ,
int
ØØ, /
index
ØØ0 5
,
ØØ5 6
int
ØØ7 :
length
ØØ; A
)
ØØA B
{
ÙÙ 	
this
ÚÚ 
.
ÚÚ 

CheckIndex
ÚÚ 
(
ÚÚ 
index
ÚÚ !
,
ÚÚ! "
length
ÚÚ# )
)
ÚÚ) *
;
ÚÚ* +
PlatformDependent
ÛÛ 
.
ÛÛ 
Clear
ÛÛ #
(
ÛÛ# $
this
ÛÛ$ (
.
ÛÛ( )
array
ÛÛ) .
,
ÛÛ. /
index
ÛÛ0 5
,
ÛÛ5 6
length
ÛÛ7 =
)
ÛÛ= >
;
ÛÛ> ?
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
İİ 	
public
ßß 
override
ßß 
short
ßß 
GetShort
ßß &
(
ßß& '
int
ßß' *
index
ßß+ 0
)
ßß0 1
{
àà 	
this
áá 
.
áá 
EnsureAccessible
áá !
(
áá! "
)
áá" #
;
áá# $
return
ââ 
this
ââ 
.
ââ 
	_GetShort
ââ !
(
ââ! "
index
ââ" '
)
ââ' (
;
ââ( )
}
ãã 	
	protected
åå 
internal
åå 
override
åå #
short
åå$ )
	_GetShort
åå* 3
(
åå3 4
int
åå4 7
index
åå8 =
)
åå= >
=>
åå? A 
HeapByteBufferUtil
ååB T
.
ååT U
GetShort
ååU ]
(
åå] ^
this
åå^ b
.
ååb c
array
ååc h
,
ååh i
index
ååj o
)
ååo p
;
ååp q
public
çç 
override
çç 
short
çç 

GetShortLE
çç (
(
çç( )
int
çç) ,
index
çç- 2
)
çç2 3
{
èè 	
this
éé 
.
éé 
EnsureAccessible
éé !
(
éé! "
)
éé" #
;
éé# $
return
êê 
this
êê 
.
êê 
_GetShortLE
êê #
(
êê# $
index
êê$ )
)
êê) *
;
êê* +
}
ëë 	
	protected
íí 
internal
íí 
override
íí #
short
íí$ )
_GetShortLE
íí* 5
(
íí5 6
int
íí6 9
index
íí: ?
)
íí? @
=>
ííA C 
HeapByteBufferUtil
ííD V
.
ííV W

GetShortLE
ííW a
(
íía b
this
ííb f
.
ííf g
array
ííg l
,
ííl m
index
íín s
)
íís t
;
íít u
public
ïï 
override
ïï 
int
ïï 
GetUnsignedMedium
ïï -
(
ïï- .
int
ïï. 1
index
ïï2 7
)
ïï7 8
{
ğğ 	
this
ññ 
.
ññ 
EnsureAccessible
ññ !
(
ññ! "
)
ññ" #
;
ññ# $
return
òò 
this
òò 
.
òò  
_GetUnsignedMedium
òò *
(
òò* +
index
òò+ 0
)
òò0 1
;
òò1 2
}
óó 	
	protected
õõ 
internal
õõ 
override
õõ #
int
õõ$ ' 
_GetUnsignedMedium
õõ( :
(
õõ: ;
int
õõ; >
index
õõ? D
)
õõD E
=>
õõF H 
HeapByteBufferUtil
õõI [
.
õõ[ \
GetUnsignedMedium
õõ\ m
(
õõm n
this
õõn r
.
õõr s
array
õõs x
,
õõx y
index
õõz 
)õõ €
;õõ€ 
public
÷÷ 
override
÷÷ 
int
÷÷ !
GetUnsignedMediumLE
÷÷ /
(
÷÷/ 0
int
÷÷0 3
index
÷÷4 9
)
÷÷9 :
{
øø 	
this
ùù 
.
ùù 
EnsureAccessible
ùù !
(
ùù! "
)
ùù" #
;
ùù# $
return
úú 
this
úú 
.
úú "
_GetUnsignedMediumLE
úú ,
(
úú, -
index
úú- 2
)
úú2 3
;
úú3 4
}
ûû 	
	protected
ıı 
internal
ıı 
override
ıı #
int
ıı$ '"
_GetUnsignedMediumLE
ıı( <
(
ıı< =
int
ıı= @
index
ııA F
)
ııF G
=>
ııH J 
HeapByteBufferUtil
ııK ]
.
ıı] ^!
GetUnsignedMediumLE
ıı^ q
(
ııq r
this
ıır v
.
ııv w
array
ııw |
,
ıı| }
indexıı~ ƒ
)ııƒ „
;ıı„ …
public
ÿÿ 
override
ÿÿ 
int
ÿÿ 
GetInt
ÿÿ "
(
ÿÿ" #
int
ÿÿ# &
index
ÿÿ' ,
)
ÿÿ, -
{
€€ 	
this
 
.
 
EnsureAccessible
 !
(
! "
)
" #
;
# $
return
‚‚ 
this
‚‚ 
.
‚‚ 
_GetInt
‚‚ 
(
‚‚  
index
‚‚  %
)
‚‚% &
;
‚‚& '
}
ƒƒ 	
	protected
…… 
internal
…… 
override
…… #
int
……$ '
_GetInt
……( /
(
……/ 0
int
……0 3
index
……4 9
)
……9 :
=>
……; = 
HeapByteBufferUtil
……> P
.
……P Q
GetInt
……Q W
(
……W X
this
……X \
.
……\ ]
array
……] b
,
……b c
index
……d i
)
……i j
;
……j k
public
‡‡ 
override
‡‡ 
int
‡‡ 
GetIntLE
‡‡ $
(
‡‡$ %
int
‡‡% (
index
‡‡) .
)
‡‡. /
{
ˆˆ 	
this
‰‰ 
.
‰‰ 
EnsureAccessible
‰‰ !
(
‰‰! "
)
‰‰" #
;
‰‰# $
return
ŠŠ 
this
ŠŠ 
.
ŠŠ 
	_GetIntLE
ŠŠ !
(
ŠŠ! "
index
ŠŠ" '
)
ŠŠ' (
;
ŠŠ( )
}
‹‹ 	
	protected
 
internal
 
override
 #
int
$ '
	_GetIntLE
( 1
(
1 2
int
2 5
index
6 ;
)
; <
=>
= ? 
HeapByteBufferUtil
@ R
.
R S
GetIntLE
S [
(
[ \
this
\ `
.
` a
array
a f
,
f g
index
h m
)
m n
;
n o
public
 
override
 
long
 
GetLong
 $
(
$ %
int
% (
index
) .
)
. /
{
 	
this
‘‘ 
.
‘‘ 
EnsureAccessible
‘‘ !
(
‘‘! "
)
‘‘" #
;
‘‘# $
return
’’ 
this
’’ 
.
’’ 
_GetLong
’’  
(
’’  !
index
’’! &
)
’’& '
;
’’' (
}
““ 	
	protected
•• 
internal
•• 
override
•• #
long
••$ (
_GetLong
••) 1
(
••1 2
int
••2 5
index
••6 ;
)
••; <
=>
••= ? 
HeapByteBufferUtil
••@ R
.
••R S
GetLong
••S Z
(
••Z [
this
••[ _
.
••_ `
array
••` e
,
••e f
index
••g l
)
••l m
;
••m n
public
—— 
override
—— 
long
—— 
	GetLongLE
—— &
(
——& '
int
——' *
index
——+ 0
)
——0 1
{
˜˜ 	
this
™™ 
.
™™ 
EnsureAccessible
™™ !
(
™™! "
)
™™" #
;
™™# $
return
šš 
this
šš 
.
šš 

_GetLongLE
šš "
(
šš" #
index
šš# (
)
šš( )
;
šš) *
}
›› 	
	protected
 
internal
 
override
 #
long
$ (

_GetLongLE
) 3
(
3 4
int
4 7
index
8 =
)
= >
=>
? A 
HeapByteBufferUtil
B T
.
T U
	GetLongLE
U ^
(
^ _
this
_ c
.
c d
array
d i
,
i j
index
k p
)
p q
;
q r
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ #
SetByte
ŸŸ$ +
(
ŸŸ+ ,
int
ŸŸ, /
index
ŸŸ0 5
,
ŸŸ5 6
int
ŸŸ7 :
value
ŸŸ; @
)
ŸŸ@ A
{
   	
this
¡¡ 
.
¡¡ 
EnsureAccessible
¡¡ !
(
¡¡! "
)
¡¡" #
;
¡¡# $
this
¢¢ 
.
¢¢ 
_SetByte
¢¢ 
(
¢¢ 
index
¢¢ 
,
¢¢  
value
¢¢! &
)
¢¢& '
;
¢¢' (
return
££ 
this
££ 
;
££ 
}
¤¤ 	
	protected
¦¦ 
internal
¦¦ 
override
¦¦ #
void
¦¦$ (
_SetByte
¦¦) 1
(
¦¦1 2
int
¦¦2 5
index
¦¦6 ;
,
¦¦; <
int
¦¦= @
value
¦¦A F
)
¦¦F G
=>
¦¦H J 
HeapByteBufferUtil
¦¦K ]
.
¦¦] ^
SetByte
¦¦^ e
(
¦¦e f
this
¦¦f j
.
¦¦j k
array
¦¦k p
,
¦¦p q
index
¦¦r w
,
¦¦w x
value
¦¦y ~
)
¦¦~ 
;¦¦ €
public
¨¨ 
override
¨¨ 
IByteBuffer
¨¨ #
SetShort
¨¨$ ,
(
¨¨, -
int
¨¨- 0
index
¨¨1 6
,
¨¨6 7
int
¨¨8 ;
value
¨¨< A
)
¨¨A B
{
©© 	
this
ªª 
.
ªª 
EnsureAccessible
ªª !
(
ªª! "
)
ªª" #
;
ªª# $
this
«« 
.
«« 
	_SetShort
«« 
(
«« 
index
««  
,
««  !
value
««" '
)
««' (
;
««( )
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
	protected
¯¯ 
internal
¯¯ 
override
¯¯ #
void
¯¯$ (
	_SetShort
¯¯) 2
(
¯¯2 3
int
¯¯3 6
index
¯¯7 <
,
¯¯< =
int
¯¯> A
value
¯¯B G
)
¯¯G H
=>
¯¯I K 
HeapByteBufferUtil
¯¯L ^
.
¯¯^ _
SetShort
¯¯_ g
(
¯¯g h
this
¯¯h l
.
¯¯l m
array
¯¯m r
,
¯¯r s
index
¯¯t y
,
¯¯y z
value¯¯{ €
)¯¯€ 
;¯¯ ‚
public
±± 
override
±± 
IByteBuffer
±± #

SetShortLE
±±$ .
(
±±. /
int
±±/ 2
index
±±3 8
,
±±8 9
int
±±: =
value
±±> C
)
±±C D
{
²² 	
this
³³ 
.
³³ 
EnsureAccessible
³³ !
(
³³! "
)
³³" #
;
³³# $
this
´´ 
.
´´ 
_SetShortLE
´´ 
(
´´ 
index
´´ "
,
´´" #
value
´´$ )
)
´´) *
;
´´* +
return
µµ 
this
µµ 
;
µµ 
}
¶¶ 	
	protected
¸¸ 
internal
¸¸ 
override
¸¸ #
void
¸¸$ (
_SetShortLE
¸¸) 4
(
¸¸4 5
int
¸¸5 8
index
¸¸9 >
,
¸¸> ?
int
¸¸@ C
value
¸¸D I
)
¸¸I J
=>
¸¸K M 
HeapByteBufferUtil
¸¸N `
.
¸¸` a

SetShortLE
¸¸a k
(
¸¸k l
this
¸¸l p
.
¸¸p q
array
¸¸q v
,
¸¸v w
index
¸¸x }
,
¸¸} ~
value¸¸ „
)¸¸„ …
;¸¸… †
public
ºº 
override
ºº 
IByteBuffer
ºº #
	SetMedium
ºº$ -
(
ºº- .
int
ºº. 1
index
ºº2 7
,
ºº7 8
int
ºº9 <
value
ºº= B
)
ººB C
{
»» 	
this
¼¼ 
.
¼¼ 
EnsureAccessible
¼¼ !
(
¼¼! "
)
¼¼" #
;
¼¼# $
this
½½ 
.
½½ 

_SetMedium
½½ 
(
½½ 
index
½½ !
,
½½! "
value
½½# (
)
½½( )
;
½½) *
return
¾¾ 
this
¾¾ 
;
¾¾ 
}
¿¿ 	
	protected
ÁÁ 
internal
ÁÁ 
override
ÁÁ #
void
ÁÁ$ (

_SetMedium
ÁÁ) 3
(
ÁÁ3 4
int
ÁÁ4 7
index
ÁÁ8 =
,
ÁÁ= >
int
ÁÁ? B
value
ÁÁC H
)
ÁÁH I
=>
ÁÁJ L 
HeapByteBufferUtil
ÁÁM _
.
ÁÁ_ `
	SetMedium
ÁÁ` i
(
ÁÁi j
this
ÁÁj n
.
ÁÁn o
array
ÁÁo t
,
ÁÁt u
index
ÁÁv {
,
ÁÁ{ |
valueÁÁ} ‚
)ÁÁ‚ ƒ
;ÁÁƒ „
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
SetMediumLE
ÃÃ$ /
(
ÃÃ/ 0
int
ÃÃ0 3
index
ÃÃ4 9
,
ÃÃ9 :
int
ÃÃ; >
value
ÃÃ? D
)
ÃÃD E
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
EnsureAccessible
ÅÅ !
(
ÅÅ! "
)
ÅÅ" #
;
ÅÅ# $
this
ÆÆ 
.
ÆÆ 
_SetMediumLE
ÆÆ 
(
ÆÆ 
index
ÆÆ #
,
ÆÆ# $
value
ÆÆ% *
)
ÆÆ* +
;
ÆÆ+ ,
return
ÇÇ 
this
ÇÇ 
;
ÇÇ 
}
ÈÈ 	
	protected
ÊÊ 
internal
ÊÊ 
override
ÊÊ #
void
ÊÊ$ (
_SetMediumLE
ÊÊ) 5
(
ÊÊ5 6
int
ÊÊ6 9
index
ÊÊ: ?
,
ÊÊ? @
int
ÊÊA D
value
ÊÊE J
)
ÊÊJ K
=>
ÊÊL N 
HeapByteBufferUtil
ÊÊO a
.
ÊÊa b
SetMediumLE
ÊÊb m
(
ÊÊm n
this
ÊÊn r
.
ÊÊr s
array
ÊÊs x
,
ÊÊx y
index
ÊÊz 
,ÊÊ €
valueÊÊ †
)ÊÊ† ‡
;ÊÊ‡ ˆ
public
ÌÌ 
override
ÌÌ 
IByteBuffer
ÌÌ #
SetInt
ÌÌ$ *
(
ÌÌ* +
int
ÌÌ+ .
index
ÌÌ/ 4
,
ÌÌ4 5
int
ÌÌ6 9
value
ÌÌ: ?
)
ÌÌ? @
{
ÍÍ 	
this
ÎÎ 
.
ÎÎ 
EnsureAccessible
ÎÎ !
(
ÎÎ! "
)
ÎÎ" #
;
ÎÎ# $
this
ÏÏ 
.
ÏÏ 
_SetInt
ÏÏ 
(
ÏÏ 
index
ÏÏ 
,
ÏÏ 
value
ÏÏ  %
)
ÏÏ% &
;
ÏÏ& '
return
ĞĞ 
this
ĞĞ 
;
ĞĞ 
}
ÑÑ 	
	protected
ÓÓ 
internal
ÓÓ 
override
ÓÓ #
void
ÓÓ$ (
_SetInt
ÓÓ) 0
(
ÓÓ0 1
int
ÓÓ1 4
index
ÓÓ5 :
,
ÓÓ: ;
int
ÓÓ< ?
value
ÓÓ@ E
)
ÓÓE F
=>
ÓÓG I 
HeapByteBufferUtil
ÓÓJ \
.
ÓÓ\ ]
SetInt
ÓÓ] c
(
ÓÓc d
this
ÓÓd h
.
ÓÓh i
array
ÓÓi n
,
ÓÓn o
index
ÓÓp u
,
ÓÓu v
value
ÓÓw |
)
ÓÓ| }
;
ÓÓ} ~
public
ÕÕ 
override
ÕÕ 
IByteBuffer
ÕÕ #
SetIntLE
ÕÕ$ ,
(
ÕÕ, -
int
ÕÕ- 0
index
ÕÕ1 6
,
ÕÕ6 7
int
ÕÕ8 ;
value
ÕÕ< A
)
ÕÕA B
{
ÖÖ 	
this
×× 
.
×× 
EnsureAccessible
×× !
(
××! "
)
××" #
;
××# $
this
ØØ 
.
ØØ 
	_SetIntLE
ØØ 
(
ØØ 
index
ØØ  
,
ØØ  !
value
ØØ" '
)
ØØ' (
;
ØØ( )
return
ÙÙ 
this
ÙÙ 
;
ÙÙ 
}
ÚÚ 	
	protected
ÜÜ 
internal
ÜÜ 
override
ÜÜ #
void
ÜÜ$ (
	_SetIntLE
ÜÜ) 2
(
ÜÜ2 3
int
ÜÜ3 6
index
ÜÜ7 <
,
ÜÜ< =
int
ÜÜ> A
value
ÜÜB G
)
ÜÜG H
=>
ÜÜI K 
HeapByteBufferUtil
ÜÜL ^
.
ÜÜ^ _
SetIntLE
ÜÜ_ g
(
ÜÜg h
this
ÜÜh l
.
ÜÜl m
array
ÜÜm r
,
ÜÜr s
index
ÜÜt y
,
ÜÜy z
valueÜÜ{ €
)ÜÜ€ 
;ÜÜ ‚
public
ŞŞ 
override
ŞŞ 
IByteBuffer
ŞŞ #
SetLong
ŞŞ$ +
(
ŞŞ+ ,
int
ŞŞ, /
index
ŞŞ0 5
,
ŞŞ5 6
long
ŞŞ7 ;
value
ŞŞ< A
)
ŞŞA B
{
ßß 	
this
àà 
.
àà 
EnsureAccessible
àà !
(
àà! "
)
àà" #
;
àà# $
this
áá 
.
áá 
_SetLong
áá 
(
áá 
index
áá 
,
áá  
value
áá! &
)
áá& '
;
áá' (
return
ââ 
this
ââ 
;
ââ 
}
ãã 	
	protected
åå 
internal
åå 
override
åå #
void
åå$ (
_SetLong
åå) 1
(
åå1 2
int
åå2 5
index
åå6 ;
,
åå; <
long
åå= A
value
ååB G
)
ååG H
=>
ååI K 
HeapByteBufferUtil
ååL ^
.
åå^ _
SetLong
åå_ f
(
ååf g
this
ååg k
.
ååk l
array
åål q
,
ååq r
index
åås x
,
ååx y
value
ååz 
)åå €
;åå€ 
public
çç 
override
çç 
IByteBuffer
çç #
	SetLongLE
çç$ -
(
çç- .
int
çç. 1
index
çç2 7
,
çç7 8
long
çç9 =
value
çç> C
)
ççC D
{
èè 	
this
éé 
.
éé 
EnsureAccessible
éé !
(
éé! "
)
éé" #
;
éé# $
this
êê 
.
êê 

_SetLongLE
êê 
(
êê 
index
êê !
,
êê! "
value
êê# (
)
êê( )
;
êê) *
return
ëë 
this
ëë 
;
ëë 
}
ìì 	
	protected
îî 
internal
îî 
override
îî #
void
îî$ (

_SetLongLE
îî) 3
(
îî3 4
int
îî4 7
index
îî8 =
,
îî= >
long
îî? C
value
îîD I
)
îîI J
=>
îîK M 
HeapByteBufferUtil
îîN `
.
îî` a
	SetLongLE
îîa j
(
îîj k
this
îîk o
.
îîo p
array
îîp u
,
îîu v
index
îîw |
,
îî| }
valueîî~ ƒ
)îîƒ „
;îî„ …
public
ğğ 
override
ğğ 
IByteBuffer
ğğ #
Copy
ğğ$ (
(
ğğ( )
int
ğğ) ,
index
ğğ- 2
,
ğğ2 3
int
ğğ4 7
length
ğğ8 >
)
ğğ> ?
{
ññ 	
this
òò 
.
òò 

CheckIndex
òò 
(
òò 
index
òò !
,
òò! "
length
òò# )
)
òò) *
;
òò* +
var
óó 
copiedArray
óó 
=
óó 
new
óó !
byte
óó" &
[
óó& '
length
óó' -
]
óó- .
;
óó. /
PlatformDependent
ôô 
.
ôô 

CopyMemory
ôô (
(
ôô( )
this
ôô) -
.
ôô- .
array
ôô. 3
,
ôô3 4
index
ôô5 :
,
ôô: ;
copiedArray
ôô< G
,
ôôG H
$num
ôôI J
,
ôôJ K
length
ôôL R
)
ôôR S
;
ôôS T
return
öö 
new
öö $
UnpooledHeapByteBuffer
öö -
(
öö- .
this
öö. 2
.
öö2 3
	Allocator
öö3 <
,
öö< =
copiedArray
öö> I
,
ööI J
this
ööK O
.
ööO P
MaxCapacity
ööP [
)
öö[ \
;
öö\ ]
}
÷÷ 	
	protected
ùù 
internal
ùù 
override
ùù #
void
ùù$ (

Deallocate
ùù) 3
(
ùù3 4
)
ùù4 5
{
úú 	
this
ûû 
.
ûû 
	FreeArray
ûû 
(
ûû 
this
ûû 
.
ûû  
array
ûû  %
)
ûû% &
;
ûû& '
this
üü 
.
üü 
array
üü 
=
üü 
null
üü 
;
üü 
}
ıı 	
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
Unwrap
ÿÿ$ *
(
ÿÿ* +
)
ÿÿ+ ,
=>
ÿÿ- /
null
ÿÿ0 4
;
ÿÿ4 5
}
€€ 
} èP
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	$
UnpooledSlicedByteBuffer
 "
:# $,
 AbstractUnpooledSlicedByteBuffer% E
{ 
internal $
UnpooledSlicedByteBuffer )
() *
AbstractByteBuffer* <
buffer= C
,C D
intE H
indexI N
,N O
intP S
lengthT Z
)Z [
:		 
base		 
(		 
buffer		 
,		 
index		  
,		  !
length		" (
)		( )
{

 	
} 	
public 
override 
int 
Capacity $
=>% '
this( ,
., -
MaxCapacity- 8
;8 9
	protected 
AbstractByteBuffer $

UnwrapCore% /
(/ 0
)0 1
=>2 4
(5 6
AbstractByteBuffer6 H
)H I
thisI M
.M N
UnwrapN T
(T U
)U V
;V W
	protected 
internal 
override #
byte$ (
_GetByte) 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
_GetByteR Z
(Z [
this[ _
._ `
Idx` c
(c d
indexd i
)i j
)j k
;k l
	protected 
internal 
override #
short$ )
	_GetShort* 3
(3 4
int4 7
index8 =
)= >
=>? A
thisB F
.F G

UnwrapCoreG Q
(Q R
)R S
.S T
	_GetShortT ]
(] ^
this^ b
.b c
Idxc f
(f g
indexg l
)l m
)m n
;n o
	protected 
internal 
override #
short$ )
_GetShortLE* 5
(5 6
int6 9
index: ?
)? @
=>A C
thisD H
.H I

UnwrapCoreI S
(S T
)T U
.U V
_GetShortLEV a
(a b
thisb f
.f g
Idxg j
(j k
indexk p
)p q
)q r
;r s
	protected 
internal 
override #
int$ '
_GetUnsignedMedium( :
(: ;
int; >
index? D
)D E
=>F H
thisI M
.M N

UnwrapCoreN X
(X Y
)Y Z
.Z [
_GetUnsignedMedium[ m
(m n
thisn r
.r s
Idxs v
(v w
indexw |
)| }
)} ~
;~ 
	protected 
internal 
override #
int$ ' 
_GetUnsignedMediumLE( <
(< =
int= @
indexA F
)F G
=>H J
thisK O
.O P

UnwrapCoreP Z
(Z [
)[ \
.\ ] 
_GetUnsignedMediumLE] q
(q r
thisr v
.v w
Idxw z
(z {
index	{ €
)
€ 
)
 ‚
;
‚ ƒ
	protected 
internal 
override #
int$ '
_GetInt( /
(/ 0
int0 3
index4 9
)9 :
=>; =
this> B
.B C

UnwrapCoreC M
(M N
)N O
.O P
_GetIntP W
(W X
thisX \
.\ ]
Idx] `
(` a
indexa f
)f g
)g h
;h i
	protected 
internal 
override #
int$ '
	_GetIntLE( 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
	_GetIntLER [
([ \
this\ `
.` a
Idxa d
(d e
indexe j
)j k
)k l
;l m
	protected 
internal 
override #
long$ (
_GetLong) 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
_GetLongR Z
(Z [
this[ _
._ `
Idx` c
(c d
indexd i
)i j
)j k
;k l
	protected!! 
internal!! 
override!! #
long!!$ (

_GetLongLE!!) 3
(!!3 4
int!!4 7
index!!8 =
)!!= >
=>!!? A
this!!B F
.!!F G

UnwrapCore!!G Q
(!!Q R
)!!R S
.!!S T

_GetLongLE!!T ^
(!!^ _
this!!_ c
.!!c d
Idx!!d g
(!!g h
index!!h m
)!!m n
)!!n o
;!!o p
	protected## 
internal## 
override## #
void##$ (
_SetByte##) 1
(##1 2
int##2 5
index##6 ;
,##; <
int##= @
value##A F
)##F G
=>##H J
this##K O
.##O P

UnwrapCore##P Z
(##Z [
)##[ \
.##\ ]
_SetByte##] e
(##e f
this##f j
.##j k
Idx##k n
(##n o
index##o t
)##t u
,##u v
value##w |
)##| }
;##} ~
	protected%% 
internal%% 
override%% #
void%%$ (
	_SetShort%%) 2
(%%2 3
int%%3 6
index%%7 <
,%%< =
int%%> A
value%%B G
)%%G H
=>%%I K
this%%L P
.%%P Q

UnwrapCore%%Q [
(%%[ \
)%%\ ]
.%%] ^
	_SetShort%%^ g
(%%g h
this%%h l
.%%l m
Idx%%m p
(%%p q
index%%q v
)%%v w
,%%w x
value%%y ~
)%%~ 
;	%% €
	protected'' 
internal'' 
override'' #
void''$ (
_SetShortLE'') 4
(''4 5
int''5 8
index''9 >
,''> ?
int''@ C
value''D I
)''I J
=>''K M
this''N R
.''R S

UnwrapCore''S ]
(''] ^
)''^ _
.''_ `
_SetShortLE''` k
(''k l
this''l p
.''p q
Idx''q t
(''t u
index''u z
)''z {
,''{ |
value	''} ‚
)
''‚ ƒ
;
''ƒ „
	protected)) 
internal)) 
override)) #
void))$ (

_SetMedium))) 3
())3 4
int))4 7
index))8 =
,))= >
int))? B
value))C H
)))H I
=>))J L
this))M Q
.))Q R

UnwrapCore))R \
())\ ]
)))] ^
.))^ _

_SetMedium))_ i
())i j
this))j n
.))n o
Idx))o r
())r s
index))s x
)))x y
,))y z
value	)){ €
)
))€ 
;
)) ‚
	protected++ 
internal++ 
override++ #
void++$ (
_SetMediumLE++) 5
(++5 6
int++6 9
index++: ?
,++? @
int++A D
value++E J
)++J K
=>++L N
this++O S
.++S T

UnwrapCore++T ^
(++^ _
)++_ `
.++` a
_SetMediumLE++a m
(++m n
this++n r
.++r s
Idx++s v
(++v w
index++w |
)++| }
,++} ~
value	++ „
)
++„ …
;
++… †
	protected-- 
internal-- 
override-- #
void--$ (
_SetInt--) 0
(--0 1
int--1 4
index--5 :
,--: ;
int--< ?
value--@ E
)--E F
=>--G I
this--J N
.--N O

UnwrapCore--O Y
(--Y Z
)--Z [
.--[ \
_SetInt--\ c
(--c d
this--d h
.--h i
Idx--i l
(--l m
index--m r
)--r s
,--s t
value--u z
)--z {
;--{ |
	protected// 
internal// 
override// #
void//$ (
	_SetIntLE//) 2
(//2 3
int//3 6
index//7 <
,//< =
int//> A
value//B G
)//G H
=>//I K
this//L P
.//P Q

UnwrapCore//Q [
(//[ \
)//\ ]
.//] ^
	_SetIntLE//^ g
(//g h
this//h l
.//l m
Idx//m p
(//p q
index//q v
)//v w
,//w x
value//y ~
)//~ 
;	// €
	protected11 
internal11 
override11 #
void11$ (
_SetLong11) 1
(111 2
int112 5
index116 ;
,11; <
long11= A
value11B G
)11G H
=>11I K
this11L P
.11P Q

UnwrapCore11Q [
(11[ \
)11\ ]
.11] ^
_SetLong11^ f
(11f g
this11g k
.11k l
Idx11l o
(11o p
index11p u
)11u v
,11v w
value11x }
)11} ~
;11~ 
	protected33 
internal33 
override33 #
void33$ (

_SetLongLE33) 3
(333 4
int334 7
index338 =
,33= >
long33? C
value33D I
)33I J
=>33K M
this33N R
.33R S

UnwrapCore33S ]
(33] ^
)33^ _
.33_ `

_SetLongLE33` j
(33j k
this33k o
.33o p
Idx33p s
(33s t
index33t y
)33y z
,33z {
value	33| 
)
33 ‚
;
33‚ ƒ
}44 
}55 ²¤
qC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledUnsafeDirectByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

unsafe 
class *
UnpooledUnsafeDirectByteBuffer 6
:7 8.
"AbstractReferenceCountedByteBuffer9 [
{ 
readonly  
IByteBufferAllocator %
	allocator& /
;/ 0
int 
capacity 
; 
bool 
	doNotFree 
; 
byte 
[ 
] 
buffer 
; 
public *
UnpooledUnsafeDirectByteBuffer -
(- . 
IByteBufferAllocator. B
allocC H
,H I
intJ M
initialCapacityN ]
,] ^
int_ b
maxCapacityc n
)n o
: 
base 
( 
maxCapacity 
) 
{ 	
Contract 
. 
Requires 
( 
alloc #
!=$ &
null' +
)+ ,
;, -
Contract 
. 
Requires 
( 
initialCapacity -
>=. 0
$num1 2
)2 3
;3 4
Contract 
. 
Requires 
( 
maxCapacity )
>=* ,
$num- .
). /
;/ 0
if   
(   
initialCapacity   
>    !
maxCapacity  " -
)  - .
{!! 
throw"" 
new"" 
ArgumentException"" +
(""+ ,
$""", .
$str"". >
{""> ?
initialCapacity""? N
}""N O
$str""O _
{""_ `
maxCapacity""` k
}""k l
$str""l m
"""m n
)""n o
;""o p
}## 
this%% 
.%% 
	allocator%% 
=%% 
alloc%% "
;%%" #
this&& 
.&& 
SetByteBuffer&& 
(&& 
this&& #
.&&# $
NewArray&&$ ,
(&&, -
initialCapacity&&- <
)&&< =
,&&= >
false&&? D
)&&D E
;&&E F
}'' 	
	protected)) *
UnpooledUnsafeDirectByteBuffer)) 0
())0 1 
IByteBufferAllocator))1 E
alloc))F K
,))K L
byte))M Q
[))Q R
]))R S
initialBuffer))T a
,))a b
int))c f
maxCapacity))g r
,))r s
bool))t x
doFree))y 
)	)) €
:** 
base** 
(** 
maxCapacity** 
)** 
{++ 	
Contract,, 
.,, 
Requires,, 
(,, 
alloc,, #
!=,,$ &
null,,' +
),,+ ,
;,,, -
Contract-- 
.-- 
Requires-- 
(-- 
initialBuffer-- +
!=--, .
null--/ 3
)--3 4
;--4 5
int// 
initialCapacity// 
=//  !
initialBuffer//" /
./// 0
Length//0 6
;//6 7
if00 
(00 
initialCapacity00 
>00  !
maxCapacity00" -
)00- .
{11 
throw22 
new22 
ArgumentException22 +
(22+ ,
$"22, .
$str22. >
{22> ?
initialCapacity22? N
}22N O
$str22O _
{22_ `
maxCapacity22` k
}22k l
$str22l m
"22m n
)22n o
;22o p
}33 
this55 
.55 
	allocator55 
=55 
alloc55 "
;55" #
this66 
.66 
	doNotFree66 
=66 
!66 
doFree66 $
;66$ %
this77 
.77 
SetByteBuffer77 
(77 
initialBuffer77 ,
,77, -
false77. 3
)773 4
;774 5
}88 	
	protected:: 
virtual:: 
byte:: 
[:: 
]::  
AllocateDirect::! /
(::/ 0
int::0 3
initialCapacity::4 C
)::C D
=>::E G
this::H L
.::L M
NewArray::M U
(::U V
initialCapacity::V e
)::e f
;::f g
	protected<< 
byte<< 
[<< 
]<< 
NewArray<< !
(<<! "
int<<" %
initialCapacity<<& 5
)<<5 6
=><<7 9
new<<: =
byte<<> B
[<<B C
initialCapacity<<C R
]<<R S
;<<S T
	protected>> 
virtual>> 
void>> 

FreeDirect>> )
(>>) *
byte>>* .
[>>. /
]>>/ 0
array>>1 6
)>>6 7
{?? 	
}AA 	
voidCC 
SetByteBufferCC 
(CC 
byteCC 
[CC  
]CC  !
arrayCC" '
,CC' (
boolCC) -
tryFreeCC. 5
)CC5 6
{DD 	
ifEE 
(EE 
tryFreeEE 
)EE 
{FF 
byteGG 
[GG 
]GG 
	oldBufferGG  
=GG! "
thisGG# '
.GG' (
bufferGG( .
;GG. /
ifHH 
(HH 
	oldBufferHH 
!=HH  
nullHH! %
)HH% &
{II 
ifJJ 
(JJ 
thisJJ 
.JJ 
	doNotFreeJJ &
)JJ& '
{KK 
thisLL 
.LL 
	doNotFreeLL &
=LL' (
falseLL) .
;LL. /
}MM 
elseNN 
{OO 
thisPP 
.PP 

FreeDirectPP '
(PP' (
	oldBufferPP( 1
)PP1 2
;PP2 3
}QQ 
}RR 
}SS 
thisTT 
.TT 
bufferTT 
=TT 
arrayTT 
;TT  
thisUU 
.UU 
capacityUU 
=UU 
arrayUU !
.UU! "
LengthUU" (
;UU( )
}VV 	
publicXX 
overrideXX 
boolXX 
IsDirectXX %
=>XX& (
trueXX) -
;XX- .
publicZZ 
overrideZZ 
intZZ 
CapacityZZ $
=>ZZ% '
thisZZ( ,
.ZZ, -
capacityZZ- 5
;ZZ5 6
public\\ 
override\\ 
IByteBuffer\\ #
AdjustCapacity\\$ 2
(\\2 3
int\\3 6
newCapacity\\7 B
)\\B C
{]] 	
this^^ 
.^^ 
CheckNewCapacity^^ !
(^^! "
newCapacity^^" -
)^^- .
;^^. /
int`` 
rIdx`` 
=`` 
this`` 
.`` 
ReaderIndex`` '
;``' (
intaa 
wIdxaa 
=aa 
thisaa 
.aa 
WriterIndexaa '
;aa' (
intcc 
oldCapacitycc 
=cc 
thiscc "
.cc" #
capacitycc# +
;cc+ ,
ifdd 
(dd 
newCapacitydd 
>dd 
oldCapacitydd )
)dd) *
{ee 
byteff 
[ff 
]ff 
	oldBufferff  
=ff! "
thisff# '
.ff' (
bufferff( .
;ff. /
bytegg 
[gg 
]gg 
	newBuffergg  
=gg! "
thisgg# '
.gg' (
AllocateDirectgg( 6
(gg6 7
newCapacitygg7 B
)ggB C
;ggC D
PlatformDependenthh !
.hh! "

CopyMemoryhh" ,
(hh, -
	oldBufferhh- 6
,hh6 7
$numhh8 9
,hh9 :
	newBufferhh; D
,hhD E
$numhhF G
,hhG H
oldCapacityhhI T
)hhT U
;hhU V
thisii 
.ii 
SetByteBufferii "
(ii" #
	newBufferii# ,
,ii, -
trueii. 2
)ii2 3
;ii3 4
}jj 
elsekk 
ifkk 
(kk 
newCapacitykk  
<kk! "
oldCapacitykk# .
)kk. /
{ll 
bytemm 
[mm 
]mm 
	oldBuffermm  
=mm! "
thismm# '
.mm' (
buffermm( .
;mm. /
bytenn 
[nn 
]nn 
	newBuffernn  
=nn! "
thisnn# '
.nn' (
AllocateDirectnn( 6
(nn6 7
newCapacitynn7 B
)nnB C
;nnC D
ifoo 
(oo 
rIdxoo 
<oo 
newCapacityoo &
)oo& '
{pp 
ifqq 
(qq 
wIdxqq 
>qq 
newCapacityqq *
)qq* +
{rr 
thisss 
.ss 
SetWriterIndexss +
(ss+ ,
wIdxss, 0
=ss1 2
newCapacityss3 >
)ss> ?
;ss? @
}tt 
PlatformDependentuu %
.uu% &

CopyMemoryuu& 0
(uu0 1
	oldBufferuu1 :
,uu: ;
rIdxuu< @
,uu@ A
	newBufferuuB K
,uuK L
$numuuM N
,uuN O
wIdxuuP T
-uuU V
rIdxuuW [
)uu[ \
;uu\ ]
}vv 
elseww 
{xx 
thisyy 
.yy 
SetIndexyy !
(yy! "
newCapacityyy" -
,yy- .
newCapacityyy/ :
)yy: ;
;yy; <
}zz 
this{{ 
.{{ 
SetByteBuffer{{ "
({{" #
	newBuffer{{# ,
,{{, -
true{{. 2
){{2 3
;{{3 4
}|| 
return}} 
this}} 
;}} 
}~~ 	
public
€€ 
override
€€ "
IByteBufferAllocator
€€ ,
	Allocator
€€- 6
=>
€€7 9
this
€€: >
.
€€> ?
	allocator
€€? H
;
€€H I
public
‚‚ 
override
‚‚ 
bool
‚‚ 
HasArray
‚‚ %
=>
‚‚& (
true
‚‚) -
;
‚‚- .
public
„„ 
override
„„ 
byte
„„ 
[
„„ 
]
„„ 
Array
„„ $
{
…… 	
get
†† 
{
‡‡ 
this
ˆˆ 
.
ˆˆ 
EnsureAccessible
ˆˆ %
(
ˆˆ% &
)
ˆˆ& '
;
ˆˆ' (
return
‰‰ 
this
‰‰ 
.
‰‰ 
buffer
‰‰ "
;
‰‰" #
}
ŠŠ 
}
‹‹ 	
public
 
override
 
int
 
ArrayOffset
 '
=>
( *
$num
+ ,
;
, -
public
 
override
 
bool
 
HasMemoryAddress
 -
=>
. 0
true
1 5
;
5 6
public
‘‘ 
override
‘‘ 
ref
‘‘ 
byte
‘‘  &
GetPinnableMemoryAddress
‘‘! 9
(
‘‘9 :
)
‘‘: ;
{
’’ 	
this
““ 
.
““ 
EnsureAccessible
““ !
(
““! "
)
““" #
;
““# $
return
”” 
ref
”” 
this
”” 
.
”” 
buffer
”” "
[
””" #
$num
””# $
]
””$ %
;
””% &
}
•• 	
public
—— 
override
—— 
IntPtr
—— #
AddressOfPinnedMemory
—— 4
(
——4 5
)
——5 6
=>
——7 9
IntPtr
——: @
.
——@ A
Zero
——A E
;
——E F
	protected
™™ 
internal
™™ 
override
™™ #
byte
™™$ (
_GetByte
™™) 1
(
™™1 2
int
™™2 5
index
™™6 ;
)
™™; <
=>
™™= ?
this
™™@ D
.
™™D E
buffer
™™E K
[
™™K L
index
™™L Q
]
™™Q R
;
™™R S
	protected
›› 
internal
›› 
override
›› #
short
››$ )
	_GetShort
››* 3
(
››3 4
int
››4 7
index
››8 =
)
››= >
{
œœ 	
fixed
 
(
 
byte
 
*
 
addr
 
=
 
&
  !
this
! %
.
% &
Addr
& *
(
* +
index
+ 0
)
0 1
)
1 2
return
 "
UnsafeByteBufferUtil
 +
.
+ ,
GetShort
, 4
(
4 5
addr
5 9
)
9 :
;
: ;
}
ŸŸ 	
	protected
¡¡ 
internal
¡¡ 
override
¡¡ #
short
¡¡$ )
_GetShortLE
¡¡* 5
(
¡¡5 6
int
¡¡6 9
index
¡¡: ?
)
¡¡? @
{
¢¢ 	
fixed
££ 
(
££ 
byte
££ 
*
££ 
addr
££ 
=
££ 
&
££  !
this
££! %
.
££% &
Addr
££& *
(
££* +
index
££+ 0
)
££0 1
)
££1 2
return
¤¤ "
UnsafeByteBufferUtil
¤¤ +
.
¤¤+ ,

GetShortLE
¤¤, 6
(
¤¤6 7
addr
¤¤7 ;
)
¤¤; <
;
¤¤< =
}
¥¥ 	
	protected
§§ 
internal
§§ 
override
§§ #
int
§§$ ' 
_GetUnsignedMedium
§§( :
(
§§: ;
int
§§; >
index
§§? D
)
§§D E
{
¨¨ 	
fixed
©© 
(
©© 
byte
©© 
*
©© 
addr
©© 
=
©© 
&
©©  !
this
©©! %
.
©©% &
Addr
©©& *
(
©©* +
index
©©+ 0
)
©©0 1
)
©©1 2
return
ªª "
UnsafeByteBufferUtil
ªª +
.
ªª+ ,
GetUnsignedMedium
ªª, =
(
ªª= >
addr
ªª> B
)
ªªB C
;
ªªC D
}
«« 	
	protected
­­ 
internal
­­ 
override
­­ #
int
­­$ '"
_GetUnsignedMediumLE
­­( <
(
­­< =
int
­­= @
index
­­A F
)
­­F G
{
®® 	
fixed
¯¯ 
(
¯¯ 
byte
¯¯ 
*
¯¯ 
addr
¯¯ 
=
¯¯ 
&
¯¯  !
this
¯¯! %
.
¯¯% &
Addr
¯¯& *
(
¯¯* +
index
¯¯+ 0
)
¯¯0 1
)
¯¯1 2
return
°° "
UnsafeByteBufferUtil
°° +
.
°°+ ,!
GetUnsignedMediumLE
°°, ?
(
°°? @
addr
°°@ D
)
°°D E
;
°°E F
}
±± 	
	protected
³³ 
internal
³³ 
override
³³ #
int
³³$ '
_GetInt
³³( /
(
³³/ 0
int
³³0 3
index
³³4 9
)
³³9 :
{
´´ 	
fixed
µµ 
(
µµ 
byte
µµ 
*
µµ 
addr
µµ 
=
µµ 
&
µµ  !
this
µµ! %
.
µµ% &
Addr
µµ& *
(
µµ* +
index
µµ+ 0
)
µµ0 1
)
µµ1 2
return
¶¶ "
UnsafeByteBufferUtil
¶¶ +
.
¶¶+ ,
GetInt
¶¶, 2
(
¶¶2 3
addr
¶¶3 7
)
¶¶7 8
;
¶¶8 9
}
·· 	
	protected
¹¹ 
internal
¹¹ 
override
¹¹ #
int
¹¹$ '
	_GetIntLE
¹¹( 1
(
¹¹1 2
int
¹¹2 5
index
¹¹6 ;
)
¹¹; <
{
ºº 	
fixed
»» 
(
»» 
byte
»» 
*
»» 
addr
»» 
=
»» 
&
»»  !
this
»»! %
.
»»% &
Addr
»»& *
(
»»* +
index
»»+ 0
)
»»0 1
)
»»1 2
return
¼¼ "
UnsafeByteBufferUtil
¼¼ +
.
¼¼+ ,
GetIntLE
¼¼, 4
(
¼¼4 5
addr
¼¼5 9
)
¼¼9 :
;
¼¼: ;
}
½½ 	
	protected
¿¿ 
internal
¿¿ 
override
¿¿ #
long
¿¿$ (
_GetLong
¿¿) 1
(
¿¿1 2
int
¿¿2 5
index
¿¿6 ;
)
¿¿; <
{
ÀÀ 	
fixed
ÁÁ 
(
ÁÁ 
byte
ÁÁ 
*
ÁÁ 
addr
ÁÁ 
=
ÁÁ 
&
ÁÁ  !
this
ÁÁ! %
.
ÁÁ% &
Addr
ÁÁ& *
(
ÁÁ* +
index
ÁÁ+ 0
)
ÁÁ0 1
)
ÁÁ1 2
return
ÂÂ "
UnsafeByteBufferUtil
ÂÂ +
.
ÂÂ+ ,
GetLong
ÂÂ, 3
(
ÂÂ3 4
addr
ÂÂ4 8
)
ÂÂ8 9
;
ÂÂ9 :
}
ÃÃ 	
	protected
ÅÅ 
internal
ÅÅ 
override
ÅÅ #
long
ÅÅ$ (

_GetLongLE
ÅÅ) 3
(
ÅÅ3 4
int
ÅÅ4 7
index
ÅÅ8 =
)
ÅÅ= >
{
ÆÆ 	
fixed
ÇÇ 
(
ÇÇ 
byte
ÇÇ 
*
ÇÇ 
addr
ÇÇ 
=
ÇÇ 
&
ÇÇ  !
this
ÇÇ! %
.
ÇÇ% &
Addr
ÇÇ& *
(
ÇÇ* +
index
ÇÇ+ 0
)
ÇÇ0 1
)
ÇÇ1 2
return
ÈÈ "
UnsafeByteBufferUtil
ÈÈ +
.
ÈÈ+ ,
	GetLongLE
ÈÈ, 5
(
ÈÈ5 6
addr
ÈÈ6 :
)
ÈÈ: ;
;
ÈÈ; <
}
ÉÉ 	
public
ËË 
override
ËË 
IByteBuffer
ËË #
GetBytes
ËË$ ,
(
ËË, -
int
ËË- 0
index
ËË1 6
,
ËË6 7
IByteBuffer
ËË8 C
dst
ËËD G
,
ËËG H
int
ËËI L
dstIndex
ËËM U
,
ËËU V
int
ËËW Z
length
ËË[ a
)
ËËa b
{
ÌÌ 	
this
ÍÍ 
.
ÍÍ 

CheckIndex
ÍÍ 
(
ÍÍ 
index
ÍÍ !
,
ÍÍ! "
length
ÍÍ# )
)
ÍÍ) *
;
ÍÍ* +
fixed
ÎÎ 
(
ÎÎ 
byte
ÎÎ 
*
ÎÎ 
addr
ÎÎ 
=
ÎÎ 
&
ÎÎ  !
this
ÎÎ! %
.
ÎÎ% &
Addr
ÎÎ& *
(
ÎÎ* +
index
ÎÎ+ 0
)
ÎÎ0 1
)
ÎÎ1 2"
UnsafeByteBufferUtil
ÏÏ $
.
ÏÏ$ %
GetBytes
ÏÏ% -
(
ÏÏ- .
this
ÏÏ. 2
,
ÏÏ2 3
addr
ÏÏ4 8
,
ÏÏ8 9
index
ÏÏ: ?
,
ÏÏ? @
dst
ÏÏA D
,
ÏÏD E
dstIndex
ÏÏF N
,
ÏÏN O
length
ÏÏP V
)
ÏÏV W
;
ÏÏW X
return
ĞĞ 
this
ĞĞ 
;
ĞĞ 
}
ÑÑ 	
public
ÓÓ 
override
ÓÓ 
IByteBuffer
ÓÓ #
GetBytes
ÓÓ$ ,
(
ÓÓ, -
int
ÓÓ- 0
index
ÓÓ1 6
,
ÓÓ6 7
byte
ÓÓ8 <
[
ÓÓ< =
]
ÓÓ= >
dst
ÓÓ? B
,
ÓÓB C
int
ÓÓD G
dstIndex
ÓÓH P
,
ÓÓP Q
int
ÓÓR U
length
ÓÓV \
)
ÓÓ\ ]
{
ÔÔ 	
this
ÕÕ 
.
ÕÕ 

CheckIndex
ÕÕ 
(
ÕÕ 
index
ÕÕ !
,
ÕÕ! "
length
ÕÕ# )
)
ÕÕ) *
;
ÕÕ* +
fixed
ÖÖ 
(
ÖÖ 
byte
ÖÖ 
*
ÖÖ 
addr
ÖÖ 
=
ÖÖ 
&
ÖÖ  !
this
ÖÖ! %
.
ÖÖ% &
Addr
ÖÖ& *
(
ÖÖ* +
index
ÖÖ+ 0
)
ÖÖ0 1
)
ÖÖ1 2"
UnsafeByteBufferUtil
×× $
.
××$ %
GetBytes
××% -
(
××- .
this
××. 2
,
××2 3
addr
××4 8
,
××8 9
index
××: ?
,
××? @
dst
××A D
,
××D E
dstIndex
××F N
,
××N O
length
××P V
)
××V W
;
××W X
return
ØØ 
this
ØØ 
;
ØØ 
}
ÙÙ 	
	protected
ÛÛ 
internal
ÛÛ 
override
ÛÛ #
void
ÛÛ$ (
_SetByte
ÛÛ) 1
(
ÛÛ1 2
int
ÛÛ2 5
index
ÛÛ6 ;
,
ÛÛ; <
int
ÛÛ= @
value
ÛÛA F
)
ÛÛF G
=>
ÛÛH J
this
ÛÛK O
.
ÛÛO P
buffer
ÛÛP V
[
ÛÛV W
index
ÛÛW \
]
ÛÛ\ ]
=
ÛÛ^ _
	unchecked
ÛÛ` i
(
ÛÛi j
(
ÛÛj k
byte
ÛÛk o
)
ÛÛo p
value
ÛÛp u
)
ÛÛu v
;
ÛÛv w
	protected
İİ 
internal
İİ 
override
İİ #
void
İİ$ (
	_SetShort
İİ) 2
(
İİ2 3
int
İİ3 6
index
İİ7 <
,
İİ< =
int
İİ> A
value
İİB G
)
İİG H
{
ŞŞ 	
fixed
ßß 
(
ßß 
byte
ßß 
*
ßß 
addr
ßß 
=
ßß 
&
ßß  !
this
ßß! %
.
ßß% &
Addr
ßß& *
(
ßß* +
index
ßß+ 0
)
ßß0 1
)
ßß1 2"
UnsafeByteBufferUtil
àà $
.
àà$ %
SetShort
àà% -
(
àà- .
addr
àà. 2
,
àà2 3
value
àà4 9
)
àà9 :
;
àà: ;
}
áá 	
	protected
ãã 
internal
ãã 
override
ãã #
void
ãã$ (
_SetShortLE
ãã) 4
(
ãã4 5
int
ãã5 8
index
ãã9 >
,
ãã> ?
int
ãã@ C
value
ããD I
)
ããI J
{
ää 	
fixed
åå 
(
åå 
byte
åå 
*
åå 
addr
åå 
=
åå 
&
åå  !
this
åå! %
.
åå% &
Addr
åå& *
(
åå* +
index
åå+ 0
)
åå0 1
)
åå1 2"
UnsafeByteBufferUtil
ææ $
.
ææ$ %

SetShortLE
ææ% /
(
ææ/ 0
addr
ææ0 4
,
ææ4 5
value
ææ6 ;
)
ææ; <
;
ææ< =
}
çç 	
	protected
éé 
internal
éé 
override
éé #
void
éé$ (

_SetMedium
éé) 3
(
éé3 4
int
éé4 7
index
éé8 =
,
éé= >
int
éé? B
value
ééC H
)
ééH I
{
êê 	
fixed
ëë 
(
ëë 
byte
ëë 
*
ëë 
addr
ëë 
=
ëë 
&
ëë  !
this
ëë! %
.
ëë% &
Addr
ëë& *
(
ëë* +
index
ëë+ 0
)
ëë0 1
)
ëë1 2"
UnsafeByteBufferUtil
ìì $
.
ìì$ %
	SetMedium
ìì% .
(
ìì. /
addr
ìì/ 3
,
ìì3 4
value
ìì5 :
)
ìì: ;
;
ìì; <
}
íí 	
	protected
ïï 
internal
ïï 
override
ïï #
void
ïï$ (
_SetMediumLE
ïï) 5
(
ïï5 6
int
ïï6 9
index
ïï: ?
,
ïï? @
int
ïïA D
value
ïïE J
)
ïïJ K
{
ğğ 	
fixed
ññ 
(
ññ 
byte
ññ 
*
ññ 
addr
ññ 
=
ññ 
&
ññ  !
this
ññ! %
.
ññ% &
Addr
ññ& *
(
ññ* +
index
ññ+ 0
)
ññ0 1
)
ññ1 2"
UnsafeByteBufferUtil
òò $
.
òò$ %
SetMediumLE
òò% 0
(
òò0 1
addr
òò1 5
,
òò5 6
value
òò7 <
)
òò< =
;
òò= >
}
óó 	
	protected
õõ 
internal
õõ 
override
õõ #
void
õõ$ (
_SetInt
õõ) 0
(
õõ0 1
int
õõ1 4
index
õõ5 :
,
õõ: ;
int
õõ< ?
value
õõ@ E
)
õõE F
{
öö 	
fixed
÷÷ 
(
÷÷ 
byte
÷÷ 
*
÷÷ 
addr
÷÷ 
=
÷÷ 
&
÷÷  !
this
÷÷! %
.
÷÷% &
Addr
÷÷& *
(
÷÷* +
index
÷÷+ 0
)
÷÷0 1
)
÷÷1 2"
UnsafeByteBufferUtil
øø $
.
øø$ %
SetInt
øø% +
(
øø+ ,
addr
øø, 0
,
øø0 1
value
øø2 7
)
øø7 8
;
øø8 9
}
ùù 	
	protected
ûû 
internal
ûû 
override
ûû #
void
ûû$ (
	_SetIntLE
ûû) 2
(
ûû2 3
int
ûû3 6
index
ûû7 <
,
ûû< =
int
ûû> A
value
ûûB G
)
ûûG H
{
üü 	
fixed
ıı 
(
ıı 
byte
ıı 
*
ıı 
addr
ıı 
=
ıı 
&
ıı  !
this
ıı! %
.
ıı% &
Addr
ıı& *
(
ıı* +
index
ıı+ 0
)
ıı0 1
)
ıı1 2"
UnsafeByteBufferUtil
şş $
.
şş$ %
SetIntLE
şş% -
(
şş- .
addr
şş. 2
,
şş2 3
value
şş4 9
)
şş9 :
;
şş: ;
}
ÿÿ 	
	protected
 
internal
 
override
 #
void
$ (
_SetLong
) 1
(
1 2
int
2 5
index
6 ;
,
; <
long
= A
value
B G
)
G H
{
‚‚ 	
fixed
ƒƒ 
(
ƒƒ 
byte
ƒƒ 
*
ƒƒ 
addr
ƒƒ 
=
ƒƒ 
&
ƒƒ  !
this
ƒƒ! %
.
ƒƒ% &
Addr
ƒƒ& *
(
ƒƒ* +
index
ƒƒ+ 0
)
ƒƒ0 1
)
ƒƒ1 2"
UnsafeByteBufferUtil
„„ $
.
„„$ %
SetLong
„„% ,
(
„„, -
addr
„„- 1
,
„„1 2
value
„„3 8
)
„„8 9
;
„„9 :
}
…… 	
	protected
‡‡ 
internal
‡‡ 
override
‡‡ #
void
‡‡$ (

_SetLongLE
‡‡) 3
(
‡‡3 4
int
‡‡4 7
index
‡‡8 =
,
‡‡= >
long
‡‡? C
value
‡‡D I
)
‡‡I J
{
ˆˆ 	
fixed
‰‰ 
(
‰‰ 
byte
‰‰ 
*
‰‰ 
addr
‰‰ 
=
‰‰ 
&
‰‰  !
this
‰‰! %
.
‰‰% &
Addr
‰‰& *
(
‰‰* +
index
‰‰+ 0
)
‰‰0 1
)
‰‰1 2"
UnsafeByteBufferUtil
ŠŠ $
.
ŠŠ$ %
	SetLongLE
ŠŠ% .
(
ŠŠ. /
addr
ŠŠ/ 3
,
ŠŠ3 4
value
ŠŠ5 :
)
ŠŠ: ;
;
ŠŠ; <
}
‹‹ 	
public
 
override
 
IByteBuffer
 #
SetBytes
$ ,
(
, -
int
- 0
index
1 6
,
6 7
IByteBuffer
8 C
src
D G
,
G H
int
I L
srcIndex
M U
,
U V
int
W Z
length
[ a
)
a b
{
 	
this
 
.
 

CheckIndex
 
(
 
index
 !
,
! "
length
# )
)
) *
;
* +
fixed
 
(
 
byte
 
*
 
addr
 
=
 
&
  !
this
! %
.
% &
Addr
& *
(
* +
index
+ 0
)
0 1
)
1 2"
UnsafeByteBufferUtil
‘‘ $
.
‘‘$ %
SetBytes
‘‘% -
(
‘‘- .
this
‘‘. 2
,
‘‘2 3
addr
‘‘4 8
,
‘‘8 9
index
‘‘: ?
,
‘‘? @
src
‘‘A D
,
‘‘D E
srcIndex
‘‘F N
,
‘‘N O
length
‘‘P V
)
‘‘V W
;
‘‘W X
return
’’ 
this
’’ 
;
’’ 
}
““ 	
public
•• 
override
•• 
IByteBuffer
•• #
SetBytes
••$ ,
(
••, -
int
••- 0
index
••1 6
,
••6 7
byte
••8 <
[
••< =
]
••= >
src
••? B
,
••B C
int
••D G
srcIndex
••H P
,
••P Q
int
••R U
length
••V \
)
••\ ]
{
–– 	
this
—— 
.
—— 

CheckIndex
—— 
(
—— 
index
—— !
,
——! "
length
——# )
)
——) *
;
——* +
if
˜˜ 
(
˜˜ 
length
˜˜ 
!=
˜˜ 
$num
˜˜ 
)
˜˜ 
{
™™ 
fixed
šš 
(
šš 
byte
šš 
*
šš 
addr
šš !
=
šš" #
&
šš$ %
this
šš% )
.
šš) *
Addr
šš* .
(
šš. /
index
šš/ 4
)
šš4 5
)
šš5 6"
UnsafeByteBufferUtil
›› (
.
››( )
SetBytes
››) 1
(
››1 2
this
››2 6
,
››6 7
addr
››8 <
,
››< =
index
››> C
,
››C D
src
››E H
,
››H I
srcIndex
››J R
,
››R S
length
››T Z
)
››Z [
;
››[ \
}
œœ 
return
 
this
 
;
 
}
 	
public
   
override
   
IByteBuffer
   #
GetBytes
  $ ,
(
  , -
int
  - 0
index
  1 6
,
  6 7
Stream
  8 >
output
  ? E
,
  E F
int
  G J
length
  K Q
)
  Q R
{
¡¡ 	
this
¢¢ 
.
¢¢ 

CheckIndex
¢¢ 
(
¢¢ 
index
¢¢ !
,
¢¢! "
length
¢¢# )
)
¢¢) *
;
¢¢* +
fixed
££ 
(
££ 
byte
££ 
*
££ 
addr
££ 
=
££ 
&
££  !
this
££! %
.
££% &
Addr
££& *
(
££* +
index
££+ 0
)
££0 1
)
££1 2"
UnsafeByteBufferUtil
¤¤ $
.
¤¤$ %
GetBytes
¤¤% -
(
¤¤- .
this
¤¤. 2
,
¤¤2 3
addr
¤¤4 8
,
¤¤8 9
index
¤¤: ?
,
¤¤? @
output
¤¤A G
,
¤¤G H
length
¤¤I O
)
¤¤O P
;
¤¤P Q
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
¦¦ 	
public
¨¨ 
override
¨¨ 
Task
¨¨ 
<
¨¨ 
int
¨¨  
>
¨¨  !
SetBytesAsync
¨¨" /
(
¨¨/ 0
int
¨¨0 3
index
¨¨4 9
,
¨¨9 :
Stream
¨¨; A
src
¨¨B E
,
¨¨E F
int
¨¨G J
length
¨¨K Q
,
¨¨Q R
CancellationToken
¨¨S d
cancellationToken
¨¨e v
)
¨¨v w
{
©© 	
this
ªª 
.
ªª 

CheckIndex
ªª 
(
ªª 
index
ªª !
,
ªª! "
length
ªª# )
)
ªª) *
;
ªª* +
fixed
«« 
(
«« 
byte
«« 
*
«« 
addr
«« 
=
«« 
&
««  !
this
««! %
.
««% &
Addr
««& *
(
««* +
index
««+ 0
)
««0 1
)
««1 2
{
¬¬ 
return
­­ "
UnsafeByteBufferUtil
­­ +
.
­­+ ,
SetBytesAsync
­­, 9
(
­­9 :
this
­­: >
,
­­> ?
addr
­­@ D
,
­­D E
index
­­F K
,
­­K L
src
­­M P
,
­­P Q
length
­­R X
,
­­X Y
cancellationToken
­­Z k
)
­­k l
;
­­l m
}
®® 
}
¯¯ 	
public
±± 
override
±± 
int
±± 
IoBufferCount
±± )
=>
±±* ,
$num
±±- .
;
±±. /
public
³³ 
override
³³ 
ArraySegment
³³ $
<
³³$ %
byte
³³% )
>
³³) *
GetIoBuffer
³³+ 6
(
³³6 7
int
³³7 :
index
³³; @
,
³³@ A
int
³³B E
length
³³F L
)
³³L M
{
´´ 	
this
µµ 
.
µµ 

CheckIndex
µµ 
(
µµ 
index
µµ !
,
µµ! "
length
µµ# )
)
µµ) *
;
µµ* +
return
¶¶ 
new
¶¶ 
ArraySegment
¶¶ #
<
¶¶# $
byte
¶¶$ (
>
¶¶( )
(
¶¶) *
this
¶¶* .
.
¶¶. /
buffer
¶¶/ 5
,
¶¶5 6
index
¶¶7 <
,
¶¶< =
length
¶¶> D
)
¶¶D E
;
¶¶E F
}
·· 	
public
¹¹ 
override
¹¹ 
ArraySegment
¹¹ $
<
¹¹$ %
byte
¹¹% )
>
¹¹) *
[
¹¹* +
]
¹¹+ ,
GetIoBuffers
¹¹- 9
(
¹¹9 :
int
¹¹: =
index
¹¹> C
,
¹¹C D
int
¹¹E H
length
¹¹I O
)
¹¹O P
=>
¹¹Q S
new
¹¹T W
[
¹¹W X
]
¹¹X Y
{
¹¹Z [
this
¹¹\ `
.
¹¹` a
GetIoBuffer
¹¹a l
(
¹¹l m
index
¹¹m r
,
¹¹r s
length
¹¹t z
)
¹¹z {
}
¹¹| }
;
¹¹} ~
public
»» 
override
»» 
IByteBuffer
»» #
Copy
»»$ (
(
»»( )
int
»») ,
index
»»- 2
,
»»2 3
int
»»4 7
length
»»8 >
)
»»> ?
{
¼¼ 	
this
½½ 
.
½½ 

CheckIndex
½½ 
(
½½ 
index
½½ !
,
½½! "
length
½½# )
)
½½) *
;
½½* +
fixed
¾¾ 
(
¾¾ 
byte
¾¾ 
*
¾¾ 
addr
¾¾ 
=
¾¾ 
&
¾¾  !
this
¾¾! %
.
¾¾% &
Addr
¾¾& *
(
¾¾* +
index
¾¾+ 0
)
¾¾0 1
)
¾¾1 2
return
¿¿ "
UnsafeByteBufferUtil
¿¿ +
.
¿¿+ ,
Copy
¿¿, 0
(
¿¿0 1
this
¿¿1 5
,
¿¿5 6
addr
¿¿7 ;
,
¿¿; <
index
¿¿= B
,
¿¿B C
length
¿¿D J
)
¿¿J K
;
¿¿K L
}
ÀÀ 	
	protected
ÂÂ 
internal
ÂÂ 
override
ÂÂ #
void
ÂÂ$ (

Deallocate
ÂÂ) 3
(
ÂÂ3 4
)
ÂÂ4 5
{
ÃÃ 	
byte
ÄÄ 
[
ÄÄ 
]
ÄÄ 
buf
ÄÄ 
=
ÄÄ 
this
ÄÄ 
.
ÄÄ 
buffer
ÄÄ $
;
ÄÄ$ %
if
ÅÅ 
(
ÅÅ 
buf
ÅÅ 
==
ÅÅ 
null
ÅÅ 
)
ÅÅ 
{
ÆÆ 
return
ÇÇ 
;
ÇÇ 
}
ÈÈ 
this
ÊÊ 
.
ÊÊ 
buffer
ÊÊ 
=
ÊÊ 
null
ÊÊ 
;
ÊÊ 
if
ÌÌ 
(
ÌÌ 
!
ÌÌ 
this
ÌÌ 
.
ÌÌ 
	doNotFree
ÌÌ 
)
ÌÌ  
{
ÍÍ 
this
ÎÎ 
.
ÎÎ 

FreeDirect
ÎÎ 
(
ÎÎ  
buf
ÎÎ  #
)
ÎÎ# $
;
ÎÎ$ %
}
ÏÏ 
}
ĞĞ 	
public
ÒÒ 
override
ÒÒ 
IByteBuffer
ÒÒ #
Unwrap
ÒÒ$ *
(
ÒÒ* +
)
ÒÒ+ ,
=>
ÒÒ- /
null
ÒÒ0 4
;
ÒÒ4 5
[
ÔÔ 	

MethodImpl
ÔÔ	 
(
ÔÔ 
MethodImplOptions
ÔÔ %
.
ÔÔ% & 
AggressiveInlining
ÔÔ& 8
)
ÔÔ8 9
]
ÔÔ9 :
ref
ÕÕ 
byte
ÕÕ 
Addr
ÕÕ 
(
ÕÕ 
int
ÕÕ 
index
ÕÕ 
)
ÕÕ  
=>
ÕÕ! #
ref
ÕÕ$ '
this
ÕÕ( ,
.
ÕÕ, -
buffer
ÕÕ- 3
[
ÕÕ3 4
index
ÕÕ4 9
]
ÕÕ9 :
;
ÕÕ: ;
public
×× 
override
×× 
IByteBuffer
×× #
SetZero
××$ +
(
××+ ,
int
××, /
index
××0 5
,
××5 6
int
××7 :
length
××; A
)
××A B
{
ØØ 	
this
ÙÙ 
.
ÙÙ 

CheckIndex
ÙÙ 
(
ÙÙ 
index
ÙÙ !
,
ÙÙ! "
length
ÙÙ# )
)
ÙÙ) *
;
ÙÙ* +
fixed
ÚÚ 
(
ÚÚ 
byte
ÚÚ 
*
ÚÚ 
addr
ÚÚ 
=
ÚÚ 
&
ÚÚ  !
this
ÚÚ! %
.
ÚÚ% &
Addr
ÚÚ& *
(
ÚÚ* +
index
ÚÚ+ 0
)
ÚÚ0 1
)
ÚÚ1 2"
UnsafeByteBufferUtil
ÛÛ $
.
ÛÛ$ %
SetZero
ÛÛ% ,
(
ÛÛ, -
addr
ÛÛ- 1
,
ÛÛ1 2
length
ÛÛ3 9
)
ÛÛ9 :
;
ÛÛ: ;
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
İİ 	
public
ßß 
override
ßß 
IByteBuffer
ßß #
	WriteZero
ßß$ -
(
ßß- .
int
ßß. 1
length
ßß2 8
)
ßß8 9
{
àà 	
this
áá 
.
áá 
EnsureWritable
áá 
(
áá  
length
áá  &
)
áá& '
;
áá' (
int
ââ 
wIndex
ââ 
=
ââ 
this
ââ 
.
ââ 
WriterIndex
ââ )
;
ââ) *
fixed
ãã 
(
ãã 
byte
ãã 
*
ãã 
addr
ãã 
=
ãã 
&
ãã  !
this
ãã! %
.
ãã% &
Addr
ãã& *
(
ãã* +
wIndex
ãã+ 1
)
ãã1 2
)
ãã2 3"
UnsafeByteBufferUtil
ää $
.
ää$ %
SetZero
ää% ,
(
ää, -
addr
ää- 1
,
ää1 2
length
ää3 9
)
ää9 :
;
ää: ;
this
åå 
.
åå 
SetWriterIndex
åå 
(
åå  
wIndex
åå  &
+
åå' (
length
åå) /
)
åå/ 0
;
åå0 1
return
ææ 
this
ææ 
;
ææ 
}
çç 	
}
èè 
}éé ƒ#
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnreleasableByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class "
UnreleasableByteBuffer '
:( )
WrappedByteBuffer* ;
{ 
internal "
UnreleasableByteBuffer '
(' (
IByteBuffer( 3
buf4 7
)7 8
:9 :
base; ?
(? @
buf@ C
)C D
{		 	
}

 	
public 
override 
IByteBuffer #
	ReadSlice$ -
(- .
int. 1
length2 8
)8 9
=>: <
new= @"
UnreleasableByteBufferA W
(W X
thisX \
.\ ]
Buf] `
.` a
	ReadSlicea j
(j k
lengthk q
)q r
)r s
;s t
public 
override 
IByteBuffer #
ReadRetainedSlice$ 5
(5 6
int6 9
length: @
)@ A
=>B D
thisD H
.H I
	ReadSliceI R
(R S
lengthS Y
)Y Z
;Z [
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
=>, .
new/ 2"
UnreleasableByteBuffer3 I
(I J
thisJ N
.N O
BufO R
.R S
SliceS X
(X Y
)Y Z
)Z [
;[ \
public 
override 
IByteBuffer #
RetainedSlice$ 1
(1 2
)2 3
=>4 6
this7 ;
.; <
Slice< A
(A B
)B C
;C D
public 
override 
IByteBuffer #
Slice$ )
() *
int* -
index. 3
,3 4
int5 8
length9 ?
)? @
=>A C
newD G"
UnreleasableByteBufferH ^
(^ _
this_ c
.c d
Bufd g
.g h
Sliceh m
(m n
indexn s
,s t
lengthu {
){ |
)| }
;} ~
public 
override 
IByteBuffer #
RetainedSlice$ 1
(1 2
int2 5
index6 ;
,; <
int= @
lengthA G
)G H
=>I K
thisL P
.P Q
SliceQ V
(V W
indexW \
,\ ]
length^ d
)d e
;e f
public!! 
override!! 
IByteBuffer!! #
	Duplicate!!$ -
(!!- .
)!!. /
=>!!0 2
new!!3 6"
UnreleasableByteBuffer!!7 M
(!!M N
this!!N R
.!!R S
Buf!!S V
.!!V W
	Duplicate!!W `
(!!` a
)!!a b
)!!b c
;!!c d
public&& 
override&& 
IByteBuffer&& #
RetainedDuplicate&&$ 5
(&&5 6
)&&6 7
=>&&8 :
this&&; ?
.&&? @
	Duplicate&&@ I
(&&I J
)&&J K
;&&K L
public(( 
override(( 
IReferenceCounted(( )
Retain((* 0
(((0 1
)((1 2
=>((3 5
this((6 :
;((: ;
public** 
override** 
IReferenceCounted** )
Retain*** 0
(**0 1
int**1 4
	increment**5 >
)**> ?
=>**@ B
this**C G
;**G H
public,, 
override,, 
IReferenceCounted,, )
Touch,,* /
(,,/ 0
),,0 1
=>,,2 4
this,,5 9
;,,9 :
public.. 
override.. 
IReferenceCounted.. )
Touch..* /
(../ 0
object..0 6
hint..7 ;
)..; <
=>..= ?
this..@ D
;..D E
public00 
override00 
bool00 
Release00 $
(00$ %
)00% &
=>00' )
false00* /
;00/ 0
public22 
override22 
bool22 
Release22 $
(22$ %
int22% (
	decrement22) 2
)222 3
=>224 6
false227 <
;22< =
}33 
}44 ÂØ
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnsafeByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

unsafe 
class  
UnsafeByteBufferUtil ,
{ 
const 
byte 
Zero 
= 
$num 
; 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 
GetShort &
(& '
byte' +
*+ ,
bytes- 2
)2 3
=>4 6
	unchecked 
( 
( 
short 
) 
( 
( 
(  
*  !
bytes! &
)& '
<<( *
$num+ ,
), -
|. /
*0 1
(1 2
bytes2 7
+8 9
$num: ;
); <
)< =
)= >
;> ?
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 

GetShortLE (
(( )
byte) -
*- .
bytes/ 4
)4 5
=>6 8
	unchecked 
( 
( 
short 
) 
( 
( 
*  
bytes  %
)% &
|' (
() *
** +
(+ ,
bytes, 1
+2 3
$num4 5
)5 6
<<7 9
$num: ;
); <
)< =
)= >
;> ?
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMedium -
(- .
byte. 2
*2 3
bytes4 9
)9 :
=>; =
* 
bytes 
<< 
$num 
| 
* 
( 
bytes 
+ 
$num 
) 
<< 
$num 
| 
*   
(   
bytes   
+   
$num   
)   
;   
["" 	

MethodImpl""	 
("" 
MethodImplOptions"" %
.""% &
AggressiveInlining""& 8
)""8 9
]""9 :
internal## 
static## 
int## 
GetUnsignedMediumLE## /
(##/ 0
byte##0 4
*##4 5
bytes##6 ;
)##; <
=>##= ?
*$$ 
bytes$$ 
|$$ 
*%% 
(%% 
bytes%% 
+%% 
$num%% 
)%% 
<<%% 
$num%% 
|%% 
*&& 
(&& 
bytes&& 
+&& 
$num&& 
)&& 
<<&& 
$num&& 
;&& 
[(( 	

MethodImpl((	 
((( 
MethodImplOptions(( %
.((% &
AggressiveInlining((& 8
)((8 9
]((9 :
internal)) 
static)) 
int)) 
GetInt)) "
())" #
byte))# '
*))' (
bytes))) .
))). /
=>))0 2
(** 
*** 
bytes** 
<<** 
$num** 
)** 
|** 
(++ 
*++ 
(++ 
bytes++ 
+++ 
$num++ 
)++ 
<<++ 
$num++ 
)++  
|++! "
(,, 
*,, 
(,, 
bytes,, 
+,, 
$num,, 
),, 
<<,, 
$num,, 
),, 
|,,  !
(-- 
*-- 
(-- 
bytes-- 
+-- 
$num-- 
)-- 
)-- 
;-- 
[// 	

MethodImpl//	 
(// 
MethodImplOptions// %
.//% &
AggressiveInlining//& 8
)//8 9
]//9 :
internal00 
static00 
int00 
GetIntLE00 $
(00$ %
byte00% )
*00) *
bytes00+ 0
)000 1
=>002 4
*11 
bytes11 
|11 
(22 
*22 
(22 
bytes22 
+22 
$num22 
)22 
<<22 
$num22 
)22 
|22  !
(33 
*33 
(33 
bytes33 
+33 
$num33 
)33 
<<33 
$num33 
)33  
|33! "
(44 
*44 
(44 
bytes44 
+44 
$num44 
)44 
<<44 
$num44 
)44  
;44  !
[66 	

MethodImpl66	 
(66 
MethodImplOptions66 %
.66% &
AggressiveInlining66& 8
)668 9
]669 :
internal77 
static77 
long77 
GetLong77 $
(77$ %
byte77% )
*77) *
bytes77+ 0
)770 1
{88 	
	unchecked99 
{:: 
int;; 
i1;; 
=;; 
(;; 
*;; 
bytes;;  
<<;;! #
$num;;$ &
);;& '
|;;( )
(;;* +
*;;+ ,
(;;, -
bytes;;- 2
+;;3 4
$num;;5 6
);;6 7
<<;;8 :
$num;;; =
);;= >
|;;? @
(;;A B
*;;B C
(;;C D
bytes;;D I
+;;J K
$num;;L M
);;M N
<<;;O Q
$num;;R S
);;S T
|;;U V
(;;W X
*;;X Y
(;;Y Z
bytes;;Z _
+;;` a
$num;;b c
);;c d
);;d e
;;;e f
int<< 
i2<< 
=<< 
(<< 
*<< 
(<< 
bytes<< !
+<<" #
$num<<$ %
)<<% &
<<<<' )
$num<<* ,
)<<, -
|<<. /
(<<0 1
*<<1 2
(<<2 3
bytes<<3 8
+<<9 :
$num<<; <
)<<< =
<<<<> @
$num<<A C
)<<C D
|<<E F
(<<G H
*<<H I
(<<I J
bytes<<J O
+<<P Q
$num<<R S
)<<S T
<<<<U W
$num<<X Y
)<<Y Z
|<<[ \
*<<] ^
(<<^ _
bytes<<_ d
+<<e f
$num<<g h
)<<h i
;<<i j
return== 
(== 
uint== 
)== 
i2== 
|==  !
(==" #
(==# $
long==$ (
)==( )
i1==) +
<<==, .
$num==/ 1
)==1 2
;==2 3
}>> 
}?? 	
[AA 	

MethodImplAA	 
(AA 
MethodImplOptionsAA %
.AA% &
AggressiveInliningAA& 8
)AA8 9
]AA9 :
internalBB 
staticBB 
longBB 
	GetLongLEBB &
(BB& '
byteBB' +
*BB+ ,
bytesBB- 2
)BB2 3
{CC 	
	uncheckedDD 
{EE 
intFF 
i1FF 
=FF 
*FF 
bytesFF 
|FF  !
(FF" #
*FF# $
(FF$ %
bytesFF% *
+FF+ ,
$numFF- .
)FF. /
<<FF0 2
$numFF3 4
)FF4 5
|FF6 7
(FF8 9
*FF9 :
(FF: ;
bytesFF; @
+FFA B
$numFFC D
)FFD E
<<FFF H
$numFFI K
)FFK L
|FFM N
(FFO P
*FFP Q
(FFQ R
bytesFFR W
+FFX Y
$numFFZ [
)FF[ \
<<FF] _
$numFF` b
)FFb c
;FFc d
intGG 
i2GG 
=GG 
*GG 
(GG 
bytesGG  
+GG! "
$numGG# $
)GG$ %
|GG& '
(GG( )
*GG) *
(GG* +
bytesGG+ 0
+GG1 2
$numGG3 4
)GG4 5
<<GG6 8
$numGG9 :
)GG: ;
|GG< =
(GG> ?
*GG? @
(GG@ A
bytesGGA F
+GGG H
$numGGI J
)GGJ K
<<GGL N
$numGGO Q
)GGQ R
|GGS T
(GGU V
*GGV W
(GGW X
bytesGGX ]
+GG^ _
$numGG` a
)GGa b
<<GGc e
$numGGf h
)GGh i
;GGi j
returnHH 
(HH 
uintHH 
)HH 
i1HH 
|HH  !
(HH" #
(HH# $
longHH$ (
)HH( )
i2HH) +
<<HH, .
$numHH/ 1
)HH1 2
;HH2 3
}II 
}JJ 	
[LL 	

MethodImplLL	 
(LL 
MethodImplOptionsLL %
.LL% &
AggressiveInliningLL& 8
)LL8 9
]LL9 :
internalMM 
staticMM 
voidMM 
SetShortMM %
(MM% &
byteMM& *
*MM* +
bytesMM, 1
,MM1 2
intMM3 6
valueMM7 <
)MM< =
{NN 	
	uncheckedOO 
{PP 
*QQ 
bytesQQ 
=QQ 
(QQ 
byteQQ 
)QQ 
(QQ  
(QQ  !
ushortQQ! '
)QQ' (
valueQQ( -
>>QQ. 0
$numQQ1 2
)QQ2 3
;QQ3 4
*RR 
(RR 
bytesRR 
+RR 
$numRR 
)RR 
=RR 
(RR  
byteRR  $
)RR$ %
valueRR% *
;RR* +
}SS 
}TT 	
[VV 	

MethodImplVV	 
(VV 
MethodImplOptionsVV %
.VV% &
AggressiveInliningVV& 8
)VV8 9
]VV9 :
internalWW 
staticWW 
voidWW 

SetShortLEWW '
(WW' (
byteWW( ,
*WW, -
bytesWW. 3
,WW3 4
intWW5 8
valueWW9 >
)WW> ?
{XX 	
	uncheckedYY 
{ZZ 
*[[ 
bytes[[ 
=[[ 
([[ 
byte[[ 
)[[ 
value[[ $
;[[$ %
*\\ 
(\\ 
bytes\\ 
+\\ 
$num\\ 
)\\ 
=\\ 
(\\  
byte\\  $
)\\$ %
(\\% &
(\\& '
ushort\\' -
)\\- .
value\\. 3
>>\\4 6
$num\\7 8
)\\8 9
;\\9 :
}]] 
}^^ 	
[`` 	

MethodImpl``	 
(`` 
MethodImplOptions`` %
.``% &
AggressiveInlining``& 8
)``8 9
]``9 :
internalaa 
staticaa 
voidaa 
	SetMediumaa &
(aa& '
byteaa' +
*aa+ ,
bytesaa- 2
,aa2 3
intaa4 7
valueaa8 =
)aa= >
{bb 	
	uncheckedcc 
{dd 
uintee 
unsignedValueee "
=ee# $
(ee% &
uintee& *
)ee* +
valueee+ 0
;ee0 1
*ff 
bytesff 
=ff 
(ff 
byteff 
)ff 
(ff  
unsignedValueff  -
>>ff. 0
$numff1 3
)ff3 4
;ff4 5
*gg 
(gg 
bytesgg 
+gg 
$numgg 
)gg 
=gg 
(gg  
bytegg  $
)gg$ %
(gg% &
unsignedValuegg& 3
>>gg4 6
$numgg7 8
)gg8 9
;gg9 :
*hh 
(hh 
byteshh 
+hh 
$numhh 
)hh 
=hh 
(hh  
bytehh  $
)hh$ %
unsignedValuehh% 2
;hh2 3
}ii 
}jj 	
[ll 	

MethodImplll	 
(ll 
MethodImplOptionsll %
.ll% &
AggressiveInliningll& 8
)ll8 9
]ll9 :
internalmm 
staticmm 
voidmm 
SetMediumLEmm (
(mm( )
bytemm) -
*mm- .
bytesmm/ 4
,mm4 5
intmm6 9
valuemm: ?
)mm? @
{nn 	
	uncheckedoo 
{pp 
uintqq 
unsignedValueqq "
=qq# $
(qq% &
uintqq& *
)qq* +
valueqq+ 0
;qq0 1
*rr 
bytesrr 
=rr 
(rr 
byterr 
)rr 
unsignedValuerr ,
;rr, -
*ss 
(ss 
bytesss 
+ss 
$numss 
)ss 
=ss 
(ss  
bytess  $
)ss$ %
(ss% &
unsignedValuess& 3
>>ss4 6
$numss7 8
)ss8 9
;ss9 :
*tt 
(tt 
bytestt 
+tt 
$numtt 
)tt 
=tt 
(tt  
bytett  $
)tt$ %
(tt% &
unsignedValuett& 3
>>tt4 6
$numtt7 9
)tt9 :
;tt: ;
}uu 
}vv 	
[xx 	

MethodImplxx	 
(xx 
MethodImplOptionsxx %
.xx% &
AggressiveInliningxx& 8
)xx8 9
]xx9 :
internalyy 
staticyy 
voidyy 
SetIntyy #
(yy# $
byteyy$ (
*yy( )
bytesyy* /
,yy/ 0
intyy1 4
valueyy5 :
)yy: ;
{zz 	
	unchecked{{ 
{|| 
uint}} 
unsignedValue}} "
=}}# $
(}}% &
uint}}& *
)}}* +
value}}+ 0
;}}0 1
*~~ 
bytes~~ 
=~~ 
(~~ 
byte~~ 
)~~ 
(~~  
unsignedValue~~  -
>>~~. 0
$num~~1 3
)~~3 4
;~~4 5
* 
( 
bytes 
+ 
$num 
) 
= 
(  
byte  $
)$ %
(% &
unsignedValue& 3
>>4 6
$num7 9
)9 :
;: ;
*
€€ 
(
€€ 
bytes
€€ 
+
€€ 
$num
€€ 
)
€€ 
=
€€ 
(
€€  
byte
€€  $
)
€€$ %
(
€€% &
unsignedValue
€€& 3
>>
€€4 6
$num
€€7 8
)
€€8 9
;
€€9 :
*
 
(
 
bytes
 
+
 
$num
 
)
 
=
 
(
  
byte
  $
)
$ %
unsignedValue
% 2
;
2 3
}
‚‚ 
}
ƒƒ 	
[
…… 	

MethodImpl
……	 
(
…… 
MethodImplOptions
…… %
.
……% & 
AggressiveInlining
……& 8
)
……8 9
]
……9 :
internal
†† 
static
†† 
void
†† 
SetIntLE
†† %
(
††% &
byte
††& *
*
††* +
bytes
††, 1
,
††1 2
int
††3 6
value
††7 <
)
††< =
{
‡‡ 	
	unchecked
ˆˆ 
{
‰‰ 
uint
ŠŠ 
unsignedValue
ŠŠ "
=
ŠŠ# $
(
ŠŠ% &
uint
ŠŠ& *
)
ŠŠ* +
value
ŠŠ+ 0
;
ŠŠ0 1
*
‹‹ 
bytes
‹‹ 
=
‹‹ 
(
‹‹ 
byte
‹‹ 
)
‹‹ 
unsignedValue
‹‹ ,
;
‹‹, -
*
ŒŒ 
(
ŒŒ 
bytes
ŒŒ 
+
ŒŒ 
$num
ŒŒ 
)
ŒŒ 
=
ŒŒ 
(
ŒŒ  
byte
ŒŒ  $
)
ŒŒ$ %
(
ŒŒ% &
unsignedValue
ŒŒ& 3
>>
ŒŒ4 6
$num
ŒŒ7 8
)
ŒŒ8 9
;
ŒŒ9 :
*
 
(
 
bytes
 
+
 
$num
 
)
 
=
 
(
  
byte
  $
)
$ %
(
% &
unsignedValue
& 3
>>
4 6
$num
7 9
)
9 :
;
: ;
*
 
(
 
bytes
 
+
 
$num
 
)
 
=
 
(
  
byte
  $
)
$ %
(
% &
unsignedValue
& 3
>>
4 6
$num
7 9
)
9 :
;
: ;
}
 
}
 	
[
’’ 	

MethodImpl
’’	 
(
’’ 
MethodImplOptions
’’ %
.
’’% & 
AggressiveInlining
’’& 8
)
’’8 9
]
’’9 :
internal
““ 
static
““ 
void
““ 
SetLong
““ $
(
““$ %
byte
““% )
*
““) *
bytes
““+ 0
,
““0 1
long
““2 6
value
““7 <
)
““< =
{
”” 	
	unchecked
•• 
{
–– 
ulong
—— 
unsignedValue
—— #
=
——$ %
(
——& '
ulong
——' ,
)
——, -
value
——- 2
;
——2 3
*
˜˜ 
bytes
˜˜ 
=
˜˜ 
(
˜˜ 
byte
˜˜ 
)
˜˜ 
(
˜˜  
unsignedValue
˜˜  -
>>
˜˜. 0
$num
˜˜1 3
)
˜˜3 4
;
˜˜4 5
*
™™ 
(
™™ 
bytes
™™ 
+
™™ 
$num
™™ 
)
™™ 
=
™™ 
(
™™  
byte
™™  $
)
™™$ %
(
™™% &
unsignedValue
™™& 3
>>
™™4 6
$num
™™7 9
)
™™9 :
;
™™: ;
*
šš 
(
šš 
bytes
šš 
+
šš 
$num
šš 
)
šš 
=
šš 
(
šš  
byte
šš  $
)
šš$ %
(
šš% &
unsignedValue
šš& 3
>>
šš4 6
$num
šš7 9
)
šš9 :
;
šš: ;
*
›› 
(
›› 
bytes
›› 
+
›› 
$num
›› 
)
›› 
=
›› 
(
››  
byte
››  $
)
››$ %
(
››% &
unsignedValue
››& 3
>>
››4 6
$num
››7 9
)
››9 :
;
››: ;
*
œœ 
(
œœ 
bytes
œœ 
+
œœ 
$num
œœ 
)
œœ 
=
œœ 
(
œœ  
byte
œœ  $
)
œœ$ %
(
œœ% &
unsignedValue
œœ& 3
>>
œœ4 6
$num
œœ7 9
)
œœ9 :
;
œœ: ;
*
 
(
 
bytes
 
+
 
$num
 
)
 
=
 
(
  
byte
  $
)
$ %
(
% &
unsignedValue
& 3
>>
4 6
$num
7 9
)
9 :
;
: ;
*
 
(
 
bytes
 
+
 
$num
 
)
 
=
 
(
  
byte
  $
)
$ %
(
% &
unsignedValue
& 3
>>
4 6
$num
7 8
)
8 9
;
9 :
*
ŸŸ 
(
ŸŸ 
bytes
ŸŸ 
+
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
=
ŸŸ 
(
ŸŸ  
byte
ŸŸ  $
)
ŸŸ$ %
unsignedValue
ŸŸ% 2
;
ŸŸ2 3
}
   
}
¡¡ 	
[
££ 	

MethodImpl
££	 
(
££ 
MethodImplOptions
££ %
.
££% & 
AggressiveInlining
££& 8
)
££8 9
]
££9 :
internal
¤¤ 
static
¤¤ 
void
¤¤ 
	SetLongLE
¤¤ &
(
¤¤& '
byte
¤¤' +
*
¤¤+ ,
bytes
¤¤- 2
,
¤¤2 3
long
¤¤4 8
value
¤¤9 >
)
¤¤> ?
{
¥¥ 	
	unchecked
¦¦ 
{
§§ 
ulong
¨¨ 
unsignedValue
¨¨ #
=
¨¨$ %
(
¨¨& '
ulong
¨¨' ,
)
¨¨, -
value
¨¨- 2
;
¨¨2 3
*
©© 
bytes
©© 
=
©© 
(
©© 
byte
©© 
)
©© 
unsignedValue
©© ,
;
©©, -
*
ªª 
(
ªª 
bytes
ªª 
+
ªª 
$num
ªª 
)
ªª 
=
ªª 
(
ªª  
byte
ªª  $
)
ªª$ %
(
ªª% &
unsignedValue
ªª& 3
>>
ªª4 6
$num
ªª7 8
)
ªª8 9
;
ªª9 :
*
«« 
(
«« 
bytes
«« 
+
«« 
$num
«« 
)
«« 
=
«« 
(
««  
byte
««  $
)
««$ %
(
««% &
unsignedValue
««& 3
>>
««4 6
$num
««7 9
)
««9 :
;
««: ;
*
¬¬ 
(
¬¬ 
bytes
¬¬ 
+
¬¬ 
$num
¬¬ 
)
¬¬ 
=
¬¬ 
(
¬¬  
byte
¬¬  $
)
¬¬$ %
(
¬¬% &
unsignedValue
¬¬& 3
>>
¬¬4 6
$num
¬¬7 9
)
¬¬9 :
;
¬¬: ;
*
­­ 
(
­­ 
bytes
­­ 
+
­­ 
$num
­­ 
)
­­ 
=
­­ 
(
­­  
byte
­­  $
)
­­$ %
(
­­% &
unsignedValue
­­& 3
>>
­­4 6
$num
­­7 9
)
­­9 :
;
­­: ;
*
®® 
(
®® 
bytes
®® 
+
®® 
$num
®® 
)
®® 
=
®® 
(
®®  
byte
®®  $
)
®®$ %
(
®®% &
unsignedValue
®®& 3
>>
®®4 6
$num
®®7 9
)
®®9 :
;
®®: ;
*
¯¯ 
(
¯¯ 
bytes
¯¯ 
+
¯¯ 
$num
¯¯ 
)
¯¯ 
=
¯¯ 
(
¯¯  
byte
¯¯  $
)
¯¯$ %
(
¯¯% &
unsignedValue
¯¯& 3
>>
¯¯4 6
$num
¯¯7 9
)
¯¯9 :
;
¯¯: ;
*
°° 
(
°° 
bytes
°° 
+
°° 
$num
°° 
)
°° 
=
°° 
(
°°  
byte
°°  $
)
°°$ %
(
°°% &
unsignedValue
°°& 3
>>
°°4 6
$num
°°7 9
)
°°9 :
;
°°: ;
}
±± 
}
²² 	
internal
´´ 
static
´´ 
void
´´ 
SetZero
´´ $
(
´´$ %
byte
´´% )
[
´´) *
]
´´* +
array
´´, 1
,
´´1 2
int
´´3 6
index
´´7 <
,
´´< =
int
´´> A
length
´´B H
)
´´H I
{
µµ 	
if
¶¶ 
(
¶¶ 
length
¶¶ 
==
¶¶ 
$num
¶¶ 
)
¶¶ 
{
·· 
return
¸¸ 
;
¸¸ 
}
¹¹ 
PlatformDependent
ºº 
.
ºº 
	SetMemory
ºº '
(
ºº' (
array
ºº( -
,
ºº- .
index
ºº/ 4
,
ºº4 5
length
ºº6 <
,
ºº< =
Zero
ºº> B
)
ººB C
;
ººC D
}
»» 	
internal
½½ 
static
½½ 
IByteBuffer
½½ #
Copy
½½$ (
(
½½( ) 
AbstractByteBuffer
½½) ;
buf
½½< ?
,
½½? @
byte
½½A E
*
½½E F
addr
½½G K
,
½½K L
int
½½M P
index
½½Q V
,
½½V W
int
½½X [
length
½½\ b
)
½½b c
{
¾¾ 	
IByteBuffer
¿¿ 
copy
¿¿ 
=
¿¿ 
buf
¿¿ "
.
¿¿" #
	Allocator
¿¿# ,
.
¿¿, -
DirectBuffer
¿¿- 9
(
¿¿9 :
length
¿¿: @
,
¿¿@ A
buf
¿¿B E
.
¿¿E F
MaxCapacity
¿¿F Q
)
¿¿Q R
;
¿¿R S
if
ÀÀ 
(
ÀÀ 
length
ÀÀ 
!=
ÀÀ 
$num
ÀÀ 
)
ÀÀ 
{
ÁÁ 
if
ÂÂ 
(
ÂÂ 
copy
ÂÂ 
.
ÂÂ 
HasMemoryAddress
ÂÂ )
)
ÂÂ) *
{
ÃÃ 
IntPtr
ÄÄ 
ptr
ÄÄ 
=
ÄÄ  
copy
ÄÄ! %
.
ÄÄ% &#
AddressOfPinnedMemory
ÄÄ& ;
(
ÄÄ; <
)
ÄÄ< =
;
ÄÄ= >
if
ÅÅ 
(
ÅÅ 
ptr
ÅÅ 
!=
ÅÅ 
IntPtr
ÅÅ %
.
ÅÅ% &
Zero
ÅÅ& *
)
ÅÅ* +
{
ÆÆ 
PlatformDependent
ÇÇ )
.
ÇÇ) *

CopyMemory
ÇÇ* 4
(
ÇÇ4 5
addr
ÇÇ5 9
,
ÇÇ9 :
(
ÇÇ; <
byte
ÇÇ< @
*
ÇÇ@ A
)
ÇÇA B
ptr
ÇÇB E
,
ÇÇE F
length
ÇÇG M
)
ÇÇM N
;
ÇÇN O
}
ÈÈ 
else
ÉÉ 
{
ÊÊ 
fixed
ËË 
(
ËË 
byte
ËË #
*
ËË# $
dst
ËË% (
=
ËË) *
&
ËË+ ,
copy
ËË, 0
.
ËË0 1&
GetPinnableMemoryAddress
ËË1 I
(
ËËI J
)
ËËJ K
)
ËËK L
{
ÌÌ 
PlatformDependent
ÍÍ -
.
ÍÍ- .

CopyMemory
ÍÍ. 8
(
ÍÍ8 9
addr
ÍÍ9 =
,
ÍÍ= >
dst
ÍÍ? B
,
ÍÍB C
length
ÍÍD J
)
ÍÍJ K
;
ÍÍK L
}
ÎÎ 
}
ÏÏ 
copy
ĞĞ 
.
ĞĞ 
SetIndex
ĞĞ !
(
ĞĞ! "
$num
ĞĞ" #
,
ĞĞ# $
length
ĞĞ% +
)
ĞĞ+ ,
;
ĞĞ, -
}
ÑÑ 
else
ÒÒ 
{
ÓÓ 
copy
ÔÔ 
.
ÔÔ 

WriteBytes
ÔÔ #
(
ÔÔ# $
buf
ÔÔ$ '
,
ÔÔ' (
index
ÔÔ) .
,
ÔÔ. /
length
ÔÔ0 6
)
ÔÔ6 7
;
ÔÔ7 8
}
ÕÕ 
}
ÖÖ 
return
×× 
copy
×× 
;
×× 
}
ØØ 	
internal
ÚÚ 
static
ÚÚ 
int
ÚÚ 
SetBytes
ÚÚ $
(
ÚÚ$ % 
AbstractByteBuffer
ÚÚ% 7
buf
ÚÚ8 ;
,
ÚÚ; <
byte
ÚÚ= A
*
ÚÚA B
addr
ÚÚC G
,
ÚÚG H
int
ÚÚI L
index
ÚÚM R
,
ÚÚR S
Stream
ÚÚT Z
input
ÚÚ[ `
,
ÚÚ` a
int
ÚÚb e
length
ÚÚf l
)
ÚÚl m
{
ÛÛ 	
if
ÜÜ 
(
ÜÜ 
length
ÜÜ 
==
ÜÜ 
$num
ÜÜ 
)
ÜÜ 
{
İİ 
return
ŞŞ 
$num
ŞŞ 
;
ŞŞ 
}
ßß 
IByteBuffer
áá 
tmpBuf
áá 
=
áá  
buf
áá! $
.
áá$ %
	Allocator
áá% .
.
áá. /

HeapBuffer
áá/ 9
(
áá9 :
length
áá: @
)
áá@ A
;
ááA B
try
ââ 
{
ãã 
byte
ää 
[
ää 
]
ää 
tmp
ää 
=
ää 
tmpBuf
ää #
.
ää# $
Array
ää$ )
;
ää) *
int
åå 
offset
åå 
=
åå 
tmpBuf
åå #
.
åå# $
ArrayOffset
åå$ /
;
åå/ 0
int
ææ 
	readBytes
ææ 
=
ææ 
input
ææ  %
.
ææ% &
Read
ææ& *
(
ææ* +
tmp
ææ+ .
,
ææ. /
offset
ææ0 6
,
ææ6 7
length
ææ8 >
)
ææ> ?
;
ææ? @
if
çç 
(
çç 
	readBytes
çç 
>
çç 
$num
çç  !
)
çç! "
{
èè 
PlatformDependent
éé %
.
éé% &

CopyMemory
éé& 0
(
éé0 1
tmp
éé1 4
,
éé4 5
offset
éé6 <
,
éé< =
addr
éé> B
,
ééB C
	readBytes
ééD M
)
ééM N
;
ééN O
}
êê 
return
ìì 
	readBytes
ìì  
;
ìì  !
}
íí 
finally
îî 
{
ïï 
tmpBuf
ğğ 
.
ğğ 
Release
ğğ 
(
ğğ 
)
ğğ  
;
ğğ  !
}
ññ 
}
òò 	
internal
ôô 
static
ôô 
Task
ôô 
<
ôô 
int
ôô  
>
ôô  !
SetBytesAsync
ôô" /
(
ôô/ 0 
AbstractByteBuffer
ôô0 B
buf
ôôC F
,
ôôF G
byte
ôôH L
*
ôôL M
addr
ôôN R
,
ôôR S
int
ôôT W
index
ôôX ]
,
ôô] ^
Stream
ôô_ e
input
ôôf k
,
ôôk l
int
ôôm p
length
ôôq w
,
ôôw x 
CancellationTokenôôy Š!
cancellationTokenôô‹ œ
)ôôœ 
{
õõ 	
if
öö 
(
öö 
length
öö 
==
öö 
$num
öö 
)
öö 
{
÷÷ 
return
øø 
TaskEx
øø 
.
øø 
Zero
øø "
;
øø" #
}
ùù 
IByteBuffer
ûû 
tmpBuf
ûû 
=
ûû  
buf
ûû! $
.
ûû$ %
	Allocator
ûû% .
.
ûû. /

HeapBuffer
ûû/ 9
(
ûû9 :
length
ûû: @
)
ûû@ A
;
ûûA B
return
üü 
tmpBuf
üü 
.
üü 
SetBytesAsync
üü '
(
üü' (
$num
üü( )
,
üü) *
input
üü+ 0
,
üü0 1
length
üü2 8
,
üü8 9
cancellationToken
üü: K
)
üüK L
.
ıı 
ContinueWith
ıı 
(
ıı 
t
ıı 
=>
ıı  "
{
ıı# $
try
şş 
{
ÿÿ 
var
€€ 
read
€€  
=
€€! "
t
€€# $
.
€€$ %
Result
€€% +
;
€€+ ,
if
 
(
 
read
  
>
! "
$num
# $
)
$ %
{
‚‚ 
PlatformDependent
ƒƒ -
.
ƒƒ- .

CopyMemory
ƒƒ. 8
(
ƒƒ8 9
tmpBuf
ƒƒ9 ?
.
ƒƒ? @
Array
ƒƒ@ E
,
ƒƒE F
tmpBuf
ƒƒG M
.
ƒƒM N
ArrayOffset
ƒƒN Y
,
ƒƒY Z
addr
ƒƒ[ _
,
ƒƒ_ `
read
ƒƒa e
)
ƒƒe f
;
ƒƒf g
}
„„ 
return
…… 
read
…… #
;
……# $
}
†† 
finally
‡‡ 
{
ˆˆ 
tmpBuf
‰‰ 
.
‰‰ 
Release
‰‰ &
(
‰‰& '
)
‰‰' (
;
‰‰( )
}
ŠŠ 
}
‹‹ 
)
‹‹ 
;
‹‹ 
}
ŒŒ 	
internal
 
static
 
void
 
GetBytes
 %
(
% & 
AbstractByteBuffer
& 8
buf
9 <
,
< =
byte
> B
*
B C
addr
D H
,
H I
int
J M
index
N S
,
S T
IByteBuffer
U `
dst
a d
,
d e
int
f i
dstIndex
j r
,
r s
int
t w
length
x ~
)
~ 
{
 	
Contract
 
.
 
Requires
 
(
 
dst
 !
!=
" $
null
% )
)
) *
;
* +
if
’’ 
(
’’ 
MathUtil
’’ 
.
’’ 
IsOutOfBounds
’’ &
(
’’& '
dstIndex
’’' /
,
’’/ 0
length
’’1 7
,
’’7 8
dst
’’9 <
.
’’< =
Capacity
’’= E
)
’’E F
)
’’F G
{
““ 
ThrowHelper
”” 
.
”” 4
&ThrowIndexOutOfRangeException_DstIndex
”” B
(
””B C
dstIndex
””C K
)
””K L
;
””L M
}
•• 
if
—— 
(
—— 
dst
—— 
.
—— 
HasMemoryAddress
—— $
)
——$ %
{
˜˜ 
IntPtr
™™ 
ptr
™™ 
=
™™ 
dst
™™  
.
™™  !#
AddressOfPinnedMemory
™™! 6
(
™™6 7
)
™™7 8
;
™™8 9
if
šš 
(
šš 
ptr
šš 
!=
šš 
IntPtr
šš !
.
šš! "
Zero
šš" &
)
šš& '
{
›› 
PlatformDependent
œœ %
.
œœ% &

CopyMemory
œœ& 0
(
œœ0 1
addr
œœ1 5
,
œœ5 6
(
œœ7 8
byte
œœ8 <
*
œœ< =
)
œœ= >
(
œœ> ?
ptr
œœ? B
+
œœC D
dstIndex
œœE M
)
œœM N
,
œœN O
length
œœP V
)
œœV W
;
œœW X
}
 
else
 
{
ŸŸ 
fixed
   
(
   
byte
   
*
    
destination
  ! ,
=
  - .
&
  / 0
dst
  0 3
.
  3 4&
GetPinnableMemoryAddress
  4 L
(
  L M
)
  M N
)
  N O
{
¡¡ 
PlatformDependent
¢¢ )
.
¢¢) *

CopyMemory
¢¢* 4
(
¢¢4 5
addr
¢¢5 9
,
¢¢9 :
destination
¢¢; F
+
¢¢G H
dstIndex
¢¢I Q
,
¢¢Q R
length
¢¢S Y
)
¢¢Y Z
;
¢¢Z [
}
££ 
}
¤¤ 
}
¥¥ 
else
¦¦ 
if
¦¦ 
(
¦¦ 
dst
¦¦ 
.
¦¦ 
HasArray
¦¦ !
)
¦¦! "
{
§§ 
PlatformDependent
¨¨ !
.
¨¨! "

CopyMemory
¨¨" ,
(
¨¨, -
addr
¨¨- 1
,
¨¨1 2
dst
¨¨3 6
.
¨¨6 7
Array
¨¨7 <
,
¨¨< =
dst
¨¨> A
.
¨¨A B
ArrayOffset
¨¨B M
+
¨¨N O
dstIndex
¨¨P X
,
¨¨X Y
length
¨¨Z `
)
¨¨` a
;
¨¨a b
}
©© 
else
ªª 
{
«« 
dst
¬¬ 
.
¬¬ 
SetBytes
¬¬ 
(
¬¬ 
dstIndex
¬¬ %
,
¬¬% &
buf
¬¬' *
,
¬¬* +
index
¬¬, 1
,
¬¬1 2
length
¬¬3 9
)
¬¬9 :
;
¬¬: ;
}
­­ 
}
®® 	
internal
°° 
static
°° 
void
°° 
GetBytes
°° %
(
°°% & 
AbstractByteBuffer
°°& 8
buf
°°9 <
,
°°< =
byte
°°> B
*
°°B C
addr
°°D H
,
°°H I
int
°°J M
index
°°N S
,
°°S T
byte
°°U Y
[
°°Y Z
]
°°Z [
dst
°°\ _
,
°°_ `
int
°°a d
dstIndex
°°e m
,
°°m n
int
°°o r
length
°°s y
)
°°y z
{
±± 	
Contract
²² 
.
²² 
Requires
²² 
(
²² 
dst
²² !
!=
²²" $
null
²²% )
)
²²) *
;
²²* +
if
´´ 
(
´´ 
MathUtil
´´ 
.
´´ 
IsOutOfBounds
´´ &
(
´´& '
dstIndex
´´' /
,
´´/ 0
length
´´1 7
,
´´7 8
dst
´´9 <
.
´´< =
Length
´´= C
)
´´C D
)
´´D E
{
µµ 
ThrowHelper
¶¶ 
.
¶¶ 4
&ThrowIndexOutOfRangeException_DstIndex
¶¶ B
(
¶¶B C
dstIndex
¶¶C K
)
¶¶K L
;
¶¶L M
}
·· 
if
¸¸ 
(
¸¸ 
length
¸¸ 
!=
¸¸ 
$num
¸¸ 
)
¸¸ 
{
¹¹ 
PlatformDependent
ºº !
.
ºº! "

CopyMemory
ºº" ,
(
ºº, -
addr
ºº- 1
,
ºº1 2
dst
ºº3 6
,
ºº6 7
dstIndex
ºº8 @
,
ºº@ A
length
ººB H
)
ººH I
;
ººI J
}
»» 
}
¼¼ 	
internal
¾¾ 
static
¾¾ 
void
¾¾ 
SetBytes
¾¾ %
(
¾¾% & 
AbstractByteBuffer
¾¾& 8
buf
¾¾9 <
,
¾¾< =
byte
¾¾> B
*
¾¾B C
addr
¾¾D H
,
¾¾H I
int
¾¾J M
index
¾¾N S
,
¾¾S T
IByteBuffer
¾¾U `
src
¾¾a d
,
¾¾d e
int
¾¾f i
srcIndex
¾¾j r
,
¾¾r s
int
¾¾t w
length
¾¾x ~
)
¾¾~ 
{
¿¿ 	
Contract
ÀÀ 
.
ÀÀ 
Requires
ÀÀ 
(
ÀÀ 
src
ÀÀ !
!=
ÀÀ" $
null
ÀÀ% )
)
ÀÀ) *
;
ÀÀ* +
if
ÂÂ 
(
ÂÂ 
MathUtil
ÂÂ 
.
ÂÂ 
IsOutOfBounds
ÂÂ &
(
ÂÂ& '
srcIndex
ÂÂ' /
,
ÂÂ/ 0
length
ÂÂ1 7
,
ÂÂ7 8
src
ÂÂ9 <
.
ÂÂ< =
Capacity
ÂÂ= E
)
ÂÂE F
)
ÂÂF G
{
ÃÃ 
ThrowHelper
ÄÄ 
.
ÄÄ 4
&ThrowIndexOutOfRangeException_SrcIndex
ÄÄ B
(
ÄÄB C
srcIndex
ÄÄC K
)
ÄÄK L
;
ÄÄL M
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
length
ÇÇ 
!=
ÇÇ 
$num
ÇÇ 
)
ÇÇ 
{
ÈÈ 
if
ÉÉ 
(
ÉÉ 
src
ÉÉ 
.
ÉÉ 
HasMemoryAddress
ÉÉ (
)
ÉÉ( )
{
ÊÊ 
IntPtr
ËË 
ptr
ËË 
=
ËË  
src
ËË! $
.
ËË$ %#
AddressOfPinnedMemory
ËË% :
(
ËË: ;
)
ËË; <
;
ËË< =
if
ÌÌ 
(
ÌÌ 
ptr
ÌÌ 
!=
ÌÌ 
IntPtr
ÌÌ %
.
ÌÌ% &
Zero
ÌÌ& *
)
ÌÌ* +
{
ÍÍ 
PlatformDependent
ÎÎ )
.
ÎÎ) *

CopyMemory
ÎÎ* 4
(
ÎÎ4 5
(
ÎÎ5 6
byte
ÎÎ6 :
*
ÎÎ: ;
)
ÎÎ; <
(
ÎÎ< =
ptr
ÎÎ= @
+
ÎÎA B
srcIndex
ÎÎC K
)
ÎÎK L
,
ÎÎL M
addr
ÎÎN R
,
ÎÎR S
length
ÎÎT Z
)
ÎÎZ [
;
ÎÎ[ \
}
ÏÏ 
else
ĞĞ 
{
ÑÑ 
fixed
ÒÒ 
(
ÒÒ 
byte
ÒÒ #
*
ÒÒ# $
source
ÒÒ% +
=
ÒÒ, -
&
ÒÒ. /
src
ÒÒ/ 2
.
ÒÒ2 3&
GetPinnableMemoryAddress
ÒÒ3 K
(
ÒÒK L
)
ÒÒL M
)
ÒÒM N
{
ÓÓ 
PlatformDependent
ÔÔ -
.
ÔÔ- .

CopyMemory
ÔÔ. 8
(
ÔÔ8 9
source
ÔÔ9 ?
+
ÔÔ@ A
srcIndex
ÔÔB J
,
ÔÔJ K
addr
ÔÔL P
,
ÔÔP Q
length
ÔÔR X
)
ÔÔX Y
;
ÔÔY Z
}
ÕÕ 
}
ÖÖ 
}
×× 
else
ØØ 
if
ØØ 
(
ØØ 
src
ØØ 
.
ØØ 
HasArray
ØØ %
)
ØØ% &
{
ÙÙ 
PlatformDependent
ÚÚ %
.
ÚÚ% &

CopyMemory
ÚÚ& 0
(
ÚÚ0 1
src
ÚÚ1 4
.
ÚÚ4 5
Array
ÚÚ5 :
,
ÚÚ: ;
src
ÚÚ< ?
.
ÚÚ? @
ArrayOffset
ÚÚ@ K
+
ÚÚL M
srcIndex
ÚÚN V
,
ÚÚV W
addr
ÚÚX \
,
ÚÚ\ ]
length
ÚÚ^ d
)
ÚÚd e
;
ÚÚe f
}
ÛÛ 
else
ÜÜ 
{
İİ 
src
ŞŞ 
.
ŞŞ 
GetBytes
ŞŞ  
(
ŞŞ  !
srcIndex
ŞŞ! )
,
ŞŞ) *
buf
ŞŞ+ .
,
ŞŞ. /
index
ŞŞ0 5
,
ŞŞ5 6
length
ŞŞ7 =
)
ŞŞ= >
;
ŞŞ> ?
}
ßß 
}
àà 
}
áá 	
internal
ää 
static
ää 
void
ää 
SetBytes
ää %
(
ää% & 
AbstractByteBuffer
ää& 8
buf
ää9 <
,
ää< =
byte
ää> B
*
ääB C
addr
ääD H
,
ääH I
int
ääJ M
index
ääN S
,
ääS T
byte
ääU Y
[
ääY Z
]
ääZ [
src
ää\ _
,
ää_ `
int
ääa d
srcIndex
ääe m
,
ääm n
int
ääo r
length
ääs y
)
ääy z
=>
ää{ }
PlatformDependent
åå !
.
åå! "

CopyMemory
åå" ,
(
åå, -
src
åå- 0
,
åå0 1
srcIndex
åå2 :
,
åå: ;
addr
åå< @
,
åå@ A
length
ååB H
)
ååH I
;
ååI J
internal
çç 
static
çç 
void
çç 
GetBytes
çç %
(
çç% & 
AbstractByteBuffer
çç& 8
buf
çç9 <
,
çç< =
byte
çç> B
*
ççB C
addr
ççD H
,
ççH I
int
ççJ M
index
ççN S
,
ççS T
Stream
ççU [
output
çç\ b
,
ççb c
int
ççd g
length
ççh n
)
ççn o
{
èè 	
if
éé 
(
éé 
length
éé 
!=
éé 
$num
éé 
)
éé 
{
êê 
IByteBuffer
ëë 
tmpBuf
ëë "
=
ëë# $
buf
ëë% (
.
ëë( )
	Allocator
ëë) 2
.
ëë2 3

HeapBuffer
ëë3 =
(
ëë= >
length
ëë> D
)
ëëD E
;
ëëE F
try
ìì 
{
íí 
byte
îî 
[
îî 
]
îî 
tmp
îî 
=
îî  
tmpBuf
îî! '
.
îî' (
Array
îî( -
;
îî- .
int
ïï 
offset
ïï 
=
ïï  
tmpBuf
ïï! '
.
ïï' (
ArrayOffset
ïï( 3
;
ïï3 4
PlatformDependent
ğğ %
.
ğğ% &

CopyMemory
ğğ& 0
(
ğğ0 1
addr
ğğ1 5
,
ğğ5 6
tmp
ğğ7 :
,
ğğ: ;
offset
ğğ< B
,
ğğB C
length
ğğD J
)
ğğJ K
;
ğğK L
output
ññ 
.
ññ 
Write
ññ  
(
ññ  !
tmp
ññ! $
,
ññ$ %
offset
ññ& ,
,
ññ, -
length
ññ. 4
)
ññ4 5
;
ññ5 6
}
òò 
finally
óó 
{
ôô 
tmpBuf
õõ 
.
õõ 
Release
õõ "
(
õõ" #
)
õõ# $
;
õõ$ %
}
öö 
}
÷÷ 
}
øø 	
internal
úú 
static
úú 
void
úú 
SetZero
úú $
(
úú$ %
byte
úú% )
*
úú) *
addr
úú+ /
,
úú/ 0
int
úú1 4
length
úú5 ;
)
úú; <
{
ûû 	
if
üü 
(
üü 
length
üü 
==
üü 
$num
üü 
)
üü 
{
ıı 
return
şş 
;
şş 
}
ÿÿ 
PlatformDependent
€€ 
.
€€ 
	SetMemory
€€ '
(
€€' (
addr
€€( ,
,
€€, -
length
€€. 4
,
€€4 5
Zero
€€6 :
)
€€: ;
;
€€; <
}
 	
internal
ƒƒ 
static
ƒƒ 
string
ƒƒ 
	GetString
ƒƒ (
(
ƒƒ( )
byte
ƒƒ) -
*
ƒƒ- .
src
ƒƒ/ 2
,
ƒƒ2 3
int
ƒƒ4 7
length
ƒƒ8 >
,
ƒƒ> ?
Encoding
ƒƒ@ H
encoding
ƒƒI Q
)
ƒƒQ R
{
„„ 	
return
†† 
encoding
†† 
.
†† 
	GetString
†† %
(
††% &
src
††& )
,
††) *
length
††+ 1
)
††1 2
;
††2 3
}
 	
internal
 
static
 ,
UnpooledUnsafeDirectByteBuffer
 6'
NewUnsafeDirectByteBuffer
7 P
(
P Q"
IByteBufferAllocator
Q e
alloc
f k
,
k l
int
m p
initialCapacityq €
,€ 
int‚ …
maxCapacity† ‘
)‘ ’
=>“ •
new
 ,
UnpooledUnsafeDirectByteBuffer
 .
(
. /
alloc
/ 4
,
4 5
initialCapacity
6 E
,
E F
maxCapacity
G R
)
R S
;
S T
}
‘‘ 
}’’ ®Ñ
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\WrappedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	
WrappedByteBuffer
 
: 
IByteBuffer )
{ 
	protected 
readonly 
IByteBuffer &
Buf' *
;* +
	protected 
WrappedByteBuffer #
(# $
IByteBuffer$ /
buf0 3
)3 4
{ 	
Contract 
. 
Requires 
( 
buf !
!=" $
null% )
)) *
;* +
this 
. 
Buf 
= 
buf 
; 
} 	
public 
bool 
HasMemoryAddress $
=>% '
this( ,
., -
Buf- 0
.0 1
HasMemoryAddress1 A
;A B
public!! 
ref!! 
byte!! $
GetPinnableMemoryAddress!! 0
(!!0 1
)!!1 2
=>!!3 5
ref!!6 9
this!!: >
.!!> ?
Buf!!? B
.!!B C$
GetPinnableMemoryAddress!!C [
(!![ \
)!!\ ]
;!!] ^
public## 
IntPtr## !
AddressOfPinnedMemory## +
(##+ ,
)##, -
=>##. 0
this##1 5
.##5 6
Buf##6 9
.##9 :!
AddressOfPinnedMemory##: O
(##O P
)##P Q
;##Q R
public%% 
int%% 
Capacity%% 
=>%% 
this%% #
.%%# $
Buf%%$ '
.%%' (
Capacity%%( 0
;%%0 1
public'' 
virtual'' 
IByteBuffer'' "
AdjustCapacity''# 1
(''1 2
int''2 5
newCapacity''6 A
)''A B
{(( 	
this)) 
.)) 
Buf)) 
.)) 
AdjustCapacity)) #
())# $
newCapacity))$ /
)))/ 0
;))0 1
return** 
this** 
;** 
}++ 	
public-- 
int-- 
MaxCapacity-- 
=>-- !
this--" &
.--& '
Buf--' *
.--* +
MaxCapacity--+ 6
;--6 7
public//  
IByteBufferAllocator// #
	Allocator//$ -
=>//. 0
this//1 5
.//5 6
Buf//6 9
.//9 :
	Allocator//: C
;//C D
public11 
IByteBuffer11 
Unwrap11 !
(11! "
)11" #
=>11$ &
this11' +
.11+ ,
Buf11, /
;11/ 0
public33 
bool33 
IsDirect33 
=>33 
this33  $
.33$ %
Buf33% (
.33( )
IsDirect33) 1
;331 2
public55 
int55 
ReaderIndex55 
=>55 !
this55" &
.55& '
Buf55' *
.55* +
ReaderIndex55+ 6
;556 7
public77 
IByteBuffer77 
SetReaderIndex77 )
(77) *
int77* -
readerIndex77. 9
)779 :
{88 	
this99 
.99 
Buf99 
.99 
SetReaderIndex99 #
(99# $
readerIndex99$ /
)99/ 0
;990 1
return:: 
this:: 
;:: 
};; 	
public== 
int== 
WriterIndex== 
=>== !
this==" &
.==& '
Buf==' *
.==* +
WriterIndex==+ 6
;==6 7
public?? 
IByteBuffer?? 
SetWriterIndex?? )
(??) *
int??* -
writerIndex??. 9
)??9 :
{@@ 	
thisAA 
.AA 
BufAA 
.AA 
SetWriterIndexAA #
(AA# $
writerIndexAA$ /
)AA/ 0
;AA0 1
returnBB 
thisBB 
;BB 
}CC 	
publicEE 
virtualEE 
IByteBufferEE "
SetIndexEE# +
(EE+ ,
intEE, /
readerIndexEE0 ;
,EE; <
intEE= @
writerIndexEEA L
)EEL M
{FF 	
thisGG 
.GG 
BufGG 
.GG 
SetIndexGG 
(GG 
readerIndexGG )
,GG) *
writerIndexGG+ 6
)GG6 7
;GG7 8
returnHH 
thisHH 
;HH 
}II 	
publicKK 
intKK 
ReadableBytesKK  
=>KK! #
thisKK$ (
.KK( )
BufKK) ,
.KK, -
ReadableBytesKK- :
;KK: ;
publicMM 
intMM 
WritableBytesMM  
=>MM! #
thisMM$ (
.MM( )
BufMM) ,
.MM, -
WritableBytesMM- :
;MM: ;
publicOO 
intOO 
MaxWritableBytesOO #
=>OO$ &
thisOO' +
.OO+ ,
BufOO, /
.OO/ 0
MaxWritableBytesOO0 @
;OO@ A
publicQQ 
boolQQ 

IsReadableQQ 
(QQ 
)QQ  
=>QQ! #
thisQQ$ (
.QQ( )
BufQQ) ,
.QQ, -

IsReadableQQ- 7
(QQ7 8
)QQ8 9
;QQ9 :
publicSS 
boolSS 

IsWritableSS 
(SS 
)SS  
=>SS! #
thisSS$ (
.SS( )
BufSS) ,
.SS, -

IsWritableSS- 7
(SS7 8
)SS8 9
;SS9 :
publicUU 
IByteBufferUU 
ClearUU  
(UU  !
)UU! "
{VV 	
thisWW 
.WW 
BufWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
returnXX 
thisXX 
;XX 
}YY 	
public[[ 
IByteBuffer[[ 
MarkReaderIndex[[ *
([[* +
)[[+ ,
{\\ 	
this]] 
.]] 
Buf]] 
.]] 
MarkReaderIndex]] $
(]]$ %
)]]% &
;]]& '
return^^ 
this^^ 
;^^ 
}__ 	
publicaa 
IByteBufferaa 
ResetReaderIndexaa +
(aa+ ,
)aa, -
{bb 	
thiscc 
.cc 
Bufcc 
.cc 
ResetReaderIndexcc %
(cc% &
)cc& '
;cc' (
returndd 
thisdd 
;dd 
}ee 	
publicgg 
IByteBuffergg 
MarkWriterIndexgg *
(gg* +
)gg+ ,
{hh 	
thisii 
.ii 
Bufii 
.ii 
MarkWriterIndexii $
(ii$ %
)ii% &
;ii& '
returnjj 
thisjj 
;jj 
}kk 	
publicmm 
IByteBuffermm 
ResetWriterIndexmm +
(mm+ ,
)mm, -
{nn 	
thisoo 
.oo 
Bufoo 
.oo 
ResetWriterIndexoo %
(oo% &
)oo& '
;oo' (
returnpp 
thispp 
;pp 
}qq 	
publicss 
virtualss 
IByteBufferss "
DiscardReadBytesss# 3
(ss3 4
)ss4 5
{tt 	
thisuu 
.uu 
Bufuu 
.uu 
DiscardReadBytesuu %
(uu% &
)uu& '
;uu' (
returnvv 
thisvv 
;vv 
}ww 	
publicyy 
virtualyy 
IByteBufferyy " 
DiscardSomeReadBytesyy# 7
(yy7 8
)yy8 9
{zz 	
this{{ 
.{{ 
Buf{{ 
.{{  
DiscardSomeReadBytes{{ )
({{) *
){{* +
;{{+ ,
return|| 
this|| 
;|| 
}}} 	
public 
virtual 
IByteBuffer "
EnsureWritable# 1
(1 2
int2 5
minWritableBytes6 F
)F G
{
€€ 	
this
 
.
 
Buf
 
.
 
EnsureWritable
 #
(
# $
minWritableBytes
$ 4
)
4 5
;
5 6
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
ƒƒ 	
public
…… 
virtual
…… 
int
…… 
EnsureWritable
…… )
(
……) *
int
……* -
minWritableBytes
……. >
,
……> ?
bool
……@ D
force
……E J
)
……J K
=>
……L N
this
……O S
.
……S T
Buf
……T W
.
……W X
EnsureWritable
……X f
(
……f g
minWritableBytes
……g w
,
……w x
force
……y ~
)
……~ 
;…… €
public
‡‡ 
virtual
‡‡ 
bool
‡‡ 

GetBoolean
‡‡ &
(
‡‡& '
int
‡‡' *
index
‡‡+ 0
)
‡‡0 1
=>
‡‡2 4
this
‡‡5 9
.
‡‡9 :
Buf
‡‡: =
.
‡‡= >

GetBoolean
‡‡> H
(
‡‡H I
index
‡‡I N
)
‡‡N O
;
‡‡O P
public
‰‰ 
virtual
‰‰ 
byte
‰‰ 
GetByte
‰‰ #
(
‰‰# $
int
‰‰$ '
index
‰‰( -
)
‰‰- .
=>
‰‰/ 1
this
‰‰2 6
.
‰‰6 7
Buf
‰‰7 :
.
‰‰: ;
GetByte
‰‰; B
(
‰‰B C
index
‰‰C H
)
‰‰H I
;
‰‰I J
public
‹‹ 
virtual
‹‹ 
short
‹‹ 
GetShort
‹‹ %
(
‹‹% &
int
‹‹& )
index
‹‹* /
)
‹‹/ 0
=>
‹‹1 3
this
‹‹4 8
.
‹‹8 9
Buf
‹‹9 <
.
‹‹< =
GetShort
‹‹= E
(
‹‹E F
index
‹‹F K
)
‹‹K L
;
‹‹L M
public
 
virtual
 
short
 

GetShortLE
 '
(
' (
int
( +
index
, 1
)
1 2
=>
3 5
this
6 :
.
: ;
Buf
; >
.
> ?

GetShortLE
? I
(
I J
index
J O
)
O P
;
P Q
public
 
virtual
 
ushort
 
GetUnsignedShort
 .
(
. /
int
/ 2
index
3 8
)
8 9
=>
: <
this
= A
.
A B
Buf
B E
.
E F
GetUnsignedShort
F V
(
V W
index
W \
)
\ ]
;
] ^
public
‘‘ 
virtual
‘‘ 
ushort
‘‘  
GetUnsignedShortLE
‘‘ 0
(
‘‘0 1
int
‘‘1 4
index
‘‘5 :
)
‘‘: ;
=>
‘‘< >
this
‘‘? C
.
‘‘C D
Buf
‘‘D G
.
‘‘G H 
GetUnsignedShortLE
‘‘H Z
(
‘‘Z [
index
‘‘[ `
)
‘‘` a
;
‘‘a b
public
““ 
virtual
““ 
int
““ 
	GetMedium
““ $
(
““$ %
int
““% (
index
““) .
)
““. /
=>
““0 2
this
““3 7
.
““7 8
Buf
““8 ;
.
““; <
	GetMedium
““< E
(
““E F
index
““F K
)
““K L
;
““L M
public
•• 
virtual
•• 
int
•• 
GetMediumLE
•• &
(
••& '
int
••' *
index
••+ 0
)
••0 1
=>
••2 4
this
••5 9
.
••9 :
Buf
••: =
.
••= >
GetMediumLE
••> I
(
••I J
index
••J O
)
••O P
;
••P Q
public
—— 
virtual
—— 
int
—— 
GetUnsignedMedium
—— ,
(
——, -
int
——- 0
index
——1 6
)
——6 7
=>
——8 :
this
——; ?
.
——? @
Buf
——@ C
.
——C D
GetUnsignedMedium
——D U
(
——U V
index
——V [
)
——[ \
;
——\ ]
public
™™ 
virtual
™™ 
int
™™ !
GetUnsignedMediumLE
™™ .
(
™™. /
int
™™/ 2
index
™™3 8
)
™™8 9
=>
™™: <
this
™™= A
.
™™A B
Buf
™™B E
.
™™E F!
GetUnsignedMediumLE
™™F Y
(
™™Y Z
index
™™Z _
)
™™_ `
;
™™` a
public
›› 
virtual
›› 
int
›› 
GetInt
›› !
(
››! "
int
››" %
index
››& +
)
››+ ,
=>
››- /
this
››0 4
.
››4 5
Buf
››5 8
.
››8 9
GetInt
››9 ?
(
››? @
index
››@ E
)
››E F
;
››F G
public
 
virtual
 
int
 
GetIntLE
 #
(
# $
int
$ '
index
( -
)
- .
=>
/ 1
this
2 6
.
6 7
Buf
7 :
.
: ;
GetIntLE
; C
(
C D
index
D I
)
I J
;
J K
public
ŸŸ 
virtual
ŸŸ 
uint
ŸŸ 
GetUnsignedInt
ŸŸ *
(
ŸŸ* +
int
ŸŸ+ .
index
ŸŸ/ 4
)
ŸŸ4 5
=>
ŸŸ6 8
this
ŸŸ9 =
.
ŸŸ= >
Buf
ŸŸ> A
.
ŸŸA B
GetUnsignedInt
ŸŸB P
(
ŸŸP Q
index
ŸŸQ V
)
ŸŸV W
;
ŸŸW X
public
¡¡ 
virtual
¡¡ 
uint
¡¡ 
GetUnsignedIntLE
¡¡ ,
(
¡¡, -
int
¡¡- 0
index
¡¡1 6
)
¡¡6 7
=>
¡¡8 :
this
¡¡; ?
.
¡¡? @
Buf
¡¡@ C
.
¡¡C D
GetUnsignedIntLE
¡¡D T
(
¡¡T U
index
¡¡U Z
)
¡¡Z [
;
¡¡[ \
public
££ 
virtual
££ 
long
££ 
GetLong
££ #
(
££# $
int
££$ '
index
££( -
)
££- .
=>
££/ 1
this
££2 6
.
££6 7
Buf
££7 :
.
££: ;
GetLong
££; B
(
££B C
index
££C H
)
££H I
;
££I J
public
¥¥ 
virtual
¥¥ 
long
¥¥ 
	GetLongLE
¥¥ %
(
¥¥% &
int
¥¥& )
index
¥¥* /
)
¥¥/ 0
=>
¥¥1 3
this
¥¥4 8
.
¥¥8 9
Buf
¥¥9 <
.
¥¥< =
	GetLongLE
¥¥= F
(
¥¥F G
index
¥¥G L
)
¥¥L M
;
¥¥M N
public
§§ 
virtual
§§ 
char
§§ 
GetChar
§§ #
(
§§# $
int
§§$ '
index
§§( -
)
§§- .
=>
§§/ 1
this
§§2 6
.
§§6 7
Buf
§§7 :
.
§§: ;
GetChar
§§; B
(
§§B C
index
§§C H
)
§§H I
;
§§I J
public
©© 
virtual
©© 
float
©© 
GetFloat
©© %
(
©©% &
int
©©& )
index
©©* /
)
©©/ 0
=>
©©1 3
this
©©4 8
.
©©8 9
Buf
©©9 <
.
©©< =
GetFloat
©©= E
(
©©E F
index
©©F K
)
©©K L
;
©©L M
public
«« 
float
«« 

GetFloatLE
«« 
(
««  
int
««  #
index
««$ )
)
««) *
=>
««+ -
this
««. 2
.
««2 3
Buf
««3 6
.
««6 7

GetFloatLE
««7 A
(
««A B
index
««B G
)
««G H
;
««H I
public
­­ 
virtual
­­ 
double
­­ 
	GetDouble
­­ '
(
­­' (
int
­­( +
index
­­, 1
)
­­1 2
=>
­­3 5
this
­­6 :
.
­­: ;
Buf
­­; >
.
­­> ?
	GetDouble
­­? H
(
­­H I
index
­­I N
)
­­N O
;
­­O P
public
¯¯ 
double
¯¯ 
GetDoubleLE
¯¯ !
(
¯¯! "
int
¯¯" %
index
¯¯& +
)
¯¯+ ,
=>
¯¯- /
this
¯¯0 4
.
¯¯4 5
Buf
¯¯5 8
.
¯¯8 9
GetDoubleLE
¯¯9 D
(
¯¯D E
index
¯¯E J
)
¯¯J K
;
¯¯K L
public
±± 
virtual
±± 
IByteBuffer
±± "
GetBytes
±±# +
(
±±+ ,
int
±±, /
index
±±0 5
,
±±5 6
IByteBuffer
±±7 B
dst
±±C F
)
±±F G
{
²² 	
this
³³ 
.
³³ 
Buf
³³ 
.
³³ 
GetBytes
³³ 
(
³³ 
index
³³ #
,
³³# $
dst
³³% (
)
³³( )
;
³³) *
return
´´ 
this
´´ 
;
´´ 
}
µµ 	
public
·· 
virtual
·· 
IByteBuffer
·· "
GetBytes
··# +
(
··+ ,
int
··, /
index
··0 5
,
··5 6
IByteBuffer
··7 B
dst
··C F
,
··F G
int
··H K
length
··L R
)
··R S
{
¸¸ 	
this
¹¹ 
.
¹¹ 
Buf
¹¹ 
.
¹¹ 
GetBytes
¹¹ 
(
¹¹ 
index
¹¹ #
,
¹¹# $
dst
¹¹% (
,
¹¹( )
length
¹¹* 0
)
¹¹0 1
;
¹¹1 2
return
ºº 
this
ºº 
;
ºº 
}
»» 	
public
½½ 
virtual
½½ 
IByteBuffer
½½ "
GetBytes
½½# +
(
½½+ ,
int
½½, /
index
½½0 5
,
½½5 6
IByteBuffer
½½7 B
dst
½½C F
,
½½F G
int
½½H K
dstIndex
½½L T
,
½½T U
int
½½V Y
length
½½Z `
)
½½` a
{
¾¾ 	
this
¿¿ 
.
¿¿ 
Buf
¿¿ 
.
¿¿ 
GetBytes
¿¿ 
(
¿¿ 
index
¿¿ #
,
¿¿# $
dst
¿¿% (
,
¿¿( )
dstIndex
¿¿* 2
,
¿¿2 3
length
¿¿4 :
)
¿¿: ;
;
¿¿; <
return
ÀÀ 
this
ÀÀ 
;
ÀÀ 
}
ÁÁ 	
public
ÃÃ 
virtual
ÃÃ 
IByteBuffer
ÃÃ "
GetBytes
ÃÃ# +
(
ÃÃ+ ,
int
ÃÃ, /
index
ÃÃ0 5
,
ÃÃ5 6
byte
ÃÃ7 ;
[
ÃÃ; <
]
ÃÃ< =
dst
ÃÃ> A
)
ÃÃA B
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
Buf
ÅÅ 
.
ÅÅ 
GetBytes
ÅÅ 
(
ÅÅ 
index
ÅÅ #
,
ÅÅ# $
dst
ÅÅ% (
)
ÅÅ( )
;
ÅÅ) *
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
virtual
ÉÉ 
IByteBuffer
ÉÉ "
GetBytes
ÉÉ# +
(
ÉÉ+ ,
int
ÉÉ, /
index
ÉÉ0 5
,
ÉÉ5 6
byte
ÉÉ7 ;
[
ÉÉ; <
]
ÉÉ< =
dst
ÉÉ> A
,
ÉÉA B
int
ÉÉC F
dstIndex
ÉÉG O
,
ÉÉO P
int
ÉÉQ T
length
ÉÉU [
)
ÉÉ[ \
{
ÊÊ 	
this
ËË 
.
ËË 
Buf
ËË 
.
ËË 
GetBytes
ËË 
(
ËË 
index
ËË #
,
ËË# $
dst
ËË% (
,
ËË( )
dstIndex
ËË* 2
,
ËË2 3
length
ËË4 :
)
ËË: ;
;
ËË; <
return
ÌÌ 
this
ÌÌ 
;
ÌÌ 
}
ÍÍ 	
public
ÏÏ 
virtual
ÏÏ 
IByteBuffer
ÏÏ "
GetBytes
ÏÏ# +
(
ÏÏ+ ,
int
ÏÏ, /
index
ÏÏ0 5
,
ÏÏ5 6
Stream
ÏÏ7 =
output
ÏÏ> D
,
ÏÏD E
int
ÏÏF I
length
ÏÏJ P
)
ÏÏP Q
{
ĞĞ 	
this
ÑÑ 
.
ÑÑ 
Buf
ÑÑ 
.
ÑÑ 
GetBytes
ÑÑ 
(
ÑÑ 
index
ÑÑ #
,
ÑÑ# $
output
ÑÑ% +
,
ÑÑ+ ,
length
ÑÑ- 3
)
ÑÑ3 4
;
ÑÑ4 5
return
ÒÒ 
this
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
ÕÕ 
ICharSequence
ÕÕ 
GetCharSequence
ÕÕ ,
(
ÕÕ, -
int
ÕÕ- 0
index
ÕÕ1 6
,
ÕÕ6 7
int
ÕÕ8 ;
length
ÕÕ< B
,
ÕÕB C
Encoding
ÕÕD L
encoding
ÕÕM U
)
ÕÕU V
=>
ÕÕW Y
this
ÕÕZ ^
.
ÕÕ^ _
Buf
ÕÕ_ b
.
ÕÕb c
GetCharSequence
ÕÕc r
(
ÕÕr s
index
ÕÕs x
,
ÕÕx y
lengthÕÕz €
,ÕÕ€ 
encodingÕÕ‚ Š
)ÕÕŠ ‹
;ÕÕ‹ Œ
public
×× 
string
×× 
	GetString
×× 
(
××  
int
××  #
index
××$ )
,
××) *
int
××+ .
length
××/ 5
,
××5 6
Encoding
××7 ?
encoding
××@ H
)
××H I
=>
××J L
this
××M Q
.
××Q R
Buf
××R U
.
××U V
	GetString
××V _
(
××_ `
index
××` e
,
××e f
length
××g m
,
××m n
encoding
××o w
)
××w x
;
××x y
public
ÙÙ 
virtual
ÙÙ 
IByteBuffer
ÙÙ "

SetBoolean
ÙÙ# -
(
ÙÙ- .
int
ÙÙ. 1
index
ÙÙ2 7
,
ÙÙ7 8
bool
ÙÙ9 =
value
ÙÙ> C
)
ÙÙC D
{
ÚÚ 	
this
ÛÛ 
.
ÛÛ 
Buf
ÛÛ 
.
ÛÛ 

SetBoolean
ÛÛ 
(
ÛÛ  
index
ÛÛ  %
,
ÛÛ% &
value
ÛÛ' ,
)
ÛÛ, -
;
ÛÛ- .
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
İİ 	
public
ßß 
virtual
ßß 
IByteBuffer
ßß "
SetByte
ßß# *
(
ßß* +
int
ßß+ .
index
ßß/ 4
,
ßß4 5
int
ßß6 9
value
ßß: ?
)
ßß? @
{
àà 	
this
áá 
.
áá 
Buf
áá 
.
áá 
SetByte
áá 
(
áá 
index
áá "
,
áá" #
value
áá$ )
)
áá) *
;
áá* +
return
ââ 
this
ââ 
;
ââ 
}
ãã 	
public
åå 
virtual
åå 
IByteBuffer
åå "
SetShort
åå# +
(
åå+ ,
int
åå, /
index
åå0 5
,
åå5 6
int
åå7 :
value
åå; @
)
åå@ A
{
ææ 	
this
çç 
.
çç 
Buf
çç 
.
çç 
SetShort
çç 
(
çç 
index
çç #
,
çç# $
value
çç% *
)
çç* +
;
çç+ ,
return
èè 
this
èè 
;
èè 
}
éé 	
public
ëë 
virtual
ëë 
IByteBuffer
ëë "

SetShortLE
ëë# -
(
ëë- .
int
ëë. 1
index
ëë2 7
,
ëë7 8
int
ëë9 <
value
ëë= B
)
ëëB C
{
ìì 	
this
íí 
.
íí 
Buf
íí 
.
íí 

SetShortLE
íí 
(
íí  
index
íí  %
,
íí% &
value
íí' ,
)
íí, -
;
íí- .
return
îî 
this
îî 
;
îî 
}
ïï 	
public
ññ 
IByteBuffer
ññ 
SetUnsignedShort
ññ +
(
ññ+ ,
int
ññ, /
index
ññ0 5
,
ññ5 6
ushort
ññ7 =
value
ññ> C
)
ññC D
=>
ññE G
this
ññH L
.
ññL M
Buf
ññM P
.
ññP Q
SetUnsignedShort
ññQ a
(
ñña b
index
ññb g
,
ññg h
value
ññi n
)
ññn o
;
ñño p
public
óó 
IByteBuffer
óó  
SetUnsignedShortLE
óó -
(
óó- .
int
óó. 1
index
óó2 7
,
óó7 8
ushort
óó9 ?
value
óó@ E
)
óóE F
=>
óóG I
this
óóJ N
.
óóN O
Buf
óóO R
.
óóR S 
SetUnsignedShortLE
óóS e
(
óóe f
index
óóf k
,
óók l
value
óóm r
)
óór s
;
óós t
public
õõ 
virtual
õõ 
IByteBuffer
õõ "
	SetMedium
õõ# ,
(
õõ, -
int
õõ- 0
index
õõ1 6
,
õõ6 7
int
õõ8 ;
value
õõ< A
)
õõA B
{
öö 	
this
÷÷ 
.
÷÷ 
Buf
÷÷ 
.
÷÷ 
	SetMedium
÷÷ 
(
÷÷ 
index
÷÷ $
,
÷÷$ %
value
÷÷& +
)
÷÷+ ,
;
÷÷, -
return
øø 
this
øø 
;
øø 
}
ùù 	
public
ûû 
virtual
ûû 
IByteBuffer
ûû "
SetMediumLE
ûû# .
(
ûû. /
int
ûû/ 2
index
ûû3 8
,
ûû8 9
int
ûû: =
value
ûû> C
)
ûûC D
{
üü 	
this
ıı 
.
ıı 
Buf
ıı 
.
ıı 
SetMediumLE
ıı  
(
ıı  !
index
ıı! &
,
ıı& '
value
ıı( -
)
ıı- .
;
ıı. /
return
şş 
this
şş 
;
şş 
}
ÿÿ 	
public
 
virtual
 
IByteBuffer
 "
SetInt
# )
(
) *
int
* -
index
. 3
,
3 4
int
5 8
value
9 >
)
> ?
{
‚‚ 	
this
ƒƒ 
.
ƒƒ 
Buf
ƒƒ 
.
ƒƒ 
SetInt
ƒƒ 
(
ƒƒ 
index
ƒƒ !
,
ƒƒ! "
value
ƒƒ# (
)
ƒƒ( )
;
ƒƒ) *
return
„„ 
this
„„ 
;
„„ 
}
…… 	
public
‡‡ 
virtual
‡‡ 
IByteBuffer
‡‡ "
SetIntLE
‡‡# +
(
‡‡+ ,
int
‡‡, /
index
‡‡0 5
,
‡‡5 6
int
‡‡7 :
value
‡‡; @
)
‡‡@ A
{
ˆˆ 	
this
‰‰ 
.
‰‰ 
Buf
‰‰ 
.
‰‰ 
SetIntLE
‰‰ 
(
‰‰ 
index
‰‰ #
,
‰‰# $
value
‰‰% *
)
‰‰* +
;
‰‰+ ,
return
ŠŠ 
this
ŠŠ 
;
ŠŠ 
}
‹‹ 	
public
 
IByteBuffer
 
SetUnsignedInt
 )
(
) *
int
* -
index
. 3
,
3 4
uint
5 9
value
: ?
)
? @
=>
A C
this
D H
.
H I
Buf
I L
.
L M
SetUnsignedInt
M [
(
[ \
index
\ a
,
a b
value
c h
)
h i
;
i j
public
 
IByteBuffer
 
SetUnsignedIntLE
 +
(
+ ,
int
, /
index
0 5
,
5 6
uint
7 ;
value
< A
)
A B
=>
C E
this
F J
.
J K
Buf
K N
.
N O
SetUnsignedIntLE
O _
(
_ `
index
` e
,
e f
value
g l
)
l m
;
m n
public
‘‘ 
virtual
‘‘ 
IByteBuffer
‘‘ "
SetLong
‘‘# *
(
‘‘* +
int
‘‘+ .
index
‘‘/ 4
,
‘‘4 5
long
‘‘6 :
value
‘‘; @
)
‘‘@ A
{
’’ 	
this
““ 
.
““ 
Buf
““ 
.
““ 
SetLong
““ 
(
““ 
index
““ "
,
““" #
value
““$ )
)
““) *
;
““* +
return
”” 
this
”” 
;
”” 
}
•• 	
public
—— 
virtual
—— 
IByteBuffer
—— "
	SetLongLE
——# ,
(
——, -
int
——- 0
index
——1 6
,
——6 7
long
——8 <
value
——= B
)
——B C
{
˜˜ 	
this
™™ 
.
™™ 
Buf
™™ 
.
™™ 
	SetLongLE
™™ 
(
™™ 
index
™™ $
,
™™$ %
value
™™& +
)
™™+ ,
;
™™, -
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
virtual
 
IByteBuffer
 "
SetChar
# *
(
* +
int
+ .
index
/ 4
,
4 5
char
6 :
value
; @
)
@ A
{
 	
this
ŸŸ 
.
ŸŸ 
Buf
ŸŸ 
.
ŸŸ 
SetChar
ŸŸ 
(
ŸŸ 
index
ŸŸ "
,
ŸŸ" #
value
ŸŸ$ )
)
ŸŸ) *
;
ŸŸ* +
return
   
this
   
;
   
}
¡¡ 	
public
££ 
virtual
££ 
IByteBuffer
££ "
SetFloat
££# +
(
££+ ,
int
££, /
index
££0 5
,
££5 6
float
££7 <
value
££= B
)
££B C
{
¤¤ 	
this
¥¥ 
.
¥¥ 
Buf
¥¥ 
.
¥¥ 
SetFloat
¥¥ 
(
¥¥ 
index
¥¥ #
,
¥¥# $
value
¥¥% *
)
¥¥* +
;
¥¥+ ,
return
¦¦ 
this
¦¦ 
;
¦¦ 
}
§§ 	
public
©© 
IByteBuffer
©© 

SetFloatLE
©© %
(
©©% &
int
©©& )
index
©©* /
,
©©/ 0
float
©©1 6
value
©©7 <
)
©©< =
{
ªª 	
this
«« 
.
«« 
Buf
«« 
.
«« 

SetFloatLE
«« 
(
««  
index
««  %
,
««% &
value
««' ,
)
««, -
;
««- .
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
public
¯¯ 
virtual
¯¯ 
IByteBuffer
¯¯ "
	SetDouble
¯¯# ,
(
¯¯, -
int
¯¯- 0
index
¯¯1 6
,
¯¯6 7
double
¯¯8 >
value
¯¯? D
)
¯¯D E
{
°° 	
this
±± 
.
±± 
Buf
±± 
.
±± 
	SetDouble
±± 
(
±± 
index
±± $
,
±±$ %
value
±±& +
)
±±+ ,
;
±±, -
return
²² 
this
²² 
;
²² 
}
³³ 	
public
µµ 
IByteBuffer
µµ 
SetDoubleLE
µµ &
(
µµ& '
int
µµ' *
index
µµ+ 0
,
µµ0 1
double
µµ2 8
value
µµ9 >
)
µµ> ?
{
¶¶ 	
this
·· 
.
·· 
Buf
·· 
.
·· 
SetDoubleLE
··  
(
··  !
index
··! &
,
··& '
value
··( -
)
··- .
;
··. /
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
public
»» 
virtual
»» 
IByteBuffer
»» "
SetBytes
»»# +
(
»»+ ,
int
»», /
index
»»0 5
,
»»5 6
IByteBuffer
»»7 B
src
»»C F
)
»»F G
{
¼¼ 	
this
½½ 
.
½½ 
Buf
½½ 
.
½½ 
SetBytes
½½ 
(
½½ 
index
½½ #
,
½½# $
src
½½% (
)
½½( )
;
½½) *
return
¾¾ 
this
¾¾ 
;
¾¾ 
}
¿¿ 	
public
ÁÁ 
virtual
ÁÁ 
IByteBuffer
ÁÁ "
SetBytes
ÁÁ# +
(
ÁÁ+ ,
int
ÁÁ, /
index
ÁÁ0 5
,
ÁÁ5 6
IByteBuffer
ÁÁ7 B
src
ÁÁC F
,
ÁÁF G
int
ÁÁH K
length
ÁÁL R
)
ÁÁR S
{
ÂÂ 	
this
ÃÃ 
.
ÃÃ 
Buf
ÃÃ 
.
ÃÃ 
SetBytes
ÃÃ 
(
ÃÃ 
index
ÃÃ #
,
ÃÃ# $
src
ÃÃ% (
,
ÃÃ( )
length
ÃÃ* 0
)
ÃÃ0 1
;
ÃÃ1 2
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÇÇ 
virtual
ÇÇ 
IByteBuffer
ÇÇ "
SetBytes
ÇÇ# +
(
ÇÇ+ ,
int
ÇÇ, /
index
ÇÇ0 5
,
ÇÇ5 6
IByteBuffer
ÇÇ7 B
src
ÇÇC F
,
ÇÇF G
int
ÇÇH K
srcIndex
ÇÇL T
,
ÇÇT U
int
ÇÇV Y
length
ÇÇZ `
)
ÇÇ` a
{
ÈÈ 	
this
ÉÉ 
.
ÉÉ 
Buf
ÉÉ 
.
ÉÉ 
SetBytes
ÉÉ 
(
ÉÉ 
index
ÉÉ #
,
ÉÉ# $
src
ÉÉ% (
,
ÉÉ( )
srcIndex
ÉÉ* 2
,
ÉÉ2 3
length
ÉÉ4 :
)
ÉÉ: ;
;
ÉÉ; <
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ËË 	
public
ÍÍ 
virtual
ÍÍ 
IByteBuffer
ÍÍ "
SetBytes
ÍÍ# +
(
ÍÍ+ ,
int
ÍÍ, /
index
ÍÍ0 5
,
ÍÍ5 6
byte
ÍÍ7 ;
[
ÍÍ; <
]
ÍÍ< =
src
ÍÍ> A
)
ÍÍA B
{
ÎÎ 	
this
ÏÏ 
.
ÏÏ 
Buf
ÏÏ 
.
ÏÏ 
SetBytes
ÏÏ 
(
ÏÏ 
index
ÏÏ #
,
ÏÏ# $
src
ÏÏ% (
)
ÏÏ( )
;
ÏÏ) *
return
ĞĞ 
this
ĞĞ 
;
ĞĞ 
}
ÑÑ 	
public
ÓÓ 
virtual
ÓÓ 
IByteBuffer
ÓÓ "
SetBytes
ÓÓ# +
(
ÓÓ+ ,
int
ÓÓ, /
index
ÓÓ0 5
,
ÓÓ5 6
byte
ÓÓ7 ;
[
ÓÓ; <
]
ÓÓ< =
src
ÓÓ> A
,
ÓÓA B
int
ÓÓC F
srcIndex
ÓÓG O
,
ÓÓO P
int
ÓÓQ T
length
ÓÓU [
)
ÓÓ[ \
{
ÔÔ 	
this
ÕÕ 
.
ÕÕ 
Buf
ÕÕ 
.
ÕÕ 
SetBytes
ÕÕ 
(
ÕÕ 
index
ÕÕ #
,
ÕÕ# $
src
ÕÕ% (
,
ÕÕ( )
srcIndex
ÕÕ* 2
,
ÕÕ2 3
length
ÕÕ4 :
)
ÕÕ: ;
;
ÕÕ; <
return
ÖÖ 
this
ÖÖ 
;
ÖÖ 
}
×× 	
public
ÙÙ 
virtual
ÙÙ 
Task
ÙÙ 
<
ÙÙ 
int
ÙÙ 
>
ÙÙ  
SetBytesAsync
ÙÙ! .
(
ÙÙ. /
int
ÙÙ/ 2
index
ÙÙ3 8
,
ÙÙ8 9
Stream
ÙÙ: @
src
ÙÙA D
,
ÙÙD E
int
ÙÙF I
length
ÙÙJ P
,
ÙÙP Q
CancellationToken
ÙÙR c
cancellationToken
ÙÙd u
)
ÙÙu v
=>
ÙÙw y
this
ÙÙz ~
.
ÙÙ~ 
BufÙÙ ‚
.ÙÙ‚ ƒ
SetBytesAsyncÙÙƒ 
(ÙÙ ‘
indexÙÙ‘ –
,ÙÙ– —
srcÙÙ˜ ›
,ÙÙ› œ
lengthÙÙ £
,ÙÙ£ ¤!
cancellationTokenÙÙ¥ ¶
)ÙÙ¶ ·
;ÙÙ· ¸
public
ÛÛ 
int
ÛÛ 
	SetString
ÛÛ 
(
ÛÛ 
int
ÛÛ  
index
ÛÛ! &
,
ÛÛ& '
string
ÛÛ( .
value
ÛÛ/ 4
,
ÛÛ4 5
Encoding
ÛÛ6 >
encoding
ÛÛ? G
)
ÛÛG H
=>
ÛÛI K
this
ÛÛL P
.
ÛÛP Q
Buf
ÛÛQ T
.
ÛÛT U
	SetString
ÛÛU ^
(
ÛÛ^ _
index
ÛÛ_ d
,
ÛÛd e
value
ÛÛf k
,
ÛÛk l
encoding
ÛÛm u
)
ÛÛu v
;
ÛÛv w
public
İİ 
virtual
İİ 
IByteBuffer
İİ "
SetZero
İİ# *
(
İİ* +
int
İİ+ .
index
İİ/ 4
,
İİ4 5
int
İİ6 9
length
İİ: @
)
İİ@ A
{
ŞŞ 	
this
ßß 
.
ßß 
Buf
ßß 
.
ßß 
SetZero
ßß 
(
ßß 
index
ßß "
,
ßß" #
length
ßß$ *
)
ßß* +
;
ßß+ ,
return
àà 
this
àà 
;
àà 
}
áá 	
public
ãã 
int
ãã 
SetCharSequence
ãã "
(
ãã" #
int
ãã# &
index
ãã' ,
,
ãã, -
ICharSequence
ãã. ;
sequence
ãã< D
,
ããD E
Encoding
ããF N
encoding
ããO W
)
ããW X
=>
ããY [
this
ãã\ `
.
ãã` a
Buf
ããa d
.
ããd e
SetCharSequence
ããe t
(
ããt u
index
ããu z
,
ããz {
sequenceãã| „
,ãã„ …
encodingãã† 
)ãã 
;ãã 
public
åå 
virtual
åå 
bool
åå 
ReadBoolean
åå '
(
åå' (
)
åå( )
=>
åå* ,
this
åå- 1
.
åå1 2
Buf
åå2 5
.
åå5 6
ReadBoolean
åå6 A
(
ååA B
)
ååB C
;
ååC D
public
çç 
virtual
çç 
byte
çç 
ReadByte
çç $
(
çç$ %
)
çç% &
=>
çç' )
this
çç* .
.
çç. /
Buf
çç/ 2
.
çç2 3
ReadByte
çç3 ;
(
çç; <
)
çç< =
;
çç= >
public
éé 
virtual
éé 
short
éé 
	ReadShort
éé &
(
éé& '
)
éé' (
=>
éé) +
this
éé, 0
.
éé0 1
Buf
éé1 4
.
éé4 5
	ReadShort
éé5 >
(
éé> ?
)
éé? @
;
éé@ A
public
ëë 
virtual
ëë 
short
ëë 
ReadShortLE
ëë (
(
ëë( )
)
ëë) *
=>
ëë+ -
this
ëë. 2
.
ëë2 3
Buf
ëë3 6
.
ëë6 7
ReadShortLE
ëë7 B
(
ëëB C
)
ëëC D
;
ëëD E
public
íí 
virtual
íí 
ushort
íí 
ReadUnsignedShort
íí /
(
íí/ 0
)
íí0 1
=>
íí2 4
this
íí5 9
.
íí9 :
Buf
íí: =
.
íí= >
ReadUnsignedShort
íí> O
(
ííO P
)
ííP Q
;
ííQ R
public
ïï 
virtual
ïï 
ushort
ïï !
ReadUnsignedShortLE
ïï 1
(
ïï1 2
)
ïï2 3
=>
ïï4 6
this
ïï7 ;
.
ïï; <
Buf
ïï< ?
.
ïï? @!
ReadUnsignedShortLE
ïï@ S
(
ïïS T
)
ïïT U
;
ïïU V
public
ññ 
virtual
ññ 
int
ññ 

ReadMedium
ññ %
(
ññ% &
)
ññ& '
=>
ññ( *
this
ññ+ /
.
ññ/ 0
Buf
ññ0 3
.
ññ3 4

ReadMedium
ññ4 >
(
ññ> ?
)
ññ? @
;
ññ@ A
public
óó 
virtual
óó 
int
óó 
ReadMediumLE
óó '
(
óó' (
)
óó( )
=>
óó* ,
this
óó- 1
.
óó1 2
Buf
óó2 5
.
óó5 6
ReadMediumLE
óó6 B
(
óóB C
)
óóC D
;
óóD E
public
õõ 
virtual
õõ 
int
õõ  
ReadUnsignedMedium
õõ -
(
õõ- .
)
õõ. /
=>
õõ0 2
this
õõ3 7
.
õõ7 8
Buf
õõ8 ;
.
õõ; < 
ReadUnsignedMedium
õõ< N
(
õõN O
)
õõO P
;
õõP Q
public
÷÷ 
virtual
÷÷ 
int
÷÷ "
ReadUnsignedMediumLE
÷÷ /
(
÷÷/ 0
)
÷÷0 1
=>
÷÷2 4
this
÷÷5 9
.
÷÷9 :
Buf
÷÷: =
.
÷÷= >"
ReadUnsignedMediumLE
÷÷> R
(
÷÷R S
)
÷÷S T
;
÷÷T U
public
ùù 
virtual
ùù 
int
ùù 
ReadInt
ùù "
(
ùù" #
)
ùù# $
=>
ùù% '
this
ùù( ,
.
ùù, -
Buf
ùù- 0
.
ùù0 1
ReadInt
ùù1 8
(
ùù8 9
)
ùù9 :
;
ùù: ;
public
ûû 
virtual
ûû 
int
ûû 
	ReadIntLE
ûû $
(
ûû$ %
)
ûû% &
=>
ûû' )
this
ûû* .
.
ûû. /
Buf
ûû/ 2
.
ûû2 3
	ReadIntLE
ûû3 <
(
ûû< =
)
ûû= >
;
ûû> ?
public
ıı 
virtual
ıı 
uint
ıı 
ReadUnsignedInt
ıı +
(
ıı+ ,
)
ıı, -
=>
ıı. 0
this
ıı1 5
.
ıı5 6
Buf
ıı6 9
.
ıı9 :
ReadUnsignedInt
ıı: I
(
ııI J
)
ııJ K
;
ııK L
public
ÿÿ 
virtual
ÿÿ 
uint
ÿÿ 
ReadUnsignedIntLE
ÿÿ -
(
ÿÿ- .
)
ÿÿ. /
=>
ÿÿ0 2
this
ÿÿ3 7
.
ÿÿ7 8
Buf
ÿÿ8 ;
.
ÿÿ; <
ReadUnsignedIntLE
ÿÿ< M
(
ÿÿM N
)
ÿÿN O
;
ÿÿO P
public
 
virtual
 
long
 
ReadLong
 $
(
$ %
)
% &
=>
' )
this
* .
.
. /
Buf
/ 2
.
2 3
ReadLong
3 ;
(
; <
)
< =
;
= >
public
ƒƒ 
virtual
ƒƒ 
long
ƒƒ 

ReadLongLE
ƒƒ &
(
ƒƒ& '
)
ƒƒ' (
=>
ƒƒ) +
this
ƒƒ, 0
.
ƒƒ0 1
Buf
ƒƒ1 4
.
ƒƒ4 5

ReadLongLE
ƒƒ5 ?
(
ƒƒ? @
)
ƒƒ@ A
;
ƒƒA B
public
…… 
virtual
…… 
char
…… 
ReadChar
…… $
(
……$ %
)
……% &
=>
……' )
this
……* .
.
……. /
Buf
……/ 2
.
……2 3
ReadChar
……3 ;
(
……; <
)
……< =
;
……= >
public
‡‡ 
virtual
‡‡ 
float
‡‡ 
	ReadFloat
‡‡ &
(
‡‡& '
)
‡‡' (
=>
‡‡) +
this
‡‡, 0
.
‡‡0 1
Buf
‡‡1 4
.
‡‡4 5
	ReadFloat
‡‡5 >
(
‡‡> ?
)
‡‡? @
;
‡‡@ A
public
‰‰ 
float
‰‰ 
ReadFloatLE
‰‰  
(
‰‰  !
)
‰‰! "
=>
‰‰# %
this
‰‰& *
.
‰‰* +
Buf
‰‰+ .
.
‰‰. /
ReadFloatLE
‰‰/ :
(
‰‰: ;
)
‰‰; <
;
‰‰< =
public
‹‹ 
virtual
‹‹ 
double
‹‹ 

ReadDouble
‹‹ (
(
‹‹( )
)
‹‹) *
=>
‹‹+ -
this
‹‹. 2
.
‹‹2 3
Buf
‹‹3 6
.
‹‹6 7

ReadDouble
‹‹7 A
(
‹‹A B
)
‹‹B C
;
‹‹C D
public
 
double
 
ReadDoubleLE
 "
(
" #
)
# $
=>
% '
this
( ,
.
, -
Buf
- 0
.
0 1
ReadDoubleLE
1 =
(
= >
)
> ?
;
? @
public
 
virtual
 
IByteBuffer
 "
	ReadBytes
# ,
(
, -
int
- 0
length
1 7
)
7 8
=>
9 ;
this
< @
.
@ A
Buf
A D
.
D E
	ReadBytes
E N
(
N O
length
O U
)
U V
;
V W
public
‘‘ 
virtual
‘‘ 
IByteBuffer
‘‘ "
	ReadSlice
‘‘# ,
(
‘‘, -
int
‘‘- 0
length
‘‘1 7
)
‘‘7 8
=>
‘‘9 ;
this
‘‘< @
.
‘‘@ A
Buf
‘‘A D
.
‘‘D E
	ReadSlice
‘‘E N
(
‘‘N O
length
‘‘O U
)
‘‘U V
;
‘‘V W
public
““ 
virtual
““ 
IByteBuffer
““ "
ReadRetainedSlice
““# 4
(
““4 5
int
““5 8
length
““9 ?
)
““? @
=>
““A C
this
““D H
.
““H I
Buf
““I L
.
““L M
ReadRetainedSlice
““M ^
(
““^ _
length
““_ e
)
““e f
;
““f g
public
•• 
Task
•• 
WriteBytesAsync
•• #
(
••# $
Stream
••$ *
stream
••+ 1
,
••1 2
int
••3 6
length
••7 =
)
••= >
=>
••? A
this
••B F
.
••F G
Buf
••G J
.
••J K
WriteBytesAsync
••K Z
(
••Z [
stream
••[ a
,
••a b
length
••c i
)
••i j
;
••j k
public
—— 
virtual
—— 
IByteBuffer
—— "
	ReadBytes
——# ,
(
——, -
IByteBuffer
——- 8
dst
——9 <
)
——< =
{
˜˜ 	
this
™™ 
.
™™ 
Buf
™™ 
.
™™ 
	ReadBytes
™™ 
(
™™ 
dst
™™ "
)
™™" #
;
™™# $
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
virtual
 
IByteBuffer
 "
	ReadBytes
# ,
(
, -
IByteBuffer
- 8
dst
9 <
,
< =
int
> A
length
B H
)
H I
{
 	
this
ŸŸ 
.
ŸŸ 
Buf
ŸŸ 
.
ŸŸ 
	ReadBytes
ŸŸ 
(
ŸŸ 
dst
ŸŸ "
,
ŸŸ" #
length
ŸŸ$ *
)
ŸŸ* +
;
ŸŸ+ ,
return
   
this
   
;
   
}
¡¡ 	
public
££ 
virtual
££ 
IByteBuffer
££ "
	ReadBytes
££# ,
(
££, -
IByteBuffer
££- 8
dst
££9 <
,
££< =
int
££> A
dstIndex
££B J
,
££J K
int
££L O
length
££P V
)
££V W
{
¤¤ 	
this
¥¥ 
.
¥¥ 
Buf
¥¥ 
.
¥¥ 
	ReadBytes
¥¥ 
(
¥¥ 
dst
¥¥ "
,
¥¥" #
dstIndex
¥¥$ ,
,
¥¥, -
length
¥¥. 4
)
¥¥4 5
;
¥¥5 6
return
¦¦ 
this
¦¦ 
;
¦¦ 
}
§§ 	
public
©© 
virtual
©© 
IByteBuffer
©© "
	ReadBytes
©©# ,
(
©©, -
byte
©©- 1
[
©©1 2
]
©©2 3
dst
©©4 7
)
©©7 8
{
ªª 	
this
«« 
.
«« 
Buf
«« 
.
«« 
	ReadBytes
«« 
(
«« 
dst
«« "
)
««" #
;
««# $
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
public
¯¯ 
virtual
¯¯ 
IByteBuffer
¯¯ "
	ReadBytes
¯¯# ,
(
¯¯, -
byte
¯¯- 1
[
¯¯1 2
]
¯¯2 3
dst
¯¯4 7
,
¯¯7 8
int
¯¯9 <
dstIndex
¯¯= E
,
¯¯E F
int
¯¯G J
length
¯¯K Q
)
¯¯Q R
{
°° 	
this
±± 
.
±± 
Buf
±± 
.
±± 
	ReadBytes
±± 
(
±± 
dst
±± "
,
±±" #
dstIndex
±±$ ,
,
±±, -
length
±±. 4
)
±±4 5
;
±±5 6
return
²² 
this
²² 
;
²² 
}
³³ 	
public
µµ 
virtual
µµ 
IByteBuffer
µµ "
	ReadBytes
µµ# ,
(
µµ, -
Stream
µµ- 3
output
µµ4 :
,
µµ: ;
int
µµ< ?
length
µµ@ F
)
µµF G
{
¶¶ 	
this
·· 
.
·· 
Buf
·· 
.
·· 
	ReadBytes
·· 
(
·· 
output
·· %
,
··% &
length
··' -
)
··- .
;
··. /
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
public
»» 
ICharSequence
»» 
ReadCharSequence
»» -
(
»»- .
int
»». 1
length
»»2 8
,
»»8 9
Encoding
»»: B
encoding
»»C K
)
»»K L
=>
»»M O
this
»»P T
.
»»T U
Buf
»»U X
.
»»X Y
ReadCharSequence
»»Y i
(
»»i j
length
»»j p
,
»»p q
encoding
»»r z
)
»»z {
;
»»{ |
public
½½ 
string
½½ 

ReadString
½½  
(
½½  !
int
½½! $
length
½½% +
,
½½+ ,
Encoding
½½- 5
encoding
½½6 >
)
½½> ?
=>
½½@ B
this
½½C G
.
½½G H
Buf
½½H K
.
½½K L

ReadString
½½L V
(
½½V W
length
½½W ]
,
½½] ^
encoding
½½_ g
)
½½g h
;
½½h i
public
¿¿ 
virtual
¿¿ 
IByteBuffer
¿¿ "
	SkipBytes
¿¿# ,
(
¿¿, -
int
¿¿- 0
length
¿¿1 7
)
¿¿7 8
{
ÀÀ 	
this
ÁÁ 
.
ÁÁ 
Buf
ÁÁ 
.
ÁÁ 
	SkipBytes
ÁÁ 
(
ÁÁ 
length
ÁÁ %
)
ÁÁ% &
;
ÁÁ& '
return
ÂÂ 
this
ÂÂ 
;
ÂÂ 
}
ÃÃ 	
public
ÅÅ 
virtual
ÅÅ 
IByteBuffer
ÅÅ "
WriteBoolean
ÅÅ# /
(
ÅÅ/ 0
bool
ÅÅ0 4
value
ÅÅ5 :
)
ÅÅ: ;
{
ÆÆ 	
this
ÇÇ 
.
ÇÇ 
Buf
ÇÇ 
.
ÇÇ 
WriteBoolean
ÇÇ !
(
ÇÇ! "
value
ÇÇ" '
)
ÇÇ' (
;
ÇÇ( )
return
ÈÈ 
this
ÈÈ 
;
ÈÈ 
}
ÉÉ 	
public
ËË 
virtual
ËË 
IByteBuffer
ËË "
	WriteByte
ËË# ,
(
ËË, -
int
ËË- 0
value
ËË1 6
)
ËË6 7
{
ÌÌ 	
this
ÍÍ 
.
ÍÍ 
Buf
ÍÍ 
.
ÍÍ 
	WriteByte
ÍÍ 
(
ÍÍ 
value
ÍÍ $
)
ÍÍ$ %
;
ÍÍ% &
return
ÎÎ 
this
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
virtual
ÑÑ 
IByteBuffer
ÑÑ "

WriteShort
ÑÑ# -
(
ÑÑ- .
int
ÑÑ. 1
value
ÑÑ2 7
)
ÑÑ7 8
{
ÒÒ 	
this
ÓÓ 
.
ÓÓ 
Buf
ÓÓ 
.
ÓÓ 

WriteShort
ÓÓ 
(
ÓÓ  
value
ÓÓ  %
)
ÓÓ% &
;
ÓÓ& '
return
ÔÔ 
this
ÔÔ 
;
ÔÔ 
}
ÕÕ 	
public
×× 
virtual
×× 
IByteBuffer
×× "
WriteShortLE
××# /
(
××/ 0
int
××0 3
value
××4 9
)
××9 :
{
ØØ 	
this
ÙÙ 
.
ÙÙ 
Buf
ÙÙ 
.
ÙÙ 
WriteShortLE
ÙÙ !
(
ÙÙ! "
value
ÙÙ" '
)
ÙÙ' (
;
ÙÙ( )
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
İİ 
IByteBuffer
İİ  
WriteUnsignedShort
İİ -
(
İİ- .
ushort
İİ. 4
value
İİ5 :
)
İİ: ;
=>
İİ< >
this
İİ? C
.
İİC D
Buf
İİD G
.
İİG H 
WriteUnsignedShort
İİH Z
(
İİZ [
value
İİ[ `
)
İİ` a
;
İİa b
public
ßß 
IByteBuffer
ßß "
WriteUnsignedShortLE
ßß /
(
ßß/ 0
ushort
ßß0 6
value
ßß7 <
)
ßß< =
=>
ßß> @
this
ßßA E
.
ßßE F
Buf
ßßF I
.
ßßI J"
WriteUnsignedShortLE
ßßJ ^
(
ßß^ _
value
ßß_ d
)
ßßd e
;
ßße f
public
áá 
virtual
áá 
IByteBuffer
áá "
WriteMedium
áá# .
(
áá. /
int
áá/ 2
value
áá3 8
)
áá8 9
{
ââ 	
this
ãã 
.
ãã 
Buf
ãã 
.
ãã 
WriteMedium
ãã  
(
ãã  !
value
ãã! &
)
ãã& '
;
ãã' (
return
ää 
this
ää 
;
ää 
}
åå 	
public
çç 
virtual
çç 
IByteBuffer
çç "
WriteMediumLE
çç# 0
(
çç0 1
int
çç1 4
value
çç5 :
)
çç: ;
{
èè 	
this
éé 
.
éé 
Buf
éé 
.
éé 
WriteMediumLE
éé "
(
éé" #
value
éé# (
)
éé( )
;
éé) *
return
êê 
this
êê 
;
êê 
}
ëë 	
public
íí 
virtual
íí 
IByteBuffer
íí "
WriteInt
íí# +
(
íí+ ,
int
íí, /
value
íí0 5
)
íí5 6
{
îî 	
this
ïï 
.
ïï 
Buf
ïï 
.
ïï 
WriteInt
ïï 
(
ïï 
value
ïï #
)
ïï# $
;
ïï$ %
return
ğğ 
this
ğğ 
;
ğğ 
}
ññ 	
public
óó 
virtual
óó 
IByteBuffer
óó "

WriteIntLE
óó# -
(
óó- .
int
óó. 1
value
óó2 7
)
óó7 8
{
ôô 	
this
õõ 
.
õõ 
Buf
õõ 
.
õõ 

WriteIntLE
õõ 
(
õõ  
value
õõ  %
)
õõ% &
;
õõ& '
return
öö 
this
öö 
;
öö 
}
÷÷ 	
public
ùù 
virtual
ùù 
IByteBuffer
ùù "
	WriteLong
ùù# ,
(
ùù, -
long
ùù- 1
value
ùù2 7
)
ùù7 8
{
úú 	
this
ûû 
.
ûû 
Buf
ûû 
.
ûû 
	WriteLong
ûû 
(
ûû 
value
ûû $
)
ûû$ %
;
ûû% &
return
üü 
this
üü 
;
üü 
}
ıı 	
public
ÿÿ 
virtual
ÿÿ 
IByteBuffer
ÿÿ "
WriteLongLE
ÿÿ# .
(
ÿÿ. /
long
ÿÿ/ 3
value
ÿÿ4 9
)
ÿÿ9 :
{
€€ 	
this
 
.
 
Buf
 
.
 
WriteLongLE
  
(
  !
value
! &
)
& '
;
' (
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
ƒƒ 	
public
…… 
virtual
…… 
IByteBuffer
…… "
	WriteChar
……# ,
(
……, -
char
……- 1
value
……2 7
)
……7 8
{
†† 	
this
‡‡ 
.
‡‡ 
Buf
‡‡ 
.
‡‡ 
	WriteChar
‡‡ 
(
‡‡ 
value
‡‡ $
)
‡‡$ %
;
‡‡% &
return
ˆˆ 
this
ˆˆ 
;
ˆˆ 
}
‰‰ 	
public
‹‹ 
virtual
‹‹ 
IByteBuffer
‹‹ "

WriteFloat
‹‹# -
(
‹‹- .
float
‹‹. 3
value
‹‹4 9
)
‹‹9 :
{
ŒŒ 	
this
 
.
 
Buf
 
.
 

WriteFloat
 
(
  
value
  %
)
% &
;
& '
return
 
this
 
;
 
}
 	
public
‘‘ 
IByteBuffer
‘‘ 
WriteFloatLE
‘‘ '
(
‘‘' (
float
‘‘( -
value
‘‘. 3
)
‘‘3 4
{
’’ 	
this
““ 
.
““ 
Buf
““ 
.
““ 
WriteFloatLE
““ !
(
““! "
value
““" '
)
““' (
;
““( )
return
”” 
this
”” 
;
”” 
}
•• 	
public
—— 
virtual
—— 
IByteBuffer
—— "
WriteDouble
——# .
(
——. /
double
——/ 5
value
——6 ;
)
——; <
{
˜˜ 	
this
™™ 
.
™™ 
Buf
™™ 
.
™™ 
WriteDouble
™™  
(
™™  !
value
™™! &
)
™™& '
;
™™' (
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
IByteBuffer
 
WriteDoubleLE
 (
(
( )
double
) /
value
0 5
)
5 6
{
 	
this
ŸŸ 
.
ŸŸ 
Buf
ŸŸ 
.
ŸŸ 
WriteDoubleLE
ŸŸ "
(
ŸŸ" #
value
ŸŸ# (
)
ŸŸ( )
;
ŸŸ) *
return
   
this
   
;
   
}
¡¡ 	
public
££ 
virtual
££ 
IByteBuffer
££ "

WriteBytes
££# -
(
££- .
IByteBuffer
££. 9
src
££: =
)
££= >
{
¤¤ 	
this
¥¥ 
.
¥¥ 
Buf
¥¥ 
.
¥¥ 

WriteBytes
¥¥ 
(
¥¥  
src
¥¥  #
)
¥¥# $
;
¥¥$ %
return
¦¦ 
this
¦¦ 
;
¦¦ 
}
§§ 	
public
©© 
virtual
©© 
IByteBuffer
©© "

WriteBytes
©©# -
(
©©- .
IByteBuffer
©©. 9
src
©©: =
,
©©= >
int
©©? B
length
©©C I
)
©©I J
{
ªª 	
this
«« 
.
«« 
Buf
«« 
.
«« 

WriteBytes
«« 
(
««  
src
««  #
,
««# $
length
««% +
)
««+ ,
;
««, -
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
public
¯¯ 
virtual
¯¯ 
IByteBuffer
¯¯ "

WriteBytes
¯¯# -
(
¯¯- .
IByteBuffer
¯¯. 9
src
¯¯: =
,
¯¯= >
int
¯¯? B
srcIndex
¯¯C K
,
¯¯K L
int
¯¯M P
length
¯¯Q W
)
¯¯W X
{
°° 	
this
±± 
.
±± 
Buf
±± 
.
±± 

WriteBytes
±± 
(
±±  
src
±±  #
,
±±# $
srcIndex
±±% -
,
±±- .
length
±±/ 5
)
±±5 6
;
±±6 7
return
²² 
this
²² 
;
²² 
}
³³ 	
public
µµ 
virtual
µµ 
IByteBuffer
µµ "

WriteBytes
µµ# -
(
µµ- .
byte
µµ. 2
[
µµ2 3
]
µµ3 4
src
µµ5 8
)
µµ8 9
{
¶¶ 	
this
·· 
.
·· 
Buf
·· 
.
·· 

WriteBytes
·· 
(
··  
src
··  #
)
··# $
;
··$ %
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
¹¹ 	
public
»» 
virtual
»» 
IByteBuffer
»» "

WriteBytes
»»# -
(
»»- .
byte
»». 2
[
»»2 3
]
»»3 4
src
»»5 8
,
»»8 9
int
»»: =
srcIndex
»»> F
,
»»F G
int
»»H K
length
»»L R
)
»»R S
{
¼¼ 	
this
½½ 
.
½½ 
Buf
½½ 
.
½½ 

WriteBytes
½½ 
(
½½  
src
½½  #
,
½½# $
srcIndex
½½% -
,
½½- .
length
½½/ 5
)
½½5 6
;
½½6 7
return
¾¾ 
this
¾¾ 
;
¾¾ 
}
¿¿ 	
public
ÁÁ 
virtual
ÁÁ 
Task
ÁÁ 
WriteBytesAsync
ÁÁ +
(
ÁÁ+ ,
Stream
ÁÁ, 2
input
ÁÁ3 8
,
ÁÁ8 9
int
ÁÁ: =
length
ÁÁ> D
,
ÁÁD E
CancellationToken
ÁÁF W
cancellationToken
ÁÁX i
)
ÁÁi j
=>
ÁÁk m
this
ÁÁn r
.
ÁÁr s
Buf
ÁÁs v
.
ÁÁv w
WriteBytesAsyncÁÁw †
(ÁÁ† ‡
inputÁÁ‡ Œ
,ÁÁŒ 
lengthÁÁ ”
,ÁÁ” •!
cancellationTokenÁÁ– §
)ÁÁ§ ¨
;ÁÁ¨ ©
public
ÃÃ 
virtual
ÃÃ 
IByteBuffer
ÃÃ "
	WriteZero
ÃÃ# ,
(
ÃÃ, -
int
ÃÃ- 0
length
ÃÃ1 7
)
ÃÃ7 8
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
Buf
ÅÅ 
.
ÅÅ 
	WriteZero
ÅÅ 
(
ÅÅ 
length
ÅÅ %
)
ÅÅ% &
;
ÅÅ& '
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
int
ÉÉ 
WriteCharSequence
ÉÉ $
(
ÉÉ$ %
ICharSequence
ÉÉ% 2
sequence
ÉÉ3 ;
,
ÉÉ; <
Encoding
ÉÉ= E
encoding
ÉÉF N
)
ÉÉN O
=>
ÉÉP R
this
ÉÉS W
.
ÉÉW X
Buf
ÉÉX [
.
ÉÉ[ \
WriteCharSequence
ÉÉ\ m
(
ÉÉm n
sequence
ÉÉn v
,
ÉÉv w
encodingÉÉx €
)ÉÉ€ 
;ÉÉ ‚
public
ËË 
int
ËË 
WriteString
ËË 
(
ËË 
string
ËË %
value
ËË& +
,
ËË+ ,
Encoding
ËË- 5
encoding
ËË6 >
)
ËË> ?
=>
ËË@ B
this
ËËC G
.
ËËG H
Buf
ËËH K
.
ËËK L
WriteString
ËËL W
(
ËËW X
value
ËËX ]
,
ËË] ^
encoding
ËË_ g
)
ËËg h
;
ËËh i
public
ÍÍ 
virtual
ÍÍ 
int
ÍÍ 
IndexOf
ÍÍ "
(
ÍÍ" #
int
ÍÍ# &
	fromIndex
ÍÍ' 0
,
ÍÍ0 1
int
ÍÍ2 5
toIndex
ÍÍ6 =
,
ÍÍ= >
byte
ÍÍ? C
value
ÍÍD I
)
ÍÍI J
=>
ÍÍK M
this
ÍÍN R
.
ÍÍR S
Buf
ÍÍS V
.
ÍÍV W
IndexOf
ÍÍW ^
(
ÍÍ^ _
	fromIndex
ÍÍ_ h
,
ÍÍh i
toIndex
ÍÍj q
,
ÍÍq r
value
ÍÍs x
)
ÍÍx y
;
ÍÍy z
public
ÏÏ 
virtual
ÏÏ 
int
ÏÏ 
BytesBefore
ÏÏ &
(
ÏÏ& '
byte
ÏÏ' +
value
ÏÏ, 1
)
ÏÏ1 2
=>
ÏÏ3 5
this
ÏÏ6 :
.
ÏÏ: ;
Buf
ÏÏ; >
.
ÏÏ> ?
BytesBefore
ÏÏ? J
(
ÏÏJ K
value
ÏÏK P
)
ÏÏP Q
;
ÏÏQ R
public
ÑÑ 
virtual
ÑÑ 
int
ÑÑ 
BytesBefore
ÑÑ &
(
ÑÑ& '
int
ÑÑ' *
length
ÑÑ+ 1
,
ÑÑ1 2
byte
ÑÑ3 7
value
ÑÑ8 =
)
ÑÑ= >
=>
ÑÑ? A
this
ÑÑB F
.
ÑÑF G
Buf
ÑÑG J
.
ÑÑJ K
BytesBefore
ÑÑK V
(
ÑÑV W
length
ÑÑW ]
,
ÑÑ] ^
value
ÑÑ_ d
)
ÑÑd e
;
ÑÑe f
public
ÓÓ 
virtual
ÓÓ 
int
ÓÓ 
BytesBefore
ÓÓ &
(
ÓÓ& '
int
ÓÓ' *
index
ÓÓ+ 0
,
ÓÓ0 1
int
ÓÓ2 5
length
ÓÓ6 <
,
ÓÓ< =
byte
ÓÓ> B
value
ÓÓC H
)
ÓÓH I
=>
ÓÓJ L
this
ÓÓM Q
.
ÓÓQ R
Buf
ÓÓR U
.
ÓÓU V
BytesBefore
ÓÓV a
(
ÓÓa b
index
ÓÓb g
,
ÓÓg h
length
ÓÓi o
,
ÓÓo p
value
ÓÓq v
)
ÓÓv w
;
ÓÓw x
public
ÕÕ 
virtual
ÕÕ 
int
ÕÕ 
ForEachByte
ÕÕ &
(
ÕÕ& '
IByteProcessor
ÕÕ' 5
	processor
ÕÕ6 ?
)
ÕÕ? @
=>
ÕÕA C
this
ÕÕD H
.
ÕÕH I
Buf
ÕÕI L
.
ÕÕL M
ForEachByte
ÕÕM X
(
ÕÕX Y
	processor
ÕÕY b
)
ÕÕb c
;
ÕÕc d
public
×× 
virtual
×× 
int
×× 
ForEachByte
×× &
(
××& '
int
××' *
index
××+ 0
,
××0 1
int
××2 5
length
××6 <
,
××< =
IByteProcessor
××> L
	processor
××M V
)
××V W
=>
××X Z
this
××[ _
.
××_ `
Buf
××` c
.
××c d
ForEachByte
××d o
(
××o p
index
××p u
,
××u v
length
××w }
,
××} ~
	processor×× ˆ
)××ˆ ‰
;××‰ Š
public
ÙÙ 
virtual
ÙÙ 
int
ÙÙ 
ForEachByteDesc
ÙÙ *
(
ÙÙ* +
IByteProcessor
ÙÙ+ 9
	processor
ÙÙ: C
)
ÙÙC D
=>
ÙÙE G
this
ÙÙH L
.
ÙÙL M
Buf
ÙÙM P
.
ÙÙP Q
ForEachByteDesc
ÙÙQ `
(
ÙÙ` a
	processor
ÙÙa j
)
ÙÙj k
;
ÙÙk l
public
ÛÛ 
virtual
ÛÛ 
int
ÛÛ 
ForEachByteDesc
ÛÛ *
(
ÛÛ* +
int
ÛÛ+ .
index
ÛÛ/ 4
,
ÛÛ4 5
int
ÛÛ6 9
length
ÛÛ: @
,
ÛÛ@ A
IByteProcessor
ÛÛB P
	processor
ÛÛQ Z
)
ÛÛZ [
=>
ÛÛ\ ^
this
ÛÛ_ c
.
ÛÛc d
Buf
ÛÛd g
.
ÛÛg h
ForEachByteDesc
ÛÛh w
(
ÛÛw x
index
ÛÛx }
,
ÛÛ} ~
lengthÛÛ …
,ÛÛ… †
	processorÛÛ‡ 
)ÛÛ ‘
;ÛÛ‘ ’
public
İİ 
virtual
İİ 
IByteBuffer
İİ "
Copy
İİ# '
(
İİ' (
)
İİ( )
=>
İİ* ,
this
İİ- 1
.
İİ1 2
Buf
İİ2 5
.
İİ5 6
Copy
İİ6 :
(
İİ: ;
)
İİ; <
;
İİ< =
public
ßß 
virtual
ßß 
IByteBuffer
ßß "
Copy
ßß# '
(
ßß' (
int
ßß( +
index
ßß, 1
,
ßß1 2
int
ßß3 6
length
ßß7 =
)
ßß= >
=>
ßß? A
this
ßßB F
.
ßßF G
Buf
ßßG J
.
ßßJ K
Copy
ßßK O
(
ßßO P
index
ßßP U
,
ßßU V
length
ßßW ]
)
ßß] ^
;
ßß^ _
public
áá 
virtual
áá 
IByteBuffer
áá "
Slice
áá# (
(
áá( )
)
áá) *
=>
áá+ -
this
áá. 2
.
áá2 3
Buf
áá3 6
.
áá6 7
Slice
áá7 <
(
áá< =
)
áá= >
;
áá> ?
public
ãã 
virtual
ãã 
IByteBuffer
ãã "
RetainedSlice
ãã# 0
(
ãã0 1
)
ãã1 2
=>
ãã3 5
this
ãã6 :
.
ãã: ;
Buf
ãã; >
.
ãã> ?
RetainedSlice
ãã? L
(
ããL M
)
ããM N
;
ããN O
public
åå 
virtual
åå 
IByteBuffer
åå "
Slice
åå# (
(
åå( )
int
åå) ,
index
åå- 2
,
åå2 3
int
åå4 7
length
åå8 >
)
åå> ?
=>
åå@ B
this
ååC G
.
ååG H
Buf
ååH K
.
ååK L
Slice
ååL Q
(
ååQ R
index
ååR W
,
ååW X
length
ååY _
)
åå_ `
;
åå` a
public
çç 
virtual
çç 
IByteBuffer
çç "
RetainedSlice
çç# 0
(
çç0 1
int
çç1 4
index
çç5 :
,
çç: ;
int
çç< ?
length
çç@ F
)
ççF G
=>
ççH J
this
ççK O
.
ççO P
Buf
ççP S
.
ççS T
RetainedSlice
ççT a
(
çça b
index
ççb g
,
ççg h
length
ççi o
)
çço p
;
ççp q
public
éé 
virtual
éé 
IByteBuffer
éé "
	Duplicate
éé# ,
(
éé, -
)
éé- .
=>
éé/ 1
this
éé2 6
.
éé6 7
Buf
éé7 :
.
éé: ;
	Duplicate
éé; D
(
ééD E
)
ééE F
;
ééF G
public
ëë 
virtual
ëë 
IByteBuffer
ëë "
RetainedDuplicate
ëë# 4
(
ëë4 5
)
ëë5 6
=>
ëë7 9
this
ëë: >
.
ëë> ?
Buf
ëë? B
.
ëëB C
RetainedDuplicate
ëëC T
(
ëëT U
)
ëëU V
;
ëëV W
public
íí 
virtual
íí 
int
íí 
IoBufferCount
íí (
=>
íí) +
this
íí, 0
.
íí0 1
Buf
íí1 4
.
íí4 5
IoBufferCount
íí5 B
;
ííB C
public
ïï 
virtual
ïï 
ArraySegment
ïï #
<
ïï# $
byte
ïï$ (
>
ïï( )
GetIoBuffer
ïï* 5
(
ïï5 6
)
ïï6 7
=>
ïï8 :
this
ïï; ?
.
ïï? @
Buf
ïï@ C
.
ïïC D
GetIoBuffer
ïïD O
(
ïïO P
)
ïïP Q
;
ïïQ R
public
ññ 
virtual
ññ 
ArraySegment
ññ #
<
ññ# $
byte
ññ$ (
>
ññ( )
GetIoBuffer
ññ* 5
(
ññ5 6
int
ññ6 9
index
ññ: ?
,
ññ? @
int
ññA D
length
ññE K
)
ññK L
=>
ññM O
this
ññP T
.
ññT U
Buf
ññU X
.
ññX Y
GetIoBuffer
ññY d
(
ññd e
index
ññe j
,
ññj k
length
ññl r
)
ññr s
;
ññs t
public
óó 
virtual
óó 
ArraySegment
óó #
<
óó# $
byte
óó$ (
>
óó( )
[
óó) *
]
óó* +
GetIoBuffers
óó, 8
(
óó8 9
)
óó9 :
=>
óó; =
this
óó> B
.
óóB C
Buf
óóC F
.
óóF G
GetIoBuffers
óóG S
(
óóS T
)
óóT U
;
óóU V
public
õõ 
virtual
õõ 
ArraySegment
õõ #
<
õõ# $
byte
õõ$ (
>
õõ( )
[
õõ) *
]
õõ* +
GetIoBuffers
õõ, 8
(
õõ8 9
int
õõ9 <
index
õõ= B
,
õõB C
int
õõD G
length
õõH N
)
õõN O
=>
õõP R
this
õõS W
.
õõW X
Buf
õõX [
.
õõ[ \
GetIoBuffers
õõ\ h
(
õõh i
index
õõi n
,
õõn o
length
õõp v
)
õõv w
;
õõw x
public
÷÷ 
bool
÷÷ 
HasArray
÷÷ 
=>
÷÷ 
this
÷÷  $
.
÷÷$ %
Buf
÷÷% (
.
÷÷( )
HasArray
÷÷) 1
;
÷÷1 2
public
ùù 
int
ùù 
ArrayOffset
ùù 
=>
ùù !
this
ùù" &
.
ùù& '
Buf
ùù' *
.
ùù* +
ArrayOffset
ùù+ 6
;
ùù6 7
public
ûû 
byte
ûû 
[
ûû 
]
ûû 
Array
ûû 
=>
ûû 
this
ûû #
.
ûû# $
Buf
ûû$ '
.
ûû' (
Array
ûû( -
;
ûû- .
public
ıı 
virtual
ıı 
string
ıı 
ToString
ıı &
(
ıı& '
Encoding
ıı' /
encoding
ıı0 8
)
ıı8 9
=>
ıı: <
this
ıı= A
.
ııA B
Buf
ııB E
.
ııE F
ToString
ııF N
(
ııN O
encoding
ııO W
)
ııW X
;
ııX Y
public
ÿÿ 
virtual
ÿÿ 
string
ÿÿ 
ToString
ÿÿ &
(
ÿÿ& '
int
ÿÿ' *
index
ÿÿ+ 0
,
ÿÿ0 1
int
ÿÿ2 5
length
ÿÿ6 <
,
ÿÿ< =
Encoding
ÿÿ> F
encoding
ÿÿG O
)
ÿÿO P
=>
ÿÿQ S
this
ÿÿT X
.
ÿÿX Y
Buf
ÿÿY \
.
ÿÿ\ ]
ToString
ÿÿ] e
(
ÿÿe f
index
ÿÿf k
,
ÿÿk l
length
ÿÿm s
,
ÿÿs t
encoding
ÿÿu }
)
ÿÿ} ~
;
ÿÿ~ 
public
 
override
 
int
 
GetHashCode
 '
(
' (
)
( )
=>
* ,
this
- 1
.
1 2
Buf
2 5
.
5 6
GetHashCode
6 A
(
A B
)
B C
;
C D
public
ƒƒ 
override
ƒƒ 
bool
ƒƒ 
Equals
ƒƒ #
(
ƒƒ# $
object
ƒƒ$ *
obj
ƒƒ+ .
)
ƒƒ. /
=>
ƒƒ0 2
this
ƒƒ3 7
.
ƒƒ7 8
Buf
ƒƒ8 ;
.
ƒƒ; <
Equals
ƒƒ< B
(
ƒƒB C
obj
ƒƒC F
)
ƒƒF G
;
ƒƒG H
public
…… 
bool
…… 
Equals
…… 
(
…… 
IByteBuffer
…… &
buffer
……' -
)
……- .
=>
……/ 1
this
……2 6
.
……6 7
Buf
……7 :
.
……: ;
Equals
……; A
(
……A B
buffer
……B H
)
……H I
;
……I J
public
‡‡ 
int
‡‡ 
	CompareTo
‡‡ 
(
‡‡ 
IByteBuffer
‡‡ (
buffer
‡‡) /
)
‡‡/ 0
=>
‡‡1 3
this
‡‡4 8
.
‡‡8 9
Buf
‡‡9 <
.
‡‡< =
	CompareTo
‡‡= F
(
‡‡F G
buffer
‡‡G M
)
‡‡M N
;
‡‡N O
public
‰‰ 
override
‰‰ 
string
‰‰ 
ToString
‰‰ '
(
‰‰' (
)
‰‰( )
=>
‰‰* ,
this
‰‰- 1
.
‰‰1 2
GetType
‰‰2 9
(
‰‰9 :
)
‰‰: ;
.
‰‰; <
Name
‰‰< @
+
‰‰A B
$char
‰‰C F
+
‰‰G H
this
‰‰I M
.
‰‰M N
Buf
‰‰N Q
+
‰‰R S
$char
‰‰T W
;
‰‰W X
public
‹‹ 
virtual
‹‹ 
IReferenceCounted
‹‹ (
Retain
‹‹) /
(
‹‹/ 0
int
‹‹0 3
	increment
‹‹4 =
)
‹‹= >
{
ŒŒ 	
this
 
.
 
Buf
 
.
 
Retain
 
(
 
	increment
 %
)
% &
;
& '
return
 
this
 
;
 
}
 	
public
‘‘ 
virtual
‘‘ 
IReferenceCounted
‘‘ (
Retain
‘‘) /
(
‘‘/ 0
)
‘‘0 1
{
’’ 	
this
““ 
.
““ 
Buf
““ 
.
““ 
Retain
““ 
(
““ 
)
““ 
;
““ 
return
”” 
this
”” 
;
”” 
}
•• 	
public
—— 
virtual
—— 
IReferenceCounted
—— (
Touch
——) .
(
——. /
)
——/ 0
{
˜˜ 	
this
™™ 
.
™™ 
Buf
™™ 
.
™™ 
Touch
™™ 
(
™™ 
)
™™ 
;
™™ 
return
šš 
this
šš 
;
šš 
}
›› 	
public
 
virtual
 
IReferenceCounted
 (
Touch
) .
(
. /
object
/ 5
hint
6 :
)
: ;
{
 	
this
ŸŸ 
.
ŸŸ 
Buf
ŸŸ 
.
ŸŸ 
Touch
ŸŸ 
(
ŸŸ 
hint
ŸŸ 
)
ŸŸ  
;
ŸŸ  !
return
   
this
   
;
   
}
¡¡ 	
public
££ 
bool
££ 

IsReadable
££ 
(
££ 
int
££ "
size
££# '
)
££' (
=>
££) +
this
££, 0
.
££0 1
Buf
££1 4
.
££4 5

IsReadable
££5 ?
(
££? @
size
££@ D
)
££D E
;
££E F
public
¥¥ 
bool
¥¥ 

IsWritable
¥¥ 
(
¥¥ 
int
¥¥ "
size
¥¥# '
)
¥¥' (
=>
¥¥) +
this
¥¥, 0
.
¥¥0 1
Buf
¥¥1 4
.
¥¥4 5

IsWritable
¥¥5 ?
(
¥¥? @
size
¥¥@ D
)
¥¥D E
;
¥¥E F
public
§§ 
int
§§ 
ReferenceCount
§§ !
=>
§§" $
this
§§% )
.
§§) *
Buf
§§* -
.
§§- .
ReferenceCount
§§. <
;
§§< =
public
©© 
virtual
©© 
bool
©© 
Release
©© #
(
©©# $
)
©©$ %
=>
©©& (
this
©©) -
.
©©- .
Buf
©©. 1
.
©©1 2
Release
©©2 9
(
©©9 :
)
©©: ;
;
©©; <
public
«« 
virtual
«« 
bool
«« 
Release
«« #
(
««# $
int
««$ '
	decrement
««( 1
)
««1 2
=>
««3 5
this
««6 :
.
««: ;
Buf
««; >
.
««> ?
Release
««? F
(
««F G
	decrement
««G P
)
««P Q
;
««Q R
}
¬¬ 
}­­ Ğˆ
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\WrappedCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	&
WrappedCompositeByteBuffer
 $
:% &
CompositeByteBuffer' :
{ 
readonly 
CompositeByteBuffer $
wrapped% ,
;, -
internal &
WrappedCompositeByteBuffer +
(+ ,
CompositeByteBuffer, ?
wrapped@ G
)G H
:I J
baseK O
(O P
wrappedP W
.W X
	AllocatorX a
)a b
{ 	
this 
. 
wrapped 
= 
wrapped "
;" #
this 
. 
SetMaxCapacity 
(  
this  $
.$ %
wrapped% ,
., -
MaxCapacity- 8
)8 9
;9 :
} 	
public 
override 
bool 
Release $
($ %
)% &
=>' )
this* .
.. /
wrapped/ 6
.6 7
Release7 >
(> ?
)? @
;@ A
public 
override 
bool 
Release $
($ %
int% (
	decrement) 2
)2 3
=>4 6
this7 ;
.; <
wrapped< C
.C D
ReleaseD K
(K L
	decrementL U
)U V
;V W
public 
sealed 
override 
int "
ReaderIndex# .
=>/ 1
this2 6
.6 7
wrapped7 >
.> ?
ReaderIndex? J
;J K
public 
sealed 
override 
int "
WriterIndex# .
=>/ 1
this2 6
.6 7
wrapped7 >
.> ?
WriterIndex? J
;J K
public!! 
sealed!! 
override!! 
bool!! #

IsReadable!!$ .
(!!. /
)!!/ 0
=>!!1 3
this!!4 8
.!!8 9
wrapped!!9 @
.!!@ A

IsReadable!!A K
(!!K L
)!!L M
;!!M N
public## 
sealed## 
override## 
bool## #

IsReadable##$ .
(##. /
int##/ 2
numBytes##3 ;
)##; <
=>##= ?
this##@ D
.##D E
wrapped##E L
.##L M

IsReadable##M W
(##W X
numBytes##X `
)##` a
;##a b
public%% 
sealed%% 
override%% 
bool%% #

IsWritable%%$ .
(%%. /
)%%/ 0
=>%%1 3
this%%4 8
.%%8 9
wrapped%%9 @
.%%@ A

IsWritable%%A K
(%%K L
)%%L M
;%%M N
public'' 
sealed'' 
override'' 
int'' "
ReadableBytes''# 0
=>''1 3
this''4 8
.''8 9
wrapped''9 @
.''@ A
ReadableBytes''A N
;''N O
public)) 
sealed)) 
override)) 
int)) "
WritableBytes))# 0
=>))1 3
this))4 8
.))8 9
wrapped))9 @
.))@ A
WritableBytes))A N
;))N O
public++ 
sealed++ 
override++ 
int++ "
MaxWritableBytes++# 3
=>++4 6
this++7 ;
.++; <
wrapped++< C
.++C D
MaxWritableBytes++D T
;++T U
public-- 
override-- 
int-- 
EnsureWritable-- *
(--* +
int--+ .
minWritableBytes--/ ?
,--? @
bool--A E
force--F K
)--K L
=>--M O
this--P T
.--T U
wrapped--U \
.--\ ]
EnsureWritable--] k
(--k l
minWritableBytes--l |
,--| }
force	--~ ƒ
)
--ƒ „
;
--„ …
public// 
override// 
short// 
GetShort// &
(//& '
int//' *
index//+ 0
)//0 1
=>//2 4
this//5 9
.//9 :
wrapped//: A
.//A B
GetShort//B J
(//J K
index//K P
)//P Q
;//Q R
public11 
override11 
short11 

GetShortLE11 (
(11( )
int11) ,
index11- 2
)112 3
=>114 6
this117 ;
.11; <
wrapped11< C
.11C D

GetShortLE11D N
(11N O
index11O T
)11T U
;11U V
public33 
override33 
int33 
GetUnsignedMedium33 -
(33- .
int33. 1
index332 7
)337 8
=>339 ;
this33< @
.33@ A
wrapped33A H
.33H I
GetUnsignedMedium33I Z
(33Z [
index33[ `
)33` a
;33a b
public55 
override55 
int55 
GetUnsignedMediumLE55 /
(55/ 0
int550 3
index554 9
)559 :
=>55; =
this55> B
.55B C
wrapped55C J
.55J K
GetUnsignedMediumLE55K ^
(55^ _
index55_ d
)55d e
;55e f
public77 
override77 
int77 
GetInt77 "
(77" #
int77# &
index77' ,
)77, -
=>77. 0
this771 5
.775 6
wrapped776 =
.77= >
GetInt77> D
(77D E
index77E J
)77J K
;77K L
public99 
override99 
int99 
GetIntLE99 $
(99$ %
int99% (
index99) .
)99. /
=>990 2
this993 7
.997 8
wrapped998 ?
.99? @
GetIntLE99@ H
(99H I
index99I N
)99N O
;99O P
public;; 
override;; 
long;; 
GetLong;; $
(;;$ %
int;;% (
index;;) .
);;. /
=>;;0 2
this;;3 7
.;;7 8
wrapped;;8 ?
.;;? @
GetLong;;@ G
(;;G H
index;;H M
);;M N
;;;N O
public== 
override== 
long== 
	GetLongLE== &
(==& '
int==' *
index==+ 0
)==0 1
=>==2 4
this==5 9
.==9 :
wrapped==: A
.==A B
	GetLongLE==B K
(==K L
index==L Q
)==Q R
;==R S
public?? 
override?? 
char?? 
GetChar?? $
(??$ %
int??% (
index??) .
)??. /
=>??0 2
this??3 7
.??7 8
wrapped??8 ?
.??? @
GetChar??@ G
(??G H
index??H M
)??M N
;??N O
publicAA 
overrideAA 
IByteBufferAA #

SetShortLEAA$ .
(AA. /
intAA/ 2
indexAA3 8
,AA8 9
intAA: =
valueAA> C
)AAC D
=>AAE G
thisAAH L
.AAL M
wrappedAAM T
.AAT U

SetShortLEAAU _
(AA_ `
indexAA` e
,AAe f
valueAAg l
)AAl m
;AAm n
publicCC 
overrideCC 
IByteBufferCC #
SetMediumLECC$ /
(CC/ 0
intCC0 3
indexCC4 9
,CC9 :
intCC; >
valueCC? D
)CCD E
=>CCF H
thisCCI M
.CCM N
wrappedCCN U
.CCU V
SetMediumLECCV a
(CCa b
indexCCb g
,CCg h
valueCCi n
)CCn o
;CCo p
publicEE 
overrideEE 
IByteBufferEE #
SetIntLEEE$ ,
(EE, -
intEE- 0
indexEE1 6
,EE6 7
intEE8 ;
valueEE< A
)EEA B
=>EEC E
thisEEF J
.EEJ K
wrappedEEK R
.EER S
SetIntLEEES [
(EE[ \
indexEE\ a
,EEa b
valueEEc h
)EEh i
;EEi j
publicGG 
overrideGG 
IByteBufferGG #
	SetLongLEGG$ -
(GG- .
intGG. 1
indexGG2 7
,GG7 8
longGG9 =
valueGG> C
)GGC D
=>GGE G
thisGGH L
.GGL M
wrappedGGM T
.GGT U
	SetLongLEGGU ^
(GG^ _
indexGG_ d
,GGd e
valueGGf k
)GGk l
;GGl m
publicII 
overrideII 
byteII 
ReadByteII %
(II% &
)II& '
=>II( *
thisII+ /
.II/ 0
wrappedII0 7
.II7 8
ReadByteII8 @
(II@ A
)IIA B
;IIB C
publicKK 
overrideKK 
shortKK 
	ReadShortKK '
(KK' (
)KK( )
=>KK* ,
thisKK- 1
.KK1 2
wrappedKK2 9
.KK9 :
	ReadShortKK: C
(KKC D
)KKD E
;KKE F
publicMM 
overrideMM 
shortMM 
ReadShortLEMM )
(MM) *
)MM* +
=>MM, .
thisMM/ 3
.MM3 4
wrappedMM4 ;
.MM; <
ReadShortLEMM< G
(MMG H
)MMH I
;MMI J
publicOO 
overrideOO 
intOO 
ReadUnsignedMediumOO .
(OO. /
)OO/ 0
=>OO1 3
thisOO4 8
.OO8 9
wrappedOO9 @
.OO@ A
ReadUnsignedMediumOOA S
(OOS T
)OOT U
;OOU V
publicQQ 
overrideQQ 
intQQ  
ReadUnsignedMediumLEQQ 0
(QQ0 1
)QQ1 2
=>QQ3 5
thisQQ6 :
.QQ: ;
wrappedQQ; B
.QQB C 
ReadUnsignedMediumLEQQC W
(QQW X
)QQX Y
;QQY Z
publicSS 
overrideSS 
intSS 
ReadIntSS #
(SS# $
)SS$ %
=>SS& (
thisSS) -
.SS- .
wrappedSS. 5
.SS5 6
ReadIntSS6 =
(SS= >
)SS> ?
;SS? @
publicUU 
overrideUU 
intUU 
	ReadIntLEUU %
(UU% &
)UU& '
=>UU( *
thisUU+ /
.UU/ 0
wrappedUU0 7
.UU7 8
	ReadIntLEUU8 A
(UUA B
)UUB C
;UUC D
publicWW 
overrideWW 
longWW 
ReadLongWW %
(WW% &
)WW& '
=>WW( *
thisWW+ /
.WW/ 0
wrappedWW0 7
.WW7 8
ReadLongWW8 @
(WW@ A
)WWA B
;WWB C
publicYY 
overrideYY 
longYY 

ReadLongLEYY '
(YY' (
)YY( )
=>YY* ,
thisYY- 1
.YY1 2
wrappedYY2 9
.YY9 :

ReadLongLEYY: D
(YYD E
)YYE F
;YYF G
public[[ 
override[[ 
IByteBuffer[[ #
	ReadBytes[[$ -
([[- .
int[[. 1
length[[2 8
)[[8 9
=>[[: <
this[[= A
.[[A B
wrapped[[B I
.[[I J
	ReadBytes[[J S
([[S T
length[[T Z
)[[Z [
;[[[ \
public]] 
override]] 
IByteBuffer]] #
Slice]]$ )
(]]) *
)]]* +
=>]], .
this]]/ 3
.]]3 4
wrapped]]4 ;
.]]; <
Slice]]< A
(]]A B
)]]B C
;]]C D
public__ 
override__ 
IByteBuffer__ #
Slice__$ )
(__) *
int__* -
index__. 3
,__3 4
int__5 8
length__9 ?
)__? @
=>__A C
this__D H
.__H I
wrapped__I P
.__P Q
Slice__Q V
(__V W
index__W \
,__\ ]
length__^ d
)__d e
;__e f
publicaa 
overrideaa 
stringaa 
ToStringaa '
(aa' (
Encodingaa( 0
encodingaa1 9
)aa9 :
=>aa; =
thisaa> B
.aaB C
wrappedaaC J
.aaJ K
ToStringaaK S
(aaS T
encodingaaT \
)aa\ ]
;aa] ^
publiccc 
overridecc 
stringcc 
ToStringcc '
(cc' (
intcc( +
indexcc, 1
,cc1 2
intcc3 6
lengthcc7 =
,cc= >
Encodingcc? G
encodingccH P
)ccP Q
=>ccR T
thisccU Y
.ccY Z
wrappedccZ a
.cca b
ToStringccb j
(ccj k
indexcck p
,ccp q
lengthccr x
,ccx y
encoding	ccz ‚
)
cc‚ ƒ
;
ccƒ „
publicee 
overrideee 
intee 
IndexOfee #
(ee# $
intee$ '
	fromIndexee( 1
,ee1 2
intee3 6
toIndexee7 >
,ee> ?
byteee@ D
valueeeE J
)eeJ K
=>eeL N
thiseeO S
.eeS T
wrappedeeT [
.ee[ \
IndexOfee\ c
(eec d
	fromIndexeed m
,eem n
toIndexeeo v
,eev w
valueeex }
)ee} ~
;ee~ 
publicgg 
overridegg 
intgg 
BytesBeforegg '
(gg' (
intgg( +
indexgg, 1
,gg1 2
intgg3 6
lengthgg7 =
,gg= >
bytegg? C
valueggD I
)ggI J
=>ggK M
thisggN R
.ggR S
wrappedggS Z
.ggZ [
BytesBeforegg[ f
(ggf g
indexggg l
,ggl m
lengthggn t
,ggt u
valueggv {
)gg{ |
;gg| }
publicii 
overrideii 
intii 
ForEachByteii '
(ii' (
IByteProcessorii( 6
	processorii7 @
)ii@ A
=>iiB D
thisiiE I
.iiI J
wrappediiJ Q
.iiQ R
ForEachByteiiR ]
(ii] ^
	processorii^ g
)iig h
;iih i
publickk 
overridekk 
intkk 
ForEachBytekk '
(kk' (
intkk( +
indexkk, 1
,kk1 2
intkk3 6
lengthkk7 =
,kk= >
IByteProcessorkk? M
	processorkkN W
)kkW X
=>kkY [
thiskk\ `
.kk` a
wrappedkka h
.kkh i
ForEachBytekki t
(kkt u
indexkku z
,kkz {
length	kk| ‚
,
kk‚ ƒ
	processor
kk„ 
)
kk 
;
kk 
publicmm 
overridemm 
intmm 
ForEachByteDescmm +
(mm+ ,
IByteProcessormm, :
	processormm; D
)mmD E
=>mmF H
thismmI M
.mmM N
wrappedmmN U
.mmU V
ForEachByteDescmmV e
(mme f
	processormmf o
)mmo p
;mmp q
publicoo 
overrideoo 
intoo 
ForEachByteDescoo +
(oo+ ,
intoo, /
indexoo0 5
,oo5 6
intoo7 :
lengthoo; A
,ooA B
IByteProcessorooC Q
	processorooR [
)oo[ \
=>oo] _
thisoo` d
.ood e
wrappedooe l
.ool m
ForEachByteDescoom |
(oo| }
index	oo} ‚
,
oo‚ ƒ
length
oo„ Š
,
ooŠ ‹
	processor
ooŒ •
)
oo• –
;
oo– —
publicqq 
sealedqq 
overrideqq 
intqq "
GetHashCodeqq# .
(qq. /
)qq/ 0
=>qq1 3
thisqq4 8
.qq8 9
wrappedqq9 @
.qq@ A
GetHashCodeqqA L
(qqL M
)qqM N
;qqN O
publicss 
sealedss 
overridess 
boolss #
Equalsss$ *
(ss* +
IByteBufferss+ 6
bufss7 :
)ss: ;
=>ss< >
thisss? C
.ssC D
wrappedssD K
.ssK L
EqualsssL R
(ssR S
bufssS V
)ssV W
;ssW X
publicuu 
sealeduu 
overrideuu 
intuu "
	CompareTouu# ,
(uu, -
IByteBufferuu- 8
thatuu9 =
)uu= >
=>uu? A
thisuuB F
.uuF G
wrappeduuG N
.uuN O
	CompareTouuO X
(uuX Y
thatuuY ]
)uu] ^
;uu^ _
publicww 
sealedww 
overrideww 
intww "
ReferenceCountww# 1
=>ww2 4
thisww5 9
.ww9 :
wrappedww: A
.wwA B
ReferenceCountwwB P
;wwP Q
publicyy 
overrideyy 
IByteBufferyy #
	Duplicateyy$ -
(yy- .
)yy. /
=>yy0 2
thisyy3 7
.yy7 8
wrappedyy8 ?
.yy? @
	Duplicateyy@ I
(yyI J
)yyJ K
;yyK L
public{{ 
override{{ 
IByteBuffer{{ #
	ReadSlice{{$ -
({{- .
int{{. 1
length{{2 8
){{8 9
=>{{: <
this{{= A
.{{A B
wrapped{{B I
.{{I J
	ReadSlice{{J S
({{S T
length{{T Z
){{Z [
;{{[ \
public}} 
override}} 
IByteBuffer}} #
WriteShortLE}}$ 0
(}}0 1
int}}1 4
value}}5 :
)}}: ;
=>}}< >
this}}? C
.}}C D
wrapped}}D K
.}}K L
WriteShortLE}}L X
(}}X Y
value}}Y ^
)}}^ _
;}}_ `
public 
override 
IByteBuffer #
WriteMediumLE$ 1
(1 2
int2 5
value6 ;
); <
=>= ?
this@ D
.D E
wrappedE L
.L M
WriteMediumLEM Z
(Z [
value[ `
)` a
;a b
public
 
override
 
IByteBuffer
 #

WriteIntLE
$ .
(
. /
int
/ 2
value
3 8
)
8 9
=>
: <
this
= A
.
A B
wrapped
B I
.
I J

WriteIntLE
J T
(
T U
value
U Z
)
Z [
;
[ \
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #
WriteLongLE
ƒƒ$ /
(
ƒƒ/ 0
long
ƒƒ0 4
value
ƒƒ5 :
)
ƒƒ: ;
=>
ƒƒ< >
this
ƒƒ? C
.
ƒƒC D
wrapped
ƒƒD K
.
ƒƒK L
WriteLongLE
ƒƒL W
(
ƒƒW X
value
ƒƒX ]
)
ƒƒ] ^
;
ƒƒ^ _
public
…… 
override
…… 
Task
…… 
WriteBytesAsync
…… ,
(
……, -
Stream
……- 3
stream
……4 :
,
……: ;
int
……< ?
length
……@ F
,
……F G
CancellationToken
……H Y
cancellationToken
……Z k
)
……k l
=>
……m o
this
……p t
.
……t u
wrapped
……u |
.
……| }
WriteBytesAsync……} Œ
(……Œ 
stream…… “
,……“ ”
length……• ›
,……› œ!
cancellationToken…… ®
)……® ¯
;……¯ °
public
‡‡ 
override
‡‡ !
CompositeByteBuffer
‡‡ +
AddComponent
‡‡, 8
(
‡‡8 9
IByteBuffer
‡‡9 D
buffer
‡‡E K
)
‡‡K L
{
ˆˆ 	
this
‰‰ 
.
‰‰ 
wrapped
‰‰ 
.
‰‰ 
AddComponent
‰‰ %
(
‰‰% &
buffer
‰‰& ,
)
‰‰, -
;
‰‰- .
return
ŠŠ 
this
ŠŠ 
;
ŠŠ 
}
‹‹ 	
public
 
override
 !
CompositeByteBuffer
 +
AddComponents
, 9
(
9 :
params
: @
IByteBuffer
A L
[
L M
]
M N
buffers
O V
)
V W
{
 	
this
 
.
 
wrapped
 
.
 
AddComponents
 &
(
& '
buffers
' .
)
. /
;
/ 0
return
 
this
 
;
 
}
‘‘ 	
public
““ 
override
““ !
CompositeByteBuffer
““ +
AddComponents
““, 9
(
““9 :
IEnumerable
““: E
<
““E F
IByteBuffer
““F Q
>
““Q R
buffers
““S Z
)
““Z [
{
”” 	
this
•• 
.
•• 
wrapped
•• 
.
•• 
AddComponents
•• &
(
••& '
buffers
••' .
)
••. /
;
••/ 0
return
–– 
this
–– 
;
–– 
}
—— 	
public
™™ 
override
™™ !
CompositeByteBuffer
™™ +
AddComponent
™™, 8
(
™™8 9
int
™™9 <
cIndex
™™= C
,
™™C D
IByteBuffer
™™E P
buffer
™™Q W
)
™™W X
{
šš 	
this
›› 
.
›› 
wrapped
›› 
.
›› 
AddComponent
›› %
(
››% &
cIndex
››& ,
,
››, -
buffer
››. 4
)
››4 5
;
››5 6
return
œœ 
this
œœ 
;
œœ 
}
 	
public
ŸŸ 
override
ŸŸ !
CompositeByteBuffer
ŸŸ +
AddComponents
ŸŸ, 9
(
ŸŸ9 :
int
ŸŸ: =
cIndex
ŸŸ> D
,
ŸŸD E
params
ŸŸF L
IByteBuffer
ŸŸM X
[
ŸŸX Y
]
ŸŸY Z
buffers
ŸŸ[ b
)
ŸŸb c
{
   	
this
¡¡ 
.
¡¡ 
wrapped
¡¡ 
.
¡¡ 
AddComponents
¡¡ &
(
¡¡& '
cIndex
¡¡' -
,
¡¡- .
buffers
¡¡/ 6
)
¡¡6 7
;
¡¡7 8
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
¥¥ 
override
¥¥ !
CompositeByteBuffer
¥¥ +
AddComponents
¥¥, 9
(
¥¥9 :
int
¥¥: =
cIndex
¥¥> D
,
¥¥D E
IEnumerable
¥¥F Q
<
¥¥Q R
IByteBuffer
¥¥R ]
>
¥¥] ^
buffers
¥¥_ f
)
¥¥f g
{
¦¦ 	
this
§§ 
.
§§ 
wrapped
§§ 
.
§§ 
AddComponents
§§ &
(
§§& '
cIndex
§§' -
,
§§- .
buffers
§§/ 6
)
§§6 7
;
§§7 8
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
©© 	
public
«« 
override
«« !
CompositeByteBuffer
«« +
AddComponent
««, 8
(
««8 9
bool
««9 =!
increaseWriterIndex
««> Q
,
««Q R
IByteBuffer
««S ^
buffer
««_ e
)
««e f
{
¬¬ 	
this
­­ 
.
­­ 
wrapped
­­ 
.
­­ 
AddComponent
­­ %
(
­­% &!
increaseWriterIndex
­­& 9
,
­­9 :
buffer
­­; A
)
­­A B
;
­­B C
return
®® 
this
®® 
;
®® 
}
¯¯ 	
public
±± 
override
±± !
CompositeByteBuffer
±± +
AddComponents
±±, 9
(
±±9 :
bool
±±: >!
increaseWriterIndex
±±? R
,
±±R S
params
±±T Z
IByteBuffer
±±[ f
[
±±f g
]
±±g h
buffers
±±i p
)
±±p q
{
²² 	
this
³³ 
.
³³ 
wrapped
³³ 
.
³³ 
AddComponents
³³ &
(
³³& '!
increaseWriterIndex
³³' :
,
³³: ;
buffers
³³< C
)
³³C D
;
³³D E
return
´´ 
this
´´ 
;
´´ 
}
µµ 	
public
·· 
override
·· !
CompositeByteBuffer
·· +
AddComponents
··, 9
(
··9 :
bool
··: >!
increaseWriterIndex
··? R
,
··R S
IEnumerable
··T _
<
··_ `
IByteBuffer
··` k
>
··k l
buffers
··m t
)
··t u
{
¸¸ 	
this
¹¹ 
.
¹¹ 
wrapped
¹¹ 
.
¹¹ 
AddComponents
¹¹ &
(
¹¹& '!
increaseWriterIndex
¹¹' :
,
¹¹: ;
buffers
¹¹< C
)
¹¹C D
;
¹¹D E
return
ºº 
this
ºº 
;
ºº 
}
»» 	
public
½½ 
override
½½ !
CompositeByteBuffer
½½ +
AddComponent
½½, 8
(
½½8 9
bool
½½9 =!
increaseWriterIndex
½½> Q
,
½½Q R
int
½½S V
cIndex
½½W ]
,
½½] ^
IByteBuffer
½½_ j
buffer
½½k q
)
½½q r
{
¾¾ 	
this
¿¿ 
.
¿¿ 
wrapped
¿¿ 
.
¿¿ 
AddComponent
¿¿ %
(
¿¿% &!
increaseWriterIndex
¿¿& 9
,
¿¿9 :
cIndex
¿¿; A
,
¿¿A B
buffer
¿¿C I
)
¿¿I J
;
¿¿J K
return
ÀÀ 
this
ÀÀ 
;
ÀÀ 
}
ÁÁ 	
public
ÃÃ 
override
ÃÃ !
CompositeByteBuffer
ÃÃ +
RemoveComponent
ÃÃ, ;
(
ÃÃ; <
int
ÃÃ< ?
cIndex
ÃÃ@ F
)
ÃÃF G
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
wrapped
ÅÅ 
.
ÅÅ 
RemoveComponent
ÅÅ (
(
ÅÅ( )
cIndex
ÅÅ) /
)
ÅÅ/ 0
;
ÅÅ0 1
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
override
ÉÉ !
CompositeByteBuffer
ÉÉ +
RemoveComponents
ÉÉ, <
(
ÉÉ< =
int
ÉÉ= @
cIndex
ÉÉA G
,
ÉÉG H
int
ÉÉI L
numComponents
ÉÉM Z
)
ÉÉZ [
{
ÊÊ 	
this
ËË 
.
ËË 
wrapped
ËË 
.
ËË 
RemoveComponents
ËË )
(
ËË) *
cIndex
ËË* 0
,
ËË0 1
numComponents
ËË2 ?
)
ËË? @
;
ËË@ A
return
ÌÌ 
this
ÌÌ 
;
ÌÌ 
}
ÍÍ 	
public
ÏÏ 
override
ÏÏ 
IEnumerator
ÏÏ #
<
ÏÏ# $
IByteBuffer
ÏÏ$ /
>
ÏÏ/ 0
GetEnumerator
ÏÏ1 >
(
ÏÏ> ?
)
ÏÏ? @
=>
ÏÏA C
this
ÏÏD H
.
ÏÏH I
wrapped
ÏÏI P
.
ÏÏP Q
GetEnumerator
ÏÏQ ^
(
ÏÏ^ _
)
ÏÏ_ `
;
ÏÏ` a
public
ÑÑ 
override
ÑÑ 
IList
ÑÑ 
<
ÑÑ 
IByteBuffer
ÑÑ )
>
ÑÑ) *
	Decompose
ÑÑ+ 4
(
ÑÑ4 5
int
ÑÑ5 8
offset
ÑÑ9 ?
,
ÑÑ? @
int
ÑÑA D
length
ÑÑE K
)
ÑÑK L
=>
ÑÑM O
this
ÑÑP T
.
ÑÑT U
wrapped
ÑÑU \
.
ÑÑ\ ]
	Decompose
ÑÑ] f
(
ÑÑf g
offset
ÑÑg m
,
ÑÑm n
length
ÑÑo u
)
ÑÑu v
;
ÑÑv w
public
ÓÓ 
sealed
ÓÓ 
override
ÓÓ 
bool
ÓÓ #
HasArray
ÓÓ$ ,
=>
ÓÓ- /
this
ÓÓ0 4
.
ÓÓ4 5
wrapped
ÓÓ5 <
.
ÓÓ< =
HasArray
ÓÓ= E
;
ÓÓE F
public
ÕÕ 
sealed
ÕÕ 
override
ÕÕ 
byte
ÕÕ #
[
ÕÕ# $
]
ÕÕ$ %
Array
ÕÕ& +
=>
ÕÕ, .
this
ÕÕ/ 3
.
ÕÕ3 4
wrapped
ÕÕ4 ;
.
ÕÕ; <
Array
ÕÕ< A
;
ÕÕA B
public
×× 
sealed
×× 
override
×× 
int
×× "
ArrayOffset
××# .
=>
××/ 1
this
××2 6
.
××6 7
wrapped
××7 >
.
××> ?
ArrayOffset
××? J
;
××J K
public
ÙÙ 
sealed
ÙÙ 
override
ÙÙ 
int
ÙÙ "
Capacity
ÙÙ# +
=>
ÙÙ, .
this
ÙÙ/ 3
.
ÙÙ3 4
wrapped
ÙÙ4 ;
.
ÙÙ; <
Capacity
ÙÙ< D
;
ÙÙD E
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #
AdjustCapacity
ÛÛ$ 2
(
ÛÛ2 3
int
ÛÛ3 6
newCapacity
ÛÛ7 B
)
ÛÛB C
{
ÜÜ 	
this
İİ 
.
İİ 
wrapped
İİ 
.
İİ 
AdjustCapacity
İİ '
(
İİ' (
newCapacity
İİ( 3
)
İİ3 4
;
İİ4 5
return
ŞŞ 
this
ŞŞ 
;
ŞŞ 
}
ßß 	
public
áá 
sealed
áá 
override
áá "
IByteBufferAllocator
áá 3
	Allocator
áá4 =
=>
áá> @
this
ááA E
.
ááE F
wrapped
ááF M
.
ááM N
	Allocator
ááN W
;
ááW X
public
ãã 
sealed
ãã 
override
ãã 
int
ãã "
NumComponents
ãã# 0
=>
ãã1 3
this
ãã4 8
.
ãã8 9
wrapped
ãã9 @
.
ãã@ A
NumComponents
ããA N
;
ããN O
public
åå 
sealed
åå 
override
åå 
int
åå "
MaxNumComponents
åå# 3
=>
åå4 6
this
åå7 ;
.
åå; <
wrapped
åå< C
.
ååC D
MaxNumComponents
ååD T
;
ååT U
public
çç 
sealed
çç 
override
çç 
int
çç "
ToComponentIndex
çç# 3
(
çç3 4
int
çç4 7
offset
çç8 >
)
çç> ?
=>
çç@ B
this
ççC G
.
ççG H
wrapped
ççH O
.
ççO P
ToComponentIndex
ççP `
(
çç` a
offset
çça g
)
ççg h
;
ççh i
public
éé 
sealed
éé 
override
éé 
int
éé "
ToByteIndex
éé# .
(
éé. /
int
éé/ 2
cIndex
éé3 9
)
éé9 :
=>
éé; =
this
éé> B
.
ééB C
wrapped
ééC J
.
ééJ K
ToByteIndex
ééK V
(
ééV W
cIndex
ééW ]
)
éé] ^
;
éé^ _
public
ëë 
override
ëë 
byte
ëë 
GetByte
ëë $
(
ëë$ %
int
ëë% (
index
ëë) .
)
ëë. /
=>
ëë0 2
this
ëë3 7
.
ëë7 8
wrapped
ëë8 ?
.
ëë? @
GetByte
ëë@ G
(
ëëG H
index
ëëH M
)
ëëM N
;
ëëN O
	protected
íí 
internal
íí 
sealed
íí !
override
íí" *
byte
íí+ /
_GetByte
íí0 8
(
íí8 9
int
íí9 <
index
íí= B
)
ííB C
=>
ííD F
this
ííG K
.
ííK L
wrapped
ííL S
.
ííS T
_GetByte
ííT \
(
íí\ ]
index
íí] b
)
ííb c
;
ííc d
	protected
ïï 
internal
ïï 
sealed
ïï !
override
ïï" *
short
ïï+ 0
	_GetShort
ïï1 :
(
ïï: ;
int
ïï; >
index
ïï? D
)
ïïD E
=>
ïïF H
this
ïïI M
.
ïïM N
wrapped
ïïN U
.
ïïU V
	_GetShort
ïïV _
(
ïï_ `
index
ïï` e
)
ïïe f
;
ïïf g
	protected
ññ 
internal
ññ 
sealed
ññ !
override
ññ" *
short
ññ+ 0
_GetShortLE
ññ1 <
(
ññ< =
int
ññ= @
index
ññA F
)
ññF G
=>
ññH J
this
ññK O
.
ññO P
wrapped
ññP W
.
ññW X
_GetShortLE
ññX c
(
ññc d
index
ññd i
)
ññi j
;
ññj k
	protected
óó 
internal
óó 
sealed
óó !
override
óó" *
int
óó+ . 
_GetUnsignedMedium
óó/ A
(
óóA B
int
óóB E
index
óóF K
)
óóK L
=>
óóM O
this
óóP T
.
óóT U
wrapped
óóU \
.
óó\ ] 
_GetUnsignedMedium
óó] o
(
óóo p
index
óóp u
)
óóu v
;
óóv w
	protected
õõ 
internal
õõ 
sealed
õõ !
override
õõ" *
int
õõ+ ."
_GetUnsignedMediumLE
õõ/ C
(
õõC D
int
õõD G
index
õõH M
)
õõM N
=>
õõO Q
this
õõR V
.
õõV W
wrapped
õõW ^
.
õõ^ _"
_GetUnsignedMediumLE
õõ_ s
(
õõs t
index
õõt y
)
õõy z
;
õõz {
	protected
÷÷ 
internal
÷÷ 
sealed
÷÷ !
override
÷÷" *
int
÷÷+ .
_GetInt
÷÷/ 6
(
÷÷6 7
int
÷÷7 :
index
÷÷; @
)
÷÷@ A
=>
÷÷B D
this
÷÷E I
.
÷÷I J
wrapped
÷÷J Q
.
÷÷Q R
_GetInt
÷÷R Y
(
÷÷Y Z
index
÷÷Z _
)
÷÷_ `
;
÷÷` a
	protected
ùù 
internal
ùù 
sealed
ùù !
override
ùù" *
int
ùù+ .
	_GetIntLE
ùù/ 8
(
ùù8 9
int
ùù9 <
index
ùù= B
)
ùùB C
=>
ùùD F
this
ùùG K
.
ùùK L
wrapped
ùùL S
.
ùùS T
	_GetIntLE
ùùT ]
(
ùù] ^
index
ùù^ c
)
ùùc d
;
ùùd e
	protected
ûû 
internal
ûû 
sealed
ûû !
override
ûû" *
long
ûû+ /
_GetLong
ûû0 8
(
ûû8 9
int
ûû9 <
index
ûû= B
)
ûûB C
=>
ûûD F
this
ûûG K
.
ûûK L
wrapped
ûûL S
.
ûûS T
_GetLong
ûûT \
(
ûû\ ]
index
ûû] b
)
ûûb c
;
ûûc d
	protected
ıı 
internal
ıı 
sealed
ıı !
override
ıı" *
long
ıı+ /

_GetLongLE
ıı0 :
(
ıı: ;
int
ıı; >
index
ıı? D
)
ııD E
=>
ııF H
this
ııI M
.
ııM N
wrapped
ııN U
.
ııU V

_GetLongLE
ııV `
(
ıı` a
index
ııa f
)
ııf g
;
ııg h
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
GetBytes
ÿÿ$ ,
(
ÿÿ, -
int
ÿÿ- 0
index
ÿÿ1 6
,
ÿÿ6 7
byte
ÿÿ8 <
[
ÿÿ< =
]
ÿÿ= >
dst
ÿÿ? B
,
ÿÿB C
int
ÿÿD G
dstIndex
ÿÿH P
,
ÿÿP Q
int
ÿÿR U
length
ÿÿV \
)
ÿÿ\ ]
{
€€ 	
this
 
.
 
wrapped
 
.
 
GetBytes
 !
(
! "
index
" '
,
' (
dst
) ,
,
, -
dstIndex
. 6
,
6 7
length
8 >
)
> ?
;
? @
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
ƒƒ 	
public
…… 
override
…… 
IByteBuffer
…… #
GetBytes
……$ ,
(
……, -
int
……- 0
index
……1 6
,
……6 7
IByteBuffer
……8 C
dst
……D G
,
……G H
int
……I L
dstIndex
……M U
,
……U V
int
……W Z
length
……[ a
)
……a b
{
†† 	
this
‡‡ 
.
‡‡ 
wrapped
‡‡ 
.
‡‡ 
GetBytes
‡‡ !
(
‡‡! "
index
‡‡" '
,
‡‡' (
dst
‡‡) ,
,
‡‡, -
dstIndex
‡‡. 6
,
‡‡6 7
length
‡‡8 >
)
‡‡> ?
;
‡‡? @
return
ˆˆ 
this
ˆˆ 
;
ˆˆ 
}
‰‰ 	
public
‹‹ 
override
‹‹ 
IByteBuffer
‹‹ #
GetBytes
‹‹$ ,
(
‹‹, -
int
‹‹- 0
index
‹‹1 6
,
‹‹6 7
Stream
‹‹8 >
destination
‹‹? J
,
‹‹J K
int
‹‹L O
length
‹‹P V
)
‹‹V W
=>
‹‹X Z
this
‹‹[ _
.
‹‹_ `
wrapped
‹‹` g
.
‹‹g h
GetBytes
‹‹h p
(
‹‹p q
index
‹‹q v
,
‹‹v w
destination‹‹x ƒ
,‹‹ƒ „
length‹‹… ‹
)‹‹‹ Œ
;‹‹Œ 
public
 
override
 
IByteBuffer
 #
SetByte
$ +
(
+ ,
int
, /
index
0 5
,
5 6
int
7 :
value
; @
)
@ A
{
 	
this
 
.
 
wrapped
 
.
 
SetByte
  
(
  !
index
! &
,
& '
value
( -
)
- .
;
. /
return
 
this
 
;
 
}
‘‘ 	
	protected
““ 
internal
““ 
sealed
““ !
override
““" *
void
““+ /
_SetByte
““0 8
(
““8 9
int
““9 <
index
““= B
,
““B C
int
““D G
value
““H M
)
““M N
=>
““O Q
this
““R V
.
““V W
wrapped
““W ^
.
““^ _
_SetByte
““_ g
(
““g h
index
““h m
,
““m n
value
““o t
)
““t u
;
““u v
public
•• 
override
•• 
IByteBuffer
•• #
SetShort
••$ ,
(
••, -
int
••- 0
index
••1 6
,
••6 7
int
••8 ;
value
••< A
)
••A B
{
–– 	
this
—— 
.
—— 
wrapped
—— 
.
—— 
SetShort
—— !
(
——! "
index
——" '
,
——' (
value
——) .
)
——. /
;
——/ 0
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
™™ 	
	protected
›› 
internal
›› 
sealed
›› !
override
››" *
void
››+ /
	_SetShort
››0 9
(
››9 :
int
››: =
index
››> C
,
››C D
int
››E H
value
››I N
)
››N O
=>
››P R
this
››S W
.
››W X
wrapped
››X _
.
››_ `
	_SetShort
››` i
(
››i j
index
››j o
,
››o p
value
››q v
)
››v w
;
››w x
	protected
 
internal
 
sealed
 !
override
" *
void
+ /
_SetShortLE
0 ;
(
; <
int
< ?
index
@ E
,
E F
int
G J
value
K P
)
P Q
=>
R T
this
U Y
.
Y Z
wrapped
Z a
.
a b
_SetShortLE
b m
(
m n
index
n s
,
s t
value
u z
)
z {
;
{ |
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ #
	SetMedium
ŸŸ$ -
(
ŸŸ- .
int
ŸŸ. 1
index
ŸŸ2 7
,
ŸŸ7 8
int
ŸŸ9 <
value
ŸŸ= B
)
ŸŸB C
{
   	
this
¡¡ 
.
¡¡ 
wrapped
¡¡ 
.
¡¡ 
	SetMedium
¡¡ "
(
¡¡" #
index
¡¡# (
,
¡¡( )
value
¡¡* /
)
¡¡/ 0
;
¡¡0 1
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
	protected
¥¥ 
internal
¥¥ 
sealed
¥¥ !
override
¥¥" *
void
¥¥+ /

_SetMedium
¥¥0 :
(
¥¥: ;
int
¥¥; >
index
¥¥? D
,
¥¥D E
int
¥¥F I
value
¥¥J O
)
¥¥O P
=>
¥¥Q S
this
¥¥T X
.
¥¥X Y
wrapped
¥¥Y `
.
¥¥` a

_SetMedium
¥¥a k
(
¥¥k l
index
¥¥l q
,
¥¥q r
value
¥¥s x
)
¥¥x y
;
¥¥y z
	protected
§§ 
internal
§§ 
sealed
§§ !
override
§§" *
void
§§+ /
_SetMediumLE
§§0 <
(
§§< =
int
§§= @
index
§§A F
,
§§F G
int
§§H K
value
§§L Q
)
§§Q R
=>
§§S U
this
§§V Z
.
§§Z [
wrapped
§§[ b
.
§§b c
_SetMediumLE
§§c o
(
§§o p
index
§§p u
,
§§u v
value
§§w |
)
§§| }
;
§§} ~
public
©© 
override
©© 
IByteBuffer
©© #
SetInt
©©$ *
(
©©* +
int
©©+ .
index
©©/ 4
,
©©4 5
int
©©6 9
value
©©: ?
)
©©? @
{
ªª 	
this
«« 
.
«« 
wrapped
«« 
.
«« 
SetInt
«« 
(
««  
index
««  %
,
««% &
value
««' ,
)
««, -
;
««- .
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
­­ 	
	protected
¯¯ 
internal
¯¯ 
sealed
¯¯ !
override
¯¯" *
void
¯¯+ /
_SetInt
¯¯0 7
(
¯¯7 8
int
¯¯8 ;
index
¯¯< A
,
¯¯A B
int
¯¯C F
value
¯¯G L
)
¯¯L M
=>
¯¯N P
this
¯¯Q U
.
¯¯U V
wrapped
¯¯V ]
.
¯¯] ^
_SetInt
¯¯^ e
(
¯¯e f
index
¯¯f k
,
¯¯k l
value
¯¯m r
)
¯¯r s
;
¯¯s t
	protected
±± 
internal
±± 
sealed
±± !
override
±±" *
void
±±+ /
	_SetIntLE
±±0 9
(
±±9 :
int
±±: =
index
±±> C
,
±±C D
int
±±E H
value
±±I N
)
±±N O
=>
±±P R
this
±±S W
.
±±W X
wrapped
±±X _
.
±±_ `
	_SetIntLE
±±` i
(
±±i j
index
±±j o
,
±±o p
value
±±q v
)
±±v w
;
±±w x
public
³³ 
override
³³ 
IByteBuffer
³³ #
SetLong
³³$ +
(
³³+ ,
int
³³, /
index
³³0 5
,
³³5 6
long
³³7 ;
value
³³< A
)
³³A B
{
´´ 	
this
µµ 
.
µµ 
wrapped
µµ 
.
µµ 
SetLong
µµ  
(
µµ  !
index
µµ! &
,
µµ& '
value
µµ( -
)
µµ- .
;
µµ. /
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
·· 	
	protected
¹¹ 
internal
¹¹ 
sealed
¹¹ !
override
¹¹" *
void
¹¹+ /
_SetLong
¹¹0 8
(
¹¹8 9
int
¹¹9 <
index
¹¹= B
,
¹¹B C
long
¹¹D H
value
¹¹I N
)
¹¹N O
=>
¹¹P R
this
¹¹S W
.
¹¹W X
wrapped
¹¹X _
.
¹¹_ `
_SetLong
¹¹` h
(
¹¹h i
index
¹¹i n
,
¹¹n o
value
¹¹p u
)
¹¹u v
;
¹¹v w
	protected
»» 
internal
»» 
sealed
»» !
override
»»" *
void
»»+ /

_SetLongLE
»»0 :
(
»»: ;
int
»»; >
index
»»? D
,
»»D E
long
»»F J
value
»»K P
)
»»P Q
=>
»»R T
this
»»U Y
.
»»Y Z
wrapped
»»Z a
.
»»a b

_SetLongLE
»»b l
(
»»l m
index
»»m r
,
»»r s
value
»»t y
)
»»y z
;
»»z {
public
½½ 
override
½½ 
IByteBuffer
½½ #
SetBytes
½½$ ,
(
½½, -
int
½½- 0
index
½½1 6
,
½½6 7
byte
½½8 <
[
½½< =
]
½½= >
src
½½? B
,
½½B C
int
½½D G
srcIndex
½½H P
,
½½P Q
int
½½R U
length
½½V \
)
½½\ ]
{
¾¾ 	
this
¿¿ 
.
¿¿ 
wrapped
¿¿ 
.
¿¿ 
SetBytes
¿¿ !
(
¿¿! "
index
¿¿" '
,
¿¿' (
src
¿¿) ,
,
¿¿, -
srcIndex
¿¿. 6
,
¿¿6 7
length
¿¿8 >
)
¿¿> ?
;
¿¿? @
return
ÀÀ 
this
ÀÀ 
;
ÀÀ 
}
ÁÁ 	
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
SetBytes
ÃÃ$ ,
(
ÃÃ, -
int
ÃÃ- 0
index
ÃÃ1 6
,
ÃÃ6 7
IByteBuffer
ÃÃ8 C
src
ÃÃD G
,
ÃÃG H
int
ÃÃI L
srcIndex
ÃÃM U
,
ÃÃU V
int
ÃÃW Z
length
ÃÃ[ a
)
ÃÃa b
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
wrapped
ÅÅ 
.
ÅÅ 
SetBytes
ÅÅ !
(
ÅÅ! "
index
ÅÅ" '
,
ÅÅ' (
src
ÅÅ) ,
,
ÅÅ, -
srcIndex
ÅÅ. 6
,
ÅÅ6 7
length
ÅÅ8 >
)
ÅÅ> ?
;
ÅÅ? @
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
override
ÉÉ 
Task
ÉÉ 
<
ÉÉ 
int
ÉÉ  
>
ÉÉ  !
SetBytesAsync
ÉÉ" /
(
ÉÉ/ 0
int
ÉÉ0 3
index
ÉÉ4 9
,
ÉÉ9 :
Stream
ÉÉ; A
src
ÉÉB E
,
ÉÉE F
int
ÉÉG J
length
ÉÉK Q
,
ÉÉQ R
CancellationToken
ÉÉS d
cancellationToken
ÉÉe v
)
ÉÉv w
=>
ÉÉx z
this
ÉÉ{ 
.ÉÉ €
wrappedÉÉ€ ‡
.ÉÉ‡ ˆ
SetBytesAsyncÉÉˆ •
(ÉÉ• –
indexÉÉ– ›
,ÉÉ› œ
srcÉÉ  
,ÉÉ  ¡
lengthÉÉ¢ ¨
,ÉÉ¨ ©!
cancellationTokenÉÉª »
)ÉÉ» ¼
;ÉÉ¼ ½
public
ËË 
override
ËË 
IByteBuffer
ËË #
Copy
ËË$ (
(
ËË( )
)
ËË) *
=>
ËË+ -
this
ËË. 2
.
ËË2 3
wrapped
ËË3 :
.
ËË: ;
Copy
ËË; ?
(
ËË? @
)
ËË@ A
;
ËËA B
public
ÍÍ 
override
ÍÍ 
IByteBuffer
ÍÍ #
Copy
ÍÍ$ (
(
ÍÍ( )
int
ÍÍ) ,
index
ÍÍ- 2
,
ÍÍ2 3
int
ÍÍ4 7
length
ÍÍ8 >
)
ÍÍ> ?
=>
ÍÍ@ B
this
ÍÍC G
.
ÍÍG H
wrapped
ÍÍH O
.
ÍÍO P
Copy
ÍÍP T
(
ÍÍT U
index
ÍÍU Z
,
ÍÍZ [
length
ÍÍ\ b
)
ÍÍb c
;
ÍÍc d
public
ÏÏ 
sealed
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ *
this
ÏÏ+ /
[
ÏÏ/ 0
int
ÏÏ0 3
cIndex
ÏÏ4 :
]
ÏÏ: ;
=>
ÏÏ< >
this
ÏÏ? C
.
ÏÏC D
wrapped
ÏÏD K
[
ÏÏK L
cIndex
ÏÏL R
]
ÏÏR S
;
ÏÏS T
public
ÑÑ 
sealed
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ *
ComponentAtOffset
ÑÑ+ <
(
ÑÑ< =
int
ÑÑ= @
offset
ÑÑA G
)
ÑÑG H
=>
ÑÑI K
this
ÑÑL P
.
ÑÑP Q
wrapped
ÑÑQ X
.
ÑÑX Y
ComponentAtOffset
ÑÑY j
(
ÑÑj k
offset
ÑÑk q
)
ÑÑq r
;
ÑÑr s
public
ÓÓ 
sealed
ÓÓ 
override
ÓÓ 
IByteBuffer
ÓÓ *
InternalComponent
ÓÓ+ <
(
ÓÓ< =
int
ÓÓ= @
cIndex
ÓÓA G
)
ÓÓG H
=>
ÓÓI K
this
ÓÓL P
.
ÓÓP Q
wrapped
ÓÓQ X
.
ÓÓX Y
InternalComponent
ÓÓY j
(
ÓÓj k
cIndex
ÓÓk q
)
ÓÓq r
;
ÓÓr s
public
ÕÕ 
sealed
ÕÕ 
override
ÕÕ 
IByteBuffer
ÕÕ *'
InternalComponentAtOffset
ÕÕ+ D
(
ÕÕD E
int
ÕÕE H
offset
ÕÕI O
)
ÕÕO P
=>
ÕÕQ S
this
ÕÕT X
.
ÕÕX Y
wrapped
ÕÕY `
.
ÕÕ` a'
InternalComponentAtOffset
ÕÕa z
(
ÕÕz {
offsetÕÕ{ 
)ÕÕ ‚
;ÕÕ‚ ƒ
public
×× 
override
×× 
int
×× 
IoBufferCount
×× )
=>
××* ,
this
××- 1
.
××1 2
wrapped
××2 9
.
××9 :
IoBufferCount
××: G
;
××G H
public
ÙÙ 
override
ÙÙ 
ArraySegment
ÙÙ $
<
ÙÙ$ %
byte
ÙÙ% )
>
ÙÙ) *
GetIoBuffer
ÙÙ+ 6
(
ÙÙ6 7
int
ÙÙ7 :
index
ÙÙ; @
,
ÙÙ@ A
int
ÙÙB E
length
ÙÙF L
)
ÙÙL M
=>
ÙÙN P
this
ÙÙQ U
.
ÙÙU V
wrapped
ÙÙV ]
.
ÙÙ] ^
GetIoBuffer
ÙÙ^ i
(
ÙÙi j
index
ÙÙj o
,
ÙÙo p
length
ÙÙq w
)
ÙÙw x
;
ÙÙx y
public
ÛÛ 
override
ÛÛ 
ArraySegment
ÛÛ $
<
ÛÛ$ %
byte
ÛÛ% )
>
ÛÛ) *
[
ÛÛ* +
]
ÛÛ+ ,
GetIoBuffers
ÛÛ- 9
(
ÛÛ9 :
int
ÛÛ: =
index
ÛÛ> C
,
ÛÛC D
int
ÛÛE H
length
ÛÛI O
)
ÛÛO P
=>
ÛÛQ S
this
ÛÛT X
.
ÛÛX Y
wrapped
ÛÛY `
.
ÛÛ` a
GetIoBuffers
ÛÛa m
(
ÛÛm n
index
ÛÛn s
,
ÛÛs t
length
ÛÛu {
)
ÛÛ{ |
;
ÛÛ| }
public
İİ 
override
İİ !
CompositeByteBuffer
İİ +
Consolidate
İİ, 7
(
İİ7 8
)
İİ8 9
{
ŞŞ 	
this
ßß 
.
ßß 
wrapped
ßß 
.
ßß 
Consolidate
ßß $
(
ßß$ %
)
ßß% &
;
ßß& '
return
àà 
this
àà 
;
àà 
}
áá 	
public
ãã 
override
ãã !
CompositeByteBuffer
ãã +
Consolidate
ãã, 7
(
ãã7 8
int
ãã8 ;
cIndex
ãã< B
,
ããB C
int
ããD G
numComponents
ããH U
)
ããU V
{
ää 	
this
åå 
.
åå 
wrapped
åå 
.
åå 
Consolidate
åå $
(
åå$ %
cIndex
åå% +
,
åå+ ,
numComponents
åå- :
)
åå: ;
;
åå; <
return
ææ 
this
ææ 
;
ææ 
}
çç 	
public
éé 
override
éé !
CompositeByteBuffer
éé +#
DiscardReadComponents
éé, A
(
ééA B
)
ééB C
{
êê 	
this
ëë 
.
ëë 
wrapped
ëë 
.
ëë #
DiscardReadComponents
ëë .
(
ëë. /
)
ëë/ 0
;
ëë0 1
return
ìì 
this
ìì 
;
ìì 
}
íí 	
public
ïï 
override
ïï 
IByteBuffer
ïï #
DiscardReadBytes
ïï$ 4
(
ïï4 5
)
ïï5 6
{
ğğ 	
this
ññ 
.
ññ 
wrapped
ññ 
.
ññ 
DiscardReadBytes
ññ )
(
ññ) *
)
ññ* +
;
ññ+ ,
return
òò 
this
òò 
;
òò 
}
óó 	
public
õõ 
sealed
õõ 
override
õõ 
string
õõ %
ToString
õõ& .
(
õõ. /
)
õõ/ 0
=>
õõ1 3
this
õõ4 8
.
õõ8 9
wrapped
õõ9 @
.
õõ@ A
ToString
õõA I
(
õõI J
)
õõJ K
;
õõK L
public
÷÷ 
sealed
÷÷ 
override
÷÷ 
IByteBuffer
÷÷ *
SetReaderIndex
÷÷+ 9
(
÷÷9 :
int
÷÷: =
readerIndex
÷÷> I
)
÷÷I J
{
øø 	
this
ùù 
.
ùù 
wrapped
ùù 
.
ùù 
SetReaderIndex
ùù '
(
ùù' (
readerIndex
ùù( 3
)
ùù3 4
;
ùù4 5
return
úú 
this
úú 
;
úú 
}
ûû 	
public
ıı 
sealed
ıı 
override
ıı 
IByteBuffer
ıı *
SetWriterIndex
ıı+ 9
(
ıı9 :
int
ıı: =
writerIndex
ıı> I
)
ııI J
{
şş 	
this
ÿÿ 
.
ÿÿ 
wrapped
ÿÿ 
.
ÿÿ 
SetWriterIndex
ÿÿ '
(
ÿÿ' (
writerIndex
ÿÿ( 3
)
ÿÿ3 4
;
ÿÿ4 5
return
€€ 
this
€€ 
;
€€ 
}
 	
public
ƒƒ 
sealed
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ *
SetIndex
ƒƒ+ 3
(
ƒƒ3 4
int
ƒƒ4 7
readerIndex
ƒƒ8 C
,
ƒƒC D
int
ƒƒE H
writerIndex
ƒƒI T
)
ƒƒT U
{
„„ 	
this
…… 
.
…… 
wrapped
…… 
.
…… 
SetIndex
…… !
(
……! "
readerIndex
……" -
,
……- .
writerIndex
……/ :
)
……: ;
;
……; <
return
†† 
this
†† 
;
†† 
}
‡‡ 	
public
‰‰ 
sealed
‰‰ 
override
‰‰ 
IByteBuffer
‰‰ *
Clear
‰‰+ 0
(
‰‰0 1
)
‰‰1 2
{
ŠŠ 	
this
‹‹ 
.
‹‹ 
wrapped
‹‹ 
.
‹‹ 
Clear
‹‹ 
(
‹‹ 
)
‹‹  
;
‹‹  !
return
ŒŒ 
this
ŒŒ 
;
ŒŒ 
}
 	
public
 
sealed
 
override
 
IByteBuffer
 *
MarkReaderIndex
+ :
(
: ;
)
; <
{
 	
this
‘‘ 
.
‘‘ 
wrapped
‘‘ 
.
‘‘ 
MarkReaderIndex
‘‘ (
(
‘‘( )
)
‘‘) *
;
‘‘* +
return
’’ 
this
’’ 
;
’’ 
}
““ 	
public
•• 
sealed
•• 
override
•• 
IByteBuffer
•• *
ResetReaderIndex
••+ ;
(
••; <
)
••< =
{
–– 	
this
—— 
.
—— 
wrapped
—— 
.
—— 
ResetReaderIndex
—— )
(
——) *
)
——* +
;
——+ ,
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
™™ 	
public
›› 
sealed
›› 
override
›› 
IByteBuffer
›› *
MarkWriterIndex
››+ :
(
››: ;
)
››; <
{
œœ 	
this
 
.
 
wrapped
 
.
 
MarkWriterIndex
 (
(
( )
)
) *
;
* +
return
 
this
 
;
 
}
ŸŸ 	
public
¡¡ 
sealed
¡¡ 
override
¡¡ 
IByteBuffer
¡¡ *
ResetWriterIndex
¡¡+ ;
(
¡¡; <
)
¡¡< =
{
¢¢ 	
this
££ 
.
££ 
wrapped
££ 
.
££ 
ResetWriterIndex
££ )
(
££) *
)
££* +
;
££+ ,
return
¤¤ 
this
¤¤ 
;
¤¤ 
}
¥¥ 	
public
§§ 
override
§§ 
IByteBuffer
§§ #
EnsureWritable
§§$ 2
(
§§2 3
int
§§3 6
minWritableBytes
§§7 G
)
§§G H
{
¨¨ 	
this
©© 
.
©© 
wrapped
©© 
.
©© 
EnsureWritable
©© '
(
©©' (
minWritableBytes
©©( 8
)
©©8 9
;
©©9 :
return
ªª 
this
ªª 
;
ªª 
}
«« 	
public
­­ 
override
­­ 
IByteBuffer
­­ #
GetBytes
­­$ ,
(
­­, -
int
­­- 0
index
­­1 6
,
­­6 7
IByteBuffer
­­8 C
dst
­­D G
)
­­G H
{
®® 	
this
¯¯ 
.
¯¯ 
wrapped
¯¯ 
.
¯¯ 
GetBytes
¯¯ !
(
¯¯! "
index
¯¯" '
,
¯¯' (
dst
¯¯) ,
)
¯¯, -
;
¯¯- .
return
°° 
this
°° 
;
°° 
}
±± 	
public
³³ 
override
³³ 
IByteBuffer
³³ #
GetBytes
³³$ ,
(
³³, -
int
³³- 0
index
³³1 6
,
³³6 7
IByteBuffer
³³8 C
dst
³³D G
,
³³G H
int
³³I L
length
³³M S
)
³³S T
{
´´ 	
this
µµ 
.
µµ 
wrapped
µµ 
.
µµ 
GetBytes
µµ !
(
µµ! "
index
µµ" '
,
µµ' (
dst
µµ) ,
,
µµ, -
length
µµ. 4
)
µµ4 5
;
µµ5 6
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
·· 	
public
¹¹ 
override
¹¹ 
IByteBuffer
¹¹ #
GetBytes
¹¹$ ,
(
¹¹, -
int
¹¹- 0
index
¹¹1 6
,
¹¹6 7
byte
¹¹8 <
[
¹¹< =
]
¹¹= >
dst
¹¹? B
)
¹¹B C
{
ºº 	
this
»» 
.
»» 
wrapped
»» 
.
»» 
GetBytes
»» !
(
»»! "
index
»»" '
,
»»' (
dst
»») ,
)
»», -
;
»»- .
return
¼¼ 
this
¼¼ 
;
¼¼ 
}
½½ 	
public
¿¿ 
override
¿¿ 
IByteBuffer
¿¿ #

SetBoolean
¿¿$ .
(
¿¿. /
int
¿¿/ 2
index
¿¿3 8
,
¿¿8 9
bool
¿¿: >
value
¿¿? D
)
¿¿D E
{
ÀÀ 	
this
ÁÁ 
.
ÁÁ 
wrapped
ÁÁ 
.
ÁÁ 

SetBoolean
ÁÁ #
(
ÁÁ# $
index
ÁÁ$ )
,
ÁÁ) *
value
ÁÁ+ 0
)
ÁÁ0 1
;
ÁÁ1 2
return
ÂÂ 
this
ÂÂ 
;
ÂÂ 
}
ÃÃ 	
public
ÅÅ 
override
ÅÅ 
IByteBuffer
ÅÅ #
SetChar
ÅÅ$ +
(
ÅÅ+ ,
int
ÅÅ, /
index
ÅÅ0 5
,
ÅÅ5 6
char
ÅÅ7 ;
value
ÅÅ< A
)
ÅÅA B
{
ÆÆ 	
this
ÇÇ 
.
ÇÇ 
wrapped
ÇÇ 
.
ÇÇ 
SetChar
ÇÇ  
(
ÇÇ  !
index
ÇÇ! &
,
ÇÇ& '
value
ÇÇ( -
)
ÇÇ- .
;
ÇÇ. /
return
ÈÈ 
this
ÈÈ 
;
ÈÈ 
}
ÉÉ 	
public
ËË 
override
ËË 
IByteBuffer
ËË #
SetFloat
ËË$ ,
(
ËË, -
int
ËË- 0
index
ËË1 6
,
ËË6 7
float
ËË8 =
value
ËË> C
)
ËËC D
{
ÌÌ 	
this
ÍÍ 
.
ÍÍ 
wrapped
ÍÍ 
.
ÍÍ 
SetFloat
ÍÍ !
(
ÍÍ! "
index
ÍÍ" '
,
ÍÍ' (
value
ÍÍ) .
)
ÍÍ. /
;
ÍÍ/ 0
return
ÎÎ 
this
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ #
	SetDouble
ÑÑ$ -
(
ÑÑ- .
int
ÑÑ. 1
index
ÑÑ2 7
,
ÑÑ7 8
double
ÑÑ9 ?
value
ÑÑ@ E
)
ÑÑE F
{
ÒÒ 	
this
ÓÓ 
.
ÓÓ 
wrapped
ÓÓ 
.
ÓÓ 
	SetDouble
ÓÓ "
(
ÓÓ" #
index
ÓÓ# (
,
ÓÓ( )
value
ÓÓ* /
)
ÓÓ/ 0
;
ÓÓ0 1
return
ÔÔ 
this
ÔÔ 
;
ÔÔ 
}
ÕÕ 	
public
×× 
override
×× 
IByteBuffer
×× #
SetBytes
××$ ,
(
××, -
int
××- 0
index
××1 6
,
××6 7
IByteBuffer
××8 C
src
××D G
)
××G H
{
ØØ 	
this
ÙÙ 
.
ÙÙ 
wrapped
ÙÙ 
.
ÙÙ 
SetBytes
ÙÙ !
(
ÙÙ! "
index
ÙÙ" '
,
ÙÙ' (
src
ÙÙ) ,
)
ÙÙ, -
;
ÙÙ- .
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
İİ 
override
İİ 
IByteBuffer
İİ #
SetBytes
İİ$ ,
(
İİ, -
int
İİ- 0
index
İİ1 6
,
İİ6 7
IByteBuffer
İİ8 C
src
İİD G
,
İİG H
int
İİI L
length
İİM S
)
İİS T
{
ŞŞ 	
this
ßß 
.
ßß 
wrapped
ßß 
.
ßß 
SetBytes
ßß !
(
ßß! "
index
ßß" '
,
ßß' (
src
ßß) ,
,
ßß, -
length
ßß. 4
)
ßß4 5
;
ßß5 6
return
àà 
this
àà 
;
àà 
}
áá 	
public
ãã 
override
ãã 
IByteBuffer
ãã #
SetBytes
ãã$ ,
(
ãã, -
int
ãã- 0
index
ãã1 6
,
ãã6 7
byte
ãã8 <
[
ãã< =
]
ãã= >
src
ãã? B
)
ããB C
{
ää 	
this
åå 
.
åå 
wrapped
åå 
.
åå 
SetBytes
åå !
(
åå! "
index
åå" '
,
åå' (
src
åå) ,
)
åå, -
;
åå- .
return
ææ 
this
ææ 
;
ææ 
}
çç 	
public
éé 
override
éé 
IByteBuffer
éé #
SetZero
éé$ +
(
éé+ ,
int
éé, /
index
éé0 5
,
éé5 6
int
éé7 :
length
éé; A
)
ééA B
{
êê 	
this
ëë 
.
ëë 
wrapped
ëë 
.
ëë 
SetZero
ëë  
(
ëë  !
index
ëë! &
,
ëë& '
length
ëë( .
)
ëë. /
;
ëë/ 0
return
ìì 
this
ìì 
;
ìì 
}
íí 	
public
ïï 
override
ïï 
IByteBuffer
ïï #
	ReadBytes
ïï$ -
(
ïï- .
IByteBuffer
ïï. 9
dst
ïï: =
)
ïï= >
{
ğğ 	
this
ññ 
.
ññ 
wrapped
ññ 
.
ññ 
	ReadBytes
ññ "
(
ññ" #
dst
ññ# &
)
ññ& '
;
ññ' (
return
òò 
this
òò 
;
òò 
}
óó 	
public
õõ 
override
õõ 
IByteBuffer
õõ #
	ReadBytes
õõ$ -
(
õõ- .
IByteBuffer
õõ. 9
dst
õõ: =
,
õõ= >
int
õõ? B
length
õõC I
)
õõI J
{
öö 	
this
÷÷ 
.
÷÷ 
wrapped
÷÷ 
.
÷÷ 
	ReadBytes
÷÷ "
(
÷÷" #
dst
÷÷# &
,
÷÷& '
length
÷÷( .
)
÷÷. /
;
÷÷/ 0
return
øø 
this
øø 
;
øø 
}
ùù 	
public
ûû 
override
ûû 
IByteBuffer
ûû #
	ReadBytes
ûû$ -
(
ûû- .
IByteBuffer
ûû. 9
dst
ûû: =
,
ûû= >
int
ûû? B
dstIndex
ûûC K
,
ûûK L
int
ûûM P
length
ûûQ W
)
ûûW X
{
üü 	
this
ıı 
.
ıı 
wrapped
ıı 
.
ıı 
	ReadBytes
ıı "
(
ıı" #
dst
ıı# &
,
ıı& '
dstIndex
ıı( 0
,
ıı0 1
length
ıı2 8
)
ıı8 9
;
ıı9 :
return
şş 
this
şş 
;
şş 
}
ÿÿ 	
public
 
override
 
IByteBuffer
 #
	ReadBytes
$ -
(
- .
byte
. 2
[
2 3
]
3 4
dst
5 8
)
8 9
{
‚‚ 	
this
ƒƒ 
.
ƒƒ 
wrapped
ƒƒ 
.
ƒƒ 
	ReadBytes
ƒƒ "
(
ƒƒ" #
dst
ƒƒ# &
)
ƒƒ& '
;
ƒƒ' (
return
„„ 
this
„„ 
;
„„ 
}
…… 	
public
‡‡ 
override
‡‡ 
IByteBuffer
‡‡ #
	ReadBytes
‡‡$ -
(
‡‡- .
byte
‡‡. 2
[
‡‡2 3
]
‡‡3 4
dst
‡‡5 8
,
‡‡8 9
int
‡‡: =
dstIndex
‡‡> F
,
‡‡F G
int
‡‡H K
length
‡‡L R
)
‡‡R S
{
ˆˆ 	
this
‰‰ 
.
‰‰ 
wrapped
‰‰ 
.
‰‰ 
	ReadBytes
‰‰ "
(
‰‰" #
dst
‰‰# &
,
‰‰& '
dstIndex
‰‰( 0
,
‰‰0 1
length
‰‰2 8
)
‰‰8 9
;
‰‰9 :
return
ŠŠ 
this
ŠŠ 
;
ŠŠ 
}
‹‹ 	
public
 
override
 
ICharSequence
 %
GetCharSequence
& 5
(
5 6
int
6 9
index
: ?
,
? @
int
A D
length
E K
,
K L
Encoding
M U
encoding
V ^
)
^ _
=>
` b
this
c g
.
g h
wrapped
h o
.
o p
GetCharSequence
p 
( €
index€ …
,… †
length‡ 
, 
encoding —
)— ˜
;˜ ™
public
 
override
 
ICharSequence
 %
ReadCharSequence
& 6
(
6 7
int
7 :
length
; A
,
A B
Encoding
C K
encoding
L T
)
T U
=>
V X
this
Y ]
.
] ^
wrapped
^ e
.
e f
ReadCharSequence
f v
(
v w
length
w }
,
} ~
encoding ‡
)‡ ˆ
;ˆ ‰
public
‘‘ 
override
‘‘ 
int
‘‘ 
SetCharSequence
‘‘ +
(
‘‘+ ,
int
‘‘, /
index
‘‘0 5
,
‘‘5 6
ICharSequence
‘‘7 D
sequence
‘‘E M
,
‘‘M N
Encoding
‘‘O W
encoding
‘‘X `
)
‘‘` a
=>
‘‘b d
this
‘‘e i
.
‘‘i j
wrapped
‘‘j q
.
‘‘q r
SetCharSequence‘‘r 
(‘‘ ‚
index‘‘‚ ‡
,‘‘‡ ˆ
sequence‘‘‰ ‘
,‘‘‘ ’
encoding‘‘“ ›
)‘‘› œ
;‘‘œ 
public
““ 
override
““ 
string
““ 
	GetString
““ (
(
““( )
int
““) ,
index
““- 2
,
““2 3
int
““4 7
length
““8 >
,
““> ?
Encoding
““@ H
encoding
““I Q
)
““Q R
=>
““S U
this
““V Z
.
““Z [
wrapped
““[ b
.
““b c
	GetString
““c l
(
““l m
index
““m r
,
““r s
length
““t z
,
““z {
encoding““| „
)““„ …
;““… †
public
•• 
override
•• 
string
•• 

ReadString
•• )
(
••) *
int
••* -
length
••. 4
,
••4 5
Encoding
••6 >
encoding
••? G
)
••G H
=>
••I K
this
••L P
.
••P Q
wrapped
••Q X
.
••X Y

ReadString
••Y c
(
••c d
length
••d j
,
••j k
encoding
••l t
)
••t u
;
••u v
public
—— 
override
—— 
int
—— 
	SetString
—— %
(
——% &
int
——& )
index
——* /
,
——/ 0
string
——1 7
value
——8 =
,
——= >
Encoding
——? G
encoding
——H P
)
——P Q
=>
——R T
this
——U Y
.
——Y Z
wrapped
——Z a
.
——a b
	SetString
——b k
(
——k l
index
——l q
,
——q r
value
——s x
,
——x y
encoding——z ‚
)——‚ ƒ
;——ƒ „
public
™™ 
override
™™ 
IByteBuffer
™™ #
	ReadBytes
™™$ -
(
™™- .
Stream
™™. 4
destination
™™5 @
,
™™@ A
int
™™B E
length
™™F L
)
™™L M
=>
™™N P
this
™™Q U
.
™™U V
wrapped
™™V ]
.
™™] ^
	ReadBytes
™™^ g
(
™™g h
destination
™™h s
,
™™s t
length
™™u {
)
™™{ |
;
™™| }
public
›› 
override
›› 
int
›› 
WriteCharSequence
›› -
(
››- .
ICharSequence
››. ;
sequence
››< D
,
››D E
Encoding
››F N
encoding
››O W
)
››W X
=>
››Y [
this
››\ `
.
››` a
wrapped
››a h
.
››h i
WriteCharSequence
››i z
(
››z {
sequence››{ ƒ
,››ƒ „
encoding››… 
)›› 
;›› 
public
 
override
 
int
 
WriteString
 '
(
' (
string
( .
value
/ 4
,
4 5
Encoding
6 >
encoding
? G
)
G H
=>
I K
this
L P
.
P Q
wrapped
Q X
.
X Y
WriteString
Y d
(
d e
value
e j
,
j k
encoding
l t
)
t u
;
u v
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ #
	SkipBytes
ŸŸ$ -
(
ŸŸ- .
int
ŸŸ. 1
length
ŸŸ2 8
)
ŸŸ8 9
{
   	
this
¡¡ 
.
¡¡ 
wrapped
¡¡ 
.
¡¡ 
	SkipBytes
¡¡ "
(
¡¡" #
length
¡¡# )
)
¡¡) *
;
¡¡* +
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ #
WriteBoolean
¥¥$ 0
(
¥¥0 1
bool
¥¥1 5
value
¥¥6 ;
)
¥¥; <
{
¦¦ 	
this
§§ 
.
§§ 
wrapped
§§ 
.
§§ 
WriteBoolean
§§ %
(
§§% &
value
§§& +
)
§§+ ,
;
§§, -
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
©© 	
public
«« 
override
«« 
IByteBuffer
«« #
	WriteByte
««$ -
(
««- .
int
««. 1
value
««2 7
)
««7 8
{
¬¬ 	
this
­­ 
.
­­ 
wrapped
­­ 
.
­­ 
	WriteByte
­­ "
(
­­" #
value
­­# (
)
­­( )
;
­­) *
return
®® 
this
®® 
;
®® 
}
¯¯ 	
public
±± 
override
±± 
IByteBuffer
±± #

WriteShort
±±$ .
(
±±. /
int
±±/ 2
value
±±3 8
)
±±8 9
{
²² 	
this
³³ 
.
³³ 
wrapped
³³ 
.
³³ 

WriteShort
³³ #
(
³³# $
value
³³$ )
)
³³) *
;
³³* +
return
´´ 
this
´´ 
;
´´ 
}
µµ 	
public
·· 
override
·· 
IByteBuffer
·· #
WriteMedium
··$ /
(
··/ 0
int
··0 3
value
··4 9
)
··9 :
{
¸¸ 	
this
¹¹ 
.
¹¹ 
wrapped
¹¹ 
.
¹¹ 
WriteMedium
¹¹ $
(
¹¹$ %
value
¹¹% *
)
¹¹* +
;
¹¹+ ,
return
ºº 
this
ºº 
;
ºº 
}
»» 	
public
½½ 
override
½½ 
IByteBuffer
½½ #
WriteInt
½½$ ,
(
½½, -
int
½½- 0
value
½½1 6
)
½½6 7
{
¾¾ 	
this
¿¿ 
.
¿¿ 
wrapped
¿¿ 
.
¿¿ 
WriteInt
¿¿ !
(
¿¿! "
value
¿¿" '
)
¿¿' (
;
¿¿( )
return
ÀÀ 
this
ÀÀ 
;
ÀÀ 
}
ÁÁ 	
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
	WriteLong
ÃÃ$ -
(
ÃÃ- .
long
ÃÃ. 2
value
ÃÃ3 8
)
ÃÃ8 9
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
wrapped
ÅÅ 
.
ÅÅ 
	WriteLong
ÅÅ "
(
ÅÅ" #
value
ÅÅ# (
)
ÅÅ( )
;
ÅÅ) *
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
	WriteChar
ÉÉ$ -
(
ÉÉ- .
char
ÉÉ. 2
value
ÉÉ3 8
)
ÉÉ8 9
{
ÊÊ 	
this
ËË 
.
ËË 
wrapped
ËË 
.
ËË 
	WriteChar
ËË "
(
ËË" #
value
ËË# (
)
ËË( )
;
ËË) *
return
ÌÌ 
this
ÌÌ 
;
ÌÌ 
}
ÍÍ 	
public
ÏÏ 
override
ÏÏ 
IByteBuffer
ÏÏ #

WriteFloat
ÏÏ$ .
(
ÏÏ. /
float
ÏÏ/ 4
value
ÏÏ5 :
)
ÏÏ: ;
{
ĞĞ 	
this
ÑÑ 
.
ÑÑ 
wrapped
ÑÑ 
.
ÑÑ 

WriteFloat
ÑÑ #
(
ÑÑ# $
value
ÑÑ$ )
)
ÑÑ) *
;
ÑÑ* +
return
ÒÒ 
this
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
ÕÕ 
override
ÕÕ 
IByteBuffer
ÕÕ #
WriteDouble
ÕÕ$ /
(
ÕÕ/ 0
double
ÕÕ0 6
value
ÕÕ7 <
)
ÕÕ< =
{
ÖÖ 	
this
×× 
.
×× 
wrapped
×× 
.
×× 
WriteDouble
×× $
(
××$ %
value
××% *
)
××* +
;
××+ ,
return
ØØ 
this
ØØ 
;
ØØ 
}
ÙÙ 	
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #

WriteBytes
ÛÛ$ .
(
ÛÛ. /
IByteBuffer
ÛÛ/ :
src
ÛÛ; >
)
ÛÛ> ?
{
ÜÜ 	
this
İİ 
.
İİ 
wrapped
İİ 
.
İİ 

WriteBytes
İİ #
(
İİ# $
src
İİ$ '
)
İİ' (
;
İİ( )
return
ŞŞ 
this
ŞŞ 
;
ŞŞ 
}
ßß 	
public
áá 
override
áá 
IByteBuffer
áá #

WriteBytes
áá$ .
(
áá. /
IByteBuffer
áá/ :
src
áá; >
,
áá> ?
int
áá@ C
length
ááD J
)
ááJ K
{
ââ 	
this
ãã 
.
ãã 
wrapped
ãã 
.
ãã 

WriteBytes
ãã #
(
ãã# $
src
ãã$ '
,
ãã' (
length
ãã) /
)
ãã/ 0
;
ãã0 1
return
ää 
this
ää 
;
ää 
}
åå 	
public
çç 
override
çç 
IByteBuffer
çç #

WriteBytes
çç$ .
(
çç. /
IByteBuffer
çç/ :
src
çç; >
,
çç> ?
int
çç@ C
srcIndex
ççD L
,
ççL M
int
ççN Q
length
ççR X
)
ççX Y
{
èè 	
this
éé 
.
éé 
wrapped
éé 
.
éé 

WriteBytes
éé #
(
éé# $
src
éé$ '
,
éé' (
srcIndex
éé) 1
,
éé1 2
length
éé3 9
)
éé9 :
;
éé: ;
return
êê 
this
êê 
;
êê 
}
ëë 	
public
íí 
override
íí 
IByteBuffer
íí #

WriteBytes
íí$ .
(
íí. /
byte
íí/ 3
[
íí3 4
]
íí4 5
src
íí6 9
)
íí9 :
{
îî 	
this
ïï 
.
ïï 
wrapped
ïï 
.
ïï 

WriteBytes
ïï #
(
ïï# $
src
ïï$ '
)
ïï' (
;
ïï( )
return
ğğ 
this
ğğ 
;
ğğ 
}
ññ 	
public
óó 
override
óó 
IByteBuffer
óó #

WriteBytes
óó$ .
(
óó. /
byte
óó/ 3
[
óó3 4
]
óó4 5
src
óó6 9
,
óó9 :
int
óó; >
srcIndex
óó? G
,
óóG H
int
óóI L
length
óóM S
)
óóS T
{
ôô 	
this
õõ 
.
õõ 
wrapped
õõ 
.
õõ 

WriteBytes
õõ #
(
õõ# $
src
õõ$ '
,
õõ' (
srcIndex
õõ) 1
,
õõ1 2
length
õõ3 9
)
õõ9 :
;
õõ: ;
return
öö 
this
öö 
;
öö 
}
÷÷ 	
public
ùù 
override
ùù 
IByteBuffer
ùù #
	WriteZero
ùù$ -
(
ùù- .
int
ùù. 1
length
ùù2 8
)
ùù8 9
{
úú 	
this
ûû 
.
ûû 
wrapped
ûû 
.
ûû 
	WriteZero
ûû "
(
ûû" #
length
ûû# )
)
ûû) *
;
ûû* +
return
üü 
this
üü 
;
üü 
}
ıı 	
public
ÿÿ 
override
ÿÿ 
IReferenceCounted
ÿÿ )
Retain
ÿÿ* 0
(
ÿÿ0 1
int
ÿÿ1 4
	increment
ÿÿ5 >
)
ÿÿ> ?
{
€€ 	
this
 
.
 
wrapped
 
.
 
Retain
 
(
  
	increment
  )
)
) *
;
* +
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
ƒƒ 	
public
…… 
override
…… 
IReferenceCounted
…… )
Retain
……* 0
(
……0 1
)
……1 2
{
†† 	
this
‡‡ 
.
‡‡ 
wrapped
‡‡ 
.
‡‡ 
Retain
‡‡ 
(
‡‡  
)
‡‡  !
;
‡‡! "
return
ˆˆ 
this
ˆˆ 
;
ˆˆ 
}
‰‰ 	
public
‹‹ 
override
‹‹ 
IReferenceCounted
‹‹ )
Touch
‹‹* /
(
‹‹/ 0
)
‹‹0 1
{
ŒŒ 	
this
 
.
 
wrapped
 
.
 
Touch
 
(
 
)
  
;
  !
return
 
this
 
;
 
}
 	
public
‘‘ 
override
‘‘ 
IReferenceCounted
‘‘ )
Touch
‘‘* /
(
‘‘/ 0
object
‘‘0 6
hint
‘‘7 ;
)
‘‘; <
{
’’ 	
this
““ 
.
““ 
wrapped
““ 
.
““ 
Touch
““ 
(
““ 
hint
““ #
)
““# $
;
““$ %
return
”” 
this
”” 
;
”” 
}
•• 	
public
—— 
override
—— 
IByteBuffer
—— #"
DiscardSomeReadBytes
——$ 8
(
——8 9
)
——9 :
{
˜˜ 	
this
™™ 
.
™™ 
wrapped
™™ 
.
™™ "
DiscardSomeReadBytes
™™ -
(
™™- .
)
™™. /
;
™™/ 0
return
šš 
this
šš 
;
šš 
}
›› 	
	protected
 
internal
 
sealed
 !
override
" *
void
+ /

Deallocate
0 :
(
: ;
)
; <
=>
= ?
this
@ D
.
D E
wrapped
E L
.
L M

Deallocate
M W
(
W X
)
X Y
;
Y Z
public
ŸŸ 
sealed
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ *
Unwrap
ŸŸ+ 1
(
ŸŸ1 2
)
ŸŸ2 3
=>
ŸŸ4 6
this
ŸŸ7 ;
.
ŸŸ; <
wrapped
ŸŸ< C
;
ŸŸC D
public
¡¡ 
sealed
¡¡ 
override
¡¡ 
IntPtr
¡¡ %#
AddressOfPinnedMemory
¡¡& ;
(
¡¡; <
)
¡¡< =
=>
¡¡> @
this
¡¡A E
.
¡¡E F
wrapped
¡¡F M
.
¡¡M N#
AddressOfPinnedMemory
¡¡N c
(
¡¡c d
)
¡¡d e
;
¡¡e f
public
££ 
sealed
££ 
override
££ 
ref
££ "
byte
££# '&
GetPinnableMemoryAddress
££( @
(
££@ A
)
££A B
=>
££C E
ref
££F I
this
££J N
.
££N O
wrapped
££O V
.
££V W&
GetPinnableMemoryAddress
££W o
(
££o p
)
££p q
;
££q r
public
¥¥ 
sealed
¥¥ 
override
¥¥ 
bool
¥¥ #
HasMemoryAddress
¥¥$ 4
=>
¥¥5 7
this
¥¥8 <
.
¥¥< =
wrapped
¥¥= D
.
¥¥D E
HasMemoryAddress
¥¥E U
;
¥¥U V
public
§§ 
sealed
§§ 
override
§§ 
bool
§§ #

IsWritable
§§$ .
(
§§. /
int
§§/ 2
size
§§3 7
)
§§7 8
=>
§§9 ;
this
§§< @
.
§§@ A
wrapped
§§A H
.
§§H I

IsWritable
§§I S
(
§§S T
size
§§T X
)
§§X Y
;
§§Y Z
public
©© 
sealed
©© 
override
©© 
int
©© "
MaxCapacity
©©# .
=>
©©/ 1
this
©©2 6
.
©©6 7
wrapped
©©7 >
.
©©> ?
MaxCapacity
©©? J
;
©©J K
public
«« 
sealed
«« 
override
«« 
bool
«« #
IsDirect
««$ ,
=>
««- /
this
««0 4
.
««4 5
wrapped
««5 <
.
««< =
IsDirect
««= E
;
««E F
public
­­ 
override
­­ 
IByteBuffer
­­ #
ReadRetainedSlice
­­$ 5
(
­­5 6
int
­­6 9
length
­­: @
)
­­@ A
=>
­­B D
this
­­E I
.
­­I J
wrapped
­­J Q
.
­­Q R
ReadRetainedSlice
­­R c
(
­­c d
length
­­d j
)
­­j k
;
­­k l
public
¯¯ 
override
¯¯ 
IByteBuffer
¯¯ #
RetainedDuplicate
¯¯$ 5
(
¯¯5 6
)
¯¯6 7
=>
¯¯8 :
this
¯¯; ?
.
¯¯? @
wrapped
¯¯@ G
.
¯¯G H
RetainedDuplicate
¯¯H Y
(
¯¯Y Z
)
¯¯Z [
;
¯¯[ \
public
±± 
override
±± 
IByteBuffer
±± #
RetainedSlice
±±$ 1
(
±±1 2
)
±±2 3
=>
±±4 6
this
±±7 ;
.
±±; <
wrapped
±±< C
.
±±C D
RetainedSlice
±±D Q
(
±±Q R
)
±±R S
;
±±S T
public
³³ 
override
³³ 
IByteBuffer
³³ #
RetainedSlice
³³$ 1
(
³³1 2
int
³³2 5
index
³³6 ;
,
³³; <
int
³³= @
length
³³A G
)
³³G H
=>
³³I K
this
³³L P
.
³³P Q
wrapped
³³Q X
.
³³X Y
RetainedSlice
³³Y f
(
³³f g
index
³³g l
,
³³l m
length
³³n t
)
³³t u
;
³³u v
}
´´ 
}µµ 