æà	
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class 
AbstractByteBuffer ,
:- .
IByteBuffer/ :
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S
AbstractByteBufferS e
>e f
(f g
)g h
;h i
const 
string 
PropMode 
= 
$str  I
;I J
static 
readonly 
bool 
CheckAccessible ,
;, -
internal 
static 
readonly   
ResourceLeakDetector! 5
LeakDetector6 B
=C D 
ResourceLeakDetectorE Y
.Y Z
CreateZ `
<` a
IByteBuffera l
>l m
(m n
)n o
;o p
int 
readerIndex 
; 
int   
writerIndex   
;   
int"" 
markedReaderIndex"" 
;"" 
int## 
markedWriterIndex## 
;## 
int$$ 
maxCapacity$$ 
;$$ 
static&& 
AbstractByteBuffer&& !
(&&! "
)&&" #
{'' 	
CheckAccessible(( 
=(( 
SystemPropertyUtil(( 0
.((0 1

GetBoolean((1 ;
(((; <
PropMode((< D
,((D E
true((F J
)((J K
;((K L
if)) 
()) 
Logger)) 
.)) 
DebugEnabled)) #
)))# $
{** 
Logger++ 
.++ 
Debug++ 
(++ 
$str++ '
,++' (
PropMode++) 1
,++1 2
CheckAccessible++3 B
)++B C
;++C D
},, 
}-- 	
	protected// 
AbstractByteBuffer// $
(//$ %
int//% (
maxCapacity//) 4
)//4 5
{00 	
Contract11 
.11 
Requires11 
(11 
maxCapacity11 )
>=11* ,
$num11- .
)11. /
;11/ 0
this33 
.33 
maxCapacity33 
=33 
maxCapacity33 *
;33* +
}44 	
public66 
abstract66 
int66 
Capacity66 $
{66% &
get66' *
;66* +
}66, -
public88 
abstract88 
IByteBuffer88 #
AdjustCapacity88$ 2
(882 3
int883 6
newCapacity887 B
)88B C
;88C D
public:: 
virtual:: 
int:: 
MaxCapacity:: &
=>::' )
this::* .
.::. /
maxCapacity::/ :
;::: ;
	protected<< 
void<< 
SetMaxCapacity<< %
(<<% &
int<<& )
newMaxCapacity<<* 8
)<<8 9
{== 	
Contract>> 
.>> 
Requires>> 
(>> 
newMaxCapacity>> ,
>=>>- /
$num>>0 1
)>>1 2
;>>2 3
this@@ 
.@@ 
maxCapacity@@ 
=@@ 
newMaxCapacity@@ -
;@@- .
}AA 	
publicCC 
abstractCC  
IByteBufferAllocatorCC ,
	AllocatorCC- 6
{CC7 8
getCC9 <
;CC< =
}CC> ?
publicEE 
virtualEE 
intEE 
ReaderIndexEE &
=>EE' )
thisEE* .
.EE. /
readerIndexEE/ :
;EE: ;
publicGG 
virtualGG 
IByteBufferGG "
SetReaderIndexGG# 1
(GG1 2
intGG2 5
indexGG6 ;
)GG; <
{HH 	
ifII 
(II 
indexII 
<II 
$numII 
||II 
indexII "
>II# $
thisII% )
.II) *
writerIndexII* 5
)II5 6
{JJ 
ThrowHelperKK 
.KK 5
)ThrowIndexOutOfRangeException_ReaderIndexKK E
(KKE F
indexKKF K
,KKK L
thisKKM Q
.KKQ R
WriterIndexKKR ]
)KK] ^
;KK^ _
}LL 
thisNN 
.NN 
readerIndexNN 
=NN 
indexNN $
;NN$ %
returnOO 
thisOO 
;OO 
}PP 	
publicRR 
virtualRR 
intRR 
WriterIndexRR &
=>RR' )
thisRR* .
.RR. /
writerIndexRR/ :
;RR: ;
publicTT 
virtualTT 
IByteBufferTT "
SetWriterIndexTT# 1
(TT1 2
intTT2 5
indexTT6 ;
)TT; <
{UU 	
ifVV 
(VV 
indexVV 
<VV 
thisVV 
.VV 
readerIndexVV (
||VV) +
indexVV, 1
>VV2 3
thisVV4 8
.VV8 9
CapacityVV9 A
)VVA B
{WW 
ThrowHelperXX 
.XX 5
)ThrowIndexOutOfRangeException_WriterIndexXX E
(XXE F
indexXXF K
,XXK L
thisXXM Q
.XXQ R
readerIndexXXR ]
,XX] ^
thisXX_ c
.XXc d
CapacityXXd l
)XXl m
;XXm n
}YY 
this[[ 
.[[ 
SetWriterIndex0[[  
([[  !
index[[! &
)[[& '
;[[' (
return\\ 
this\\ 
;\\ 
}]] 	
	protected__ 
void__ 
SetWriterIndex0__ &
(__& '
int__' *
index__+ 0
)__0 1
{`` 	
thisaa 
.aa 
writerIndexaa 
=aa 
indexaa $
;aa$ %
}bb 	
publicdd 
virtualdd 
IByteBufferdd "
SetIndexdd# +
(dd+ ,
intdd, /
	readerIdxdd0 9
,dd9 :
intdd; >
	writerIdxdd? H
)ddH I
{ee 	
ifff 
(ff 
	readerIdxff 
<ff 
$numff 
||ff  
	readerIdxff! *
>ff+ ,
	writerIdxff- 6
||ff7 9
	writerIdxff: C
>ffD E
thisffF J
.ffJ K
CapacityffK S
)ffS T
{gg 
ThrowHelperhh 
.hh ;
/ThrowIndexOutOfRangeException_ReaderWriterIndexhh K
(hhK L
	readerIdxhhL U
,hhU V
	writerIdxhhW `
,hh` a
thishhb f
.hhf g
Capacityhhg o
)hho p
;hhp q
}ii 
thiskk 
.kk 
	SetIndex0kk 
(kk 
	readerIdxkk $
,kk$ %
	writerIdxkk& /
)kk/ 0
;kk0 1
returnll 
thisll 
;ll 
}mm 	
publicoo 
virtualoo 
IByteBufferoo "
Clearoo# (
(oo( )
)oo) *
{pp 	
thisqq 
.qq 
readerIndexqq 
=qq 
thisqq #
.qq# $
writerIndexqq$ /
=qq0 1
$numqq2 3
;qq3 4
returnrr 
thisrr 
;rr 
}ss 	
publicuu 
virtualuu 
booluu 

IsReadableuu &
(uu& '
)uu' (
=>uu) +
thisuu, 0
.uu0 1
writerIndexuu1 <
>uu= >
thisuu? C
.uuC D
readerIndexuuD O
;uuO P
publicww 
virtualww 
boolww 

IsReadableww &
(ww& '
intww' *
sizeww+ /
)ww/ 0
=>ww1 3
thisww4 8
.ww8 9
writerIndexww9 D
-wwE F
thiswwG K
.wwK L
readerIndexwwL W
>=wwX Z
sizeww[ _
;ww_ `
publicyy 
virtualyy 
boolyy 

IsWritableyy &
(yy& '
)yy' (
=>yy) +
thisyy, 0
.yy0 1
Capacityyy1 9
>yy: ;
thisyy< @
.yy@ A
writerIndexyyA L
;yyL M
public{{ 
virtual{{ 
bool{{ 

IsWritable{{ &
({{& '
int{{' *
size{{+ /
){{/ 0
=>{{1 3
this{{4 8
.{{8 9
Capacity{{9 A
-{{B C
this{{D H
.{{H I
writerIndex{{I T
>={{U W
size{{X \
;{{\ ]
public}} 
virtual}} 
int}} 
ReadableBytes}} (
=>}}) +
this}}, 0
.}}0 1
writerIndex}}1 <
-}}= >
this}}? C
.}}C D
readerIndex}}D O
;}}O P
public 
virtual 
int 
WritableBytes (
=>) +
this, 0
.0 1
Capacity1 9
-: ;
this< @
.@ A
writerIndexA L
;L M
public
ÅÅ 
virtual
ÅÅ 
int
ÅÅ 
MaxWritableBytes
ÅÅ +
=>
ÅÅ, .
this
ÅÅ/ 3
.
ÅÅ3 4
MaxCapacity
ÅÅ4 ?
-
ÅÅ@ A
this
ÅÅB F
.
ÅÅF G
writerIndex
ÅÅG R
;
ÅÅR S
public
ÉÉ 
virtual
ÉÉ 
IByteBuffer
ÉÉ "
MarkReaderIndex
ÉÉ# 2
(
ÉÉ2 3
)
ÉÉ3 4
{
ÑÑ 	
this
ÖÖ 
.
ÖÖ 
markedReaderIndex
ÖÖ "
=
ÖÖ# $
this
ÖÖ% )
.
ÖÖ) *
readerIndex
ÖÖ* 5
;
ÖÖ5 6
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
áá 	
public
ââ 
virtual
ââ 
IByteBuffer
ââ "
ResetReaderIndex
ââ# 3
(
ââ3 4
)
ââ4 5
{
ää 	
this
ãã 
.
ãã 
SetReaderIndex
ãã 
(
ãã  
this
ãã  $
.
ãã$ %
markedReaderIndex
ãã% 6
)
ãã6 7
;
ãã7 8
return
åå 
this
åå 
;
åå 
}
çç 	
public
èè 
virtual
èè 
IByteBuffer
èè "
MarkWriterIndex
èè# 2
(
èè2 3
)
èè3 4
{
êê 	
this
ëë 
.
ëë 
markedWriterIndex
ëë "
=
ëë# $
this
ëë% )
.
ëë) *
writerIndex
ëë* 5
;
ëë5 6
return
íí 
this
íí 
;
íí 
}
ìì 	
public
ïï 
virtual
ïï 
IByteBuffer
ïï "
ResetWriterIndex
ïï# 3
(
ïï3 4
)
ïï4 5
{
ññ 	
this
óó 
.
óó 
SetWriterIndex
óó 
(
óó  
this
óó  $
.
óó$ %
markedWriterIndex
óó% 6
)
óó6 7
;
óó7 8
return
òò 
this
òò 
;
òò 
}
ôô 	
	protected
õõ 
void
õõ 
	MarkIndex
õõ  
(
õõ  !
)
õõ! "
{
úú 	
this
ùù 
.
ùù 
markedReaderIndex
ùù "
=
ùù# $
this
ùù% )
.
ùù) *
readerIndex
ùù* 5
;
ùù5 6
this
ûû 
.
ûû 
markedWriterIndex
ûû "
=
ûû# $
this
ûû% )
.
ûû) *
writerIndex
ûû* 5
;
ûû5 6
}
üü 	
public
°° 
virtual
°° 
IByteBuffer
°° "
DiscardReadBytes
°°# 3
(
°°3 4
)
°°4 5
{
¢¢ 	
this
££ 
.
££ 
EnsureAccessible
££ !
(
££! "
)
££" #
;
££# $
if
§§ 
(
§§ 
this
§§ 
.
§§ 
readerIndex
§§  
==
§§! #
$num
§§$ %
)
§§% &
{
•• 
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
ßß 
if
©© 
(
©© 
this
©© 
.
©© 
readerIndex
©©  
!=
©©! #
this
©©$ (
.
©©( )
writerIndex
©©) 4
)
©©4 5
{
™™ 
this
´´ 
.
´´ 
SetBytes
´´ 
(
´´ 
$num
´´ 
,
´´  
this
´´! %
,
´´% &
this
´´' +
.
´´+ ,
readerIndex
´´, 7
,
´´7 8
this
´´9 =
.
´´= >
writerIndex
´´> I
-
´´J K
this
´´L P
.
´´P Q
readerIndex
´´Q \
)
´´\ ]
;
´´] ^
this
¨¨ 
.
¨¨ 
writerIndex
¨¨  
-=
¨¨! #
this
¨¨$ (
.
¨¨( )
readerIndex
¨¨) 4
;
¨¨4 5
this
≠≠ 
.
≠≠ 
AdjustMarkers
≠≠ "
(
≠≠" #
this
≠≠# '
.
≠≠' (
readerIndex
≠≠( 3
)
≠≠3 4
;
≠≠4 5
this
ÆÆ 
.
ÆÆ 
readerIndex
ÆÆ  
=
ÆÆ! "
$num
ÆÆ# $
;
ÆÆ$ %
}
ØØ 
else
∞∞ 
{
±± 
this
≤≤ 
.
≤≤ 
AdjustMarkers
≤≤ "
(
≤≤" #
this
≤≤# '
.
≤≤' (
readerIndex
≤≤( 3
)
≤≤3 4
;
≤≤4 5
this
≥≥ 
.
≥≥ 
writerIndex
≥≥  
=
≥≥! "
this
≥≥# '
.
≥≥' (
readerIndex
≥≥( 3
=
≥≥4 5
$num
≥≥6 7
;
≥≥7 8
}
¥¥ 
return
∂∂ 
this
∂∂ 
;
∂∂ 
}
∑∑ 	
public
ππ 
virtual
ππ 
IByteBuffer
ππ ""
DiscardSomeReadBytes
ππ# 7
(
ππ7 8
)
ππ8 9
{
∫∫ 	
this
ªª 
.
ªª 
EnsureAccessible
ªª !
(
ªª! "
)
ªª" #
;
ªª# $
if
ºº 
(
ºº 
this
ºº 
.
ºº 
readerIndex
ºº  
==
ºº! #
$num
ºº$ %
)
ºº% &
{
ΩΩ 
return
ææ 
this
ææ 
;
ææ 
}
øø 
if
¡¡ 
(
¡¡ 
this
¡¡ 
.
¡¡ 
readerIndex
¡¡  
==
¡¡! #
this
¡¡$ (
.
¡¡( )
writerIndex
¡¡) 4
)
¡¡4 5
{
¬¬ 
this
√√ 
.
√√ 
AdjustMarkers
√√ "
(
√√" #
this
√√# '
.
√√' (
readerIndex
√√( 3
)
√√3 4
;
√√4 5
this
ƒƒ 
.
ƒƒ 
writerIndex
ƒƒ  
=
ƒƒ! "
this
ƒƒ# '
.
ƒƒ' (
readerIndex
ƒƒ( 3
=
ƒƒ4 5
$num
ƒƒ6 7
;
ƒƒ7 8
return
≈≈ 
this
≈≈ 
;
≈≈ 
}
∆∆ 
if
»» 
(
»» 
this
»» 
.
»» 
readerIndex
»»  
>=
»»! #
this
»»$ (
.
»»( )
Capacity
»») 1
.
»»1 2
RightUShift
»»2 =
(
»»= >
$num
»»> ?
)
»»? @
)
»»@ A
{
…… 
this
   
.
   
SetBytes
   
(
   
$num
   
,
    
this
  ! %
,
  % &
this
  ' +
.
  + ,
readerIndex
  , 7
,
  7 8
this
  9 =
.
  = >
writerIndex
  > I
-
  J K
this
  L P
.
  P Q
readerIndex
  Q \
)
  \ ]
;
  ] ^
this
ÀÀ 
.
ÀÀ 
writerIndex
ÀÀ  
-=
ÀÀ! #
this
ÀÀ$ (
.
ÀÀ( )
readerIndex
ÀÀ) 4
;
ÀÀ4 5
this
ÃÃ 
.
ÃÃ 
AdjustMarkers
ÃÃ "
(
ÃÃ" #
this
ÃÃ# '
.
ÃÃ' (
readerIndex
ÃÃ( 3
)
ÃÃ3 4
;
ÃÃ4 5
this
ÕÕ 
.
ÕÕ 
readerIndex
ÕÕ  
=
ÕÕ! "
$num
ÕÕ# $
;
ÕÕ$ %
}
ŒŒ 
return
–– 
this
–– 
;
–– 
}
—— 	
	protected
”” 
void
”” 
AdjustMarkers
”” $
(
””$ %
int
””% (
	decrement
””) 2
)
””2 3
{
‘‘ 	
int
’’ 
markedReaderIdx
’’ 
=
’’  !
this
’’" &
.
’’& '
markedReaderIndex
’’' 8
;
’’8 9
if
÷÷ 
(
÷÷ 
markedReaderIdx
÷÷ 
<=
÷÷  "
	decrement
÷÷# ,
)
÷÷, -
{
◊◊ 
this
ÿÿ 
.
ÿÿ 
markedReaderIndex
ÿÿ &
=
ÿÿ' (
$num
ÿÿ) *
;
ÿÿ* +
int
ŸŸ 
markedWriterIdx
ŸŸ #
=
ŸŸ$ %
this
ŸŸ& *
.
ŸŸ* +
markedWriterIndex
ŸŸ+ <
;
ŸŸ< =
if
⁄⁄ 
(
⁄⁄ 
markedWriterIdx
⁄⁄ #
<=
⁄⁄$ &
	decrement
⁄⁄' 0
)
⁄⁄0 1
{
€€ 
this
‹‹ 
.
‹‹ 
markedWriterIndex
‹‹ *
=
‹‹+ ,
$num
‹‹- .
;
‹‹. /
}
›› 
else
ﬁﬁ 
{
ﬂﬂ 
this
‡‡ 
.
‡‡ 
markedWriterIndex
‡‡ *
=
‡‡+ ,
markedWriterIdx
‡‡- <
-
‡‡= >
	decrement
‡‡? H
;
‡‡H I
}
·· 
}
‚‚ 
else
„„ 
{
‰‰ 
this
ÂÂ 
.
ÂÂ 
markedReaderIndex
ÂÂ &
=
ÂÂ' (
markedReaderIdx
ÂÂ) 8
-
ÂÂ9 :
	decrement
ÂÂ; D
;
ÂÂD E
this
ÊÊ 
.
ÊÊ 
markedWriterIndex
ÊÊ &
-=
ÊÊ' )
	decrement
ÊÊ* 3
;
ÊÊ3 4
}
ÁÁ 
}
ËË 	
public
ÍÍ 
virtual
ÍÍ 
IByteBuffer
ÍÍ "
EnsureWritable
ÍÍ# 1
(
ÍÍ1 2
int
ÍÍ2 5
minWritableBytes
ÍÍ6 F
)
ÍÍF G
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
minWritableBytes
ÏÏ  
<
ÏÏ! "
$num
ÏÏ# $
)
ÏÏ$ %
{
ÌÌ 
ThrowHelper
ÓÓ 
.
ÓÓ ?
1ThrowArgumentOutOfRangeException_MinWritableBytes
ÓÓ M
(
ÓÓM N
)
ÓÓN O
;
ÓÓO P
}
ÔÔ 
this
ÒÒ 
.
ÒÒ 
EnsureWritable0
ÒÒ  
(
ÒÒ  !
minWritableBytes
ÒÒ! 1
)
ÒÒ1 2
;
ÒÒ2 3
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
[
ıı 	

MethodImpl
ıı	 
(
ıı 
MethodImplOptions
ıı %
.
ıı% & 
AggressiveInlining
ıı& 8
)
ıı8 9
]
ıı9 :
	protected
ˆˆ 
internal
ˆˆ 
void
ˆˆ 
EnsureWritable0
ˆˆ  /
(
ˆˆ/ 0
int
ˆˆ0 3
minWritableBytes
ˆˆ4 D
)
ˆˆD E
{
˜˜ 	
this
¯¯ 
.
¯¯ 
EnsureAccessible
¯¯ !
(
¯¯! "
)
¯¯" #
;
¯¯# $
if
˘˘ 
(
˘˘ 
minWritableBytes
˘˘  
<=
˘˘! #
this
˘˘$ (
.
˘˘( )
WritableBytes
˘˘) 6
)
˘˘6 7
{
˙˙ 
return
˚˚ 
;
˚˚ 
}
¸¸ 
if
˛˛ 
(
˛˛ 
minWritableBytes
˛˛  
>
˛˛! "
this
˛˛# '
.
˛˛' (
MaxCapacity
˛˛( 3
-
˛˛4 5
this
˛˛6 :
.
˛˛: ;
writerIndex
˛˛; F
)
˛˛F G
{
ˇˇ 
ThrowHelper
ÄÄ 
.
ÄÄ 7
)ThrowIndexOutOfRangeException_WriterIndex
ÄÄ E
(
ÄÄE F
minWritableBytes
ÄÄF V
,
ÄÄV W
this
ÄÄX \
.
ÄÄ\ ]
writerIndex
ÄÄ] h
,
ÄÄh i
this
ÄÄj n
.
ÄÄn o
MaxCapacity
ÄÄo z
,
ÄÄz {
thisÄÄ| Ä
)ÄÄÄ Å
;ÄÄÅ Ç
}
ÅÅ 
int
ÑÑ 
newCapacity
ÑÑ 
=
ÑÑ 
this
ÑÑ "
.
ÑÑ" #
	Allocator
ÑÑ# ,
.
ÑÑ, -"
CalculateNewCapacity
ÑÑ- A
(
ÑÑA B
this
ÑÑB F
.
ÑÑF G
writerIndex
ÑÑG R
+
ÑÑS T
minWritableBytes
ÑÑU e
,
ÑÑe f
this
ÑÑg k
.
ÑÑk l
MaxCapacity
ÑÑl w
)
ÑÑw x
;
ÑÑx y
this
áá 
.
áá 
AdjustCapacity
áá 
(
áá  
newCapacity
áá  +
)
áá+ ,
;
áá, -
}
àà 	
public
ää 
virtual
ää 
int
ää 
EnsureWritable
ää )
(
ää) *
int
ää* -
minWritableBytes
ää. >
,
ää> ?
bool
ää@ D
force
ääE J
)
ääJ K
{
ãã 	
Contract
åå 
.
åå 
Ensures
åå 
(
åå 
minWritableBytes
åå -
>=
åå. 0
$num
åå1 2
)
åå2 3
;
åå3 4
this
éé 
.
éé 
EnsureAccessible
éé !
(
éé! "
)
éé" #
;
éé# $
if
èè 
(
èè 
minWritableBytes
èè  
<=
èè! #
this
èè$ (
.
èè( )
WritableBytes
èè) 6
)
èè6 7
{
êê 
return
ëë 
$num
ëë 
;
ëë 
}
íí 
if
îî 
(
îî 
minWritableBytes
îî  
>
îî! "
this
îî# '
.
îî' (
MaxCapacity
îî( 3
-
îî4 5
this
îî6 :
.
îî: ;
writerIndex
îî; F
)
îîF G
{
ïï 
if
ññ 
(
ññ 
!
ññ 
force
ññ 
||
ññ 
this
ññ "
.
ññ" #
Capacity
ññ# +
==
ññ, .
this
ññ/ 3
.
ññ3 4
MaxCapacity
ññ4 ?
)
ññ? @
{
óó 
return
òò 
$num
òò  
;
òò  !
}
ôô 
this
õõ 
.
õõ 
AdjustCapacity
õõ #
(
õõ# $
this
õõ$ (
.
õõ( )
MaxCapacity
õõ) 4
)
õõ4 5
;
õõ5 6
return
úú 
$num
úú 
;
úú 
}
ùù 
int
†† 
newCapacity
†† 
=
†† 
this
†† "
.
††" #
	Allocator
††# ,
.
††, -"
CalculateNewCapacity
††- A
(
††A B
this
††B F
.
††F G
writerIndex
††G R
+
††S T
minWritableBytes
††U e
,
††e f
this
††g k
.
††k l
MaxCapacity
††l w
)
††w x
;
††x y
this
££ 
.
££ 
AdjustCapacity
££ 
(
££  
newCapacity
££  +
)
££+ ,
;
££, -
return
§§ 
$num
§§ 
;
§§ 
}
•• 	
public
ßß 
virtual
ßß 
byte
ßß 
GetByte
ßß #
(
ßß# $
int
ßß$ '
index
ßß( -
)
ßß- .
{
®® 	
this
©© 
.
©© 

CheckIndex
©© 
(
©© 
index
©© !
)
©©! "
;
©©" #
return
™™ 
this
™™ 
.
™™ 
_GetByte
™™  
(
™™  !
index
™™! &
)
™™& '
;
™™' (
}
´´ 	
	protected
≠≠ 
internal
≠≠ 
abstract
≠≠ #
byte
≠≠$ (
_GetByte
≠≠) 1
(
≠≠1 2
int
≠≠2 5
index
≠≠6 ;
)
≠≠; <
;
≠≠< =
public
ØØ 
bool
ØØ 

GetBoolean
ØØ 
(
ØØ 
int
ØØ "
index
ØØ# (
)
ØØ( )
=>
ØØ* ,
this
ØØ- 1
.
ØØ1 2
GetByte
ØØ2 9
(
ØØ9 :
index
ØØ: ?
)
ØØ? @
!=
ØØA C
$num
ØØD E
;
ØØE F
public
±± 
virtual
±± 
short
±± 
GetShort
±± %
(
±±% &
int
±±& )
index
±±* /
)
±±/ 0
{
≤≤ 	
this
≥≥ 
.
≥≥ 

CheckIndex
≥≥ 
(
≥≥ 
index
≥≥ !
,
≥≥! "
$num
≥≥# $
)
≥≥$ %
;
≥≥% &
return
¥¥ 
this
¥¥ 
.
¥¥ 
	_GetShort
¥¥ !
(
¥¥! "
index
¥¥" '
)
¥¥' (
;
¥¥( )
}
µµ 	
	protected
∑∑ 
internal
∑∑ 
abstract
∑∑ #
short
∑∑$ )
	_GetShort
∑∑* 3
(
∑∑3 4
int
∑∑4 7
index
∑∑8 =
)
∑∑= >
;
∑∑> ?
public
ππ 
virtual
ππ 
short
ππ 

GetShortLE
ππ '
(
ππ' (
int
ππ( +
index
ππ, 1
)
ππ1 2
{
∫∫ 	
this
ªª 
.
ªª 

CheckIndex
ªª 
(
ªª 
index
ªª !
,
ªª! "
$num
ªª# $
)
ªª$ %
;
ªª% &
return
ºº 
this
ºº 
.
ºº 
_GetShortLE
ºº #
(
ºº# $
index
ºº$ )
)
ºº) *
;
ºº* +
}
ΩΩ 	
	protected
øø 
internal
øø 
abstract
øø #
short
øø$ )
_GetShortLE
øø* 5
(
øø5 6
int
øø6 9
index
øø: ?
)
øø? @
;
øø@ A
public
¡¡ 
ushort
¡¡ 
GetUnsignedShort
¡¡ &
(
¡¡& '
int
¡¡' *
index
¡¡+ 0
)
¡¡0 1
{
¬¬ 	
	unchecked
√√ 
{
ƒƒ 
return
≈≈ 
(
≈≈ 
ushort
≈≈ 
)
≈≈ 
this
≈≈ #
.
≈≈# $
GetShort
≈≈$ ,
(
≈≈, -
index
≈≈- 2
)
≈≈2 3
;
≈≈3 4
}
∆∆ 
}
«« 	
public
…… 
ushort
……  
GetUnsignedShortLE
…… (
(
……( )
int
……) ,
index
……- 2
)
……2 3
{
   	
	unchecked
ÀÀ 
{
ÃÃ 
return
ÕÕ 
(
ÕÕ 
ushort
ÕÕ 
)
ÕÕ 
this
ÕÕ #
.
ÕÕ# $

GetShortLE
ÕÕ$ .
(
ÕÕ. /
index
ÕÕ/ 4
)
ÕÕ4 5
;
ÕÕ5 6
}
ŒŒ 
}
œœ 	
public
—— 
virtual
—— 
int
—— 
GetUnsignedMedium
—— ,
(
——, -
int
——- 0
index
——1 6
)
——6 7
{
““ 	
this
”” 
.
”” 

CheckIndex
”” 
(
”” 
index
”” !
,
””! "
$num
””# $
)
””$ %
;
””% &
return
‘‘ 
this
‘‘ 
.
‘‘  
_GetUnsignedMedium
‘‘ *
(
‘‘* +
index
‘‘+ 0
)
‘‘0 1
;
‘‘1 2
}
’’ 	
	protected
◊◊ 
internal
◊◊ 
abstract
◊◊ #
int
◊◊$ ' 
_GetUnsignedMedium
◊◊( :
(
◊◊: ;
int
◊◊; >
index
◊◊? D
)
◊◊D E
;
◊◊E F
public
ŸŸ 
virtual
ŸŸ 
int
ŸŸ !
GetUnsignedMediumLE
ŸŸ .
(
ŸŸ. /
int
ŸŸ/ 2
index
ŸŸ3 8
)
ŸŸ8 9
{
⁄⁄ 	
this
€€ 
.
€€ 

CheckIndex
€€ 
(
€€ 
index
€€ !
,
€€! "
$num
€€# $
)
€€$ %
;
€€% &
return
‹‹ 
this
‹‹ 
.
‹‹ "
_GetUnsignedMediumLE
‹‹ ,
(
‹‹, -
index
‹‹- 2
)
‹‹2 3
;
‹‹3 4
}
›› 	
	protected
ﬂﬂ 
internal
ﬂﬂ 
abstract
ﬂﬂ #
int
ﬂﬂ$ '"
_GetUnsignedMediumLE
ﬂﬂ( <
(
ﬂﬂ< =
int
ﬂﬂ= @
index
ﬂﬂA F
)
ﬂﬂF G
;
ﬂﬂG H
public
·· 
int
·· 
	GetMedium
·· 
(
·· 
int
··  
index
··! &
)
··& '
{
‚‚ 	
uint
„„ 
value
„„ 
=
„„ 
(
„„ 
uint
„„ 
)
„„ 
this
„„ #
.
„„# $
GetUnsignedMedium
„„$ 5
(
„„5 6
index
„„6 ;
)
„„; <
;
„„< =
if
‰‰ 
(
‰‰ 
(
‰‰ 
value
‰‰ 
&
‰‰ 
$num
‰‰ !
)
‰‰! "
!=
‰‰# %
$num
‰‰& '
)
‰‰' (
{
ÂÂ 
value
ÊÊ 
|=
ÊÊ 
$num
ÊÊ #
;
ÊÊ# $
}
ÁÁ 
return
ÈÈ 
(
ÈÈ 
int
ÈÈ 
)
ÈÈ 
value
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
public
ÏÏ 
int
ÏÏ 
GetMediumLE
ÏÏ 
(
ÏÏ 
int
ÏÏ "
index
ÏÏ# (
)
ÏÏ( )
{
ÌÌ 	
uint
ÓÓ 
value
ÓÓ 
=
ÓÓ 
(
ÓÓ 
uint
ÓÓ 
)
ÓÓ 
this
ÓÓ #
.
ÓÓ# $!
GetUnsignedMediumLE
ÓÓ$ 7
(
ÓÓ7 8
index
ÓÓ8 =
)
ÓÓ= >
;
ÓÓ> ?
if
ÔÔ 
(
ÔÔ 
(
ÔÔ 
value
ÔÔ 
&
ÔÔ 
$num
ÔÔ !
)
ÔÔ! "
!=
ÔÔ# %
$num
ÔÔ& '
)
ÔÔ' (
{
 
value
ÒÒ 
|=
ÒÒ 
$num
ÒÒ #
;
ÒÒ# $
}
ÚÚ 
return
ÙÙ 
(
ÙÙ 
int
ÙÙ 
)
ÙÙ 
value
ÙÙ 
;
ÙÙ 
}
ıı 	
public
˜˜ 
virtual
˜˜ 
int
˜˜ 
GetInt
˜˜ !
(
˜˜! "
int
˜˜" %
index
˜˜& +
)
˜˜+ ,
{
¯¯ 	
this
˘˘ 
.
˘˘ 

CheckIndex
˘˘ 
(
˘˘ 
index
˘˘ !
,
˘˘! "
$num
˘˘# $
)
˘˘$ %
;
˘˘% &
return
˙˙ 
this
˙˙ 
.
˙˙ 
_GetInt
˙˙ 
(
˙˙  
index
˙˙  %
)
˙˙% &
;
˙˙& '
}
˚˚ 	
	protected
˝˝ 
internal
˝˝ 
abstract
˝˝ #
int
˝˝$ '
_GetInt
˝˝( /
(
˝˝/ 0
int
˝˝0 3
index
˝˝4 9
)
˝˝9 :
;
˝˝: ;
public
ˇˇ 
virtual
ˇˇ 
int
ˇˇ 
GetIntLE
ˇˇ #
(
ˇˇ# $
int
ˇˇ$ '
index
ˇˇ( -
)
ˇˇ- .
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 

CheckIndex
ÅÅ 
(
ÅÅ 
index
ÅÅ !
,
ÅÅ! "
$num
ÅÅ# $
)
ÅÅ$ %
;
ÅÅ% &
return
ÇÇ 
this
ÇÇ 
.
ÇÇ 
	_GetIntLE
ÇÇ !
(
ÇÇ! "
index
ÇÇ" '
)
ÇÇ' (
;
ÇÇ( )
}
ÉÉ 	
	protected
ÖÖ 
internal
ÖÖ 
abstract
ÖÖ #
int
ÖÖ$ '
	_GetIntLE
ÖÖ( 1
(
ÖÖ1 2
int
ÖÖ2 5
index
ÖÖ6 ;
)
ÖÖ; <
;
ÖÖ< =
public
áá 
uint
áá 
GetUnsignedInt
áá "
(
áá" #
int
áá# &
index
áá' ,
)
áá, -
{
àà 	
	unchecked
ââ 
{
ää 
return
ãã 
(
ãã 
uint
ãã 
)
ãã 
(
ãã 
this
ãã "
.
ãã" #
GetInt
ãã# )
(
ãã) *
index
ãã* /
)
ãã/ 0
)
ãã0 1
;
ãã1 2
}
åå 
}
çç 	
public
èè 
uint
èè 
GetUnsignedIntLE
èè $
(
èè$ %
int
èè% (
index
èè) .
)
èè. /
{
êê 	
	unchecked
ëë 
{
íí 
return
ìì 
(
ìì 
uint
ìì 
)
ìì 
this
ìì !
.
ìì! "
GetIntLE
ìì" *
(
ìì* +
index
ìì+ 0
)
ìì0 1
;
ìì1 2
}
îî 
}
ïï 	
public
óó 
virtual
óó 
long
óó 
GetLong
óó #
(
óó# $
int
óó$ '
index
óó( -
)
óó- .
{
òò 	
this
ôô 
.
ôô 

CheckIndex
ôô 
(
ôô 
index
ôô !
,
ôô! "
$num
ôô# $
)
ôô$ %
;
ôô% &
return
öö 
this
öö 
.
öö 
_GetLong
öö  
(
öö  !
index
öö! &
)
öö& '
;
öö' (
}
õõ 	
	protected
ùù 
internal
ùù 
abstract
ùù #
long
ùù$ (
_GetLong
ùù) 1
(
ùù1 2
int
ùù2 5
index
ùù6 ;
)
ùù; <
;
ùù< =
public
üü 
virtual
üü 
long
üü 
	GetLongLE
üü %
(
üü% &
int
üü& )
index
üü* /
)
üü/ 0
{
†† 	
this
°° 
.
°° 

CheckIndex
°° 
(
°° 
index
°° !
,
°°! "
$num
°°# $
)
°°$ %
;
°°% &
return
¢¢ 
this
¢¢ 
.
¢¢ 

_GetLongLE
¢¢ "
(
¢¢" #
index
¢¢# (
)
¢¢( )
;
¢¢) *
}
££ 	
	protected
•• 
internal
•• 
abstract
•• #
long
••$ (

_GetLongLE
••) 3
(
••3 4
int
••4 7
index
••8 =
)
••= >
;
••> ?
public
ßß 
virtual
ßß 
char
ßß 
GetChar
ßß #
(
ßß# $
int
ßß$ '
index
ßß( -
)
ßß- .
=>
ßß/ 1
Convert
ßß2 9
.
ßß9 :
ToChar
ßß: @
(
ßß@ A
this
ßßA E
.
ßßE F
GetShort
ßßF N
(
ßßN O
index
ßßO T
)
ßßT U
)
ßßU V
;
ßßV W
public
©© 
float
©© 
GetFloat
©© 
(
©© 
int
©© !
index
©©" '
)
©©' (
=>
©©) +
ByteBufferUtil
©©, :
.
©©: ;
Int32BitsToSingle
©©; L
(
©©L M
this
©©M Q
.
©©Q R
GetInt
©©R X
(
©©X Y
index
©©Y ^
)
©©^ _
)
©©_ `
;
©©` a
public
´´ 
float
´´ 

GetFloatLE
´´ 
(
´´  
int
´´  #
index
´´$ )
)
´´) *
=>
´´+ -
ByteBufferUtil
´´. <
.
´´< =
Int32BitsToSingle
´´= N
(
´´N O
this
´´O S
.
´´S T
GetIntLE
´´T \
(
´´\ ]
index
´´] b
)
´´b c
)
´´c d
;
´´d e
public
≠≠ 
double
≠≠ 
	GetDouble
≠≠ 
(
≠≠  
int
≠≠  #
index
≠≠$ )
)
≠≠) *
=>
≠≠+ -
BitConverter
≠≠. :
.
≠≠: ;
Int64BitsToDouble
≠≠; L
(
≠≠L M
this
≠≠M Q
.
≠≠Q R
GetLong
≠≠R Y
(
≠≠Y Z
index
≠≠Z _
)
≠≠_ `
)
≠≠` a
;
≠≠a b
public
ØØ 
double
ØØ 
GetDoubleLE
ØØ !
(
ØØ! "
int
ØØ" %
index
ØØ& +
)
ØØ+ ,
=>
ØØ- /
BitConverter
ØØ0 <
.
ØØ< =
Int64BitsToDouble
ØØ= N
(
ØØN O
this
ØØO S
.
ØØS T
	GetLongLE
ØØT ]
(
ØØ] ^
index
ØØ^ c
)
ØØc d
)
ØØd e
;
ØØe f
public
±± 
virtual
±± 
IByteBuffer
±± "
GetBytes
±±# +
(
±±+ ,
int
±±, /
index
±±0 5
,
±±5 6
byte
±±7 ;
[
±±; <
]
±±< =
destination
±±> I
)
±±I J
{
≤≤ 	
this
≥≥ 
.
≥≥ 
GetBytes
≥≥ 
(
≥≥ 
index
≥≥ 
,
≥≥  
destination
≥≥! ,
,
≥≥, -
$num
≥≥. /
,
≥≥/ 0
destination
≥≥1 <
.
≥≥< =
Length
≥≥= C
)
≥≥C D
;
≥≥D E
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
abstract
∑∑ 
IByteBuffer
∑∑ #
GetBytes
∑∑$ ,
(
∑∑, -
int
∑∑- 0
index
∑∑1 6
,
∑∑6 7
byte
∑∑8 <
[
∑∑< =
]
∑∑= >
destination
∑∑? J
,
∑∑J K
int
∑∑L O
dstIndex
∑∑P X
,
∑∑X Y
int
∑∑Z ]
length
∑∑^ d
)
∑∑d e
;
∑∑e f
public
ππ 
virtual
ππ 
IByteBuffer
ππ "
GetBytes
ππ# +
(
ππ+ ,
int
ππ, /
index
ππ0 5
,
ππ5 6
IByteBuffer
ππ7 B
destination
ππC N
)
ππN O
{
∫∫ 	
this
ªª 
.
ªª 
GetBytes
ªª 
(
ªª 
index
ªª 
,
ªª  
destination
ªª! ,
,
ªª, -
destination
ªª. 9
.
ªª9 :
WritableBytes
ªª: G
)
ªªG H
;
ªªH I
return
ºº 
this
ºº 
;
ºº 
}
ΩΩ 	
public
øø 
virtual
øø 
IByteBuffer
øø "
GetBytes
øø# +
(
øø+ ,
int
øø, /
index
øø0 5
,
øø5 6
IByteBuffer
øø7 B
destination
øøC N
,
øøN O
int
øøP S
length
øøT Z
)
øøZ [
{
¿¿ 	
this
¡¡ 
.
¡¡ 
GetBytes
¡¡ 
(
¡¡ 
index
¡¡ 
,
¡¡  
destination
¡¡! ,
,
¡¡, -
destination
¡¡. 9
.
¡¡9 :
WriterIndex
¡¡: E
,
¡¡E F
length
¡¡G M
)
¡¡M N
;
¡¡N O
destination
¬¬ 
.
¬¬ 
SetWriterIndex
¬¬ &
(
¬¬& '
destination
¬¬' 2
.
¬¬2 3
WriterIndex
¬¬3 >
+
¬¬? @
length
¬¬A G
)
¬¬G H
;
¬¬H I
return
√√ 
this
√√ 
;
√√ 
}
ƒƒ 	
public
∆∆ 
abstract
∆∆ 
IByteBuffer
∆∆ #
GetBytes
∆∆$ ,
(
∆∆, -
int
∆∆- 0
index
∆∆1 6
,
∆∆6 7
IByteBuffer
∆∆8 C
destination
∆∆D O
,
∆∆O P
int
∆∆Q T
dstIndex
∆∆U ]
,
∆∆] ^
int
∆∆_ b
length
∆∆c i
)
∆∆i j
;
∆∆j k
public
»» 
abstract
»» 
IByteBuffer
»» #
GetBytes
»»$ ,
(
»», -
int
»»- 0
index
»»1 6
,
»»6 7
Stream
»»8 >
destination
»»? J
,
»»J K
int
»»L O
length
»»P V
)
»»V W
;
»»W X
public
   
virtual
   
unsafe
   
string
   $
	GetString
  % .
(
  . /
int
  / 2
index
  3 8
,
  8 9
int
  : =
length
  > D
,
  D E
Encoding
  F N
encoding
  O W
)
  W X
{
ÀÀ 	
this
ÃÃ 
.
ÃÃ 
CheckIndex0
ÃÃ 
(
ÃÃ 
index
ÃÃ "
,
ÃÃ" #
length
ÃÃ$ *
)
ÃÃ* +
;
ÃÃ+ ,
if
ÕÕ 
(
ÕÕ 
length
ÕÕ 
==
ÕÕ 
$num
ÕÕ 
)
ÕÕ 
{
ŒŒ 
return
œœ 
string
œœ 
.
œœ 
Empty
œœ #
;
œœ# $
}
–– 
if
““ 
(
““ 
this
““ 
.
““ 
HasMemoryAddress
““ %
)
““% &
{
”” 
IntPtr
‘‘ 
ptr
‘‘ 
=
‘‘ 
this
‘‘ !
.
‘‘! "#
AddressOfPinnedMemory
‘‘" 7
(
‘‘7 8
)
‘‘8 9
;
‘‘9 :
if
’’ 
(
’’ 
ptr
’’ 
!=
’’ 
IntPtr
’’ !
.
’’! "
Zero
’’" &
)
’’& '
{
÷÷ 
return
◊◊ "
UnsafeByteBufferUtil
◊◊ /
.
◊◊/ 0
	GetString
◊◊0 9
(
◊◊9 :
(
◊◊: ;
byte
◊◊; ?
*
◊◊? @
)
◊◊@ A
(
◊◊A B
ptr
◊◊B E
+
◊◊F G
index
◊◊H M
)
◊◊M N
,
◊◊N O
length
◊◊P V
,
◊◊V W
encoding
◊◊X `
)
◊◊` a
;
◊◊a b
}
ÿÿ 
else
ŸŸ 
{
⁄⁄ 
fixed
€€ 
(
€€ 
byte
€€ 
*
€€  
p
€€! "
=
€€# $
&
€€% &
this
€€& *
.
€€* +&
GetPinnableMemoryAddress
€€+ C
(
€€C D
)
€€D E
)
€€E F
return
‹‹ "
UnsafeByteBufferUtil
‹‹ 3
.
‹‹3 4
	GetString
‹‹4 =
(
‹‹= >
p
‹‹> ?
+
‹‹@ A
index
‹‹B G
,
‹‹G H
length
‹‹I O
,
‹‹O P
encoding
‹‹Q Y
)
‹‹Y Z
;
‹‹Z [
}
›› 
}
ﬁﬁ 
if
ﬂﬂ 
(
ﬂﬂ 
this
ﬂﬂ 
.
ﬂﬂ 
HasArray
ﬂﬂ 
)
ﬂﬂ 
{
‡‡ 
return
·· 
encoding
·· 
.
··  
	GetString
··  )
(
··) *
this
··* .
.
··. /
Array
··/ 4
,
··4 5
this
··6 :
.
··: ;
ArrayOffset
··; F
+
··G H
index
··I N
,
··N O
length
··P V
)
··V W
;
··W X
}
‚‚ 
return
‰‰ 
this
‰‰ 
.
‰‰ 
ToString
‰‰  
(
‰‰  !
index
‰‰! &
,
‰‰& '
length
‰‰( .
,
‰‰. /
encoding
‰‰0 8
)
‰‰8 9
;
‰‰9 :
}
ÂÂ 	
public
ÁÁ 
virtual
ÁÁ 
string
ÁÁ 

ReadString
ÁÁ (
(
ÁÁ( )
int
ÁÁ) ,
length
ÁÁ- 3
,
ÁÁ3 4
Encoding
ÁÁ5 =
encoding
ÁÁ> F
)
ÁÁF G
{
ËË 	
string
ÈÈ 
value
ÈÈ 
=
ÈÈ 
this
ÈÈ 
.
ÈÈ  
	GetString
ÈÈ  )
(
ÈÈ) *
this
ÈÈ* .
.
ÈÈ. /
readerIndex
ÈÈ/ :
,
ÈÈ: ;
length
ÈÈ< B
,
ÈÈB C
encoding
ÈÈD L
)
ÈÈL M
;
ÈÈM N
this
ÍÍ 
.
ÍÍ 
readerIndex
ÍÍ 
+=
ÍÍ 
length
ÍÍ  &
;
ÍÍ& '
return
ÎÎ 
value
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÓÓ 
virtual
ÓÓ 
unsafe
ÓÓ 
ICharSequence
ÓÓ +
GetCharSequence
ÓÓ, ;
(
ÓÓ; <
int
ÓÓ< ?
index
ÓÓ@ E
,
ÓÓE F
int
ÓÓG J
length
ÓÓK Q
,
ÓÓQ R
Encoding
ÓÓS [
encoding
ÓÓ\ d
)
ÓÓd e
{
ÔÔ 	
this
 
.
 
CheckIndex0
 
(
 
index
 "
,
" #
length
$ *
)
* +
;
+ ,
if
ÒÒ 
(
ÒÒ 
length
ÒÒ 
==
ÒÒ 
$num
ÒÒ 
)
ÒÒ 
{
ÚÚ 
return
ÛÛ  
StringCharSequence
ÛÛ )
.
ÛÛ) *
Empty
ÛÛ* /
;
ÛÛ/ 0
}
ÙÙ 
if
ˆˆ 
(
ˆˆ 
this
ˆˆ 
.
ˆˆ 
HasMemoryAddress
ˆˆ %
)
ˆˆ% &
{
˜˜ 
IntPtr
¯¯ 
ptr
¯¯ 
=
¯¯ 
this
¯¯ !
.
¯¯! "#
AddressOfPinnedMemory
¯¯" 7
(
¯¯7 8
)
¯¯8 9
;
¯¯9 :
if
˘˘ 
(
˘˘ 
ptr
˘˘ 
!=
˘˘ 
IntPtr
˘˘ !
.
˘˘! "
Zero
˘˘" &
)
˘˘& '
{
˙˙ 
return
˚˚ 
new
˚˚  
StringCharSequence
˚˚ 1
(
˚˚1 2"
UnsafeByteBufferUtil
˚˚2 F
.
˚˚F G
	GetString
˚˚G P
(
˚˚P Q
(
˚˚Q R
byte
˚˚R V
*
˚˚V W
)
˚˚W X
(
˚˚X Y
ptr
˚˚Y \
+
˚˚] ^
index
˚˚_ d
)
˚˚d e
,
˚˚e f
length
˚˚g m
,
˚˚m n
encoding
˚˚o w
)
˚˚w x
)
˚˚x y
;
˚˚y z
}
¸¸ 
else
˝˝ 
{
˛˛ 
fixed
ˇˇ 
(
ˇˇ 
byte
ˇˇ 
*
ˇˇ  
p
ˇˇ! "
=
ˇˇ# $
&
ˇˇ% &
this
ˇˇ& *
.
ˇˇ* +&
GetPinnableMemoryAddress
ˇˇ+ C
(
ˇˇC D
)
ˇˇD E
)
ˇˇE F
return
ÄÄ 
new
ÄÄ " 
StringCharSequence
ÄÄ# 5
(
ÄÄ5 6"
UnsafeByteBufferUtil
ÄÄ6 J
.
ÄÄJ K
	GetString
ÄÄK T
(
ÄÄT U
p
ÄÄU V
+
ÄÄW X
index
ÄÄY ^
,
ÄÄ^ _
length
ÄÄ` f
,
ÄÄf g
encoding
ÄÄh p
)
ÄÄp q
)
ÄÄq r
;
ÄÄr s
}
ÅÅ 
}
ÇÇ 
if
ÉÉ 
(
ÉÉ 
this
ÉÉ 
.
ÉÉ 
HasArray
ÉÉ 
)
ÉÉ 
{
ÑÑ 
return
ÖÖ 
new
ÖÖ  
StringCharSequence
ÖÖ -
(
ÖÖ- .
encoding
ÖÖ. 6
.
ÖÖ6 7
	GetString
ÖÖ7 @
(
ÖÖ@ A
this
ÖÖA E
.
ÖÖE F
Array
ÖÖF K
,
ÖÖK L
this
ÖÖM Q
.
ÖÖQ R
ArrayOffset
ÖÖR ]
+
ÖÖ^ _
index
ÖÖ` e
,
ÖÖe f
length
ÖÖg m
)
ÖÖm n
)
ÖÖn o
;
ÖÖo p
}
ÜÜ 
return
àà 
new
àà  
StringCharSequence
àà )
(
àà) *
this
àà* .
.
àà. /
ToString
àà/ 7
(
àà7 8
index
àà8 =
,
àà= >
length
àà? E
,
ààE F
encoding
ààG O
)
ààO P
)
ààP Q
;
ààQ R
}
ââ 	
public
ãã 
virtual
ãã 
ICharSequence
ãã $
ReadCharSequence
ãã% 5
(
ãã5 6
int
ãã6 9
length
ãã: @
,
ãã@ A
Encoding
ããB J
encoding
ããK S
)
ããS T
{
åå 	
ICharSequence
çç 
sequence
çç "
=
çç# $
this
çç% )
.
çç) *
GetCharSequence
çç* 9
(
çç9 :
this
çç: >
.
çç> ?
readerIndex
çç? J
,
ççJ K
length
ççL R
,
ççR S
encoding
ççT \
)
çç\ ]
;
çç] ^
this
éé 
.
éé 
readerIndex
éé 
+=
éé 
length
éé  &
;
éé& '
return
èè 
sequence
èè 
;
èè 
}
êê 	
public
íí 
virtual
íí 
IByteBuffer
íí "
SetByte
íí# *
(
íí* +
int
íí+ .
index
íí/ 4
,
íí4 5
int
íí6 9
value
íí: ?
)
íí? @
{
ìì 	
this
îî 
.
îî 

CheckIndex
îî 
(
îî 
index
îî !
)
îî! "
;
îî" #
this
ïï 
.
ïï 
_SetByte
ïï 
(
ïï 
index
ïï 
,
ïï  
value
ïï! &
)
ïï& '
;
ïï' (
return
ññ 
this
ññ 
;
ññ 
}
óó 	
	protected
ôô 
internal
ôô 
abstract
ôô #
void
ôô$ (
_SetByte
ôô) 1
(
ôô1 2
int
ôô2 5
index
ôô6 ;
,
ôô; <
int
ôô= @
value
ôôA F
)
ôôF G
;
ôôG H
public
õõ 
virtual
õõ 
IByteBuffer
õõ "

SetBoolean
õõ# -
(
õõ- .
int
õõ. 1
index
õõ2 7
,
õõ7 8
bool
õõ9 =
value
õõ> C
)
õõC D
{
úú 	
this
ùù 
.
ùù 
SetByte
ùù 
(
ùù 
index
ùù 
,
ùù 
value
ùù  %
?
ùù& '
$num
ùù( )
:
ùù* +
$num
ùù, -
)
ùù- .
;
ùù. /
return
ûû 
this
ûû 
;
ûû 
}
üü 	
public
°° 
virtual
°° 
IByteBuffer
°° "
SetShort
°°# +
(
°°+ ,
int
°°, /
index
°°0 5
,
°°5 6
int
°°7 :
value
°°; @
)
°°@ A
{
¢¢ 	
this
££ 
.
££ 

CheckIndex
££ 
(
££ 
index
££ !
,
££! "
$num
££# $
)
££$ %
;
££% &
this
§§ 
.
§§ 
	_SetShort
§§ 
(
§§ 
index
§§  
,
§§  !
value
§§" '
)
§§' (
;
§§( )
return
•• 
this
•• 
;
•• 
}
¶¶ 	
	protected
®® 
internal
®® 
abstract
®® #
void
®®$ (
	_SetShort
®®) 2
(
®®2 3
int
®®3 6
index
®®7 <
,
®®< =
int
®®> A
value
®®B G
)
®®G H
;
®®H I
public
™™ 
virtual
™™ 
IByteBuffer
™™ "

SetShortLE
™™# -
(
™™- .
int
™™. 1
index
™™2 7
,
™™7 8
int
™™9 <
value
™™= B
)
™™B C
{
´´ 	
this
¨¨ 
.
¨¨ 

CheckIndex
¨¨ 
(
¨¨ 
index
¨¨ !
,
¨¨! "
$num
¨¨# $
)
¨¨$ %
;
¨¨% &
this
≠≠ 
.
≠≠ 
_SetShortLE
≠≠ 
(
≠≠ 
index
≠≠ "
,
≠≠" #
value
≠≠$ )
)
≠≠) *
;
≠≠* +
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ØØ 	
	protected
±± 
internal
±± 
abstract
±± #
void
±±$ (
_SetShortLE
±±) 4
(
±±4 5
int
±±5 8
index
±±9 >
,
±±> ?
int
±±@ C
value
±±D I
)
±±I J
;
±±J K
public
≥≥ 
IByteBuffer
≥≥ 
SetUnsignedShort
≥≥ +
(
≥≥+ ,
int
≥≥, /
index
≥≥0 5
,
≥≥5 6
ushort
≥≥7 =
value
≥≥> C
)
≥≥C D
{
¥¥ 	
	unchecked
µµ 
{
∂∂ 
return
∑∑ 
this
∑∑ 
.
∑∑ 
SetShort
∑∑ $
(
∑∑$ %
index
∑∑% *
,
∑∑* +
(
∑∑, -
short
∑∑- 2
)
∑∑2 3
value
∑∑3 8
)
∑∑8 9
;
∑∑9 :
}
∏∏ 
}
ππ 	
public
ªª 
IByteBuffer
ªª  
SetUnsignedShortLE
ªª -
(
ªª- .
int
ªª. 1
index
ªª2 7
,
ªª7 8
ushort
ªª9 ?
value
ªª@ E
)
ªªE F
{
ºº 	
	unchecked
ΩΩ 
{
ææ 
return
øø 
this
øø 
.
øø 

SetShortLE
øø &
(
øø& '
index
øø' ,
,
øø, -
(
øø. /
short
øø/ 4
)
øø4 5
value
øø5 :
)
øø: ;
;
øø; <
}
¿¿ 
}
¡¡ 	
public
√√ 
virtual
√√ 
IByteBuffer
√√ "
SetChar
√√# *
(
√√* +
int
√√+ .
index
√√/ 4
,
√√4 5
char
√√6 :
value
√√; @
)
√√@ A
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
SetShort
≈≈ 
(
≈≈ 
index
≈≈ 
,
≈≈  
value
≈≈! &
)
≈≈& '
;
≈≈' (
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
virtual
…… 
IByteBuffer
…… "
	SetMedium
……# ,
(
……, -
int
……- 0
index
……1 6
,
……6 7
int
……8 ;
value
……< A
)
……A B
{
   	
this
ÀÀ 
.
ÀÀ 

CheckIndex
ÀÀ 
(
ÀÀ 
index
ÀÀ !
,
ÀÀ! "
$num
ÀÀ# $
)
ÀÀ$ %
;
ÀÀ% &
this
ÃÃ 
.
ÃÃ 

_SetMedium
ÃÃ 
(
ÃÃ 
index
ÃÃ !
,
ÃÃ! "
value
ÃÃ# (
)
ÃÃ( )
;
ÃÃ) *
return
ÕÕ 
this
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
	protected
–– 
internal
–– 
abstract
–– #
void
––$ (

_SetMedium
––) 3
(
––3 4
int
––4 7
index
––8 =
,
––= >
int
––? B
value
––C H
)
––H I
;
––I J
public
““ 
virtual
““ 
IByteBuffer
““ "
SetMediumLE
““# .
(
““. /
int
““/ 2
index
““3 8
,
““8 9
int
““: =
value
““> C
)
““C D
{
”” 	
this
‘‘ 
.
‘‘ 

CheckIndex
‘‘ 
(
‘‘ 
index
‘‘ !
,
‘‘! "
$num
‘‘# $
)
‘‘$ %
;
‘‘% &
this
’’ 
.
’’ 
_SetMediumLE
’’ 
(
’’ 
index
’’ #
,
’’# $
value
’’% *
)
’’* +
;
’’+ ,
return
÷÷ 
this
÷÷ 
;
÷÷ 
}
◊◊ 	
	protected
ŸŸ 
internal
ŸŸ 
abstract
ŸŸ #
void
ŸŸ$ (
_SetMediumLE
ŸŸ) 5
(
ŸŸ5 6
int
ŸŸ6 9
index
ŸŸ: ?
,
ŸŸ? @
int
ŸŸA D
value
ŸŸE J
)
ŸŸJ K
;
ŸŸK L
public
€€ 
virtual
€€ 
IByteBuffer
€€ "
SetInt
€€# )
(
€€) *
int
€€* -
index
€€. 3
,
€€3 4
int
€€5 8
value
€€9 >
)
€€> ?
{
‹‹ 	
this
›› 
.
›› 

CheckIndex
›› 
(
›› 
index
›› !
,
››! "
$num
››# $
)
››$ %
;
››% &
this
ﬁﬁ 
.
ﬁﬁ 
_SetInt
ﬁﬁ 
(
ﬁﬁ 
index
ﬁﬁ 
,
ﬁﬁ 
value
ﬁﬁ  %
)
ﬁﬁ% &
;
ﬁﬁ& '
return
ﬂﬂ 
this
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
public
‚‚ 
IByteBuffer
‚‚ 
SetUnsignedInt
‚‚ )
(
‚‚) *
int
‚‚* -
index
‚‚. 3
,
‚‚3 4
uint
‚‚5 9
value
‚‚: ?
)
‚‚? @
{
„„ 	
	unchecked
‰‰ 
{
ÂÂ 
return
ÊÊ 
this
ÊÊ 
.
ÊÊ 
SetInt
ÊÊ "
(
ÊÊ" #
index
ÊÊ# (
,
ÊÊ( )
(
ÊÊ* +
int
ÊÊ+ .
)
ÊÊ. /
value
ÊÊ/ 4
)
ÊÊ4 5
;
ÊÊ5 6
}
ÁÁ 
}
ËË 	
public
ÍÍ 
IByteBuffer
ÍÍ 
SetUnsignedIntLE
ÍÍ +
(
ÍÍ+ ,
int
ÍÍ, /
index
ÍÍ0 5
,
ÍÍ5 6
uint
ÍÍ7 ;
value
ÍÍ< A
)
ÍÍA B
{
ÎÎ 	
	unchecked
ÏÏ 
{
ÌÌ 
return
ÓÓ 
this
ÓÓ 
.
ÓÓ 
SetIntLE
ÓÓ $
(
ÓÓ$ %
index
ÓÓ% *
,
ÓÓ* +
(
ÓÓ, -
int
ÓÓ- 0
)
ÓÓ0 1
value
ÓÓ1 6
)
ÓÓ6 7
;
ÓÓ7 8
}
ÔÔ 
}
 	
	protected
ÚÚ 
internal
ÚÚ 
abstract
ÚÚ #
void
ÚÚ$ (
_SetInt
ÚÚ) 0
(
ÚÚ0 1
int
ÚÚ1 4
index
ÚÚ5 :
,
ÚÚ: ;
int
ÚÚ< ?
value
ÚÚ@ E
)
ÚÚE F
;
ÚÚF G
public
ÙÙ 
virtual
ÙÙ 
IByteBuffer
ÙÙ "
SetIntLE
ÙÙ# +
(
ÙÙ+ ,
int
ÙÙ, /
index
ÙÙ0 5
,
ÙÙ5 6
int
ÙÙ7 :
value
ÙÙ; @
)
ÙÙ@ A
{
ıı 	
this
ˆˆ 
.
ˆˆ 

CheckIndex
ˆˆ 
(
ˆˆ 
index
ˆˆ !
,
ˆˆ! "
$num
ˆˆ# $
)
ˆˆ$ %
;
ˆˆ% &
this
˜˜ 
.
˜˜ 
	_SetIntLE
˜˜ 
(
˜˜ 
index
˜˜  
,
˜˜  !
value
˜˜" '
)
˜˜' (
;
˜˜( )
return
¯¯ 
this
¯¯ 
;
¯¯ 
}
˘˘ 	
	protected
˚˚ 
internal
˚˚ 
abstract
˚˚ #
void
˚˚$ (
	_SetIntLE
˚˚) 2
(
˚˚2 3
int
˚˚3 6
index
˚˚7 <
,
˚˚< =
int
˚˚> A
value
˚˚B G
)
˚˚G H
;
˚˚H I
public
˝˝ 
virtual
˝˝ 
IByteBuffer
˝˝ "
SetFloat
˝˝# +
(
˝˝+ ,
int
˝˝, /
index
˝˝0 5
,
˝˝5 6
float
˝˝7 <
value
˝˝= B
)
˝˝B C
{
˛˛ 	
this
ˇˇ 
.
ˇˇ 
SetInt
ˇˇ 
(
ˇˇ 
index
ˇˇ 
,
ˇˇ 
ByteBufferUtil
ˇˇ -
.
ˇˇ- .
SingleToInt32Bits
ˇˇ. ?
(
ˇˇ? @
value
ˇˇ@ E
)
ˇˇE F
)
ˇˇF G
;
ˇˇG H
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
IByteBuffer
ÉÉ 

SetFloatLE
ÉÉ %
(
ÉÉ% &
int
ÉÉ& )
index
ÉÉ* /
,
ÉÉ/ 0
float
ÉÉ1 6
value
ÉÉ7 <
)
ÉÉ< =
=>
ÉÉ> @
this
ÉÉA E
.
ÉÉE F
SetIntLE
ÉÉF N
(
ÉÉN O
index
ÉÉO T
,
ÉÉT U
ByteBufferUtil
ÉÉV d
.
ÉÉd e
SingleToInt32Bits
ÉÉe v
(
ÉÉv w
value
ÉÉw |
)
ÉÉ| }
)
ÉÉ} ~
;
ÉÉ~ 
public
ÖÖ 
virtual
ÖÖ 
IByteBuffer
ÖÖ "
SetLong
ÖÖ# *
(
ÖÖ* +
int
ÖÖ+ .
index
ÖÖ/ 4
,
ÖÖ4 5
long
ÖÖ6 :
value
ÖÖ; @
)
ÖÖ@ A
{
ÜÜ 	
this
áá 
.
áá 

CheckIndex
áá 
(
áá 
index
áá !
,
áá! "
$num
áá# $
)
áá$ %
;
áá% &
this
àà 
.
àà 
_SetLong
àà 
(
àà 
index
àà 
,
àà  
value
àà! &
)
àà& '
;
àà' (
return
ââ 
this
ââ 
;
ââ 
}
ää 	
	protected
åå 
internal
åå 
abstract
åå #
void
åå$ (
_SetLong
åå) 1
(
åå1 2
int
åå2 5
index
åå6 ;
,
åå; <
long
åå= A
value
ååB G
)
ååG H
;
ååH I
public
éé 
virtual
éé 
IByteBuffer
éé "
	SetLongLE
éé# ,
(
éé, -
int
éé- 0
index
éé1 6
,
éé6 7
long
éé8 <
value
éé= B
)
ééB C
{
èè 	
this
êê 
.
êê 

CheckIndex
êê 
(
êê 
index
êê !
,
êê! "
$num
êê# $
)
êê$ %
;
êê% &
this
ëë 
.
ëë 

_SetLongLE
ëë 
(
ëë 
index
ëë !
,
ëë! "
value
ëë# (
)
ëë( )
;
ëë) *
return
íí 
this
íí 
;
íí 
}
ìì 	
	protected
ïï 
internal
ïï 
abstract
ïï #
void
ïï$ (

_SetLongLE
ïï) 3
(
ïï3 4
int
ïï4 7
index
ïï8 =
,
ïï= >
long
ïï? C
value
ïïD I
)
ïïI J
;
ïïJ K
public
óó 
virtual
óó 
IByteBuffer
óó "
	SetDouble
óó# ,
(
óó, -
int
óó- 0
index
óó1 6
,
óó6 7
double
óó8 >
value
óó? D
)
óóD E
{
òò 	
this
ôô 
.
ôô 
SetLong
ôô 
(
ôô 
index
ôô 
,
ôô 
BitConverter
ôô  ,
.
ôô, -
DoubleToInt64Bits
ôô- >
(
ôô> ?
value
ôô? D
)
ôôD E
)
ôôE F
;
ôôF G
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
IByteBuffer
ùù 
SetDoubleLE
ùù &
(
ùù& '
int
ùù' *
index
ùù+ 0
,
ùù0 1
double
ùù2 8
value
ùù9 >
)
ùù> ?
=>
ùù@ B
this
ùùC G
.
ùùG H
	SetLongLE
ùùH Q
(
ùùQ R
index
ùùR W
,
ùùW X
BitConverter
ùùY e
.
ùùe f
DoubleToInt64Bits
ùùf w
(
ùùw x
value
ùùx }
)
ùù} ~
)
ùù~ 
;ùù Ä
public
üü 
virtual
üü 
IByteBuffer
üü "
SetBytes
üü# +
(
üü+ ,
int
üü, /
index
üü0 5
,
üü5 6
byte
üü7 ;
[
üü; <
]
üü< =
src
üü> A
)
üüA B
{
†† 	
this
°° 
.
°° 
SetBytes
°° 
(
°° 
index
°° 
,
°°  
src
°°! $
,
°°$ %
$num
°°& '
,
°°' (
src
°°) ,
.
°°, -
Length
°°- 3
)
°°3 4
;
°°4 5
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
abstract
•• 
IByteBuffer
•• #
SetBytes
••$ ,
(
••, -
int
••- 0
index
••1 6
,
••6 7
byte
••8 <
[
••< =
]
••= >
src
••? B
,
••B C
int
••D G
srcIndex
••H P
,
••P Q
int
••R U
length
••V \
)
••\ ]
;
••] ^
public
ßß 
virtual
ßß 
IByteBuffer
ßß "
SetBytes
ßß# +
(
ßß+ ,
int
ßß, /
index
ßß0 5
,
ßß5 6
IByteBuffer
ßß7 B
src
ßßC F
)
ßßF G
{
®® 	
this
©© 
.
©© 
SetBytes
©© 
(
©© 
index
©© 
,
©©  
src
©©! $
,
©©$ %
src
©©& )
.
©©) *
ReadableBytes
©©* 7
)
©©7 8
;
©©8 9
return
™™ 
this
™™ 
;
™™ 
}
´´ 	
public
≠≠ 
virtual
≠≠ 
IByteBuffer
≠≠ "
SetBytes
≠≠# +
(
≠≠+ ,
int
≠≠, /
index
≠≠0 5
,
≠≠5 6
IByteBuffer
≠≠7 B
src
≠≠C F
,
≠≠F G
int
≠≠H K
length
≠≠L R
)
≠≠R S
{
ÆÆ 	
Contract
ØØ 
.
ØØ 
Requires
ØØ 
(
ØØ 
src
ØØ !
!=
ØØ" $
null
ØØ% )
)
ØØ) *
;
ØØ* +
this
±± 
.
±± 

CheckIndex
±± 
(
±± 
index
±± !
,
±±! "
length
±±# )
)
±±) *
;
±±* +
if
≤≤ 
(
≤≤ 
length
≤≤ 
>
≤≤ 
src
≤≤ 
.
≤≤ 
ReadableBytes
≤≤ *
)
≤≤* +
{
≥≥ 
ThrowHelper
¥¥ 
.
¥¥ 9
+ThrowIndexOutOfRangeException_ReadableBytes
¥¥ G
(
¥¥G H
length
¥¥H N
,
¥¥N O
src
¥¥P S
)
¥¥S T
;
¥¥T U
}
µµ 
this
∂∂ 
.
∂∂ 
SetBytes
∂∂ 
(
∂∂ 
index
∂∂ 
,
∂∂  
src
∂∂! $
,
∂∂$ %
src
∂∂& )
.
∂∂) *
ReaderIndex
∂∂* 5
,
∂∂5 6
length
∂∂7 =
)
∂∂= >
;
∂∂> ?
src
∑∑ 
.
∑∑ 
SetReaderIndex
∑∑ 
(
∑∑ 
src
∑∑ "
.
∑∑" #
ReaderIndex
∑∑# .
+
∑∑/ 0
length
∑∑1 7
)
∑∑7 8
;
∑∑8 9
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
public
ªª 
abstract
ªª 
IByteBuffer
ªª #
SetBytes
ªª$ ,
(
ªª, -
int
ªª- 0
index
ªª1 6
,
ªª6 7
IByteBuffer
ªª8 C
src
ªªD G
,
ªªG H
int
ªªI L
srcIndex
ªªM U
,
ªªU V
int
ªªW Z
length
ªª[ a
)
ªªa b
;
ªªb c
public
ΩΩ 
abstract
ΩΩ 
Task
ΩΩ 
<
ΩΩ 
int
ΩΩ  
>
ΩΩ  !
SetBytesAsync
ΩΩ" /
(
ΩΩ/ 0
int
ΩΩ0 3
index
ΩΩ4 9
,
ΩΩ9 :
Stream
ΩΩ; A
src
ΩΩB E
,
ΩΩE F
int
ΩΩG J
length
ΩΩK Q
,
ΩΩQ R
CancellationToken
ΩΩS d
cancellationToken
ΩΩe v
)
ΩΩv w
;
ΩΩw x
public
øø 
virtual
øø 
IByteBuffer
øø "
SetZero
øø# *
(
øø* +
int
øø+ .
index
øø/ 4
,
øø4 5
int
øø6 9
length
øø: @
)
øø@ A
{
¿¿ 	
if
¡¡ 
(
¡¡ 
length
¡¡ 
==
¡¡ 
$num
¡¡ 
)
¡¡ 
{
¬¬ 
return
√√ 
this
√√ 
;
√√ 
}
ƒƒ 
this
∆∆ 
.
∆∆ 

CheckIndex
∆∆ 
(
∆∆ 
index
∆∆ !
,
∆∆! "
length
∆∆# )
)
∆∆) *
;
∆∆* +
int
»» 
nLong
»» 
=
»» 
length
»» 
.
»» 
RightUShift
»» *
(
»»* +
$num
»»+ ,
)
»», -
;
»»- .
int
…… 
nBytes
…… 
=
…… 
length
…… 
&
……  !
$num
……" #
;
……# $
for
   
(
   
int
   
i
   
=
   
nLong
   
;
   
i
    !
>
  " #
$num
  $ %
;
  % &
i
  ' (
--
  ( *
)
  * +
{
ÀÀ 
this
ÃÃ 
.
ÃÃ 
_SetLong
ÃÃ 
(
ÃÃ 
index
ÃÃ #
,
ÃÃ# $
$num
ÃÃ% &
)
ÃÃ& '
;
ÃÃ' (
index
ÕÕ 
+=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
}
ŒŒ 
if
œœ 
(
œœ 
nBytes
œœ 
==
œœ 
$num
œœ 
)
œœ 
{
–– 
this
—— 
.
—— 
_SetInt
—— 
(
—— 
index
—— "
,
——" #
$num
——$ %
)
——% &
;
——& '
}
”” 
else
‘‘ 
if
‘‘ 
(
‘‘ 
nBytes
‘‘ 
<
‘‘ 
$num
‘‘ 
)
‘‘  
{
’’ 
for
÷÷ 
(
÷÷ 
int
÷÷ 
i
÷÷ 
=
÷÷ 
nBytes
÷÷ #
;
÷÷# $
i
÷÷% &
>
÷÷' (
$num
÷÷) *
;
÷÷* +
i
÷÷, -
--
÷÷- /
)
÷÷/ 0
{
◊◊ 
this
ÿÿ 
.
ÿÿ 
_SetByte
ÿÿ !
(
ÿÿ! "
index
ÿÿ" '
,
ÿÿ' (
$num
ÿÿ) *
)
ÿÿ* +
;
ÿÿ+ ,
index
ŸŸ 
++
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
}
€€ 
else
‹‹ 
{
›› 
this
ﬁﬁ 
.
ﬁﬁ 
_SetInt
ﬁﬁ 
(
ﬁﬁ 
index
ﬁﬁ "
,
ﬁﬁ" #
$num
ﬁﬁ$ %
)
ﬁﬁ% &
;
ﬁﬁ& '
index
ﬂﬂ 
+=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
for
‡‡ 
(
‡‡ 
int
‡‡ 
i
‡‡ 
=
‡‡ 
nBytes
‡‡ #
-
‡‡$ %
$num
‡‡& '
;
‡‡' (
i
‡‡) *
>
‡‡+ ,
$num
‡‡- .
;
‡‡. /
i
‡‡0 1
--
‡‡1 3
)
‡‡3 4
{
·· 
this
‚‚ 
.
‚‚ 
_SetByte
‚‚ !
(
‚‚! "
index
‚‚" '
,
‚‚' (
$num
‚‚) *
)
‚‚* +
;
‚‚+ ,
index
„„ 
++
„„ 
;
„„ 
}
‰‰ 
}
ÂÂ 
return
ÁÁ 
this
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÍÍ 
virtual
ÍÍ 
int
ÍÍ 
	SetString
ÍÍ $
(
ÍÍ$ %
int
ÍÍ% (
index
ÍÍ) .
,
ÍÍ. /
string
ÍÍ0 6
value
ÍÍ7 <
,
ÍÍ< =
Encoding
ÍÍ> F
encoding
ÍÍG O
)
ÍÍO P
=>
ÍÍQ S
this
ÍÍT X
.
ÍÍX Y

SetString0
ÍÍY c
(
ÍÍc d
index
ÍÍd i
,
ÍÍi j
value
ÍÍk p
,
ÍÍp q
encoding
ÍÍr z
,
ÍÍz {
falseÍÍ| Å
)ÍÍÅ Ç
;ÍÍÇ É
int
ÏÏ 

SetString0
ÏÏ 
(
ÏÏ 
int
ÏÏ 
index
ÏÏ  
,
ÏÏ  !
string
ÏÏ" (
value
ÏÏ) .
,
ÏÏ. /
Encoding
ÏÏ0 8
encoding
ÏÏ9 A
,
ÏÏA B
bool
ÏÏC G
expand
ÏÏH N
)
ÏÏN O
{
ÌÌ 	
if
ÓÓ 
(
ÓÓ 
ReferenceEquals
ÓÓ 
(
ÓÓ  
encoding
ÓÓ  (
,
ÓÓ( )
Encoding
ÓÓ* 2
.
ÓÓ2 3
UTF8
ÓÓ3 7
)
ÓÓ7 8
)
ÓÓ8 9
{
ÔÔ 
int
 
length
 
=
 
ByteBufferUtil
 +
.
+ ,
Utf8MaxBytes
, 8
(
8 9
value
9 >
)
> ?
;
? @
if
ÒÒ 
(
ÒÒ 
expand
ÒÒ 
)
ÒÒ 
{
ÚÚ 
this
ÛÛ 
.
ÛÛ 
EnsureWritable0
ÛÛ (
(
ÛÛ( )
length
ÛÛ) /
)
ÛÛ/ 0
;
ÛÛ0 1
this
ÙÙ 
.
ÙÙ 
CheckIndex0
ÙÙ $
(
ÙÙ$ %
index
ÙÙ% *
,
ÙÙ* +
length
ÙÙ, 2
)
ÙÙ2 3
;
ÙÙ3 4
}
ıı 
else
ˆˆ 
{
˜˜ 
this
¯¯ 
.
¯¯ 

CheckIndex
¯¯ #
(
¯¯# $
index
¯¯$ )
,
¯¯) *
length
¯¯+ 1
)
¯¯1 2
;
¯¯2 3
}
˘˘ 
return
˙˙ 
ByteBufferUtil
˙˙ %
.
˙˙% &
	WriteUtf8
˙˙& /
(
˙˙/ 0
this
˙˙0 4
,
˙˙4 5
index
˙˙6 ;
,
˙˙; <
value
˙˙= B
,
˙˙B C
value
˙˙D I
.
˙˙I J
Length
˙˙J P
)
˙˙P Q
;
˙˙Q R
}
˚˚ 
if
¸¸ 
(
¸¸ 
ReferenceEquals
¸¸ 
(
¸¸  
encoding
¸¸  (
,
¸¸( )
Encoding
¸¸* 2
.
¸¸2 3
ASCII
¸¸3 8
)
¸¸8 9
)
¸¸9 :
{
˝˝ 
int
˛˛ 
length
˛˛ 
=
˛˛ 
value
˛˛ "
.
˛˛" #
Length
˛˛# )
;
˛˛) *
if
ˇˇ 
(
ˇˇ 
expand
ˇˇ 
)
ˇˇ 
{
ÄÄ 
this
ÅÅ 
.
ÅÅ 
EnsureWritable0
ÅÅ (
(
ÅÅ( )
length
ÅÅ) /
)
ÅÅ/ 0
;
ÅÅ0 1
this
ÇÇ 
.
ÇÇ 
CheckIndex0
ÇÇ $
(
ÇÇ$ %
index
ÇÇ% *
,
ÇÇ* +
length
ÇÇ, 2
)
ÇÇ2 3
;
ÇÇ3 4
}
ÉÉ 
else
ÑÑ 
{
ÖÖ 
this
ÜÜ 
.
ÜÜ 

CheckIndex
ÜÜ #
(
ÜÜ# $
index
ÜÜ$ )
,
ÜÜ) *
length
ÜÜ+ 1
)
ÜÜ1 2
;
ÜÜ2 3
}
áá 
return
àà 
ByteBufferUtil
àà %
.
àà% &

WriteAscii
àà& 0
(
àà0 1
this
àà1 5
,
àà5 6
index
àà7 <
,
àà< =
value
àà> C
,
ààC D
length
ààE K
)
ààK L
;
ààL M
}
ââ 
byte
ää 
[
ää 
]
ää 
bytes
ää 
=
ää 
encoding
ää #
.
ää# $
GetBytes
ää$ ,
(
ää, -
value
ää- 2
)
ää2 3
;
ää3 4
if
ãã 
(
ãã 
expand
ãã 
)
ãã 
{
åå 
this
çç 
.
çç 
EnsureWritable0
çç $
(
çç$ %
bytes
çç% *
.
çç* +
Length
çç+ 1
)
çç1 2
;
çç2 3
}
èè 
this
êê 
.
êê 
SetBytes
êê 
(
êê 
index
êê 
,
êê  
bytes
êê! &
)
êê& '
;
êê' (
return
ëë 
bytes
ëë 
.
ëë 
Length
ëë 
;
ëë  
}
íí 	
public
îî 
virtual
îî 
int
îî 
SetCharSequence
îî *
(
îî* +
int
îî+ .
index
îî/ 4
,
îî4 5
ICharSequence
îî6 C
sequence
îîD L
,
îîL M
Encoding
îîN V
encoding
îîW _
)
îî_ `
=>
îîa c
this
îîd h
.
îîh i
SetCharSequence0
îîi y
(
îîy z
index
îîz 
,îî Ä
sequenceîîÅ â
,îîâ ä
encodingîîã ì
,îîì î
falseîîï ö
)îîö õ
;îîõ ú
int
ññ 
SetCharSequence0
ññ 
(
ññ 
int
ññ  
index
ññ! &
,
ññ& '
ICharSequence
ññ( 5
sequence
ññ6 >
,
ññ> ?
Encoding
ññ@ H
encoding
ññI Q
,
ññQ R
bool
ññS W
expand
ññX ^
)
ññ^ _
{
óó 	
if
òò 
(
òò 
ReferenceEquals
òò 
(
òò  
encoding
òò  (
,
òò( )
Encoding
òò* 2
.
òò2 3
UTF8
òò3 7
)
òò7 8
)
òò8 9
{
ôô 
int
öö 
length
öö 
=
öö 
ByteBufferUtil
öö +
.
öö+ ,
Utf8MaxBytes
öö, 8
(
öö8 9
sequence
öö9 A
)
ööA B
;
ööB C
if
õõ 
(
õõ 
expand
õõ 
)
õõ 
{
úú 
this
ùù 
.
ùù 
EnsureWritable0
ùù (
(
ùù( )
length
ùù) /
)
ùù/ 0
;
ùù0 1
this
ûû 
.
ûû 
CheckIndex0
ûû $
(
ûû$ %
index
ûû% *
,
ûû* +
length
ûû, 2
)
ûû2 3
;
ûû3 4
}
üü 
else
†† 
{
°° 
this
¢¢ 
.
¢¢ 

CheckIndex
¢¢ #
(
¢¢# $
index
¢¢$ )
,
¢¢) *
length
¢¢+ 1
)
¢¢1 2
;
¢¢2 3
}
££ 
return
§§ 
ByteBufferUtil
§§ %
.
§§% &
	WriteUtf8
§§& /
(
§§/ 0
this
§§0 4
,
§§4 5
index
§§6 ;
,
§§; <
sequence
§§= E
,
§§E F
sequence
§§G O
.
§§O P
Count
§§P U
)
§§U V
;
§§V W
}
•• 
if
¶¶ 
(
¶¶ 
ReferenceEquals
¶¶ 
(
¶¶  
encoding
¶¶  (
,
¶¶( )
Encoding
¶¶* 2
.
¶¶2 3
ASCII
¶¶3 8
)
¶¶8 9
)
¶¶9 :
{
ßß 
int
®® 
length
®® 
=
®® 
sequence
®® %
.
®®% &
Count
®®& +
;
®®+ ,
if
©© 
(
©© 
expand
©© 
)
©© 
{
™™ 
this
´´ 
.
´´ 
EnsureWritable0
´´ (
(
´´( )
length
´´) /
)
´´/ 0
;
´´0 1
this
¨¨ 
.
¨¨ 
CheckIndex0
¨¨ $
(
¨¨$ %
index
¨¨% *
,
¨¨* +
length
¨¨, 2
)
¨¨2 3
;
¨¨3 4
}
≠≠ 
else
ÆÆ 
{
ØØ 
this
∞∞ 
.
∞∞ 

CheckIndex
∞∞ #
(
∞∞# $
index
∞∞$ )
,
∞∞) *
length
∞∞+ 1
)
∞∞1 2
;
∞∞2 3
}
±± 
return
≤≤ 
ByteBufferUtil
≤≤ %
.
≤≤% &

WriteAscii
≤≤& 0
(
≤≤0 1
this
≤≤1 5
,
≤≤5 6
index
≤≤7 <
,
≤≤< =
sequence
≤≤> F
,
≤≤F G
length
≤≤H N
)
≤≤N O
;
≤≤O P
}
≥≥ 
byte
¥¥ 
[
¥¥ 
]
¥¥ 
bytes
¥¥ 
=
¥¥ 
encoding
¥¥ #
.
¥¥# $
GetBytes
¥¥$ ,
(
¥¥, -
sequence
¥¥- 5
.
¥¥5 6
ToString
¥¥6 >
(
¥¥> ?
)
¥¥? @
)
¥¥@ A
;
¥¥A B
if
µµ 
(
µµ 
expand
µµ 
)
µµ 
{
∂∂ 
this
∑∑ 
.
∑∑ 
EnsureWritable0
∑∑ $
(
∑∑$ %
bytes
∑∑% *
.
∑∑* +
Length
∑∑+ 1
)
∑∑1 2
;
∑∑2 3
}
ππ 
this
∫∫ 
.
∫∫ 
SetBytes
∫∫ 
(
∫∫ 
index
∫∫ 
,
∫∫  
bytes
∫∫! &
)
∫∫& '
;
∫∫' (
return
ªª 
bytes
ªª 
.
ªª 
Length
ªª 
;
ªª  
}
ºº 	
public
ææ 
virtual
ææ 
byte
ææ 
ReadByte
ææ $
(
ææ$ %
)
ææ% &
{
øø 	
this
¿¿ 
.
¿¿ !
CheckReadableBytes0
¿¿ $
(
¿¿$ %
$num
¿¿% &
)
¿¿& '
;
¿¿' (
int
¡¡ 
i
¡¡ 
=
¡¡ 
this
¡¡ 
.
¡¡ 
readerIndex
¡¡ $
;
¡¡$ %
byte
¬¬ 
b
¬¬ 
=
¬¬ 
this
¬¬ 
.
¬¬ 
_GetByte
¬¬ "
(
¬¬" #
i
¬¬# $
)
¬¬$ %
;
¬¬% &
this
√√ 
.
√√ 
readerIndex
√√ 
=
√√ 
i
√√  
+
√√! "
$num
√√# $
;
√√$ %
return
ƒƒ 
b
ƒƒ 
;
ƒƒ 
}
≈≈ 	
public
«« 
bool
«« 
ReadBoolean
«« 
(
««  
)
««  !
=>
««" $
this
««% )
.
««) *
ReadByte
««* 2
(
««2 3
)
««3 4
!=
««5 7
$num
««8 9
;
««9 :
public
…… 
virtual
…… 
short
…… 
	ReadShort
…… &
(
……& '
)
……' (
{
   	
this
ÀÀ 
.
ÀÀ !
CheckReadableBytes0
ÀÀ $
(
ÀÀ$ %
$num
ÀÀ% &
)
ÀÀ& '
;
ÀÀ' (
short
ÃÃ 
v
ÃÃ 
=
ÃÃ 
this
ÃÃ 
.
ÃÃ 
	_GetShort
ÃÃ $
(
ÃÃ$ %
this
ÃÃ% )
.
ÃÃ) *
readerIndex
ÃÃ* 5
)
ÃÃ5 6
;
ÃÃ6 7
this
ÕÕ 
.
ÕÕ 
readerIndex
ÕÕ 
+=
ÕÕ 
$num
ÕÕ  !
;
ÕÕ! "
return
ŒŒ 
v
ŒŒ 
;
ŒŒ 
}
œœ 	
public
—— 
virtual
—— 
short
—— 
ReadShortLE
—— (
(
——( )
)
——) *
{
““ 	
this
”” 
.
”” !
CheckReadableBytes0
”” $
(
””$ %
$num
””% &
)
””& '
;
””' (
short
‘‘ 
v
‘‘ 
=
‘‘ 
this
‘‘ 
.
‘‘ 
_GetShortLE
‘‘ &
(
‘‘& '
this
‘‘' +
.
‘‘+ ,
readerIndex
‘‘, 7
)
‘‘7 8
;
‘‘8 9
this
’’ 
.
’’ 
readerIndex
’’ 
+=
’’ 
$num
’’  !
;
’’! "
return
÷÷ 
v
÷÷ 
;
÷÷ 
}
◊◊ 	
public
ŸŸ 
ushort
ŸŸ 
ReadUnsignedShort
ŸŸ '
(
ŸŸ' (
)
ŸŸ( )
{
⁄⁄ 	
	unchecked
€€ 
{
‹‹ 
return
›› 
(
›› 
ushort
›› 
)
›› 
(
››  
this
››  $
.
››$ %
	ReadShort
››% .
(
››. /
)
››/ 0
)
››0 1
;
››1 2
}
ﬁﬁ 
}
ﬂﬂ 	
public
·· 
ushort
·· !
ReadUnsignedShortLE
·· )
(
··) *
)
··* +
{
‚‚ 	
	unchecked
„„ 
{
‰‰ 
return
ÂÂ 
(
ÂÂ 
ushort
ÂÂ 
)
ÂÂ 
this
ÂÂ #
.
ÂÂ# $
ReadShortLE
ÂÂ$ /
(
ÂÂ/ 0
)
ÂÂ0 1
;
ÂÂ1 2
}
ÊÊ 
}
ÁÁ 	
public
ÈÈ 
int
ÈÈ 

ReadMedium
ÈÈ 
(
ÈÈ 
)
ÈÈ 
{
ÍÍ 	
uint
ÎÎ 
value
ÎÎ 
=
ÎÎ 
(
ÎÎ 
uint
ÎÎ 
)
ÎÎ 
this
ÎÎ #
.
ÎÎ# $ 
ReadUnsignedMedium
ÎÎ$ 6
(
ÎÎ6 7
)
ÎÎ7 8
;
ÎÎ8 9
if
ÏÏ 
(
ÏÏ 
(
ÏÏ 
value
ÏÏ 
&
ÏÏ 
$num
ÏÏ !
)
ÏÏ! "
!=
ÏÏ# %
$num
ÏÏ& '
)
ÏÏ' (
{
ÌÌ 
value
ÓÓ 
|=
ÓÓ 
$num
ÓÓ #
;
ÓÓ# $
}
ÔÔ 
return
ÒÒ 
(
ÒÒ 
int
ÒÒ 
)
ÒÒ 
value
ÒÒ 
;
ÒÒ 
}
ÚÚ 	
public
ÙÙ 
int
ÙÙ 
ReadMediumLE
ÙÙ 
(
ÙÙ  
)
ÙÙ  !
{
ıı 	
uint
ˆˆ 
value
ˆˆ 
=
ˆˆ 
(
ˆˆ 
uint
ˆˆ 
)
ˆˆ 
this
ˆˆ #
.
ˆˆ# $"
ReadUnsignedMediumLE
ˆˆ$ 8
(
ˆˆ8 9
)
ˆˆ9 :
;
ˆˆ: ;
if
˜˜ 
(
˜˜ 
(
˜˜ 
value
˜˜ 
&
˜˜ 
$num
˜˜ !
)
˜˜! "
!=
˜˜# %
$num
˜˜& '
)
˜˜' (
{
¯¯ 
value
˘˘ 
|=
˘˘ 
$num
˘˘ #
;
˘˘# $
}
˙˙ 
return
¸¸ 
(
¸¸ 
int
¸¸ 
)
¸¸ 
value
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
virtual
ˇˇ 
int
ˇˇ  
ReadUnsignedMedium
ˇˇ -
(
ˇˇ- .
)
ˇˇ. /
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ !
CheckReadableBytes0
ÅÅ $
(
ÅÅ$ %
$num
ÅÅ% &
)
ÅÅ& '
;
ÅÅ' (
int
ÇÇ 
v
ÇÇ 
=
ÇÇ 
this
ÇÇ 
.
ÇÇ  
_GetUnsignedMedium
ÇÇ +
(
ÇÇ+ ,
this
ÇÇ, 0
.
ÇÇ0 1
readerIndex
ÇÇ1 <
)
ÇÇ< =
;
ÇÇ= >
this
ÉÉ 
.
ÉÉ 
readerIndex
ÉÉ 
+=
ÉÉ 
$num
ÉÉ  !
;
ÉÉ! "
return
ÑÑ 
v
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
áá 
virtual
áá 
int
áá "
ReadUnsignedMediumLE
áá /
(
áá/ 0
)
áá0 1
{
àà 	
this
ââ 
.
ââ !
CheckReadableBytes0
ââ $
(
ââ$ %
$num
ââ% &
)
ââ& '
;
ââ' (
int
ää 
v
ää 
=
ää 
this
ää 
.
ää "
_GetUnsignedMediumLE
ää -
(
ää- .
this
ää. 2
.
ää2 3
readerIndex
ää3 >
)
ää> ?
;
ää? @
this
ãã 
.
ãã 
readerIndex
ãã 
+=
ãã 
$num
ãã  !
;
ãã! "
return
åå 
v
åå 
;
åå 
}
çç 	
public
èè 
virtual
èè 
int
èè 
ReadInt
èè "
(
èè" #
)
èè# $
{
êê 	
this
ëë 
.
ëë !
CheckReadableBytes0
ëë $
(
ëë$ %
$num
ëë% &
)
ëë& '
;
ëë' (
int
íí 
v
íí 
=
íí 
this
íí 
.
íí 
_GetInt
íí  
(
íí  !
this
íí! %
.
íí% &
readerIndex
íí& 1
)
íí1 2
;
íí2 3
this
ìì 
.
ìì 
readerIndex
ìì 
+=
ìì 
$num
ìì  !
;
ìì! "
return
îî 
v
îî 
;
îî 
}
ïï 	
public
óó 
virtual
óó 
int
óó 
	ReadIntLE
óó $
(
óó$ %
)
óó% &
{
òò 	
this
ôô 
.
ôô !
CheckReadableBytes0
ôô $
(
ôô$ %
$num
ôô% &
)
ôô& '
;
ôô' (
int
öö 
v
öö 
=
öö 
this
öö 
.
öö 
	_GetIntLE
öö "
(
öö" #
this
öö# '
.
öö' (
readerIndex
öö( 3
)
öö3 4
;
öö4 5
this
õõ 
.
õõ 
readerIndex
õõ 
+=
õõ 
$num
õõ  !
;
õõ! "
return
úú 
v
úú 
;
úú 
}
ùù 	
public
üü 
uint
üü 
ReadUnsignedInt
üü #
(
üü# $
)
üü$ %
{
†† 	
	unchecked
°° 
{
¢¢ 
return
££ 
(
££ 
uint
££ 
)
££ 
(
££ 
this
££ "
.
££" #
ReadInt
££# *
(
££* +
)
££+ ,
)
££, -
;
££- .
}
§§ 
}
•• 	
public
ßß 
uint
ßß 
ReadUnsignedIntLE
ßß %
(
ßß% &
)
ßß& '
{
®® 	
	unchecked
©© 
{
™™ 
return
´´ 
(
´´ 
uint
´´ 
)
´´ 
this
´´ !
.
´´! "
	ReadIntLE
´´" +
(
´´+ ,
)
´´, -
;
´´- .
}
¨¨ 
}
≠≠ 	
public
ØØ 
virtual
ØØ 
long
ØØ 
ReadLong
ØØ $
(
ØØ$ %
)
ØØ% &
{
∞∞ 	
this
±± 
.
±± !
CheckReadableBytes0
±± $
(
±±$ %
$num
±±% &
)
±±& '
;
±±' (
long
≤≤ 
v
≤≤ 
=
≤≤ 
this
≤≤ 
.
≤≤ 
_GetLong
≤≤ "
(
≤≤" #
this
≤≤# '
.
≤≤' (
readerIndex
≤≤( 3
)
≤≤3 4
;
≤≤4 5
this
≥≥ 
.
≥≥ 
readerIndex
≥≥ 
+=
≥≥ 
$num
≥≥  !
;
≥≥! "
return
¥¥ 
v
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
virtual
∑∑ 
long
∑∑ 

ReadLongLE
∑∑ &
(
∑∑& '
)
∑∑' (
{
∏∏ 	
this
ππ 
.
ππ !
CheckReadableBytes0
ππ $
(
ππ$ %
$num
ππ% &
)
ππ& '
;
ππ' (
long
∫∫ 
v
∫∫ 
=
∫∫ 
this
∫∫ 
.
∫∫ 

_GetLongLE
∫∫ $
(
∫∫$ %
this
∫∫% )
.
∫∫) *
readerIndex
∫∫* 5
)
∫∫5 6
;
∫∫6 7
this
ªª 
.
ªª 
readerIndex
ªª 
+=
ªª 
$num
ªª  !
;
ªª! "
return
ºº 
v
ºº 
;
ºº 
}
ΩΩ 	
public
øø 
char
øø 
ReadChar
øø 
(
øø 
)
øø 
=>
øø !
(
øø" #
char
øø# '
)
øø' (
this
øø( ,
.
øø, -
	ReadShort
øø- 6
(
øø6 7
)
øø7 8
;
øø8 9
public
¡¡ 
float
¡¡ 
	ReadFloat
¡¡ 
(
¡¡ 
)
¡¡  
=>
¡¡! #
ByteBufferUtil
¡¡$ 2
.
¡¡2 3
Int32BitsToSingle
¡¡3 D
(
¡¡D E
this
¡¡E I
.
¡¡I J
ReadInt
¡¡J Q
(
¡¡Q R
)
¡¡R S
)
¡¡S T
;
¡¡T U
public
√√ 
float
√√ 
ReadFloatLE
√√  
(
√√  !
)
√√! "
=>
√√# %
ByteBufferUtil
√√& 4
.
√√4 5
Int32BitsToSingle
√√5 F
(
√√F G
this
√√G K
.
√√K L
	ReadIntLE
√√L U
(
√√U V
)
√√V W
)
√√W X
;
√√X Y
public
≈≈ 
double
≈≈ 

ReadDouble
≈≈  
(
≈≈  !
)
≈≈! "
=>
≈≈# %
BitConverter
≈≈& 2
.
≈≈2 3
Int64BitsToDouble
≈≈3 D
(
≈≈D E
this
≈≈E I
.
≈≈I J
ReadLong
≈≈J R
(
≈≈R S
)
≈≈S T
)
≈≈T U
;
≈≈U V
public
«« 
double
«« 
ReadDoubleLE
«« "
(
««" #
)
««# $
=>
««% '
BitConverter
««( 4
.
««4 5
Int64BitsToDouble
««5 F
(
««F G
this
««G K
.
««K L

ReadLongLE
««L V
(
««V W
)
««W X
)
««X Y
;
««Y Z
public
…… 
virtual
…… 
IByteBuffer
…… "
	ReadBytes
……# ,
(
……, -
int
……- 0
length
……1 7
)
……7 8
{
   	
this
ÀÀ 
.
ÀÀ  
CheckReadableBytes
ÀÀ #
(
ÀÀ# $
length
ÀÀ$ *
)
ÀÀ* +
;
ÀÀ+ ,
if
ÃÃ 
(
ÃÃ 
length
ÃÃ 
==
ÃÃ 
$num
ÃÃ 
)
ÃÃ 
{
ÕÕ 
return
ŒŒ 
Unpooled
ŒŒ 
.
ŒŒ  
Empty
ŒŒ  %
;
ŒŒ% &
}
œœ 
IByteBuffer
—— 
buf
—— 
=
—— 
this
—— "
.
——" #
	Allocator
——# ,
.
——, -
Buffer
——- 3
(
——3 4
length
——4 :
,
——: ;
this
——< @
.
——@ A
MaxCapacity
——A L
)
——L M
;
——M N
buf
““ 
.
““ 

WriteBytes
““ 
(
““ 
this
““ 
,
““  
this
““! %
.
““% &
readerIndex
““& 1
,
““1 2
length
““3 9
)
““9 :
;
““: ;
this
”” 
.
”” 
readerIndex
”” 
+=
”” 
length
””  &
;
””& '
return
‘‘ 
buf
‘‘ 
;
‘‘ 
}
’’ 	
public
◊◊ 
virtual
◊◊ 
IByteBuffer
◊◊ "
	ReadSlice
◊◊# ,
(
◊◊, -
int
◊◊- 0
length
◊◊1 7
)
◊◊7 8
{
ÿÿ 	
this
ŸŸ 
.
ŸŸ  
CheckReadableBytes
ŸŸ #
(
ŸŸ# $
length
ŸŸ$ *
)
ŸŸ* +
;
ŸŸ+ ,
IByteBuffer
⁄⁄ 
slice
⁄⁄ 
=
⁄⁄ 
this
⁄⁄  $
.
⁄⁄$ %
Slice
⁄⁄% *
(
⁄⁄* +
this
⁄⁄+ /
.
⁄⁄/ 0
readerIndex
⁄⁄0 ;
,
⁄⁄; <
length
⁄⁄= C
)
⁄⁄C D
;
⁄⁄D E
this
€€ 
.
€€ 
readerIndex
€€ 
+=
€€ 
length
€€  &
;
€€& '
return
‹‹ 
slice
‹‹ 
;
‹‹ 
}
›› 	
public
ﬂﬂ 
virtual
ﬂﬂ 
IByteBuffer
ﬂﬂ "
ReadRetainedSlice
ﬂﬂ# 4
(
ﬂﬂ4 5
int
ﬂﬂ5 8
length
ﬂﬂ9 ?
)
ﬂﬂ? @
{
‡‡ 	
this
·· 
.
··  
CheckReadableBytes
·· #
(
··# $
length
··$ *
)
··* +
;
··+ ,
IByteBuffer
‚‚ 
slice
‚‚ 
=
‚‚ 
this
‚‚  $
.
‚‚$ %
RetainedSlice
‚‚% 2
(
‚‚2 3
this
‚‚3 7
.
‚‚7 8
readerIndex
‚‚8 C
,
‚‚C D
length
‚‚E K
)
‚‚K L
;
‚‚L M
this
„„ 
.
„„ 
readerIndex
„„ 
+=
„„ 
length
„„  &
;
„„& '
return
‰‰ 
slice
‰‰ 
;
‰‰ 
}
ÂÂ 	
public
ÁÁ 
virtual
ÁÁ 
IByteBuffer
ÁÁ "
	ReadBytes
ÁÁ# ,
(
ÁÁ, -
byte
ÁÁ- 1
[
ÁÁ1 2
]
ÁÁ2 3
destination
ÁÁ4 ?
,
ÁÁ? @
int
ÁÁA D
dstIndex
ÁÁE M
,
ÁÁM N
int
ÁÁO R
length
ÁÁS Y
)
ÁÁY Z
{
ËË 	
this
ÈÈ 
.
ÈÈ  
CheckReadableBytes
ÈÈ #
(
ÈÈ# $
length
ÈÈ$ *
)
ÈÈ* +
;
ÈÈ+ ,
this
ÍÍ 
.
ÍÍ 
GetBytes
ÍÍ 
(
ÍÍ 
this
ÍÍ 
.
ÍÍ 
readerIndex
ÍÍ *
,
ÍÍ* +
destination
ÍÍ, 7
,
ÍÍ7 8
dstIndex
ÍÍ9 A
,
ÍÍA B
length
ÍÍC I
)
ÍÍI J
;
ÍÍJ K
this
ÎÎ 
.
ÎÎ 
readerIndex
ÎÎ 
+=
ÎÎ 
length
ÎÎ  &
;
ÎÎ& '
return
ÏÏ 
this
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
public
ÔÔ 
virtual
ÔÔ 
IByteBuffer
ÔÔ "
	ReadBytes
ÔÔ# ,
(
ÔÔ, -
byte
ÔÔ- 1
[
ÔÔ1 2
]
ÔÔ2 3
dst
ÔÔ4 7
)
ÔÔ7 8
{
 	
this
ÒÒ 
.
ÒÒ 
	ReadBytes
ÒÒ 
(
ÒÒ 
dst
ÒÒ 
,
ÒÒ 
$num
ÒÒ  !
,
ÒÒ! "
dst
ÒÒ# &
.
ÒÒ& '
Length
ÒÒ' -
)
ÒÒ- .
;
ÒÒ. /
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
ıı 
virtual
ıı 
IByteBuffer
ıı "
	ReadBytes
ıı# ,
(
ıı, -
IByteBuffer
ıı- 8
dst
ıı9 <
)
ıı< =
{
ˆˆ 	
this
˜˜ 
.
˜˜ 
	ReadBytes
˜˜ 
(
˜˜ 
dst
˜˜ 
,
˜˜ 
dst
˜˜  #
.
˜˜# $
WritableBytes
˜˜$ 1
)
˜˜1 2
;
˜˜2 3
return
¯¯ 
this
¯¯ 
;
¯¯ 
}
˘˘ 	
public
˚˚ 
virtual
˚˚ 
IByteBuffer
˚˚ "
	ReadBytes
˚˚# ,
(
˚˚, -
IByteBuffer
˚˚- 8
dst
˚˚9 <
,
˚˚< =
int
˚˚> A
length
˚˚B H
)
˚˚H I
{
¸¸ 	
if
˝˝ 
(
˝˝ 
length
˝˝ 
>
˝˝ 
dst
˝˝ 
.
˝˝ 
WritableBytes
˝˝ *
)
˝˝* +
{
˛˛ 
ThrowHelper
ˇˇ 
.
ˇˇ 9
+ThrowIndexOutOfRangeException_WritableBytes
ˇˇ G
(
ˇˇG H
length
ˇˇH N
,
ˇˇN O
dst
ˇˇP S
)
ˇˇS T
;
ˇˇT U
}
ÄÄ 
this
ÅÅ 
.
ÅÅ 
	ReadBytes
ÅÅ 
(
ÅÅ 
dst
ÅÅ 
,
ÅÅ 
dst
ÅÅ  #
.
ÅÅ# $
WriterIndex
ÅÅ$ /
,
ÅÅ/ 0
length
ÅÅ1 7
)
ÅÅ7 8
;
ÅÅ8 9
dst
ÇÇ 
.
ÇÇ 
SetWriterIndex
ÇÇ 
(
ÇÇ 
dst
ÇÇ "
.
ÇÇ" #
WriterIndex
ÇÇ# .
+
ÇÇ/ 0
length
ÇÇ1 7
)
ÇÇ7 8
;
ÇÇ8 9
return
ÉÉ 
this
ÉÉ 
;
ÉÉ 
}
ÑÑ 	
public
ÜÜ 
virtual
ÜÜ 
IByteBuffer
ÜÜ "
	ReadBytes
ÜÜ# ,
(
ÜÜ, -
IByteBuffer
ÜÜ- 8
dst
ÜÜ9 <
,
ÜÜ< =
int
ÜÜ> A
dstIndex
ÜÜB J
,
ÜÜJ K
int
ÜÜL O
length
ÜÜP V
)
ÜÜV W
{
áá 	
this
àà 
.
àà  
CheckReadableBytes
àà #
(
àà# $
length
àà$ *
)
àà* +
;
àà+ ,
this
ââ 
.
ââ 
GetBytes
ââ 
(
ââ 
this
ââ 
.
ââ 
readerIndex
ââ *
,
ââ* +
dst
ââ, /
,
ââ/ 0
dstIndex
ââ1 9
,
ââ9 :
length
ââ; A
)
ââA B
;
ââB C
this
ää 
.
ää 
readerIndex
ää 
+=
ää 
length
ää  &
;
ää& '
return
ãã 
this
ãã 
;
ãã 
}
åå 	
public
éé 
virtual
éé 
IByteBuffer
éé "
	ReadBytes
éé# ,
(
éé, -
Stream
éé- 3
destination
éé4 ?
,
éé? @
int
ééA D
length
ééE K
)
ééK L
{
èè 	
this
êê 
.
êê  
CheckReadableBytes
êê #
(
êê# $
length
êê$ *
)
êê* +
;
êê+ ,
this
ëë 
.
ëë 
GetBytes
ëë 
(
ëë 
this
ëë 
.
ëë 
readerIndex
ëë *
,
ëë* +
destination
ëë, 7
,
ëë7 8
length
ëë9 ?
)
ëë? @
;
ëë@ A
this
íí 
.
íí 
readerIndex
íí 
+=
íí 
length
íí  &
;
íí& '
return
ìì 
this
ìì 
;
ìì 
}
îî 	
public
ññ 
virtual
ññ 
IByteBuffer
ññ "
	SkipBytes
ññ# ,
(
ññ, -
int
ññ- 0
length
ññ1 7
)
ññ7 8
{
óó 	
this
òò 
.
òò  
CheckReadableBytes
òò #
(
òò# $
length
òò$ *
)
òò* +
;
òò+ ,
this
ôô 
.
ôô 
readerIndex
ôô 
+=
ôô 
length
ôô  &
;
ôô& '
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
virtual
ùù 
IByteBuffer
ùù "
WriteBoolean
ùù# /
(
ùù/ 0
bool
ùù0 4
value
ùù5 :
)
ùù: ;
{
ûû 	
this
üü 
.
üü 
	WriteByte
üü 
(
üü 
value
üü  
?
üü! "
$num
üü# $
:
üü% &
$num
üü' (
)
üü( )
;
üü) *
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
virtual
££ 
IByteBuffer
££ "
	WriteByte
££# ,
(
££, -
int
££- 0
value
££1 6
)
££6 7
{
§§ 	
this
•• 
.
•• 
EnsureWritable0
••  
(
••  !
$num
••! "
)
••" #
;
••# $
this
¶¶ 
.
¶¶ 
_SetByte
¶¶ 
(
¶¶ 
this
¶¶ 
.
¶¶ 
writerIndex
¶¶ *
++
¶¶* ,
,
¶¶, -
value
¶¶. 3
)
¶¶3 4
;
¶¶4 5
return
ßß 
this
ßß 
;
ßß 
}
®® 	
public
™™ 
virtual
™™ 
IByteBuffer
™™ "

WriteShort
™™# -
(
™™- .
int
™™. 1
value
™™2 7
)
™™7 8
{
´´ 	
this
¨¨ 
.
¨¨ 
EnsureWritable0
¨¨  
(
¨¨  !
$num
¨¨! "
)
¨¨" #
;
¨¨# $
this
≠≠ 
.
≠≠ 
	_SetShort
≠≠ 
(
≠≠ 
this
≠≠ 
.
≠≠  
writerIndex
≠≠  +
,
≠≠+ ,
value
≠≠- 2
)
≠≠2 3
;
≠≠3 4
this
ÆÆ 
.
ÆÆ 
writerIndex
ÆÆ 
+=
ÆÆ 
$num
ÆÆ  !
;
ÆÆ! "
return
ØØ 
this
ØØ 
;
ØØ 
}
∞∞ 	
public
≤≤ 
virtual
≤≤ 
IByteBuffer
≤≤ "
WriteShortLE
≤≤# /
(
≤≤/ 0
int
≤≤0 3
value
≤≤4 9
)
≤≤9 :
{
≥≥ 	
this
¥¥ 
.
¥¥ 
EnsureWritable0
¥¥  
(
¥¥  !
$num
¥¥! "
)
¥¥" #
;
¥¥# $
this
µµ 
.
µµ 
_SetShortLE
µµ 
(
µµ 
this
µµ !
.
µµ! "
writerIndex
µµ" -
,
µµ- .
value
µµ/ 4
)
µµ4 5
;
µµ5 6
this
∂∂ 
.
∂∂ 
writerIndex
∂∂ 
+=
∂∂ 
$num
∂∂  !
;
∂∂! "
return
∑∑ 
this
∑∑ 
;
∑∑ 
}
∏∏ 	
public
∫∫ 
IByteBuffer
∫∫  
WriteUnsignedShort
∫∫ -
(
∫∫- .
ushort
∫∫. 4
value
∫∫5 :
)
∫∫: ;
{
ªª 	
	unchecked
ºº 
{
ΩΩ 
return
ææ 
this
ææ 
.
ææ 

WriteShort
ææ &
(
ææ& '
(
ææ' (
short
ææ( -
)
ææ- .
value
ææ. 3
)
ææ3 4
;
ææ4 5
}
øø 
}
¿¿ 	
public
¬¬ 
IByteBuffer
¬¬ "
WriteUnsignedShortLE
¬¬ /
(
¬¬/ 0
ushort
¬¬0 6
value
¬¬7 <
)
¬¬< =
{
√√ 	
	unchecked
ƒƒ 
{
≈≈ 
return
∆∆ 
this
∆∆ 
.
∆∆ 
WriteShortLE
∆∆ (
(
∆∆( )
(
∆∆) *
short
∆∆* /
)
∆∆/ 0
value
∆∆0 5
)
∆∆5 6
;
∆∆6 7
}
«« 
}
»» 	
public
   
virtual
   
IByteBuffer
   "
WriteMedium
  # .
(
  . /
int
  / 2
value
  3 8
)
  8 9
{
ÀÀ 	
this
ÃÃ 
.
ÃÃ 
EnsureWritable0
ÃÃ  
(
ÃÃ  !
$num
ÃÃ! "
)
ÃÃ" #
;
ÃÃ# $
this
ÕÕ 
.
ÕÕ 

_SetMedium
ÕÕ 
(
ÕÕ 
this
ÕÕ  
.
ÕÕ  !
writerIndex
ÕÕ! ,
,
ÕÕ, -
value
ÕÕ. 3
)
ÕÕ3 4
;
ÕÕ4 5
this
ŒŒ 
.
ŒŒ 
writerIndex
ŒŒ 
+=
ŒŒ 
$num
ŒŒ  !
;
ŒŒ! "
return
œœ 
this
œœ 
;
œœ 
}
–– 	
public
““ 
virtual
““ 
IByteBuffer
““ "
WriteMediumLE
““# 0
(
““0 1
int
““1 4
value
““5 :
)
““: ;
{
”” 	
this
‘‘ 
.
‘‘ 
EnsureWritable0
‘‘  
(
‘‘  !
$num
‘‘! "
)
‘‘" #
;
‘‘# $
this
’’ 
.
’’ 
_SetMediumLE
’’ 
(
’’ 
this
’’ "
.
’’" #
writerIndex
’’# .
,
’’. /
value
’’0 5
)
’’5 6
;
’’6 7
this
÷÷ 
.
÷÷ 
writerIndex
÷÷ 
+=
÷÷ 
$num
÷÷  !
;
÷÷! "
return
◊◊ 
this
◊◊ 
;
◊◊ 
}
ÿÿ 	
public
⁄⁄ 
virtual
⁄⁄ 
IByteBuffer
⁄⁄ "
WriteInt
⁄⁄# +
(
⁄⁄+ ,
int
⁄⁄, /
value
⁄⁄0 5
)
⁄⁄5 6
{
€€ 	
this
‹‹ 
.
‹‹ 
EnsureWritable0
‹‹  
(
‹‹  !
$num
‹‹! "
)
‹‹" #
;
‹‹# $
this
›› 
.
›› 
_SetInt
›› 
(
›› 
this
›› 
.
›› 
writerIndex
›› )
,
››) *
value
››+ 0
)
››0 1
;
››1 2
this
ﬁﬁ 
.
ﬁﬁ 
writerIndex
ﬁﬁ 
+=
ﬁﬁ 
$num
ﬁﬁ  !
;
ﬁﬁ! "
return
ﬂﬂ 
this
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
public
‚‚ 
virtual
‚‚ 
IByteBuffer
‚‚ "

WriteIntLE
‚‚# -
(
‚‚- .
int
‚‚. 1
value
‚‚2 7
)
‚‚7 8
{
„„ 	
this
‰‰ 
.
‰‰ 
EnsureWritable0
‰‰  
(
‰‰  !
$num
‰‰! "
)
‰‰" #
;
‰‰# $
this
ÂÂ 
.
ÂÂ 
	_SetIntLE
ÂÂ 
(
ÂÂ 
this
ÂÂ 
.
ÂÂ  
writerIndex
ÂÂ  +
,
ÂÂ+ ,
value
ÂÂ- 2
)
ÂÂ2 3
;
ÂÂ3 4
this
ÊÊ 
.
ÊÊ 
writerIndex
ÊÊ 
+=
ÊÊ 
$num
ÊÊ  !
;
ÊÊ! "
return
ÁÁ 
this
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÍÍ 
virtual
ÍÍ 
IByteBuffer
ÍÍ "
	WriteLong
ÍÍ# ,
(
ÍÍ, -
long
ÍÍ- 1
value
ÍÍ2 7
)
ÍÍ7 8
{
ÎÎ 	
this
ÏÏ 
.
ÏÏ 
EnsureWritable0
ÏÏ  
(
ÏÏ  !
$num
ÏÏ! "
)
ÏÏ" #
;
ÏÏ# $
this
ÌÌ 
.
ÌÌ 
_SetLong
ÌÌ 
(
ÌÌ 
this
ÌÌ 
.
ÌÌ 
writerIndex
ÌÌ *
,
ÌÌ* +
value
ÌÌ, 1
)
ÌÌ1 2
;
ÌÌ2 3
this
ÓÓ 
.
ÓÓ 
writerIndex
ÓÓ 
+=
ÓÓ 
$num
ÓÓ  !
;
ÓÓ! "
return
ÔÔ 
this
ÔÔ 
;
ÔÔ 
}
 	
public
ÚÚ 
virtual
ÚÚ 
IByteBuffer
ÚÚ "
WriteLongLE
ÚÚ# .
(
ÚÚ. /
long
ÚÚ/ 3
value
ÚÚ4 9
)
ÚÚ9 :
{
ÛÛ 	
this
ÙÙ 
.
ÙÙ 
EnsureWritable0
ÙÙ  
(
ÙÙ  !
$num
ÙÙ! "
)
ÙÙ" #
;
ÙÙ# $
this
ıı 
.
ıı 

_SetLongLE
ıı 
(
ıı 
this
ıı  
.
ıı  !
writerIndex
ıı! ,
,
ıı, -
value
ıı. 3
)
ıı3 4
;
ıı4 5
this
ˆˆ 
.
ˆˆ 
writerIndex
ˆˆ 
+=
ˆˆ 
$num
ˆˆ  !
;
ˆˆ! "
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
¯¯ 	
public
˙˙ 
virtual
˙˙ 
IByteBuffer
˙˙ "
	WriteChar
˙˙# ,
(
˙˙, -
char
˙˙- 1
value
˙˙2 7
)
˙˙7 8
{
˚˚ 	
this
¸¸ 
.
¸¸ 

WriteShort
¸¸ 
(
¸¸ 
value
¸¸ !
)
¸¸! "
;
¸¸" #
return
˝˝ 
this
˝˝ 
;
˝˝ 
}
˛˛ 	
public
Ä	Ä	 
virtual
Ä	Ä	 
IByteBuffer
Ä	Ä	 "

WriteFloat
Ä	Ä	# -
(
Ä	Ä	- .
float
Ä	Ä	. 3
value
Ä	Ä	4 9
)
Ä	Ä	9 :
{
Å	Å	 	
this
Ç	Ç	 
.
Ç	Ç	 
WriteInt
Ç	Ç	 
(
Ç	Ç	 
ByteBufferUtil
Ç	Ç	 (
.
Ç	Ç	( )
SingleToInt32Bits
Ç	Ç	) :
(
Ç	Ç	: ;
value
Ç	Ç	; @
)
Ç	Ç	@ A
)
Ç	Ç	A B
;
Ç	Ç	B C
return
É	É	 
this
É	É	 
;
É	É	 
}
Ñ	Ñ	 	
public
Ü	Ü	 
IByteBuffer
Ü	Ü	 
WriteFloatLE
Ü	Ü	 '
(
Ü	Ü	' (
float
Ü	Ü	( -
value
Ü	Ü	. 3
)
Ü	Ü	3 4
=>
Ü	Ü	5 7
this
Ü	Ü	8 <
.
Ü	Ü	< =

WriteIntLE
Ü	Ü	= G
(
Ü	Ü	G H
ByteBufferUtil
Ü	Ü	H V
.
Ü	Ü	V W
SingleToInt32Bits
Ü	Ü	W h
(
Ü	Ü	h i
value
Ü	Ü	i n
)
Ü	Ü	n o
)
Ü	Ü	o p
;
Ü	Ü	p q
public
à	à	 
virtual
à	à	 
IByteBuffer
à	à	 "
WriteDouble
à	à	# .
(
à	à	. /
double
à	à	/ 5
value
à	à	6 ;
)
à	à	; <
{
â	â	 	
this
ä	ä	 
.
ä	ä	 
	WriteLong
ä	ä	 
(
ä	ä	 
BitConverter
ä	ä	 '
.
ä	ä	' (
DoubleToInt64Bits
ä	ä	( 9
(
ä	ä	9 :
value
ä	ä	: ?
)
ä	ä	? @
)
ä	ä	@ A
;
ä	ä	A B
return
ã	ã	 
this
ã	ã	 
;
ã	ã	 
}
å	å	 	
public
é	é	 
IByteBuffer
é	é	 
WriteDoubleLE
é	é	 (
(
é	é	( )
double
é	é	) /
value
é	é	0 5
)
é	é	5 6
=>
é	é	7 9
this
é	é	: >
.
é	é	> ?
WriteLongLE
é	é	? J
(
é	é	J K
BitConverter
é	é	K W
.
é	é	W X
DoubleToInt64Bits
é	é	X i
(
é	é	i j
value
é	é	j o
)
é	é	o p
)
é	é	p q
;
é	é	q r
public
ê	ê	 
virtual
ê	ê	 
IByteBuffer
ê	ê	 "

WriteBytes
ê	ê	# -
(
ê	ê	- .
byte
ê	ê	. 2
[
ê	ê	2 3
]
ê	ê	3 4
src
ê	ê	5 8
,
ê	ê	8 9
int
ê	ê	: =
srcIndex
ê	ê	> F
,
ê	ê	F G
int
ê	ê	H K
length
ê	ê	L R
)
ê	ê	R S
{
ë	ë	 	
this
í	í	 
.
í	í	 
EnsureWritable
í	í	 
(
í	í	  
length
í	í	  &
)
í	í	& '
;
í	í	' (
this
ì	ì	 
.
ì	ì	 
SetBytes
ì	ì	 
(
ì	ì	 
this
ì	ì	 
.
ì	ì	 
writerIndex
ì	ì	 *
,
ì	ì	* +
src
ì	ì	, /
,
ì	ì	/ 0
srcIndex
ì	ì	1 9
,
ì	ì	9 :
length
ì	ì	; A
)
ì	ì	A B
;
ì	ì	B C
this
î	î	 
.
î	î	 
writerIndex
î	î	 
+=
î	î	 
length
î	î	  &
;
î	î	& '
return
ï	ï	 
this
ï	ï	 
;
ï	ï	 
}
ñ	ñ	 	
public
ò	ò	 
virtual
ò	ò	 
IByteBuffer
ò	ò	 "

WriteBytes
ò	ò	# -
(
ò	ò	- .
byte
ò	ò	. 2
[
ò	ò	2 3
]
ò	ò	3 4
src
ò	ò	5 8
)
ò	ò	8 9
{
ô	ô	 	
this
ö	ö	 
.
ö	ö	 

WriteBytes
ö	ö	 
(
ö	ö	 
src
ö	ö	 
,
ö	ö	  
$num
ö	ö	! "
,
ö	ö	" #
src
ö	ö	$ '
.
ö	ö	' (
Length
ö	ö	( .
)
ö	ö	. /
;
ö	ö	/ 0
return
õ	õ	 
this
õ	õ	 
;
õ	õ	 
}
ú	ú	 	
public
û	û	 
virtual
û	û	 
IByteBuffer
û	û	 "

WriteBytes
û	û	# -
(
û	û	- .
IByteBuffer
û	û	. 9
src
û	û	: =
)
û	û	= >
{
ü	ü	 	
this
†	†	 
.
†	†	 

WriteBytes
†	†	 
(
†	†	 
src
†	†	 
,
†	†	  
src
†	†	! $
.
†	†	$ %
ReadableBytes
†	†	% 2
)
†	†	2 3
;
†	†	3 4
return
°	°	 
this
°	°	 
;
°	°	 
}
¢	¢	 	
public
§	§	 
virtual
§	§	 
IByteBuffer
§	§	 "

WriteBytes
§	§	# -
(
§	§	- .
IByteBuffer
§	§	. 9
src
§	§	: =
,
§	§	= >
int
§	§	? B
length
§	§	C I
)
§	§	I J
{
•	•	 	
if
¶	¶	 
(
¶	¶	 
length
¶	¶	 
>
¶	¶	 
src
¶	¶	 
.
¶	¶	 
ReadableBytes
¶	¶	 *
)
¶	¶	* +
{
ß	ß	 
ThrowHelper
®	®	 
.
®	®	 9
+ThrowIndexOutOfRangeException_ReadableBytes
®	®	 G
(
®	®	G H
length
®	®	H N
,
®	®	N O
src
®	®	P S
)
®	®	S T
;
®	®	T U
}
©	©	 
this
™	™	 
.
™	™	 

WriteBytes
™	™	 
(
™	™	 
src
™	™	 
,
™	™	  
src
™	™	! $
.
™	™	$ %
ReaderIndex
™	™	% 0
,
™	™	0 1
length
™	™	2 8
)
™	™	8 9
;
™	™	9 :
src
´	´	 
.
´	´	 
SetReaderIndex
´	´	 
(
´	´	 
src
´	´	 "
.
´	´	" #
ReaderIndex
´	´	# .
+
´	´	/ 0
length
´	´	1 7
)
´	´	7 8
;
´	´	8 9
return
¨	¨	 
this
¨	¨	 
;
¨	¨	 
}
≠	≠	 	
public
Ø	Ø	 
virtual
Ø	Ø	 
IByteBuffer
Ø	Ø	 "

WriteBytes
Ø	Ø	# -
(
Ø	Ø	- .
IByteBuffer
Ø	Ø	. 9
src
Ø	Ø	: =
,
Ø	Ø	= >
int
Ø	Ø	? B
srcIndex
Ø	Ø	C K
,
Ø	Ø	K L
int
Ø	Ø	M P
length
Ø	Ø	Q W
)
Ø	Ø	W X
{
∞	∞	 	
this
±	±	 
.
±	±	 
EnsureWritable
±	±	 
(
±	±	  
length
±	±	  &
)
±	±	& '
;
±	±	' (
this
≤	≤	 
.
≤	≤	 
SetBytes
≤	≤	 
(
≤	≤	 
this
≤	≤	 
.
≤	≤	 
writerIndex
≤	≤	 *
,
≤	≤	* +
src
≤	≤	, /
,
≤	≤	/ 0
srcIndex
≤	≤	1 9
,
≤	≤	9 :
length
≤	≤	; A
)
≤	≤	A B
;
≤	≤	B C
this
≥	≥	 
.
≥	≥	 
writerIndex
≥	≥	 
+=
≥	≥	 
length
≥	≥	  &
;
≥	≥	& '
return
¥	¥	 
this
¥	¥	 
;
¥	¥	 
}
µ	µ	 	
public
∑	∑	 
virtual
∑	∑	 
async
∑	∑	 
Task
∑	∑	 !
WriteBytesAsync
∑	∑	" 1
(
∑	∑	1 2
Stream
∑	∑	2 8
stream
∑	∑	9 ?
,
∑	∑	? @
int
∑	∑	A D
length
∑	∑	E K
,
∑	∑	K L
CancellationToken
∑	∑	M ^
cancellationToken
∑	∑	_ p
)
∑	∑	p q
{
∏	∏	 	
this
π	π	 
.
π	π	 
EnsureWritable
π	π	 
(
π	π	  
length
π	π	  &
)
π	π	& '
;
π	π	' (
if
∫	∫	 
(
∫	∫	 
this
∫	∫	 
.
∫	∫	 
WritableBytes
∫	∫	 "
<
∫	∫	# $
length
∫	∫	% +
)
∫	∫	+ ,
{
ª	ª	 
throw
º	º	 
new
º	º	 )
ArgumentOutOfRangeException
º	º	 5
(
º	º	5 6
nameof
º	º	6 <
(
º	º	< =
length
º	º	= C
)
º	º	C D
)
º	º	D E
;
º	º	E F
}
Ω	Ω	 
int
ø	ø	 
	writerIdx
ø	ø	 
=
ø	ø	 
this
ø	ø	  
.
ø	ø	  !
writerIndex
ø	ø	! ,
;
ø	ø	, -
int
¿	¿	 
wrote
¿	¿	 
=
¿	¿	 
await
¿	¿	 
this
¿	¿	 "
.
¿	¿	" #
SetBytesAsync
¿	¿	# 0
(
¿	¿	0 1
	writerIdx
¿	¿	1 :
,
¿	¿	: ;
stream
¿	¿	< B
,
¿	¿	B C
length
¿	¿	D J
,
¿	¿	J K
cancellationToken
¿	¿	L ]
)
¿	¿	] ^
;
¿	¿	^ _
Contract
¬	¬	 
.
¬	¬	 
Assert
¬	¬	 
(
¬	¬	 
	writerIdx
¬	¬	 %
==
¬	¬	& (
this
¬	¬	) -
.
¬	¬	- .
writerIndex
¬	¬	. 9
)
¬	¬	9 :
;
¬	¬	: ;
this
√	√	 
.
√	√	 
writerIndex
√	√	 
=
√	√	 
	writerIdx
√	√	 (
+
√	√	) *
wrote
√	√	+ 0
;
√	√	0 1
}
ƒ	ƒ	 	
public
∆	∆	 
Task
∆	∆	 
WriteBytesAsync
∆	∆	 #
(
∆	∆	# $
Stream
∆	∆	$ *
stream
∆	∆	+ 1
,
∆	∆	1 2
int
∆	∆	3 6
length
∆	∆	7 =
)
∆	∆	= >
=>
∆	∆	? A
this
∆	∆	B F
.
∆	∆	F G
WriteBytesAsync
∆	∆	G V
(
∆	∆	V W
stream
∆	∆	W ]
,
∆	∆	] ^
length
∆	∆	_ e
,
∆	∆	e f
CancellationToken
∆	∆	g x
.
∆	∆	x y
None
∆	∆	y }
)
∆	∆	} ~
;
∆	∆	~ 
public
»	»	 
virtual
»	»	 
IByteBuffer
»	»	 "
	WriteZero
»	»	# ,
(
»	»	, -
int
»	»	- 0
length
»	»	1 7
)
»	»	7 8
{
…	…	 	
if
 	 	 
(
 	 	 
length
 	 	 
==
 	 	 
$num
 	 	 
)
 	 	 
{
À	À	 
return
Ã	Ã	 
this
Ã	Ã	 
;
Ã	Ã	 
}
Õ	Õ	 
this
œ	œ	 
.
œ	œ	 
EnsureWritable
œ	œ	 
(
œ	œ	  
length
œ	œ	  &
)
œ	œ	& '
;
œ	œ	' (
int
–	–	 
wIndex
–	–	 
=
–	–	 
this
–	–	 
.
–	–	 
writerIndex
–	–	 )
;
–	–	) *
this
—	—	 
.
—	—	 
CheckIndex0
—	—	 
(
—	—	 
wIndex
—	—	 #
,
—	—	# $
length
—	—	% +
)
—	—	+ ,
;
—	—	, -
int
”	”	 
nLong
”	”	 
=
”	”	 
length
”	”	 
.
”	”	 
RightUShift
”	”	 *
(
”	”	* +
$num
”	”	+ ,
)
”	”	, -
;
”	”	- .
int
‘	‘	 
nBytes
‘	‘	 
=
‘	‘	 
length
‘	‘	 
&
‘	‘	  !
$num
‘	‘	" #
;
‘	‘	# $
for
’	’	 
(
’	’	 
int
’	’	 
i
’	’	 
=
’	’	 
nLong
’	’	 
;
’	’	 
i
’	’	  !
>
’	’	" #
$num
’	’	$ %
;
’	’	% &
i
’	’	' (
--
’	’	( *
)
’	’	* +
{
÷	÷	 
this
◊	◊	 
.
◊	◊	 
_SetLong
◊	◊	 
(
◊	◊	 
wIndex
◊	◊	 $
,
◊	◊	$ %
$num
◊	◊	& '
)
◊	◊	' (
;
◊	◊	( )
wIndex
ÿ	ÿ	 
+=
ÿ	ÿ	 
$num
ÿ	ÿ	 
;
ÿ	ÿ	 
}
Ÿ	Ÿ	 
if
⁄	⁄	 
(
⁄	⁄	 
nBytes
⁄	⁄	 
==
⁄	⁄	 
$num
⁄	⁄	 
)
⁄	⁄	 
{
€	€	 
this
‹	‹	 
.
‹	‹	 
_SetInt
‹	‹	 
(
‹	‹	 
wIndex
‹	‹	 #
,
‹	‹	# $
$num
‹	‹	% &
)
‹	‹	& '
;
‹	‹	' (
wIndex
›	›	 
+=
›	›	 
$num
›	›	 
;
›	›	 
}
ﬁ	ﬁ	 
else
ﬂ	ﬂ	 
if
ﬂ	ﬂ	 
(
ﬂ	ﬂ	 
nBytes
ﬂ	ﬂ	 
<
ﬂ	ﬂ	 
$num
ﬂ	ﬂ	 
)
ﬂ	ﬂ	  
{
‡	‡	 
for
·	·	 
(
·	·	 
int
·	·	 
i
·	·	 
=
·	·	 
nBytes
·	·	 #
;
·	·	# $
i
·	·	% &
>
·	·	' (
$num
·	·	) *
;
·	·	* +
i
·	·	, -
--
·	·	- /
)
·	·	/ 0
{
‚	‚	 
this
„	„	 
.
„	„	 
_SetByte
„	„	 !
(
„	„	! "
wIndex
„	„	" (
,
„	„	( )
$num
„	„	* +
)
„	„	+ ,
;
„	„	, -
wIndex
‰	‰	 
++
‰	‰	 
;
‰	‰	 
}
Â	Â	 
}
Ê	Ê	 
else
Á	Á	 
{
Ë	Ë	 
this
È	È	 
.
È	È	 
_SetInt
È	È	 
(
È	È	 
wIndex
È	È	 #
,
È	È	# $
$num
È	È	% &
)
È	È	& '
;
È	È	' (
wIndex
Í	Í	 
+=
Í	Í	 
$num
Í	Í	 
;
Í	Í	 
for
Î	Î	 
(
Î	Î	 
int
Î	Î	 
i
Î	Î	 
=
Î	Î	 
nBytes
Î	Î	 #
-
Î	Î	$ %
$num
Î	Î	& '
;
Î	Î	' (
i
Î	Î	) *
>
Î	Î	+ ,
$num
Î	Î	- .
;
Î	Î	. /
i
Î	Î	0 1
--
Î	Î	1 3
)
Î	Î	3 4
{
Ï	Ï	 
this
Ì	Ì	 
.
Ì	Ì	 
_SetByte
Ì	Ì	 !
(
Ì	Ì	! "
wIndex
Ì	Ì	" (
,
Ì	Ì	( )
$num
Ì	Ì	* +
)
Ì	Ì	+ ,
;
Ì	Ì	, -
wIndex
Ó	Ó	 
++
Ó	Ó	 
;
Ó	Ó	 
}
Ô	Ô	 
}
		 
this
Ú	Ú	 
.
Ú	Ú	 
writerIndex
Ú	Ú	 
=
Ú	Ú	 
wIndex
Ú	Ú	 %
;
Ú	Ú	% &
return
Û	Û	 
this
Û	Û	 
;
Û	Û	 
}
Ù	Ù	 	
public
ˆ	ˆ	 
virtual
ˆ	ˆ	 
int
ˆ	ˆ	 
WriteCharSequence
ˆ	ˆ	 ,
(
ˆ	ˆ	, -
ICharSequence
ˆ	ˆ	- :
sequence
ˆ	ˆ	; C
,
ˆ	ˆ	C D
Encoding
ˆ	ˆ	E M
encoding
ˆ	ˆ	N V
)
ˆ	ˆ	V W
{
˜	˜	 	
int
¯	¯	 
written
¯	¯	 
=
¯	¯	 
this
¯	¯	 
.
¯	¯	 
SetCharSequence0
¯	¯	 /
(
¯	¯	/ 0
this
¯	¯	0 4
.
¯	¯	4 5
writerIndex
¯	¯	5 @
,
¯	¯	@ A
sequence
¯	¯	B J
,
¯	¯	J K
encoding
¯	¯	L T
,
¯	¯	T U
true
¯	¯	V Z
)
¯	¯	Z [
;
¯	¯	[ \
this
˘	˘	 
.
˘	˘	 
writerIndex
˘	˘	 
+=
˘	˘	 
written
˘	˘	  '
;
˘	˘	' (
return
˙	˙	 
written
˙	˙	 
;
˙	˙	 
}
˚	˚	 	
public
˝	˝	 
virtual
˝	˝	 
int
˝	˝	 
WriteString
˝	˝	 &
(
˝	˝	& '
string
˝	˝	' -
value
˝	˝	. 3
,
˝	˝	3 4
Encoding
˝	˝	5 =
encoding
˝	˝	> F
)
˝	˝	F G
{
˛	˛	 	
int
ˇ	ˇ	 
written
ˇ	ˇ	 
=
ˇ	ˇ	 
this
ˇ	ˇ	 
.
ˇ	ˇ	 

SetString0
ˇ	ˇ	 )
(
ˇ	ˇ	) *
this
ˇ	ˇ	* .
.
ˇ	ˇ	. /
writerIndex
ˇ	ˇ	/ :
,
ˇ	ˇ	: ;
value
ˇ	ˇ	< A
,
ˇ	ˇ	A B
encoding
ˇ	ˇ	C K
,
ˇ	ˇ	K L
true
ˇ	ˇ	M Q
)
ˇ	ˇ	Q R
;
ˇ	ˇ	R S
this
Ä
Ä
 
.
Ä
Ä
 
writerIndex
Ä
Ä
 
+=
Ä
Ä
 
written
Ä
Ä
  '
;
Ä
Ä
' (
return
Å
Å
 
written
Å
Å
 
;
Å
Å
 
}
Ç
Ç
 	
public
Ñ
Ñ
 
virtual
Ñ
Ñ
 
IByteBuffer
Ñ
Ñ
 "
Copy
Ñ
Ñ
# '
(
Ñ
Ñ
' (
)
Ñ
Ñ
( )
=>
Ñ
Ñ
* ,
this
Ñ
Ñ
- 1
.
Ñ
Ñ
1 2
Copy
Ñ
Ñ
2 6
(
Ñ
Ñ
6 7
this
Ñ
Ñ
7 ;
.
Ñ
Ñ
; <
readerIndex
Ñ
Ñ
< G
,
Ñ
Ñ
G H
this
Ñ
Ñ
I M
.
Ñ
Ñ
M N
ReadableBytes
Ñ
Ñ
N [
)
Ñ
Ñ
[ \
;
Ñ
Ñ
\ ]
public
Ü
Ü
 
abstract
Ü
Ü
 
IByteBuffer
Ü
Ü
 #
Copy
Ü
Ü
$ (
(
Ü
Ü
( )
int
Ü
Ü
) ,
index
Ü
Ü
- 2
,
Ü
Ü
2 3
int
Ü
Ü
4 7
length
Ü
Ü
8 >
)
Ü
Ü
> ?
;
Ü
Ü
? @
public
à
à
 
virtual
à
à
 
IByteBuffer
à
à
 "
	Duplicate
à
à
# ,
(
à
à
, -
)
à
à
- .
=>
à
à
/ 1
new
à
à
2 5*
UnpooledDuplicatedByteBuffer
à
à
6 R
(
à
à
R S
this
à
à
S W
)
à
à
W X
;
à
à
X Y
public
ä
ä
 
virtual
ä
ä
 
IByteBuffer
ä
ä
 "
RetainedDuplicate
ä
ä
# 4
(
ä
ä
4 5
)
ä
ä
5 6
=>
ä
ä
7 9
(
ä
ä
: ;
IByteBuffer
ä
ä
; F
)
ä
ä
F G
this
ä
ä
G K
.
ä
ä
K L
	Duplicate
ä
ä
L U
(
ä
ä
U V
)
ä
ä
V W
.
ä
ä
W X
Retain
ä
ä
X ^
(
ä
ä
^ _
)
ä
ä
_ `
;
ä
ä
` a
public
å
å
 
virtual
å
å
 
IByteBuffer
å
å
 "
Slice
å
å
# (
(
å
å
( )
)
å
å
) *
=>
å
å
+ -
this
å
å
. 2
.
å
å
2 3
Slice
å
å
3 8
(
å
å
8 9
this
å
å
9 =
.
å
å
= >
readerIndex
å
å
> I
,
å
å
I J
this
å
å
K O
.
å
å
O P
ReadableBytes
å
å
P ]
)
å
å
] ^
;
å
å
^ _
public
é
é
 
virtual
é
é
 
IByteBuffer
é
é
 "
RetainedSlice
é
é
# 0
(
é
é
0 1
)
é
é
1 2
=>
é
é
3 5
(
é
é
6 7
IByteBuffer
é
é
7 B
)
é
é
B C
this
é
é
C G
.
é
é
G H
Slice
é
é
H M
(
é
é
M N
)
é
é
N O
.
é
é
O P
Retain
é
é
P V
(
é
é
V W
)
é
é
W X
;
é
é
X Y
public
ê
ê
 
virtual
ê
ê
 
IByteBuffer
ê
ê
 "
Slice
ê
ê
# (
(
ê
ê
( )
int
ê
ê
) ,
index
ê
ê
- 2
,
ê
ê
2 3
int
ê
ê
4 7
length
ê
ê
8 >
)
ê
ê
> ?
=>
ê
ê
@ B
new
ê
ê
C F&
UnpooledSlicedByteBuffer
ê
ê
G _
(
ê
ê
_ `
this
ê
ê
` d
,
ê
ê
d e
index
ê
ê
f k
,
ê
ê
k l
length
ê
ê
m s
)
ê
ê
s t
;
ê
ê
t u
public
í
í
 
virtual
í
í
 
IByteBuffer
í
í
 "
RetainedSlice
í
í
# 0
(
í
í
0 1
int
í
í
1 4
index
í
í
5 :
,
í
í
: ;
int
í
í
< ?
length
í
í
@ F
)
í
í
F G
=>
í
í
H J
(
í
í
K L
IByteBuffer
í
í
L W
)
í
í
W X
this
í
í
X \
.
í
í
\ ]
Slice
í
í
] b
(
í
í
b c
index
í
í
c h
,
í
í
h i
length
í
í
j p
)
í
í
p q
.
í
í
q r
Retain
í
í
r x
(
í
í
x y
)
í
í
y z
;
í
í
z {
public
î
î
 
virtual
î
î
 
string
î
î
 
ToString
î
î
 &
(
î
î
& '
Encoding
î
î
' /
encoding
î
î
0 8
)
î
î
8 9
=>
î
î
: <
this
î
î
= A
.
î
î
A B
ToString
î
î
B J
(
î
î
J K
this
î
î
K O
.
î
î
O P
readerIndex
î
î
P [
,
î
î
[ \
this
î
î
] a
.
î
î
a b
ReadableBytes
î
î
b o
,
î
î
o p
encoding
î
î
q y
)
î
î
y z
;
î
î
z {
public
ñ
ñ
 
virtual
ñ
ñ
 
string
ñ
ñ
 
ToString
ñ
ñ
 &
(
ñ
ñ
& '
int
ñ
ñ
' *
index
ñ
ñ
+ 0
,
ñ
ñ
0 1
int
ñ
ñ
2 5
length
ñ
ñ
6 <
,
ñ
ñ
< =
Encoding
ñ
ñ
> F
encoding
ñ
ñ
G O
)
ñ
ñ
O P
=>
ñ
ñ
Q S
ByteBufferUtil
ñ
ñ
T b
.
ñ
ñ
b c
DecodeString
ñ
ñ
c o
(
ñ
ñ
o p
this
ñ
ñ
p t
,
ñ
ñ
t u
index
ñ
ñ
v {
,
ñ
ñ
{ |
lengthñ
ñ
} É
,ñ
ñ
É Ñ
encodingñ
ñ
Ö ç
)ñ
ñ
ç é
;ñ
ñ
é è
public
ò
ò
 
virtual
ò
ò
 
int
ò
ò
 
IndexOf
ò
ò
 "
(
ò
ò
" #
int
ò
ò
# &
	fromIndex
ò
ò
' 0
,
ò
ò
0 1
int
ò
ò
2 5
toIndex
ò
ò
6 =
,
ò
ò
= >
byte
ò
ò
? C
value
ò
ò
D I
)
ò
ò
I J
=>
ò
ò
K M
ByteBufferUtil
ò
ò
N \
.
ò
ò
\ ]
IndexOf
ò
ò
] d
(
ò
ò
d e
this
ò
ò
e i
,
ò
ò
i j
	fromIndex
ò
ò
k t
,
ò
ò
t u
toIndex
ò
ò
v }
,
ò
ò
} ~
valueò
ò
 Ñ
)ò
ò
Ñ Ö
;ò
ò
Ö Ü
public
ö
ö
 
int
ö
ö
 
BytesBefore
ö
ö
 
(
ö
ö
 
byte
ö
ö
 #
value
ö
ö
$ )
)
ö
ö
) *
=>
ö
ö
+ -
this
ö
ö
. 2
.
ö
ö
2 3
BytesBefore
ö
ö
3 >
(
ö
ö
> ?
this
ö
ö
? C
.
ö
ö
C D
ReaderIndex
ö
ö
D O
,
ö
ö
O P
this
ö
ö
Q U
.
ö
ö
U V
ReadableBytes
ö
ö
V c
,
ö
ö
c d
value
ö
ö
e j
)
ö
ö
j k
;
ö
ö
k l
public
ú
ú
 
int
ú
ú
 
BytesBefore
ú
ú
 
(
ú
ú
 
int
ú
ú
 "
length
ú
ú
# )
,
ú
ú
) *
byte
ú
ú
+ /
value
ú
ú
0 5
)
ú
ú
5 6
{
ù
ù
 	
this
û
û
 
.
û
û
  
CheckReadableBytes
û
û
 #
(
û
û
# $
length
û
û
$ *
)
û
û
* +
;
û
û
+ ,
return
ü
ü
 
this
ü
ü
 
.
ü
ü
 
BytesBefore
ü
ü
 #
(
ü
ü
# $
this
ü
ü
$ (
.
ü
ü
( )
ReaderIndex
ü
ü
) 4
,
ü
ü
4 5
length
ü
ü
6 <
,
ü
ü
< =
value
ü
ü
> C
)
ü
ü
C D
;
ü
ü
D E
}
†
†
 	
public
¢
¢
 
virtual
¢
¢
 
int
¢
¢
 
BytesBefore
¢
¢
 &
(
¢
¢
& '
int
¢
¢
' *
index
¢
¢
+ 0
,
¢
¢
0 1
int
¢
¢
2 5
length
¢
¢
6 <
,
¢
¢
< =
byte
¢
¢
> B
value
¢
¢
C H
)
¢
¢
H I
{
£
£
 	
int
§
§
 
endIndex
§
§
 
=
§
§
 
this
§
§
 
.
§
§
  
IndexOf
§
§
  '
(
§
§
' (
index
§
§
( -
,
§
§
- .
index
§
§
/ 4
+
§
§
5 6
length
§
§
7 =
,
§
§
= >
value
§
§
? D
)
§
§
D E
;
§
§
E F
if
•
•
 
(
•
•
 
endIndex
•
•
 
<
•
•
 
$num
•
•
 
)
•
•
 
{
¶
¶
 
return
ß
ß
 
-
ß
ß
 
$num
ß
ß
 
;
ß
ß
 
}
®
®
 
return
™
™
 
endIndex
™
™
 
-
™
™
 
index
™
™
 #
;
™
™
# $
}
´
´
 	
public
≠
≠
 
virtual
≠
≠
 
int
≠
≠
 
ForEachByte
≠
≠
 &
(
≠
≠
& '
IByteProcessor
≠
≠
' 5
	processor
≠
≠
6 ?
)
≠
≠
? @
{
Æ
Æ
 	
this
Ø
Ø
 
.
Ø
Ø
 
EnsureAccessible
Ø
Ø
 !
(
Ø
Ø
! "
)
Ø
Ø
" #
;
Ø
Ø
# $
return
∞
∞
 
this
∞
∞
 
.
∞
∞
 
ForEachByteAsc0
∞
∞
 '
(
∞
∞
' (
this
∞
∞
( ,
.
∞
∞
, -
readerIndex
∞
∞
- 8
,
∞
∞
8 9
this
∞
∞
: >
.
∞
∞
> ?
writerIndex
∞
∞
? J
,
∞
∞
J K
	processor
∞
∞
L U
)
∞
∞
U V
;
∞
∞
V W
}
±
±
 	
public
≥
≥
 
virtual
≥
≥
 
int
≥
≥
 
ForEachByte
≥
≥
 &
(
≥
≥
& '
int
≥
≥
' *
index
≥
≥
+ 0
,
≥
≥
0 1
int
≥
≥
2 5
length
≥
≥
6 <
,
≥
≥
< =
IByteProcessor
≥
≥
> L
	processor
≥
≥
M V
)
≥
≥
V W
{
¥
¥
 	
this
µ
µ
 
.
µ
µ
 

CheckIndex
µ
µ
 
(
µ
µ
 
index
µ
µ
 !
,
µ
µ
! "
length
µ
µ
# )
)
µ
µ
) *
;
µ
µ
* +
return
∂
∂
 
this
∂
∂
 
.
∂
∂
 
ForEachByteAsc0
∂
∂
 '
(
∂
∂
' (
index
∂
∂
( -
,
∂
∂
- .
index
∂
∂
/ 4
+
∂
∂
5 6
length
∂
∂
7 =
,
∂
∂
= >
	processor
∂
∂
? H
)
∂
∂
H I
;
∂
∂
I J
}
∑
∑
 	
int
π
π
 
ForEachByteAsc0
π
π
 
(
π
π
 
int
π
π
 
start
π
π
  %
,
π
π
% &
int
π
π
' *
end
π
π
+ .
,
π
π
. /
IByteProcessor
π
π
0 >
	processor
π
π
? H
)
π
π
H I
{
∫
∫
 	
for
ª
ª
 
(
ª
ª
 
;
ª
ª
 
start
ª
ª
 
<
ª
ª
 
end
ª
ª
 
;
ª
ª
 
++
ª
ª
  "
start
ª
ª
" '
)
ª
ª
' (
{
º
º
 
if
Ω
Ω
 
(
Ω
Ω
 
!
Ω
Ω
 
	processor
Ω
Ω
 
.
Ω
Ω
 
Process
Ω
Ω
 &
(
Ω
Ω
& '
this
Ω
Ω
' +
.
Ω
Ω
+ ,
_GetByte
Ω
Ω
, 4
(
Ω
Ω
4 5
start
Ω
Ω
5 :
)
Ω
Ω
: ;
)
Ω
Ω
; <
)
Ω
Ω
< =
{
æ
æ
 
return
ø
ø
 
start
ø
ø
  
;
ø
ø
  !
}
¿
¿
 
}
¡
¡
 
return
√
√
 
-
√
√
 
$num
√
√
 
;
√
√
 
}
ƒ
ƒ
 	
public
∆
∆
 
virtual
∆
∆
 
int
∆
∆
 
ForEachByteDesc
∆
∆
 *
(
∆
∆
* +
IByteProcessor
∆
∆
+ 9
	processor
∆
∆
: C
)
∆
∆
C D
{
«
«
 	
this
»
»
 
.
»
»
 
EnsureAccessible
»
»
 !
(
»
»
! "
)
»
»
" #
;
»
»
# $
return
…
…
 
this
…
…
 
.
…
…
 
ForEachByteDesc0
…
…
 (
(
…
…
( )
this
…
…
) -
.
…
…
- .
writerIndex
…
…
. 9
-
…
…
: ;
$num
…
…
< =
,
…
…
= >
this
…
…
? C
.
…
…
C D
readerIndex
…
…
D O
,
…
…
O P
	processor
…
…
Q Z
)
…
…
Z [
;
…
…
[ \
}
 
 
 	
public
Ã
Ã
 
virtual
Ã
Ã
 
int
Ã
Ã
 
ForEachByteDesc
Ã
Ã
 *
(
Ã
Ã
* +
int
Ã
Ã
+ .
index
Ã
Ã
/ 4
,
Ã
Ã
4 5
int
Ã
Ã
6 9
length
Ã
Ã
: @
,
Ã
Ã
@ A
IByteProcessor
Ã
Ã
B P
	processor
Ã
Ã
Q Z
)
Ã
Ã
Z [
{
Õ
Õ
 	
this
Œ
Œ
 
.
Œ
Œ
 

CheckIndex
Œ
Œ
 
(
Œ
Œ
 
index
Œ
Œ
 !
,
Œ
Œ
! "
length
Œ
Œ
# )
)
Œ
Œ
) *
;
Œ
Œ
* +
return
œ
œ
 
this
œ
œ
 
.
œ
œ
 
ForEachByteDesc0
œ
œ
 (
(
œ
œ
( )
index
œ
œ
) .
+
œ
œ
/ 0
length
œ
œ
1 7
-
œ
œ
8 9
$num
œ
œ
: ;
,
œ
œ
; <
index
œ
œ
= B
,
œ
œ
B C
	processor
œ
œ
D M
)
œ
œ
M N
;
œ
œ
N O
}
–
–
 	
int
“
“
 
ForEachByteDesc0
“
“
 
(
“
“
 
int
“
“
  
rStart
“
“
! '
,
“
“
' (
int
“
“
) ,
rEnd
“
“
- 1
,
“
“
1 2
IByteProcessor
“
“
3 A
	processor
“
“
B K
)
“
“
K L
{
”
”
 	
for
‘
‘
 
(
‘
‘
 
;
‘
‘
 
rStart
‘
‘
 
>=
‘
‘
 
rEnd
‘
‘
 !
;
‘
‘
! "
--
‘
‘
# %
rStart
‘
‘
% +
)
‘
‘
+ ,
{
’
’
 
if
÷
÷
 
(
÷
÷
 
!
÷
÷
 
	processor
÷
÷
 
.
÷
÷
 
Process
÷
÷
 &
(
÷
÷
& '
this
÷
÷
' +
.
÷
÷
+ ,
_GetByte
÷
÷
, 4
(
÷
÷
4 5
rStart
÷
÷
5 ;
)
÷
÷
; <
)
÷
÷
< =
)
÷
÷
= >
{
◊
◊
 
return
ÿ
ÿ
 
rStart
ÿ
ÿ
 !
;
ÿ
ÿ
! "
}
Ÿ
Ÿ
 
}
⁄
⁄
 
return
‹
‹
 
-
‹
‹
 
$num
‹
‹
 
;
‹
‹
 
}
›
›
 	
public
ﬂ
ﬂ
 
override
ﬂ
ﬂ
 
int
ﬂ
ﬂ
 
GetHashCode
ﬂ
ﬂ
 '
(
ﬂ
ﬂ
' (
)
ﬂ
ﬂ
( )
=>
ﬂ
ﬂ
* ,
ByteBufferUtil
ﬂ
ﬂ
- ;
.
ﬂ
ﬂ
; <
HashCode
ﬂ
ﬂ
< D
(
ﬂ
ﬂ
D E
this
ﬂ
ﬂ
E I
)
ﬂ
ﬂ
I J
;
ﬂ
ﬂ
J K
public
·
·
 
sealed
·
·
 
override
·
·
 
bool
·
·
 #
Equals
·
·
$ *
(
·
·
* +
object
·
·
+ 1
o
·
·
2 3
)
·
·
3 4
=>
·
·
5 7
this
·
·
8 <
.
·
·
< =
Equals
·
·
= C
(
·
·
C D
o
·
·
D E
as
·
·
F H
IByteBuffer
·
·
I T
)
·
·
T U
;
·
·
U V
public
„
„
 
virtual
„
„
 
bool
„
„
 
Equals
„
„
 "
(
„
„
" #
IByteBuffer
„
„
# .
buffer
„
„
/ 5
)
„
„
5 6
=>
„
„
7 9
ReferenceEquals
‰
‰
 
(
‰
‰
 
this
‰
‰
  
,
‰
‰
  !
buffer
‰
‰
" (
)
‰
‰
( )
||
‰
‰
* ,
buffer
‰
‰
- 3
!=
‰
‰
4 6
null
‰
‰
7 ;
&&
‰
‰
< >
ByteBufferUtil
‰
‰
? M
.
‰
‰
M N
Equals
‰
‰
N T
(
‰
‰
T U
this
‰
‰
U Y
,
‰
‰
Y Z
buffer
‰
‰
[ a
)
‰
‰
a b
;
‰
‰
b c
public
Ê
Ê
 
virtual
Ê
Ê
 
int
Ê
Ê
 
	CompareTo
Ê
Ê
 $
(
Ê
Ê
$ %
IByteBuffer
Ê
Ê
% 0
that
Ê
Ê
1 5
)
Ê
Ê
5 6
=>
Ê
Ê
7 9
ByteBufferUtil
Ê
Ê
: H
.
Ê
Ê
H I
Compare
Ê
Ê
I P
(
Ê
Ê
P Q
this
Ê
Ê
Q U
,
Ê
Ê
U V
that
Ê
Ê
W [
)
Ê
Ê
[ \
;
Ê
Ê
\ ]
public
Ë
Ë
 
override
Ë
Ë
 
string
Ë
Ë
 
ToString
Ë
Ë
 '
(
Ë
Ë
' (
)
Ë
Ë
( )
{
È
È
 	
if
Í
Í
 
(
Í
Í
 
this
Í
Í
 
.
Í
Í
 
ReferenceCount
Í
Í
 #
==
Í
Í
$ &
$num
Í
Í
' (
)
Í
Í
( )
{
Î
Î
 
return
Ï
Ï
 

StringUtil
Ï
Ï
 !
.
Ï
Ï
! "
SimpleClassName
Ï
Ï
" 1
(
Ï
Ï
1 2
this
Ï
Ï
2 6
)
Ï
Ï
6 7
+
Ï
Ï
8 9
$str
Ï
Ï
: C
;
Ï
Ï
C D
}
Ì
Ì
 
StringBuilder
Ô
Ô
 
buf
Ô
Ô
 
=
Ô
Ô
 
new
Ô
Ô
  #
StringBuilder
Ô
Ô
$ 1
(
Ô
Ô
1 2
)
Ô
Ô
2 3
.


 
Append


 
(


 

StringUtil


 "
.


" #
SimpleClassName


# 2
(


2 3
this


3 7
)


7 8
)


8 9
.
Ò
Ò
 
Append
Ò
Ò
 
(
Ò
Ò
 
$str
Ò
Ò
 !
)
Ò
Ò
! "
.
Ò
Ò
" #
Append
Ò
Ò
# )
(
Ò
Ò
) *
this
Ò
Ò
* .
.
Ò
Ò
. /
readerIndex
Ò
Ò
/ :
)
Ò
Ò
: ;
.
Ú
Ú
 
Append
Ú
Ú
 
(
Ú
Ú
 
$str
Ú
Ú
 "
)
Ú
Ú
" #
.
Ú
Ú
# $
Append
Ú
Ú
$ *
(
Ú
Ú
* +
this
Ú
Ú
+ /
.
Ú
Ú
/ 0
writerIndex
Ú
Ú
0 ;
)
Ú
Ú
; <
.
Û
Û
 
Append
Û
Û
 
(
Û
Û
 
$str
Û
Û
 !
)
Û
Û
! "
.
Û
Û
" #
Append
Û
Û
# )
(
Û
Û
) *
this
Û
Û
* .
.
Û
Û
. /
Capacity
Û
Û
/ 7
)
Û
Û
7 8
;
Û
Û
8 9
if
Ù
Ù
 
(
Ù
Ù
 
this
Ù
Ù
 
.
Ù
Ù
 
MaxCapacity
Ù
Ù
  
!=
Ù
Ù
! #
int
Ù
Ù
$ '
.
Ù
Ù
' (
MaxValue
Ù
Ù
( 0
)
Ù
Ù
0 1
{
ı
ı
 
buf
ˆ
ˆ
 
.
ˆ
ˆ
 
Append
ˆ
ˆ
 
(
ˆ
ˆ
 
$char
ˆ
ˆ
 
)
ˆ
ˆ
 
.
ˆ
ˆ
  
Append
ˆ
ˆ
  &
(
ˆ
ˆ
& '
this
ˆ
ˆ
' +
.
ˆ
ˆ
+ ,
MaxCapacity
ˆ
ˆ
, 7
)
ˆ
ˆ
7 8
;
ˆ
ˆ
8 9
}
˜
˜
 
IByteBuffer
˘
˘
 
	unwrapped
˘
˘
 !
=
˘
˘
" #
this
˘
˘
$ (
.
˘
˘
( )
Unwrap
˘
˘
) /
(
˘
˘
/ 0
)
˘
˘
0 1
;
˘
˘
1 2
if
˙
˙
 
(
˙
˙
 
	unwrapped
˙
˙
 
!=
˙
˙
 
null
˙
˙
 !
)
˙
˙
! "
{
˚
˚
 
buf
¸
¸
 
.
¸
¸
 
Append
¸
¸
 
(
¸
¸
 
$str
¸
¸
 *
)
¸
¸
* +
.
¸
¸
+ ,
Append
¸
¸
, 2
(
¸
¸
2 3
	unwrapped
¸
¸
3 <
)
¸
¸
< =
;
¸
¸
= >
}
˝
˝
 
buf
˛
˛
 
.
˛
˛
 
Append
˛
˛
 
(
˛
˛
 
$char
˛
˛
 
)
˛
˛
 
;
˛
˛
 
return
ˇ
ˇ
 
buf
ˇ
ˇ
 
.
ˇ
ˇ
 
ToString
ˇ
ˇ
 
(
ˇ
ˇ
  
)
ˇ
ˇ
  !
;
ˇ
ˇ
! "
}
ÄÄ 	
	protected
ÇÇ 
void
ÇÇ 

CheckIndex
ÇÇ !
(
ÇÇ! "
int
ÇÇ" %
index
ÇÇ& +
)
ÇÇ+ ,
=>
ÇÇ- /
this
ÇÇ0 4
.
ÇÇ4 5

CheckIndex
ÇÇ5 ?
(
ÇÇ? @
index
ÇÇ@ E
,
ÇÇE F
$num
ÇÇG H
)
ÇÇH I
;
ÇÇI J
	protected
ÑÑ 
internal
ÑÑ 
void
ÑÑ 

CheckIndex
ÑÑ  *
(
ÑÑ* +
int
ÑÑ+ .
index
ÑÑ/ 4
,
ÑÑ4 5
int
ÑÑ6 9
fieldLength
ÑÑ: E
)
ÑÑE F
{
ÖÖ 	
this
ÜÜ 
.
ÜÜ 
EnsureAccessible
ÜÜ !
(
ÜÜ! "
)
ÜÜ" #
;
ÜÜ# $
this
áá 
.
áá 
CheckIndex0
áá 
(
áá 
index
áá "
,
áá" #
fieldLength
áá$ /
)
áá/ 0
;
áá0 1
}
àà 	
[
ää 	

MethodImpl
ää	 
(
ää 
MethodImplOptions
ää %
.
ää% & 
AggressiveInlining
ää& 8
)
ää8 9
]
ää9 :
	protected
ãã 
void
ãã 
CheckIndex0
ãã "
(
ãã" #
int
ãã# &
index
ãã' ,
,
ãã, -
int
ãã. 1
fieldLength
ãã2 =
)
ãã= >
{
åå 	
if
çç 
(
çç 
MathUtil
çç 
.
çç 
IsOutOfBounds
çç &
(
çç& '
index
çç' ,
,
çç, -
fieldLength
çç. 9
,
çç9 :
this
çç; ?
.
çç? @
Capacity
çç@ H
)
ççH I
)
ççI J
{
éé 
ThrowHelper
èè 
.
èè 1
#ThrowIndexOutOfRangeException_Index
èè ?
(
èè? @
index
èè@ E
,
èèE F
fieldLength
èèG R
,
èèR S
this
èèT X
.
èèX Y
Capacity
èèY a
)
èèa b
;
èèb c
}
êê 
}
ëë 	
[
ìì 	

MethodImpl
ìì	 
(
ìì 
MethodImplOptions
ìì %
.
ìì% & 
AggressiveInlining
ìì& 8
)
ìì8 9
]
ìì9 :
	protected
îî 
void
îî 
CheckSrcIndex
îî $
(
îî$ %
int
îî% (
index
îî) .
,
îî. /
int
îî0 3
length
îî4 :
,
îî: ;
int
îî< ?
srcIndex
îî@ H
,
îîH I
int
îîJ M
srcCapacity
îîN Y
)
îîY Z
{
ïï 	
this
ññ 
.
ññ 

CheckIndex
ññ 
(
ññ 
index
ññ !
,
ññ! "
length
ññ# )
)
ññ) *
;
ññ* +
if
óó 
(
óó 
MathUtil
óó 
.
óó 
IsOutOfBounds
óó &
(
óó& '
srcIndex
óó' /
,
óó/ 0
length
óó1 7
,
óó7 8
srcCapacity
óó9 D
)
óóD E
)
óóE F
{
òò 
ThrowHelper
ôô 
.
ôô 4
&ThrowIndexOutOfRangeException_SrcIndex
ôô B
(
ôôB C
srcIndex
ôôC K
,
ôôK L
length
ôôM S
,
ôôS T
srcCapacity
ôôU `
)
ôô` a
;
ôôa b
}
öö 
}
õõ 	
[
ùù 	

MethodImpl
ùù	 
(
ùù 
MethodImplOptions
ùù %
.
ùù% & 
AggressiveInlining
ùù& 8
)
ùù8 9
]
ùù9 :
	protected
ûû 
void
ûû 
CheckDstIndex
ûû $
(
ûû$ %
int
ûû% (
index
ûû) .
,
ûû. /
int
ûû0 3
length
ûû4 :
,
ûû: ;
int
ûû< ?
dstIndex
ûû@ H
,
ûûH I
int
ûûJ M
dstCapacity
ûûN Y
)
ûûY Z
{
üü 	
this
†† 
.
†† 

CheckIndex
†† 
(
†† 
index
†† !
,
††! "
length
††# )
)
††) *
;
††* +
if
°° 
(
°° 
MathUtil
°° 
.
°° 
IsOutOfBounds
°° &
(
°°& '
dstIndex
°°' /
,
°°/ 0
length
°°1 7
,
°°7 8
dstCapacity
°°9 D
)
°°D E
)
°°E F
{
¢¢ 
ThrowHelper
££ 
.
££ 4
&ThrowIndexOutOfRangeException_DstIndex
££ B
(
££B C
dstIndex
££C K
,
££K L
length
££M S
,
££S T
dstCapacity
££U `
)
££` a
;
££a b
}
§§ 
}
•• 	
	protected
ßß 
void
ßß  
CheckReadableBytes
ßß )
(
ßß) *
int
ßß* -"
minimumReadableBytes
ßß. B
)
ßßB C
{
®® 	
if
©© 
(
©© "
minimumReadableBytes
©© $
<
©©% &
$num
©©' (
)
©©( )
{
™™ 
ThrowHelper
´´ 
.
´´ C
5ThrowArgumentOutOfRangeException_MinimumReadableBytes
´´ Q
(
´´Q R"
minimumReadableBytes
´´R f
)
´´f g
;
´´g h
}
¨¨ 
this
ÆÆ 
.
ÆÆ !
CheckReadableBytes0
ÆÆ $
(
ÆÆ$ %"
minimumReadableBytes
ÆÆ% 9
)
ÆÆ9 :
;
ÆÆ: ;
}
ØØ 	
	protected
±± 
void
±± 
CheckNewCapacity
±± '
(
±±' (
int
±±( +
newCapacity
±±, 7
)
±±7 8
{
≤≤ 	
this
≥≥ 
.
≥≥ 
EnsureAccessible
≥≥ !
(
≥≥! "
)
≥≥" #
;
≥≥# $
if
¥¥ 
(
¥¥ 
newCapacity
¥¥ 
<
¥¥ 
$num
¥¥ 
||
¥¥  "
newCapacity
¥¥# .
>
¥¥/ 0
this
¥¥1 5
.
¥¥5 6
MaxCapacity
¥¥6 A
)
¥¥A B
{
µµ 
ThrowHelper
∂∂ 
.
∂∂ 7
)ThrowArgumentOutOfRangeException_Capacity
∂∂ E
(
∂∂E F
newCapacity
∂∂F Q
,
∂∂Q R
this
∂∂S W
.
∂∂W X
MaxCapacity
∂∂X c
)
∂∂c d
;
∂∂d e
}
∑∑ 
}
∏∏ 	
[
∫∫ 	

MethodImpl
∫∫	 
(
∫∫ 
MethodImplOptions
∫∫ %
.
∫∫% & 
AggressiveInlining
∫∫& 8
)
∫∫8 9
]
∫∫9 :
void
ªª !
CheckReadableBytes0
ªª  
(
ªª  !
int
ªª! $"
minimumReadableBytes
ªª% 9
)
ªª9 :
{
ºº 	
this
ΩΩ 
.
ΩΩ 
EnsureAccessible
ΩΩ !
(
ΩΩ! "
)
ΩΩ" #
;
ΩΩ# $
if
ææ 
(
ææ 
this
ææ 
.
ææ 
readerIndex
ææ  
>
ææ! "
this
ææ# '
.
ææ' (
writerIndex
ææ( 3
-
ææ4 5"
minimumReadableBytes
ææ6 J
)
ææJ K
{
øø 
ThrowHelper
¿¿ 
.
¿¿ 7
)ThrowIndexOutOfRangeException_ReaderIndex
¿¿ E
(
¿¿E F"
minimumReadableBytes
¿¿F Z
,
¿¿Z [
this
¿¿\ `
.
¿¿` a
readerIndex
¿¿a l
,
¿¿l m
this
¿¿n r
.
¿¿r s
writerIndex
¿¿s ~
,
¿¿~ 
this¿¿Ä Ñ
)¿¿Ñ Ö
;¿¿Ö Ü
}
¡¡ 
}
¬¬ 	
[
ƒƒ 	

MethodImpl
ƒƒ	 
(
ƒƒ 
MethodImplOptions
ƒƒ %
.
ƒƒ% & 
AggressiveInlining
ƒƒ& 8
)
ƒƒ8 9
]
ƒƒ9 :
	protected
≈≈ 
void
≈≈ 
EnsureAccessible
≈≈ '
(
≈≈' (
)
≈≈( )
{
∆∆ 	
if
«« 
(
«« 
CheckAccessible
«« 
&&
««  "
this
««# '
.
««' (
ReferenceCount
««( 6
==
««7 9
$num
««: ;
)
««; <
{
»» 
ThrowHelper
…… 
.
…… 1
#ThrowIllegalReferenceCountException
…… ?
(
……? @
$num
……@ A
)
……A B
;
……B C
}
   
}
ÀÀ 	
	protected
ÕÕ 
void
ÕÕ 
	SetIndex0
ÕÕ  
(
ÕÕ  !
int
ÕÕ! $
	readerIdx
ÕÕ% .
,
ÕÕ. /
int
ÕÕ0 3
	writerIdx
ÕÕ4 =
)
ÕÕ= >
{
ŒŒ 	
this
œœ 
.
œœ 
readerIndex
œœ 
=
œœ 
	readerIdx
œœ (
;
œœ( )
this
–– 
.
–– 
writerIndex
–– 
=
–– 
	writerIdx
–– (
;
––( )
}
—— 	
	protected
”” 
void
”” 
DiscardMarks
”” #
(
””# $
)
””$ %
{
‘‘ 	
this
’’ 
.
’’ 
markedReaderIndex
’’ "
=
’’# $
this
’’% )
.
’’) *
markedWriterIndex
’’* ;
=
’’< =
$num
’’> ?
;
’’? @
}
÷÷ 	
public
ÿÿ 
abstract
ÿÿ 
int
ÿÿ 
IoBufferCount
ÿÿ )
{
ÿÿ* +
get
ÿÿ, /
;
ÿÿ/ 0
}
ÿÿ1 2
public
⁄⁄ 
ArraySegment
⁄⁄ 
<
⁄⁄ 
byte
⁄⁄  
>
⁄⁄  !
GetIoBuffer
⁄⁄" -
(
⁄⁄- .
)
⁄⁄. /
=>
⁄⁄0 2
this
⁄⁄3 7
.
⁄⁄7 8
GetIoBuffer
⁄⁄8 C
(
⁄⁄C D
this
⁄⁄D H
.
⁄⁄H I
readerIndex
⁄⁄I T
,
⁄⁄T U
this
⁄⁄V Z
.
⁄⁄Z [
ReadableBytes
⁄⁄[ h
)
⁄⁄h i
;
⁄⁄i j
public
‹‹ 
abstract
‹‹ 
ArraySegment
‹‹ $
<
‹‹$ %
byte
‹‹% )
>
‹‹) *
GetIoBuffer
‹‹+ 6
(
‹‹6 7
int
‹‹7 :
index
‹‹; @
,
‹‹@ A
int
‹‹B E
length
‹‹F L
)
‹‹L M
;
‹‹M N
public
ﬁﬁ 
ArraySegment
ﬁﬁ 
<
ﬁﬁ 
byte
ﬁﬁ  
>
ﬁﬁ  !
[
ﬁﬁ! "
]
ﬁﬁ" #
GetIoBuffers
ﬁﬁ$ 0
(
ﬁﬁ0 1
)
ﬁﬁ1 2
=>
ﬁﬁ3 5
this
ﬁﬁ6 :
.
ﬁﬁ: ;
GetIoBuffers
ﬁﬁ; G
(
ﬁﬁG H
this
ﬁﬁH L
.
ﬁﬁL M
readerIndex
ﬁﬁM X
,
ﬁﬁX Y
this
ﬁﬁZ ^
.
ﬁﬁ^ _
ReadableBytes
ﬁﬁ_ l
)
ﬁﬁl m
;
ﬁﬁm n
public
‡‡ 
abstract
‡‡ 
ArraySegment
‡‡ $
<
‡‡$ %
byte
‡‡% )
>
‡‡) *
[
‡‡* +
]
‡‡+ ,
GetIoBuffers
‡‡- 9
(
‡‡9 :
int
‡‡: =
index
‡‡> C
,
‡‡C D
int
‡‡E H
length
‡‡I O
)
‡‡O P
;
‡‡P Q
public
‚‚ 
abstract
‚‚ 
bool
‚‚ 
HasArray
‚‚ %
{
‚‚& '
get
‚‚( +
;
‚‚+ ,
}
‚‚- .
public
‰‰ 
abstract
‰‰ 
byte
‰‰ 
[
‰‰ 
]
‰‰ 
Array
‰‰ $
{
‰‰% &
get
‰‰' *
;
‰‰* +
}
‰‰, -
public
ÊÊ 
abstract
ÊÊ 
int
ÊÊ 
ArrayOffset
ÊÊ '
{
ÊÊ( )
get
ÊÊ* -
;
ÊÊ- .
}
ÊÊ/ 0
public
ËË 
abstract
ËË 
bool
ËË 
HasMemoryAddress
ËË -
{
ËË. /
get
ËË0 3
;
ËË3 4
}
ËË5 6
public
ÍÍ 
abstract
ÍÍ 
ref
ÍÍ 
byte
ÍÍ  &
GetPinnableMemoryAddress
ÍÍ! 9
(
ÍÍ9 :
)
ÍÍ: ;
;
ÍÍ; <
public
ÏÏ 
abstract
ÏÏ 
IntPtr
ÏÏ #
AddressOfPinnedMemory
ÏÏ 4
(
ÏÏ4 5
)
ÏÏ5 6
;
ÏÏ6 7
public
ÓÓ 
abstract
ÓÓ 
IByteBuffer
ÓÓ #
Unwrap
ÓÓ$ *
(
ÓÓ* +
)
ÓÓ+ ,
;
ÓÓ, -
public
 
abstract
 
bool
 
IsDirect
 %
{
& '
get
( +
;
+ ,
}
- .
public
ÚÚ 
abstract
ÚÚ 
int
ÚÚ 
ReferenceCount
ÚÚ *
{
ÚÚ+ ,
get
ÚÚ- 0
;
ÚÚ0 1
}
ÚÚ2 3
public
ÙÙ 
abstract
ÙÙ 
IReferenceCounted
ÙÙ )
Retain
ÙÙ* 0
(
ÙÙ0 1
)
ÙÙ1 2
;
ÙÙ2 3
public
ˆˆ 
abstract
ˆˆ 
IReferenceCounted
ˆˆ )
Retain
ˆˆ* 0
(
ˆˆ0 1
int
ˆˆ1 4
	increment
ˆˆ5 >
)
ˆˆ> ?
;
ˆˆ? @
public
¯¯ 
abstract
¯¯ 
IReferenceCounted
¯¯ )
Touch
¯¯* /
(
¯¯/ 0
)
¯¯0 1
;
¯¯1 2
public
˙˙ 
abstract
˙˙ 
IReferenceCounted
˙˙ )
Touch
˙˙* /
(
˙˙/ 0
object
˙˙0 6
hint
˙˙7 ;
)
˙˙; <
;
˙˙< =
public
¸¸ 
abstract
¸¸ 
bool
¸¸ 
Release
¸¸ $
(
¸¸$ %
)
¸¸% &
;
¸¸& '
public
˛˛ 
abstract
˛˛ 
bool
˛˛ 
Release
˛˛ $
(
˛˛$ %
int
˛˛% (
	decrement
˛˛) 2
)
˛˛2 3
;
˛˛3 4
}
ˇˇ 
}ÄÄ øë
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class '
AbstractByteBufferAllocator 5
:6 7 
IByteBufferAllocator8 L
{ 
public 
const 
int "
DefaultInitialCapacity /
=0 1
$num2 5
;5 6
public 
const 
int  
DefaultMaxComponents -
=. /
$num0 2
;2 3
public 
const 
int 
DefaultMaxCapacity +
=, -
int. 1
.1 2
MaxValue2 :
;: ;
const 
int 
CalculateThreshold $
=% &
$num' .
*/ 0
$num1 2
;2 3
	protected 
static 
IByteBuffer $
ToLeakAwareBuffer% 6
(6 7
IByteBuffer7 B
bufC F
)F G
{ 	 
IResourceLeakTracker  
leak! %
;% &
switch 
(  
ResourceLeakDetector (
.( )
Level) .
). /
{ 
case  
ResourceLeakDetector )
.) *
DetectionLevel* 8
.8 9
Simple9 ?
:? @
leak 
= 
AbstractByteBuffer -
.- .
LeakDetector. :
.: ;
Track; @
(@ A
bufA D
)D E
;E F
if 
( 
leak 
!= 
null  $
)$ %
{ 
buf 
= 
new !%
SimpleLeakAwareByteBuffer" ;
(; <
buf< ?
,? @
leakA E
)E F
;F G
} 
break   
;   
case!!  
ResourceLeakDetector!! )
.!!) *
DetectionLevel!!* 8
.!!8 9
Advanced!!9 A
:!!A B
case""  
ResourceLeakDetector"" )
."") *
DetectionLevel""* 8
.""8 9
Paranoid""9 A
:""A B
leak## 
=## 
AbstractByteBuffer## -
.##- .
LeakDetector##. :
.##: ;
Track##; @
(##@ A
buf##A D
)##D E
;##E F
if$$ 
($$ 
leak$$ 
!=$$ 
null$$  $
)$$$ %
{%% 
buf&& 
=&& 
new&& !'
AdvancedLeakAwareByteBuffer&&" =
(&&= >
buf&&> A
,&&A B
leak&&C G
)&&G H
;&&H I
}'' 
break(( 
;(( 
case))  
ResourceLeakDetector)) )
.))) *
DetectionLevel))* 8
.))8 9
Disabled))9 A
:))A B
break** 
;** 
default++ 
:++ 
throw,, 
new,, '
ArgumentOutOfRangeException,, 9
(,,9 :
),,: ;
;,,; <
}-- 
return// 
buf// 
;// 
}00 	
	protected22 
static22 
CompositeByteBuffer22 ,
ToLeakAwareBuffer22- >
(22> ?
CompositeByteBuffer22? R
buf22S V
)22V W
{33 	 
IResourceLeakTracker44  
leak44! %
;44% &
switch55 
(55  
ResourceLeakDetector55 (
.55( )
Level55) .
)55. /
{66 
case77  
ResourceLeakDetector77 )
.77) *
DetectionLevel77* 8
.778 9
Simple779 ?
:77? @
leak88 
=88 
AbstractByteBuffer88 -
.88- .
LeakDetector88. :
.88: ;
Track88; @
(88@ A
buf88A D
)88D E
;88E F
if99 
(99 
leak99 
!=99 
null99  $
)99$ %
{:: 
buf;; 
=;; 
new;; !.
"SimpleLeakAwareCompositeByteBuffer;;" D
(;;D E
buf;;E H
,;;H I
leak;;J N
);;N O
;;;O P
}<< 
break== 
;== 
case>>  
ResourceLeakDetector>> )
.>>) *
DetectionLevel>>* 8
.>>8 9
Advanced>>9 A
:>>A B
case??  
ResourceLeakDetector?? )
.??) *
DetectionLevel??* 8
.??8 9
Paranoid??9 A
:??A B
leak@@ 
=@@ 
AbstractByteBuffer@@ -
.@@- .
LeakDetector@@. :
.@@: ;
Track@@; @
(@@@ A
buf@@A D
)@@D E
;@@E F
ifAA 
(AA 
leakAA 
!=AA 
nullAA  $
)AA$ %
{BB 
bufCC 
=CC 
newCC !0
$AdvancedLeakAwareCompositeByteBufferCC" F
(CCF G
bufCCG J
,CCJ K
leakCCL P
)CCP Q
;CCQ R
}DD 
breakEE 
;EE 
caseFF  
ResourceLeakDetectorFF )
.FF) *
DetectionLevelFF* 8
.FF8 9
DisabledFF9 A
:FFA B
breakGG 
;GG 
defaultHH 
:HH 
throwII 
newII '
ArgumentOutOfRangeExceptionII 9
(II9 :
)II: ;
;II; <
}JJ 
returnLL 
bufLL 
;LL 
}MM 	
readonlyOO 
boolOO 
directByDefaultOO %
;OO% &
readonlyPP 
IByteBufferPP 
emptyBufferPP (
;PP( )
	protectedRR '
AbstractByteBufferAllocatorRR -
(RR- .
)RR. /
{SS 	
thisTT 
.TT 
emptyBufferTT 
=TT 
newTT "
EmptyByteBufferTT# 2
(TT2 3
thisTT3 7
)TT7 8
;TT8 9
}UU 	
	protectedWW '
AbstractByteBufferAllocatorWW -
(WW- .
boolWW. 2
preferDirectWW3 ?
)WW? @
{XX 	
thisYY 
.YY 
directByDefaultYY  
=YY! "
preferDirectYY# /
;YY/ 0
thisZZ 
.ZZ 
emptyBufferZZ 
=ZZ 
newZZ "
EmptyByteBufferZZ# 2
(ZZ2 3
thisZZ3 7
)ZZ7 8
;ZZ8 9
}[[ 	
public]] 
IByteBuffer]] 
Buffer]] !
(]]! "
)]]" #
=>]]$ &
this]]' +
.]]+ ,
directByDefault]], ;
?]]< =
this]]> B
.]]B C
DirectBuffer]]C O
(]]O P
)]]P Q
:]]R S
this]]T X
.]]X Y

HeapBuffer]]Y c
(]]c d
)]]d e
;]]e f
public__ 
IByteBuffer__ 
Buffer__ !
(__! "
int__" %
initialCapacity__& 5
)__5 6
=>__7 9
this`` 
.`` 
directByDefault``  
?``! "
this``# '
.``' (
DirectBuffer``( 4
(``4 5
initialCapacity``5 D
)``D E
:``F G
this``H L
.``L M

HeapBuffer``M W
(``W X
initialCapacity``X g
)``g h
;``h i
publicbb 
IByteBufferbb 
Bufferbb !
(bb! "
intbb" %
initialCapacitybb& 5
,bb5 6
intbb7 :
maxCapacitybb; F
)bbF G
=>bbH J
thiscc 
.cc 
directByDefaultcc  
?cc! "
thiscc# '
.cc' (
DirectBuffercc( 4
(cc4 5
initialCapacitycc5 D
,ccD E
maxCapacityccF Q
)ccQ R
:ccS T
thisccU Y
.ccY Z

HeapBufferccZ d
(ccd e
initialCapacitycce t
,cct u
maxCapacity	ccv Å
)
ccÅ Ç
;
ccÇ É
publicee 
IByteBufferee 

HeapBufferee %
(ee% &
)ee& '
=>ee( *
thisee+ /
.ee/ 0

HeapBufferee0 :
(ee: ;"
DefaultInitialCapacityee; Q
,eeQ R
DefaultMaxCapacityeeS e
)eee f
;eef g
publicgg 
IByteBuffergg 

HeapBuffergg %
(gg% &
intgg& )
initialCapacitygg* 9
)gg9 :
=>gg; =
thisgg> B
.ggB C

HeapBufferggC M
(ggM N
initialCapacityggN ]
,gg] ^
DefaultMaxCapacitygg_ q
)ggq r
;ggr s
publicii 
IByteBufferii 

HeapBufferii %
(ii% &
intii& )
initialCapacityii* 9
,ii9 :
intii; >
maxCapacityii? J
)iiJ K
{jj 	
ifkk 
(kk 
initialCapacitykk 
==kk  "
$numkk# $
&&kk% '
maxCapacitykk( 3
==kk4 6
$numkk7 8
)kk8 9
{ll 
returnmm 
thismm 
.mm 
emptyBuffermm '
;mm' (
}nn 
Validatepp 
(pp 
initialCapacitypp $
,pp$ %
maxCapacitypp& 1
)pp1 2
;pp2 3
returnqq 
thisqq 
.qq 
NewHeapBufferqq %
(qq% &
initialCapacityqq& 5
,qq5 6
maxCapacityqq7 B
)qqB C
;qqC D
}rr 	
publictt 
unsafett 
IByteBuffertt !
DirectBuffertt" .
(tt. /
)tt/ 0
=>tt1 3
thistt4 8
.tt8 9
DirectBuffertt9 E
(ttE F"
DefaultInitialCapacityttF \
,tt\ ]
DefaultMaxCapacitytt^ p
)ttp q
;ttq r
publicvv 
unsafevv 
IByteBuffervv !
DirectBuffervv" .
(vv. /
intvv/ 2
initialCapacityvv3 B
)vvB C
=>vvD F
thisvvG K
.vvK L
DirectBuffervvL X
(vvX Y
initialCapacityvvY h
,vvh i
DefaultMaxCapacityvvj |
)vv| }
;vv} ~
publicxx 
unsafexx 
IByteBufferxx !
DirectBufferxx" .
(xx. /
intxx/ 2
initialCapacityxx3 B
,xxB C
intxxD G
maxCapacityxxH S
)xxS T
{yy 	
ifzz 
(zz 
initialCapacityzz 
==zz  "
$numzz# $
&&zz% '
maxCapacityzz( 3
==zz4 6
$numzz7 8
)zz8 9
{{{ 
return|| 
this|| 
.|| 
emptyBuffer|| '
;||' (
}}} 
Validate~~ 
(~~ 
initialCapacity~~ $
,~~$ %
maxCapacity~~& 1
)~~1 2
;~~2 3
return 
this 
. 
NewDirectBuffer '
(' (
initialCapacity( 7
,7 8
maxCapacity9 D
)D E
;E F
}
ÄÄ 	
public
ÇÇ !
CompositeByteBuffer
ÇÇ "
CompositeBuffer
ÇÇ# 2
(
ÇÇ2 3
)
ÇÇ3 4
=>
ÇÇ5 7
this
ÉÉ 
.
ÉÉ 
directByDefault
ÉÉ  
?
ÉÉ! "
this
ÉÉ# '
.
ÉÉ' (#
CompositeDirectBuffer
ÉÉ( =
(
ÉÉ= >
)
ÉÉ> ?
:
ÉÉ@ A
this
ÉÉB F
.
ÉÉF G!
CompositeHeapBuffer
ÉÉG Z
(
ÉÉZ [
)
ÉÉ[ \
;
ÉÉ\ ]
public
ÖÖ !
CompositeByteBuffer
ÖÖ "
CompositeBuffer
ÖÖ# 2
(
ÖÖ2 3
int
ÖÖ3 6
maxComponents
ÖÖ7 D
)
ÖÖD E
=>
ÖÖF H
this
ÜÜ 
.
ÜÜ 
directByDefault
ÜÜ  
?
ÜÜ! "
this
ÜÜ# '
.
ÜÜ' (#
CompositeDirectBuffer
ÜÜ( =
(
ÜÜ= >
maxComponents
ÜÜ> K
)
ÜÜK L
:
ÜÜM N
this
ÜÜO S
.
ÜÜS T!
CompositeHeapBuffer
ÜÜT g
(
ÜÜg h
maxComponents
ÜÜh u
)
ÜÜu v
;
ÜÜv w
public
àà !
CompositeByteBuffer
àà "!
CompositeHeapBuffer
àà# 6
(
àà6 7
)
àà7 8
=>
àà9 ;
this
àà< @
.
àà@ A!
CompositeHeapBuffer
ààA T
(
ààT U"
DefaultMaxComponents
ààU i
)
àài j
;
ààj k
public
ää 
virtual
ää !
CompositeByteBuffer
ää *!
CompositeHeapBuffer
ää+ >
(
ää> ?
int
ää? B
maxNumComponents
ääC S
)
ääS T
=>
ääU W
ToLeakAwareBuffer
ãã 
(
ãã 
new
ãã !!
CompositeByteBuffer
ãã" 5
(
ãã5 6
this
ãã6 :
,
ãã: ;
false
ãã< A
,
ããA B
maxNumComponents
ããC S
)
ããS T
)
ããT U
;
ããU V
public
çç 
unsafe
çç !
CompositeByteBuffer
çç )#
CompositeDirectBuffer
çç* ?
(
çç? @
)
çç@ A
=>
ççB D
this
ççE I
.
ççI J#
CompositeDirectBuffer
ççJ _
(
çç_ `"
DefaultMaxComponents
çç` t
)
ççt u
;
ççu v
public
èè 
unsafe
èè 
virtual
èè !
CompositeByteBuffer
èè 1#
CompositeDirectBuffer
èè2 G
(
èèG H
int
èèH K
maxNumComponents
èèL \
)
èè\ ]
=>
èè^ `
ToLeakAwareBuffer
êê 
(
êê 
new
êê !!
CompositeByteBuffer
êê" 5
(
êê5 6
this
êê6 :
,
êê: ;
true
êê< @
,
êê@ A
maxNumComponents
êêB R
)
êêR S
)
êêS T
;
êêT U
[
íí 	

MethodImpl
íí	 
(
íí 
MethodImplOptions
íí %
.
íí% & 
AggressiveInlining
íí& 8
)
íí8 9
]
íí9 :
static
ìì 
void
ìì 
Validate
ìì 
(
ìì 
int
ìì  
initialCapacity
ìì! 0
,
ìì0 1
int
ìì2 5
maxCapacity
ìì6 A
)
ììA B
{
îî 	
if
ïï 
(
ïï 
initialCapacity
ïï 
<
ïï  !
$num
ïï" #
)
ïï# $
{
ññ 
ThrowHelper
óó 
.
óó >
0ThrowArgumentOutOfRangeException_InitialCapacity
óó L
(
óóL M
)
óóM N
;
óóN O
}
òò 
if
öö 
(
öö 
initialCapacity
öö 
>
öö  !
maxCapacity
öö" -
)
öö- .
{
õõ 
ThrowHelper
úú 
.
úú >
0ThrowArgumentOutOfRangeException_InitialCapacity
úú L
(
úúL M
initialCapacity
úúM \
,
úú\ ]
maxCapacity
úú^ i
)
úúi j
;
úúj k
}
ùù 
}
ûû 	
	protected
†† 
abstract
†† 
IByteBuffer
†† &
NewHeapBuffer
††' 4
(
††4 5
int
††5 8
initialCapacity
††9 H
,
††H I
int
††J M
maxCapacity
††N Y
)
††Y Z
;
††Z [
	protected
¢¢ 
unsafe
¢¢ 
abstract
¢¢ !
IByteBuffer
¢¢" -
NewDirectBuffer
¢¢. =
(
¢¢= >
int
¢¢> A
initialCapacity
¢¢B Q
,
¢¢Q R
int
¢¢S V
maxCapacity
¢¢W b
)
¢¢b c
;
¢¢c d
public
§§ 
abstract
§§ 
bool
§§ "
IsDirectBufferPooled
§§ 1
{
§§2 3
get
§§4 7
;
§§7 8
}
§§9 :
public
¶¶ 
int
¶¶ "
CalculateNewCapacity
¶¶ '
(
¶¶' (
int
¶¶( +
minNewCapacity
¶¶, :
,
¶¶: ;
int
¶¶< ?
maxCapacity
¶¶@ K
)
¶¶K L
{
ßß 	
if
®® 
(
®® 
minNewCapacity
®® 
<
®®  
$num
®®! "
)
®®" #
{
©© 
ThrowHelper
™™ 
.
™™ =
/ThrowArgumentOutOfRangeException_MinNewCapacity
™™ K
(
™™K L
minNewCapacity
™™L Z
)
™™Z [
;
™™[ \
}
´´ 
if
¨¨ 
(
¨¨ 
minNewCapacity
¨¨ 
>
¨¨  
maxCapacity
¨¨! ,
)
¨¨, -
{
≠≠ 
ThrowHelper
ÆÆ 
.
ÆÆ :
,ThrowArgumentOutOfRangeException_MaxCapacity
ÆÆ H
(
ÆÆH I
minNewCapacity
ÆÆI W
,
ÆÆW X
maxCapacity
ÆÆY d
)
ÆÆd e
;
ÆÆe f
}
ØØ 
const
±± 
int
±± 
	Threshold
±± 
=
±±  ! 
CalculateThreshold
±±" 4
;
±±4 5
if
≤≤ 
(
≤≤ 
minNewCapacity
≤≤ 
==
≤≤ ! 
CalculateThreshold
≤≤" 4
)
≤≤4 5
{
≥≥ 
return
¥¥ 
	Threshold
¥¥  
;
¥¥  !
}
µµ 
int
∑∑ 
newCapacity
∑∑ 
;
∑∑ 
if
ππ 
(
ππ 
minNewCapacity
ππ 
>
ππ  
	Threshold
ππ! *
)
ππ* +
{
∫∫ 
newCapacity
ªª 
=
ªª 
minNewCapacity
ªª ,
/
ªª- .
	Threshold
ªª/ 8
*
ªª9 :
	Threshold
ªª; D
;
ªªD E
if
ºº 
(
ºº 
newCapacity
ºº 
>
ºº  !
maxCapacity
ºº" -
-
ºº. /
	Threshold
ºº0 9
)
ºº9 :
{
ΩΩ 
newCapacity
ææ 
=
ææ  !
maxCapacity
ææ" -
;
ææ- .
}
øø 
else
¿¿ 
{
¡¡ 
newCapacity
¬¬ 
+=
¬¬  "
	Threshold
¬¬# ,
;
¬¬, -
}
√√ 
return
≈≈ 
newCapacity
≈≈ "
;
≈≈" #
}
∆∆ 
newCapacity
…… 
=
…… 
$num
…… 
;
…… 
while
   
(
   
newCapacity
   
<
    
minNewCapacity
  ! /
)
  / 0
{
ÀÀ 
newCapacity
ÃÃ 
<<=
ÃÃ 
$num
ÃÃ  !
;
ÃÃ! "
}
ÕÕ 
return
œœ 
Math
œœ 
.
œœ 
Min
œœ 
(
œœ 
newCapacity
œœ '
,
œœ' (
maxCapacity
œœ) 4
)
œœ4 5
;
œœ5 6
}
–– 	
}
—— 
}““ ﬂ/
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractDerivedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class %
AbstractDerivedByteBuffer 3
:4 5
AbstractByteBuffer6 H
{ 
	protected %
AbstractDerivedByteBuffer +
(+ ,
int, /
maxCapacity0 ;
); <
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
sealed 
override 
int "
ReferenceCount# 1
=>2 4
this5 9
.9 :
ReferenceCount0: I
(I J
)J K
;K L
	protected 
virtual 
int 
ReferenceCount0 -
(- .
). /
=>0 2
this3 7
.7 8
Unwrap8 >
(> ?
)? @
.@ A
ReferenceCountA O
;O P
public 
sealed 
override 
IReferenceCounted 0
Retain1 7
(7 8
)8 9
=>: <
this= A
.A B
Retain0B I
(I J
)J K
;K L
	protected 
virtual 
IByteBuffer %
Retain0& -
(- .
). /
{ 	
this 
. 
Unwrap 
( 
) 
. 
Retain  
(  !
)! "
;" #
return 
this 
; 
} 	
public!! 
sealed!! 
override!! 
IReferenceCounted!! 0
Retain!!1 7
(!!7 8
int!!8 ;
	increment!!< E
)!!E F
=>!!G I
this!!J N
.!!N O
Retain0!!O V
(!!V W
	increment!!W `
)!!` a
;!!a b
	protected## 
virtual## 
IByteBuffer## %
Retain0##& -
(##- .
int##. 1
	increment##2 ;
)##; <
{$$ 	
this%% 
.%% 
Unwrap%% 
(%% 
)%% 
.%% 
Retain%%  
(%%  !
	increment%%! *
)%%* +
;%%+ ,
return&& 
this&& 
;&& 
}'' 	
public)) 
sealed)) 
override)) 
IReferenceCounted)) 0
Touch))1 6
())6 7
)))7 8
=>))9 ;
this))< @
.))@ A
Touch0))A G
())G H
)))H I
;))I J
	protected++ 
virtual++ 
IByteBuffer++ %
Touch0++& ,
(++, -
)++- .
{,, 	
this-- 
.-- 
Unwrap-- 
(-- 
)-- 
.-- 
Touch-- 
(--  
)--  !
;--! "
return.. 
this.. 
;.. 
}// 	
public11 
sealed11 
override11 
IReferenceCounted11 0
Touch111 6
(116 7
object117 =
hint11> B
)11B C
=>11D F
this11G K
.11K L
Touch011L R
(11R S
hint11S W
)11W X
;11X Y
	protected33 
virtual33 
IByteBuffer33 %
Touch033& ,
(33, -
object33- 3
hint334 8
)338 9
{44 	
this55 
.55 
Unwrap55 
(55 
)55 
.55 
Touch55 
(55  
hint55  $
)55$ %
;55% &
return66 
this66 
;66 
}77 	
public99 
sealed99 
override99 
bool99 #
Release99$ +
(99+ ,
)99, -
=>99. 0
this991 5
.995 6
Release0996 >
(99> ?
)99? @
;99@ A
	protected;; 
virtual;; 
bool;; 
Release0;; '
(;;' (
);;( )
=>;;* ,
this;;- 1
.;;1 2
Unwrap;;2 8
(;;8 9
);;9 :
.;;: ;
Release;;; B
(;;B C
);;C D
;;;D E
public== 
sealed== 
override== 
bool== #
Release==$ +
(==+ ,
int==, /
	decrement==0 9
)==9 :
=>==; =
this==> B
.==B C
Release0==C K
(==K L
	decrement==L U
)==U V
;==V W
	protected?? 
virtual?? 
bool?? 
Release0?? '
(??' (
int??( +
	decrement??, 5
)??5 6
=>??7 9
this??: >
.??> ?
Unwrap??? E
(??E F
)??F G
.??G H
Release??H O
(??O P
	decrement??P Y
)??Y Z
;??Z [
publicAA 
overrideAA 
ArraySegmentAA $
<AA$ %
byteAA% )
>AA) *
GetIoBufferAA+ 6
(AA6 7
intAA7 :
indexAA; @
,AA@ A
intAAB E
lengthAAF L
)AAL M
=>AAN P
thisAAQ U
.AAU V
UnwrapAAV \
(AA\ ]
)AA] ^
.AA^ _
GetIoBufferAA_ j
(AAj k
indexAAk p
,AAp q
lengthAAr x
)AAx y
;AAy z
publicCC 
overrideCC 
ArraySegmentCC $
<CC$ %
byteCC% )
>CC) *
[CC* +
]CC+ ,
GetIoBuffersCC- 9
(CC9 :
intCC: =
indexCC> C
,CCC D
intCCE H
lengthCCI O
)CCO P
=>CCQ S
thisCCT X
.CCX Y
UnwrapCCY _
(CC_ `
)CC` a
.CCa b
GetIoBuffersCCb n
(CCn o
indexCCo t
,CCt u
lengthCCv |
)CC| }
;CC} ~
}EE 
}FF »£
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractPooledDerivedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract

 
class

 +
AbstractPooledDerivedByteBuffer

 2
:

3 4.
"AbstractReferenceCountedByteBuffer

5 W
{ 
readonly 
ThreadLocalPool  
.  !
Handle! '
recyclerHandle( 6
;6 7
AbstractByteBuffer 

rootParent %
;% &
IByteBuffer 
parent 
; 
	protected +
AbstractPooledDerivedByteBuffer 1
(1 2
ThreadLocalPool2 A
.A B
HandleB H
recyclerHandleI W
)W X
: 
base 
( 
$num 
) 
{ 	
this 
. 
recyclerHandle 
=  !
recyclerHandle" 0
;0 1
} 	
internal 
void 
Parent 
( 
IByteBuffer (
	newParent) 2
)2 3
{ 	
Debug 
. 
Assert 
( 
	newParent "
is# %%
SimpleLeakAwareByteBuffer& ?
)? @
;@ A
this   
.   
parent   
=   
	newParent   #
;  # $
}!! 	
public## 
sealed## 
override## 
IByteBuffer## *
Unwrap##+ 1
(##1 2
)##2 3
=>##4 6
this##7 ;
.##; <

UnwrapCore##< F
(##F G
)##G H
;##H I
	protected%% 
AbstractByteBuffer%% $

UnwrapCore%%% /
(%%/ 0
)%%0 1
=>%%2 4
this%%5 9
.%%9 :

rootParent%%: D
;%%D E
internal'' 
T'' 
Init'' 
<'' 
T'' 
>'' 
('' 
AbstractByteBuffer(( 
	unwrapped(( (
,((( )
IByteBuffer((* 5
wrapped((6 =
,((= >
int((? B
readerIndex((C N
,((N O
int((P S
writerIndex((T _
,((_ `
int((a d
maxCapacity((e p
)((p q
where)) 
T)) 
:)) +
AbstractPooledDerivedByteBuffer)) 5
{** 	
wrapped++ 
.++ 
Retain++ 
(++ 
)++ 
;++ 
this,, 
.,, 
parent,, 
=,, 
wrapped,, !
;,,! "
this-- 
.-- 

rootParent-- 
=-- 
	unwrapped-- '
;--' (
try// 
{00 
this11 
.11 
SetMaxCapacity11 #
(11# $
maxCapacity11$ /
)11/ 0
;110 1
this22 
.22 
	SetIndex022 
(22 
readerIndex22 *
,22* +
writerIndex22, 7
)227 8
;228 9
this33 
.33 
SetReferenceCount33 &
(33& '
$num33' (
)33( )
;33) *
wrapped55 
=55 
null55 
;55 
return66 
(66 
T66 
)66 
this66 
;66 
}77 
finally88 
{99 
if:: 
(:: 
wrapped:: 
!=:: 
null:: #
)::# $
{;; 
this<< 
.<< 
parent<< 
=<<  !
this<<" &
.<<& '

rootParent<<' 1
=<<2 3
null<<4 8
;<<8 9
wrapped== 
.== 
Release== #
(==# $
)==$ %
;==% &
}>> 
}?? 
}@@ 	
	protectedBB 
internalBB 
sealedBB !
overrideBB" *
voidBB+ /

DeallocateBB0 :
(BB: ;
)BB; <
{CC 	
IByteBufferGG 
	parentBufGG !
=GG" #
thisGG$ (
.GG( )
parentGG) /
;GG/ 0
thisHH 
.HH 
recyclerHandleHH 
.HH  
ReleaseHH  '
(HH' (
thisHH( ,
)HH, -
;HH- .
	parentBufII 
.II 
ReleaseII 
(II 
)II 
;II  
}JJ 	
publicLL 
sealedLL 
overrideLL  
IByteBufferAllocatorLL 3
	AllocatorLL4 =
=>LL> @
thisLLA E
.LLE F
UnwrapLLF L
(LLL M
)LLM N
.LLN O
	AllocatorLLO X
;LLX Y
publicNN 
sealedNN 
overrideNN 
boolNN #
IsDirectNN$ ,
=>NN- /
thisNN0 4
.NN4 5
UnwrapNN5 ;
(NN; <
)NN< =
.NN= >
IsDirectNN> F
;NNF G
publicPP 
overridePP 
boolPP 
HasArrayPP %
=>PP& (
thisPP) -
.PP- .
UnwrapPP. 4
(PP4 5
)PP5 6
.PP6 7
HasArrayPP7 ?
;PP? @
publicRR 
overrideRR 
byteRR 
[RR 
]RR 
ArrayRR $
=>RR% '
thisRR( ,
.RR, -
UnwrapRR- 3
(RR3 4
)RR4 5
.RR5 6
ArrayRR6 ;
;RR; <
publicTT 
overrideTT 
boolTT 
HasMemoryAddressTT -
=>TT. 0
thisTT1 5
.TT5 6
UnwrapTT6 <
(TT< =
)TT= >
.TT> ?
HasMemoryAddressTT? O
;TTO P
publicVV 
sealedVV 
overrideVV 
intVV "
IoBufferCountVV# 0
=>VV1 3
thisVV4 8
.VV8 9
UnwrapVV9 ?
(VV? @
)VV@ A
.VVA B
IoBufferCountVVB O
;VVO P
publicXX 
sealedXX 
overrideXX 
IByteBufferXX *
RetainedSliceXX+ 8
(XX8 9
)XX9 :
{YY 	
intZZ 
indexZZ 
=ZZ 
thisZZ 
.ZZ 
ReaderIndexZZ (
;ZZ( )
return[[ 
base[[ 
.[[ 
RetainedSlice[[ %
([[% &
index[[& +
,[[+ ,
this[[- 1
.[[1 2
WriterIndex[[2 =
-[[> ?
index[[@ E
)[[E F
;[[F G
}\\ 	
public^^ 
override^^ 
IByteBuffer^^ #
Slice^^$ )
(^^) *
int^^* -
index^^. 3
,^^3 4
int^^5 8
length^^9 ?
)^^? @
{__ 	
returnaa 
newaa -
!PooledNonRetainedSlicedByteBufferaa 8
(aa8 9
thisaa9 =
,aa= >
(aa? @
AbstractByteBufferaa@ R
)aaR S
thisaaS W
.aaW X
UnwrapaaX ^
(aa^ _
)aa_ `
,aa` a
indexaab g
,aag h
lengthaai o
)aao p
;aap q
}bb 	
	protecteddd 
IByteBufferdd 

Duplicate0dd (
(dd( )
)dd) *
{ee 	
returngg 
newgg 0
$PooledNonRetainedDuplicateByteBuffergg ;
(gg; <
thisgg< @
,gg@ A
(ggB C
AbstractByteBufferggC U
)ggU V
thisggV Z
.ggZ [
Unwrapgg[ a
(gga b
)ggb c
)ggc d
;ggd e
}hh 	
sealedjj 
classjj 0
$PooledNonRetainedDuplicateByteBufferjj 9
:jj: ;(
UnpooledDuplicatedByteBufferjj< X
{kk 	
readonlyll 
IReferenceCountedll &"
referenceCountDelegatell' =
;ll= >
internalnn 0
$PooledNonRetainedDuplicateByteBuffernn 9
(nn9 :
IReferenceCountednn: K"
referenceCountDelegatennL b
,nnb c
AbstractByteBuffernnd v
buffernnw }
)nn} ~
:oo 
baseoo 
(oo 
bufferoo 
)oo 
{pp 
thisqq 
.qq "
referenceCountDelegateqq +
=qq, -"
referenceCountDelegateqq. D
;qqD E
}rr 
	protectedtt 
overridett 
inttt "
ReferenceCount0tt# 2
(tt2 3
)tt3 4
=>tt5 7
thistt8 <
.tt< ="
referenceCountDelegatett= S
.ttS T
ReferenceCountttT b
;ttb c
	protectedvv 
overridevv 
IByteBuffervv *
Retain0vv+ 2
(vv2 3
)vv3 4
{ww 
thisxx 
.xx "
referenceCountDelegatexx +
.xx+ ,
Retainxx, 2
(xx2 3
)xx3 4
;xx4 5
returnyy 
thisyy 
;yy 
}zz 
	protected|| 
override|| 
IByteBuffer|| *
Retain0||+ 2
(||2 3
int||3 6
	increment||7 @
)||@ A
{}} 
this~~ 
.~~ "
referenceCountDelegate~~ +
.~~+ ,
Retain~~, 2
(~~2 3
	increment~~3 <
)~~< =
;~~= >
return 
this 
; 
}
ÄÄ 
	protected
ÇÇ 
override
ÇÇ 
IByteBuffer
ÇÇ *
Touch0
ÇÇ+ 1
(
ÇÇ1 2
)
ÇÇ2 3
{
ÉÉ 
this
ÑÑ 
.
ÑÑ $
referenceCountDelegate
ÑÑ +
.
ÑÑ+ ,
Touch
ÑÑ, 1
(
ÑÑ1 2
)
ÑÑ2 3
;
ÑÑ3 4
return
ÖÖ 
this
ÖÖ 
;
ÖÖ 
}
ÜÜ 
	protected
àà 
override
àà 
IByteBuffer
àà *
Touch0
àà+ 1
(
àà1 2
object
àà2 8
hint
àà9 =
)
àà= >
{
ââ 
this
ää 
.
ää $
referenceCountDelegate
ää +
.
ää+ ,
Touch
ää, 1
(
ää1 2
hint
ää2 6
)
ää6 7
;
ää7 8
return
ãã 
this
ãã 
;
ãã 
}
åå 
	protected
éé 
override
éé 
bool
éé #
Release0
éé$ ,
(
éé, -
)
éé- .
=>
éé/ 1
this
éé2 6
.
éé6 7$
referenceCountDelegate
éé7 M
.
ééM N
Release
ééN U
(
ééU V
)
ééV W
;
ééW X
	protected
êê 
override
êê 
bool
êê #
Release0
êê$ ,
(
êê, -
int
êê- 0
	decrement
êê1 :
)
êê: ;
=>
êê< >
this
êê? C
.
êêC D$
referenceCountDelegate
êêD Z
.
êêZ [
Release
êê[ b
(
êêb c
	decrement
êêc l
)
êêl m
;
êêm n
public
íí 
override
íí 
IByteBuffer
íí '
	Duplicate
íí( 1
(
íí1 2
)
íí2 3
=>
íí4 6
new
íí7 :2
$PooledNonRetainedDuplicateByteBuffer
íí; _
(
íí_ `
this
íí` d
.
ííd e$
referenceCountDelegate
ííe {
,
íí{ |
thisíí} Å
)ííÅ Ç
;ííÇ É
public
îî 
override
îî 
IByteBuffer
îî '
RetainedDuplicate
îî( 9
(
îî9 :
)
îî: ;
=>
îî< >(
PooledDuplicatedByteBuffer
îî? Y
.
îîY Z
NewInstance
îîZ e
(
îîe f
this
îîf j
.
îîj k

UnwrapCore
îîk u
(
îîu v
)
îîv w
,
îîw x
this
îîy }
,
îî} ~
thisîî É
.îîÉ Ñ
ReaderIndexîîÑ è
,îîè ê
thisîîë ï
.îîï ñ
WriterIndexîîñ °
)îî° ¢
;îî¢ £
public
ññ 
override
ññ 
IByteBuffer
ññ '
Slice
ññ( -
(
ññ- .
int
ññ. 1
index
ññ2 7
,
ññ7 8
int
ññ9 <
length
ññ= C
)
ññC D
{
óó 
this
òò 
.
òò 
CheckIndex0
òò  
(
òò  !
index
òò! &
,
òò& '
length
òò( .
)
òò. /
;
òò/ 0
return
ôô 
new
ôô /
!PooledNonRetainedSlicedByteBuffer
ôô <
(
ôô< =
this
ôô= A
.
ôôA B$
referenceCountDelegate
ôôB X
,
ôôX Y
(
ôôZ [ 
AbstractByteBuffer
ôô[ m
)
ôôm n
this
ôôn r
.
ôôr s
Unwrap
ôôs y
(
ôôy z
)
ôôz {
,
ôô{ |
indexôô} Ç
,ôôÇ É
lengthôôÑ ä
)ôôä ã
;ôôã å
}
öö 
public
ùù 
override
ùù 
IByteBuffer
ùù '
RetainedSlice
ùù( 5
(
ùù5 6
)
ùù6 7
=>
ùù8 :
this
ùù; ?
.
ùù? @
RetainedSlice
ùù@ M
(
ùùM N
this
ùùN R
.
ùùR S
ReaderIndex
ùùS ^
,
ùù^ _
this
ùù` d
.
ùùd e
Capacity
ùùe m
)
ùùm n
;
ùùn o
public
üü 
override
üü 
IByteBuffer
üü '
RetainedSlice
üü( 5
(
üü5 6
int
üü6 9
index
üü: ?
,
üü? @
int
üüA D
length
üüE K
)
üüK L
=>
üüM O$
PooledSlicedByteBuffer
üüP f
.
üüf g
NewInstance
üüg r
(
üür s
this
üüs w
.
üüw x

UnwrapCoreüüx Ç
(üüÇ É
)üüÉ Ñ
,üüÑ Ö
thisüüÜ ä
,üüä ã
indexüüå ë
,üüë í
lengthüüì ô
)üüô ö
;üüö õ
}
†† 	
sealed
¢¢ 
class
¢¢ /
!PooledNonRetainedSlicedByteBuffer
¢¢ 6
:
¢¢7 8&
UnpooledSlicedByteBuffer
¢¢9 Q
{
££ 	
readonly
§§ 
IReferenceCounted
§§ &$
referenceCountDelegate
§§' =
;
§§= >
public
¶¶ /
!PooledNonRetainedSlicedByteBuffer
¶¶ 4
(
¶¶4 5
IReferenceCounted
¶¶5 F$
referenceCountDelegate
¶¶G ]
,
¶¶] ^ 
AbstractByteBuffer
¶¶_ q
buffer
¶¶r x
,
¶¶x y
int
¶¶z }
index¶¶~ É
,¶¶É Ñ
int¶¶Ö à
length¶¶â è
)¶¶è ê
:
ßß 
base
ßß 
(
ßß 
buffer
ßß 
,
ßß 
index
ßß $
,
ßß$ %
length
ßß& ,
)
ßß, -
{
®® 
this
©© 
.
©© $
referenceCountDelegate
©© +
=
©©, -$
referenceCountDelegate
©©. D
;
©©D E
}
™™ 
	protected
¨¨ 
override
¨¨ 
int
¨¨ "
ReferenceCount0
¨¨# 2
(
¨¨2 3
)
¨¨3 4
=>
¨¨5 7
this
¨¨8 <
.
¨¨< =$
referenceCountDelegate
¨¨= S
.
¨¨S T
ReferenceCount
¨¨T b
;
¨¨b c
	protected
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ *
Retain0
ÆÆ+ 2
(
ÆÆ2 3
)
ÆÆ3 4
{
ØØ 
this
∞∞ 
.
∞∞ $
referenceCountDelegate
∞∞ +
.
∞∞+ ,
Retain
∞∞, 2
(
∞∞2 3
)
∞∞3 4
;
∞∞4 5
return
±± 
this
±± 
;
±± 
}
≤≤ 
	protected
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ *
Retain0
¥¥+ 2
(
¥¥2 3
int
¥¥3 6
	increment
¥¥7 @
)
¥¥@ A
{
µµ 
this
∂∂ 
.
∂∂ $
referenceCountDelegate
∂∂ +
.
∂∂+ ,
Retain
∂∂, 2
(
∂∂2 3
	increment
∂∂3 <
)
∂∂< =
;
∂∂= >
return
∑∑ 
this
∑∑ 
;
∑∑ 
}
∏∏ 
	protected
∫∫ 
override
∫∫ 
IByteBuffer
∫∫ *
Touch0
∫∫+ 1
(
∫∫1 2
)
∫∫2 3
{
ªª 
this
ºº 
.
ºº $
referenceCountDelegate
ºº +
.
ºº+ ,
Touch
ºº, 1
(
ºº1 2
)
ºº2 3
;
ºº3 4
return
ΩΩ 
this
ΩΩ 
;
ΩΩ 
}
ææ 
	protected
¿¿ 
override
¿¿ 
IByteBuffer
¿¿ *
Touch0
¿¿+ 1
(
¿¿1 2
object
¿¿2 8
hint
¿¿9 =
)
¿¿= >
{
¡¡ 
this
¬¬ 
.
¬¬ $
referenceCountDelegate
¬¬ +
.
¬¬+ ,
Touch
¬¬, 1
(
¬¬1 2
hint
¬¬2 6
)
¬¬6 7
;
¬¬7 8
return
√√ 
this
√√ 
;
√√ 
}
ƒƒ 
	protected
∆∆ 
override
∆∆ 
bool
∆∆ #
Release0
∆∆$ ,
(
∆∆, -
)
∆∆- .
=>
∆∆/ 1
this
∆∆2 6
.
∆∆6 7$
referenceCountDelegate
∆∆7 M
.
∆∆M N
Release
∆∆N U
(
∆∆U V
)
∆∆V W
;
∆∆W X
	protected
»» 
override
»» 
bool
»» #
Release0
»»$ ,
(
»», -
int
»»- 0
	decrement
»»1 :
)
»»: ;
=>
»»< >
this
»»? C
.
»»C D$
referenceCountDelegate
»»D Z
.
»»Z [
Release
»»[ b
(
»»b c
	decrement
»»c l
)
»»l m
;
»»m n
public
   
override
   
IByteBuffer
   '
	Duplicate
  ( 1
(
  1 2
)
  2 3
=>
  4 6
new
ÀÀ 2
$PooledNonRetainedDuplicateByteBuffer
ÀÀ 8
(
ÀÀ8 9
this
ÀÀ9 =
.
ÀÀ= >$
referenceCountDelegate
ÀÀ> T
,
ÀÀT U
this
ÀÀV Z
.
ÀÀZ [

UnwrapCore
ÀÀ[ e
(
ÀÀe f
)
ÀÀf g
)
ÀÀg h
.
ÃÃ 
SetIndex
ÃÃ 
(
ÃÃ 
this
ÃÃ "
.
ÃÃ" #
Idx
ÃÃ# &
(
ÃÃ& '
this
ÃÃ' +
.
ÃÃ+ ,
ReaderIndex
ÃÃ, 7
)
ÃÃ7 8
,
ÃÃ8 9
this
ÃÃ: >
.
ÃÃ> ?
Idx
ÃÃ? B
(
ÃÃB C
this
ÃÃC G
.
ÃÃG H
WriterIndex
ÃÃH S
)
ÃÃS T
)
ÃÃT U
;
ÃÃU V
public
ŒŒ 
override
ŒŒ 
IByteBuffer
ŒŒ '
RetainedDuplicate
ŒŒ( 9
(
ŒŒ9 :
)
ŒŒ: ;
=>
ŒŒ< >(
PooledDuplicatedByteBuffer
ŒŒ? Y
.
ŒŒY Z
NewInstance
ŒŒZ e
(
ŒŒe f
this
ŒŒf j
.
ŒŒj k

UnwrapCore
ŒŒk u
(
ŒŒu v
)
ŒŒv w
,
ŒŒw x
this
ŒŒy }
,
ŒŒ} ~
thisŒŒ É
.ŒŒÉ Ñ
IdxŒŒÑ á
(ŒŒá à
thisŒŒà å
.ŒŒå ç
ReaderIndexŒŒç ò
)ŒŒò ô
,ŒŒô ö
thisŒŒõ ü
.ŒŒü †
IdxŒŒ† £
(ŒŒ£ §
thisŒŒ§ ®
.ŒŒ® ©
WriterIndexŒŒ© ¥
)ŒŒ¥ µ
)ŒŒµ ∂
;ŒŒ∂ ∑
public
–– 
override
–– 
IByteBuffer
–– '
Slice
––( -
(
––- .
int
––. 1
index
––2 7
,
––7 8
int
––9 <
length
––= C
)
––C D
{
—— 
this
““ 
.
““ 
CheckIndex0
““  
(
““  !
index
““! &
,
““& '
length
““( .
)
““. /
;
““/ 0
return
”” 
new
”” /
!PooledNonRetainedSlicedByteBuffer
”” <
(
””< =
this
””= A
.
””A B$
referenceCountDelegate
””B X
,
””X Y
this
””Z ^
.
””^ _

UnwrapCore
””_ i
(
””i j
)
””j k
,
””k l
this
””m q
.
””q r
Idx
””r u
(
””u v
index
””v {
)
””{ |
,
””| }
length””~ Ñ
)””Ñ Ö
;””Ö Ü
}
‘‘ 
public
÷÷ 
override
÷÷ 
IByteBuffer
÷÷ '
RetainedSlice
÷÷( 5
(
÷÷5 6
int
÷÷6 9
index
÷÷: ?
,
÷÷? @
int
÷÷A D
length
÷÷E K
)
÷÷K L
=>
÷÷M O$
PooledSlicedByteBuffer
÷÷P f
.
÷÷f g
NewInstance
÷÷g r
(
÷÷r s
this
÷÷s w
.
÷÷w x

UnwrapCore÷÷x Ç
(÷÷Ç É
)÷÷É Ñ
,÷÷Ñ Ö
this÷÷Ü ä
,÷÷ä ã
this÷÷å ê
.÷÷ê ë
Idx÷÷ë î
(÷÷î ï
index÷÷ï ö
)÷÷ö õ
,÷÷õ ú
length÷÷ù £
)÷÷£ §
;÷÷§ •
}
◊◊ 	
}
ÿÿ 
}ŸŸ ˘.
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractReferenceCountedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

abstract 
class .
"AbstractReferenceCountedByteBuffer <
:= >
AbstractByteBuffer? Q
{ 
volatile 
int 
referenceCount #
=$ %
$num& '
;' (
	protected .
"AbstractReferenceCountedByteBuffer 4
(4 5
int5 8
maxCapacity9 D
)D E
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
override 
int 
ReferenceCount *
=>+ -
this. 2
.2 3
referenceCount3 A
;A B
	protected 
internal 
void 
SetReferenceCount  1
(1 2
int2 5
value6 ;
); <
=>= ?
this@ D
.D E
referenceCountE S
=T U
valueV [
;[ \
public 
override 
IReferenceCounted )
Retain* 0
(0 1
)1 2
=>3 5
this6 :
.: ;
Retain0; B
(B C
$numC D
)D E
;E F
public 
override 
IReferenceCounted )
Retain* 0
(0 1
int1 4
	increment5 >
)> ?
{ 	
Contract 
. 
Requires 
( 
	increment '
>( )
$num* +
)+ ,
;, -
return!! 
this!! 
.!! 
Retain0!! 
(!!  
	increment!!  )
)!!) *
;!!* +
}"" 	
IReferenceCounted$$ 
Retain0$$ !
($$! "
int$$" %
	increment$$& /
)$$/ 0
{%% 	
while&& 
(&& 
true&& 
)&& 
{'' 
int(( 
refCnt(( 
=(( 
this(( !
.((! "
referenceCount((" 0
;((0 1
int)) 
nextCnt)) 
=)) 
refCnt)) $
+))% &
	increment))' 0
;))0 1
if,, 
(,, 
nextCnt,, 
<=,, 
	increment,, (
),,( )
{-- 
throw.. 
new.. *
IllegalReferenceCountException.. <
(..< =
refCnt..= C
,..C D
	increment..E N
)..N O
;..O P
}// 
if00 
(00 
Interlocked00 
.00  
CompareExchange00  /
(00/ 0
ref000 3
this004 8
.008 9
referenceCount009 G
,00G H
refCnt00I O
+00P Q
	increment00R [
,00[ \
refCnt00] c
)00c d
==00e g
refCnt00h n
)00n o
{11 
break22 
;22 
}33 
}44 
return66 
this66 
;66 
}77 	
public99 
override99 
IReferenceCounted99 )
Touch99* /
(99/ 0
)990 1
=>992 4
this995 9
;999 :
public;; 
override;; 
IReferenceCounted;; )
Touch;;* /
(;;/ 0
object;;0 6
hint;;7 ;
);;; <
=>;;= ?
this;;@ D
;;;D E
public== 
override== 
bool== 
Release== $
(==$ %
)==% &
=>==' )
this==* .
.==. /
Release0==/ 7
(==7 8
$num==8 9
)==9 :
;==: ;
public?? 
override?? 
bool?? 
Release?? $
(??$ %
int??% (
	decrement??) 2
)??2 3
{@@ 	
ContractAA 
.AA 
RequiresAA 
(AA 
	decrementAA '
>AA( )
$numAA* +
)AA+ ,
;AA, -
returnCC 
thisCC 
.CC 
Release0CC  
(CC  !
	decrementCC! *
)CC* +
;CC+ ,
}DD 	
boolFF 
Release0FF 
(FF 
intFF 
	decrementFF #
)FF# $
{GG 	
whileHH 
(HH 
trueHH 
)HH 
{II 
intJJ 
refCntJJ 
=JJ 
thisJJ !
.JJ! "
ReferenceCountJJ" 0
;JJ0 1
ifKK 
(KK 
refCntKK 
<KK 
	decrementKK &
)KK& '
{LL 
throwMM 
newMM *
IllegalReferenceCountExceptionMM <
(MM< =
refCntMM= C
,MMC D
-MME F
	decrementMMF O
)MMO P
;MMP Q
}NN 
ifPP 
(PP 
InterlockedPP 
.PP  
CompareExchangePP  /
(PP/ 0
refPP0 3
thisPP4 8
.PP8 9
referenceCountPP9 G
,PPG H
refCntPPI O
-PPP Q
	decrementPPR [
,PP[ \
refCntPP] c
)PPc d
==PPe g
refCntPPh n
)PPn o
{QQ 
ifRR 
(RR 
refCntRR 
==RR !
	decrementRR" +
)RR+ ,
{SS 
thisTT 
.TT 

DeallocateTT '
(TT' (
)TT( )
;TT) *
returnUU 
trueUU #
;UU# $
}VV 
returnXX 
falseXX  
;XX  !
}YY 
}ZZ 
}[[ 	
	protected]] 
internal]] 
abstract]] #
void]]$ (

Deallocate]]) 3
(]]3 4
)]]4 5
;]]5 6
}^^ 
}__ Á“
sC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AbstractUnpooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract 
class ,
 AbstractUnpooledSlicedByteBuffer 3
:4 5%
AbstractDerivedByteBuffer6 O
{ 
readonly 
IByteBuffer 
buffer #
;# $
readonly 
int 

adjustment 
;  
	protected ,
 AbstractUnpooledSlicedByteBuffer 2
(2 3
IByteBuffer3 >
buffer? E
,E F
intG J
indexK P
,P Q
intR U
lengthV \
)\ ]
: 
base 
( 
length 
) 
{ 	!
CheckSliceOutOfBounds !
(! "
index" '
,' (
length) /
,/ 0
buffer1 7
)7 8
;8 9
if 
( 
buffer 
is ,
 AbstractUnpooledSlicedByteBuffer :

byteBuffer; E
)E F
{ 
this 
. 
buffer 
= 

byteBuffer (
.( )
buffer) /
;/ 0
this 
. 

adjustment 
=  !

byteBuffer" ,
., -

adjustment- 7
+8 9
index: ?
;? @
} 
else 
if 
( 
buffer 
is (
UnpooledDuplicatedByteBuffer ;
); <
{ 
this 
. 
buffer 
= 
buffer $
.$ %
Unwrap% +
(+ ,
), -
;- .
this   
.   

adjustment   
=    !
index  " '
;  ' (
}!! 
else"" 
{## 
this$$ 
.$$ 
buffer$$ 
=$$ 
buffer$$ $
;$$$ %
this%% 
.%% 

adjustment%% 
=%%  !
index%%" '
;%%' (
}&& 
this(( 
.(( 
SetWriterIndex0((  
(((  !
length((! '
)((' (
;((( )
})) 	
internal++ 
int++ 
Length++ 
=>++ 
this++ #
.++# $
Capacity++$ ,
;++, -
public-- 
override-- 
IByteBuffer-- #
Unwrap--$ *
(--* +
)--+ ,
=>--- /
this--0 4
.--4 5
buffer--5 ;
;--; <
public// 
override//  
IByteBufferAllocator// ,
	Allocator//- 6
=>//7 9
this//: >
.//> ?
Unwrap//? E
(//E F
)//F G
.//G H
	Allocator//H Q
;//Q R
public11 
override11 
bool11 
IsDirect11 %
=>11& (
this11) -
.11- .
Unwrap11. 4
(114 5
)115 6
.116 7
IsDirect117 ?
;11? @
public33 
override33 
IByteBuffer33 #
AdjustCapacity33$ 2
(332 3
int333 6
newCapacity337 B
)33B C
=>33D F
throw33G L
new33M P!
NotSupportedException33Q f
(33f g
$str33g v
)33v w
;33w x
public55 
override55 
bool55 
HasArray55 %
=>55& (
this55) -
.55- .
Unwrap55. 4
(554 5
)555 6
.556 7
HasArray557 ?
;55? @
public77 
override77 
byte77 
[77 
]77 
Array77 $
=>77% '
this77( ,
.77, -
Unwrap77- 3
(773 4
)774 5
.775 6
Array776 ;
;77; <
public99 
override99 
int99 
ArrayOffset99 '
=>99( *
this99+ /
.99/ 0
Idx990 3
(993 4
this994 8
.998 9
Unwrap999 ?
(99? @
)99@ A
.99A B
ArrayOffset99B M
)99M N
;99N O
public;; 
override;; 
bool;; 
HasMemoryAddress;; -
=>;;. 0
this;;1 5
.;;5 6
Unwrap;;6 <
(;;< =
);;= >
.;;> ?
HasMemoryAddress;;? O
;;;O P
public== 
override== 
ref== 
byte==  $
GetPinnableMemoryAddress==! 9
(==9 :
)==: ;
=>==< >
ref==? B
Unsafe==C I
.==I J
Add==J M
(==M N
ref==N Q
this==R V
.==V W
Unwrap==W ]
(==] ^
)==^ _
.==_ `$
GetPinnableMemoryAddress==` x
(==x y
)==y z
,==z {
this	==| Ä
.
==Ä Å

adjustment
==Å ã
)
==ã å
;
==å ç
public?? 
override?? 
IntPtr?? !
AddressOfPinnedMemory?? 4
(??4 5
)??5 6
{@@ 	
IntPtrAA 
ptrAA 
=AA 
thisAA 
.AA 
UnwrapAA $
(AA$ %
)AA% &
.AA& '!
AddressOfPinnedMemoryAA' <
(AA< =
)AA= >
;AA> ?
ifBB 
(BB 
ptrBB 
==BB 
IntPtrBB 
.BB 
ZeroBB "
)BB" #
{CC 
returnDD 
ptrDD 
;DD 
}EE 
returnFF 
ptrFF 
+FF 
thisFF 
.FF 

adjustmentFF (
;FF( )
}GG 	
publicII 
overrideII 
byteII 
GetByteII $
(II$ %
intII% (
indexII) .
)II. /
{JJ 	
thisKK 
.KK 
CheckIndex0KK 
(KK 
indexKK "
,KK" #
$numKK$ %
)KK% &
;KK& '
returnLL 
thisLL 
.LL 
UnwrapLL 
(LL 
)LL  
.LL  !
GetByteLL! (
(LL( )
thisLL) -
.LL- .
IdxLL. 1
(LL1 2
indexLL2 7
)LL7 8
)LL8 9
;LL9 :
}MM 	
	protectedOO 
internalOO 
overrideOO #
byteOO$ (
_GetByteOO) 1
(OO1 2
intOO2 5
indexOO6 ;
)OO; <
=>OO= ?
thisOO@ D
.OOD E
UnwrapOOE K
(OOK L
)OOL M
.OOM N
GetByteOON U
(OOU V
thisOOV Z
.OOZ [
IdxOO[ ^
(OO^ _
indexOO_ d
)OOd e
)OOe f
;OOf g
publicQQ 
overrideQQ 
shortQQ 
GetShortQQ &
(QQ& '
intQQ' *
indexQQ+ 0
)QQ0 1
{RR 	
thisSS 
.SS 
CheckIndex0SS 
(SS 
indexSS "
,SS" #
$numSS$ %
)SS% &
;SS& '
returnTT 
thisTT 
.TT 
UnwrapTT 
(TT 
)TT  
.TT  !
GetShortTT! )
(TT) *
thisTT* .
.TT. /
IdxTT/ 2
(TT2 3
indexTT3 8
)TT8 9
)TT9 :
;TT: ;
}UU 	
	protectedWW 
internalWW 
overrideWW #
shortWW$ )
	_GetShortWW* 3
(WW3 4
intWW4 7
indexWW8 =
)WW= >
=>WW? A
thisWWB F
.WWF G
UnwrapWWG M
(WWM N
)WWN O
.WWO P
GetShortWWP X
(WWX Y
thisWWY ]
.WW] ^
IdxWW^ a
(WWa b
indexWWb g
)WWg h
)WWh i
;WWi j
publicYY 
overrideYY 
shortYY 

GetShortLEYY (
(YY( )
intYY) ,
indexYY- 2
)YY2 3
{ZZ 	
this[[ 
.[[ 
CheckIndex0[[ 
([[ 
index[[ "
,[[" #
$num[[$ %
)[[% &
;[[& '
return\\ 
this\\ 
.\\ 
Unwrap\\ 
(\\ 
)\\  
.\\  !

GetShortLE\\! +
(\\+ ,
this\\, 0
.\\0 1
Idx\\1 4
(\\4 5
index\\5 :
)\\: ;
)\\; <
;\\< =
}]] 	
	protected__ 
internal__ 
override__ #
short__$ )
_GetShortLE__* 5
(__5 6
int__6 9
index__: ?
)__? @
=>__A C
this__D H
.__H I
Unwrap__I O
(__O P
)__P Q
.__Q R

GetShortLE__R \
(__\ ]
this__] a
.__a b
Idx__b e
(__e f
index__f k
)__k l
)__l m
;__m n
publicaa 
overrideaa 
intaa 
GetUnsignedMediumaa -
(aa- .
intaa. 1
indexaa2 7
)aa7 8
{bb 	
thiscc 
.cc 
CheckIndex0cc 
(cc 
indexcc "
,cc" #
$numcc$ %
)cc% &
;cc& '
returndd 
thisdd 
.dd 
Unwrapdd 
(dd 
)dd  
.dd  !
GetUnsignedMediumdd! 2
(dd2 3
thisdd3 7
.dd7 8
Idxdd8 ;
(dd; <
indexdd< A
)ddA B
)ddB C
;ddC D
}ee 	
	protectedgg 
internalgg 
overridegg #
intgg$ '
_GetUnsignedMediumgg( :
(gg: ;
intgg; >
indexgg? D
)ggD E
=>ggF H
thisggI M
.ggM N
UnwrapggN T
(ggT U
)ggU V
.ggV W
GetUnsignedMediumggW h
(ggh i
thisggi m
.ggm n
Idxggn q
(ggq r
indexggr w
)ggw x
)ggx y
;ggy z
publicii 
overrideii 
intii 
GetUnsignedMediumLEii /
(ii/ 0
intii0 3
indexii4 9
)ii9 :
{jj 	
thiskk 
.kk 
CheckIndex0kk 
(kk 
indexkk "
,kk" #
$numkk$ %
)kk% &
;kk& '
returnll 
thisll 
.ll 
Unwrapll 
(ll 
)ll  
.ll  !
GetUnsignedMediumLEll! 4
(ll4 5
thisll5 9
.ll9 :
Idxll: =
(ll= >
indexll> C
)llC D
)llD E
;llE F
}mm 	
	protectedoo 
internaloo 
overrideoo #
intoo$ ' 
_GetUnsignedMediumLEoo( <
(oo< =
intoo= @
indexooA F
)ooF G
=>ooH J
thisooK O
.ooO P
UnwrapooP V
(ooV W
)ooW X
.ooX Y
GetUnsignedMediumLEooY l
(ool m
thisoom q
.ooq r
Idxoor u
(oou v
indexoov {
)oo{ |
)oo| }
;oo} ~
publicqq 
overrideqq 
intqq 
GetIntqq "
(qq" #
intqq# &
indexqq' ,
)qq, -
{rr 	
thisss 
.ss 
CheckIndex0ss 
(ss 
indexss "
,ss" #
$numss$ %
)ss% &
;ss& '
returntt 
thistt 
.tt 
Unwraptt 
(tt 
)tt  
.tt  !
GetInttt! '
(tt' (
thistt( ,
.tt, -
Idxtt- 0
(tt0 1
indextt1 6
)tt6 7
)tt7 8
;tt8 9
}uu 	
	protectedww 
internalww 
overrideww #
intww$ '
_GetIntww( /
(ww/ 0
intww0 3
indexww4 9
)ww9 :
=>ww; =
thisww> B
.wwB C
UnwrapwwC I
(wwI J
)wwJ K
.wwK L
GetIntwwL R
(wwR S
thiswwS W
.wwW X
IdxwwX [
(ww[ \
indexww\ a
)wwa b
)wwb c
;wwc d
publicyy 
overrideyy 
intyy 
GetIntLEyy $
(yy$ %
intyy% (
indexyy) .
)yy. /
{zz 	
this{{ 
.{{ 
CheckIndex0{{ 
({{ 
index{{ "
,{{" #
$num{{$ %
){{% &
;{{& '
return|| 
this|| 
.|| 
Unwrap|| 
(|| 
)||  
.||  !
GetIntLE||! )
(||) *
this||* .
.||. /
Idx||/ 2
(||2 3
index||3 8
)||8 9
)||9 :
;||: ;
}}} 	
	protected 
internal 
override #
int$ '
	_GetIntLE( 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E
UnwrapE K
(K L
)L M
.M N
GetIntLEN V
(V W
thisW [
.[ \
Idx\ _
(_ `
index` e
)e f
)f g
;g h
public
ÅÅ 
override
ÅÅ 
long
ÅÅ 
GetLong
ÅÅ $
(
ÅÅ$ %
int
ÅÅ% (
index
ÅÅ) .
)
ÅÅ. /
{
ÇÇ 	
this
ÉÉ 
.
ÉÉ 
CheckIndex0
ÉÉ 
(
ÉÉ 
index
ÉÉ "
,
ÉÉ" #
$num
ÉÉ$ %
)
ÉÉ% &
;
ÉÉ& '
return
ÑÑ 
this
ÑÑ 
.
ÑÑ 
Unwrap
ÑÑ 
(
ÑÑ 
)
ÑÑ  
.
ÑÑ  !
GetLong
ÑÑ! (
(
ÑÑ( )
this
ÑÑ) -
.
ÑÑ- .
Idx
ÑÑ. 1
(
ÑÑ1 2
index
ÑÑ2 7
)
ÑÑ7 8
)
ÑÑ8 9
;
ÑÑ9 :
}
ÖÖ 	
	protected
áá 
internal
áá 
override
áá #
long
áá$ (
_GetLong
áá) 1
(
áá1 2
int
áá2 5
index
áá6 ;
)
áá; <
=>
áá= ?
this
áá@ D
.
ááD E
Unwrap
ááE K
(
ááK L
)
ááL M
.
ááM N
GetLong
ááN U
(
ááU V
this
ááV Z
.
ááZ [
Idx
áá[ ^
(
áá^ _
index
áá_ d
)
áád e
)
ááe f
;
ááf g
public
ââ 
override
ââ 
long
ââ 
	GetLongLE
ââ &
(
ââ& '
int
ââ' *
index
ââ+ 0
)
ââ0 1
{
ää 	
this
ãã 
.
ãã 
CheckIndex0
ãã 
(
ãã 
index
ãã "
,
ãã" #
$num
ãã$ %
)
ãã% &
;
ãã& '
return
åå 
this
åå 
.
åå 
Unwrap
åå 
(
åå 
)
åå  
.
åå  !
	GetLongLE
åå! *
(
åå* +
this
åå+ /
.
åå/ 0
Idx
åå0 3
(
åå3 4
index
åå4 9
)
åå9 :
)
åå: ;
;
åå; <
}
çç 	
	protected
èè 
internal
èè 
override
èè #
long
èè$ (

_GetLongLE
èè) 3
(
èè3 4
int
èè4 7
index
èè8 =
)
èè= >
=>
èè? A
this
èèB F
.
èèF G
Unwrap
èèG M
(
èèM N
)
èèN O
.
èèO P
	GetLongLE
èèP Y
(
èèY Z
this
èèZ ^
.
èè^ _
Idx
èè_ b
(
èèb c
index
èèc h
)
èèh i
)
èèi j
;
èèj k
public
ëë 
override
ëë 
IByteBuffer
ëë #
	Duplicate
ëë$ -
(
ëë- .
)
ëë. /
=>
ëë0 2
this
ëë3 7
.
ëë7 8
Unwrap
ëë8 >
(
ëë> ?
)
ëë? @
.
ëë@ A
	Duplicate
ëëA J
(
ëëJ K
)
ëëK L
.
ëëL M
SetIndex
ëëM U
(
ëëU V
this
ëëV Z
.
ëëZ [
Idx
ëë[ ^
(
ëë^ _
this
ëë_ c
.
ëëc d
ReaderIndex
ëëd o
)
ëëo p
,
ëëp q
this
ëër v
.
ëëv w
Idx
ëëw z
(
ëëz {
this
ëë{ 
.ëë Ä
WriterIndexëëÄ ã
)ëëã å
)ëëå ç
;ëëç é
public
ìì 
override
ìì 
IByteBuffer
ìì #
Copy
ìì$ (
(
ìì( )
int
ìì) ,
index
ìì- 2
,
ìì2 3
int
ìì4 7
length
ìì8 >
)
ìì> ?
{
îî 	
this
ïï 
.
ïï 
CheckIndex0
ïï 
(
ïï 
index
ïï "
,
ïï" #
length
ïï$ *
)
ïï* +
;
ïï+ ,
return
ññ 
this
ññ 
.
ññ 
Unwrap
ññ 
(
ññ 
)
ññ  
.
ññ  !
Copy
ññ! %
(
ññ% &
this
ññ& *
.
ññ* +
Idx
ññ+ .
(
ññ. /
index
ññ/ 4
)
ññ4 5
,
ññ5 6
length
ññ7 =
)
ññ= >
;
ññ> ?
}
óó 	
public
ôô 
override
ôô 
IByteBuffer
ôô #
Slice
ôô$ )
(
ôô) *
int
ôô* -
index
ôô. 3
,
ôô3 4
int
ôô5 8
length
ôô9 ?
)
ôô? @
{
öö 	
this
õõ 
.
õõ 
CheckIndex0
õõ 
(
õõ 
index
õõ "
,
õõ" #
length
õõ$ *
)
õõ* +
;
õõ+ ,
return
úú 
this
úú 
.
úú 
Unwrap
úú 
(
úú 
)
úú  
.
úú  !
Slice
úú! &
(
úú& '
this
úú' +
.
úú+ ,
Idx
úú, /
(
úú/ 0
index
úú0 5
)
úú5 6
,
úú6 7
length
úú8 >
)
úú> ?
;
úú? @
}
ùù 	
public
üü 
override
üü 
IByteBuffer
üü #
GetBytes
üü$ ,
(
üü, -
int
üü- 0
index
üü1 6
,
üü6 7
IByteBuffer
üü8 C
dst
üüD G
,
üüG H
int
üüI L
dstIndex
üüM U
,
üüU V
int
üüW Z
length
üü[ a
)
üüa b
{
†† 	
this
°° 
.
°° 
CheckIndex0
°° 
(
°° 
index
°° "
,
°°" #
length
°°$ *
)
°°* +
;
°°+ ,
this
¢¢ 
.
¢¢ 
Unwrap
¢¢ 
(
¢¢ 
)
¢¢ 
.
¢¢ 
GetBytes
¢¢ "
(
¢¢" #
this
¢¢# '
.
¢¢' (
Idx
¢¢( +
(
¢¢+ ,
index
¢¢, 1
)
¢¢1 2
,
¢¢2 3
dst
¢¢4 7
,
¢¢7 8
dstIndex
¢¢9 A
,
¢¢A B
length
¢¢C I
)
¢¢I J
;
¢¢J K
return
££ 
this
££ 
;
££ 
}
§§ 	
public
¶¶ 
override
¶¶ 
IByteBuffer
¶¶ #
GetBytes
¶¶$ ,
(
¶¶, -
int
¶¶- 0
index
¶¶1 6
,
¶¶6 7
byte
¶¶8 <
[
¶¶< =
]
¶¶= >
dst
¶¶? B
,
¶¶B C
int
¶¶D G
dstIndex
¶¶H P
,
¶¶P Q
int
¶¶R U
length
¶¶V \
)
¶¶\ ]
{
ßß 	
this
®® 
.
®® 
CheckIndex0
®® 
(
®® 
index
®® "
,
®®" #
length
®®$ *
)
®®* +
;
®®+ ,
this
©© 
.
©© 
Unwrap
©© 
(
©© 
)
©© 
.
©© 
GetBytes
©© "
(
©©" #
this
©©# '
.
©©' (
Idx
©©( +
(
©©+ ,
index
©©, 1
)
©©1 2
,
©©2 3
dst
©©4 7
,
©©7 8
dstIndex
©©9 A
,
©©A B
length
©©C I
)
©©I J
;
©©J K
return
™™ 
this
™™ 
;
™™ 
}
´´ 	
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #
GetBytes
≠≠$ ,
(
≠≠, -
int
≠≠- 0
index
≠≠1 6
,
≠≠6 7
Stream
≠≠8 >
destination
≠≠? J
,
≠≠J K
int
≠≠L O
length
≠≠P V
)
≠≠V W
{
ÆÆ 	
this
ØØ 
.
ØØ 
CheckIndex0
ØØ 
(
ØØ 
index
ØØ "
,
ØØ" #
length
ØØ$ *
)
ØØ* +
;
ØØ+ ,
this
∞∞ 
.
∞∞ 
Unwrap
∞∞ 
(
∞∞ 
)
∞∞ 
.
∞∞ 
GetBytes
∞∞ "
(
∞∞" #
this
∞∞# '
.
∞∞' (
Idx
∞∞( +
(
∞∞+ ,
index
∞∞, 1
)
∞∞1 2
,
∞∞2 3
destination
∞∞4 ?
,
∞∞? @
length
∞∞A G
)
∞∞G H
;
∞∞H I
return
±± 
this
±± 
;
±± 
}
≤≤ 	
public
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ #
SetByte
¥¥$ +
(
¥¥+ ,
int
¥¥, /
index
¥¥0 5
,
¥¥5 6
int
¥¥7 :
value
¥¥; @
)
¥¥@ A
{
µµ 	
this
∂∂ 
.
∂∂ 
CheckIndex0
∂∂ 
(
∂∂ 
index
∂∂ "
,
∂∂" #
$num
∂∂$ %
)
∂∂% &
;
∂∂& '
this
∑∑ 
.
∑∑ 
Unwrap
∑∑ 
(
∑∑ 
)
∑∑ 
.
∑∑ 
SetByte
∑∑ !
(
∑∑! "
this
∑∑" &
.
∑∑& '
Idx
∑∑' *
(
∑∑* +
index
∑∑+ 0
)
∑∑0 1
,
∑∑1 2
value
∑∑3 8
)
∑∑8 9
;
∑∑9 :
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
	protected
ªª 
internal
ªª 
override
ªª #
void
ªª$ (
_SetByte
ªª) 1
(
ªª1 2
int
ªª2 5
index
ªª6 ;
,
ªª; <
int
ªª= @
value
ªªA F
)
ªªF G
=>
ªªH J
this
ªªK O
.
ªªO P
Unwrap
ªªP V
(
ªªV W
)
ªªW X
.
ªªX Y
SetByte
ªªY `
(
ªª` a
this
ªªa e
.
ªªe f
Idx
ªªf i
(
ªªi j
index
ªªj o
)
ªªo p
,
ªªp q
value
ªªr w
)
ªªw x
;
ªªx y
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
SetShort
ΩΩ$ ,
(
ΩΩ, -
int
ΩΩ- 0
index
ΩΩ1 6
,
ΩΩ6 7
int
ΩΩ8 ;
value
ΩΩ< A
)
ΩΩA B
{
ææ 	
this
øø 
.
øø 
CheckIndex0
øø 
(
øø 
index
øø "
,
øø" #
$num
øø$ %
)
øø% &
;
øø& '
this
¿¿ 
.
¿¿ 
Unwrap
¿¿ 
(
¿¿ 
)
¿¿ 
.
¿¿ 
SetShort
¿¿ "
(
¿¿" #
this
¿¿# '
.
¿¿' (
Idx
¿¿( +
(
¿¿+ ,
index
¿¿, 1
)
¿¿1 2
,
¿¿2 3
value
¿¿4 9
)
¿¿9 :
;
¿¿: ;
return
¡¡ 
this
¡¡ 
;
¡¡ 
}
¬¬ 	
	protected
ƒƒ 
internal
ƒƒ 
override
ƒƒ #
void
ƒƒ$ (
	_SetShort
ƒƒ) 2
(
ƒƒ2 3
int
ƒƒ3 6
index
ƒƒ7 <
,
ƒƒ< =
int
ƒƒ> A
value
ƒƒB G
)
ƒƒG H
=>
ƒƒI K
this
ƒƒL P
.
ƒƒP Q
Unwrap
ƒƒQ W
(
ƒƒW X
)
ƒƒX Y
.
ƒƒY Z
SetShort
ƒƒZ b
(
ƒƒb c
this
ƒƒc g
.
ƒƒg h
Idx
ƒƒh k
(
ƒƒk l
index
ƒƒl q
)
ƒƒq r
,
ƒƒr s
value
ƒƒt y
)
ƒƒy z
;
ƒƒz {
public
∆∆ 
override
∆∆ 
IByteBuffer
∆∆ #

SetShortLE
∆∆$ .
(
∆∆. /
int
∆∆/ 2
index
∆∆3 8
,
∆∆8 9
int
∆∆: =
value
∆∆> C
)
∆∆C D
{
«« 	
this
»» 
.
»» 
CheckIndex0
»» 
(
»» 
index
»» "
,
»»" #
$num
»»$ %
)
»»% &
;
»»& '
this
…… 
.
…… 
Unwrap
…… 
(
…… 
)
…… 
.
…… 

SetShortLE
…… $
(
……$ %
this
……% )
.
……) *
Idx
……* -
(
……- .
index
……. 3
)
……3 4
,
……4 5
value
……6 ;
)
……; <
;
……< =
return
   
this
   
;
   
}
ÀÀ 	
	protected
ÕÕ 
internal
ÕÕ 
override
ÕÕ #
void
ÕÕ$ (
_SetShortLE
ÕÕ) 4
(
ÕÕ4 5
int
ÕÕ5 8
index
ÕÕ9 >
,
ÕÕ> ?
int
ÕÕ@ C
value
ÕÕD I
)
ÕÕI J
=>
ÕÕK M
this
ÕÕN R
.
ÕÕR S
Unwrap
ÕÕS Y
(
ÕÕY Z
)
ÕÕZ [
.
ÕÕ[ \

SetShortLE
ÕÕ\ f
(
ÕÕf g
this
ÕÕg k
.
ÕÕk l
Idx
ÕÕl o
(
ÕÕo p
index
ÕÕp u
)
ÕÕu v
,
ÕÕv w
value
ÕÕx }
)
ÕÕ} ~
;
ÕÕ~ 
public
œœ 
override
œœ 
IByteBuffer
œœ #
	SetMedium
œœ$ -
(
œœ- .
int
œœ. 1
index
œœ2 7
,
œœ7 8
int
œœ9 <
value
œœ= B
)
œœB C
{
–– 	
this
—— 
.
—— 
CheckIndex0
—— 
(
—— 
index
—— "
,
——" #
$num
——$ %
)
——% &
;
——& '
this
““ 
.
““ 
Unwrap
““ 
(
““ 
)
““ 
.
““ 
	SetMedium
““ #
(
““# $
this
““$ (
.
““( )
Idx
““) ,
(
““, -
index
““- 2
)
““2 3
,
““3 4
value
““5 :
)
““: ;
;
““; <
return
”” 
this
”” 
;
”” 
}
‘‘ 	
	protected
÷÷ 
internal
÷÷ 
override
÷÷ #
void
÷÷$ (

_SetMedium
÷÷) 3
(
÷÷3 4
int
÷÷4 7
index
÷÷8 =
,
÷÷= >
int
÷÷? B
value
÷÷C H
)
÷÷H I
=>
÷÷J L
this
÷÷M Q
.
÷÷Q R
Unwrap
÷÷R X
(
÷÷X Y
)
÷÷Y Z
.
÷÷Z [
	SetMedium
÷÷[ d
(
÷÷d e
this
÷÷e i
.
÷÷i j
Idx
÷÷j m
(
÷÷m n
index
÷÷n s
)
÷÷s t
,
÷÷t u
value
÷÷v {
)
÷÷{ |
;
÷÷| }
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
SetMediumLE
ÿÿ$ /
(
ÿÿ/ 0
int
ÿÿ0 3
index
ÿÿ4 9
,
ÿÿ9 :
int
ÿÿ; >
value
ÿÿ? D
)
ÿÿD E
{
ŸŸ 	
this
⁄⁄ 
.
⁄⁄ 
CheckIndex0
⁄⁄ 
(
⁄⁄ 
index
⁄⁄ "
,
⁄⁄" #
$num
⁄⁄$ %
)
⁄⁄% &
;
⁄⁄& '
this
€€ 
.
€€ 
Unwrap
€€ 
(
€€ 
)
€€ 
.
€€ 
SetMediumLE
€€ %
(
€€% &
this
€€& *
.
€€* +
Idx
€€+ .
(
€€. /
index
€€/ 4
)
€€4 5
,
€€5 6
value
€€7 <
)
€€< =
;
€€= >
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
›› 	
	protected
ﬂﬂ 
internal
ﬂﬂ 
override
ﬂﬂ #
void
ﬂﬂ$ (
_SetMediumLE
ﬂﬂ) 5
(
ﬂﬂ5 6
int
ﬂﬂ6 9
index
ﬂﬂ: ?
,
ﬂﬂ? @
int
ﬂﬂA D
value
ﬂﬂE J
)
ﬂﬂJ K
=>
ﬂﬂL N
this
ﬂﬂO S
.
ﬂﬂS T
Unwrap
ﬂﬂT Z
(
ﬂﬂZ [
)
ﬂﬂ[ \
.
ﬂﬂ\ ]
SetMediumLE
ﬂﬂ] h
(
ﬂﬂh i
this
ﬂﬂi m
.
ﬂﬂm n
Idx
ﬂﬂn q
(
ﬂﬂq r
index
ﬂﬂr w
)
ﬂﬂw x
,
ﬂﬂx y
value
ﬂﬂz 
)ﬂﬂ Ä
;ﬂﬂÄ Å
public
·· 
override
·· 
IByteBuffer
·· #
SetInt
··$ *
(
··* +
int
··+ .
index
··/ 4
,
··4 5
int
··6 9
value
··: ?
)
··? @
{
‚‚ 	
this
„„ 
.
„„ 
CheckIndex0
„„ 
(
„„ 
index
„„ "
,
„„" #
$num
„„$ %
)
„„% &
;
„„& '
this
‰‰ 
.
‰‰ 
Unwrap
‰‰ 
(
‰‰ 
)
‰‰ 
.
‰‰ 
SetInt
‰‰  
(
‰‰  !
this
‰‰! %
.
‰‰% &
Idx
‰‰& )
(
‰‰) *
index
‰‰* /
)
‰‰/ 0
,
‰‰0 1
value
‰‰2 7
)
‰‰7 8
;
‰‰8 9
return
ÂÂ 
this
ÂÂ 
;
ÂÂ 
}
ÊÊ 	
	protected
ËË 
internal
ËË 
override
ËË #
void
ËË$ (
_SetInt
ËË) 0
(
ËË0 1
int
ËË1 4
index
ËË5 :
,
ËË: ;
int
ËË< ?
value
ËË@ E
)
ËËE F
=>
ËËG I
this
ËËJ N
.
ËËN O
Unwrap
ËËO U
(
ËËU V
)
ËËV W
.
ËËW X
SetInt
ËËX ^
(
ËË^ _
this
ËË_ c
.
ËËc d
Idx
ËËd g
(
ËËg h
index
ËËh m
)
ËËm n
,
ËËn o
value
ËËp u
)
ËËu v
;
ËËv w
public
ÍÍ 
override
ÍÍ 
IByteBuffer
ÍÍ #
SetIntLE
ÍÍ$ ,
(
ÍÍ, -
int
ÍÍ- 0
index
ÍÍ1 6
,
ÍÍ6 7
int
ÍÍ8 ;
value
ÍÍ< A
)
ÍÍA B
{
ÎÎ 	
this
ÏÏ 
.
ÏÏ 
CheckIndex0
ÏÏ 
(
ÏÏ 
index
ÏÏ "
,
ÏÏ" #
$num
ÏÏ$ %
)
ÏÏ% &
;
ÏÏ& '
this
ÌÌ 
.
ÌÌ 
Unwrap
ÌÌ 
(
ÌÌ 
)
ÌÌ 
.
ÌÌ 
SetIntLE
ÌÌ "
(
ÌÌ" #
this
ÌÌ# '
.
ÌÌ' (
Idx
ÌÌ( +
(
ÌÌ+ ,
index
ÌÌ, 1
)
ÌÌ1 2
,
ÌÌ2 3
value
ÌÌ4 9
)
ÌÌ9 :
;
ÌÌ: ;
return
ÓÓ 
this
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
	protected
ÒÒ 
internal
ÒÒ 
override
ÒÒ #
void
ÒÒ$ (
	_SetIntLE
ÒÒ) 2
(
ÒÒ2 3
int
ÒÒ3 6
index
ÒÒ7 <
,
ÒÒ< =
int
ÒÒ> A
value
ÒÒB G
)
ÒÒG H
=>
ÒÒI K
this
ÒÒL P
.
ÒÒP Q
Unwrap
ÒÒQ W
(
ÒÒW X
)
ÒÒX Y
.
ÒÒY Z
SetIntLE
ÒÒZ b
(
ÒÒb c
this
ÒÒc g
.
ÒÒg h
Idx
ÒÒh k
(
ÒÒk l
index
ÒÒl q
)
ÒÒq r
,
ÒÒr s
value
ÒÒt y
)
ÒÒy z
;
ÒÒz {
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #
SetLong
ÛÛ$ +
(
ÛÛ+ ,
int
ÛÛ, /
index
ÛÛ0 5
,
ÛÛ5 6
long
ÛÛ7 ;
value
ÛÛ< A
)
ÛÛA B
{
ÙÙ 	
this
ıı 
.
ıı 
CheckIndex0
ıı 
(
ıı 
index
ıı "
,
ıı" #
$num
ıı$ %
)
ıı% &
;
ıı& '
this
ˆˆ 
.
ˆˆ 
Unwrap
ˆˆ 
(
ˆˆ 
)
ˆˆ 
.
ˆˆ 
SetLong
ˆˆ !
(
ˆˆ! "
this
ˆˆ" &
.
ˆˆ& '
Idx
ˆˆ' *
(
ˆˆ* +
index
ˆˆ+ 0
)
ˆˆ0 1
,
ˆˆ1 2
value
ˆˆ3 8
)
ˆˆ8 9
;
ˆˆ9 :
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
¯¯ 	
	protected
˙˙ 
internal
˙˙ 
override
˙˙ #
void
˙˙$ (
_SetLong
˙˙) 1
(
˙˙1 2
int
˙˙2 5
index
˙˙6 ;
,
˙˙; <
long
˙˙= A
value
˙˙B G
)
˙˙G H
=>
˙˙I K
this
˙˙L P
.
˙˙P Q
Unwrap
˙˙Q W
(
˙˙W X
)
˙˙X Y
.
˙˙Y Z
SetLong
˙˙Z a
(
˙˙a b
this
˙˙b f
.
˙˙f g
Idx
˙˙g j
(
˙˙j k
index
˙˙k p
)
˙˙p q
,
˙˙q r
value
˙˙s x
)
˙˙x y
;
˙˙y z
public
¸¸ 
override
¸¸ 
IByteBuffer
¸¸ #
	SetLongLE
¸¸$ -
(
¸¸- .
int
¸¸. 1
index
¸¸2 7
,
¸¸7 8
long
¸¸9 =
value
¸¸> C
)
¸¸C D
{
˝˝ 	
this
˛˛ 
.
˛˛ 
CheckIndex0
˛˛ 
(
˛˛ 
index
˛˛ "
,
˛˛" #
$num
˛˛$ %
)
˛˛% &
;
˛˛& '
this
ˇˇ 
.
ˇˇ 
Unwrap
ˇˇ 
(
ˇˇ 
)
ˇˇ 
.
ˇˇ 
	SetLongLE
ˇˇ #
(
ˇˇ# $
this
ˇˇ$ (
.
ˇˇ( )
Idx
ˇˇ) ,
(
ˇˇ, -
index
ˇˇ- 2
)
ˇˇ2 3
,
ˇˇ3 4
value
ˇˇ5 :
)
ˇˇ: ;
;
ˇˇ; <
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
	protected
ÉÉ 
internal
ÉÉ 
override
ÉÉ #
void
ÉÉ$ (

_SetLongLE
ÉÉ) 3
(
ÉÉ3 4
int
ÉÉ4 7
index
ÉÉ8 =
,
ÉÉ= >
long
ÉÉ? C
value
ÉÉD I
)
ÉÉI J
=>
ÉÉK M
this
ÉÉN R
.
ÉÉR S
Unwrap
ÉÉS Y
(
ÉÉY Z
)
ÉÉZ [
.
ÉÉ[ \
	SetLongLE
ÉÉ\ e
(
ÉÉe f
this
ÉÉf j
.
ÉÉj k
Idx
ÉÉk n
(
ÉÉn o
index
ÉÉo t
)
ÉÉt u
,
ÉÉu v
value
ÉÉw |
)
ÉÉ| }
;
ÉÉ} ~
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ #
SetBytes
ÖÖ$ ,
(
ÖÖ, -
int
ÖÖ- 0
index
ÖÖ1 6
,
ÖÖ6 7
byte
ÖÖ8 <
[
ÖÖ< =
]
ÖÖ= >
src
ÖÖ? B
,
ÖÖB C
int
ÖÖD G
srcIndex
ÖÖH P
,
ÖÖP Q
int
ÖÖR U
length
ÖÖV \
)
ÖÖ\ ]
{
ÜÜ 	
this
áá 
.
áá 
CheckIndex0
áá 
(
áá 
index
áá "
,
áá" #
length
áá$ *
)
áá* +
;
áá+ ,
this
àà 
.
àà 
Unwrap
àà 
(
àà 
)
àà 
.
àà 
SetBytes
àà "
(
àà" #
this
àà# '
.
àà' (
Idx
àà( +
(
àà+ ,
index
àà, 1
)
àà1 2
,
àà2 3
src
àà4 7
,
àà7 8
srcIndex
àà9 A
,
ààA B
length
ààC I
)
ààI J
;
ààJ K
return
ââ 
this
ââ 
;
ââ 
}
ää 	
public
åå 
override
åå 
IByteBuffer
åå #
SetBytes
åå$ ,
(
åå, -
int
åå- 0
index
åå1 6
,
åå6 7
IByteBuffer
åå8 C
src
ååD G
,
ååG H
int
ååI L
srcIndex
ååM U
,
ååU V
int
ååW Z
length
åå[ a
)
ååa b
{
çç 	
this
éé 
.
éé 
CheckIndex0
éé 
(
éé 
index
éé "
,
éé" #
length
éé$ *
)
éé* +
;
éé+ ,
this
èè 
.
èè 
Unwrap
èè 
(
èè 
)
èè 
.
èè 
SetBytes
èè "
(
èè" #
this
èè# '
.
èè' (
Idx
èè( +
(
èè+ ,
index
èè, 1
)
èè1 2
,
èè2 3
src
èè4 7
,
èè7 8
srcIndex
èè9 A
,
èèA B
length
èèC I
)
èèI J
;
èèJ K
return
êê 
this
êê 
;
êê 
}
ëë 	
public
ìì 
override
ìì 
Task
ìì 
<
ìì 
int
ìì  
>
ìì  !
SetBytesAsync
ìì" /
(
ìì/ 0
int
ìì0 3
index
ìì4 9
,
ìì9 :
Stream
ìì; A
src
ììB E
,
ììE F
int
ììG J
length
ììK Q
,
ììQ R
CancellationToken
ììS d
cancellationToken
ììe v
)
ììv w
{
îî 	
this
ïï 
.
ïï 
CheckIndex0
ïï 
(
ïï 
index
ïï "
,
ïï" #
length
ïï$ *
)
ïï* +
;
ïï+ ,
return
ññ 
this
ññ 
.
ññ 
Unwrap
ññ 
(
ññ 
)
ññ  
.
ññ  !
SetBytesAsync
ññ! .
(
ññ. /
index
ññ/ 4
+
ññ5 6
this
ññ7 ;
.
ññ; <

adjustment
ññ< F
,
ññF G
src
ññH K
,
ññK L
length
ññM S
,
ññS T
cancellationToken
ññU f
)
ññf g
;
ññg h
}
óó 	
public
ôô 
override
ôô 
int
ôô 
IoBufferCount
ôô )
=>
ôô* ,
this
ôô- 1
.
ôô1 2
Unwrap
ôô2 8
(
ôô8 9
)
ôô9 :
.
ôô: ;
IoBufferCount
ôô; H
;
ôôH I
public
õõ 
override
õõ 
ArraySegment
õõ $
<
õõ$ %
byte
õõ% )
>
õõ) *
GetIoBuffer
õõ+ 6
(
õõ6 7
int
õõ7 :
index
õõ; @
,
õõ@ A
int
õõB E
length
õõF L
)
õõL M
{
úú 	
this
ùù 
.
ùù 
CheckIndex0
ùù 
(
ùù 
index
ùù "
,
ùù" #
length
ùù$ *
)
ùù* +
;
ùù+ ,
return
ûû 
this
ûû 
.
ûû 
Unwrap
ûû 
(
ûû 
)
ûû  
.
ûû  !
GetIoBuffer
ûû! ,
(
ûû, -
index
ûû- 2
+
ûû3 4
this
ûû5 9
.
ûû9 :

adjustment
ûû: D
,
ûûD E
length
ûûF L
)
ûûL M
;
ûûM N
}
üü 	
public
°° 
override
°° 
ArraySegment
°° $
<
°°$ %
byte
°°% )
>
°°) *
[
°°* +
]
°°+ ,
GetIoBuffers
°°- 9
(
°°9 :
int
°°: =
index
°°> C
,
°°C D
int
°°E H
length
°°I O
)
°°O P
{
¢¢ 	
this
££ 
.
££ 
CheckIndex0
££ 
(
££ 
index
££ "
,
££" #
length
££$ *
)
££* +
;
££+ ,
return
§§ 
this
§§ 
.
§§ 
Unwrap
§§ 
(
§§ 
)
§§  
.
§§  !
GetIoBuffers
§§! -
(
§§- .
index
§§. 3
+
§§4 5
this
§§6 :
.
§§: ;

adjustment
§§; E
,
§§E F
length
§§G M
)
§§M N
;
§§N O
}
•• 	
public
ßß 
override
ßß 
int
ßß 
ForEachByte
ßß '
(
ßß' (
int
ßß( +
index
ßß, 1
,
ßß1 2
int
ßß3 6
length
ßß7 =
,
ßß= >
IByteProcessor
ßß? M
	processor
ßßN W
)
ßßW X
{
®® 	
this
©© 
.
©© 
CheckIndex0
©© 
(
©© 
index
©© "
,
©©" #
length
©©$ *
)
©©* +
;
©©+ ,
int
™™ 
ret
™™ 
=
™™ 
this
™™ 
.
™™ 
Unwrap
™™ !
(
™™! "
)
™™" #
.
™™# $
ForEachByte
™™$ /
(
™™/ 0
this
™™0 4
.
™™4 5
Idx
™™5 8
(
™™8 9
index
™™9 >
)
™™> ?
,
™™? @
length
™™A G
,
™™G H
	processor
™™I R
)
™™R S
;
™™S T
if
´´ 
(
´´ 
ret
´´ 
>=
´´ 
this
´´ 
.
´´ 

adjustment
´´ &
)
´´& '
{
¨¨ 
return
≠≠ 
ret
≠≠ 
-
≠≠ 
this
≠≠ !
.
≠≠! "

adjustment
≠≠" ,
;
≠≠, -
}
ÆÆ 
else
ØØ 
{
∞∞ 
return
±± 
-
±± 
$num
±± 
;
±± 
}
≤≤ 
}
≥≥ 	
public
µµ 
override
µµ 
int
µµ 
ForEachByteDesc
µµ +
(
µµ+ ,
int
µµ, /
index
µµ0 5
,
µµ5 6
int
µµ7 :
length
µµ; A
,
µµA B
IByteProcessor
µµC Q
	processor
µµR [
)
µµ[ \
{
∂∂ 	
this
∑∑ 
.
∑∑ 
CheckIndex0
∑∑ 
(
∑∑ 
index
∑∑ "
,
∑∑" #
length
∑∑$ *
)
∑∑* +
;
∑∑+ ,
int
∏∏ 
ret
∏∏ 
=
∏∏ 
this
∏∏ 
.
∏∏ 
Unwrap
∏∏ !
(
∏∏! "
)
∏∏" #
.
∏∏# $
ForEachByteDesc
∏∏$ 3
(
∏∏3 4
this
∏∏4 8
.
∏∏8 9
Idx
∏∏9 <
(
∏∏< =
index
∏∏= B
)
∏∏B C
,
∏∏C D
length
∏∏E K
,
∏∏K L
	processor
∏∏M V
)
∏∏V W
;
∏∏W X
if
ππ 
(
ππ 
ret
ππ 
>=
ππ 
this
ππ 
.
ππ 

adjustment
ππ &
)
ππ& '
{
∫∫ 
return
ªª 
ret
ªª 
-
ªª 
this
ªª !
.
ªª! "

adjustment
ªª" ,
;
ªª, -
}
ºº 
else
ΩΩ 
{
ææ 
return
øø 
-
øø 
$num
øø 
;
øø 
}
¿¿ 
}
¡¡ 	
	protected
ƒƒ 
int
ƒƒ 
Idx
ƒƒ 
(
ƒƒ 
int
ƒƒ 
index
ƒƒ #
)
ƒƒ# $
=>
ƒƒ% '
index
ƒƒ( -
+
ƒƒ. /
this
ƒƒ0 4
.
ƒƒ4 5

adjustment
ƒƒ5 ?
;
ƒƒ? @
internal
∆∆ 
static
∆∆ 
void
∆∆ #
CheckSliceOutOfBounds
∆∆ 2
(
∆∆2 3
int
∆∆3 6
index
∆∆7 <
,
∆∆< =
int
∆∆> A
length
∆∆B H
,
∆∆H I
IByteBuffer
∆∆J U
buffer
∆∆V \
)
∆∆\ ]
{
«« 	
if
»» 
(
»» 
MathUtil
»» 
.
»» 
IsOutOfBounds
»» &
(
»»& '
index
»»' ,
,
»», -
length
»». 4
,
»»4 5
buffer
»»6 <
.
»»< =
Capacity
»»= E
)
»»E F
)
»»F G
{
…… 
throw
   
new
   &
IndexOutOfRangeException
   2
(
  2 3
$"
  3 5
{
  5 6
buffer
  6 <
}
  < =
$str
  = D
{
  D E
index
  E J
}
  J K
$str
  K M
{
  M N
length
  N T
}
  T U
$str
  U V
"
  V W
)
  W X
;
  X Y
}
ÀÀ 
}
ÃÃ 	
}
ÕÕ 
}ŒŒ √«
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AdvancedLeakAwareByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class '
AdvancedLeakAwareByteBuffer ,
:- .%
SimpleLeakAwareByteBuffer/ H
{ 
const 
string %
PropAcquireAndReleaseOnly .
=/ 0
$str1 _
;_ `
static 
readonly 
bool !
AcquireAndReleaseOnly 2
;2 3
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S'
AdvancedLeakAwareByteBufferS n
>n o
(o p
)p q
;q r
static '
AdvancedLeakAwareByteBuffer *
(* +
)+ ,
{ 	!
AcquireAndReleaseOnly !
=" #
SystemPropertyUtil$ 6
.6 7

GetBoolean7 A
(A B%
PropAcquireAndReleaseOnlyB [
,[ \
false] b
)b c
;c d
if 
( 
Logger 
. 
DebugEnabled #
)# $
{ 
Logger 
. 
Debug 
( 
$str '
,' (%
PropAcquireAndReleaseOnly) B
,B C!
AcquireAndReleaseOnlyD Y
)Y Z
;Z [
} 
} 	
internal!! '
AdvancedLeakAwareByteBuffer!! ,
(!!, -
IByteBuffer!!- 8
buf!!9 <
,!!< = 
IResourceLeakTracker!!> R
leak!!S W
)!!W X
:"" 
base"" 
("" 
buf"" 
,"" 
leak"" 
)"" 
{## 	
}$$ 	
internal&& '
AdvancedLeakAwareByteBuffer&& ,
(&&, -
IByteBuffer&&- 8
wrapped&&9 @
,&&@ A
IByteBuffer&&B M
trackedByteBuf&&N \
,&&\ ] 
IResourceLeakTracker&&^ r
leak&&s w
)&&w x
:'' 
base'' 
('' 
wrapped'' 
,'' 
trackedByteBuf'' *
,''* +
leak'', 0
)''0 1
{(( 	
})) 	
internal++ 
static++ 
void++ -
!RecordLeakNonRefCountingOperation++ >
(++> ? 
IResourceLeakTracker++? S
leak++T X
)++X Y
{,, 	
if-- 
(-- 
!-- !
AcquireAndReleaseOnly-- &
)--& '
{.. 
leak// 
.// 
Record// 
(// 
)// 
;// 
}00 
}11 	
public33 
override33 
IByteBuffer33 #
Slice33$ )
(33) *
)33* +
{44 	-
!RecordLeakNonRefCountingOperation55 -
(55- .
this55. 2
.552 3
Leak553 7
)557 8
;558 9
return66 
base66 
.66 
Slice66 
(66 
)66 
;66  
}77 	
public99 
override99 
IByteBuffer99 #
Slice99$ )
(99) *
int99* -
index99. 3
,993 4
int995 8
length999 ?
)99? @
{:: 	-
!RecordLeakNonRefCountingOperation;; -
(;;- .
this;;. 2
.;;2 3
Leak;;3 7
);;7 8
;;;8 9
return<< 
base<< 
.<< 
Slice<< 
(<< 
index<< #
,<<# $
length<<% +
)<<+ ,
;<<, -
}== 	
public?? 
override?? 
IByteBuffer?? #
	Duplicate??$ -
(??- .
)??. /
{@@ 	-
!RecordLeakNonRefCountingOperationAA -
(AA- .
thisAA. 2
.AA2 3
LeakAA3 7
)AA7 8
;AA8 9
returnBB 
baseBB 
.BB 
	DuplicateBB !
(BB! "
)BB" #
;BB# $
}CC 	
publicEE 
overrideEE 
IByteBufferEE #
	ReadSliceEE$ -
(EE- .
intEE. 1
lengthEE2 8
)EE8 9
{FF 	-
!RecordLeakNonRefCountingOperationGG -
(GG- .
thisGG. 2
.GG2 3
LeakGG3 7
)GG7 8
;GG8 9
returnHH 
baseHH 
.HH 
	ReadSliceHH !
(HH! "
lengthHH" (
)HH( )
;HH) *
}II 	
publicKK 
overrideKK 
IByteBufferKK #
DiscardReadBytesKK$ 4
(KK4 5
)KK5 6
{LL 	-
!RecordLeakNonRefCountingOperationMM -
(MM- .
thisMM. 2
.MM2 3
LeakMM3 7
)MM7 8
;MM8 9
returnNN 
baseNN 
.NN 
DiscardReadBytesNN (
(NN( )
)NN) *
;NN* +
}OO 	
publicQQ 
overrideQQ 
IByteBufferQQ # 
DiscardSomeReadBytesQQ$ 8
(QQ8 9
)QQ9 :
{RR 	-
!RecordLeakNonRefCountingOperationSS -
(SS- .
thisSS. 2
.SS2 3
LeakSS3 7
)SS7 8
;SS8 9
returnTT 
baseTT 
.TT  
DiscardSomeReadBytesTT ,
(TT, -
)TT- .
;TT. /
}UU 	
publicWW 
overrideWW 
IByteBufferWW #
EnsureWritableWW$ 2
(WW2 3
intWW3 6
minWritableBytesWW7 G
)WWG H
{XX 	-
!RecordLeakNonRefCountingOperationYY -
(YY- .
thisYY. 2
.YY2 3
LeakYY3 7
)YY7 8
;YY8 9
returnZZ 
baseZZ 
.ZZ 
EnsureWritableZZ &
(ZZ& '
minWritableBytesZZ' 7
)ZZ7 8
;ZZ8 9
}[[ 	
public]] 
override]] 
int]] 
EnsureWritable]] *
(]]* +
int]]+ .
minWritableBytes]]/ ?
,]]? @
bool]]A E
force]]F K
)]]K L
{^^ 	-
!RecordLeakNonRefCountingOperation__ -
(__- .
this__. 2
.__2 3
Leak__3 7
)__7 8
;__8 9
return`` 
base`` 
.`` 
EnsureWritable`` &
(``& '
minWritableBytes``' 7
,``7 8
force``9 >
)``> ?
;``? @
}aa 	
publiccc 
overridecc 
boolcc 

GetBooleancc '
(cc' (
intcc( +
indexcc, 1
)cc1 2
{dd 	-
!RecordLeakNonRefCountingOperationee -
(ee- .
thisee. 2
.ee2 3
Leakee3 7
)ee7 8
;ee8 9
returnff 
baseff 
.ff 

GetBooleanff "
(ff" #
indexff# (
)ff( )
;ff) *
}gg 	
publicii 
overrideii 
byteii 
GetByteii $
(ii$ %
intii% (
indexii) .
)ii. /
{jj 	-
!RecordLeakNonRefCountingOperationkk -
(kk- .
thiskk. 2
.kk2 3
Leakkk3 7
)kk7 8
;kk8 9
returnll 
basell 
.ll 
GetBytell 
(ll  
indexll  %
)ll% &
;ll& '
}mm 	
publicoo 
overrideoo 
intoo 
	GetMediumoo %
(oo% &
intoo& )
indexoo* /
)oo/ 0
{pp 	-
!RecordLeakNonRefCountingOperationqq -
(qq- .
thisqq. 2
.qq2 3
Leakqq3 7
)qq7 8
;qq8 9
returnrr 
baserr 
.rr 
	GetMediumrr !
(rr! "
indexrr" '
)rr' (
;rr( )
}ss 	
publicuu 
overrideuu 
intuu 
GetUnsignedMediumuu -
(uu- .
intuu. 1
indexuu2 7
)uu7 8
{vv 	-
!RecordLeakNonRefCountingOperationww -
(ww- .
thisww. 2
.ww2 3
Leakww3 7
)ww7 8
;ww8 9
returnxx 
basexx 
.xx 
GetUnsignedMediumxx )
(xx) *
indexxx* /
)xx/ 0
;xx0 1
}yy 	
public{{ 
override{{ 
short{{ 
GetShort{{ &
({{& '
int{{' *
index{{+ 0
){{0 1
{|| 	-
!RecordLeakNonRefCountingOperation}} -
(}}- .
this}}. 2
.}}2 3
Leak}}3 7
)}}7 8
;}}8 9
return~~ 
base~~ 
.~~ 
GetShort~~  
(~~  !
index~~! &
)~~& '
;~~' (
} 	
public
ÅÅ 
override
ÅÅ 
ushort
ÅÅ 
GetUnsignedShort
ÅÅ /
(
ÅÅ/ 0
int
ÅÅ0 3
index
ÅÅ4 9
)
ÅÅ9 :
{
ÇÇ 	/
!RecordLeakNonRefCountingOperation
ÉÉ -
(
ÉÉ- .
this
ÉÉ. 2
.
ÉÉ2 3
Leak
ÉÉ3 7
)
ÉÉ7 8
;
ÉÉ8 9
return
ÑÑ 
base
ÑÑ 
.
ÑÑ 
GetUnsignedShort
ÑÑ (
(
ÑÑ( )
index
ÑÑ) .
)
ÑÑ. /
;
ÑÑ/ 0
}
ÖÖ 	
public
áá 
override
áá 
int
áá 
GetInt
áá "
(
áá" #
int
áá# &
index
áá' ,
)
áá, -
{
àà 	/
!RecordLeakNonRefCountingOperation
ââ -
(
ââ- .
this
ââ. 2
.
ââ2 3
Leak
ââ3 7
)
ââ7 8
;
ââ8 9
return
ää 
base
ää 
.
ää 
GetInt
ää 
(
ää 
index
ää $
)
ää$ %
;
ää% &
}
ãã 	
public
çç 
override
çç 
uint
çç 
GetUnsignedInt
çç +
(
çç+ ,
int
çç, /
index
çç0 5
)
çç5 6
{
éé 	/
!RecordLeakNonRefCountingOperation
èè -
(
èè- .
this
èè. 2
.
èè2 3
Leak
èè3 7
)
èè7 8
;
èè8 9
return
êê 
base
êê 
.
êê 
GetUnsignedInt
êê &
(
êê& '
index
êê' ,
)
êê, -
;
êê- .
}
ëë 	
public
ìì 
override
ìì 
long
ìì 
GetLong
ìì $
(
ìì$ %
int
ìì% (
index
ìì) .
)
ìì. /
{
îî 	/
!RecordLeakNonRefCountingOperation
ïï -
(
ïï- .
this
ïï. 2
.
ïï2 3
Leak
ïï3 7
)
ïï7 8
;
ïï8 9
return
ññ 
base
ññ 
.
ññ 
GetLong
ññ 
(
ññ  
index
ññ  %
)
ññ% &
;
ññ& '
}
óó 	
public
ôô 
override
ôô 
char
ôô 
GetChar
ôô $
(
ôô$ %
int
ôô% (
index
ôô) .
)
ôô. /
{
öö 	/
!RecordLeakNonRefCountingOperation
õõ -
(
õõ- .
this
õõ. 2
.
õõ2 3
Leak
õõ3 7
)
õõ7 8
;
õõ8 9
return
úú 
base
úú 
.
úú 
GetChar
úú 
(
úú  
index
úú  %
)
úú% &
;
úú& '
}
ùù 	
public
üü 
override
üü 
float
üü 
GetFloat
üü &
(
üü& '
int
üü' *
index
üü+ 0
)
üü0 1
{
†† 	/
!RecordLeakNonRefCountingOperation
°° -
(
°°- .
this
°°. 2
.
°°2 3
Leak
°°3 7
)
°°7 8
;
°°8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
GetFloat
¢¢  
(
¢¢  !
index
¢¢! &
)
¢¢& '
;
¢¢' (
}
££ 	
public
•• 
override
•• 
double
•• 
	GetDouble
•• (
(
••( )
int
••) ,
index
••- 2
)
••2 3
{
¶¶ 	/
!RecordLeakNonRefCountingOperation
ßß -
(
ßß- .
this
ßß. 2
.
ßß2 3
Leak
ßß3 7
)
ßß7 8
;
ßß8 9
return
®® 
base
®® 
.
®® 
	GetDouble
®® !
(
®®! "
index
®®" '
)
®®' (
;
®®( )
}
©© 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
GetBytes
´´$ ,
(
´´, -
int
´´- 0
index
´´1 6
,
´´6 7
IByteBuffer
´´8 C
dst
´´D G
)
´´G H
{
¨¨ 	/
!RecordLeakNonRefCountingOperation
≠≠ -
(
≠≠- .
this
≠≠. 2
.
≠≠2 3
Leak
≠≠3 7
)
≠≠7 8
;
≠≠8 9
return
ÆÆ 
base
ÆÆ 
.
ÆÆ 
GetBytes
ÆÆ  
(
ÆÆ  !
index
ÆÆ! &
,
ÆÆ& '
dst
ÆÆ( +
)
ÆÆ+ ,
;
ÆÆ, -
}
ØØ 	
public
±± 
override
±± 
IByteBuffer
±± #
GetBytes
±±$ ,
(
±±, -
int
±±- 0
index
±±1 6
,
±±6 7
IByteBuffer
±±8 C
dst
±±D G
,
±±G H
int
±±I L
length
±±M S
)
±±S T
{
≤≤ 	/
!RecordLeakNonRefCountingOperation
≥≥ -
(
≥≥- .
this
≥≥. 2
.
≥≥2 3
Leak
≥≥3 7
)
≥≥7 8
;
≥≥8 9
return
¥¥ 
base
¥¥ 
.
¥¥ 
GetBytes
¥¥  
(
¥¥  !
index
¥¥! &
,
¥¥& '
dst
¥¥( +
,
¥¥+ ,
length
¥¥- 3
)
¥¥3 4
;
¥¥4 5
}
µµ 	
public
∑∑ 
override
∑∑ 
IByteBuffer
∑∑ #
GetBytes
∑∑$ ,
(
∑∑, -
int
∑∑- 0
index
∑∑1 6
,
∑∑6 7
IByteBuffer
∑∑8 C
dst
∑∑D G
,
∑∑G H
int
∑∑I L
dstIndex
∑∑M U
,
∑∑U V
int
∑∑W Z
length
∑∑[ a
)
∑∑a b
{
∏∏ 	/
!RecordLeakNonRefCountingOperation
ππ -
(
ππ- .
this
ππ. 2
.
ππ2 3
Leak
ππ3 7
)
ππ7 8
;
ππ8 9
return
∫∫ 
base
∫∫ 
.
∫∫ 
GetBytes
∫∫  
(
∫∫  !
index
∫∫! &
,
∫∫& '
dst
∫∫( +
,
∫∫+ ,
dstIndex
∫∫- 5
,
∫∫5 6
length
∫∫7 =
)
∫∫= >
;
∫∫> ?
}
ªª 	
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
GetBytes
ΩΩ$ ,
(
ΩΩ, -
int
ΩΩ- 0
index
ΩΩ1 6
,
ΩΩ6 7
byte
ΩΩ8 <
[
ΩΩ< =
]
ΩΩ= >
dst
ΩΩ? B
)
ΩΩB C
{
ææ 	/
!RecordLeakNonRefCountingOperation
øø -
(
øø- .
this
øø. 2
.
øø2 3
Leak
øø3 7
)
øø7 8
;
øø8 9
return
¿¿ 
base
¿¿ 
.
¿¿ 
GetBytes
¿¿  
(
¿¿  !
index
¿¿! &
,
¿¿& '
dst
¿¿( +
)
¿¿+ ,
;
¿¿, -
}
¡¡ 	
public
√√ 
override
√√ 
IByteBuffer
√√ #
GetBytes
√√$ ,
(
√√, -
int
√√- 0
index
√√1 6
,
√√6 7
byte
√√8 <
[
√√< =
]
√√= >
dst
√√? B
,
√√B C
int
√√D G
dstIndex
√√H P
,
√√P Q
int
√√R U
length
√√V \
)
√√\ ]
{
ƒƒ 	/
!RecordLeakNonRefCountingOperation
≈≈ -
(
≈≈- .
this
≈≈. 2
.
≈≈2 3
Leak
≈≈3 7
)
≈≈7 8
;
≈≈8 9
return
∆∆ 
base
∆∆ 
.
∆∆ 
GetBytes
∆∆  
(
∆∆  !
index
∆∆! &
,
∆∆& '
dst
∆∆( +
,
∆∆+ ,
dstIndex
∆∆- 5
,
∆∆5 6
length
∆∆7 =
)
∆∆= >
;
∆∆> ?
}
«« 	
public
…… 
override
…… 
IByteBuffer
…… #

SetBoolean
……$ .
(
……. /
int
……/ 2
index
……3 8
,
……8 9
bool
……: >
value
……? D
)
……D E
{
   	/
!RecordLeakNonRefCountingOperation
ÀÀ -
(
ÀÀ- .
this
ÀÀ. 2
.
ÀÀ2 3
Leak
ÀÀ3 7
)
ÀÀ7 8
;
ÀÀ8 9
return
ÃÃ 
base
ÃÃ 
.
ÃÃ 

SetBoolean
ÃÃ "
(
ÃÃ" #
index
ÃÃ# (
,
ÃÃ( )
value
ÃÃ* /
)
ÃÃ/ 0
;
ÃÃ0 1
}
ÕÕ 	
public
œœ 
override
œœ 
IByteBuffer
œœ #
SetByte
œœ$ +
(
œœ+ ,
int
œœ, /
index
œœ0 5
,
œœ5 6
int
œœ7 :
value
œœ; @
)
œœ@ A
{
–– 	/
!RecordLeakNonRefCountingOperation
—— -
(
——- .
this
——. 2
.
——2 3
Leak
——3 7
)
——7 8
;
——8 9
return
““ 
base
““ 
.
““ 
SetByte
““ 
(
““  
index
““  %
,
““% &
value
““' ,
)
““, -
;
““- .
}
”” 	
public
’’ 
override
’’ 
IByteBuffer
’’ #
	SetMedium
’’$ -
(
’’- .
int
’’. 1
index
’’2 7
,
’’7 8
int
’’9 <
value
’’= B
)
’’B C
{
÷÷ 	/
!RecordLeakNonRefCountingOperation
◊◊ -
(
◊◊- .
this
◊◊. 2
.
◊◊2 3
Leak
◊◊3 7
)
◊◊7 8
;
◊◊8 9
return
ÿÿ 
base
ÿÿ 
.
ÿÿ 
	SetMedium
ÿÿ !
(
ÿÿ! "
index
ÿÿ" '
,
ÿÿ' (
value
ÿÿ) .
)
ÿÿ. /
;
ÿÿ/ 0
}
ŸŸ 	
public
€€ 
override
€€ 
IByteBuffer
€€ #
SetShort
€€$ ,
(
€€, -
int
€€- 0
index
€€1 6
,
€€6 7
int
€€8 ;
value
€€< A
)
€€A B
{
‹‹ 	/
!RecordLeakNonRefCountingOperation
›› -
(
››- .
this
››. 2
.
››2 3
Leak
››3 7
)
››7 8
;
››8 9
return
ﬁﬁ 
base
ﬁﬁ 
.
ﬁﬁ 
SetShort
ﬁﬁ  
(
ﬁﬁ  !
index
ﬁﬁ! &
,
ﬁﬁ& '
value
ﬁﬁ( -
)
ﬁﬁ- .
;
ﬁﬁ. /
}
ﬂﬂ 	
public
·· 
override
·· 
IByteBuffer
·· #
SetInt
··$ *
(
··* +
int
··+ .
index
··/ 4
,
··4 5
int
··6 9
value
··: ?
)
··? @
{
‚‚ 	/
!RecordLeakNonRefCountingOperation
„„ -
(
„„- .
this
„„. 2
.
„„2 3
Leak
„„3 7
)
„„7 8
;
„„8 9
return
‰‰ 
base
‰‰ 
.
‰‰ 
SetInt
‰‰ 
(
‰‰ 
index
‰‰ $
,
‰‰$ %
value
‰‰& +
)
‰‰+ ,
;
‰‰, -
}
ÂÂ 	
public
ÁÁ 
override
ÁÁ 
IByteBuffer
ÁÁ #
SetLong
ÁÁ$ +
(
ÁÁ+ ,
int
ÁÁ, /
index
ÁÁ0 5
,
ÁÁ5 6
long
ÁÁ7 ;
value
ÁÁ< A
)
ÁÁA B
{
ËË 	/
!RecordLeakNonRefCountingOperation
ÈÈ -
(
ÈÈ- .
this
ÈÈ. 2
.
ÈÈ2 3
Leak
ÈÈ3 7
)
ÈÈ7 8
;
ÈÈ8 9
return
ÍÍ 
base
ÍÍ 
.
ÍÍ 
SetLong
ÍÍ 
(
ÍÍ  
index
ÍÍ  %
,
ÍÍ% &
value
ÍÍ' ,
)
ÍÍ, -
;
ÍÍ- .
}
ÎÎ 	
public
ÌÌ 
override
ÌÌ 
IByteBuffer
ÌÌ #
SetChar
ÌÌ$ +
(
ÌÌ+ ,
int
ÌÌ, /
index
ÌÌ0 5
,
ÌÌ5 6
char
ÌÌ7 ;
value
ÌÌ< A
)
ÌÌA B
{
ÓÓ 	/
!RecordLeakNonRefCountingOperation
ÔÔ -
(
ÔÔ- .
this
ÔÔ. 2
.
ÔÔ2 3
Leak
ÔÔ3 7
)
ÔÔ7 8
;
ÔÔ8 9
return
 
base
 
.
 
SetChar
 
(
  
index
  %
,
% &
value
' ,
)
, -
;
- .
}
ÒÒ 	
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #
SetFloat
ÛÛ$ ,
(
ÛÛ, -
int
ÛÛ- 0
index
ÛÛ1 6
,
ÛÛ6 7
float
ÛÛ8 =
value
ÛÛ> C
)
ÛÛC D
{
ÙÙ 	/
!RecordLeakNonRefCountingOperation
ıı -
(
ıı- .
this
ıı. 2
.
ıı2 3
Leak
ıı3 7
)
ıı7 8
;
ıı8 9
return
ˆˆ 
base
ˆˆ 
.
ˆˆ 
SetFloat
ˆˆ  
(
ˆˆ  !
index
ˆˆ! &
,
ˆˆ& '
value
ˆˆ( -
)
ˆˆ- .
;
ˆˆ. /
}
˜˜ 	
public
˘˘ 
override
˘˘ 
IByteBuffer
˘˘ #
	SetDouble
˘˘$ -
(
˘˘- .
int
˘˘. 1
index
˘˘2 7
,
˘˘7 8
double
˘˘9 ?
value
˘˘@ E
)
˘˘E F
{
˙˙ 	/
!RecordLeakNonRefCountingOperation
˚˚ -
(
˚˚- .
this
˚˚. 2
.
˚˚2 3
Leak
˚˚3 7
)
˚˚7 8
;
˚˚8 9
return
¸¸ 
base
¸¸ 
.
¸¸ 
	SetDouble
¸¸ !
(
¸¸! "
index
¸¸" '
,
¸¸' (
value
¸¸) .
)
¸¸. /
;
¸¸/ 0
}
˝˝ 	
public
ˇˇ 
override
ˇˇ 
IByteBuffer
ˇˇ #
SetBytes
ˇˇ$ ,
(
ˇˇ, -
int
ˇˇ- 0
index
ˇˇ1 6
,
ˇˇ6 7
IByteBuffer
ˇˇ8 C
src
ˇˇD G
)
ˇˇG H
{
ÄÄ 	/
!RecordLeakNonRefCountingOperation
ÅÅ -
(
ÅÅ- .
this
ÅÅ. 2
.
ÅÅ2 3
Leak
ÅÅ3 7
)
ÅÅ7 8
;
ÅÅ8 9
return
ÇÇ 
base
ÇÇ 
.
ÇÇ 
SetBytes
ÇÇ  
(
ÇÇ  !
index
ÇÇ! &
,
ÇÇ& '
src
ÇÇ( +
)
ÇÇ+ ,
;
ÇÇ, -
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ #
SetBytes
ÖÖ$ ,
(
ÖÖ, -
int
ÖÖ- 0
index
ÖÖ1 6
,
ÖÖ6 7
IByteBuffer
ÖÖ8 C
src
ÖÖD G
,
ÖÖG H
int
ÖÖI L
length
ÖÖM S
)
ÖÖS T
{
ÜÜ 	/
!RecordLeakNonRefCountingOperation
áá -
(
áá- .
this
áá. 2
.
áá2 3
Leak
áá3 7
)
áá7 8
;
áá8 9
return
àà 
base
àà 
.
àà 
SetBytes
àà  
(
àà  !
index
àà! &
,
àà& '
src
àà( +
,
àà+ ,
length
àà- 3
)
àà3 4
;
àà4 5
}
ââ 	
public
ãã 
override
ãã 
IByteBuffer
ãã #
SetBytes
ãã$ ,
(
ãã, -
int
ãã- 0
index
ãã1 6
,
ãã6 7
IByteBuffer
ãã8 C
src
ããD G
,
ããG H
int
ããI L
srcIndex
ããM U
,
ããU V
int
ããW Z
length
ãã[ a
)
ããa b
{
åå 	/
!RecordLeakNonRefCountingOperation
çç -
(
çç- .
this
çç. 2
.
çç2 3
Leak
çç3 7
)
çç7 8
;
çç8 9
return
éé 
base
éé 
.
éé 
SetBytes
éé  
(
éé  !
index
éé! &
,
éé& '
src
éé( +
,
éé+ ,
srcIndex
éé- 5
,
éé5 6
length
éé7 =
)
éé= >
;
éé> ?
}
èè 	
public
ëë 
override
ëë 
IByteBuffer
ëë #
SetBytes
ëë$ ,
(
ëë, -
int
ëë- 0
index
ëë1 6
,
ëë6 7
byte
ëë8 <
[
ëë< =
]
ëë= >
src
ëë? B
)
ëëB C
{
íí 	/
!RecordLeakNonRefCountingOperation
ìì -
(
ìì- .
this
ìì. 2
.
ìì2 3
Leak
ìì3 7
)
ìì7 8
;
ìì8 9
return
îî 
base
îî 
.
îî 
SetBytes
îî  
(
îî  !
index
îî! &
,
îî& '
src
îî( +
)
îî+ ,
;
îî, -
}
ïï 	
public
óó 
override
óó 
IByteBuffer
óó #
SetBytes
óó$ ,
(
óó, -
int
óó- 0
index
óó1 6
,
óó6 7
byte
óó8 <
[
óó< =
]
óó= >
src
óó? B
,
óóB C
int
óóD G
srcIndex
óóH P
,
óóP Q
int
óóR U
length
óóV \
)
óó\ ]
{
òò 	/
!RecordLeakNonRefCountingOperation
ôô -
(
ôô- .
this
ôô. 2
.
ôô2 3
Leak
ôô3 7
)
ôô7 8
;
ôô8 9
return
öö 
base
öö 
.
öö 
SetBytes
öö  
(
öö  !
index
öö! &
,
öö& '
src
öö( +
,
öö+ ,
srcIndex
öö- 5
,
öö5 6
length
öö7 =
)
öö= >
;
öö> ?
}
õõ 	
public
ùù 
override
ùù 
Task
ùù 
<
ùù 
int
ùù  
>
ùù  !
SetBytesAsync
ùù" /
(
ùù/ 0
int
ùù0 3
index
ùù4 9
,
ùù9 :
Stream
ùù; A
input
ùùB G
,
ùùG H
int
ùùI L
length
ùùM S
,
ùùS T
CancellationToken
ùùU f
cancellationToken
ùùg x
)
ùùx y
{
ûû 	/
!RecordLeakNonRefCountingOperation
üü -
(
üü- .
this
üü. 2
.
üü2 3
Leak
üü3 7
)
üü7 8
;
üü8 9
return
†† 
base
†† 
.
†† 
SetBytesAsync
†† %
(
††% &
index
††& +
,
††+ ,
input
††- 2
,
††2 3
length
††4 :
,
††: ;
cancellationToken
††< M
)
††M N
;
††N O
}
°° 	
public
££ 
override
££ 
IByteBuffer
££ #
SetZero
££$ +
(
££+ ,
int
££, /
index
££0 5
,
££5 6
int
££7 :
length
££; A
)
££A B
{
§§ 	/
!RecordLeakNonRefCountingOperation
•• -
(
••- .
this
••. 2
.
••2 3
Leak
••3 7
)
••7 8
;
••8 9
return
¶¶ 
base
¶¶ 
.
¶¶ 
SetZero
¶¶ 
(
¶¶  
index
¶¶  %
,
¶¶% &
length
¶¶' -
)
¶¶- .
;
¶¶. /
}
ßß 	
public
©© 
override
©© 
bool
©© 
ReadBoolean
©© (
(
©©( )
)
©©) *
{
™™ 	/
!RecordLeakNonRefCountingOperation
´´ -
(
´´- .
this
´´. 2
.
´´2 3
Leak
´´3 7
)
´´7 8
;
´´8 9
return
¨¨ 
base
¨¨ 
.
¨¨ 
ReadBoolean
¨¨ #
(
¨¨# $
)
¨¨$ %
;
¨¨% &
}
≠≠ 	
public
ØØ 
override
ØØ 
byte
ØØ 
ReadByte
ØØ %
(
ØØ% &
)
ØØ& '
{
∞∞ 	/
!RecordLeakNonRefCountingOperation
±± -
(
±±- .
this
±±. 2
.
±±2 3
Leak
±±3 7
)
±±7 8
;
±±8 9
return
≤≤ 
base
≤≤ 
.
≤≤ 
ReadByte
≤≤  
(
≤≤  !
)
≤≤! "
;
≤≤" #
}
≥≥ 	
public
µµ 
override
µµ 
short
µµ 
	ReadShort
µµ '
(
µµ' (
)
µµ( )
{
∂∂ 	/
!RecordLeakNonRefCountingOperation
∑∑ -
(
∑∑- .
this
∑∑. 2
.
∑∑2 3
Leak
∑∑3 7
)
∑∑7 8
;
∑∑8 9
return
∏∏ 
base
∏∏ 
.
∏∏ 
	ReadShort
∏∏ !
(
∏∏! "
)
∏∏" #
;
∏∏# $
}
ππ 	
public
ªª 
override
ªª 
ushort
ªª 
ReadUnsignedShort
ªª 0
(
ªª0 1
)
ªª1 2
{
ºº 	/
!RecordLeakNonRefCountingOperation
ΩΩ -
(
ΩΩ- .
this
ΩΩ. 2
.
ΩΩ2 3
Leak
ΩΩ3 7
)
ΩΩ7 8
;
ΩΩ8 9
return
ææ 
base
ææ 
.
ææ 
ReadUnsignedShort
ææ )
(
ææ) *
)
ææ* +
;
ææ+ ,
}
øø 	
public
¡¡ 
override
¡¡ 
int
¡¡ 

ReadMedium
¡¡ &
(
¡¡& '
)
¡¡' (
{
¬¬ 	/
!RecordLeakNonRefCountingOperation
√√ -
(
√√- .
this
√√. 2
.
√√2 3
Leak
√√3 7
)
√√7 8
;
√√8 9
return
ƒƒ 
base
ƒƒ 
.
ƒƒ 

ReadMedium
ƒƒ "
(
ƒƒ" #
)
ƒƒ# $
;
ƒƒ$ %
}
≈≈ 	
public
«« 
override
«« 
int
««  
ReadUnsignedMedium
«« .
(
««. /
)
««/ 0
{
»» 	/
!RecordLeakNonRefCountingOperation
…… -
(
……- .
this
……. 2
.
……2 3
Leak
……3 7
)
……7 8
;
……8 9
return
   
base
   
.
    
ReadUnsignedMedium
   *
(
  * +
)
  + ,
;
  , -
}
ÀÀ 	
public
ÕÕ 
override
ÕÕ 
int
ÕÕ 
ReadInt
ÕÕ #
(
ÕÕ# $
)
ÕÕ$ %
{
ŒŒ 	/
!RecordLeakNonRefCountingOperation
œœ -
(
œœ- .
this
œœ. 2
.
œœ2 3
Leak
œœ3 7
)
œœ7 8
;
œœ8 9
return
–– 
base
–– 
.
–– 
ReadInt
–– 
(
––  
)
––  !
;
––! "
}
—— 	
public
”” 
override
”” 
uint
”” 
ReadUnsignedInt
”” ,
(
””, -
)
””- .
{
‘‘ 	/
!RecordLeakNonRefCountingOperation
’’ -
(
’’- .
this
’’. 2
.
’’2 3
Leak
’’3 7
)
’’7 8
;
’’8 9
return
÷÷ 
base
÷÷ 
.
÷÷ 
ReadUnsignedInt
÷÷ '
(
÷÷' (
)
÷÷( )
;
÷÷) *
}
◊◊ 	
public
ŸŸ 
override
ŸŸ 
long
ŸŸ 
ReadLong
ŸŸ %
(
ŸŸ% &
)
ŸŸ& '
{
⁄⁄ 	/
!RecordLeakNonRefCountingOperation
€€ -
(
€€- .
this
€€. 2
.
€€2 3
Leak
€€3 7
)
€€7 8
;
€€8 9
return
‹‹ 
base
‹‹ 
.
‹‹ 
ReadLong
‹‹  
(
‹‹  !
)
‹‹! "
;
‹‹" #
}
›› 	
public
ﬂﬂ 
override
ﬂﬂ 
char
ﬂﬂ 
ReadChar
ﬂﬂ %
(
ﬂﬂ% &
)
ﬂﬂ& '
{
‡‡ 	/
!RecordLeakNonRefCountingOperation
·· -
(
··- .
this
··. 2
.
··2 3
Leak
··3 7
)
··7 8
;
··8 9
return
‚‚ 
base
‚‚ 
.
‚‚ 
ReadChar
‚‚  
(
‚‚  !
)
‚‚! "
;
‚‚" #
}
„„ 	
public
ÂÂ 
override
ÂÂ 
float
ÂÂ 
	ReadFloat
ÂÂ '
(
ÂÂ' (
)
ÂÂ( )
{
ÊÊ 	/
!RecordLeakNonRefCountingOperation
ÁÁ -
(
ÁÁ- .
this
ÁÁ. 2
.
ÁÁ2 3
Leak
ÁÁ3 7
)
ÁÁ7 8
;
ÁÁ8 9
return
ËË 
base
ËË 
.
ËË 
	ReadFloat
ËË !
(
ËË! "
)
ËË" #
;
ËË# $
}
ÈÈ 	
public
ÎÎ 
override
ÎÎ 
double
ÎÎ 

ReadDouble
ÎÎ )
(
ÎÎ) *
)
ÎÎ* +
{
ÏÏ 	/
!RecordLeakNonRefCountingOperation
ÌÌ -
(
ÌÌ- .
this
ÌÌ. 2
.
ÌÌ2 3
Leak
ÌÌ3 7
)
ÌÌ7 8
;
ÌÌ8 9
return
ÓÓ 
base
ÓÓ 
.
ÓÓ 

ReadDouble
ÓÓ "
(
ÓÓ" #
)
ÓÓ# $
;
ÓÓ$ %
}
ÔÔ 	
public
ÒÒ 
override
ÒÒ 
IByteBuffer
ÒÒ #
	ReadBytes
ÒÒ$ -
(
ÒÒ- .
int
ÒÒ. 1
length
ÒÒ2 8
)
ÒÒ8 9
{
ÚÚ 	/
!RecordLeakNonRefCountingOperation
ÛÛ -
(
ÛÛ- .
this
ÛÛ. 2
.
ÛÛ2 3
Leak
ÛÛ3 7
)
ÛÛ7 8
;
ÛÛ8 9
return
ÙÙ 
base
ÙÙ 
.
ÙÙ 
	ReadBytes
ÙÙ !
(
ÙÙ! "
length
ÙÙ" (
)
ÙÙ( )
;
ÙÙ) *
}
ıı 	
public
˜˜ 
override
˜˜ 
IByteBuffer
˜˜ #
	ReadBytes
˜˜$ -
(
˜˜- .
IByteBuffer
˜˜. 9
dst
˜˜: =
)
˜˜= >
{
¯¯ 	/
!RecordLeakNonRefCountingOperation
˘˘ -
(
˘˘- .
this
˘˘. 2
.
˘˘2 3
Leak
˘˘3 7
)
˘˘7 8
;
˘˘8 9
return
˙˙ 
base
˙˙ 
.
˙˙ 
	ReadBytes
˙˙ !
(
˙˙! "
dst
˙˙" %
)
˙˙% &
;
˙˙& '
}
˚˚ 	
public
˝˝ 
override
˝˝ 
IByteBuffer
˝˝ #
	ReadBytes
˝˝$ -
(
˝˝- .
IByteBuffer
˝˝. 9
dst
˝˝: =
,
˝˝= >
int
˝˝? B
length
˝˝C I
)
˝˝I J
{
˛˛ 	/
!RecordLeakNonRefCountingOperation
ˇˇ -
(
ˇˇ- .
this
ˇˇ. 2
.
ˇˇ2 3
Leak
ˇˇ3 7
)
ˇˇ7 8
;
ˇˇ8 9
return
ÄÄ 
base
ÄÄ 
.
ÄÄ 
	ReadBytes
ÄÄ !
(
ÄÄ! "
dst
ÄÄ" %
,
ÄÄ% &
length
ÄÄ' -
)
ÄÄ- .
;
ÄÄ. /
}
ÅÅ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
	ReadBytes
ÉÉ$ -
(
ÉÉ- .
IByteBuffer
ÉÉ. 9
dst
ÉÉ: =
,
ÉÉ= >
int
ÉÉ? B
dstIndex
ÉÉC K
,
ÉÉK L
int
ÉÉM P
length
ÉÉQ W
)
ÉÉW X
{
ÑÑ 	/
!RecordLeakNonRefCountingOperation
ÖÖ -
(
ÖÖ- .
this
ÖÖ. 2
.
ÖÖ2 3
Leak
ÖÖ3 7
)
ÖÖ7 8
;
ÖÖ8 9
return
ÜÜ 
base
ÜÜ 
.
ÜÜ 
	ReadBytes
ÜÜ !
(
ÜÜ! "
dst
ÜÜ" %
,
ÜÜ% &
dstIndex
ÜÜ' /
,
ÜÜ/ 0
length
ÜÜ1 7
)
ÜÜ7 8
;
ÜÜ8 9
}
áá 	
public
ââ 
override
ââ 
IByteBuffer
ââ #
	ReadBytes
ââ$ -
(
ââ- .
byte
ââ. 2
[
ââ2 3
]
ââ3 4
dst
ââ5 8
)
ââ8 9
{
ää 	/
!RecordLeakNonRefCountingOperation
ãã -
(
ãã- .
this
ãã. 2
.
ãã2 3
Leak
ãã3 7
)
ãã7 8
;
ãã8 9
return
åå 
base
åå 
.
åå 
	ReadBytes
åå !
(
åå! "
dst
åå" %
)
åå% &
;
åå& '
}
çç 	
public
èè 
override
èè 
IByteBuffer
èè #
	ReadBytes
èè$ -
(
èè- .
byte
èè. 2
[
èè2 3
]
èè3 4
dst
èè5 8
,
èè8 9
int
èè: =
dstIndex
èè> F
,
èèF G
int
èèH K
length
èèL R
)
èèR S
{
êê 	/
!RecordLeakNonRefCountingOperation
ëë -
(
ëë- .
this
ëë. 2
.
ëë2 3
Leak
ëë3 7
)
ëë7 8
;
ëë8 9
return
íí 
base
íí 
.
íí 
	ReadBytes
íí !
(
íí! "
dst
íí" %
,
íí% &
dstIndex
íí' /
,
íí/ 0
length
íí1 7
)
íí7 8
;
íí8 9
}
ìì 	
public
ïï 
override
ïï 
IByteBuffer
ïï #
	ReadBytes
ïï$ -
(
ïï- .
Stream
ïï. 4
output
ïï5 ;
,
ïï; <
int
ïï= @
length
ïïA G
)
ïïG H
{
ññ 	/
!RecordLeakNonRefCountingOperation
óó -
(
óó- .
this
óó. 2
.
óó2 3
Leak
óó3 7
)
óó7 8
;
óó8 9
return
òò 
base
òò 
.
òò 
	ReadBytes
òò !
(
òò! "
output
òò" (
,
òò( )
length
òò* 0
)
òò0 1
;
òò1 2
}
ôô 	
public
õõ 
override
õõ 
IByteBuffer
õõ #
	SkipBytes
õõ$ -
(
õõ- .
int
õõ. 1
length
õõ2 8
)
õõ8 9
{
úú 	/
!RecordLeakNonRefCountingOperation
ùù -
(
ùù- .
this
ùù. 2
.
ùù2 3
Leak
ùù3 7
)
ùù7 8
;
ùù8 9
return
ûû 
base
ûû 
.
ûû 
	SkipBytes
ûû !
(
ûû! "
length
ûû" (
)
ûû( )
;
ûû) *
}
üü 	
public
°° 
override
°° 
IByteBuffer
°° #
WriteBoolean
°°$ 0
(
°°0 1
bool
°°1 5
value
°°6 ;
)
°°; <
{
¢¢ 	/
!RecordLeakNonRefCountingOperation
££ -
(
££- .
this
££. 2
.
££2 3
Leak
££3 7
)
££7 8
;
££8 9
return
§§ 
base
§§ 
.
§§ 
WriteBoolean
§§ $
(
§§$ %
value
§§% *
)
§§* +
;
§§+ ,
}
•• 	
public
ßß 
override
ßß 
IByteBuffer
ßß #
	WriteByte
ßß$ -
(
ßß- .
int
ßß. 1
value
ßß2 7
)
ßß7 8
{
®® 	/
!RecordLeakNonRefCountingOperation
©© -
(
©©- .
this
©©. 2
.
©©2 3
Leak
©©3 7
)
©©7 8
;
©©8 9
return
™™ 
base
™™ 
.
™™ 
	WriteByte
™™ !
(
™™! "
value
™™" '
)
™™' (
;
™™( )
}
´´ 	
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #

WriteShort
≠≠$ .
(
≠≠. /
int
≠≠/ 2
value
≠≠3 8
)
≠≠8 9
{
ÆÆ 	/
!RecordLeakNonRefCountingOperation
ØØ -
(
ØØ- .
this
ØØ. 2
.
ØØ2 3
Leak
ØØ3 7
)
ØØ7 8
;
ØØ8 9
return
∞∞ 
base
∞∞ 
.
∞∞ 

WriteShort
∞∞ "
(
∞∞" #
value
∞∞# (
)
∞∞( )
;
∞∞) *
}
±± 	
public
≥≥ 
override
≥≥ 
IByteBuffer
≥≥ #
WriteInt
≥≥$ ,
(
≥≥, -
int
≥≥- 0
value
≥≥1 6
)
≥≥6 7
{
¥¥ 	/
!RecordLeakNonRefCountingOperation
µµ -
(
µµ- .
this
µµ. 2
.
µµ2 3
Leak
µµ3 7
)
µµ7 8
;
µµ8 9
return
∂∂ 
base
∂∂ 
.
∂∂ 
WriteInt
∂∂  
(
∂∂  !
value
∂∂! &
)
∂∂& '
;
∂∂' (
}
∑∑ 	
public
ππ 
override
ππ 
IByteBuffer
ππ #
WriteMedium
ππ$ /
(
ππ/ 0
int
ππ0 3
value
ππ4 9
)
ππ9 :
{
∫∫ 	/
!RecordLeakNonRefCountingOperation
ªª -
(
ªª- .
this
ªª. 2
.
ªª2 3
Leak
ªª3 7
)
ªª7 8
;
ªª8 9
return
ºº 
base
ºº 
.
ºº 
WriteMedium
ºº #
(
ºº# $
value
ºº$ )
)
ºº) *
;
ºº* +
}
ΩΩ 	
public
øø 
override
øø 
IByteBuffer
øø #
	WriteLong
øø$ -
(
øø- .
long
øø. 2
value
øø3 8
)
øø8 9
{
¿¿ 	/
!RecordLeakNonRefCountingOperation
¡¡ -
(
¡¡- .
this
¡¡. 2
.
¡¡2 3
Leak
¡¡3 7
)
¡¡7 8
;
¡¡8 9
return
¬¬ 
base
¬¬ 
.
¬¬ 
	WriteLong
¬¬ !
(
¬¬! "
value
¬¬" '
)
¬¬' (
;
¬¬( )
}
√√ 	
public
≈≈ 
override
≈≈ 
IByteBuffer
≈≈ #
	WriteChar
≈≈$ -
(
≈≈- .
char
≈≈. 2
value
≈≈3 8
)
≈≈8 9
{
∆∆ 	/
!RecordLeakNonRefCountingOperation
«« -
(
««- .
this
««. 2
.
««2 3
Leak
««3 7
)
««7 8
;
««8 9
return
»» 
base
»» 
.
»» 
	WriteChar
»» !
(
»»! "
value
»»" '
)
»»' (
;
»»( )
}
…… 	
public
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ #

WriteFloat
ÀÀ$ .
(
ÀÀ. /
float
ÀÀ/ 4
value
ÀÀ5 :
)
ÀÀ: ;
{
ÃÃ 	/
!RecordLeakNonRefCountingOperation
ÕÕ -
(
ÕÕ- .
this
ÕÕ. 2
.
ÕÕ2 3
Leak
ÕÕ3 7
)
ÕÕ7 8
;
ÕÕ8 9
return
ŒŒ 
base
ŒŒ 
.
ŒŒ 

WriteFloat
ŒŒ "
(
ŒŒ" #
value
ŒŒ# (
)
ŒŒ( )
;
ŒŒ) *
}
œœ 	
public
—— 
override
—— 
IByteBuffer
—— #
WriteDouble
——$ /
(
——/ 0
double
——0 6
value
——7 <
)
——< =
{
““ 	/
!RecordLeakNonRefCountingOperation
”” -
(
””- .
this
””. 2
.
””2 3
Leak
””3 7
)
””7 8
;
””8 9
return
‘‘ 
base
‘‘ 
.
‘‘ 
WriteDouble
‘‘ #
(
‘‘# $
value
‘‘$ )
)
‘‘) *
;
‘‘* +
}
’’ 	
public
◊◊ 
override
◊◊ 
IByteBuffer
◊◊ #

WriteBytes
◊◊$ .
(
◊◊. /
IByteBuffer
◊◊/ :
src
◊◊; >
)
◊◊> ?
{
ÿÿ 	/
!RecordLeakNonRefCountingOperation
ŸŸ -
(
ŸŸ- .
this
ŸŸ. 2
.
ŸŸ2 3
Leak
ŸŸ3 7
)
ŸŸ7 8
;
ŸŸ8 9
return
⁄⁄ 
base
⁄⁄ 
.
⁄⁄ 

WriteBytes
⁄⁄ "
(
⁄⁄" #
src
⁄⁄# &
)
⁄⁄& '
;
⁄⁄' (
}
€€ 	
public
›› 
override
›› 
IByteBuffer
›› #

WriteBytes
››$ .
(
››. /
IByteBuffer
››/ :
src
››; >
,
››> ?
int
››@ C
length
››D J
)
››J K
{
ﬁﬁ 	/
!RecordLeakNonRefCountingOperation
ﬂﬂ -
(
ﬂﬂ- .
this
ﬂﬂ. 2
.
ﬂﬂ2 3
Leak
ﬂﬂ3 7
)
ﬂﬂ7 8
;
ﬂﬂ8 9
return
‡‡ 
base
‡‡ 
.
‡‡ 

WriteBytes
‡‡ "
(
‡‡" #
src
‡‡# &
,
‡‡& '
length
‡‡( .
)
‡‡. /
;
‡‡/ 0
}
·· 	
public
„„ 
override
„„ 
IByteBuffer
„„ #

WriteBytes
„„$ .
(
„„. /
IByteBuffer
„„/ :
src
„„; >
,
„„> ?
int
„„@ C
srcIndex
„„D L
,
„„L M
int
„„N Q
length
„„R X
)
„„X Y
{
‰‰ 	/
!RecordLeakNonRefCountingOperation
ÂÂ -
(
ÂÂ- .
this
ÂÂ. 2
.
ÂÂ2 3
Leak
ÂÂ3 7
)
ÂÂ7 8
;
ÂÂ8 9
return
ÊÊ 
base
ÊÊ 
.
ÊÊ 

WriteBytes
ÊÊ "
(
ÊÊ" #
src
ÊÊ# &
,
ÊÊ& '
srcIndex
ÊÊ( 0
,
ÊÊ0 1
length
ÊÊ2 8
)
ÊÊ8 9
;
ÊÊ9 :
}
ÁÁ 	
public
ÈÈ 
override
ÈÈ 
IByteBuffer
ÈÈ #

WriteBytes
ÈÈ$ .
(
ÈÈ. /
byte
ÈÈ/ 3
[
ÈÈ3 4
]
ÈÈ4 5
src
ÈÈ6 9
)
ÈÈ9 :
{
ÍÍ 	/
!RecordLeakNonRefCountingOperation
ÎÎ -
(
ÎÎ- .
this
ÎÎ. 2
.
ÎÎ2 3
Leak
ÎÎ3 7
)
ÎÎ7 8
;
ÎÎ8 9
return
ÏÏ 
base
ÏÏ 
.
ÏÏ 

WriteBytes
ÏÏ "
(
ÏÏ" #
src
ÏÏ# &
)
ÏÏ& '
;
ÏÏ' (
}
ÌÌ 	
public
ÔÔ 
override
ÔÔ 
IByteBuffer
ÔÔ #

WriteBytes
ÔÔ$ .
(
ÔÔ. /
byte
ÔÔ/ 3
[
ÔÔ3 4
]
ÔÔ4 5
src
ÔÔ6 9
,
ÔÔ9 :
int
ÔÔ; >
srcIndex
ÔÔ? G
,
ÔÔG H
int
ÔÔI L
length
ÔÔM S
)
ÔÔS T
{
 	/
!RecordLeakNonRefCountingOperation
ÒÒ -
(
ÒÒ- .
this
ÒÒ. 2
.
ÒÒ2 3
Leak
ÒÒ3 7
)
ÒÒ7 8
;
ÒÒ8 9
return
ÚÚ 
base
ÚÚ 
.
ÚÚ 

WriteBytes
ÚÚ "
(
ÚÚ" #
src
ÚÚ# &
,
ÚÚ& '
srcIndex
ÚÚ( 0
,
ÚÚ0 1
length
ÚÚ2 8
)
ÚÚ8 9
;
ÚÚ9 :
}
ÛÛ 	
public
ıı 
override
ıı 
Task
ıı 
WriteBytesAsync
ıı ,
(
ıı, -
Stream
ıı- 3
input
ıı4 9
,
ıı9 :
int
ıı; >
length
ıı? E
,
ııE F
CancellationToken
ııG X
cancellationToken
ııY j
)
ııj k
{
ˆˆ 	/
!RecordLeakNonRefCountingOperation
˜˜ -
(
˜˜- .
this
˜˜. 2
.
˜˜2 3
Leak
˜˜3 7
)
˜˜7 8
;
˜˜8 9
return
¯¯ 
base
¯¯ 
.
¯¯ 
WriteBytesAsync
¯¯ '
(
¯¯' (
input
¯¯( -
,
¯¯- .
length
¯¯/ 5
,
¯¯5 6
cancellationToken
¯¯7 H
)
¯¯H I
;
¯¯I J
}
˘˘ 	
public
˚˚ 
override
˚˚ 
IByteBuffer
˚˚ #
	WriteZero
˚˚$ -
(
˚˚- .
int
˚˚. 1
length
˚˚2 8
)
˚˚8 9
{
¸¸ 	/
!RecordLeakNonRefCountingOperation
˝˝ -
(
˝˝- .
this
˝˝. 2
.
˝˝2 3
Leak
˝˝3 7
)
˝˝7 8
;
˝˝8 9
return
˛˛ 
base
˛˛ 
.
˛˛ 
	WriteZero
˛˛ !
(
˛˛! "
length
˛˛" (
)
˛˛( )
;
˛˛) *
}
ˇˇ 	
public
ÅÅ 
override
ÅÅ 
int
ÅÅ 
IndexOf
ÅÅ #
(
ÅÅ# $
int
ÅÅ$ '
	fromIndex
ÅÅ( 1
,
ÅÅ1 2
int
ÅÅ3 6
toIndex
ÅÅ7 >
,
ÅÅ> ?
byte
ÅÅ@ D
value
ÅÅE J
)
ÅÅJ K
{
ÇÇ 	/
!RecordLeakNonRefCountingOperation
ÉÉ -
(
ÉÉ- .
this
ÉÉ. 2
.
ÉÉ2 3
Leak
ÉÉ3 7
)
ÉÉ7 8
;
ÉÉ8 9
return
ÑÑ 
base
ÑÑ 
.
ÑÑ 
IndexOf
ÑÑ 
(
ÑÑ  
	fromIndex
ÑÑ  )
,
ÑÑ) *
toIndex
ÑÑ+ 2
,
ÑÑ2 3
value
ÑÑ4 9
)
ÑÑ9 :
;
ÑÑ: ;
}
ÖÖ 	
public
áá 
override
áá 
int
áá 
BytesBefore
áá '
(
áá' (
byte
áá( ,
value
áá- 2
)
áá2 3
{
àà 	/
!RecordLeakNonRefCountingOperation
ââ -
(
ââ- .
this
ââ. 2
.
ââ2 3
Leak
ââ3 7
)
ââ7 8
;
ââ8 9
return
ää 
base
ää 
.
ää 
BytesBefore
ää #
(
ää# $
value
ää$ )
)
ää) *
;
ää* +
}
ãã 	
public
çç 
override
çç 
int
çç 
BytesBefore
çç '
(
çç' (
int
çç( +
length
çç, 2
,
çç2 3
byte
çç4 8
value
çç9 >
)
çç> ?
{
éé 	/
!RecordLeakNonRefCountingOperation
èè -
(
èè- .
this
èè. 2
.
èè2 3
Leak
èè3 7
)
èè7 8
;
èè8 9
return
êê 
base
êê 
.
êê 
BytesBefore
êê #
(
êê# $
length
êê$ *
,
êê* +
value
êê, 1
)
êê1 2
;
êê2 3
}
ëë 	
public
ìì 
override
ìì 
int
ìì 
BytesBefore
ìì '
(
ìì' (
int
ìì( +
index
ìì, 1
,
ìì1 2
int
ìì3 6
length
ìì7 =
,
ìì= >
byte
ìì? C
value
ììD I
)
ììI J
{
îî 	/
!RecordLeakNonRefCountingOperation
ïï -
(
ïï- .
this
ïï. 2
.
ïï2 3
Leak
ïï3 7
)
ïï7 8
;
ïï8 9
return
ññ 
base
ññ 
.
ññ 
BytesBefore
ññ #
(
ññ# $
index
ññ$ )
,
ññ) *
length
ññ+ 1
,
ññ1 2
value
ññ3 8
)
ññ8 9
;
ññ9 :
}
óó 	
public
ôô 
override
ôô 
int
ôô 
ForEachByte
ôô '
(
ôô' (
IByteProcessor
ôô( 6
	processor
ôô7 @
)
ôô@ A
{
öö 	/
!RecordLeakNonRefCountingOperation
õõ -
(
õõ- .
this
õõ. 2
.
õõ2 3
Leak
õõ3 7
)
õõ7 8
;
õõ8 9
return
úú 
base
úú 
.
úú 
ForEachByte
úú #
(
úú# $
	processor
úú$ -
)
úú- .
;
úú. /
}
ùù 	
public
üü 
override
üü 
int
üü 
ForEachByte
üü '
(
üü' (
int
üü( +
index
üü, 1
,
üü1 2
int
üü3 6
length
üü7 =
,
üü= >
IByteProcessor
üü? M
	processor
üüN W
)
üüW X
{
†† 	/
!RecordLeakNonRefCountingOperation
°° -
(
°°- .
this
°°. 2
.
°°2 3
Leak
°°3 7
)
°°7 8
;
°°8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
ForEachByte
¢¢ #
(
¢¢# $
index
¢¢$ )
,
¢¢) *
length
¢¢+ 1
,
¢¢1 2
	processor
¢¢3 <
)
¢¢< =
;
¢¢= >
}
££ 	
public
•• 
override
•• 
int
•• 
ForEachByteDesc
•• +
(
••+ ,
IByteProcessor
••, :
	processor
••; D
)
••D E
{
¶¶ 	/
!RecordLeakNonRefCountingOperation
ßß -
(
ßß- .
this
ßß. 2
.
ßß2 3
Leak
ßß3 7
)
ßß7 8
;
ßß8 9
return
®® 
base
®® 
.
®® 
ForEachByteDesc
®® '
(
®®' (
	processor
®®( 1
)
®®1 2
;
®®2 3
}
©© 	
public
´´ 
override
´´ 
int
´´ 
ForEachByteDesc
´´ +
(
´´+ ,
int
´´, /
index
´´0 5
,
´´5 6
int
´´7 :
length
´´; A
,
´´A B
IByteProcessor
´´C Q
	processor
´´R [
)
´´[ \
{
¨¨ 	/
!RecordLeakNonRefCountingOperation
≠≠ -
(
≠≠- .
this
≠≠. 2
.
≠≠2 3
Leak
≠≠3 7
)
≠≠7 8
;
≠≠8 9
return
ÆÆ 
base
ÆÆ 
.
ÆÆ 
ForEachByteDesc
ÆÆ '
(
ÆÆ' (
index
ÆÆ( -
,
ÆÆ- .
length
ÆÆ/ 5
,
ÆÆ5 6
	processor
ÆÆ7 @
)
ÆÆ@ A
;
ÆÆA B
}
ØØ 	
public
±± 
override
±± 
IByteBuffer
±± #
Copy
±±$ (
(
±±( )
)
±±) *
{
≤≤ 	/
!RecordLeakNonRefCountingOperation
≥≥ -
(
≥≥- .
this
≥≥. 2
.
≥≥2 3
Leak
≥≥3 7
)
≥≥7 8
;
≥≥8 9
return
¥¥ 
base
¥¥ 
.
¥¥ 
Copy
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
override
∑∑ 
IByteBuffer
∑∑ #
Copy
∑∑$ (
(
∑∑( )
int
∑∑) ,
index
∑∑- 2
,
∑∑2 3
int
∑∑4 7
length
∑∑8 >
)
∑∑> ?
{
∏∏ 	/
!RecordLeakNonRefCountingOperation
ππ -
(
ππ- .
this
ππ. 2
.
ππ2 3
Leak
ππ3 7
)
ππ7 8
;
ππ8 9
return
∫∫ 
base
∫∫ 
.
∫∫ 
Copy
∫∫ 
(
∫∫ 
index
∫∫ "
,
∫∫" #
length
∫∫$ *
)
∫∫* +
;
∫∫+ ,
}
ªª 	
public
ΩΩ 
override
ΩΩ 
int
ΩΩ 
IoBufferCount
ΩΩ )
{
ææ 	
get
øø 
{
¿¿ /
!RecordLeakNonRefCountingOperation
¡¡ 1
(
¡¡1 2
this
¡¡2 6
.
¡¡6 7
Leak
¡¡7 ;
)
¡¡; <
;
¡¡< =
return
¬¬ 
base
¬¬ 
.
¬¬ 
IoBufferCount
¬¬ )
;
¬¬) *
}
√√ 
}
ƒƒ 	
public
∆∆ 
override
∆∆ 
ArraySegment
∆∆ $
<
∆∆$ %
byte
∆∆% )
>
∆∆) *
GetIoBuffer
∆∆+ 6
(
∆∆6 7
)
∆∆7 8
{
«« 	/
!RecordLeakNonRefCountingOperation
»» -
(
»»- .
this
»». 2
.
»»2 3
Leak
»»3 7
)
»»7 8
;
»»8 9
return
…… 
base
…… 
.
…… 
GetIoBuffer
…… #
(
……# $
)
……$ %
;
……% &
}
   	
public
ÃÃ 
override
ÃÃ 
ArraySegment
ÃÃ $
<
ÃÃ$ %
byte
ÃÃ% )
>
ÃÃ) *
GetIoBuffer
ÃÃ+ 6
(
ÃÃ6 7
int
ÃÃ7 :
index
ÃÃ; @
,
ÃÃ@ A
int
ÃÃB E
length
ÃÃF L
)
ÃÃL M
{
ÕÕ 	/
!RecordLeakNonRefCountingOperation
ŒŒ -
(
ŒŒ- .
this
ŒŒ. 2
.
ŒŒ2 3
Leak
ŒŒ3 7
)
ŒŒ7 8
;
ŒŒ8 9
return
œœ 
base
œœ 
.
œœ 
GetIoBuffer
œœ #
(
œœ# $
index
œœ$ )
,
œœ) *
length
œœ+ 1
)
œœ1 2
;
œœ2 3
}
–– 	
public
““ 
override
““ 
ArraySegment
““ $
<
““$ %
byte
““% )
>
““) *
[
““* +
]
““+ ,
GetIoBuffers
““- 9
(
““9 :
)
““: ;
{
”” 	/
!RecordLeakNonRefCountingOperation
‘‘ -
(
‘‘- .
this
‘‘. 2
.
‘‘2 3
Leak
‘‘3 7
)
‘‘7 8
;
‘‘8 9
return
’’ 
base
’’ 
.
’’ 
GetIoBuffers
’’ $
(
’’$ %
)
’’% &
;
’’& '
}
÷÷ 	
public
ÿÿ 
override
ÿÿ 
ArraySegment
ÿÿ $
<
ÿÿ$ %
byte
ÿÿ% )
>
ÿÿ) *
[
ÿÿ* +
]
ÿÿ+ ,
GetIoBuffers
ÿÿ- 9
(
ÿÿ9 :
int
ÿÿ: =
index
ÿÿ> C
,
ÿÿC D
int
ÿÿE H
length
ÿÿI O
)
ÿÿO P
{
ŸŸ 	/
!RecordLeakNonRefCountingOperation
⁄⁄ -
(
⁄⁄- .
this
⁄⁄. 2
.
⁄⁄2 3
Leak
⁄⁄3 7
)
⁄⁄7 8
;
⁄⁄8 9
return
€€ 
base
€€ 
.
€€ 
GetIoBuffers
€€ $
(
€€$ %
index
€€% *
,
€€* +
length
€€, 2
)
€€2 3
;
€€3 4
}
‹‹ 	
public
ﬁﬁ 
override
ﬁﬁ 
string
ﬁﬁ 
ToString
ﬁﬁ '
(
ﬁﬁ' (
Encoding
ﬁﬁ( 0
encoding
ﬁﬁ1 9
)
ﬁﬁ9 :
{
ﬂﬂ 	/
!RecordLeakNonRefCountingOperation
‡‡ -
(
‡‡- .
this
‡‡. 2
.
‡‡2 3
Leak
‡‡3 7
)
‡‡7 8
;
‡‡8 9
return
·· 
base
·· 
.
·· 
ToString
··  
(
··  !
encoding
··! )
)
··) *
;
··* +
}
‚‚ 	
public
‰‰ 
override
‰‰ 
string
‰‰ 
ToString
‰‰ '
(
‰‰' (
int
‰‰( +
index
‰‰, 1
,
‰‰1 2
int
‰‰3 6
length
‰‰7 =
,
‰‰= >
Encoding
‰‰? G
encoding
‰‰H P
)
‰‰P Q
{
ÂÂ 	/
!RecordLeakNonRefCountingOperation
ÊÊ -
(
ÊÊ- .
this
ÊÊ. 2
.
ÊÊ2 3
Leak
ÊÊ3 7
)
ÊÊ7 8
;
ÊÊ8 9
return
ÁÁ 
base
ÁÁ 
.
ÁÁ 
ToString
ÁÁ  
(
ÁÁ  !
index
ÁÁ! &
,
ÁÁ& '
length
ÁÁ( .
,
ÁÁ. /
encoding
ÁÁ0 8
)
ÁÁ8 9
;
ÁÁ9 :
}
ËË 	
public
ÍÍ 
override
ÍÍ 
IByteBuffer
ÍÍ #
AdjustCapacity
ÍÍ$ 2
(
ÍÍ2 3
int
ÍÍ3 6
newCapacity
ÍÍ7 B
)
ÍÍB C
{
ÎÎ 	/
!RecordLeakNonRefCountingOperation
ÏÏ -
(
ÏÏ- .
this
ÏÏ. 2
.
ÏÏ2 3
Leak
ÏÏ3 7
)
ÏÏ7 8
;
ÏÏ8 9
return
ÌÌ 
base
ÌÌ 
.
ÌÌ 
AdjustCapacity
ÌÌ &
(
ÌÌ& '
newCapacity
ÌÌ' 2
)
ÌÌ2 3
;
ÌÌ3 4
}
ÓÓ 	
public
 
override
 
short
 

GetShortLE
 (
(
( )
int
) ,
index
- 2
)
2 3
{
ÒÒ 	/
!RecordLeakNonRefCountingOperation
ÚÚ -
(
ÚÚ- .
this
ÚÚ. 2
.
ÚÚ2 3
Leak
ÚÚ3 7
)
ÚÚ7 8
;
ÚÚ8 9
return
ÛÛ 
base
ÛÛ 
.
ÛÛ 

GetShortLE
ÛÛ "
(
ÛÛ" #
index
ÛÛ# (
)
ÛÛ( )
;
ÛÛ) *
}
ÙÙ 	
public
ˆˆ 
override
ˆˆ 
ushort
ˆˆ  
GetUnsignedShortLE
ˆˆ 1
(
ˆˆ1 2
int
ˆˆ2 5
index
ˆˆ6 ;
)
ˆˆ; <
{
˜˜ 	/
!RecordLeakNonRefCountingOperation
¯¯ -
(
¯¯- .
this
¯¯. 2
.
¯¯2 3
Leak
¯¯3 7
)
¯¯7 8
;
¯¯8 9
return
˘˘ 
base
˘˘ 
.
˘˘  
GetUnsignedShortLE
˘˘ *
(
˘˘* +
index
˘˘+ 0
)
˘˘0 1
;
˘˘1 2
}
˙˙ 	
public
¸¸ 
override
¸¸ 
int
¸¸ 
GetMediumLE
¸¸ '
(
¸¸' (
int
¸¸( +
index
¸¸, 1
)
¸¸1 2
{
˝˝ 	/
!RecordLeakNonRefCountingOperation
˛˛ -
(
˛˛- .
this
˛˛. 2
.
˛˛2 3
Leak
˛˛3 7
)
˛˛7 8
;
˛˛8 9
return
ˇˇ 
base
ˇˇ 
.
ˇˇ 
GetMediumLE
ˇˇ #
(
ˇˇ# $
index
ˇˇ$ )
)
ˇˇ) *
;
ˇˇ* +
}
ÄÄ 	
public
ÇÇ 
override
ÇÇ 
int
ÇÇ !
GetUnsignedMediumLE
ÇÇ /
(
ÇÇ/ 0
int
ÇÇ0 3
index
ÇÇ4 9
)
ÇÇ9 :
{
ÉÉ 	/
!RecordLeakNonRefCountingOperation
ÑÑ -
(
ÑÑ- .
this
ÑÑ. 2
.
ÑÑ2 3
Leak
ÑÑ3 7
)
ÑÑ7 8
;
ÑÑ8 9
return
ÖÖ 
base
ÖÖ 
.
ÖÖ !
GetUnsignedMediumLE
ÖÖ +
(
ÖÖ+ ,
index
ÖÖ, 1
)
ÖÖ1 2
;
ÖÖ2 3
}
ÜÜ 	
public
àà 
override
àà 
int
àà 
GetIntLE
àà $
(
àà$ %
int
àà% (
index
àà) .
)
àà. /
{
ââ 	/
!RecordLeakNonRefCountingOperation
ää -
(
ää- .
this
ää. 2
.
ää2 3
Leak
ää3 7
)
ää7 8
;
ää8 9
return
ãã 
base
ãã 
.
ãã 
GetIntLE
ãã  
(
ãã  !
index
ãã! &
)
ãã& '
;
ãã' (
}
åå 	
public
éé 
override
éé 
uint
éé 
GetUnsignedIntLE
éé -
(
éé- .
int
éé. 1
index
éé2 7
)
éé7 8
{
èè 	/
!RecordLeakNonRefCountingOperation
êê -
(
êê- .
this
êê. 2
.
êê2 3
Leak
êê3 7
)
êê7 8
;
êê8 9
return
ëë 
base
ëë 
.
ëë 
GetUnsignedIntLE
ëë (
(
ëë( )
index
ëë) .
)
ëë. /
;
ëë/ 0
}
íí 	
public
îî 
override
îî 
long
îî 
	GetLongLE
îî &
(
îî& '
int
îî' *
index
îî+ 0
)
îî0 1
{
ïï 	/
!RecordLeakNonRefCountingOperation
ññ -
(
ññ- .
this
ññ. 2
.
ññ2 3
Leak
ññ3 7
)
ññ7 8
;
ññ8 9
return
óó 
base
óó 
.
óó 
	GetLongLE
óó !
(
óó! "
index
óó" '
)
óó' (
;
óó( )
}
òò 	
public
öö 
override
öö 
IByteBuffer
öö #

SetShortLE
öö$ .
(
öö. /
int
öö/ 2
index
öö3 8
,
öö8 9
int
öö: =
value
öö> C
)
ööC D
{
õõ 	/
!RecordLeakNonRefCountingOperation
úú -
(
úú- .
this
úú. 2
.
úú2 3
Leak
úú3 7
)
úú7 8
;
úú8 9
return
ùù 
base
ùù 
.
ùù 

SetShortLE
ùù "
(
ùù" #
index
ùù# (
,
ùù( )
value
ùù* /
)
ùù/ 0
;
ùù0 1
}
ûû 	
public
†† 
override
†† 
IByteBuffer
†† #
SetIntLE
††$ ,
(
††, -
int
††- 0
index
††1 6
,
††6 7
int
††8 ;
value
††< A
)
††A B
{
°° 	/
!RecordLeakNonRefCountingOperation
¢¢ -
(
¢¢- .
this
¢¢. 2
.
¢¢2 3
Leak
¢¢3 7
)
¢¢7 8
;
¢¢8 9
return
££ 
base
££ 
.
££ 
SetIntLE
££  
(
££  !
index
££! &
,
££& '
value
££( -
)
££- .
;
££. /
}
§§ 	
public
¶¶ 
override
¶¶ 
IByteBuffer
¶¶ #
SetMediumLE
¶¶$ /
(
¶¶/ 0
int
¶¶0 3
index
¶¶4 9
,
¶¶9 :
int
¶¶; >
value
¶¶? D
)
¶¶D E
{
ßß 	/
!RecordLeakNonRefCountingOperation
®® -
(
®®- .
this
®®. 2
.
®®2 3
Leak
®®3 7
)
®®7 8
;
®®8 9
return
©© 
base
©© 
.
©© 
SetMediumLE
©© #
(
©©# $
index
©©$ )
,
©©) *
value
©©+ 0
)
©©0 1
;
©©1 2
}
™™ 	
public
¨¨ 
override
¨¨ 
IByteBuffer
¨¨ #
	SetLongLE
¨¨$ -
(
¨¨- .
int
¨¨. 1
index
¨¨2 7
,
¨¨7 8
long
¨¨9 =
value
¨¨> C
)
¨¨C D
{
≠≠ 	/
!RecordLeakNonRefCountingOperation
ÆÆ -
(
ÆÆ- .
this
ÆÆ. 2
.
ÆÆ2 3
Leak
ÆÆ3 7
)
ÆÆ7 8
;
ÆÆ8 9
return
ØØ 
base
ØØ 
.
ØØ 
	SetLongLE
ØØ !
(
ØØ! "
index
ØØ" '
,
ØØ' (
value
ØØ) .
)
ØØ. /
;
ØØ/ 0
}
∞∞ 	
public
≤≤ 
override
≤≤ 
short
≤≤ 
ReadShortLE
≤≤ )
(
≤≤) *
)
≤≤* +
{
≥≥ 	/
!RecordLeakNonRefCountingOperation
¥¥ -
(
¥¥- .
this
¥¥. 2
.
¥¥2 3
Leak
¥¥3 7
)
¥¥7 8
;
¥¥8 9
return
µµ 
base
µµ 
.
µµ 
ReadShortLE
µµ #
(
µµ# $
)
µµ$ %
;
µµ% &
}
∂∂ 	
public
∏∏ 
override
∏∏ 
ushort
∏∏ !
ReadUnsignedShortLE
∏∏ 2
(
∏∏2 3
)
∏∏3 4
{
ππ 	/
!RecordLeakNonRefCountingOperation
∫∫ -
(
∫∫- .
this
∫∫. 2
.
∫∫2 3
Leak
∫∫3 7
)
∫∫7 8
;
∫∫8 9
return
ªª 
base
ªª 
.
ªª !
ReadUnsignedShortLE
ªª +
(
ªª+ ,
)
ªª, -
;
ªª- .
}
ºº 	
public
ææ 
override
ææ 
int
ææ 
ReadMediumLE
ææ (
(
ææ( )
)
ææ) *
{
øø 	/
!RecordLeakNonRefCountingOperation
¿¿ -
(
¿¿- .
this
¿¿. 2
.
¿¿2 3
Leak
¿¿3 7
)
¿¿7 8
;
¿¿8 9
return
¡¡ 
base
¡¡ 
.
¡¡ 
ReadMediumLE
¡¡ $
(
¡¡$ %
)
¡¡% &
;
¡¡& '
}
¬¬ 	
public
ƒƒ 
override
ƒƒ 
int
ƒƒ "
ReadUnsignedMediumLE
ƒƒ 0
(
ƒƒ0 1
)
ƒƒ1 2
{
≈≈ 	/
!RecordLeakNonRefCountingOperation
∆∆ -
(
∆∆- .
this
∆∆. 2
.
∆∆2 3
Leak
∆∆3 7
)
∆∆7 8
;
∆∆8 9
return
«« 
base
«« 
.
«« "
ReadUnsignedMediumLE
«« ,
(
««, -
)
««- .
;
««. /
}
»» 	
public
   
override
   
int
   
	ReadIntLE
   %
(
  % &
)
  & '
{
ÀÀ 	/
!RecordLeakNonRefCountingOperation
ÃÃ -
(
ÃÃ- .
this
ÃÃ. 2
.
ÃÃ2 3
Leak
ÃÃ3 7
)
ÃÃ7 8
;
ÃÃ8 9
return
ÕÕ 
base
ÕÕ 
.
ÕÕ 
	ReadIntLE
ÕÕ !
(
ÕÕ! "
)
ÕÕ" #
;
ÕÕ# $
}
ŒŒ 	
public
–– 
override
–– 
uint
–– 
ReadUnsignedIntLE
–– .
(
––. /
)
––/ 0
{
—— 	/
!RecordLeakNonRefCountingOperation
““ -
(
““- .
this
““. 2
.
““2 3
Leak
““3 7
)
““7 8
;
““8 9
return
”” 
base
”” 
.
”” 
ReadUnsignedIntLE
”” )
(
””) *
)
””* +
;
””+ ,
}
‘‘ 	
public
÷÷ 
override
÷÷ 
long
÷÷ 

ReadLongLE
÷÷ '
(
÷÷' (
)
÷÷( )
{
◊◊ 	/
!RecordLeakNonRefCountingOperation
ÿÿ -
(
ÿÿ- .
this
ÿÿ. 2
.
ÿÿ2 3
Leak
ÿÿ3 7
)
ÿÿ7 8
;
ÿÿ8 9
return
ŸŸ 
base
ŸŸ 
.
ŸŸ 

ReadLongLE
ŸŸ "
(
ŸŸ" #
)
ŸŸ# $
;
ŸŸ$ %
}
⁄⁄ 	
public
‹‹ 
override
‹‹ 
IByteBuffer
‹‹ #
WriteShortLE
‹‹$ 0
(
‹‹0 1
int
‹‹1 4
value
‹‹5 :
)
‹‹: ;
{
›› 	/
!RecordLeakNonRefCountingOperation
ﬁﬁ -
(
ﬁﬁ- .
this
ﬁﬁ. 2
.
ﬁﬁ2 3
Leak
ﬁﬁ3 7
)
ﬁﬁ7 8
;
ﬁﬁ8 9
return
ﬂﬂ 
base
ﬂﬂ 
.
ﬂﬂ 
WriteShortLE
ﬂﬂ $
(
ﬂﬂ$ %
value
ﬂﬂ% *
)
ﬂﬂ* +
;
ﬂﬂ+ ,
}
‡‡ 	
public
‚‚ 
override
‚‚ 
IByteBuffer
‚‚ #
WriteMediumLE
‚‚$ 1
(
‚‚1 2
int
‚‚2 5
value
‚‚6 ;
)
‚‚; <
{
„„ 	/
!RecordLeakNonRefCountingOperation
‰‰ -
(
‰‰- .
this
‰‰. 2
.
‰‰2 3
Leak
‰‰3 7
)
‰‰7 8
;
‰‰8 9
return
ÂÂ 
base
ÂÂ 
.
ÂÂ 
WriteMediumLE
ÂÂ %
(
ÂÂ% &
value
ÂÂ& +
)
ÂÂ+ ,
;
ÂÂ, -
}
ÊÊ 	
public
ËË 
override
ËË 
IByteBuffer
ËË #

WriteIntLE
ËË$ .
(
ËË. /
int
ËË/ 2
value
ËË3 8
)
ËË8 9
{
ÈÈ 	/
!RecordLeakNonRefCountingOperation
ÍÍ -
(
ÍÍ- .
this
ÍÍ. 2
.
ÍÍ2 3
Leak
ÍÍ3 7
)
ÍÍ7 8
;
ÍÍ8 9
return
ÎÎ 
base
ÎÎ 
.
ÎÎ 

WriteIntLE
ÎÎ "
(
ÎÎ" #
value
ÎÎ# (
)
ÎÎ( )
;
ÎÎ) *
}
ÏÏ 	
public
ÓÓ 
override
ÓÓ 
IByteBuffer
ÓÓ #
WriteLongLE
ÓÓ$ /
(
ÓÓ/ 0
long
ÓÓ0 4
value
ÓÓ5 :
)
ÓÓ: ;
{
ÔÔ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
ÒÒ 
base
ÒÒ 
.
ÒÒ 
WriteLongLE
ÒÒ #
(
ÒÒ# $
value
ÒÒ$ )
)
ÒÒ) *
;
ÒÒ* +
}
ÚÚ 	
public
ÙÙ 
override
ÙÙ 
IByteBuffer
ÙÙ #
GetBytes
ÙÙ$ ,
(
ÙÙ, -
int
ÙÙ- 0
index
ÙÙ1 6
,
ÙÙ6 7
Stream
ÙÙ8 >
destination
ÙÙ? J
,
ÙÙJ K
int
ÙÙL O
length
ÙÙP V
)
ÙÙV W
{
ıı 	/
!RecordLeakNonRefCountingOperation
ˆˆ -
(
ˆˆ- .
this
ˆˆ. 2
.
ˆˆ2 3
Leak
ˆˆ3 7
)
ˆˆ7 8
;
ˆˆ8 9
return
˜˜ 
base
˜˜ 
.
˜˜ 
GetBytes
˜˜  
(
˜˜  !
index
˜˜! &
,
˜˜& '
destination
˜˜( 3
,
˜˜3 4
length
˜˜5 ;
)
˜˜; <
;
˜˜< =
}
¯¯ 	
public
˙˙ 
override
˙˙ 
IReferenceCounted
˙˙ )
Retain
˙˙* 0
(
˙˙0 1
)
˙˙1 2
{
˚˚ 	
this
¸¸ 
.
¸¸ 
Leak
¸¸ 
.
¸¸ 
Record
¸¸ 
(
¸¸ 
)
¸¸ 
;
¸¸ 
return
˝˝ 
base
˝˝ 
.
˝˝ 
Retain
˝˝ 
(
˝˝ 
)
˝˝  
;
˝˝  !
}
˛˛ 	
public
ÄÄ 
override
ÄÄ 
IReferenceCounted
ÄÄ )
Retain
ÄÄ* 0
(
ÄÄ0 1
int
ÄÄ1 4
	increment
ÄÄ5 >
)
ÄÄ> ?
{
ÅÅ 	
this
ÇÇ 
.
ÇÇ 
Leak
ÇÇ 
.
ÇÇ 
Record
ÇÇ 
(
ÇÇ 
)
ÇÇ 
;
ÇÇ 
return
ÉÉ 
base
ÉÉ 
.
ÉÉ 
Retain
ÉÉ 
(
ÉÉ 
	increment
ÉÉ (
)
ÉÉ( )
;
ÉÉ) *
}
ÑÑ 	
public
ÜÜ 
override
ÜÜ 
IByteBuffer
ÜÜ #
RetainedSlice
ÜÜ$ 1
(
ÜÜ1 2
)
ÜÜ2 3
{
áá 	/
!RecordLeakNonRefCountingOperation
àà -
(
àà- .
this
àà. 2
.
àà2 3
Leak
àà3 7
)
àà7 8
;
àà8 9
return
ââ 
base
ââ 
.
ââ 
RetainedSlice
ââ %
(
ââ% &
)
ââ& '
;
ââ' (
}
ää 	
public
åå 
override
åå 
IByteBuffer
åå #
RetainedSlice
åå$ 1
(
åå1 2
int
åå2 5
index
åå6 ;
,
åå; <
int
åå= @
length
ååA G
)
ååG H
{
çç 	/
!RecordLeakNonRefCountingOperation
éé -
(
éé- .
this
éé. 2
.
éé2 3
Leak
éé3 7
)
éé7 8
;
éé8 9
return
èè 
base
èè 
.
èè 
RetainedSlice
èè %
(
èè% &
index
èè& +
,
èè+ ,
length
èè- 3
)
èè3 4
;
èè4 5
}
êê 	
public
íí 
override
íí 
IByteBuffer
íí #
RetainedDuplicate
íí$ 5
(
íí5 6
)
íí6 7
{
ìì 	/
!RecordLeakNonRefCountingOperation
îî -
(
îî- .
this
îî. 2
.
îî2 3
Leak
îî3 7
)
îî7 8
;
îî8 9
return
ïï 
base
ïï 
.
ïï 
RetainedDuplicate
ïï )
(
ïï) *
)
ïï* +
;
ïï+ ,
}
ññ 	
public
òò 
override
òò 
IByteBuffer
òò #
ReadRetainedSlice
òò$ 5
(
òò5 6
int
òò6 9
length
òò: @
)
òò@ A
{
ôô 	/
!RecordLeakNonRefCountingOperation
öö -
(
öö- .
this
öö. 2
.
öö2 3
Leak
öö3 7
)
öö7 8
;
öö8 9
return
õõ 
base
õõ 
.
õõ 
ReadRetainedSlice
õõ )
(
õõ) *
length
õõ* 0
)
õõ0 1
;
õõ1 2
}
úú 	
public
ûû 
override
ûû 
IReferenceCounted
ûû )
Touch
ûû* /
(
ûû/ 0
)
ûû0 1
{
üü 	
this
†† 
.
†† 
Leak
†† 
.
†† 
Record
†† 
(
†† 
)
†† 
;
†† 
return
°° 
this
°° 
;
°° 
}
¢¢ 	
public
§§ 
override
§§ 
IReferenceCounted
§§ )
Touch
§§* /
(
§§/ 0
object
§§0 6
hint
§§7 ;
)
§§; <
{
•• 	
this
¶¶ 
.
¶¶ 
Leak
¶¶ 
.
¶¶ 
Record
¶¶ 
(
¶¶ 
hint
¶¶ !
)
¶¶! "
;
¶¶" #
return
ßß 
this
ßß 
;
ßß 
}
®® 	
public
™™ 
override
™™ 
bool
™™ 
Release
™™ $
(
™™$ %
)
™™% &
{
´´ 	
this
¨¨ 
.
¨¨ 
Leak
¨¨ 
.
¨¨ 
Record
¨¨ 
(
¨¨ 
)
¨¨ 
;
¨¨ 
return
≠≠ 
base
≠≠ 
.
≠≠ 
Release
≠≠ 
(
≠≠  
)
≠≠  !
;
≠≠! "
}
ÆÆ 	
public
∞∞ 
override
∞∞ 
bool
∞∞ 
Release
∞∞ $
(
∞∞$ %
int
∞∞% (
	decrement
∞∞) 2
)
∞∞2 3
{
±± 	
this
≤≤ 
.
≤≤ 
Leak
≤≤ 
.
≤≤ 
Record
≤≤ 
(
≤≤ 
)
≤≤ 
;
≤≤ 
return
≥≥ 
base
≥≥ 
.
≥≥ 
Release
≥≥ 
(
≥≥  
	decrement
≥≥  )
)
≥≥) *
;
≥≥* +
}
¥¥ 	
	protected
∂∂ 
override
∂∂ '
SimpleLeakAwareByteBuffer
∂∂ 4$
NewLeakAwareByteBuffer
∂∂5 K
(
∂∂K L
IByteBuffer
∂∂L W
buf
∂∂X [
,
∂∂[ \
IByteBuffer
∂∂] h
trackedByteBuf
∂∂i w
,
∂∂w x#
IResourceLeakTracker∂∂y ç
leakTracker∂∂é ô
)∂∂ô ö
=>∂∂õ ù
new
∑∑ )
AdvancedLeakAwareByteBuffer
∑∑ +
(
∑∑+ ,
buf
∑∑, /
,
∑∑/ 0
trackedByteBuf
∑∑1 ?
,
∑∑? @
leakTracker
∑∑A L
)
∑∑L M
;
∑∑M N
}
∏∏ 
}ππ ≤Ÿ
wC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\AdvancedLeakAwareCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 0
$AdvancedLeakAwareCompositeByteBuffer 5
:6 7.
"SimpleLeakAwareCompositeByteBuffer8 Z
{ 
internal 0
$AdvancedLeakAwareCompositeByteBuffer 5
(5 6
CompositeByteBuffer6 I
wrappedJ Q
,Q R 
IResourceLeakTrackerS g
leakh l
)l m
: 
base 
( 
wrapped 
, 
leak  
)  !
{ 	
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
{ 	-
!RecordLeakNonRefCountingOperation -
(- .
this. 2
.2 3
Leak3 7
)7 8
;8 9
return 
base 
. 
Slice 
( 
) 
;  
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
int* -
index. 3
,3 4
int5 8
length9 ?
)? @
{ 	-
!RecordLeakNonRefCountingOperation   -
(  - .
this  . 2
.  2 3
Leak  3 7
)  7 8
;  8 9
return!! 
base!! 
.!! 
Slice!! 
(!! 
index!! #
,!!# $
length!!% +
)!!+ ,
;!!, -
}"" 	
public$$ 
override$$ 
IByteBuffer$$ #
	Duplicate$$$ -
($$- .
)$$. /
{%% 	-
!RecordLeakNonRefCountingOperation&& -
(&&- .
this&&. 2
.&&2 3
Leak&&3 7
)&&7 8
;&&8 9
return'' 
base'' 
.'' 
	Duplicate'' !
(''! "
)''" #
;''# $
}(( 	
public** 
override** 
IByteBuffer** #
	ReadSlice**$ -
(**- .
int**. 1
length**2 8
)**8 9
{++ 	-
!RecordLeakNonRefCountingOperation,, -
(,,- .
this,,. 2
.,,2 3
Leak,,3 7
),,7 8
;,,8 9
return-- 
base-- 
.-- 
	ReadSlice-- !
(--! "
length--" (
)--( )
;--) *
}.. 	
public00 
override00 
IByteBuffer00 #
DiscardReadBytes00$ 4
(004 5
)005 6
{11 	-
!RecordLeakNonRefCountingOperation22 -
(22- .
this22. 2
.222 3
Leak223 7
)227 8
;228 9
return33 
base33 
.33 
DiscardReadBytes33 (
(33( )
)33) *
;33* +
}44 	
public66 
override66 
IByteBuffer66 # 
DiscardSomeReadBytes66$ 8
(668 9
)669 :
{77 	-
!RecordLeakNonRefCountingOperation88 -
(88- .
this88. 2
.882 3
Leak883 7
)887 8
;888 9
return99 
base99 
.99  
DiscardSomeReadBytes99 ,
(99, -
)99- .
;99. /
}:: 	
public<< 
override<< 
IByteBuffer<< #
EnsureWritable<<$ 2
(<<2 3
int<<3 6
minWritableBytes<<7 G
)<<G H
{== 	-
!RecordLeakNonRefCountingOperation>> -
(>>- .
this>>. 2
.>>2 3
Leak>>3 7
)>>7 8
;>>8 9
return?? 
base?? 
.?? 
EnsureWritable?? &
(??& '
minWritableBytes??' 7
)??7 8
;??8 9
}@@ 	
publicBB 
overrideBB 
intBB 
EnsureWritableBB *
(BB* +
intBB+ .
minWritableBytesBB/ ?
,BB? @
boolBBA E
forceBBF K
)BBK L
{CC 	-
!RecordLeakNonRefCountingOperationDD -
(DD- .
thisDD. 2
.DD2 3
LeakDD3 7
)DD7 8
;DD8 9
returnEE 
baseEE 
.EE 
EnsureWritableEE &
(EE& '
minWritableBytesEE' 7
,EE7 8
forceEE9 >
)EE> ?
;EE? @
}FF 	
publicHH 
overrideHH 
byteHH 
GetByteHH $
(HH$ %
intHH% (
indexHH) .
)HH. /
{II 	-
!RecordLeakNonRefCountingOperationJJ -
(JJ- .
thisJJ. 2
.JJ2 3
LeakJJ3 7
)JJ7 8
;JJ8 9
returnKK 
baseKK 
.KK 
GetByteKK 
(KK  
indexKK  %
)KK% &
;KK& '
}LL 	
publicNN 
overrideNN 
intNN 
GetUnsignedMediumNN -
(NN- .
intNN. 1
indexNN2 7
)NN7 8
{OO 	-
!RecordLeakNonRefCountingOperationPP -
(PP- .
thisPP. 2
.PP2 3
LeakPP3 7
)PP7 8
;PP8 9
returnQQ 
baseQQ 
.QQ 
GetUnsignedMediumQQ )
(QQ) *
indexQQ* /
)QQ/ 0
;QQ0 1
}RR 	
publicTT 
overrideTT 
shortTT 
GetShortTT &
(TT& '
intTT' *
indexTT+ 0
)TT0 1
{UU 	-
!RecordLeakNonRefCountingOperationVV -
(VV- .
thisVV. 2
.VV2 3
LeakVV3 7
)VV7 8
;VV8 9
returnWW 
baseWW 
.WW 
GetShortWW  
(WW  !
indexWW! &
)WW& '
;WW' (
}XX 	
publicZZ 
overrideZZ 
intZZ 
GetIntZZ "
(ZZ" #
intZZ# &
indexZZ' ,
)ZZ, -
{[[ 	-
!RecordLeakNonRefCountingOperation\\ -
(\\- .
this\\. 2
.\\2 3
Leak\\3 7
)\\7 8
;\\8 9
return]] 
base]] 
.]] 
GetInt]] 
(]] 
index]] $
)]]$ %
;]]% &
}^^ 	
public`` 
override`` 
long`` 
GetLong`` $
(``$ %
int``% (
index``) .
)``. /
{aa 	-
!RecordLeakNonRefCountingOperationbb -
(bb- .
thisbb. 2
.bb2 3
Leakbb3 7
)bb7 8
;bb8 9
returncc 
basecc 
.cc 
GetLongcc 
(cc  
indexcc  %
)cc% &
;cc& '
}dd 	
publicff 
overrideff 
charff 
GetCharff $
(ff$ %
intff% (
indexff) .
)ff. /
{gg 	-
!RecordLeakNonRefCountingOperationhh -
(hh- .
thishh. 2
.hh2 3
Leakhh3 7
)hh7 8
;hh8 9
returnii 
baseii 
.ii 
GetCharii 
(ii  
indexii  %
)ii% &
;ii& '
}jj 	
publicll 
overridell 
IByteBufferll #
GetBytesll$ ,
(ll, -
intll- 0
indexll1 6
,ll6 7
IByteBufferll8 C
dstllD G
)llG H
{mm 	-
!RecordLeakNonRefCountingOperationnn -
(nn- .
thisnn. 2
.nn2 3
Leaknn3 7
)nn7 8
;nn8 9
returnoo 
baseoo 
.oo 
GetBytesoo  
(oo  !
indexoo! &
,oo& '
dstoo( +
)oo+ ,
;oo, -
}pp 	
publicrr 
overriderr 
IByteBufferrr #
GetBytesrr$ ,
(rr, -
intrr- 0
indexrr1 6
,rr6 7
IByteBufferrr8 C
dstrrD G
,rrG H
intrrI L
lengthrrM S
)rrS T
{ss 	-
!RecordLeakNonRefCountingOperationtt -
(tt- .
thistt. 2
.tt2 3
Leaktt3 7
)tt7 8
;tt8 9
returnuu 
baseuu 
.uu 
GetBytesuu  
(uu  !
indexuu! &
,uu& '
dstuu( +
,uu+ ,
lengthuu- 3
)uu3 4
;uu4 5
}vv 	
publicxx 
overridexx 
IByteBufferxx #
GetBytesxx$ ,
(xx, -
intxx- 0
indexxx1 6
,xx6 7
IByteBufferxx8 C
dstxxD G
,xxG H
intxxI L
dstIndexxxM U
,xxU V
intxxW Z
lengthxx[ a
)xxa b
{yy 	-
!RecordLeakNonRefCountingOperationzz -
(zz- .
thiszz. 2
.zz2 3
Leakzz3 7
)zz7 8
;zz8 9
return{{ 
base{{ 
.{{ 
GetBytes{{  
({{  !
index{{! &
,{{& '
dst{{( +
,{{+ ,
dstIndex{{- 5
,{{5 6
length{{7 =
){{= >
;{{> ?
}|| 	
public~~ 
override~~ 
IByteBuffer~~ #
GetBytes~~$ ,
(~~, -
int~~- 0
index~~1 6
,~~6 7
byte~~8 <
[~~< =
]~~= >
dst~~? B
)~~B C
{ 	/
!RecordLeakNonRefCountingOperation
ÄÄ -
(
ÄÄ- .
this
ÄÄ. 2
.
ÄÄ2 3
Leak
ÄÄ3 7
)
ÄÄ7 8
;
ÄÄ8 9
return
ÅÅ 
base
ÅÅ 
.
ÅÅ 
GetBytes
ÅÅ  
(
ÅÅ  !
index
ÅÅ! &
,
ÅÅ& '
dst
ÅÅ( +
)
ÅÅ+ ,
;
ÅÅ, -
}
ÇÇ 	
public
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ #
GetBytes
ÑÑ$ ,
(
ÑÑ, -
int
ÑÑ- 0
index
ÑÑ1 6
,
ÑÑ6 7
byte
ÑÑ8 <
[
ÑÑ< =
]
ÑÑ= >
dst
ÑÑ? B
,
ÑÑB C
int
ÑÑD G
dstIndex
ÑÑH P
,
ÑÑP Q
int
ÑÑR U
length
ÑÑV \
)
ÑÑ\ ]
{
ÖÖ 	/
!RecordLeakNonRefCountingOperation
ÜÜ -
(
ÜÜ- .
this
ÜÜ. 2
.
ÜÜ2 3
Leak
ÜÜ3 7
)
ÜÜ7 8
;
ÜÜ8 9
return
áá 
base
áá 
.
áá 
GetBytes
áá  
(
áá  !
index
áá! &
,
áá& '
dst
áá( +
,
áá+ ,
dstIndex
áá- 5
,
áá5 6
length
áá7 =
)
áá= >
;
áá> ?
}
àà 	
public
ää 
override
ää 
IByteBuffer
ää #

SetBoolean
ää$ .
(
ää. /
int
ää/ 2
index
ää3 8
,
ää8 9
bool
ää: >
value
ää? D
)
ääD E
{
ãã 	/
!RecordLeakNonRefCountingOperation
åå -
(
åå- .
this
åå. 2
.
åå2 3
Leak
åå3 7
)
åå7 8
;
åå8 9
return
çç 
base
çç 
.
çç 

SetBoolean
çç "
(
çç" #
index
çç# (
,
çç( )
value
çç* /
)
çç/ 0
;
çç0 1
}
éé 	
public
êê 
override
êê 
IByteBuffer
êê #
SetByte
êê$ +
(
êê+ ,
int
êê, /
index
êê0 5
,
êê5 6
int
êê7 :
value
êê; @
)
êê@ A
{
ëë 	/
!RecordLeakNonRefCountingOperation
íí -
(
íí- .
this
íí. 2
.
íí2 3
Leak
íí3 7
)
íí7 8
;
íí8 9
return
ìì 
base
ìì 
.
ìì 
SetByte
ìì 
(
ìì  
index
ìì  %
,
ìì% &
value
ìì' ,
)
ìì, -
;
ìì- .
}
îî 	
public
ññ 
override
ññ 
IByteBuffer
ññ #
	SetMedium
ññ$ -
(
ññ- .
int
ññ. 1
index
ññ2 7
,
ññ7 8
int
ññ9 <
value
ññ= B
)
ññB C
{
óó 	/
!RecordLeakNonRefCountingOperation
òò -
(
òò- .
this
òò. 2
.
òò2 3
Leak
òò3 7
)
òò7 8
;
òò8 9
return
ôô 
base
ôô 
.
ôô 
	SetMedium
ôô !
(
ôô! "
index
ôô" '
,
ôô' (
value
ôô) .
)
ôô. /
;
ôô/ 0
}
öö 	
public
úú 
override
úú 
IByteBuffer
úú #
SetShort
úú$ ,
(
úú, -
int
úú- 0
index
úú1 6
,
úú6 7
int
úú8 ;
value
úú< A
)
úúA B
{
ùù 	/
!RecordLeakNonRefCountingOperation
ûû -
(
ûû- .
this
ûû. 2
.
ûû2 3
Leak
ûû3 7
)
ûû7 8
;
ûû8 9
return
üü 
base
üü 
.
üü 
SetShort
üü  
(
üü  !
index
üü! &
,
üü& '
value
üü( -
)
üü- .
;
üü. /
}
†† 	
public
¢¢ 
override
¢¢ 
IByteBuffer
¢¢ #
SetInt
¢¢$ *
(
¢¢* +
int
¢¢+ .
index
¢¢/ 4
,
¢¢4 5
int
¢¢6 9
value
¢¢: ?
)
¢¢? @
{
££ 	/
!RecordLeakNonRefCountingOperation
§§ -
(
§§- .
this
§§. 2
.
§§2 3
Leak
§§3 7
)
§§7 8
;
§§8 9
return
•• 
base
•• 
.
•• 
SetInt
•• 
(
•• 
index
•• $
,
••$ %
value
••& +
)
••+ ,
;
••, -
}
¶¶ 	
public
®® 
override
®® 
IByteBuffer
®® #
SetLong
®®$ +
(
®®+ ,
int
®®, /
index
®®0 5
,
®®5 6
long
®®7 ;
value
®®< A
)
®®A B
{
©© 	/
!RecordLeakNonRefCountingOperation
™™ -
(
™™- .
this
™™. 2
.
™™2 3
Leak
™™3 7
)
™™7 8
;
™™8 9
return
´´ 
base
´´ 
.
´´ 
SetLong
´´ 
(
´´  
index
´´  %
,
´´% &
value
´´' ,
)
´´, -
;
´´- .
}
¨¨ 	
public
ÆÆ 
override
ÆÆ 
IByteBuffer
ÆÆ #
SetChar
ÆÆ$ +
(
ÆÆ+ ,
int
ÆÆ, /
index
ÆÆ0 5
,
ÆÆ5 6
char
ÆÆ7 ;
value
ÆÆ< A
)
ÆÆA B
{
ØØ 	/
!RecordLeakNonRefCountingOperation
∞∞ -
(
∞∞- .
this
∞∞. 2
.
∞∞2 3
Leak
∞∞3 7
)
∞∞7 8
;
∞∞8 9
return
±± 
base
±± 
.
±± 
SetChar
±± 
(
±±  
index
±±  %
,
±±% &
value
±±' ,
)
±±, -
;
±±- .
}
≤≤ 	
public
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ #
SetFloat
¥¥$ ,
(
¥¥, -
int
¥¥- 0
index
¥¥1 6
,
¥¥6 7
float
¥¥8 =
value
¥¥> C
)
¥¥C D
{
µµ 	/
!RecordLeakNonRefCountingOperation
∂∂ -
(
∂∂- .
this
∂∂. 2
.
∂∂2 3
Leak
∂∂3 7
)
∂∂7 8
;
∂∂8 9
return
∑∑ 
base
∑∑ 
.
∑∑ 
SetFloat
∑∑  
(
∑∑  !
index
∑∑! &
,
∑∑& '
value
∑∑( -
)
∑∑- .
;
∑∑. /
}
∏∏ 	
public
∫∫ 
override
∫∫ 
IByteBuffer
∫∫ #
	SetDouble
∫∫$ -
(
∫∫- .
int
∫∫. 1
index
∫∫2 7
,
∫∫7 8
double
∫∫9 ?
value
∫∫@ E
)
∫∫E F
{
ªª 	/
!RecordLeakNonRefCountingOperation
ºº -
(
ºº- .
this
ºº. 2
.
ºº2 3
Leak
ºº3 7
)
ºº7 8
;
ºº8 9
return
ΩΩ 
base
ΩΩ 
.
ΩΩ 
	SetDouble
ΩΩ !
(
ΩΩ! "
index
ΩΩ" '
,
ΩΩ' (
value
ΩΩ) .
)
ΩΩ. /
;
ΩΩ/ 0
}
ææ 	
public
¿¿ 
override
¿¿ 
IByteBuffer
¿¿ #
SetBytes
¿¿$ ,
(
¿¿, -
int
¿¿- 0
index
¿¿1 6
,
¿¿6 7
IByteBuffer
¿¿8 C
src
¿¿D G
)
¿¿G H
{
¡¡ 	/
!RecordLeakNonRefCountingOperation
¬¬ -
(
¬¬- .
this
¬¬. 2
.
¬¬2 3
Leak
¬¬3 7
)
¬¬7 8
;
¬¬8 9
return
√√ 
base
√√ 
.
√√ 
SetBytes
√√  
(
√√  !
index
√√! &
,
√√& '
src
√√( +
)
√√+ ,
;
√√, -
}
ƒƒ 	
public
∆∆ 
override
∆∆ 
IByteBuffer
∆∆ #
SetBytes
∆∆$ ,
(
∆∆, -
int
∆∆- 0
index
∆∆1 6
,
∆∆6 7
IByteBuffer
∆∆8 C
src
∆∆D G
,
∆∆G H
int
∆∆I L
length
∆∆M S
)
∆∆S T
{
«« 	/
!RecordLeakNonRefCountingOperation
»» -
(
»»- .
this
»». 2
.
»»2 3
Leak
»»3 7
)
»»7 8
;
»»8 9
return
…… 
base
…… 
.
…… 
SetBytes
……  
(
……  !
index
……! &
,
……& '
src
……( +
,
……+ ,
length
……- 3
)
……3 4
;
……4 5
}
   	
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
SetBytes
ÃÃ$ ,
(
ÃÃ, -
int
ÃÃ- 0
index
ÃÃ1 6
,
ÃÃ6 7
IByteBuffer
ÃÃ8 C
src
ÃÃD G
,
ÃÃG H
int
ÃÃI L
srcIndex
ÃÃM U
,
ÃÃU V
int
ÃÃW Z
length
ÃÃ[ a
)
ÃÃa b
{
ÕÕ 	/
!RecordLeakNonRefCountingOperation
ŒŒ -
(
ŒŒ- .
this
ŒŒ. 2
.
ŒŒ2 3
Leak
ŒŒ3 7
)
ŒŒ7 8
;
ŒŒ8 9
return
œœ 
base
œœ 
.
œœ 
SetBytes
œœ  
(
œœ  !
index
œœ! &
,
œœ& '
src
œœ( +
,
œœ+ ,
srcIndex
œœ- 5
,
œœ5 6
length
œœ7 =
)
œœ= >
;
œœ> ?
}
–– 	
public
““ 
override
““ 
IByteBuffer
““ #
SetBytes
““$ ,
(
““, -
int
““- 0
index
““1 6
,
““6 7
byte
““8 <
[
““< =
]
““= >
src
““? B
)
““B C
{
”” 	/
!RecordLeakNonRefCountingOperation
‘‘ -
(
‘‘- .
this
‘‘. 2
.
‘‘2 3
Leak
‘‘3 7
)
‘‘7 8
;
‘‘8 9
return
’’ 
base
’’ 
.
’’ 
SetBytes
’’  
(
’’  !
index
’’! &
,
’’& '
src
’’( +
)
’’+ ,
;
’’, -
}
÷÷ 	
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
SetBytes
ÿÿ$ ,
(
ÿÿ, -
int
ÿÿ- 0
index
ÿÿ1 6
,
ÿÿ6 7
byte
ÿÿ8 <
[
ÿÿ< =
]
ÿÿ= >
src
ÿÿ? B
,
ÿÿB C
int
ÿÿD G
srcIndex
ÿÿH P
,
ÿÿP Q
int
ÿÿR U
length
ÿÿV \
)
ÿÿ\ ]
{
ŸŸ 	/
!RecordLeakNonRefCountingOperation
⁄⁄ -
(
⁄⁄- .
this
⁄⁄. 2
.
⁄⁄2 3
Leak
⁄⁄3 7
)
⁄⁄7 8
;
⁄⁄8 9
return
€€ 
base
€€ 
.
€€ 
SetBytes
€€  
(
€€  !
index
€€! &
,
€€& '
src
€€( +
,
€€+ ,
srcIndex
€€- 5
,
€€5 6
length
€€7 =
)
€€= >
;
€€> ?
}
‹‹ 	
public
ﬁﬁ 
override
ﬁﬁ 
Task
ﬁﬁ 
<
ﬁﬁ 
int
ﬁﬁ  
>
ﬁﬁ  !
SetBytesAsync
ﬁﬁ" /
(
ﬁﬁ/ 0
int
ﬁﬁ0 3
index
ﬁﬁ4 9
,
ﬁﬁ9 :
Stream
ﬁﬁ; A
input
ﬁﬁB G
,
ﬁﬁG H
int
ﬁﬁI L
length
ﬁﬁM S
,
ﬁﬁS T
CancellationToken
ﬁﬁU f
cancellationToken
ﬁﬁg x
)
ﬁﬁx y
{
ﬂﬂ 	/
!RecordLeakNonRefCountingOperation
‡‡ -
(
‡‡- .
this
‡‡. 2
.
‡‡2 3
Leak
‡‡3 7
)
‡‡7 8
;
‡‡8 9
return
·· 
base
·· 
.
·· 
SetBytesAsync
·· %
(
··% &
index
··& +
,
··+ ,
input
··- 2
,
··2 3
length
··4 :
,
··: ;
cancellationToken
··< M
)
··M N
;
··N O
}
‚‚ 	
public
‰‰ 
override
‰‰ 
IByteBuffer
‰‰ #
SetZero
‰‰$ +
(
‰‰+ ,
int
‰‰, /
index
‰‰0 5
,
‰‰5 6
int
‰‰7 :
length
‰‰; A
)
‰‰A B
{
ÂÂ 	/
!RecordLeakNonRefCountingOperation
ÊÊ -
(
ÊÊ- .
this
ÊÊ. 2
.
ÊÊ2 3
Leak
ÊÊ3 7
)
ÊÊ7 8
;
ÊÊ8 9
return
ÁÁ 
base
ÁÁ 
.
ÁÁ 
SetZero
ÁÁ 
(
ÁÁ  
index
ÁÁ  %
,
ÁÁ% &
length
ÁÁ' -
)
ÁÁ- .
;
ÁÁ. /
}
ËË 	
public
ÍÍ 
override
ÍÍ 
byte
ÍÍ 
ReadByte
ÍÍ %
(
ÍÍ% &
)
ÍÍ& '
{
ÎÎ 	/
!RecordLeakNonRefCountingOperation
ÏÏ -
(
ÏÏ- .
this
ÏÏ. 2
.
ÏÏ2 3
Leak
ÏÏ3 7
)
ÏÏ7 8
;
ÏÏ8 9
return
ÌÌ 
base
ÌÌ 
.
ÌÌ 
ReadByte
ÌÌ  
(
ÌÌ  !
)
ÌÌ! "
;
ÌÌ" #
}
ÓÓ 	
public
 
override
 
short
 
	ReadShort
 '
(
' (
)
( )
{
ÒÒ 	/
!RecordLeakNonRefCountingOperation
ÚÚ -
(
ÚÚ- .
this
ÚÚ. 2
.
ÚÚ2 3
Leak
ÚÚ3 7
)
ÚÚ7 8
;
ÚÚ8 9
return
ÛÛ 
base
ÛÛ 
.
ÛÛ 
	ReadShort
ÛÛ !
(
ÛÛ! "
)
ÛÛ" #
;
ÛÛ# $
}
ÙÙ 	
public
ˆˆ 
override
ˆˆ 
int
ˆˆ  
ReadUnsignedMedium
ˆˆ .
(
ˆˆ. /
)
ˆˆ/ 0
{
˜˜ 	/
!RecordLeakNonRefCountingOperation
¯¯ -
(
¯¯- .
this
¯¯. 2
.
¯¯2 3
Leak
¯¯3 7
)
¯¯7 8
;
¯¯8 9
return
˘˘ 
base
˘˘ 
.
˘˘  
ReadUnsignedMedium
˘˘ *
(
˘˘* +
)
˘˘+ ,
;
˘˘, -
}
˙˙ 	
public
¸¸ 
override
¸¸ 
int
¸¸ 
ReadInt
¸¸ #
(
¸¸# $
)
¸¸$ %
{
˝˝ 	/
!RecordLeakNonRefCountingOperation
˛˛ -
(
˛˛- .
this
˛˛. 2
.
˛˛2 3
Leak
˛˛3 7
)
˛˛7 8
;
˛˛8 9
return
ˇˇ 
base
ˇˇ 
.
ˇˇ 
ReadInt
ˇˇ 
(
ˇˇ  
)
ˇˇ  !
;
ˇˇ! "
}
ÄÄ 	
public
ÇÇ 
override
ÇÇ 
long
ÇÇ 
ReadLong
ÇÇ %
(
ÇÇ% &
)
ÇÇ& '
{
ÉÉ 	/
!RecordLeakNonRefCountingOperation
ÑÑ -
(
ÑÑ- .
this
ÑÑ. 2
.
ÑÑ2 3
Leak
ÑÑ3 7
)
ÑÑ7 8
;
ÑÑ8 9
return
ÖÖ 
base
ÖÖ 
.
ÖÖ 
ReadLong
ÖÖ  
(
ÖÖ  !
)
ÖÖ! "
;
ÖÖ" #
}
ÜÜ 	
public
àà 
override
àà 
IByteBuffer
àà #
	ReadBytes
àà$ -
(
àà- .
int
àà. 1
length
àà2 8
)
àà8 9
{
ââ 	/
!RecordLeakNonRefCountingOperation
ää -
(
ää- .
this
ää. 2
.
ää2 3
Leak
ää3 7
)
ää7 8
;
ää8 9
return
ãã 
base
ãã 
.
ãã 
	ReadBytes
ãã !
(
ãã! "
length
ãã" (
)
ãã( )
;
ãã) *
}
åå 	
public
éé 
override
éé 
IByteBuffer
éé #
	ReadBytes
éé$ -
(
éé- .
IByteBuffer
éé. 9
dst
éé: =
)
éé= >
{
èè 	/
!RecordLeakNonRefCountingOperation
êê -
(
êê- .
this
êê. 2
.
êê2 3
Leak
êê3 7
)
êê7 8
;
êê8 9
return
ëë 
base
ëë 
.
ëë 
	ReadBytes
ëë !
(
ëë! "
dst
ëë" %
)
ëë% &
;
ëë& '
}
íí 	
public
îî 
override
îî 
IByteBuffer
îî #
	ReadBytes
îî$ -
(
îî- .
IByteBuffer
îî. 9
dst
îî: =
,
îî= >
int
îî? B
length
îîC I
)
îîI J
{
ïï 	/
!RecordLeakNonRefCountingOperation
ññ -
(
ññ- .
this
ññ. 2
.
ññ2 3
Leak
ññ3 7
)
ññ7 8
;
ññ8 9
return
óó 
base
óó 
.
óó 
	ReadBytes
óó !
(
óó! "
dst
óó" %
,
óó% &
length
óó' -
)
óó- .
;
óó. /
}
òò 	
public
öö 
override
öö 
IByteBuffer
öö #
	ReadBytes
öö$ -
(
öö- .
IByteBuffer
öö. 9
dst
öö: =
,
öö= >
int
öö? B
dstIndex
ööC K
,
ööK L
int
ööM P
length
ööQ W
)
ööW X
{
õõ 	/
!RecordLeakNonRefCountingOperation
úú -
(
úú- .
this
úú. 2
.
úú2 3
Leak
úú3 7
)
úú7 8
;
úú8 9
return
ùù 
base
ùù 
.
ùù 
	ReadBytes
ùù !
(
ùù! "
dst
ùù" %
,
ùù% &
dstIndex
ùù' /
,
ùù/ 0
length
ùù1 7
)
ùù7 8
;
ùù8 9
}
ûû 	
public
†† 
override
†† 
IByteBuffer
†† #
	ReadBytes
††$ -
(
††- .
byte
††. 2
[
††2 3
]
††3 4
dst
††5 8
)
††8 9
{
°° 	/
!RecordLeakNonRefCountingOperation
¢¢ -
(
¢¢- .
this
¢¢. 2
.
¢¢2 3
Leak
¢¢3 7
)
¢¢7 8
;
¢¢8 9
return
££ 
base
££ 
.
££ 
	ReadBytes
££ !
(
££! "
dst
££" %
)
££% &
;
££& '
}
§§ 	
public
¶¶ 
override
¶¶ 
IByteBuffer
¶¶ #
	ReadBytes
¶¶$ -
(
¶¶- .
byte
¶¶. 2
[
¶¶2 3
]
¶¶3 4
dst
¶¶5 8
,
¶¶8 9
int
¶¶: =
dstIndex
¶¶> F
,
¶¶F G
int
¶¶H K
length
¶¶L R
)
¶¶R S
{
ßß 	/
!RecordLeakNonRefCountingOperation
®® -
(
®®- .
this
®®. 2
.
®®2 3
Leak
®®3 7
)
®®7 8
;
®®8 9
return
©© 
base
©© 
.
©© 
	ReadBytes
©© !
(
©©! "
dst
©©" %
,
©©% &
dstIndex
©©' /
,
©©/ 0
length
©©1 7
)
©©7 8
;
©©8 9
}
™™ 	
public
¨¨ 
override
¨¨ 
IByteBuffer
¨¨ #
	ReadBytes
¨¨$ -
(
¨¨- .
Stream
¨¨. 4
output
¨¨5 ;
,
¨¨; <
int
¨¨= @
length
¨¨A G
)
¨¨G H
{
≠≠ 	/
!RecordLeakNonRefCountingOperation
ÆÆ -
(
ÆÆ- .
this
ÆÆ. 2
.
ÆÆ2 3
Leak
ÆÆ3 7
)
ÆÆ7 8
;
ÆÆ8 9
return
ØØ 
base
ØØ 
.
ØØ 
	ReadBytes
ØØ !
(
ØØ! "
output
ØØ" (
,
ØØ( )
length
ØØ* 0
)
ØØ0 1
;
ØØ1 2
}
∞∞ 	
public
≤≤ 
override
≤≤ 
IByteBuffer
≤≤ #
	SkipBytes
≤≤$ -
(
≤≤- .
int
≤≤. 1
length
≤≤2 8
)
≤≤8 9
{
≥≥ 	/
!RecordLeakNonRefCountingOperation
¥¥ -
(
¥¥- .
this
¥¥. 2
.
¥¥2 3
Leak
¥¥3 7
)
¥¥7 8
;
¥¥8 9
return
µµ 
base
µµ 
.
µµ 
	SkipBytes
µµ !
(
µµ! "
length
µµ" (
)
µµ( )
;
µµ) *
}
∂∂ 	
public
∏∏ 
override
∏∏ 
IByteBuffer
∏∏ #
WriteBoolean
∏∏$ 0
(
∏∏0 1
bool
∏∏1 5
value
∏∏6 ;
)
∏∏; <
{
ππ 	/
!RecordLeakNonRefCountingOperation
∫∫ -
(
∫∫- .
this
∫∫. 2
.
∫∫2 3
Leak
∫∫3 7
)
∫∫7 8
;
∫∫8 9
return
ªª 
base
ªª 
.
ªª 
WriteBoolean
ªª $
(
ªª$ %
value
ªª% *
)
ªª* +
;
ªª+ ,
}
ºº 	
public
ææ 
override
ææ 
IByteBuffer
ææ #
	WriteByte
ææ$ -
(
ææ- .
int
ææ. 1
value
ææ2 7
)
ææ7 8
{
øø 	/
!RecordLeakNonRefCountingOperation
¿¿ -
(
¿¿- .
this
¿¿. 2
.
¿¿2 3
Leak
¿¿3 7
)
¿¿7 8
;
¿¿8 9
return
¡¡ 
base
¡¡ 
.
¡¡ 
	WriteByte
¡¡ !
(
¡¡! "
value
¡¡" '
)
¡¡' (
;
¡¡( )
}
¬¬ 	
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #

WriteShort
ƒƒ$ .
(
ƒƒ. /
int
ƒƒ/ 2
value
ƒƒ3 8
)
ƒƒ8 9
{
≈≈ 	/
!RecordLeakNonRefCountingOperation
∆∆ -
(
∆∆- .
this
∆∆. 2
.
∆∆2 3
Leak
∆∆3 7
)
∆∆7 8
;
∆∆8 9
return
«« 
base
«« 
.
«« 

WriteShort
«« "
(
««" #
value
««# (
)
««( )
;
««) *
}
»» 	
public
   
override
   
IByteBuffer
   #
WriteInt
  $ ,
(
  , -
int
  - 0
value
  1 6
)
  6 7
{
ÀÀ 	/
!RecordLeakNonRefCountingOperation
ÃÃ -
(
ÃÃ- .
this
ÃÃ. 2
.
ÃÃ2 3
Leak
ÃÃ3 7
)
ÃÃ7 8
;
ÃÃ8 9
return
ÕÕ 
base
ÕÕ 
.
ÕÕ 
WriteInt
ÕÕ  
(
ÕÕ  !
value
ÕÕ! &
)
ÕÕ& '
;
ÕÕ' (
}
ŒŒ 	
public
–– 
override
–– 
IByteBuffer
–– #
WriteMedium
––$ /
(
––/ 0
int
––0 3
value
––4 9
)
––9 :
{
—— 	/
!RecordLeakNonRefCountingOperation
““ -
(
““- .
this
““. 2
.
““2 3
Leak
““3 7
)
““7 8
;
““8 9
return
”” 
base
”” 
.
”” 
WriteMedium
”” #
(
””# $
value
””$ )
)
””) *
;
””* +
}
‘‘ 	
public
÷÷ 
override
÷÷ 
IByteBuffer
÷÷ #
	WriteLong
÷÷$ -
(
÷÷- .
long
÷÷. 2
value
÷÷3 8
)
÷÷8 9
{
◊◊ 	/
!RecordLeakNonRefCountingOperation
ÿÿ -
(
ÿÿ- .
this
ÿÿ. 2
.
ÿÿ2 3
Leak
ÿÿ3 7
)
ÿÿ7 8
;
ÿÿ8 9
return
ŸŸ 
base
ŸŸ 
.
ŸŸ 
	WriteLong
ŸŸ !
(
ŸŸ! "
value
ŸŸ" '
)
ŸŸ' (
;
ŸŸ( )
}
⁄⁄ 	
public
‹‹ 
override
‹‹ 
IByteBuffer
‹‹ #
	WriteChar
‹‹$ -
(
‹‹- .
char
‹‹. 2
value
‹‹3 8
)
‹‹8 9
{
›› 	/
!RecordLeakNonRefCountingOperation
ﬁﬁ -
(
ﬁﬁ- .
this
ﬁﬁ. 2
.
ﬁﬁ2 3
Leak
ﬁﬁ3 7
)
ﬁﬁ7 8
;
ﬁﬁ8 9
return
ﬂﬂ 
base
ﬂﬂ 
.
ﬂﬂ 
	WriteChar
ﬂﬂ !
(
ﬂﬂ! "
value
ﬂﬂ" '
)
ﬂﬂ' (
;
ﬂﬂ( )
}
‡‡ 	
public
‚‚ 
override
‚‚ 
IByteBuffer
‚‚ #

WriteFloat
‚‚$ .
(
‚‚. /
float
‚‚/ 4
value
‚‚5 :
)
‚‚: ;
{
„„ 	/
!RecordLeakNonRefCountingOperation
‰‰ -
(
‰‰- .
this
‰‰. 2
.
‰‰2 3
Leak
‰‰3 7
)
‰‰7 8
;
‰‰8 9
return
ÂÂ 
base
ÂÂ 
.
ÂÂ 

WriteFloat
ÂÂ "
(
ÂÂ" #
value
ÂÂ# (
)
ÂÂ( )
;
ÂÂ) *
}
ÊÊ 	
public
ËË 
override
ËË 
IByteBuffer
ËË #
WriteDouble
ËË$ /
(
ËË/ 0
double
ËË0 6
value
ËË7 <
)
ËË< =
{
ÈÈ 	/
!RecordLeakNonRefCountingOperation
ÍÍ -
(
ÍÍ- .
this
ÍÍ. 2
.
ÍÍ2 3
Leak
ÍÍ3 7
)
ÍÍ7 8
;
ÍÍ8 9
return
ÎÎ 
base
ÎÎ 
.
ÎÎ 
WriteDouble
ÎÎ #
(
ÎÎ# $
value
ÎÎ$ )
)
ÎÎ) *
;
ÎÎ* +
}
ÏÏ 	
public
ÓÓ 
override
ÓÓ 
IByteBuffer
ÓÓ #

WriteBytes
ÓÓ$ .
(
ÓÓ. /
IByteBuffer
ÓÓ/ :
src
ÓÓ; >
)
ÓÓ> ?
{
ÔÔ 	/
!RecordLeakNonRefCountingOperation
 -
(
- .
this
. 2
.
2 3
Leak
3 7
)
7 8
;
8 9
return
ÒÒ 
base
ÒÒ 
.
ÒÒ 

WriteBytes
ÒÒ "
(
ÒÒ" #
src
ÒÒ# &
)
ÒÒ& '
;
ÒÒ' (
}
ÚÚ 	
public
ÙÙ 
override
ÙÙ 
IByteBuffer
ÙÙ #

WriteBytes
ÙÙ$ .
(
ÙÙ. /
IByteBuffer
ÙÙ/ :
src
ÙÙ; >
,
ÙÙ> ?
int
ÙÙ@ C
length
ÙÙD J
)
ÙÙJ K
{
ıı 	/
!RecordLeakNonRefCountingOperation
ˆˆ -
(
ˆˆ- .
this
ˆˆ. 2
.
ˆˆ2 3
Leak
ˆˆ3 7
)
ˆˆ7 8
;
ˆˆ8 9
return
˜˜ 
base
˜˜ 
.
˜˜ 

WriteBytes
˜˜ "
(
˜˜" #
src
˜˜# &
,
˜˜& '
length
˜˜( .
)
˜˜. /
;
˜˜/ 0
}
¯¯ 	
public
˙˙ 
override
˙˙ 
IByteBuffer
˙˙ #

WriteBytes
˙˙$ .
(
˙˙. /
IByteBuffer
˙˙/ :
src
˙˙; >
,
˙˙> ?
int
˙˙@ C
srcIndex
˙˙D L
,
˙˙L M
int
˙˙N Q
length
˙˙R X
)
˙˙X Y
{
˚˚ 	/
!RecordLeakNonRefCountingOperation
¸¸ -
(
¸¸- .
this
¸¸. 2
.
¸¸2 3
Leak
¸¸3 7
)
¸¸7 8
;
¸¸8 9
return
˝˝ 
base
˝˝ 
.
˝˝ 

WriteBytes
˝˝ "
(
˝˝" #
src
˝˝# &
,
˝˝& '
srcIndex
˝˝( 0
,
˝˝0 1
length
˝˝2 8
)
˝˝8 9
;
˝˝9 :
}
˛˛ 	
public
ÄÄ 
override
ÄÄ 
IByteBuffer
ÄÄ #

WriteBytes
ÄÄ$ .
(
ÄÄ. /
byte
ÄÄ/ 3
[
ÄÄ3 4
]
ÄÄ4 5
src
ÄÄ6 9
)
ÄÄ9 :
{
ÅÅ 	/
!RecordLeakNonRefCountingOperation
ÇÇ -
(
ÇÇ- .
this
ÇÇ. 2
.
ÇÇ2 3
Leak
ÇÇ3 7
)
ÇÇ7 8
;
ÇÇ8 9
return
ÉÉ 
base
ÉÉ 
.
ÉÉ 

WriteBytes
ÉÉ "
(
ÉÉ" #
src
ÉÉ# &
)
ÉÉ& '
;
ÉÉ' (
}
ÑÑ 	
public
ÜÜ 
override
ÜÜ 
IByteBuffer
ÜÜ #

WriteBytes
ÜÜ$ .
(
ÜÜ. /
byte
ÜÜ/ 3
[
ÜÜ3 4
]
ÜÜ4 5
src
ÜÜ6 9
,
ÜÜ9 :
int
ÜÜ; >
srcIndex
ÜÜ? G
,
ÜÜG H
int
ÜÜI L
length
ÜÜM S
)
ÜÜS T
{
áá 	/
!RecordLeakNonRefCountingOperation
àà -
(
àà- .
this
àà. 2
.
àà2 3
Leak
àà3 7
)
àà7 8
;
àà8 9
return
ââ 
base
ââ 
.
ââ 

WriteBytes
ââ "
(
ââ" #
src
ââ# &
,
ââ& '
srcIndex
ââ( 0
,
ââ0 1
length
ââ2 8
)
ââ8 9
;
ââ9 :
}
ää 	
public
åå 
override
åå 
Task
åå 
WriteBytesAsync
åå ,
(
åå, -
Stream
åå- 3
input
åå4 9
,
åå9 :
int
åå; >
length
åå? E
,
ååE F
CancellationToken
ååG X
cancellationToken
ååY j
)
ååj k
{
çç 	/
!RecordLeakNonRefCountingOperation
éé -
(
éé- .
this
éé. 2
.
éé2 3
Leak
éé3 7
)
éé7 8
;
éé8 9
return
èè 
base
èè 
.
èè 
WriteBytesAsync
èè '
(
èè' (
input
èè( -
,
èè- .
length
èè/ 5
,
èè5 6
cancellationToken
èè7 H
)
èèH I
;
èèI J
}
êê 	
public
íí 
override
íí 
IByteBuffer
íí #
	WriteZero
íí$ -
(
íí- .
int
íí. 1
length
íí2 8
)
íí8 9
{
ìì 	/
!RecordLeakNonRefCountingOperation
îî -
(
îî- .
this
îî. 2
.
îî2 3
Leak
îî3 7
)
îî7 8
;
îî8 9
return
ïï 
base
ïï 
.
ïï 
	WriteZero
ïï !
(
ïï! "
length
ïï" (
)
ïï( )
;
ïï) *
}
ññ 	
public
òò 
override
òò 
int
òò 
IndexOf
òò #
(
òò# $
int
òò$ '
	fromIndex
òò( 1
,
òò1 2
int
òò3 6
toIndex
òò7 >
,
òò> ?
byte
òò@ D
value
òòE J
)
òòJ K
{
ôô 	/
!RecordLeakNonRefCountingOperation
öö -
(
öö- .
this
öö. 2
.
öö2 3
Leak
öö3 7
)
öö7 8
;
öö8 9
return
õõ 
base
õõ 
.
õõ 
IndexOf
õõ 
(
õõ  
	fromIndex
õõ  )
,
õõ) *
toIndex
õõ+ 2
,
õõ2 3
value
õõ4 9
)
õõ9 :
;
õõ: ;
}
úú 	
public
ûû 
override
ûû 
int
ûû 
BytesBefore
ûû '
(
ûû' (
int
ûû( +
index
ûû, 1
,
ûû1 2
int
ûû3 6
length
ûû7 =
,
ûû= >
byte
ûû? C
value
ûûD I
)
ûûI J
{
üü 	/
!RecordLeakNonRefCountingOperation
†† -
(
††- .
this
††. 2
.
††2 3
Leak
††3 7
)
††7 8
;
††8 9
return
°° 
base
°° 
.
°° 
BytesBefore
°° #
(
°°# $
index
°°$ )
,
°°) *
length
°°+ 1
,
°°1 2
value
°°3 8
)
°°8 9
;
°°9 :
}
¢¢ 	
public
§§ 
override
§§ 
int
§§ 
ForEachByte
§§ '
(
§§' (
IByteProcessor
§§( 6
	processor
§§7 @
)
§§@ A
{
•• 	/
!RecordLeakNonRefCountingOperation
¶¶ -
(
¶¶- .
this
¶¶. 2
.
¶¶2 3
Leak
¶¶3 7
)
¶¶7 8
;
¶¶8 9
return
ßß 
base
ßß 
.
ßß 
ForEachByte
ßß #
(
ßß# $
	processor
ßß$ -
)
ßß- .
;
ßß. /
}
®® 	
public
™™ 
override
™™ 
int
™™ 
ForEachByte
™™ '
(
™™' (
int
™™( +
index
™™, 1
,
™™1 2
int
™™3 6
length
™™7 =
,
™™= >
IByteProcessor
™™? M
	processor
™™N W
)
™™W X
{
´´ 	/
!RecordLeakNonRefCountingOperation
¨¨ -
(
¨¨- .
this
¨¨. 2
.
¨¨2 3
Leak
¨¨3 7
)
¨¨7 8
;
¨¨8 9
return
≠≠ 
base
≠≠ 
.
≠≠ 
ForEachByte
≠≠ #
(
≠≠# $
index
≠≠$ )
,
≠≠) *
length
≠≠+ 1
,
≠≠1 2
	processor
≠≠3 <
)
≠≠< =
;
≠≠= >
}
ÆÆ 	
public
∞∞ 
override
∞∞ 
int
∞∞ 
ForEachByteDesc
∞∞ +
(
∞∞+ ,
IByteProcessor
∞∞, :
	processor
∞∞; D
)
∞∞D E
{
±± 	/
!RecordLeakNonRefCountingOperation
≤≤ -
(
≤≤- .
this
≤≤. 2
.
≤≤2 3
Leak
≤≤3 7
)
≤≤7 8
;
≤≤8 9
return
≥≥ 
base
≥≥ 
.
≥≥ 
ForEachByteDesc
≥≥ '
(
≥≥' (
	processor
≥≥( 1
)
≥≥1 2
;
≥≥2 3
}
¥¥ 	
public
∂∂ 
override
∂∂ 
int
∂∂ 
ForEachByteDesc
∂∂ +
(
∂∂+ ,
int
∂∂, /
index
∂∂0 5
,
∂∂5 6
int
∂∂7 :
length
∂∂; A
,
∂∂A B
IByteProcessor
∂∂C Q
	processor
∂∂R [
)
∂∂[ \
{
∑∑ 	/
!RecordLeakNonRefCountingOperation
∏∏ -
(
∏∏- .
this
∏∏. 2
.
∏∏2 3
Leak
∏∏3 7
)
∏∏7 8
;
∏∏8 9
return
ππ 
base
ππ 
.
ππ 
ForEachByteDesc
ππ '
(
ππ' (
index
ππ( -
,
ππ- .
length
ππ/ 5
,
ππ5 6
	processor
ππ7 @
)
ππ@ A
;
ππA B
}
∫∫ 	
public
ºº 
override
ºº 
IByteBuffer
ºº #
Copy
ºº$ (
(
ºº( )
)
ºº) *
{
ΩΩ 	/
!RecordLeakNonRefCountingOperation
ææ -
(
ææ- .
this
ææ. 2
.
ææ2 3
Leak
ææ3 7
)
ææ7 8
;
ææ8 9
return
øø 
base
øø 
.
øø 
Copy
øø 
(
øø 
)
øø 
;
øø 
}
¿¿ 	
public
¬¬ 
override
¬¬ 
IByteBuffer
¬¬ #
Copy
¬¬$ (
(
¬¬( )
int
¬¬) ,
index
¬¬- 2
,
¬¬2 3
int
¬¬4 7
length
¬¬8 >
)
¬¬> ?
{
√√ 	/
!RecordLeakNonRefCountingOperation
ƒƒ -
(
ƒƒ- .
this
ƒƒ. 2
.
ƒƒ2 3
Leak
ƒƒ3 7
)
ƒƒ7 8
;
ƒƒ8 9
return
≈≈ 
base
≈≈ 
.
≈≈ 
Copy
≈≈ 
(
≈≈ 
index
≈≈ "
,
≈≈" #
length
≈≈$ *
)
≈≈* +
;
≈≈+ ,
}
∆∆ 	
public
»» 
override
»» 
int
»» 
IoBufferCount
»» )
{
…… 	
get
   
{
ÀÀ /
!RecordLeakNonRefCountingOperation
ÃÃ 1
(
ÃÃ1 2
this
ÃÃ2 6
.
ÃÃ6 7
Leak
ÃÃ7 ;
)
ÃÃ; <
;
ÃÃ< =
return
ÕÕ 
base
ÕÕ 
.
ÕÕ 
IoBufferCount
ÕÕ )
;
ÕÕ) *
}
ŒŒ 
}
œœ 	
public
—— 
override
—— 
ArraySegment
—— $
<
——$ %
byte
——% )
>
——) *
GetIoBuffer
——+ 6
(
——6 7
int
——7 :
index
——; @
,
——@ A
int
——B E
length
——F L
)
——L M
{
““ 	/
!RecordLeakNonRefCountingOperation
”” -
(
””- .
this
””. 2
.
””2 3
Leak
””3 7
)
””7 8
;
””8 9
return
‘‘ 
base
‘‘ 
.
‘‘ 
GetIoBuffer
‘‘ #
(
‘‘# $
index
‘‘$ )
,
‘‘) *
length
‘‘+ 1
)
‘‘1 2
;
‘‘2 3
}
’’ 	
public
◊◊ 
override
◊◊ 
ArraySegment
◊◊ $
<
◊◊$ %
byte
◊◊% )
>
◊◊) *
[
◊◊* +
]
◊◊+ ,
GetIoBuffers
◊◊- 9
(
◊◊9 :
int
◊◊: =
index
◊◊> C
,
◊◊C D
int
◊◊E H
length
◊◊I O
)
◊◊O P
{
ÿÿ 	/
!RecordLeakNonRefCountingOperation
ŸŸ -
(
ŸŸ- .
this
ŸŸ. 2
.
ŸŸ2 3
Leak
ŸŸ3 7
)
ŸŸ7 8
;
ŸŸ8 9
return
⁄⁄ 
base
⁄⁄ 
.
⁄⁄ 
GetIoBuffers
⁄⁄ $
(
⁄⁄$ %
index
⁄⁄% *
,
⁄⁄* +
length
⁄⁄, 2
)
⁄⁄2 3
;
⁄⁄3 4
}
€€ 	
public
›› 
override
›› 
string
›› 
ToString
›› '
(
››' (
Encoding
››( 0
encoding
››1 9
)
››9 :
{
ﬁﬁ 	/
!RecordLeakNonRefCountingOperation
ﬂﬂ -
(
ﬂﬂ- .
this
ﬂﬂ. 2
.
ﬂﬂ2 3
Leak
ﬂﬂ3 7
)
ﬂﬂ7 8
;
ﬂﬂ8 9
return
‡‡ 
base
‡‡ 
.
‡‡ 
ToString
‡‡  
(
‡‡  !
encoding
‡‡! )
)
‡‡) *
;
‡‡* +
}
·· 	
public
„„ 
override
„„ 
string
„„ 
ToString
„„ '
(
„„' (
int
„„( +
index
„„, 1
,
„„1 2
int
„„3 6
length
„„7 =
,
„„= >
Encoding
„„? G
encoding
„„H P
)
„„P Q
{
‰‰ 	/
!RecordLeakNonRefCountingOperation
ÂÂ -
(
ÂÂ- .
this
ÂÂ. 2
.
ÂÂ2 3
Leak
ÂÂ3 7
)
ÂÂ7 8
;
ÂÂ8 9
return
ÊÊ 
base
ÊÊ 
.
ÊÊ 
ToString
ÊÊ  
(
ÊÊ  !
index
ÊÊ! &
,
ÊÊ& '
length
ÊÊ( .
,
ÊÊ. /
encoding
ÊÊ0 8
)
ÊÊ8 9
;
ÊÊ9 :
}
ÁÁ 	
public
ÈÈ 
override
ÈÈ 
IByteBuffer
ÈÈ #
AdjustCapacity
ÈÈ$ 2
(
ÈÈ2 3
int
ÈÈ3 6
newCapacity
ÈÈ7 B
)
ÈÈB C
{
ÍÍ 	/
!RecordLeakNonRefCountingOperation
ÎÎ -
(
ÎÎ- .
this
ÎÎ. 2
.
ÎÎ2 3
Leak
ÎÎ3 7
)
ÎÎ7 8
;
ÎÎ8 9
return
ÏÏ 
base
ÏÏ 
.
ÏÏ 
AdjustCapacity
ÏÏ &
(
ÏÏ& '
newCapacity
ÏÏ' 2
)
ÏÏ2 3
;
ÏÏ3 4
}
ÌÌ 	
public
ÔÔ 
override
ÔÔ 
short
ÔÔ 

GetShortLE
ÔÔ (
(
ÔÔ( )
int
ÔÔ) ,
index
ÔÔ- 2
)
ÔÔ2 3
{
 	/
!RecordLeakNonRefCountingOperation
ÒÒ -
(
ÒÒ- .
this
ÒÒ. 2
.
ÒÒ2 3
Leak
ÒÒ3 7
)
ÒÒ7 8
;
ÒÒ8 9
return
ÚÚ 
base
ÚÚ 
.
ÚÚ 

GetShortLE
ÚÚ "
(
ÚÚ" #
index
ÚÚ# (
)
ÚÚ( )
;
ÚÚ) *
}
ÛÛ 	
public
ıı 
override
ıı 
int
ıı !
GetUnsignedMediumLE
ıı /
(
ıı/ 0
int
ıı0 3
index
ıı4 9
)
ıı9 :
{
ˆˆ 	/
!RecordLeakNonRefCountingOperation
˜˜ -
(
˜˜- .
this
˜˜. 2
.
˜˜2 3
Leak
˜˜3 7
)
˜˜7 8
;
˜˜8 9
return
¯¯ 
base
¯¯ 
.
¯¯ !
GetUnsignedMediumLE
¯¯ +
(
¯¯+ ,
index
¯¯, 1
)
¯¯1 2
;
¯¯2 3
}
˘˘ 	
public
˚˚ 
override
˚˚ 
int
˚˚ 
GetIntLE
˚˚ $
(
˚˚$ %
int
˚˚% (
index
˚˚) .
)
˚˚. /
{
¸¸ 	/
!RecordLeakNonRefCountingOperation
˝˝ -
(
˝˝- .
this
˝˝. 2
.
˝˝2 3
Leak
˝˝3 7
)
˝˝7 8
;
˝˝8 9
return
˛˛ 
base
˛˛ 
.
˛˛ 
GetIntLE
˛˛  
(
˛˛  !
index
˛˛! &
)
˛˛& '
;
˛˛' (
}
ˇˇ 	
public
ÅÅ 
override
ÅÅ 
long
ÅÅ 
	GetLongLE
ÅÅ &
(
ÅÅ& '
int
ÅÅ' *
index
ÅÅ+ 0
)
ÅÅ0 1
{
ÇÇ 	/
!RecordLeakNonRefCountingOperation
ÉÉ -
(
ÉÉ- .
this
ÉÉ. 2
.
ÉÉ2 3
Leak
ÉÉ3 7
)
ÉÉ7 8
;
ÉÉ8 9
return
ÑÑ 
base
ÑÑ 
.
ÑÑ 
	GetLongLE
ÑÑ !
(
ÑÑ! "
index
ÑÑ" '
)
ÑÑ' (
;
ÑÑ( )
}
ÖÖ 	
public
áá 
override
áá 
IByteBuffer
áá #

SetShortLE
áá$ .
(
áá. /
int
áá/ 2
index
áá3 8
,
áá8 9
int
áá: =
value
áá> C
)
ááC D
{
àà 	/
!RecordLeakNonRefCountingOperation
ââ -
(
ââ- .
this
ââ. 2
.
ââ2 3
Leak
ââ3 7
)
ââ7 8
;
ââ8 9
return
ää 
base
ää 
.
ää 

SetShortLE
ää "
(
ää" #
index
ää# (
,
ää( )
value
ää* /
)
ää/ 0
;
ää0 1
}
ãã 	
public
çç 
override
çç 
IByteBuffer
çç #
SetIntLE
çç$ ,
(
çç, -
int
çç- 0
index
çç1 6
,
çç6 7
int
çç8 ;
value
çç< A
)
ççA B
{
éé 	/
!RecordLeakNonRefCountingOperation
èè -
(
èè- .
this
èè. 2
.
èè2 3
Leak
èè3 7
)
èè7 8
;
èè8 9
return
êê 
base
êê 
.
êê 
SetIntLE
êê  
(
êê  !
index
êê! &
,
êê& '
value
êê( -
)
êê- .
;
êê. /
}
ëë 	
public
ìì 
override
ìì 
IByteBuffer
ìì #
SetMediumLE
ìì$ /
(
ìì/ 0
int
ìì0 3
index
ìì4 9
,
ìì9 :
int
ìì; >
value
ìì? D
)
ììD E
{
îî 	/
!RecordLeakNonRefCountingOperation
ïï -
(
ïï- .
this
ïï. 2
.
ïï2 3
Leak
ïï3 7
)
ïï7 8
;
ïï8 9
return
ññ 
base
ññ 
.
ññ 
SetMediumLE
ññ #
(
ññ# $
index
ññ$ )
,
ññ) *
value
ññ+ 0
)
ññ0 1
;
ññ1 2
}
óó 	
public
ôô 
override
ôô 
IByteBuffer
ôô #
	SetLongLE
ôô$ -
(
ôô- .
int
ôô. 1
index
ôô2 7
,
ôô7 8
long
ôô9 =
value
ôô> C
)
ôôC D
{
öö 	/
!RecordLeakNonRefCountingOperation
õõ -
(
õõ- .
this
õõ. 2
.
õõ2 3
Leak
õõ3 7
)
õõ7 8
;
õõ8 9
return
úú 
base
úú 
.
úú 
	SetLongLE
úú !
(
úú! "
index
úú" '
,
úú' (
value
úú) .
)
úú. /
;
úú/ 0
}
ùù 	
public
üü 
override
üü 
short
üü 
ReadShortLE
üü )
(
üü) *
)
üü* +
{
†† 	/
!RecordLeakNonRefCountingOperation
°° -
(
°°- .
this
°°. 2
.
°°2 3
Leak
°°3 7
)
°°7 8
;
°°8 9
return
¢¢ 
base
¢¢ 
.
¢¢ 
ReadShortLE
¢¢ #
(
¢¢# $
)
¢¢$ %
;
¢¢% &
}
££ 	
public
•• 
override
•• 
int
•• "
ReadUnsignedMediumLE
•• 0
(
••0 1
)
••1 2
{
¶¶ 	/
!RecordLeakNonRefCountingOperation
ßß -
(
ßß- .
this
ßß. 2
.
ßß2 3
Leak
ßß3 7
)
ßß7 8
;
ßß8 9
return
®® 
base
®® 
.
®® "
ReadUnsignedMediumLE
®® ,
(
®®, -
)
®®- .
;
®®. /
}
©© 	
public
´´ 
override
´´ 
int
´´ 
	ReadIntLE
´´ %
(
´´% &
)
´´& '
{
¨¨ 	/
!RecordLeakNonRefCountingOperation
≠≠ -
(
≠≠- .
this
≠≠. 2
.
≠≠2 3
Leak
≠≠3 7
)
≠≠7 8
;
≠≠8 9
return
ÆÆ 
base
ÆÆ 
.
ÆÆ 
	ReadIntLE
ÆÆ !
(
ÆÆ! "
)
ÆÆ" #
;
ÆÆ# $
}
ØØ 	
public
±± 
override
±± 
long
±± 

ReadLongLE
±± '
(
±±' (
)
±±( )
{
≤≤ 	/
!RecordLeakNonRefCountingOperation
≥≥ -
(
≥≥- .
this
≥≥. 2
.
≥≥2 3
Leak
≥≥3 7
)
≥≥7 8
;
≥≥8 9
return
¥¥ 
base
¥¥ 
.
¥¥ 

ReadLongLE
¥¥ "
(
¥¥" #
)
¥¥# $
;
¥¥$ %
}
µµ 	
public
∑∑ 
override
∑∑ 
IByteBuffer
∑∑ #
WriteShortLE
∑∑$ 0
(
∑∑0 1
int
∑∑1 4
value
∑∑5 :
)
∑∑: ;
{
∏∏ 	/
!RecordLeakNonRefCountingOperation
ππ -
(
ππ- .
this
ππ. 2
.
ππ2 3
Leak
ππ3 7
)
ππ7 8
;
ππ8 9
return
∫∫ 
base
∫∫ 
.
∫∫ 
WriteShortLE
∫∫ $
(
∫∫$ %
value
∫∫% *
)
∫∫* +
;
∫∫+ ,
}
ªª 	
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
WriteMediumLE
ΩΩ$ 1
(
ΩΩ1 2
int
ΩΩ2 5
value
ΩΩ6 ;
)
ΩΩ; <
{
ææ 	/
!RecordLeakNonRefCountingOperation
øø -
(
øø- .
this
øø. 2
.
øø2 3
Leak
øø3 7
)
øø7 8
;
øø8 9
return
¿¿ 
base
¿¿ 
.
¿¿ 
WriteMediumLE
¿¿ %
(
¿¿% &
value
¿¿& +
)
¿¿+ ,
;
¿¿, -
}
¡¡ 	
public
√√ 
override
√√ 
IByteBuffer
√√ #

WriteIntLE
√√$ .
(
√√. /
int
√√/ 2
value
√√3 8
)
√√8 9
{
ƒƒ 	/
!RecordLeakNonRefCountingOperation
≈≈ -
(
≈≈- .
this
≈≈. 2
.
≈≈2 3
Leak
≈≈3 7
)
≈≈7 8
;
≈≈8 9
return
∆∆ 
base
∆∆ 
.
∆∆ 

WriteIntLE
∆∆ "
(
∆∆" #
value
∆∆# (
)
∆∆( )
;
∆∆) *
}
«« 	
public
…… 
override
…… 
IByteBuffer
…… #
WriteLongLE
……$ /
(
……/ 0
long
……0 4
value
……5 :
)
……: ;
{
   	/
!RecordLeakNonRefCountingOperation
ÀÀ -
(
ÀÀ- .
this
ÀÀ. 2
.
ÀÀ2 3
Leak
ÀÀ3 7
)
ÀÀ7 8
;
ÀÀ8 9
return
ÃÃ 
base
ÃÃ 
.
ÃÃ 
WriteLongLE
ÃÃ #
(
ÃÃ# $
value
ÃÃ$ )
)
ÃÃ) *
;
ÃÃ* +
}
ÕÕ 	
public
œœ 
override
œœ 
IByteBuffer
œœ #
GetBytes
œœ$ ,
(
œœ, -
int
œœ- 0
index
œœ1 6
,
œœ6 7
Stream
œœ8 >
destination
œœ? J
,
œœJ K
int
œœL O
length
œœP V
)
œœV W
{
–– 	/
!RecordLeakNonRefCountingOperation
—— -
(
——- .
this
——. 2
.
——2 3
Leak
——3 7
)
——7 8
;
——8 9
return
““ 
base
““ 
.
““ 
GetBytes
““  
(
““  !
index
““! &
,
““& '
destination
““( 3
,
““3 4
length
““5 ;
)
““; <
;
““< =
}
”” 	
public
’’ 
override
’’ !
CompositeByteBuffer
’’ +
AddComponent
’’, 8
(
’’8 9
bool
’’9 =!
increaseWriterIndex
’’> Q
,
’’Q R
IByteBuffer
’’S ^
buffer
’’_ e
)
’’e f
{
÷÷ 	/
!RecordLeakNonRefCountingOperation
◊◊ -
(
◊◊- .
this
◊◊. 2
.
◊◊2 3
Leak
◊◊3 7
)
◊◊7 8
;
◊◊8 9
return
ÿÿ 
base
ÿÿ 
.
ÿÿ 
AddComponent
ÿÿ $
(
ÿÿ$ %!
increaseWriterIndex
ÿÿ% 8
,
ÿÿ8 9
buffer
ÿÿ: @
)
ÿÿ@ A
;
ÿÿA B
}
ŸŸ 	
public
€€ 
override
€€ !
CompositeByteBuffer
€€ +
AddComponent
€€, 8
(
€€8 9
bool
€€9 =!
increaseWriterIndex
€€> Q
,
€€Q R
int
€€S V
cIndex
€€W ]
,
€€] ^
IByteBuffer
€€_ j
buffer
€€k q
)
€€q r
{
‹‹ 	/
!RecordLeakNonRefCountingOperation
›› -
(
››- .
this
››. 2
.
››2 3
Leak
››3 7
)
››7 8
;
››8 9
return
ﬁﬁ 
base
ﬁﬁ 
.
ﬁﬁ 
AddComponent
ﬁﬁ $
(
ﬁﬁ$ %!
increaseWriterIndex
ﬁﬁ% 8
,
ﬁﬁ8 9
cIndex
ﬁﬁ: @
,
ﬁﬁ@ A
buffer
ﬁﬁB H
)
ﬁﬁH I
;
ﬁﬁI J
}
ﬂﬂ 	
public
·· 
override
·· !
CompositeByteBuffer
·· +
AddComponent
··, 8
(
··8 9
IByteBuffer
··9 D
buffer
··E K
)
··K L
{
‚‚ 	/
!RecordLeakNonRefCountingOperation
„„ -
(
„„- .
this
„„. 2
.
„„2 3
Leak
„„3 7
)
„„7 8
;
„„8 9
return
‰‰ 
base
‰‰ 
.
‰‰ 
AddComponent
‰‰ $
(
‰‰$ %
buffer
‰‰% +
)
‰‰+ ,
;
‰‰, -
}
ÂÂ 	
public
ÁÁ 
override
ÁÁ !
CompositeByteBuffer
ÁÁ +
AddComponent
ÁÁ, 8
(
ÁÁ8 9
int
ÁÁ9 <
cIndex
ÁÁ= C
,
ÁÁC D
IByteBuffer
ÁÁE P
buffer
ÁÁQ W
)
ÁÁW X
{
ËË 	/
!RecordLeakNonRefCountingOperation
ÈÈ -
(
ÈÈ- .
this
ÈÈ. 2
.
ÈÈ2 3
Leak
ÈÈ3 7
)
ÈÈ7 8
;
ÈÈ8 9
return
ÍÍ 
base
ÍÍ 
.
ÍÍ 
AddComponent
ÍÍ $
(
ÍÍ$ %
cIndex
ÍÍ% +
,
ÍÍ+ ,
buffer
ÍÍ- 3
)
ÍÍ3 4
;
ÍÍ4 5
}
ÎÎ 	
public
ÌÌ 
override
ÌÌ !
CompositeByteBuffer
ÌÌ +
AddComponents
ÌÌ, 9
(
ÌÌ9 :
bool
ÌÌ: >!
increaseWriterIndex
ÌÌ? R
,
ÌÌR S
params
ÌÌT Z
IByteBuffer
ÌÌ[ f
[
ÌÌf g
]
ÌÌg h
buffers
ÌÌi p
)
ÌÌp q
{
ÓÓ 	/
!RecordLeakNonRefCountingOperation
ÔÔ -
(
ÔÔ- .
this
ÔÔ. 2
.
ÔÔ2 3
Leak
ÔÔ3 7
)
ÔÔ7 8
;
ÔÔ8 9
return
 
base
 
.
 
AddComponents
 %
(
% &!
increaseWriterIndex
& 9
,
9 :
buffers
; B
)
B C
;
C D
}
ÒÒ 	
public
ÛÛ 
override
ÛÛ !
CompositeByteBuffer
ÛÛ +
AddComponents
ÛÛ, 9
(
ÛÛ9 :
bool
ÛÛ: >!
increaseWriterIndex
ÛÛ? R
,
ÛÛR S
IEnumerable
ÛÛT _
<
ÛÛ_ `
IByteBuffer
ÛÛ` k
>
ÛÛk l
buffers
ÛÛm t
)
ÛÛt u
{
ÙÙ 	/
!RecordLeakNonRefCountingOperation
ıı -
(
ıı- .
this
ıı. 2
.
ıı2 3
Leak
ıı3 7
)
ıı7 8
;
ıı8 9
return
ˆˆ 
base
ˆˆ 
.
ˆˆ 
AddComponents
ˆˆ %
(
ˆˆ% &!
increaseWriterIndex
ˆˆ& 9
,
ˆˆ9 :
buffers
ˆˆ; B
)
ˆˆB C
;
ˆˆC D
}
˜˜ 	
public
˘˘ 
override
˘˘ !
CompositeByteBuffer
˘˘ +
AddComponents
˘˘, 9
(
˘˘9 :
IEnumerable
˘˘: E
<
˘˘E F
IByteBuffer
˘˘F Q
>
˘˘Q R
buffers
˘˘S Z
)
˘˘Z [
{
˙˙ 	/
!RecordLeakNonRefCountingOperation
˚˚ -
(
˚˚- .
this
˚˚. 2
.
˚˚2 3
Leak
˚˚3 7
)
˚˚7 8
;
˚˚8 9
return
¸¸ 
base
¸¸ 
.
¸¸ 
AddComponents
¸¸ %
(
¸¸% &
buffers
¸¸& -
)
¸¸- .
;
¸¸. /
}
˝˝ 	
public
ˇˇ 
override
ˇˇ !
CompositeByteBuffer
ˇˇ +
AddComponents
ˇˇ, 9
(
ˇˇ9 :
int
ˇˇ: =
cIndex
ˇˇ> D
,
ˇˇD E
IEnumerable
ˇˇF Q
<
ˇˇQ R
IByteBuffer
ˇˇR ]
>
ˇˇ] ^
buffers
ˇˇ_ f
)
ˇˇf g
{
ÄÄ 	/
!RecordLeakNonRefCountingOperation
ÅÅ -
(
ÅÅ- .
this
ÅÅ. 2
.
ÅÅ2 3
Leak
ÅÅ3 7
)
ÅÅ7 8
;
ÅÅ8 9
return
ÇÇ 
base
ÇÇ 
.
ÇÇ 
AddComponents
ÇÇ %
(
ÇÇ% &
cIndex
ÇÇ& ,
,
ÇÇ, -
buffers
ÇÇ. 5
)
ÇÇ5 6
;
ÇÇ6 7
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ !
CompositeByteBuffer
ÖÖ +
AddComponents
ÖÖ, 9
(
ÖÖ9 :
int
ÖÖ: =
cIndex
ÖÖ> D
,
ÖÖD E
params
ÖÖF L
IByteBuffer
ÖÖM X
[
ÖÖX Y
]
ÖÖY Z
buffers
ÖÖ[ b
)
ÖÖb c
{
ÜÜ 	/
!RecordLeakNonRefCountingOperation
áá -
(
áá- .
this
áá. 2
.
áá2 3
Leak
áá3 7
)
áá7 8
;
áá8 9
return
àà 
base
àà 
.
àà 
AddComponents
àà %
(
àà% &
cIndex
àà& ,
,
àà, -
buffers
àà. 5
)
àà5 6
;
àà6 7
}
ââ 	
public
ãã 
override
ãã !
CompositeByteBuffer
ãã +
AddComponents
ãã, 9
(
ãã9 :
params
ãã: @
IByteBuffer
ããA L
[
ããL M
]
ããM N
buffers
ããO V
)
ããV W
{
åå 	/
!RecordLeakNonRefCountingOperation
çç -
(
çç- .
this
çç. 2
.
çç2 3
Leak
çç3 7
)
çç7 8
;
çç8 9
return
éé 
base
éé 
.
éé 
AddComponents
éé %
(
éé% &
buffers
éé& -
)
éé- .
;
éé. /
}
èè 	
public
ëë 
override
ëë !
CompositeByteBuffer
ëë +
RemoveComponent
ëë, ;
(
ëë; <
int
ëë< ?
cIndex
ëë@ F
)
ëëF G
{
íí 	/
!RecordLeakNonRefCountingOperation
ìì -
(
ìì- .
this
ìì. 2
.
ìì2 3
Leak
ìì3 7
)
ìì7 8
;
ìì8 9
return
îî 
base
îî 
.
îî 
RemoveComponent
îî '
(
îî' (
cIndex
îî( .
)
îî. /
;
îî/ 0
}
ïï 	
public
óó 
override
óó !
CompositeByteBuffer
óó +
RemoveComponents
óó, <
(
óó< =
int
óó= @
cIndex
óóA G
,
óóG H
int
óóI L
numComponents
óóM Z
)
óóZ [
{
òò 	/
!RecordLeakNonRefCountingOperation
ôô -
(
ôô- .
this
ôô. 2
.
ôô2 3
Leak
ôô3 7
)
ôô7 8
;
ôô8 9
return
öö 
base
öö 
.
öö 
RemoveComponents
öö (
(
öö( )
cIndex
öö) /
,
öö/ 0
numComponents
öö1 >
)
öö> ?
;
öö? @
}
õõ 	
public
ùù 
override
ùù !
CompositeByteBuffer
ùù +
Consolidate
ùù, 7
(
ùù7 8
)
ùù8 9
{
ûû 	/
!RecordLeakNonRefCountingOperation
üü -
(
üü- .
this
üü. 2
.
üü2 3
Leak
üü3 7
)
üü7 8
;
üü8 9
return
†† 
base
†† 
.
†† 
Consolidate
†† #
(
††# $
)
††$ %
;
††% &
}
°° 	
public
££ 
override
££ !
CompositeByteBuffer
££ +
Consolidate
££, 7
(
££7 8
int
££8 ;
cIndex
££< B
,
££B C
int
££D G
numComponents
££H U
)
££U V
{
§§ 	/
!RecordLeakNonRefCountingOperation
•• -
(
••- .
this
••. 2
.
••2 3
Leak
••3 7
)
••7 8
;
••8 9
return
¶¶ 
base
¶¶ 
.
¶¶ 
Consolidate
¶¶ #
(
¶¶# $
cIndex
¶¶$ *
,
¶¶* +
numComponents
¶¶, 9
)
¶¶9 :
;
¶¶: ;
}
ßß 	
public
©© 
override
©© !
CompositeByteBuffer
©© +#
DiscardReadComponents
©©, A
(
©©A B
)
©©B C
{
™™ 	/
!RecordLeakNonRefCountingOperation
´´ -
(
´´- .
this
´´. 2
.
´´2 3
Leak
´´3 7
)
´´7 8
;
´´8 9
return
¨¨ 
base
¨¨ 
.
¨¨ #
DiscardReadComponents
¨¨ -
(
¨¨- .
)
¨¨. /
;
¨¨/ 0
}
≠≠ 	
public
ØØ 
override
ØØ 
IList
ØØ 
<
ØØ 
IByteBuffer
ØØ )
>
ØØ) *
	Decompose
ØØ+ 4
(
ØØ4 5
int
ØØ5 8
offset
ØØ9 ?
,
ØØ? @
int
ØØA D
length
ØØE K
)
ØØK L
{
∞∞ 	/
!RecordLeakNonRefCountingOperation
±± -
(
±±- .
this
±±. 2
.
±±2 3
Leak
±±3 7
)
±±7 8
;
±±8 9
return
≤≤ 
base
≤≤ 
.
≤≤ 
	Decompose
≤≤ !
(
≤≤! "
offset
≤≤" (
,
≤≤( )
length
≤≤* 0
)
≤≤0 1
;
≤≤1 2
}
≥≥ 	
public
µµ 
override
µµ 
ICharSequence
µµ %
GetCharSequence
µµ& 5
(
µµ5 6
int
µµ6 9
index
µµ: ?
,
µµ? @
int
µµA D
length
µµE K
,
µµK L
Encoding
µµM U
encoding
µµV ^
)
µµ^ _
{
∂∂ 	/
!RecordLeakNonRefCountingOperation
∑∑ -
(
∑∑- .
this
∑∑. 2
.
∑∑2 3
Leak
∑∑3 7
)
∑∑7 8
;
∑∑8 9
return
∏∏ 
base
∏∏ 
.
∏∏ 
GetCharSequence
∏∏ '
(
∏∏' (
index
∏∏( -
,
∏∏- .
length
∏∏/ 5
,
∏∏5 6
encoding
∏∏7 ?
)
∏∏? @
;
∏∏@ A
}
ππ 	
public
ªª 
override
ªª 
ICharSequence
ªª %
ReadCharSequence
ªª& 6
(
ªª6 7
int
ªª7 :
length
ªª; A
,
ªªA B
Encoding
ªªC K
encoding
ªªL T
)
ªªT U
{
ºº 	/
!RecordLeakNonRefCountingOperation
ΩΩ -
(
ΩΩ- .
this
ΩΩ. 2
.
ΩΩ2 3
Leak
ΩΩ3 7
)
ΩΩ7 8
;
ΩΩ8 9
return
ææ 
base
ææ 
.
ææ 
ReadCharSequence
ææ (
(
ææ( )
length
ææ) /
,
ææ/ 0
encoding
ææ1 9
)
ææ9 :
;
ææ: ;
}
øø 	
public
¡¡ 
override
¡¡ 
int
¡¡ 
SetCharSequence
¡¡ +
(
¡¡+ ,
int
¡¡, /
index
¡¡0 5
,
¡¡5 6
ICharSequence
¡¡7 D
sequence
¡¡E M
,
¡¡M N
Encoding
¡¡O W
encoding
¡¡X `
)
¡¡` a
{
¬¬ 	/
!RecordLeakNonRefCountingOperation
√√ -
(
√√- .
this
√√. 2
.
√√2 3
Leak
√√3 7
)
√√7 8
;
√√8 9
return
ƒƒ 
base
ƒƒ 
.
ƒƒ 
SetCharSequence
ƒƒ '
(
ƒƒ' (
index
ƒƒ( -
,
ƒƒ- .
sequence
ƒƒ/ 7
,
ƒƒ7 8
encoding
ƒƒ9 A
)
ƒƒA B
;
ƒƒB C
}
≈≈ 	
public
«« 
override
«« 
int
«« 
WriteCharSequence
«« -
(
««- .
ICharSequence
««. ;
sequence
««< D
,
««D E
Encoding
««F N
encoding
««O W
)
««W X
{
»» 	/
!RecordLeakNonRefCountingOperation
…… -
(
……- .
this
……. 2
.
……2 3
Leak
……3 7
)
……7 8
;
……8 9
return
   
base
   
.
   
WriteCharSequence
   )
(
  ) *
sequence
  * 2
,
  2 3
encoding
  4 <
)
  < =
;
  = >
}
ÀÀ 	
public
ÕÕ 
override
ÕÕ 
string
ÕÕ 
	GetString
ÕÕ (
(
ÕÕ( )
int
ÕÕ) ,
index
ÕÕ- 2
,
ÕÕ2 3
int
ÕÕ4 7
length
ÕÕ8 >
,
ÕÕ> ?
Encoding
ÕÕ@ H
encoding
ÕÕI Q
)
ÕÕQ R
{
ŒŒ 	/
!RecordLeakNonRefCountingOperation
œœ -
(
œœ- .
this
œœ. 2
.
œœ2 3
Leak
œœ3 7
)
œœ7 8
;
œœ8 9
return
–– 
base
–– 
.
–– 
	GetString
–– !
(
––! "
index
––" '
,
––' (
length
––) /
,
––/ 0
encoding
––1 9
)
––9 :
;
––: ;
}
—— 	
public
”” 
override
”” 
string
”” 

ReadString
”” )
(
””) *
int
””* -
length
””. 4
,
””4 5
Encoding
””6 >
encoding
””? G
)
””G H
{
‘‘ 	/
!RecordLeakNonRefCountingOperation
’’ -
(
’’- .
this
’’. 2
.
’’2 3
Leak
’’3 7
)
’’7 8
;
’’8 9
return
÷÷ 
base
÷÷ 
.
÷÷ 

ReadString
÷÷ "
(
÷÷" #
length
÷÷# )
,
÷÷) *
encoding
÷÷+ 3
)
÷÷3 4
;
÷÷4 5
}
◊◊ 	
public
ŸŸ 
override
ŸŸ 
int
ŸŸ 
	SetString
ŸŸ %
(
ŸŸ% &
int
ŸŸ& )
index
ŸŸ* /
,
ŸŸ/ 0
string
ŸŸ1 7
value
ŸŸ8 =
,
ŸŸ= >
Encoding
ŸŸ? G
encoding
ŸŸH P
)
ŸŸP Q
{
⁄⁄ 	/
!RecordLeakNonRefCountingOperation
€€ -
(
€€- .
this
€€. 2
.
€€2 3
Leak
€€3 7
)
€€7 8
;
€€8 9
return
‹‹ 
base
‹‹ 
.
‹‹ 
	SetString
‹‹ !
(
‹‹! "
index
‹‹" '
,
‹‹' (
value
‹‹) .
,
‹‹. /
encoding
‹‹0 8
)
‹‹8 9
;
‹‹9 :
}
›› 	
public
ﬂﬂ 
override
ﬂﬂ 
int
ﬂﬂ 
WriteString
ﬂﬂ '
(
ﬂﬂ' (
string
ﬂﬂ( .
value
ﬂﬂ/ 4
,
ﬂﬂ4 5
Encoding
ﬂﬂ6 >
encoding
ﬂﬂ? G
)
ﬂﬂG H
{
‡‡ 	/
!RecordLeakNonRefCountingOperation
·· -
(
··- .
this
··. 2
.
··2 3
Leak
··3 7
)
··7 8
;
··8 9
return
‚‚ 
base
‚‚ 
.
‚‚ 
WriteString
‚‚ #
(
‚‚# $
value
‚‚$ )
,
‚‚) *
encoding
‚‚+ 3
)
‚‚3 4
;
‚‚4 5
}
„„ 	
public
ÂÂ 
override
ÂÂ 
IEnumerator
ÂÂ #
<
ÂÂ# $
IByteBuffer
ÂÂ$ /
>
ÂÂ/ 0
GetEnumerator
ÂÂ1 >
(
ÂÂ> ?
)
ÂÂ? @
{
ÊÊ 	/
!RecordLeakNonRefCountingOperation
ÁÁ -
(
ÁÁ- .
this
ÁÁ. 2
.
ÁÁ2 3
Leak
ÁÁ3 7
)
ÁÁ7 8
;
ÁÁ8 9
return
ËË 
base
ËË 
.
ËË 
GetEnumerator
ËË %
(
ËË% &
)
ËË& '
;
ËË' (
}
ÈÈ 	
public
ÎÎ 
override
ÎÎ 
IReferenceCounted
ÎÎ )
Retain
ÎÎ* 0
(
ÎÎ0 1
)
ÎÎ1 2
{
ÏÏ 	
this
ÌÌ 
.
ÌÌ 
Leak
ÌÌ 
.
ÌÌ 
Record
ÌÌ 
(
ÌÌ 
)
ÌÌ 
;
ÌÌ 
return
ÓÓ 
base
ÓÓ 
.
ÓÓ 
Retain
ÓÓ 
(
ÓÓ 
)
ÓÓ  
;
ÓÓ  !
}
ÔÔ 	
public
ÒÒ 
override
ÒÒ 
IReferenceCounted
ÒÒ )
Retain
ÒÒ* 0
(
ÒÒ0 1
int
ÒÒ1 4
	increment
ÒÒ5 >
)
ÒÒ> ?
{
ÚÚ 	
this
ÛÛ 
.
ÛÛ 
Leak
ÛÛ 
.
ÛÛ 
Record
ÛÛ 
(
ÛÛ 
)
ÛÛ 
;
ÛÛ 
return
ÙÙ 
base
ÙÙ 
.
ÙÙ 
Retain
ÙÙ 
(
ÙÙ 
	increment
ÙÙ (
)
ÙÙ( )
;
ÙÙ) *
}
ıı 	
public
˜˜ 
override
˜˜ 
IByteBuffer
˜˜ #
RetainedSlice
˜˜$ 1
(
˜˜1 2
)
˜˜2 3
{
¯¯ 	/
!RecordLeakNonRefCountingOperation
˘˘ -
(
˘˘- .
this
˘˘. 2
.
˘˘2 3
Leak
˘˘3 7
)
˘˘7 8
;
˘˘8 9
return
˙˙ 
base
˙˙ 
.
˙˙ 
RetainedSlice
˙˙ %
(
˙˙% &
)
˙˙& '
;
˙˙' (
}
˚˚ 	
public
˝˝ 
override
˝˝ 
IByteBuffer
˝˝ #
RetainedSlice
˝˝$ 1
(
˝˝1 2
int
˝˝2 5
index
˝˝6 ;
,
˝˝; <
int
˝˝= @
length
˝˝A G
)
˝˝G H
{
˛˛ 	/
!RecordLeakNonRefCountingOperation
ˇˇ -
(
ˇˇ- .
this
ˇˇ. 2
.
ˇˇ2 3
Leak
ˇˇ3 7
)
ˇˇ7 8
;
ˇˇ8 9
return
ÄÄ 
base
ÄÄ 
.
ÄÄ 
RetainedSlice
ÄÄ %
(
ÄÄ% &
index
ÄÄ& +
,
ÄÄ+ ,
length
ÄÄ- 3
)
ÄÄ3 4
;
ÄÄ4 5
}
ÅÅ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
RetainedDuplicate
ÉÉ$ 5
(
ÉÉ5 6
)
ÉÉ6 7
{
ÑÑ 	/
!RecordLeakNonRefCountingOperation
ÖÖ -
(
ÖÖ- .
this
ÖÖ. 2
.
ÖÖ2 3
Leak
ÖÖ3 7
)
ÖÖ7 8
;
ÖÖ8 9
return
ÜÜ 
base
ÜÜ 
.
ÜÜ 
RetainedDuplicate
ÜÜ )
(
ÜÜ) *
)
ÜÜ* +
;
ÜÜ+ ,
}
áá 	
public
ââ 
override
ââ 
IByteBuffer
ââ #
ReadRetainedSlice
ââ$ 5
(
ââ5 6
int
ââ6 9
length
ââ: @
)
ââ@ A
{
ää 	/
!RecordLeakNonRefCountingOperation
ãã -
(
ãã- .
this
ãã. 2
.
ãã2 3
Leak
ãã3 7
)
ãã7 8
;
ãã8 9
return
åå 
base
åå 
.
åå 
ReadRetainedSlice
åå )
(
åå) *
length
åå* 0
)
åå0 1
;
åå1 2
}
çç 	
public
èè 
override
èè 
bool
èè 
Release
èè $
(
èè$ %
)
èè% &
{
êê 	
this
ëë 
.
ëë 
Leak
ëë 
.
ëë 
Record
ëë 
(
ëë 
)
ëë 
;
ëë 
return
íí 
base
íí 
.
íí 
Release
íí 
(
íí  
)
íí  !
;
íí! "
}
ìì 	
public
ïï 
override
ïï 
bool
ïï 
Release
ïï $
(
ïï$ %
int
ïï% (
	decrement
ïï) 2
)
ïï2 3
{
ññ 	
this
óó 
.
óó 
Leak
óó 
.
óó 
Record
óó 
(
óó 
)
óó 
;
óó 
return
òò 
base
òò 
.
òò 
Release
òò 
(
òò  
	decrement
òò  )
)
òò) *
;
òò* +
}
ôô 	
public
õõ 
override
õõ 
IReferenceCounted
õõ )
Touch
õõ* /
(
õõ/ 0
)
õõ0 1
{
úú 	
this
ùù 
.
ùù 
Leak
ùù 
.
ùù 
Record
ùù 
(
ùù 
)
ùù 
;
ùù 
return
ûû 
this
ûû 
;
ûû 
}
üü 	
public
°° 
override
°° 
IReferenceCounted
°° )
Touch
°°* /
(
°°/ 0
object
°°0 6
hint
°°7 ;
)
°°; <
{
¢¢ 	
this
££ 
.
££ 
Leak
££ 
.
££ 
Record
££ 
(
££ 
hint
££ !
)
££! "
;
££" #
return
§§ 
this
§§ 
;
§§ 
}
•• 	
	protected
ßß 
override
ßß '
SimpleLeakAwareByteBuffer
ßß 4$
NewLeakAwareByteBuffer
ßß5 K
(
ßßK L
IByteBuffer
ßßL W
wrapped
ßßX _
,
ßß_ `
IByteBuffer
ßßa l
trackedByteBuf
ßßm {
,
ßß{ |#
IResourceLeakTrackerßß} ë
leakTrackerßßí ù
)ßßù û
=>ßßü °
new
®® )
AdvancedLeakAwareByteBuffer
®® +
(
®®+ ,
wrapped
®®, 3
,
®®3 4
trackedByteBuf
®®5 C
,
®®C D
leakTracker
®®E P
)
®®P Q
;
®®Q R
}
©© 
}™™ ¸ı
aC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

static 
class 
ByteBufferUtil &
{ 
const 
char 
WriteUtfUnknown "
=# $
$char% (
;( )
static 
readonly 
int 
MaxBytesPerCharUtf8 /
=0 1
Encoding2 :
.: ;
UTF8; ?
.? @
GetMaxByteCount@ O
(O P
$numP Q
)Q R
;R S
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
(R S
typeofS Y
(Y Z
ByteBufferUtilZ h
)h i
)i j
;j k
public 
static 
readonly  
IByteBufferAllocator 3
DefaultAllocator4 D
;D E
static 
ByteBufferUtil 
( 
) 
{ 	
string 
	allocType 
= 
SystemPropertyUtil 1
.1 2
Get2 5
(5 6
$str6 O
,O P
$strQ Y
)Y Z
;Z [
	allocType 
= 
	allocType !
.! "
Trim" &
(& '
)' (
;( ) 
IByteBufferAllocator  
alloc! &
;& '
if 
( 
$str 
. 
Equals !
(! "
	allocType" +
,+ ,
StringComparison- =
.= >
OrdinalIgnoreCase> O
)O P
)P Q
{ 
alloc 
= '
UnpooledByteBufferAllocator 3
.3 4
Default4 ;
;; <
Logger   
.   
Debug   
(   
$str   <
,  < =
	allocType  > G
)  G H
;  H I
}!! 
else"" 
if"" 
("" 
$str"" 
."" 
Equals"" $
(""$ %
	allocType""% .
,"". /
StringComparison""0 @
.""@ A
OrdinalIgnoreCase""A R
)""R S
)""S T
{## 
alloc$$ 
=$$ %
PooledByteBufferAllocator$$ 1
.$$1 2
Default$$2 9
;$$9 :
Logger%% 
.%% 
Debug%% 
(%% 
$str%% <
,%%< =
	allocType%%> G
)%%G H
;%%H I
}&& 
else'' 
{(( 
alloc)) 
=)) %
PooledByteBufferAllocator)) 1
.))1 2
Default))2 9
;))9 :
Logger** 
.** 
Debug** 
(** 
$str** N
,**N O
	allocType**P Y
)**Y Z
;**Z [
}++ 
DefaultAllocator-- 
=-- 
alloc-- $
;--$ %
}.. 	
public44 
static44 
string44 
HexDump44 $
(44$ %
IByteBuffer44% 0
buffer441 7
)447 8
=>449 ;
HexDump44< C
(44C D
buffer44D J
,44J K
buffer44L R
.44R S
ReaderIndex44S ^
,44^ _
buffer44` f
.44f g
ReadableBytes44g t
)44t u
;44u v
public:: 
static:: 
string:: 
HexDump:: $
(::$ %
IByteBuffer::% 0
buffer::1 7
,::7 8
int::9 <
	fromIndex::= F
,::F G
int::H K
length::L R
)::R S
=>::T V
HexUtil::W ^
.::^ _
	DoHexDump::_ h
(::h i
buffer::i o
,::o p
	fromIndex::q z
,::z {
length	::| Ç
)
::Ç É
;
::É Ñ
public@@ 
static@@ 
string@@ 
HexDump@@ $
(@@$ %
byte@@% )
[@@) *
]@@* +
array@@, 1
)@@1 2
=>@@3 5
HexDump@@6 =
(@@= >
array@@> C
,@@C D
$num@@E F
,@@F G
array@@H M
.@@M N
Length@@N T
)@@T U
;@@U V
publicFF 
staticFF 
stringFF 
HexDumpFF $
(FF$ %
byteFF% )
[FF) *
]FF* +
arrayFF, 1
,FF1 2
intFF3 6
	fromIndexFF7 @
,FF@ A
intFFB E
lengthFFF L
)FFL M
=>FFN P
HexUtilFFQ X
.FFX Y
	DoHexDumpFFY b
(FFb c
arrayFFc h
,FFh i
	fromIndexFFj s
,FFs t
lengthFFu {
)FF{ |
;FF| }
publicHH 
staticHH 
boolHH !
EnsureWritableSuccessHH 0
(HH0 1
intHH1 4 
ensureWritableResultHH5 I
)HHI J
=>HHK M 
ensureWritableResultHHN b
==HHc e
$numHHf g
||HHh j 
ensureWritableResultHHk 
==
HHÄ Ç
$num
HHÉ Ñ
;
HHÑ Ö
publicNN 
staticNN 
intNN 
HashCodeNN "
(NN" #
IByteBufferNN# .
bufferNN/ 5
)NN5 6
{OO 	
intPP 
aLenPP 
=PP 
bufferPP 
.PP 
ReadableBytesPP +
;PP+ ,
intQQ 
intCountQQ 
=QQ 
(QQ 
intQQ 
)QQ  
(QQ  !
(QQ! "
uintQQ" &
)QQ& '
aLenQQ' +
>>QQ, .
$numQQ/ 0
)QQ0 1
;QQ1 2
intRR 
	byteCountRR 
=RR 
aLenRR  
&RR! "
$numRR# $
;RR$ %
intTT 
hashCodeTT 
=TT 
$numTT 
;TT 
intUU 

arrayIndexUU 
=UU 
bufferUU #
.UU# $
ReaderIndexUU$ /
;UU/ 0
forVV 
(VV 
intVV 
iVV 
=VV 
intCountVV !
;VV! "
iVV# $
>VV% &
$numVV' (
;VV( )
iVV* +
--VV+ -
)VV- .
{WW 
hashCodeXX 
=XX 
$numXX 
*XX 
hashCodeXX  (
+XX) *
bufferXX+ 1
.XX1 2
GetIntXX2 8
(XX8 9

arrayIndexXX9 C
)XXC D
;XXD E

arrayIndexYY 
+=YY 
$numYY 
;YY  
}ZZ 
for\\ 
(\\ 
int\\ 
i\\ 
=\\ 
	byteCount\\ "
;\\" #
i\\$ %
>\\& '
$num\\( )
;\\) *
i\\+ ,
--\\, .
)\\. /
{]] 
hashCode^^ 
=^^ 
$num^^ 
*^^ 
hashCode^^  (
+^^) *
buffer^^+ 1
.^^1 2
GetByte^^2 9
(^^9 :

arrayIndex^^: D
++^^D F
)^^F G
;^^G H
}__ 
ifaa 
(aa 
hashCodeaa 
==aa 
$numaa 
)aa 
{bb 
hashCodecc 
=cc 
$numcc 
;cc 
}dd 
returnff 
hashCodeff 
;ff 
}gg 	
publicll 
staticll 
intll 
IndexOfll !
(ll! "
IByteBufferll" -
needlell. 4
,ll4 5
IByteBufferll6 A
haystackllB J
)llJ K
{mm 	
intoo 
attemptsoo 
=oo 
haystackoo #
.oo# $
ReadableBytesoo$ 1
-oo2 3
needleoo4 :
.oo: ;
ReadableBytesoo; H
+ooI J
$numooK L
;ooL M
forpp 
(pp 
intpp 
ipp 
=pp 
$numpp 
;pp 
ipp 
<pp 
attemptspp  (
;pp( )
ipp* +
++pp+ -
)pp- .
{qq 
ifrr 
(rr 
Equalsrr 
(rr 
needlerr !
,rr! "
needlerr# )
.rr) *
ReaderIndexrr* 5
,rr5 6
haystackrr7 ?
,rr? @
haystackrrA I
.rrI J
ReaderIndexrrJ U
+rrV W
irrX Y
,rrY Z
needlerr[ a
.rra b
ReadableBytesrrb o
)rro p
)rrp q
{ss 
returntt 
haystacktt #
.tt# $
ReaderIndextt$ /
+tt0 1
itt2 3
;tt3 4
}uu 
}vv 
returnxx 
-xx 
$numxx 
;xx 
}yy 	
public
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
Equals
ÉÉ !
(
ÉÉ! "
IByteBuffer
ÉÉ" -
a
ÉÉ. /
,
ÉÉ/ 0
int
ÉÉ1 4
aStartIndex
ÉÉ5 @
,
ÉÉ@ A
IByteBuffer
ÉÉB M
b
ÉÉN O
,
ÉÉO P
int
ÉÉQ T
bStartIndex
ÉÉU `
,
ÉÉ` a
int
ÉÉb e
length
ÉÉf l
)
ÉÉl m
{
ÑÑ 	
if
ÖÖ 
(
ÖÖ 
aStartIndex
ÖÖ 
<
ÖÖ 
$num
ÖÖ 
||
ÖÖ  "
bStartIndex
ÖÖ# .
<
ÖÖ/ 0
$num
ÖÖ1 2
||
ÖÖ3 5
length
ÖÖ6 <
<
ÖÖ= >
$num
ÖÖ? @
)
ÖÖ@ A
{
ÜÜ 
throw
áá 
new
áá 
ArgumentException
áá +
(
áá+ ,
$str
áá, Z
)
ááZ [
;
áá[ \
}
àà 
if
ââ 
(
ââ 
a
ââ 
.
ââ 
WriterIndex
ââ 
-
ââ 
length
ââ  &
<
ââ' (
aStartIndex
ââ) 4
||
ââ5 7
b
ââ8 9
.
ââ9 :
WriterIndex
ââ: E
-
ââF G
length
ââH N
<
ââO P
bStartIndex
ââQ \
)
ââ\ ]
{
ää 
return
ãã 
false
ãã 
;
ãã 
}
åå 
int
éé 
	longCount
éé 
=
éé 
	unchecked
éé %
(
éé% &
(
éé& '
int
éé' *
)
éé* +
(
éé+ ,
(
éé, -
uint
éé- 1
)
éé1 2
length
éé2 8
>>
éé9 ;
$num
éé< =
)
éé= >
)
éé> ?
;
éé? @
int
èè 
	byteCount
èè 
=
èè 
length
èè "
&
èè# $
$num
èè% &
;
èè& '
for
ëë 
(
ëë 
int
ëë 
i
ëë 
=
ëë 
	longCount
ëë "
;
ëë" #
i
ëë$ %
>
ëë& '
$num
ëë( )
;
ëë) *
i
ëë+ ,
--
ëë, .
)
ëë. /
{
íí 
if
ìì 
(
ìì 
a
ìì 
.
ìì 
GetLong
ìì 
(
ìì 
aStartIndex
ìì )
)
ìì) *
!=
ìì+ -
b
ìì. /
.
ìì/ 0
GetLong
ìì0 7
(
ìì7 8
bStartIndex
ìì8 C
)
ììC D
)
ììD E
{
îî 
return
ïï 
false
ïï  
;
ïï  !
}
ññ 
aStartIndex
óó 
+=
óó 
$num
óó  
;
óó  !
bStartIndex
òò 
+=
òò 
$num
òò  
;
òò  !
}
ôô 
for
õõ 
(
õõ 
int
õõ 
i
õõ 
=
õõ 
	byteCount
õõ "
;
õõ" #
i
õõ$ %
>
õõ& '
$num
õõ( )
;
õõ) *
i
õõ+ ,
--
õõ, .
)
õõ. /
{
úú 
if
ùù 
(
ùù 
a
ùù 
.
ùù 
GetByte
ùù 
(
ùù 
aStartIndex
ùù )
)
ùù) *
!=
ùù+ -
b
ùù. /
.
ùù/ 0
GetByte
ùù0 7
(
ùù7 8
bStartIndex
ùù8 C
)
ùùC D
)
ùùD E
{
ûû 
return
üü 
false
üü  
;
üü  !
}
†† 
aStartIndex
°° 
++
°° 
;
°° 
bStartIndex
¢¢ 
++
¢¢ 
;
¢¢ 
}
££ 
return
•• 
true
•• 
;
•• 
}
¶¶ 	
public
≠≠ 
static
≠≠ 
bool
≠≠ 
Equals
≠≠ !
(
≠≠! "
IByteBuffer
≠≠" -
bufferA
≠≠. 5
,
≠≠5 6
IByteBuffer
≠≠7 B
bufferB
≠≠C J
)
≠≠J K
{
ÆÆ 	
int
ØØ 
aLen
ØØ 
=
ØØ 
bufferA
ØØ 
.
ØØ 
ReadableBytes
ØØ ,
;
ØØ, -
if
∞∞ 
(
∞∞ 
aLen
∞∞ 
!=
∞∞ 
bufferB
∞∞ 
.
∞∞  
ReadableBytes
∞∞  -
)
∞∞- .
{
±± 
return
≤≤ 
false
≤≤ 
;
≤≤ 
}
≥≥ 
return
µµ 
Equals
µµ 
(
µµ 
bufferA
µµ !
,
µµ! "
bufferA
µµ# *
.
µµ* +
ReaderIndex
µµ+ 6
,
µµ6 7
bufferB
µµ8 ?
,
µµ? @
bufferB
µµA H
.
µµH I
ReaderIndex
µµI T
,
µµT U
aLen
µµV Z
)
µµZ [
;
µµ[ \
}
∂∂ 	
public
ºº 
static
ºº 
int
ºº 
Compare
ºº !
(
ºº! "
IByteBuffer
ºº" -
bufferA
ºº. 5
,
ºº5 6
IByteBuffer
ºº7 B
bufferB
ººC J
)
ººJ K
{
ΩΩ 	
int
ææ 
aLen
ææ 
=
ææ 
bufferA
ææ 
.
ææ 
ReadableBytes
ææ ,
;
ææ, -
int
øø 
bLen
øø 
=
øø 
bufferB
øø 
.
øø 
ReadableBytes
øø ,
;
øø, -
int
¿¿ 
	minLength
¿¿ 
=
¿¿ 
Math
¿¿  
.
¿¿  !
Min
¿¿! $
(
¿¿$ %
aLen
¿¿% )
,
¿¿) *
bLen
¿¿+ /
)
¿¿/ 0
;
¿¿0 1
int
¡¡ 
	uintCount
¡¡ 
=
¡¡ 
	minLength
¡¡ %
.
¡¡% &
RightUShift
¡¡& 1
(
¡¡1 2
$num
¡¡2 3
)
¡¡3 4
;
¡¡4 5
int
¬¬ 
	byteCount
¬¬ 
=
¬¬ 
	minLength
¬¬ %
&
¬¬& '
$num
¬¬( )
;
¬¬) *
int
ƒƒ 
aIndex
ƒƒ 
=
ƒƒ 
bufferA
ƒƒ  
.
ƒƒ  !
ReaderIndex
ƒƒ! ,
;
ƒƒ, -
int
≈≈ 
bIndex
≈≈ 
=
≈≈ 
bufferB
≈≈  
.
≈≈  !
ReaderIndex
≈≈! ,
;
≈≈, -
if
«« 
(
«« 
	uintCount
«« 
>
«« 
$num
«« 
)
«« 
{
»» 
int
……  
uintCountIncrement
…… &
=
……' (
	uintCount
……) 2
<<
……3 5
$num
……6 7
;
……7 8
int
   
res
   
=
   
CompareUint
   %
(
  % &
bufferA
  & -
,
  - .
bufferB
  / 6
,
  6 7
aIndex
  8 >
,
  > ?
bIndex
  @ F
,
  F G 
uintCountIncrement
  H Z
)
  Z [
;
  [ \
if
ÀÀ 
(
ÀÀ 
res
ÀÀ 
!=
ÀÀ 
$num
ÀÀ 
)
ÀÀ 
{
ÃÃ 
return
ÕÕ 
res
ÕÕ 
;
ÕÕ 
}
ŒŒ 
aIndex
–– 
+=
––  
uintCountIncrement
–– ,
;
––, -
bIndex
—— 
+=
——  
uintCountIncrement
—— ,
;
——, -
}
““ 
for
‘‘ 
(
‘‘ 
int
‘‘ 
aEnd
‘‘ 
=
‘‘ 
aIndex
‘‘ "
+
‘‘# $
	byteCount
‘‘% .
;
‘‘. /
aIndex
‘‘0 6
<
‘‘7 8
aEnd
‘‘9 =
;
‘‘= >
++
‘‘? A
aIndex
‘‘A G
,
‘‘G H
++
‘‘I K
bIndex
‘‘K Q
)
‘‘Q R
{
’’ 
int
÷÷ 
comp
÷÷ 
=
÷÷ 
bufferA
÷÷ "
.
÷÷" #
GetByte
÷÷# *
(
÷÷* +
aIndex
÷÷+ 1
)
÷÷1 2
-
÷÷3 4
bufferB
÷÷5 <
.
÷÷< =
GetByte
÷÷= D
(
÷÷D E
bIndex
÷÷E K
)
÷÷K L
;
÷÷L M
if
◊◊ 
(
◊◊ 
comp
◊◊ 
!=
◊◊ 
$num
◊◊ 
)
◊◊ 
{
ÿÿ 
return
ŸŸ 
comp
ŸŸ 
;
ŸŸ  
}
⁄⁄ 
}
€€ 
return
›› 
aLen
›› 
-
›› 
bLen
›› 
;
›› 
}
ﬁﬁ 	
static
‡‡ 
int
‡‡ 
CompareUint
‡‡ 
(
‡‡ 
IByteBuffer
‡‡ *
bufferA
‡‡+ 2
,
‡‡2 3
IByteBuffer
‡‡4 ?
bufferB
‡‡@ G
,
‡‡G H
int
‡‡I L
aIndex
‡‡M S
,
‡‡S T
int
‡‡U X
bIndex
‡‡Y _
,
‡‡_ `
int
‡‡a d 
uintCountIncrement
‡‡e w
)
‡‡w x
{
·· 	
for
‚‚ 
(
‚‚ 
int
‚‚ 
aEnd
‚‚ 
=
‚‚ 
aIndex
‚‚ "
+
‚‚# $ 
uintCountIncrement
‚‚% 7
;
‚‚7 8
aIndex
‚‚9 ?
<
‚‚@ A
aEnd
‚‚B F
;
‚‚F G
aIndex
‚‚H N
+=
‚‚O Q
$num
‚‚R S
,
‚‚S T
bIndex
‚‚U [
+=
‚‚\ ^
$num
‚‚_ `
)
‚‚` a
{
„„ 
long
‰‰ 
va
‰‰ 
=
‰‰ 
bufferA
‰‰ !
.
‰‰! "
GetUnsignedInt
‰‰" 0
(
‰‰0 1
aIndex
‰‰1 7
)
‰‰7 8
;
‰‰8 9
long
ÂÂ 
vb
ÂÂ 
=
ÂÂ 
bufferB
ÂÂ !
.
ÂÂ! "
GetUnsignedInt
ÂÂ" 0
(
ÂÂ0 1
bIndex
ÂÂ1 7
)
ÂÂ7 8
;
ÂÂ8 9
if
ÊÊ 
(
ÊÊ 
va
ÊÊ 
>
ÊÊ 
vb
ÊÊ 
)
ÊÊ 
{
ÁÁ 
return
ËË 
$num
ËË 
;
ËË 
}
ÈÈ 
if
ÍÍ 
(
ÍÍ 
va
ÍÍ 
<
ÍÍ 
vb
ÍÍ 
)
ÍÍ 
{
ÎÎ 
return
ÏÏ 
-
ÏÏ 
$num
ÏÏ 
;
ÏÏ 
}
ÌÌ 
}
ÓÓ 
return
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
}
 	
public
ˆˆ 
static
ˆˆ 
int
ˆˆ 
IndexOf
ˆˆ !
(
ˆˆ! "
IByteBuffer
ˆˆ" -
buffer
ˆˆ. 4
,
ˆˆ4 5
int
ˆˆ6 9
	fromIndex
ˆˆ: C
,
ˆˆC D
int
ˆˆE H
toIndex
ˆˆI P
,
ˆˆP Q
byte
ˆˆR V
value
ˆˆW \
)
ˆˆ\ ]
{
˜˜ 	
if
¯¯ 
(
¯¯ 
	fromIndex
¯¯ 
<=
¯¯ 
toIndex
¯¯ $
)
¯¯$ %
{
˘˘ 
return
˙˙ 
FirstIndexOf
˙˙ #
(
˙˙# $
buffer
˙˙$ *
,
˙˙* +
	fromIndex
˙˙, 5
,
˙˙5 6
toIndex
˙˙7 >
,
˙˙> ?
value
˙˙@ E
)
˙˙E F
;
˙˙F G
}
˚˚ 
else
¸¸ 
{
˝˝ 
return
˛˛ 
LastIndexOf
˛˛ "
(
˛˛" #
buffer
˛˛# )
,
˛˛) *
	fromIndex
˛˛+ 4
,
˛˛4 5
toIndex
˛˛6 =
,
˛˛= >
value
˛˛? D
)
˛˛D E
;
˛˛E F
}
ˇˇ 
}
ÄÄ 	
public
ÖÖ 
static
ÖÖ 
IByteBuffer
ÖÖ !
	ReadBytes
ÖÖ" +
(
ÖÖ+ ,"
IByteBufferAllocator
ÖÖ, @
alloc
ÖÖA F
,
ÖÖF G
IByteBuffer
ÖÖH S
buffer
ÖÖT Z
,
ÖÖZ [
int
ÖÖ\ _
length
ÖÖ` f
)
ÖÖf g
{
ÜÜ 	
bool
áá 
release
áá 
=
áá 
true
áá 
;
áá  
IByteBuffer
àà 
dst
àà 
=
àà 
alloc
àà #
.
àà# $
Buffer
àà$ *
(
àà* +
length
àà+ 1
)
àà1 2
;
àà2 3
try
ââ 
{
ää 
buffer
ãã 
.
ãã 
	ReadBytes
ãã  
(
ãã  !
dst
ãã! $
)
ãã$ %
;
ãã% &
release
åå 
=
åå 
false
åå 
;
åå  
return
çç 
dst
çç 
;
çç 
}
éé 
finally
èè 
{
êê 
if
ëë 
(
ëë 
release
ëë 
)
ëë 
{
íí 
dst
ìì 
.
ìì 
Release
ìì 
(
ìì  
)
ìì  !
;
ìì! "
}
îî 
}
ïï 
}
ññ 	
static
òò 
int
òò 
FirstIndexOf
òò 
(
òò  
IByteBuffer
òò  +
buffer
òò, 2
,
òò2 3
int
òò4 7
	fromIndex
òò8 A
,
òòA B
int
òòC F
toIndex
òòG N
,
òòN O
byte
òòP T
value
òòU Z
)
òòZ [
{
ôô 	
	fromIndex
öö 
=
öö 
Math
öö 
.
öö 
Max
öö  
(
öö  !
	fromIndex
öö! *
,
öö* +
$num
öö, -
)
öö- .
;
öö. /
if
õõ 
(
õõ 
	fromIndex
õõ 
>=
õõ 
toIndex
õõ $
||
õõ% '
buffer
õõ( .
.
õõ. /
Capacity
õõ/ 7
==
õõ8 :
$num
õõ; <
)
õõ< =
{
úú 
return
ùù 
-
ùù 
$num
ùù 
;
ùù 
}
ûû 
return
†† 
buffer
†† 
.
†† 
ForEachByte
†† %
(
††% &
	fromIndex
††& /
,
††/ 0
toIndex
††1 8
-
††9 :
	fromIndex
††; D
,
††D E
new
††F I
IndexOfProcessor
††J Z
(
††Z [
value
††[ `
)
††` a
)
††a b
;
††b c
}
°° 	
static
££ 
int
££ 
LastIndexOf
££ 
(
££ 
IByteBuffer
££ *
buffer
££+ 1
,
££1 2
int
££3 6
	fromIndex
££7 @
,
££@ A
int
££B E
toIndex
££F M
,
££M N
byte
££O S
value
££T Y
)
££Y Z
{
§§ 	
	fromIndex
•• 
=
•• 
Math
•• 
.
•• 
Min
••  
(
••  !
	fromIndex
••! *
,
••* +
buffer
••, 2
.
••2 3
Capacity
••3 ;
)
••; <
;
••< =
if
¶¶ 
(
¶¶ 
	fromIndex
¶¶ 
<
¶¶ 
$num
¶¶ 
||
¶¶  
buffer
¶¶! '
.
¶¶' (
Capacity
¶¶( 0
==
¶¶1 3
$num
¶¶4 5
)
¶¶5 6
{
ßß 
return
®® 
-
®® 
$num
®® 
;
®® 
}
©© 
return
´´ 
buffer
´´ 
.
´´ 
ForEachByteDesc
´´ )
(
´´) *
toIndex
´´* 1
,
´´1 2
	fromIndex
´´3 <
-
´´= >
toIndex
´´? F
,
´´F G
new
´´H K
IndexOfProcessor
´´L \
(
´´\ ]
value
´´] b
)
´´b c
)
´´c d
;
´´d e
}
¨¨ 	
public
ÆÆ 
static
ÆÆ 
IByteBuffer
ÆÆ !
	WriteUtf8
ÆÆ" +
(
ÆÆ+ ,"
IByteBufferAllocator
ÆÆ, @
alloc
ÆÆA F
,
ÆÆF G
ICharSequence
ÆÆH U
seq
ÆÆV Y
)
ÆÆY Z
{
ØØ 	
IByteBuffer
±± 
buf
±± 
=
±± 
alloc
±± #
.
±±# $
Buffer
±±$ *
(
±±* +
Utf8MaxBytes
±±+ 7
(
±±7 8
seq
±±8 ;
)
±±; <
)
±±< =
;
±±= >
	WriteUtf8
≤≤ 
(
≤≤ 
buf
≤≤ 
,
≤≤ 
seq
≤≤ 
)
≤≤ 
;
≤≤  
return
≥≥ 
buf
≥≥ 
;
≥≥ 
}
¥¥ 	
public
∂∂ 
static
∂∂ 
int
∂∂ 
	WriteUtf8
∂∂ #
(
∂∂# $
IByteBuffer
∂∂$ /
buf
∂∂0 3
,
∂∂3 4
ICharSequence
∂∂5 B
seq
∂∂C F
)
∂∂F G
=>
∂∂H J!
ReserveAndWriteUtf8
∂∂K ^
(
∂∂^ _
buf
∂∂_ b
,
∂∂b c
seq
∂∂d g
,
∂∂g h
Utf8MaxBytes
∂∂i u
(
∂∂u v
seq
∂∂v y
)
∂∂y z
)
∂∂z {
;
∂∂{ |
public
∏∏ 
static
∏∏ 
int
∏∏ !
ReserveAndWriteUtf8
∏∏ -
(
∏∏- .
IByteBuffer
∏∏. 9
buf
∏∏: =
,
∏∏= >
ICharSequence
∏∏? L
seq
∏∏M P
,
∏∏P Q
int
∏∏R U
reserveBytes
∏∏V b
)
∏∏b c
{
ππ 	
for
∫∫ 
(
∫∫ 
;
∫∫ 
;
∫∫ 
)
∫∫ 
{
ªª 
if
ºº 
(
ºº 
buf
ºº 
is
ºº  
AbstractByteBuffer
ºº -
byteBuf
ºº. 5
)
ºº5 6
{
ΩΩ 
byteBuf
ææ 
.
ææ 
EnsureWritable0
ææ +
(
ææ+ ,
reserveBytes
ææ, 8
)
ææ8 9
;
ææ9 :
int
øø 
written
øø 
=
øø  !
	WriteUtf8
øø" +
(
øø+ ,
byteBuf
øø, 3
,
øø3 4
byteBuf
øø5 <
.
øø< =
WriterIndex
øø= H
,
øøH I
seq
øøJ M
,
øøM N
seq
øøO R
.
øøR S
Count
øøS X
)
øøX Y
;
øøY Z
byteBuf
¿¿ 
.
¿¿ 
SetWriterIndex
¿¿ *
(
¿¿* +
byteBuf
¿¿+ 2
.
¿¿2 3
WriterIndex
¿¿3 >
+
¿¿? @
written
¿¿A H
)
¿¿H I
;
¿¿I J
return
¡¡ 
written
¡¡ "
;
¡¡" #
}
¬¬ 
else
√√ 
if
√√ 
(
√√ 
buf
√√ 
is
√√ 
WrappedByteBuffer
√√  1
)
√√1 2
{
ƒƒ 
buf
∆∆ 
=
∆∆ 
buf
∆∆ 
.
∆∆ 
Unwrap
∆∆ $
(
∆∆$ %
)
∆∆% &
;
∆∆& '
}
«« 
else
»» 
{
…… 
byte
   
[
   
]
   
bytes
    
=
  ! "
Encoding
  # +
.
  + ,
UTF8
  , 0
.
  0 1
GetBytes
  1 9
(
  9 :
seq
  : =
.
  = >
ToString
  > F
(
  F G
)
  G H
)
  H I
;
  I J
buf
ÀÀ 
.
ÀÀ 

WriteBytes
ÀÀ "
(
ÀÀ" #
bytes
ÀÀ# (
)
ÀÀ( )
;
ÀÀ) *
return
ÃÃ 
bytes
ÃÃ  
.
ÃÃ  !
Length
ÃÃ! '
;
ÃÃ' (
}
ÕÕ 
}
ŒŒ 
}
œœ 	
internal
““ 
static
““ 
int
““ 
	WriteUtf8
““ %
(
““% & 
AbstractByteBuffer
““& 8
buffer
““9 ?
,
““? @
int
““A D
writerIndex
““E P
,
““P Q
ICharSequence
““R _
value
““` e
,
““e f
int
““g j
len
““k n
)
““n o
{
”” 	
int
‘‘ 
oldWriterIndex
‘‘ 
=
‘‘  
writerIndex
‘‘! ,
;
‘‘, -
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
i
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
i
ÿÿ 
<
ÿÿ 
len
ÿÿ  #
;
ÿÿ# $
i
ÿÿ% &
++
ÿÿ& (
)
ÿÿ( )
{
ŸŸ 
char
⁄⁄ 
c
⁄⁄ 
=
⁄⁄ 
value
⁄⁄ 
[
⁄⁄ 
i
⁄⁄  
]
⁄⁄  !
;
⁄⁄! "
if
€€ 
(
€€ 
c
€€ 
<
€€ 
$num
€€ 
)
€€ 
{
‹‹ 
buffer
›› 
.
›› 
_SetByte
›› #
(
››# $
writerIndex
››$ /
++
››/ 1
,
››1 2
(
››3 4
byte
››4 8
)
››8 9
c
››9 :
)
››: ;
;
››; <
}
ﬁﬁ 
else
ﬂﬂ 
if
ﬂﬂ 
(
ﬂﬂ 
c
ﬂﬂ 
<
ﬂﬂ 
$num
ﬂﬂ "
)
ﬂﬂ" #
{
‡‡ 
buffer
·· 
.
·· 
_SetByte
·· #
(
··# $
writerIndex
··$ /
++
··/ 1
,
··1 2
(
··3 4
byte
··4 8
)
··8 9
(
··9 :
$num
··: >
|
··? @
(
··A B
c
··B C
>>
··D F
$num
··G H
)
··H I
)
··I J
)
··J K
;
··K L
buffer
‚‚ 
.
‚‚ 
_SetByte
‚‚ #
(
‚‚# $
writerIndex
‚‚$ /
++
‚‚/ 1
,
‚‚1 2
(
‚‚3 4
byte
‚‚4 8
)
‚‚8 9
(
‚‚9 :
$num
‚‚: >
|
‚‚? @
(
‚‚A B
c
‚‚B C
&
‚‚D E
$num
‚‚F J
)
‚‚J K
)
‚‚K L
)
‚‚L M
;
‚‚M N
}
„„ 
else
‰‰ 
if
‰‰ 
(
‰‰ 
char
‰‰ 
.
‰‰ 
IsSurrogate
‰‰ )
(
‰‰) *
c
‰‰* +
)
‰‰+ ,
)
‰‰, -
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
char
ÊÊ 
.
ÊÊ 
IsHighSurrogate
ÊÊ -
(
ÊÊ- .
c
ÊÊ. /
)
ÊÊ/ 0
)
ÊÊ0 1
{
ÁÁ 
buffer
ËË 
.
ËË 
_SetByte
ËË '
(
ËË' (
writerIndex
ËË( 3
++
ËË3 5
,
ËË5 6
WriteUtfUnknown
ËË7 F
)
ËËF G
;
ËËG H
continue
ÈÈ  
;
ÈÈ  !
}
ÍÍ 
char
ÎÎ 
c2
ÎÎ 
;
ÎÎ 
try
ÏÏ 
{
ÌÌ 
c2
ÒÒ 
=
ÒÒ 
value
ÒÒ "
[
ÒÒ" #
++
ÒÒ# %
i
ÒÒ% &
]
ÒÒ& '
;
ÒÒ' (
}
ÚÚ 
catch
ÛÛ 
(
ÛÛ &
IndexOutOfRangeException
ÛÛ 3
)
ÛÛ3 4
{
ÙÙ 
buffer
ıı 
.
ıı 
_SetByte
ıı '
(
ıı' (
writerIndex
ıı( 3
++
ıı3 5
,
ıı5 6
WriteUtfUnknown
ıı7 F
)
ııF G
;
ııG H
break
ˆˆ 
;
ˆˆ 
}
˜˜ 
if
¯¯ 
(
¯¯ 
!
¯¯ 
char
¯¯ 
.
¯¯ 
IsLowSurrogate
¯¯ ,
(
¯¯, -
c2
¯¯- /
)
¯¯/ 0
)
¯¯0 1
{
˘˘ 
buffer
˙˙ 
.
˙˙ 
_SetByte
˙˙ '
(
˙˙' (
writerIndex
˙˙( 3
++
˙˙3 5
,
˙˙5 6
WriteUtfUnknown
˙˙7 F
)
˙˙F G
;
˙˙G H
buffer
˚˚ 
.
˚˚ 
_SetByte
˚˚ '
(
˚˚' (
writerIndex
˚˚( 3
++
˚˚3 5
,
˚˚5 6
char
˚˚7 ;
.
˚˚; <
IsHighSurrogate
˚˚< K
(
˚˚K L
c2
˚˚L N
)
˚˚N O
?
˚˚P Q
WriteUtfUnknown
˚˚R a
:
˚˚b c
c2
˚˚d f
)
˚˚f g
;
˚˚g h
continue
¸¸  
;
¸¸  !
}
˝˝ 
int
˛˛ 
	codePoint
˛˛ !
=
˛˛" #
CharUtil
˛˛$ ,
.
˛˛, -
ToCodePoint
˛˛- 8
(
˛˛8 9
c
˛˛9 :
,
˛˛: ;
c2
˛˛< >
)
˛˛> ?
;
˛˛? @
buffer
ÄÄ 
.
ÄÄ 
_SetByte
ÄÄ #
(
ÄÄ# $
writerIndex
ÄÄ$ /
++
ÄÄ/ 1
,
ÄÄ1 2
(
ÄÄ3 4
byte
ÄÄ4 8
)
ÄÄ8 9
(
ÄÄ9 :
$num
ÄÄ: >
|
ÄÄ? @
(
ÄÄA B
	codePoint
ÄÄB K
>>
ÄÄL N
$num
ÄÄO Q
)
ÄÄQ R
)
ÄÄR S
)
ÄÄS T
;
ÄÄT U
buffer
ÅÅ 
.
ÅÅ 
_SetByte
ÅÅ #
(
ÅÅ# $
writerIndex
ÅÅ$ /
++
ÅÅ/ 1
,
ÅÅ1 2
(
ÅÅ3 4
byte
ÅÅ4 8
)
ÅÅ8 9
(
ÅÅ9 :
$num
ÅÅ: >
|
ÅÅ? @
(
ÅÅA B
(
ÅÅB C
	codePoint
ÅÅC L
>>
ÅÅM O
$num
ÅÅP R
)
ÅÅR S
&
ÅÅT U
$num
ÅÅV Z
)
ÅÅZ [
)
ÅÅ[ \
)
ÅÅ\ ]
;
ÅÅ] ^
buffer
ÇÇ 
.
ÇÇ 
_SetByte
ÇÇ #
(
ÇÇ# $
writerIndex
ÇÇ$ /
++
ÇÇ/ 1
,
ÇÇ1 2
(
ÇÇ3 4
byte
ÇÇ4 8
)
ÇÇ8 9
(
ÇÇ9 :
$num
ÇÇ: >
|
ÇÇ? @
(
ÇÇA B
(
ÇÇB C
	codePoint
ÇÇC L
>>
ÇÇM O
$num
ÇÇP Q
)
ÇÇQ R
&
ÇÇS T
$num
ÇÇU Y
)
ÇÇY Z
)
ÇÇZ [
)
ÇÇ[ \
;
ÇÇ\ ]
buffer
ÉÉ 
.
ÉÉ 
_SetByte
ÉÉ #
(
ÉÉ# $
writerIndex
ÉÉ$ /
++
ÉÉ/ 1
,
ÉÉ1 2
(
ÉÉ3 4
byte
ÉÉ4 8
)
ÉÉ8 9
(
ÉÉ9 :
$num
ÉÉ: >
|
ÉÉ? @
(
ÉÉA B
	codePoint
ÉÉB K
&
ÉÉL M
$num
ÉÉN R
)
ÉÉR S
)
ÉÉS T
)
ÉÉT U
;
ÉÉU V
}
ÑÑ 
else
ÖÖ 
{
ÜÜ 
buffer
áá 
.
áá 
_SetByte
áá #
(
áá# $
writerIndex
áá$ /
++
áá/ 1
,
áá1 2
(
áá3 4
byte
áá4 8
)
áá8 9
(
áá9 :
$num
áá: >
|
áá? @
(
ááA B
c
ááB C
>>
ááD F
$num
ááG I
)
ááI J
)
ááJ K
)
ááK L
;
ááL M
buffer
àà 
.
àà 
_SetByte
àà #
(
àà# $
writerIndex
àà$ /
++
àà/ 1
,
àà1 2
(
àà3 4
byte
àà4 8
)
àà8 9
(
àà9 :
$num
àà: >
|
àà? @
(
ààA B
(
ààB C
c
ààC D
>>
ààE G
$num
ààH I
)
ààI J
&
ààK L
$num
ààM Q
)
ààQ R
)
ààR S
)
ààS T
;
ààT U
buffer
ââ 
.
ââ 
_SetByte
ââ #
(
ââ# $
writerIndex
ââ$ /
++
ââ/ 1
,
ââ1 2
(
ââ3 4
byte
ââ4 8
)
ââ8 9
(
ââ9 :
$num
ââ: >
|
ââ? @
(
ââA B
c
ââB C
&
ââD E
$num
ââF J
)
ââJ K
)
ââK L
)
ââL M
;
ââM N
}
ää 
}
ãã 
return
çç 
writerIndex
çç 
-
çç  
oldWriterIndex
çç! /
;
çç/ 0
}
éé 	
public
êê 
static
êê 
IByteBuffer
êê !
	WriteUtf8
êê" +
(
êê+ ,"
IByteBufferAllocator
êê, @
alloc
êêA F
,
êêF G
string
êêH N
value
êêO T
)
êêT U
{
ëë 	
IByteBuffer
ìì 
buf
ìì 
=
ìì 
alloc
ìì #
.
ìì# $
Buffer
ìì$ *
(
ìì* +
Utf8MaxBytes
ìì+ 7
(
ìì7 8
value
ìì8 =
)
ìì= >
)
ìì> ?
;
ìì? @
	WriteUtf8
îî 
(
îî 
buf
îî 
,
îî 
value
îî  
)
îî  !
;
îî! "
return
ïï 
buf
ïï 
;
ïï 
}
ññ 	
public
òò 
static
òò 
int
òò 
	WriteUtf8
òò #
(
òò# $
IByteBuffer
òò$ /
buf
òò0 3
,
òò3 4
string
òò5 ;
seq
òò< ?
)
òò? @
=>
òòA C!
ReserveAndWriteUtf8
òòD W
(
òòW X
buf
òòX [
,
òò[ \
seq
òò] `
,
òò` a
Utf8MaxBytes
òòb n
(
òòn o
seq
òòo r
)
òòr s
)
òòs t
;
òòt u
public
°° 
static
°° 
int
°° !
ReserveAndWriteUtf8
°° -
(
°°- .
IByteBuffer
°°. 9
buf
°°: =
,
°°= >
string
°°? E
value
°°F K
,
°°K L
int
°°M P
reserveBytes
°°Q ]
)
°°] ^
{
¢¢ 	
for
££ 
(
££ 
;
££ 
;
££ 
)
££ 
{
§§ 
if
•• 
(
•• 
buf
•• 
is
••  
AbstractByteBuffer
•• -
byteBuf
••. 5
)
••5 6
{
¶¶ 
byteBuf
ßß 
.
ßß 
EnsureWritable0
ßß +
(
ßß+ ,
reserveBytes
ßß, 8
)
ßß8 9
;
ßß9 :
int
®® 
written
®® 
=
®®  !
	WriteUtf8
®®" +
(
®®+ ,
byteBuf
®®, 3
,
®®3 4
byteBuf
®®5 <
.
®®< =
WriterIndex
®®= H
,
®®H I
value
®®J O
,
®®O P
value
®®Q V
.
®®V W
Length
®®W ]
)
®®] ^
;
®®^ _
byteBuf
©© 
.
©© 
SetWriterIndex
©© *
(
©©* +
byteBuf
©©+ 2
.
©©2 3
WriterIndex
©©3 >
+
©©? @
written
©©A H
)
©©H I
;
©©I J
return
™™ 
written
™™ "
;
™™" #
}
´´ 
else
¨¨ 
if
¨¨ 
(
¨¨ 
buf
¨¨ 
is
¨¨ 
WrappedByteBuffer
¨¨  1
)
¨¨1 2
{
≠≠ 
buf
ØØ 
=
ØØ 
buf
ØØ 
.
ØØ 
Unwrap
ØØ $
(
ØØ$ %
)
ØØ% &
;
ØØ& '
}
∞∞ 
else
±± 
{
≤≤ 
byte
≥≥ 
[
≥≥ 
]
≥≥ 
bytes
≥≥  
=
≥≥! "
Encoding
≥≥# +
.
≥≥+ ,
UTF8
≥≥, 0
.
≥≥0 1
GetBytes
≥≥1 9
(
≥≥9 :
value
≥≥: ?
)
≥≥? @
;
≥≥@ A
buf
¥¥ 
.
¥¥ 

WriteBytes
¥¥ "
(
¥¥" #
bytes
¥¥# (
)
¥¥( )
;
¥¥) *
return
µµ 
bytes
µµ  
.
µµ  !
Length
µµ! '
;
µµ' (
}
∂∂ 
}
∑∑ 
}
∏∏ 	
internal
ªª 
static
ªª 
int
ªª 
	WriteUtf8
ªª %
(
ªª% & 
AbstractByteBuffer
ªª& 8
buffer
ªª9 ?
,
ªª? @
int
ªªA D
writerIndex
ªªE P
,
ªªP Q
string
ªªR X
value
ªªY ^
,
ªª^ _
int
ªª` c
len
ªªd g
)
ªªg h
{
ºº 	
int
ΩΩ 
oldWriterIndex
ΩΩ 
=
ΩΩ  
writerIndex
ΩΩ! ,
;
ΩΩ, -
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡ 
<
¡¡ 
len
¡¡  #
;
¡¡# $
i
¡¡% &
++
¡¡& (
)
¡¡( )
{
¬¬ 
char
√√ 
c
√√ 
=
√√ 
value
√√ 
[
√√ 
i
√√  
]
√√  !
;
√√! "
if
ƒƒ 
(
ƒƒ 
c
ƒƒ 
<
ƒƒ 
$num
ƒƒ 
)
ƒƒ 
{
≈≈ 
buffer
∆∆ 
.
∆∆ 
_SetByte
∆∆ #
(
∆∆# $
writerIndex
∆∆$ /
++
∆∆/ 1
,
∆∆1 2
(
∆∆3 4
byte
∆∆4 8
)
∆∆8 9
c
∆∆9 :
)
∆∆: ;
;
∆∆; <
}
«« 
else
»» 
if
»» 
(
»» 
c
»» 
<
»» 
$num
»» "
)
»»" #
{
…… 
buffer
   
.
   
_SetByte
   #
(
  # $
writerIndex
  $ /
++
  / 1
,
  1 2
(
  3 4
byte
  4 8
)
  8 9
(
  9 :
$num
  : >
|
  ? @
(
  A B
c
  B C
>>
  D F
$num
  G H
)
  H I
)
  I J
)
  J K
;
  K L
buffer
ÀÀ 
.
ÀÀ 
_SetByte
ÀÀ #
(
ÀÀ# $
writerIndex
ÀÀ$ /
++
ÀÀ/ 1
,
ÀÀ1 2
(
ÀÀ3 4
byte
ÀÀ4 8
)
ÀÀ8 9
(
ÀÀ9 :
$num
ÀÀ: >
|
ÀÀ? @
(
ÀÀA B
c
ÀÀB C
&
ÀÀD E
$num
ÀÀF J
)
ÀÀJ K
)
ÀÀK L
)
ÀÀL M
;
ÀÀM N
}
ÃÃ 
else
ÕÕ 
if
ÕÕ 
(
ÕÕ 
char
ÕÕ 
.
ÕÕ 
IsSurrogate
ÕÕ )
(
ÕÕ) *
c
ÕÕ* +
)
ÕÕ+ ,
)
ÕÕ, -
{
ŒŒ 
if
œœ 
(
œœ 
!
œœ 
char
œœ 
.
œœ 
IsHighSurrogate
œœ -
(
œœ- .
c
œœ. /
)
œœ/ 0
)
œœ0 1
{
–– 
buffer
—— 
.
—— 
_SetByte
—— '
(
——' (
writerIndex
——( 3
++
——3 5
,
——5 6
WriteUtfUnknown
——7 F
)
——F G
;
——G H
continue
““  
;
““  !
}
”” 
char
‘‘ 
c2
‘‘ 
;
‘‘ 
try
’’ 
{
÷÷ 
c2
⁄⁄ 
=
⁄⁄ 
value
⁄⁄ "
[
⁄⁄" #
++
⁄⁄# %
i
⁄⁄% &
]
⁄⁄& '
;
⁄⁄' (
}
€€ 
catch
‹‹ 
(
‹‹ &
IndexOutOfRangeException
‹‹ 3
)
‹‹3 4
{
›› 
buffer
ﬁﬁ 
.
ﬁﬁ 
_SetByte
ﬁﬁ '
(
ﬁﬁ' (
writerIndex
ﬁﬁ( 3
++
ﬁﬁ3 5
,
ﬁﬁ5 6
WriteUtfUnknown
ﬁﬁ7 F
)
ﬁﬁF G
;
ﬁﬁG H
break
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
if
·· 
(
·· 
!
·· 
char
·· 
.
·· 
IsLowSurrogate
·· ,
(
··, -
c2
··- /
)
··/ 0
)
··0 1
{
‚‚ 
buffer
„„ 
.
„„ 
_SetByte
„„ '
(
„„' (
writerIndex
„„( 3
++
„„3 5
,
„„5 6
WriteUtfUnknown
„„7 F
)
„„F G
;
„„G H
buffer
‰‰ 
.
‰‰ 
_SetByte
‰‰ '
(
‰‰' (
writerIndex
‰‰( 3
++
‰‰3 5
,
‰‰5 6
char
‰‰7 ;
.
‰‰; <
IsHighSurrogate
‰‰< K
(
‰‰K L
c2
‰‰L N
)
‰‰N O
?
‰‰P Q
WriteUtfUnknown
‰‰R a
:
‰‰b c
c2
‰‰d f
)
‰‰f g
;
‰‰g h
continue
ÂÂ  
;
ÂÂ  !
}
ÊÊ 
int
ÁÁ 
	codePoint
ÁÁ !
=
ÁÁ" #
CharUtil
ÁÁ$ ,
.
ÁÁ, -
ToCodePoint
ÁÁ- 8
(
ÁÁ8 9
c
ÁÁ9 :
,
ÁÁ: ;
c2
ÁÁ< >
)
ÁÁ> ?
;
ÁÁ? @
buffer
ÈÈ 
.
ÈÈ 
_SetByte
ÈÈ #
(
ÈÈ# $
writerIndex
ÈÈ$ /
++
ÈÈ/ 1
,
ÈÈ1 2
(
ÈÈ3 4
byte
ÈÈ4 8
)
ÈÈ8 9
(
ÈÈ9 :
$num
ÈÈ: >
|
ÈÈ? @
(
ÈÈA B
	codePoint
ÈÈB K
>>
ÈÈL N
$num
ÈÈO Q
)
ÈÈQ R
)
ÈÈR S
)
ÈÈS T
;
ÈÈT U
buffer
ÍÍ 
.
ÍÍ 
_SetByte
ÍÍ #
(
ÍÍ# $
writerIndex
ÍÍ$ /
++
ÍÍ/ 1
,
ÍÍ1 2
(
ÍÍ3 4
byte
ÍÍ4 8
)
ÍÍ8 9
(
ÍÍ9 :
$num
ÍÍ: >
|
ÍÍ? @
(
ÍÍA B
(
ÍÍB C
	codePoint
ÍÍC L
>>
ÍÍM O
$num
ÍÍP R
)
ÍÍR S
&
ÍÍT U
$num
ÍÍV Z
)
ÍÍZ [
)
ÍÍ[ \
)
ÍÍ\ ]
;
ÍÍ] ^
buffer
ÎÎ 
.
ÎÎ 
_SetByte
ÎÎ #
(
ÎÎ# $
writerIndex
ÎÎ$ /
++
ÎÎ/ 1
,
ÎÎ1 2
(
ÎÎ3 4
byte
ÎÎ4 8
)
ÎÎ8 9
(
ÎÎ9 :
$num
ÎÎ: >
|
ÎÎ? @
(
ÎÎA B
(
ÎÎB C
	codePoint
ÎÎC L
>>
ÎÎM O
$num
ÎÎP Q
)
ÎÎQ R
&
ÎÎS T
$num
ÎÎU Y
)
ÎÎY Z
)
ÎÎZ [
)
ÎÎ[ \
;
ÎÎ\ ]
buffer
ÏÏ 
.
ÏÏ 
_SetByte
ÏÏ #
(
ÏÏ# $
writerIndex
ÏÏ$ /
++
ÏÏ/ 1
,
ÏÏ1 2
(
ÏÏ3 4
byte
ÏÏ4 8
)
ÏÏ8 9
(
ÏÏ9 :
$num
ÏÏ: >
|
ÏÏ? @
(
ÏÏA B
	codePoint
ÏÏB K
&
ÏÏL M
$num
ÏÏN R
)
ÏÏR S
)
ÏÏS T
)
ÏÏT U
;
ÏÏU V
}
ÌÌ 
else
ÓÓ 
{
ÔÔ 
buffer
 
.
 
_SetByte
 #
(
# $
writerIndex
$ /
++
/ 1
,
1 2
(
3 4
byte
4 8
)
8 9
(
9 :
$num
: >
|
? @
(
A B
c
B C
>>
D F
$num
G I
)
I J
)
J K
)
K L
;
L M
buffer
ÒÒ 
.
ÒÒ 
_SetByte
ÒÒ #
(
ÒÒ# $
writerIndex
ÒÒ$ /
++
ÒÒ/ 1
,
ÒÒ1 2
(
ÒÒ3 4
byte
ÒÒ4 8
)
ÒÒ8 9
(
ÒÒ9 :
$num
ÒÒ: >
|
ÒÒ? @
(
ÒÒA B
(
ÒÒB C
c
ÒÒC D
>>
ÒÒE G
$num
ÒÒH I
)
ÒÒI J
&
ÒÒK L
$num
ÒÒM Q
)
ÒÒQ R
)
ÒÒR S
)
ÒÒS T
;
ÒÒT U
buffer
ÚÚ 
.
ÚÚ 
_SetByte
ÚÚ #
(
ÚÚ# $
writerIndex
ÚÚ$ /
++
ÚÚ/ 1
,
ÚÚ1 2
(
ÚÚ3 4
byte
ÚÚ4 8
)
ÚÚ8 9
(
ÚÚ9 :
$num
ÚÚ: >
|
ÚÚ? @
(
ÚÚA B
c
ÚÚB C
&
ÚÚD E
$num
ÚÚF J
)
ÚÚJ K
)
ÚÚK L
)
ÚÚL M
;
ÚÚM N
}
ÛÛ 
}
ÙÙ 
return
ˆˆ 
writerIndex
ˆˆ 
-
ˆˆ  
oldWriterIndex
ˆˆ! /
;
ˆˆ/ 0
}
˜˜ 	
internal
˘˘ 
static
˘˘ 
int
˘˘ 
Utf8MaxBytes
˘˘ (
(
˘˘( )
ICharSequence
˘˘) 6
seq
˘˘7 :
)
˘˘: ;
=>
˘˘< >
Utf8MaxBytes
˘˘? K
(
˘˘K L
seq
˘˘L O
.
˘˘O P
Count
˘˘P U
)
˘˘U V
;
˘˘V W
public
˚˚ 
static
˚˚ 
int
˚˚ 
Utf8MaxBytes
˚˚ &
(
˚˚& '
string
˚˚' -
seq
˚˚. 1
)
˚˚1 2
=>
˚˚3 5
Utf8MaxBytes
˚˚6 B
(
˚˚B C
seq
˚˚C F
.
˚˚F G
Length
˚˚G M
)
˚˚M N
;
˚˚N O
internal
˝˝ 
static
˝˝ 
int
˝˝ 
Utf8MaxBytes
˝˝ (
(
˝˝( )
int
˝˝) ,
	seqLength
˝˝- 6
)
˝˝6 7
=>
˝˝8 :
	seqLength
˝˝; D
*
˝˝E F!
MaxBytesPerCharUtf8
˝˝G Z
;
˝˝Z [
internal
ˇˇ 
static
ˇˇ 
int
ˇˇ 
	Utf8Bytes
ˇˇ %
(
ˇˇ% &
string
ˇˇ& ,
seq
ˇˇ- 0
)
ˇˇ0 1
{
ÄÄ 	
int
ÅÅ 
	seqLength
ÅÅ 
=
ÅÅ 
seq
ÅÅ 
.
ÅÅ  
Length
ÅÅ  &
;
ÅÅ& '
int
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
while
ÑÑ 
(
ÑÑ 
i
ÑÑ 
<
ÑÑ 
	seqLength
ÑÑ  
&&
ÑÑ! #
seq
ÑÑ$ '
[
ÑÑ' (
i
ÑÑ( )
]
ÑÑ) *
<
ÑÑ+ ,
$num
ÑÑ- 1
)
ÑÑ1 2
{
ÖÖ 
++
ÜÜ 
i
ÜÜ 
;
ÜÜ 
}
áá 
return
ââ 
i
ââ 
<
ââ 
	seqLength
ââ  
?
ââ! "
i
ââ# $
+
ââ% &
	Utf8Bytes
ââ' 0
(
ââ0 1
seq
ââ1 4
,
ââ4 5
i
ââ6 7
,
ââ7 8
	seqLength
ââ9 B
)
ââB C
:
ââD E
i
ââF G
;
ââG H
}
ää 	
static
åå 
int
åå 
	Utf8Bytes
åå 
(
åå 
string
åå #
seq
åå$ '
,
åå' (
int
åå) ,
start
åå- 2
,
åå2 3
int
åå4 7
length
åå8 >
)
åå> ?
{
çç 	
int
éé 
encodedLength
éé 
=
éé 
$num
éé  !
;
éé! "
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
start
èè 
;
èè 
i
èè  !
<
èè" #
length
èè$ *
;
èè* +
i
èè, -
++
èè- /
)
èè/ 0
{
êê 
char
ëë 
c
ëë 
=
ëë 
seq
ëë 
[
ëë 
i
ëë 
]
ëë 
;
ëë  
if
ìì 
(
ìì 
c
ìì 
<
ìì 
$num
ìì 
)
ìì 
{
îî 
encodedLength
ññ !
+=
ññ" $
(
ññ% &
(
ññ& '
$num
ññ' +
-
ññ, -
c
ññ. /
)
ññ/ 0
.
ññ0 1
RightUShift
ññ1 <
(
ññ< =
$num
ññ= ?
)
ññ? @
)
ññ@ A
+
ññB C
$num
ññD E
;
ññE F
}
óó 
else
òò 
if
òò 
(
òò 
char
òò 
.
òò 
IsSurrogate
òò )
(
òò) *
c
òò* +
)
òò+ ,
)
òò, -
{
ôô 
if
öö 
(
öö 
!
öö 
char
öö 
.
öö 
IsHighSurrogate
öö -
(
öö- .
c
öö. /
)
öö/ 0
)
öö0 1
{
õõ 
encodedLength
úú %
++
úú% '
;
úú' (
continue
ûû  
;
ûû  !
}
üü 
char
†† 
c2
†† 
;
†† 
try
°° 
{
¢¢ 
c2
•• 
=
•• 
seq
••  
[
••  !
++
••! #
i
••# $
]
••$ %
;
••% &
}
¶¶ 
catch
ßß 
(
ßß &
IndexOutOfRangeException
ßß 3
)
ßß3 4
{
®® 
encodedLength
©© %
++
©©% '
;
©©' (
break
´´ 
;
´´ 
}
¨¨ 
if
≠≠ 
(
≠≠ 
!
≠≠ 
char
≠≠ 
.
≠≠ 
IsLowSurrogate
≠≠ ,
(
≠≠, -
c2
≠≠- /
)
≠≠/ 0
)
≠≠0 1
{
ÆÆ 
encodedLength
∞∞ %
+=
∞∞& (
$num
∞∞) *
;
∞∞* +
continue
±±  
;
±±  !
}
≤≤ 
encodedLength
¥¥ !
+=
¥¥" $
$num
¥¥% &
;
¥¥& '
}
µµ 
else
∂∂ 
{
∑∑ 
encodedLength
∏∏ !
+=
∏∏" $
$num
∏∏% &
;
∏∏& '
}
ππ 
}
∫∫ 
return
ªª 
encodedLength
ªª  
;
ªª  !
}
ºº 	
public
ææ 
static
ææ 
IByteBuffer
ææ !

WriteAscii
ææ" ,
(
ææ, -"
IByteBufferAllocator
ææ- A
alloc
ææB G
,
ææG H
ICharSequence
ææI V
seq
ææW Z
)
ææZ [
{
øø 	
IByteBuffer
¡¡ 
buf
¡¡ 
=
¡¡ 
alloc
¡¡ #
.
¡¡# $
Buffer
¡¡$ *
(
¡¡* +
seq
¡¡+ .
.
¡¡. /
Count
¡¡/ 4
)
¡¡4 5
;
¡¡5 6

WriteAscii
¬¬ 
(
¬¬ 
buf
¬¬ 
,
¬¬ 
seq
¬¬ 
)
¬¬  
;
¬¬  !
return
√√ 
buf
√√ 
;
√√ 
}
ƒƒ 	
public
∆∆ 
static
∆∆ 
int
∆∆ 

WriteAscii
∆∆ $
(
∆∆$ %
IByteBuffer
∆∆% 0
buf
∆∆1 4
,
∆∆4 5
ICharSequence
∆∆6 C
seq
∆∆D G
)
∆∆G H
{
«« 	
int
…… 
len
…… 
=
…… 
seq
…… 
.
…… 
Count
…… 
;
……  
if
   
(
   
seq
   
is
   
AsciiString
   "
asciiString
  # .
)
  . /
{
ÀÀ 
buf
ÃÃ 
.
ÃÃ 

WriteBytes
ÃÃ 
(
ÃÃ 
asciiString
ÃÃ *
.
ÃÃ* +
Array
ÃÃ+ 0
,
ÃÃ0 1
asciiString
ÃÃ2 =
.
ÃÃ= >
Offset
ÃÃ> D
,
ÃÃD E
len
ÃÃF I
)
ÃÃI J
;
ÃÃJ K
}
ÕÕ 
else
ŒŒ 
{
œœ 
for
–– 
(
–– 
;
–– 
;
–– 
)
–– 
{
—— 
if
““ 
(
““ 
buf
““ 
is
““  
AbstractByteBuffer
““ 1
byteBuf
““2 9
)
““9 :
{
”” 
byteBuf
‘‘ 
.
‘‘  
EnsureWritable0
‘‘  /
(
‘‘/ 0
len
‘‘0 3
)
‘‘3 4
;
‘‘4 5
int
’’ 
written
’’ #
=
’’$ %

WriteAscii
’’& 0
(
’’0 1
byteBuf
’’1 8
,
’’8 9
byteBuf
’’: A
.
’’A B
WriterIndex
’’B M
,
’’M N
seq
’’O R
,
’’R S
len
’’T W
)
’’W X
;
’’X Y
byteBuf
÷÷ 
.
÷÷  
SetWriterIndex
÷÷  .
(
÷÷. /
byteBuf
÷÷/ 6
.
÷÷6 7
WriterIndex
÷÷7 B
+
÷÷C D
written
÷÷E L
)
÷÷L M
;
÷÷M N
return
◊◊ 
written
◊◊ &
;
◊◊& '
}
ÿÿ 
else
ŸŸ 
if
ŸŸ 
(
ŸŸ 
buf
ŸŸ  
is
ŸŸ! #
WrappedByteBuffer
ŸŸ$ 5
)
ŸŸ5 6
{
⁄⁄ 
buf
‹‹ 
=
‹‹ 
buf
‹‹ !
.
‹‹! "
Unwrap
‹‹" (
(
‹‹( )
)
‹‹) *
;
‹‹* +
}
›› 
else
ﬁﬁ 
{
ﬂﬂ 
byte
‡‡ 
[
‡‡ 
]
‡‡ 
bytes
‡‡ $
=
‡‡% &
Encoding
‡‡' /
.
‡‡/ 0
ASCII
‡‡0 5
.
‡‡5 6
GetBytes
‡‡6 >
(
‡‡> ?
seq
‡‡? B
.
‡‡B C
ToString
‡‡C K
(
‡‡K L
)
‡‡L M
)
‡‡M N
;
‡‡N O
buf
·· 
.
·· 

WriteBytes
·· &
(
··& '
bytes
··' ,
)
··, -
;
··- .
return
‚‚ 
bytes
‚‚ $
.
‚‚$ %
Length
‚‚% +
;
‚‚+ ,
}
„„ 
}
‰‰ 
}
ÂÂ 
return
ÊÊ 
len
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
internal
ÍÍ 
static
ÍÍ 
int
ÍÍ 

WriteAscii
ÍÍ &
(
ÍÍ& ' 
AbstractByteBuffer
ÍÍ' 9
buffer
ÍÍ: @
,
ÍÍ@ A
int
ÍÍB E
writerIndex
ÍÍF Q
,
ÍÍQ R
ICharSequence
ÍÍS `
seq
ÍÍa d
,
ÍÍd e
int
ÍÍf i
len
ÍÍj m
)
ÍÍm n
{
ÎÎ 	
for
ÓÓ 
(
ÓÓ 
int
ÓÓ 
i
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
i
ÓÓ 
<
ÓÓ 
len
ÓÓ  #
;
ÓÓ# $
i
ÓÓ% &
++
ÓÓ& (
)
ÓÓ( )
{
ÔÔ 
buffer
 
.
 
_SetByte
 
(
  
writerIndex
  +
++
+ -
,
- .
AsciiString
/ :
.
: ;

CharToByte
; E
(
E F
seq
F I
[
I J
i
J K
]
K L
)
L M
)
M N
;
N O
}
ÒÒ 
return
ÚÚ 
len
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
ıı 
static
ıı 
IByteBuffer
ıı !

WriteAscii
ıı" ,
(
ıı, -"
IByteBufferAllocator
ıı- A
alloc
ııB G
,
ııG H
string
ııI O
value
ııP U
)
ııU V
{
ˆˆ 	
IByteBuffer
¯¯ 
buf
¯¯ 
=
¯¯ 
alloc
¯¯ #
.
¯¯# $
Buffer
¯¯$ *
(
¯¯* +
value
¯¯+ 0
.
¯¯0 1
Length
¯¯1 7
)
¯¯7 8
;
¯¯8 9

WriteAscii
˘˘ 
(
˘˘ 
buf
˘˘ 
,
˘˘ 
value
˘˘ !
)
˘˘! "
;
˘˘" #
return
˙˙ 
buf
˙˙ 
;
˙˙ 
}
˚˚ 	
public
˝˝ 
static
˝˝ 
int
˝˝ 

WriteAscii
˝˝ $
(
˝˝$ %
IByteBuffer
˝˝% 0
buf
˝˝1 4
,
˝˝4 5
string
˝˝6 <
value
˝˝= B
)
˝˝B C
{
˛˛ 	
int
ÄÄ 
len
ÄÄ 
=
ÄÄ 
value
ÄÄ 
.
ÄÄ 
Length
ÄÄ "
;
ÄÄ" #
for
ÅÅ 
(
ÅÅ 
;
ÅÅ 
;
ÅÅ 
)
ÅÅ 
{
ÇÇ 
if
ÉÉ 
(
ÉÉ 
buf
ÉÉ 
is
ÉÉ  
AbstractByteBuffer
ÉÉ -
byteBuf
ÉÉ. 5
)
ÉÉ5 6
{
ÑÑ 
byteBuf
ÖÖ 
.
ÖÖ 
EnsureWritable0
ÖÖ +
(
ÖÖ+ ,
len
ÖÖ, /
)
ÖÖ/ 0
;
ÖÖ0 1
int
ÜÜ 
written
ÜÜ 
=
ÜÜ  !

WriteAscii
ÜÜ" ,
(
ÜÜ, -
byteBuf
ÜÜ- 4
,
ÜÜ4 5
byteBuf
ÜÜ6 =
.
ÜÜ= >
WriterIndex
ÜÜ> I
,
ÜÜI J
value
ÜÜK P
,
ÜÜP Q
len
ÜÜR U
)
ÜÜU V
;
ÜÜV W
byteBuf
áá 
.
áá 
SetWriterIndex
áá *
(
áá* +
byteBuf
áá+ 2
.
áá2 3
WriterIndex
áá3 >
+
áá? @
written
ááA H
)
ááH I
;
ááI J
return
àà 
written
àà "
;
àà" #
}
ââ 
else
ää 
if
ää 
(
ää 
buf
ää 
is
ää 
WrappedByteBuffer
ää  1
)
ää1 2
{
ãã 
buf
çç 
=
çç 
buf
çç 
.
çç 
Unwrap
çç $
(
çç$ %
)
çç% &
;
çç& '
}
éé 
else
èè 
{
êê 
byte
ëë 
[
ëë 
]
ëë 
bytes
ëë  
=
ëë! "
Encoding
ëë# +
.
ëë+ ,
ASCII
ëë, 1
.
ëë1 2
GetBytes
ëë2 :
(
ëë: ;
value
ëë; @
)
ëë@ A
;
ëëA B
buf
íí 
.
íí 

WriteBytes
íí "
(
íí" #
bytes
íí# (
)
íí( )
;
íí) *
return
ìì 
bytes
ìì  
.
ìì  !
Length
ìì! '
;
ìì' (
}
îî 
}
ïï 
}
ññ 	
internal
òò 
static
òò 
int
òò 

WriteAscii
òò &
(
òò& ' 
AbstractByteBuffer
òò' 9
buffer
òò: @
,
òò@ A
int
òòB E
writerIndex
òòF Q
,
òòQ R
string
òòS Y
value
òòZ _
,
òò_ `
int
òòa d
len
òòe h
)
òòh i
{
ôô 	
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 
len
úú  #
;
úú# $
i
úú% &
++
úú& (
)
úú( )
{
ùù 
buffer
ûû 
.
ûû 
_SetByte
ûû 
(
ûû  
writerIndex
ûû  +
++
ûû+ -
,
ûû- .
(
ûû/ 0
byte
ûû0 4
)
ûû4 5
value
ûû5 :
[
ûû: ;
i
ûû; <
]
ûû< =
)
ûû= >
;
ûû> ?
}
üü 
return
†† 
len
†† 
;
†† 
}
°° 	
public
´´ 
static
´´ 
IByteBuffer
´´ !
EncodeString
´´" .
(
´´. /"
IByteBufferAllocator
´´/ C
alloc
´´D I
,
´´I J
string
´´K Q
src
´´R U
,
´´U V
Encoding
´´W _
encoding
´´` h
)
´´h i
=>
´´j l
EncodeString0
´´m z
(
´´z {
alloc´´{ Ä
,´´Ä Å
false´´Ç á
,´´á à
src´´â å
,´´å ç
encoding´´é ñ
,´´ñ ó
$num´´ò ô
)´´ô ö
;´´ö õ
public
∂∂ 
static
∂∂ 
IByteBuffer
∂∂ !
EncodeString
∂∂" .
(
∂∂. /"
IByteBufferAllocator
∂∂/ C
alloc
∂∂D I
,
∂∂I J
string
∂∂K Q
src
∂∂R U
,
∂∂U V
Encoding
∂∂W _
encoding
∂∂` h
,
∂∂h i
int
∂∂j m
extraCapacity
∂∂n {
)
∂∂{ |
=>
∂∂} 
EncodeString0∂∂Ä ç
(∂∂ç é
alloc∂∂é ì
,∂∂ì î
false∂∂ï ö
,∂∂ö õ
src∂∂ú ü
,∂∂ü †
encoding∂∂° ©
,∂∂© ™
extraCapacity∂∂´ ∏
)∂∂∏ π
;∂∂π ∫
internal
∏∏ 
static
∏∏ 
IByteBuffer
∏∏ #
EncodeString0
∏∏$ 1
(
∏∏1 2"
IByteBufferAllocator
∏∏2 F
alloc
∏∏G L
,
∏∏L M
bool
∏∏N R
enforceHeap
∏∏S ^
,
∏∏^ _
string
∏∏` f
src
∏∏g j
,
∏∏j k
Encoding
∏∏l t
encoding
∏∏u }
,
∏∏} ~
int∏∏ Ç
extraCapacity∏∏É ê
)∏∏ê ë
{
ππ 	
int
∫∫ 
length
∫∫ 
=
∫∫ 
encoding
∫∫ !
.
∫∫! "
GetMaxByteCount
∫∫" 1
(
∫∫1 2
src
∫∫2 5
.
∫∫5 6
Length
∫∫6 <
)
∫∫< =
+
∫∫> ?
extraCapacity
∫∫@ M
;
∫∫M N
bool
ªª 
release
ªª 
=
ªª 
true
ªª 
;
ªª  
IByteBuffer
ΩΩ 
dst
ΩΩ 
=
ΩΩ 
enforceHeap
ΩΩ )
?
ΩΩ* +
alloc
ΩΩ, 1
.
ΩΩ1 2

HeapBuffer
ΩΩ2 <
(
ΩΩ< =
length
ΩΩ= C
)
ΩΩC D
:
ΩΩE F
alloc
ΩΩG L
.
ΩΩL M
Buffer
ΩΩM S
(
ΩΩS T
length
ΩΩT Z
)
ΩΩZ [
;
ΩΩ[ \
Contract
ææ 
.
ææ 
Assert
ææ 
(
ææ 
dst
ææ 
.
ææ  
HasArray
ææ  (
,
ææ( )
$str
ææ* g
)
ææg h
;
ææh i
try
¿¿ 
{
¡¡ 
int
¬¬ 
written
¬¬ 
=
¬¬ 
encoding
¬¬ &
.
¬¬& '
GetBytes
¬¬' /
(
¬¬/ 0
src
¬¬0 3
,
¬¬3 4
$num
¬¬5 6
,
¬¬6 7
src
¬¬8 ;
.
¬¬; <
Length
¬¬< B
,
¬¬B C
dst
¬¬D G
.
¬¬G H
Array
¬¬H M
,
¬¬M N
dst
¬¬O R
.
¬¬R S
ArrayOffset
¬¬S ^
+
¬¬_ `
dst
¬¬a d
.
¬¬d e
WriterIndex
¬¬e p
)
¬¬p q
;
¬¬q r
dst
√√ 
.
√√ 
SetWriterIndex
√√ "
(
√√" #
dst
√√# &
.
√√& '
WriterIndex
√√' 2
+
√√3 4
written
√√5 <
)
√√< =
;
√√= >
release
ƒƒ 
=
ƒƒ 
false
ƒƒ 
;
ƒƒ  
return
∆∆ 
dst
∆∆ 
;
∆∆ 
}
«« 
finally
»» 
{
…… 
if
   
(
   
release
   
)
   
{
ÀÀ 
dst
ÃÃ 
.
ÃÃ 
Release
ÃÃ 
(
ÃÃ  
)
ÃÃ  !
;
ÃÃ! "
}
ÕÕ 
}
ŒŒ 
}
œœ 	
public
—— 
static
—— 
string
—— 
DecodeString
—— )
(
——) *
IByteBuffer
——* 5
src
——6 9
,
——9 :
int
——; >
readerIndex
——? J
,
——J K
int
——L O
len
——P S
,
——S T
Encoding
——U ]
encoding
——^ f
)
——f g
{
““ 	
if
”” 
(
”” 
len
”” 
==
”” 
$num
”” 
)
”” 
{
‘‘ 
return
’’ 
string
’’ 
.
’’ 
Empty
’’ #
;
’’# $
}
÷÷ 
if
ÿÿ 
(
ÿÿ 
src
ÿÿ 
.
ÿÿ 
IoBufferCount
ÿÿ !
==
ÿÿ" $
$num
ÿÿ% &
)
ÿÿ& '
{
ŸŸ 
ArraySegment
⁄⁄ 
<
⁄⁄ 
byte
⁄⁄ !
>
⁄⁄! "
ioBuf
⁄⁄# (
=
⁄⁄) *
src
⁄⁄+ .
.
⁄⁄. /
GetIoBuffer
⁄⁄/ :
(
⁄⁄: ;
readerIndex
⁄⁄; F
,
⁄⁄F G
len
⁄⁄H K
)
⁄⁄K L
;
⁄⁄L M
return
€€ 
encoding
€€ 
.
€€  
	GetString
€€  )
(
€€) *
ioBuf
€€* /
.
€€/ 0
Array
€€0 5
,
€€5 6
ioBuf
€€7 <
.
€€< =
Offset
€€= C
,
€€C D
ioBuf
€€E J
.
€€J K
Count
€€K P
)
€€P Q
;
€€Q R
}
‹‹ 
else
›› 
{
ﬁﬁ 
int
ﬂﬂ 
	maxLength
ﬂﬂ 
=
ﬂﬂ 
encoding
ﬂﬂ  (
.
ﬂﬂ( )
GetMaxCharCount
ﬂﬂ) 8
(
ﬂﬂ8 9
len
ﬂﬂ9 <
)
ﬂﬂ< =
;
ﬂﬂ= >
IByteBuffer
‡‡ 
buffer
‡‡ "
=
‡‡# $
src
‡‡% (
.
‡‡( )
	Allocator
‡‡) 2
.
‡‡2 3

HeapBuffer
‡‡3 =
(
‡‡= >
	maxLength
‡‡> G
)
‡‡G H
;
‡‡H I
try
·· 
{
‚‚ 
buffer
„„ 
.
„„ 

WriteBytes
„„ %
(
„„% &
src
„„& )
,
„„) *
readerIndex
„„+ 6
,
„„6 7
len
„„8 ;
)
„„; <
;
„„< =
ArraySegment
‰‰  
<
‰‰  !
byte
‰‰! %
>
‰‰% &
ioBuf
‰‰' ,
=
‰‰- .
buffer
‰‰/ 5
.
‰‰5 6
GetIoBuffer
‰‰6 A
(
‰‰A B
)
‰‰B C
;
‰‰C D
return
ÂÂ 
encoding
ÂÂ #
.
ÂÂ# $
	GetString
ÂÂ$ -
(
ÂÂ- .
ioBuf
ÂÂ. 3
.
ÂÂ3 4
Array
ÂÂ4 9
,
ÂÂ9 :
ioBuf
ÂÂ; @
.
ÂÂ@ A
Offset
ÂÂA G
,
ÂÂG H
ioBuf
ÂÂI N
.
ÂÂN O
Count
ÂÂO T
)
ÂÂT U
;
ÂÂU V
}
ÊÊ 
finally
ÁÁ 
{
ËË 
buffer
ÍÍ 
.
ÍÍ 
Release
ÍÍ "
(
ÍÍ" #
)
ÍÍ# $
;
ÍÍ$ %
}
ÎÎ 
}
ÏÏ 
}
ÌÌ 	
public
ÔÔ 
static
ÔÔ 
void
ÔÔ 
Copy
ÔÔ 
(
ÔÔ  
AsciiString
ÔÔ  +
src
ÔÔ, /
,
ÔÔ/ 0
IByteBuffer
ÔÔ1 <
dst
ÔÔ= @
)
ÔÔ@ A
=>
ÔÔB D
Copy
ÔÔE I
(
ÔÔI J
src
ÔÔJ M
,
ÔÔM N
$num
ÔÔO P
,
ÔÔP Q
dst
ÔÔR U
,
ÔÔU V
src
ÔÔW Z
.
ÔÔZ [
Count
ÔÔ[ `
)
ÔÔ` a
;
ÔÔa b
[
ÒÒ 	

MethodImpl
ÒÒ	 
(
ÒÒ 
MethodImplOptions
ÒÒ %
.
ÒÒ% & 
AggressiveInlining
ÒÒ& 8
)
ÒÒ8 9
]
ÒÒ9 :
public
ÚÚ 
static
ÚÚ 
void
ÚÚ 
Copy
ÚÚ 
(
ÚÚ  
AsciiString
ÚÚ  +
src
ÚÚ, /
,
ÚÚ/ 0
int
ÚÚ1 4
srcIdx
ÚÚ5 ;
,
ÚÚ; <
IByteBuffer
ÚÚ= H
dst
ÚÚI L
,
ÚÚL M
int
ÚÚN Q
dstIdx
ÚÚR X
,
ÚÚX Y
int
ÚÚZ ]
length
ÚÚ^ d
)
ÚÚd e
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
MathUtil
ÙÙ 
.
ÙÙ 
IsOutOfBounds
ÙÙ &
(
ÙÙ& '
srcIdx
ÙÙ' -
,
ÙÙ- .
length
ÙÙ/ 5
,
ÙÙ5 6
src
ÙÙ7 :
.
ÙÙ: ;
Count
ÙÙ; @
)
ÙÙ@ A
)
ÙÙA B
{
ıı 
ThrowHelper
ˆˆ 
.
ˆˆ /
!ThrowIndexOutOfRangeException_Src
ˆˆ =
(
ˆˆ= >
srcIdx
ˆˆ> D
,
ˆˆD E
length
ˆˆF L
,
ˆˆL M
src
ˆˆN Q
.
ˆˆQ R
Count
ˆˆR W
)
ˆˆW X
;
ˆˆX Y
}
˜˜ 
if
¯¯ 
(
¯¯ 
dst
¯¯ 
==
¯¯ 
null
¯¯ 
)
¯¯ 
{
˘˘ 
ThrowHelper
˙˙ 
.
˙˙ ,
ThrowArgumentNullException_Dst
˙˙ :
(
˙˙: ;
)
˙˙; <
;
˙˙< =
}
˚˚ 
dst
˝˝ 
.
˝˝ 
SetBytes
˝˝ 
(
˝˝ 
dstIdx
˝˝ 
,
˝˝  
src
˝˝! $
.
˝˝$ %
Array
˝˝% *
,
˝˝* +
srcIdx
˝˝, 2
+
˝˝3 4
src
˝˝5 8
.
˝˝8 9
Offset
˝˝9 ?
,
˝˝? @
length
˝˝A G
)
˝˝G H
;
˝˝H I
}
˛˛ 	
[
ÄÄ 	

MethodImpl
ÄÄ	 
(
ÄÄ 
MethodImplOptions
ÄÄ %
.
ÄÄ% & 
AggressiveInlining
ÄÄ& 8
)
ÄÄ8 9
]
ÄÄ9 :
public
ÅÅ 
static
ÅÅ 
void
ÅÅ 
Copy
ÅÅ 
(
ÅÅ  
AsciiString
ÅÅ  +
src
ÅÅ, /
,
ÅÅ/ 0
int
ÅÅ1 4
srcIdx
ÅÅ5 ;
,
ÅÅ; <
IByteBuffer
ÅÅ= H
dst
ÅÅI L
,
ÅÅL M
int
ÅÅN Q
length
ÅÅR X
)
ÅÅX Y
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
MathUtil
ÉÉ 
.
ÉÉ 
IsOutOfBounds
ÉÉ &
(
ÉÉ& '
srcIdx
ÉÉ' -
,
ÉÉ- .
length
ÉÉ/ 5
,
ÉÉ5 6
src
ÉÉ7 :
.
ÉÉ: ;
Count
ÉÉ; @
)
ÉÉ@ A
)
ÉÉA B
{
ÑÑ 
ThrowHelper
ÖÖ 
.
ÖÖ /
!ThrowIndexOutOfRangeException_Src
ÖÖ =
(
ÖÖ= >
srcIdx
ÖÖ> D
,
ÖÖD E
length
ÖÖF L
,
ÖÖL M
src
ÖÖN Q
.
ÖÖQ R
Count
ÖÖR W
)
ÖÖW X
;
ÖÖX Y
}
ÜÜ 
if
áá 
(
áá 
dst
áá 
==
áá 
null
áá 
)
áá 
{
àà 
ThrowHelper
ââ 
.
ââ ,
ThrowArgumentNullException_Dst
ââ :
(
ââ: ;
)
ââ; <
;
ââ< =
}
ää 
dst
åå 
.
åå 

WriteBytes
åå 
(
åå 
src
åå 
.
åå 
Array
åå $
,
åå$ %
srcIdx
åå& ,
+
åå- .
src
åå/ 2
.
åå2 3
Offset
åå3 9
,
åå9 :
length
åå; A
)
ååA B
;
ååB C
}
çç 	
public
íí 
static
íí 
string
íí 
PrettyHexDump
íí *
(
íí* +
IByteBuffer
íí+ 6
buffer
íí7 =
)
íí= >
=>
íí? A
PrettyHexDump
ííB O
(
ííO P
buffer
ííP V
,
ííV W
buffer
ííX ^
.
íí^ _
ReaderIndex
íí_ j
,
ííj k
buffer
ííl r
.
íír s
ReadableBytesíís Ä
)ííÄ Å
;ííÅ Ç
public
òò 
static
òò 
string
òò 
PrettyHexDump
òò *
(
òò* +
IByteBuffer
òò+ 6
buffer
òò7 =
,
òò= >
int
òò? B
offset
òòC I
,
òòI J
int
òòK N
length
òòO U
)
òòU V
=>
òòW Y
HexUtil
òòZ a
.
òòa b
DoPrettyHexDump
òòb q
(
òòq r
buffer
òòr x
,
òòx y
offsetòòz Ä
,òòÄ Å
lengthòòÇ à
)òòà â
;òòâ ä
public
ûû 
static
ûû 
void
ûû !
AppendPrettyHexDump
ûû .
(
ûû. /
StringBuilder
ûû/ <
dump
ûû= A
,
ûûA B
IByteBuffer
ûûC N
buf
ûûO R
)
ûûR S
=>
ûûT V!
AppendPrettyHexDump
ûûW j
(
ûûj k
dump
ûûk o
,
ûûo p
buf
ûûq t
,
ûût u
buf
ûûv y
.
ûûy z
ReaderIndexûûz Ö
,ûûÖ Ü
bufûûá ä
.ûûä ã
ReadableBytesûûã ò
)ûûò ô
;ûûô ö
public
•• 
static
•• 
void
•• !
AppendPrettyHexDump
•• .
(
••. /
StringBuilder
••/ <
dump
••= A
,
••A B
IByteBuffer
••C N
buf
••O R
,
••R S
int
••T W
offset
••X ^
,
••^ _
int
••` c
length
••d j
)
••j k
=>
••l n
HexUtil
••o v
.
••v w$
DoAppendPrettyHexDump••w å
(••å ç
dump••ç ë
,••ë í
buf••ì ñ
,••ñ ó
offset••ò û
,••û ü
length••† ¶
)••¶ ß
;••ß ®
static
ßß 
class
ßß 
HexUtil
ßß 
{
®® 	
static
©© 
readonly
©© 
char
©©  
[
©©  !
]
©©! "
HexdumpTable
©©# /
=
©©0 1
new
©©2 5
char
©©6 :
[
©©: ;
$num
©©; >
*
©©? @
$num
©©A B
]
©©B C
;
©©C D
static
™™ 
readonly
™™ 
string
™™ "
Newline
™™# *
=
™™+ ,

StringUtil
™™- 7
.
™™7 8
Newline
™™8 ?
;
™™? @
static
´´ 
readonly
´´ 
string
´´ "
[
´´" #
]
´´# $
Byte2Hex
´´% -
=
´´. /
new
´´0 3
string
´´4 :
[
´´: ;
$num
´´; >
]
´´> ?
;
´´? @
static
¨¨ 
readonly
¨¨ 
string
¨¨ "
[
¨¨" #
]
¨¨# $

HexPadding
¨¨% /
=
¨¨0 1
new
¨¨2 5
string
¨¨6 <
[
¨¨< =
$num
¨¨= ?
]
¨¨? @
;
¨¨@ A
static
≠≠ 
readonly
≠≠ 
string
≠≠ "
[
≠≠" #
]
≠≠# $
BytePadding
≠≠% 0
=
≠≠1 2
new
≠≠3 6
string
≠≠7 =
[
≠≠= >
$num
≠≠> @
]
≠≠@ A
;
≠≠A B
static
ÆÆ 
readonly
ÆÆ 
char
ÆÆ  
[
ÆÆ  !
]
ÆÆ! "
	Byte2Char
ÆÆ# ,
=
ÆÆ- .
new
ÆÆ/ 2
char
ÆÆ3 7
[
ÆÆ7 8
$num
ÆÆ8 ;
]
ÆÆ; <
;
ÆÆ< =
static
ØØ 
readonly
ØØ 
string
ØØ "
[
ØØ" #
]
ØØ# $ 
HexDumpRowPrefixes
ØØ% 7
=
ØØ8 9
new
ØØ: =
string
ØØ> D
[
ØØD E
(
ØØE F
int
ØØF I
)
ØØI J
(
ØØJ K
(
ØØK L
uint
ØØL P
)
ØØP Q
$num
ØØQ V
>>
ØØW Y
$num
ØØZ [
)
ØØ[ \
]
ØØ\ ]
;
ØØ] ^
static
±± 
HexUtil
±± 
(
±± 
)
±± 
{
≤≤ 
char
≥≥ 
[
≥≥ 
]
≥≥ 
digits
≥≥ 
=
≥≥ 
$str
≥≥  2
.
≥≥2 3
ToCharArray
≥≥3 >
(
≥≥> ?
)
≥≥? @
;
≥≥@ A
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥  !
<
¥¥" #
$num
¥¥$ '
;
¥¥' (
i
¥¥) *
++
¥¥* ,
)
¥¥, -
{
µµ 
HexdumpTable
∂∂  
[
∂∂  !
i
∂∂! "
<<
∂∂# %
$num
∂∂& '
]
∂∂' (
=
∂∂) *
digits
∂∂+ 1
[
∂∂1 2
(
∂∂2 3
int
∂∂3 6
)
∂∂6 7
(
∂∂7 8
(
∂∂8 9
uint
∂∂9 =
)
∂∂= >
i
∂∂> ?
>>
∂∂@ B
$num
∂∂C D
&
∂∂E F
$num
∂∂G K
)
∂∂K L
]
∂∂L M
;
∂∂M N
HexdumpTable
∑∑  
[
∑∑  !
(
∑∑! "
i
∑∑" #
<<
∑∑$ &
$num
∑∑' (
)
∑∑( )
+
∑∑* +
$num
∑∑, -
]
∑∑- .
=
∑∑/ 0
digits
∑∑1 7
[
∑∑7 8
i
∑∑8 9
&
∑∑: ;
$num
∑∑< @
]
∑∑@ A
;
∑∑A B
}
∏∏ 
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª  !
<
ªª" #
Byte2Hex
ªª$ ,
.
ªª, -
Length
ªª- 3
;
ªª3 4
i
ªª5 6
++
ªª6 8
)
ªª8 9
{
ºº 
Byte2Hex
ΩΩ 
[
ΩΩ 
i
ΩΩ 
]
ΩΩ 
=
ΩΩ  !
$char
ΩΩ" %
+
ΩΩ& '

StringUtil
ΩΩ( 2
.
ΩΩ2 3#
ByteToHexStringPadded
ΩΩ3 H
(
ΩΩH I
i
ΩΩI J
)
ΩΩJ K
;
ΩΩK L
}
ææ 
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡  !
<
¡¡" #

HexPadding
¡¡$ .
.
¡¡. /
Length
¡¡/ 5
;
¡¡5 6
i
¡¡7 8
++
¡¡8 :
)
¡¡: ;
{
¬¬ 
int
√√ 
padding
√√ 
=
√√  !

HexPadding
√√" ,
.
√√, -
Length
√√- 3
-
√√4 5
i
√√6 7
;
√√7 8
var
ƒƒ 
buf
ƒƒ 
=
ƒƒ 
new
ƒƒ !
StringBuilder
ƒƒ" /
(
ƒƒ/ 0
padding
ƒƒ0 7
*
ƒƒ8 9
$num
ƒƒ: ;
)
ƒƒ; <
;
ƒƒ< =
for
≈≈ 
(
≈≈ 
int
≈≈ 
j
≈≈ 
=
≈≈  
$num
≈≈! "
;
≈≈" #
j
≈≈$ %
<
≈≈& '
padding
≈≈( /
;
≈≈/ 0
j
≈≈1 2
++
≈≈2 4
)
≈≈4 5
{
∆∆ 
buf
«« 
.
«« 
Append
«« "
(
««" #
$str
««# (
)
««( )
;
««) *
}
»» 

HexPadding
…… 
[
…… 
i
……  
]
……  !
=
……" #
buf
……$ '
.
……' (
ToString
……( 0
(
……0 1
)
……1 2
;
……2 3
}
   
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ  !
<
ÕÕ" #
BytePadding
ÕÕ$ /
.
ÕÕ/ 0
Length
ÕÕ0 6
;
ÕÕ6 7
i
ÕÕ8 9
++
ÕÕ9 ;
)
ÕÕ; <
{
ŒŒ 
int
œœ 
padding
œœ 
=
œœ  !
BytePadding
œœ" -
.
œœ- .
Length
œœ. 4
-
œœ5 6
i
œœ7 8
;
œœ8 9
var
–– 
buf
–– 
=
–– 
new
–– !
StringBuilder
––" /
(
––/ 0
padding
––0 7
)
––7 8
;
––8 9
for
—— 
(
—— 
int
—— 
j
—— 
=
——  
$num
——! "
;
——" #
j
——$ %
<
——& '
padding
——( /
;
——/ 0
j
——1 2
++
——2 4
)
——4 5
{
““ 
buf
”” 
.
”” 
Append
”” "
(
””" #
$char
””# &
)
””& '
;
””' (
}
‘‘ 
BytePadding
’’ 
[
’’  
i
’’  !
]
’’! "
=
’’# $
buf
’’% (
.
’’( )
ToString
’’) 1
(
’’1 2
)
’’2 3
;
’’3 4
}
÷÷ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ  !
<
ŸŸ" #
	Byte2Char
ŸŸ$ -
.
ŸŸ- .
Length
ŸŸ. 4
;
ŸŸ4 5
i
ŸŸ6 7
++
ŸŸ7 9
)
ŸŸ9 :
{
⁄⁄ 
if
€€ 
(
€€ 
i
€€ 
<=
€€ 
$num
€€ !
||
€€" $
i
€€% &
>=
€€' )
$num
€€* .
)
€€. /
{
‹‹ 
	Byte2Char
›› !
[
››! "
i
››" #
]
››# $
=
››% &
$char
››' *
;
››* +
}
ﬁﬁ 
else
ﬂﬂ 
{
‡‡ 
	Byte2Char
·· !
[
··! "
i
··" #
]
··# $
=
··% &
(
··' (
char
··( ,
)
··, -
i
··- .
;
··. /
}
‚‚ 
}
„„ 
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ  !
<
ÊÊ" # 
HexDumpRowPrefixes
ÊÊ$ 6
.
ÊÊ6 7
Length
ÊÊ7 =
;
ÊÊ= >
i
ÊÊ? @
++
ÊÊ@ B
)
ÊÊB C
{
ÁÁ 
var
ËË 
buf
ËË 
=
ËË 
new
ËË !
StringBuilder
ËË" /
(
ËË/ 0
$num
ËË0 2
)
ËË2 3
;
ËË3 4
buf
ÈÈ 
.
ÈÈ 
Append
ÈÈ 
(
ÈÈ 
Environment
ÈÈ *
.
ÈÈ* +
NewLine
ÈÈ+ 2
)
ÈÈ2 3
;
ÈÈ3 4
buf
ÍÍ 
.
ÍÍ 
Append
ÍÍ 
(
ÍÍ 
(
ÍÍ  
i
ÍÍ  !
<<
ÍÍ" $
$num
ÍÍ% &
&
ÍÍ' (
$num
ÍÍ) 4
|
ÍÍ5 6
$num
ÍÍ7 C
)
ÍÍC D
.
ÍÍD E
ToString
ÍÍE M
(
ÍÍM N
$str
ÍÍN R
)
ÍÍR S
)
ÍÍS T
;
ÍÍT U
buf
ÎÎ 
.
ÎÎ 
Insert
ÎÎ 
(
ÎÎ 
buf
ÎÎ "
.
ÎÎ" #
Length
ÎÎ# )
-
ÎÎ* +
$num
ÎÎ, -
,
ÎÎ- .
$char
ÎÎ/ 2
)
ÎÎ2 3
;
ÎÎ3 4
buf
ÏÏ 
.
ÏÏ 
Append
ÏÏ 
(
ÏÏ 
$char
ÏÏ "
)
ÏÏ" #
;
ÏÏ# $ 
HexDumpRowPrefixes
ÌÌ &
[
ÌÌ& '
i
ÌÌ' (
]
ÌÌ( )
=
ÌÌ* +
buf
ÌÌ, /
.
ÌÌ/ 0
ToString
ÌÌ0 8
(
ÌÌ8 9
)
ÌÌ9 :
;
ÌÌ: ;
}
ÓÓ 
}
ÔÔ 
public
ÒÒ 
static
ÒÒ 
string
ÒÒ  
	DoHexDump
ÒÒ! *
(
ÒÒ* +
IByteBuffer
ÒÒ+ 6
buffer
ÒÒ7 =
,
ÒÒ= >
int
ÒÒ? B
	fromIndex
ÒÒC L
,
ÒÒL M
int
ÒÒN Q
length
ÒÒR X
)
ÒÒX Y
{
ÚÚ 
Contract
ÛÛ 
.
ÛÛ 
Requires
ÛÛ !
(
ÛÛ! "
length
ÛÛ" (
>=
ÛÛ) +
$num
ÛÛ, -
)
ÛÛ- .
;
ÛÛ. /
if
ÙÙ 
(
ÙÙ 
length
ÙÙ 
==
ÙÙ 
$num
ÙÙ 
)
ÙÙ  
{
ıı 
return
ˆˆ 
$str
ˆˆ 
;
ˆˆ 
}
˜˜ 
int
¯¯ 
endIndex
¯¯ 
=
¯¯ 
	fromIndex
¯¯ (
+
¯¯) *
length
¯¯+ 1
;
¯¯1 2
var
˘˘ 
buf
˘˘ 
=
˘˘ 
new
˘˘ 
char
˘˘ "
[
˘˘" #
length
˘˘# )
<<
˘˘* ,
$num
˘˘- .
]
˘˘. /
;
˘˘/ 0
int
˚˚ 
srcIdx
˚˚ 
=
˚˚ 
	fromIndex
˚˚ &
;
˚˚& '
int
¸¸ 
dstIdx
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
for
˝˝ 
(
˝˝ 
;
˝˝ 
srcIdx
˝˝ 
<
˝˝ 
endIndex
˝˝  (
;
˝˝( )
srcIdx
˝˝* 0
++
˝˝0 2
,
˝˝2 3
dstIdx
˝˝4 :
+=
˝˝; =
$num
˝˝> ?
)
˝˝? @
{
˛˛ 
Array
ˇˇ 
.
ˇˇ 
Copy
ˇˇ 
(
ˇˇ 
HexdumpTable
ÄÄ $
,
ÄÄ$ %
buffer
ÄÄ& ,
.
ÄÄ, -
GetByte
ÄÄ- 4
(
ÄÄ4 5
srcIdx
ÄÄ5 ;
)
ÄÄ; <
<<
ÄÄ= ?
$num
ÄÄ@ A
,
ÄÄA B
buf
ÅÅ 
,
ÅÅ 
dstIdx
ÅÅ #
,
ÅÅ# $
$num
ÅÅ% &
)
ÅÅ& '
;
ÅÅ' (
}
ÇÇ 
return
ÑÑ 
new
ÑÑ 
string
ÑÑ !
(
ÑÑ! "
buf
ÑÑ" %
)
ÑÑ% &
;
ÑÑ& '
}
ÖÖ 
public
áá 
static
áá 
string
áá  
	DoHexDump
áá! *
(
áá* +
byte
áá+ /
[
áá/ 0
]
áá0 1
array
áá2 7
,
áá7 8
int
áá9 <
	fromIndex
áá= F
,
ááF G
int
ááH K
length
ááL R
)
ááR S
{
àà 
Contract
ââ 
.
ââ 
Requires
ââ !
(
ââ! "
length
ââ" (
>=
ââ) +
$num
ââ, -
)
ââ- .
;
ââ. /
if
ãã 
(
ãã 
length
ãã 
==
ãã 
$num
ãã 
)
ãã  
{
åå 
return
çç 
$str
çç 
;
çç 
}
éé 
int
êê 
endIndex
êê 
=
êê 
	fromIndex
êê (
+
êê) *
length
êê+ 1
;
êê1 2
var
ëë 
buf
ëë 
=
ëë 
new
ëë 
char
ëë "
[
ëë" #
length
ëë# )
<<
ëë* ,
$num
ëë- .
]
ëë. /
;
ëë/ 0
int
ìì 
srcIdx
ìì 
=
ìì 
	fromIndex
ìì &
;
ìì& '
int
îî 
dstIdx
îî 
=
îî 
$num
îî 
;
îî 
for
ïï 
(
ïï 
;
ïï 
srcIdx
ïï 
<
ïï 
endIndex
ïï  (
;
ïï( )
srcIdx
ïï* 0
++
ïï0 2
,
ïï2 3
dstIdx
ïï4 :
+=
ïï; =
$num
ïï> ?
)
ïï? @
{
ññ 
Array
óó 
.
óó 
Copy
óó 
(
óó 
HexdumpTable
óó +
,
óó+ ,
(
óó- .
array
óó. 3
[
óó3 4
srcIdx
óó4 :
]
óó: ;
&
óó< =
$num
óó> B
)
óóB C
<<
óóD F
$num
óóG H
,
óóH I
buf
óóJ M
,
óóM N
dstIdx
óóO U
,
óóU V
$num
óóW X
)
óóX Y
;
óóY Z
}
òò 
return
öö 
new
öö 
string
öö !
(
öö! "
buf
öö" %
)
öö% &
;
öö& '
}
õõ 
public
ùù 
static
ùù 
string
ùù  
DoPrettyHexDump
ùù! 0
(
ùù0 1
IByteBuffer
ùù1 <
buffer
ùù= C
,
ùùC D
int
ùùE H
offset
ùùI O
,
ùùO P
int
ùùQ T
length
ùùU [
)
ùù[ \
{
ûû 
if
üü 
(
üü 
length
üü 
==
üü 
$num
üü 
)
üü  
{
†† 
return
°° 
string
°° !
.
°°! "
Empty
°°" '
;
°°' (
}
¢¢ 
else
££ 
{
§§ 
int
•• 
rows
•• 
=
•• 
length
•• %
/
••& '
$num
••( *
+
••+ ,
(
••- .
length
••. 4
%
••5 6
$num
••7 9
==
••: <
$num
••= >
?
••? @
$num
••A B
:
••C D
$num
••E F
)
••F G
+
••H I
$num
••J K
;
••K L
var
¶¶ 
buf
¶¶ 
=
¶¶ 
new
¶¶ !
StringBuilder
¶¶" /
(
¶¶/ 0
rows
¶¶0 4
*
¶¶5 6
$num
¶¶7 9
)
¶¶9 :
;
¶¶: ;!
AppendPrettyHexDump
ßß '
(
ßß' (
buf
ßß( +
,
ßß+ ,
buffer
ßß- 3
,
ßß3 4
offset
ßß5 ;
,
ßß; <
length
ßß= C
)
ßßC D
;
ßßD E
return
®® 
buf
®® 
.
®® 
ToString
®® '
(
®®' (
)
®®( )
;
®®) *
}
©© 
}
™™ 
public
¨¨ 
static
¨¨ 
void
¨¨ #
DoAppendPrettyHexDump
¨¨ 4
(
¨¨4 5
StringBuilder
¨¨5 B
dump
¨¨C G
,
¨¨G H
IByteBuffer
¨¨I T
buf
¨¨U X
,
¨¨X Y
int
¨¨Z ]
offset
¨¨^ d
,
¨¨d e
int
¨¨f i
length
¨¨j p
)
¨¨p q
{
≠≠ 
if
ÆÆ 
(
ÆÆ 
MathUtil
ÆÆ 
.
ÆÆ 
IsOutOfBounds
ÆÆ *
(
ÆÆ* +
offset
ÆÆ+ 1
,
ÆÆ1 2
length
ÆÆ3 9
,
ÆÆ9 :
buf
ÆÆ; >
.
ÆÆ> ?
Capacity
ÆÆ? G
)
ÆÆG H
)
ÆÆH I
{
ØØ 
throw
∞∞ 
new
∞∞ &
IndexOutOfRangeException
∞∞ 6
(
∞∞6 7
$"
±± 
$str
±± 0
{
±±0 1
offset
±±1 7
}
±±7 8
$str
±±8 M
{
±±M N
length
±±N T
}
±±T U
$str
±±U g
{
±±g h
buf
±±h k
.
±±k l
Capacity
±±l t
}
±±t u
{
±±u v
$char
±±v y
}
±±y z
"
±±z {
)
±±{ |
;
±±| }
}
≤≤ 
if
≥≥ 
(
≥≥ 
length
≥≥ 
==
≥≥ 
$num
≥≥ 
)
≥≥  
{
¥¥ 
return
µµ 
;
µµ 
}
∂∂ 
dump
∑∑ 
.
∑∑ 
Append
∑∑ 
(
∑∑ 
$str
∏∏ R
+
∏∏S T
Newline
ππ 
+
ππ 
$str
ππ \
+
ππ] ^
Newline
∫∫ 
+
∫∫ 
$str
∫∫ m
)
∫∫m n
;
∫∫n o
int
ºº 

startIndex
ºº 
=
ºº  
offset
ºº! '
;
ºº' (
int
ΩΩ 
fullRows
ΩΩ 
=
ΩΩ 
(
ΩΩ  
int
ΩΩ  #
)
ΩΩ# $
(
ΩΩ$ %
(
ΩΩ% &
uint
ΩΩ& *
)
ΩΩ* +
length
ΩΩ+ 1
>>
ΩΩ2 4
$num
ΩΩ5 6
)
ΩΩ6 7
;
ΩΩ7 8
int
ææ 
	remainder
ææ 
=
ææ 
length
ææ  &
&
ææ' (
$num
ææ) ,
;
ææ, -
for
¡¡ 
(
¡¡ 
int
¡¡ 
row
¡¡ 
=
¡¡ 
$num
¡¡  
;
¡¡  !
row
¡¡" %
<
¡¡& '
fullRows
¡¡( 0
;
¡¡0 1
row
¡¡2 5
++
¡¡5 7
)
¡¡7 8
{
¬¬ 
int
√√ 
rowStartIndex
√√ %
=
√√& '
(
√√( )
row
√√) ,
<<
√√- /
$num
√√0 1
)
√√1 2
+
√√3 4

startIndex
√√5 ?
;
√√? @$
AppendHexDumpRowPrefix
∆∆ *
(
∆∆* +
dump
∆∆+ /
,
∆∆/ 0
row
∆∆1 4
,
∆∆4 5
rowStartIndex
∆∆6 C
)
∆∆C D
;
∆∆D E
int
…… 
rowEndIndex
…… #
=
……$ %
rowStartIndex
……& 3
+
……4 5
$num
……6 8
;
……8 9
for
   
(
   
int
   
j
   
=
    
rowStartIndex
  ! .
;
  . /
j
  0 1
<
  2 3
rowEndIndex
  4 ?
;
  ? @
j
  A B
++
  B D
)
  D E
{
ÀÀ 
dump
ÃÃ 
.
ÃÃ 
Append
ÃÃ #
(
ÃÃ# $
Byte2Hex
ÃÃ$ ,
[
ÃÃ, -
buf
ÃÃ- 0
.
ÃÃ0 1
GetByte
ÃÃ1 8
(
ÃÃ8 9
j
ÃÃ9 :
)
ÃÃ: ;
]
ÃÃ; <
)
ÃÃ< =
;
ÃÃ= >
}
ÕÕ 
dump
ŒŒ 
.
ŒŒ 
Append
ŒŒ 
(
ŒŒ  
$str
ŒŒ  $
)
ŒŒ$ %
;
ŒŒ% &
for
—— 
(
—— 
int
—— 
j
—— 
=
——  
rowStartIndex
——! .
;
——. /
j
——0 1
<
——2 3
rowEndIndex
——4 ?
;
——? @
j
——A B
++
——B D
)
——D E
{
““ 
dump
”” 
.
”” 
Append
”” #
(
””# $
	Byte2Char
””$ -
[
””- .
buf
””. 1
.
””1 2
GetByte
””2 9
(
””9 :
j
””: ;
)
””; <
]
””< =
)
””= >
;
””> ?
}
‘‘ 
dump
’’ 
.
’’ 
Append
’’ 
(
’’  
$char
’’  #
)
’’# $
;
’’$ %
}
÷÷ 
if
ŸŸ 
(
ŸŸ 
	remainder
ŸŸ 
!=
ŸŸ  
$num
ŸŸ! "
)
ŸŸ" #
{
⁄⁄ 
int
€€ 
rowStartIndex
€€ %
=
€€& '
(
€€( )
fullRows
€€) 1
<<
€€2 4
$num
€€5 6
)
€€6 7
+
€€8 9

startIndex
€€: D
;
€€D E$
AppendHexDumpRowPrefix
‹‹ *
(
‹‹* +
dump
‹‹+ /
,
‹‹/ 0
fullRows
‹‹1 9
,
‹‹9 :
rowStartIndex
‹‹; H
)
‹‹H I
;
‹‹I J
int
ﬂﬂ 
rowEndIndex
ﬂﬂ #
=
ﬂﬂ$ %
rowStartIndex
ﬂﬂ& 3
+
ﬂﬂ4 5
	remainder
ﬂﬂ6 ?
;
ﬂﬂ? @
for
‡‡ 
(
‡‡ 
int
‡‡ 
j
‡‡ 
=
‡‡  
rowStartIndex
‡‡! .
;
‡‡. /
j
‡‡0 1
<
‡‡2 3
rowEndIndex
‡‡4 ?
;
‡‡? @
j
‡‡A B
++
‡‡B D
)
‡‡D E
{
·· 
dump
‚‚ 
.
‚‚ 
Append
‚‚ #
(
‚‚# $
Byte2Hex
‚‚$ ,
[
‚‚, -
buf
‚‚- 0
.
‚‚0 1
GetByte
‚‚1 8
(
‚‚8 9
j
‚‚9 :
)
‚‚: ;
]
‚‚; <
)
‚‚< =
;
‚‚= >
}
„„ 
dump
‰‰ 
.
‰‰ 
Append
‰‰ 
(
‰‰  

HexPadding
‰‰  *
[
‰‰* +
	remainder
‰‰+ 4
]
‰‰4 5
)
‰‰5 6
;
‰‰6 7
dump
ÂÂ 
.
ÂÂ 
Append
ÂÂ 
(
ÂÂ  
$str
ÂÂ  $
)
ÂÂ$ %
;
ÂÂ% &
for
ËË 
(
ËË 
int
ËË 
j
ËË 
=
ËË  
rowStartIndex
ËË! .
;
ËË. /
j
ËË0 1
<
ËË2 3
rowEndIndex
ËË4 ?
;
ËË? @
j
ËËA B
++
ËËB D
)
ËËD E
{
ÈÈ 
dump
ÍÍ 
.
ÍÍ 
Append
ÍÍ #
(
ÍÍ# $
	Byte2Char
ÍÍ$ -
[
ÍÍ- .
buf
ÍÍ. 1
.
ÍÍ1 2
GetByte
ÍÍ2 9
(
ÍÍ9 :
j
ÍÍ: ;
)
ÍÍ; <
]
ÍÍ< =
)
ÍÍ= >
;
ÍÍ> ?
}
ÎÎ 
dump
ÏÏ 
.
ÏÏ 
Append
ÏÏ 
(
ÏÏ  
BytePadding
ÏÏ  +
[
ÏÏ+ ,
	remainder
ÏÏ, 5
]
ÏÏ5 6
)
ÏÏ6 7
;
ÏÏ7 8
dump
ÌÌ 
.
ÌÌ 
Append
ÌÌ 
(
ÌÌ  
$char
ÌÌ  #
)
ÌÌ# $
;
ÌÌ$ %
}
ÓÓ 
dump
 
.
 
Append
 
(
 
Newline
 #
+
$ %
$str
& u
)
u v
;
v w
}
ÒÒ 
static
ÛÛ 
void
ÛÛ $
AppendHexDumpRowPrefix
ÛÛ .
(
ÛÛ. /
StringBuilder
ÛÛ/ <
dump
ÛÛ= A
,
ÛÛA B
int
ÛÛC F
row
ÛÛG J
,
ÛÛJ K
int
ÛÛL O
rowStartIndex
ÛÛP ]
)
ÛÛ] ^
{
ÙÙ 
if
ıı 
(
ıı 
row
ıı 
<
ıı  
HexDumpRowPrefixes
ıı ,
.
ıı, -
Length
ıı- 3
)
ıı3 4
{
ˆˆ 
dump
˜˜ 
.
˜˜ 
Append
˜˜ 
(
˜˜   
HexDumpRowPrefixes
˜˜  2
[
˜˜2 3
row
˜˜3 6
]
˜˜6 7
)
˜˜7 8
;
˜˜8 9
}
¯¯ 
else
˘˘ 
{
˙˙ 
dump
˚˚ 
.
˚˚ 
Append
˚˚ 
(
˚˚  
Environment
˚˚  +
.
˚˚+ ,
NewLine
˚˚, 3
)
˚˚3 4
;
˚˚4 5
dump
¸¸ 
.
¸¸ 
Append
¸¸ 
(
¸¸  
(
¸¸  !
rowStartIndex
¸¸! .
&
¸¸/ 0
$num
¸¸1 <
|
¸¸= >
$num
¸¸? K
)
¸¸K L
.
¸¸L M
ToString
¸¸M U
(
¸¸U V
$str
¸¸V Z
)
¸¸Z [
)
¸¸[ \
;
¸¸\ ]
dump
˝˝ 
.
˝˝ 
Insert
˝˝ 
(
˝˝  
dump
˝˝  $
.
˝˝$ %
Length
˝˝% +
-
˝˝, -
$num
˝˝. /
,
˝˝/ 0
$char
˝˝1 4
)
˝˝4 5
;
˝˝5 6
dump
˛˛ 
.
˛˛ 
Append
˛˛ 
(
˛˛  
$char
˛˛  #
)
˛˛# $
;
˛˛$ %
}
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
IsText
ÉÉ !
(
ÉÉ! "
IByteBuffer
ÉÉ" -
buf
ÉÉ. 1
,
ÉÉ1 2
int
ÉÉ3 6
index
ÉÉ7 <
,
ÉÉ< =
int
ÉÉ> A
length
ÉÉB H
,
ÉÉH I
Encoding
ÉÉJ R
encoding
ÉÉS [
)
ÉÉ[ \
{
ÑÑ 	
Contract
ÖÖ 
.
ÖÖ 
Requires
ÖÖ 
(
ÖÖ 
buf
ÖÖ !
!=
ÖÖ" $
null
ÖÖ% )
)
ÖÖ) *
;
ÖÖ* +
Contract
ÜÜ 
.
ÜÜ 
Requires
ÜÜ 
(
ÜÜ 
encoding
ÜÜ &
!=
ÜÜ' )
null
ÜÜ* .
)
ÜÜ. /
;
ÜÜ/ 0
int
àà 
maxIndex
àà 
=
àà 
buf
àà 
.
àà 
ReaderIndex
àà *
+
àà+ ,
buf
àà- 0
.
àà0 1
ReadableBytes
àà1 >
;
àà> ?
if
ââ 
(
ââ 
index
ââ 
<
ââ 
$num
ââ 
||
ââ 
length
ââ #
<
ââ$ %
$num
ââ& '
||
ââ( *
index
ââ+ 0
>
ââ1 2
maxIndex
ââ3 ;
-
ââ< =
length
ââ> D
)
ââD E
{
ää 
throw
ãã 
new
ãã &
IndexOutOfRangeException
ãã 2
(
ãã2 3
$"
ãã3 5
$str
ãã5 <
{
ãã< =
index
ãã= B
}
ããB C
$str
ããC K
{
ããK L
length
ããL R
}
ããR S
"
ããS T
)
ããT U
;
ããU V
}
åå 
if
çç 
(
çç 
ReferenceEquals
çç 
(
çç  
Encoding
çç  (
.
çç( )
UTF8
çç) -
,
çç- .
encoding
çç/ 7
)
çç7 8
)
çç8 9
{
éé 
return
èè 
IsUtf8
èè 
(
èè 
buf
èè !
,
èè! "
index
èè# (
,
èè( )
length
èè* 0
)
èè0 1
;
èè1 2
}
êê 
else
ëë 
if
ëë 
(
ëë 
ReferenceEquals
ëë $
(
ëë$ %
Encoding
ëë% -
.
ëë- .
ASCII
ëë. 3
,
ëë3 4
encoding
ëë5 =
)
ëë= >
)
ëë> ?
{
íí 
return
ìì 
IsAscii
ìì 
(
ìì 
buf
ìì "
,
ìì" #
index
ìì$ )
,
ìì) *
length
ìì+ 1
)
ìì1 2
;
ìì2 3
}
îî 
else
ïï 
{
ññ 
try
óó 
{
òò 
if
ôô 
(
ôô 
buf
ôô 
.
ôô 
IoBufferCount
ôô )
==
ôô* ,
$num
ôô- .
)
ôô. /
{
öö 
ArraySegment
õõ $
<
õõ$ %
byte
õõ% )
>
õõ) *
segment
õõ+ 2
=
õõ3 4
buf
õõ5 8
.
õõ8 9
GetIoBuffer
õõ9 D
(
õõD E
)
õõE F
;
õõF G
encoding
úú  
.
úú  !
GetChars
úú! )
(
úú) *
segment
úú* 1
.
úú1 2
Array
úú2 7
,
úú7 8
segment
úú9 @
.
úú@ A
Offset
úúA G
,
úúG H
segment
úúI P
.
úúP Q
Count
úúQ V
)
úúV W
;
úúW X
}
ùù 
else
ûû 
{
üü 
IByteBuffer
†† #

heapBuffer
††$ .
=
††/ 0
buf
††1 4
.
††4 5
	Allocator
††5 >
.
††> ?

HeapBuffer
††? I
(
††I J
length
††J P
)
††P Q
;
††Q R
try
°° 
{
¢¢ 

heapBuffer
££ &
.
££& '

WriteBytes
££' 1
(
££1 2
buf
££2 5
,
££5 6
index
££7 <
,
££< =
length
££> D
)
££D E
;
££E F
ArraySegment
§§ (
<
§§( )
byte
§§) -
>
§§- .
segment
§§/ 6
=
§§7 8

heapBuffer
§§9 C
.
§§C D
GetIoBuffer
§§D O
(
§§O P
)
§§P Q
;
§§Q R
encoding
•• $
.
••$ %
GetChars
••% -
(
••- .
segment
••. 5
.
••5 6
Array
••6 ;
,
••; <
segment
••= D
.
••D E
Offset
••E K
,
••K L
segment
••M T
.
••T U
Count
••U Z
)
••Z [
;
••[ \
}
¶¶ 
finally
ßß 
{
®® 

heapBuffer
©© &
.
©©& '
Release
©©' .
(
©©. /
)
©©/ 0
;
©©0 1
}
™™ 
}
´´ 
return
¨¨ 
true
¨¨ 
;
¨¨  
}
≠≠ 
catch
ÆÆ 
{
ØØ 
return
∞∞ 
false
∞∞  
;
∞∞  !
}
±± 
}
≤≤ 
}
≥≥ 	
static
µµ 
readonly
µµ 
FindNonAscii
µµ $ 
AsciiByteProcessor
µµ% 7
=
µµ8 9
new
µµ: =
FindNonAscii
µµ> J
(
µµJ K
)
µµK L
;
µµL M
sealed
∑∑ 
class
∑∑ 
FindNonAscii
∑∑ !
:
∑∑" #
IByteProcessor
∑∑$ 2
{
∏∏ 	
public
ππ 
bool
ππ 
Process
ππ 
(
ππ  
byte
ππ  $
value
ππ% *
)
ππ* +
=>
ππ, .
value
ππ/ 4
<
ππ5 6
$num
ππ7 ;
;
ππ; <
}
∫∫ 	
static
ºº 
bool
ºº 
IsAscii
ºº 
(
ºº 
IByteBuffer
ºº '
buf
ºº( +
,
ºº+ ,
int
ºº- 0
index
ºº1 6
,
ºº6 7
int
ºº8 ;
length
ºº< B
)
ººB C
=>
ººD F
buf
ººG J
.
ººJ K
ForEachByte
ººK V
(
ººV W
index
ººW \
,
ºº\ ]
length
ºº^ d
,
ººd e 
AsciiByteProcessor
ººf x
)
ººx y
==
ººz |
-
ºº} ~
$num
ºº~ 
;ºº Ä
static
ææ 
bool
ææ 
IsUtf8
ææ 
(
ææ 
IByteBuffer
ææ &
buf
ææ' *
,
ææ* +
int
ææ, /
index
ææ0 5
,
ææ5 6
int
ææ7 :
length
ææ; A
)
ææA B
{
øø 	
int
¿¿ 
endIndex
¿¿ 
=
¿¿ 
index
¿¿  
+
¿¿! "
length
¿¿# )
;
¿¿) *
while
¡¡ 
(
¡¡ 
index
¡¡ 
<
¡¡ 
endIndex
¡¡ #
)
¡¡# $
{
¬¬ 
byte
√√ 
b1
√√ 
=
√√ 
buf
√√ 
.
√√ 
GetByte
√√ %
(
√√% &
index
√√& +
++
√√+ -
)
√√- .
;
√√. /
byte
ƒƒ 
b2
ƒƒ 
,
ƒƒ 
b3
ƒƒ 
;
ƒƒ 
if
≈≈ 
(
≈≈ 
(
≈≈ 
b1
≈≈ 
&
≈≈ 
$num
≈≈ 
)
≈≈ 
==
≈≈  "
$num
≈≈# $
)
≈≈$ %
{
∆∆ 
continue
»» 
;
»» 
}
…… 
if
   
(
   
(
   
b1
   
&
   
$num
   
)
   
==
    "
$num
  # '
)
  ' (
{
ÀÀ 
if
—— 
(
—— 
index
—— 
>=
——  
endIndex
——! )
)
——) *
{
““ 
return
”” 
false
”” $
;
””$ %
}
‘‘ 
b2
’’ 
=
’’ 
buf
’’ 
.
’’ 
GetByte
’’ $
(
’’$ %
index
’’% *
++
’’* ,
)
’’, -
;
’’- .
if
÷÷ 
(
÷÷ 
(
÷÷ 
b2
÷÷ 
&
÷÷ 
$num
÷÷ "
)
÷÷" #
!=
÷÷$ &
$num
÷÷' +
)
÷÷+ ,
{
◊◊ 
return
ÿÿ 
false
ÿÿ $
;
ÿÿ$ %
}
ŸŸ 
if
⁄⁄ 
(
⁄⁄ 
(
⁄⁄ 
b1
⁄⁄ 
&
⁄⁄ 
$num
⁄⁄ "
)
⁄⁄" #
<
⁄⁄$ %
$num
⁄⁄& *
)
⁄⁄* +
{
€€ 
return
‹‹ 
false
‹‹ $
;
‹‹$ %
}
›› 
}
ﬁﬁ 
else
ﬂﬂ 
if
ﬂﬂ 
(
ﬂﬂ 
(
ﬂﬂ 
b1
ﬂﬂ 
&
ﬂﬂ 
$num
ﬂﬂ #
)
ﬂﬂ# $
==
ﬂﬂ% '
$num
ﬂﬂ( ,
)
ﬂﬂ, -
{
‡‡ 
if
ÈÈ 
(
ÈÈ 
index
ÈÈ 
>
ÈÈ 
endIndex
ÈÈ  (
-
ÈÈ) *
$num
ÈÈ+ ,
)
ÈÈ, -
{
ÍÍ 
return
ÎÎ 
false
ÎÎ $
;
ÎÎ$ %
}
ÏÏ 
b2
ÌÌ 
=
ÌÌ 
buf
ÌÌ 
.
ÌÌ 
GetByte
ÌÌ $
(
ÌÌ$ %
index
ÌÌ% *
++
ÌÌ* ,
)
ÌÌ, -
;
ÌÌ- .
b3
ÓÓ 
=
ÓÓ 
buf
ÓÓ 
.
ÓÓ 
GetByte
ÓÓ $
(
ÓÓ$ %
index
ÓÓ% *
++
ÓÓ* ,
)
ÓÓ, -
;
ÓÓ- .
if
ÔÔ 
(
ÔÔ 
(
ÔÔ 
b2
ÔÔ 
&
ÔÔ 
$num
ÔÔ "
)
ÔÔ" #
!=
ÔÔ$ &
$num
ÔÔ' +
||
ÔÔ, .
(
ÔÔ/ 0
b3
ÔÔ0 2
&
ÔÔ3 4
$num
ÔÔ5 9
)
ÔÔ9 :
!=
ÔÔ; =
$num
ÔÔ> B
)
ÔÔB C
{
 
return
ÒÒ 
false
ÒÒ $
;
ÒÒ$ %
}
ÚÚ 
if
ÛÛ 
(
ÛÛ 
(
ÛÛ 
b1
ÛÛ 
&
ÛÛ 
$num
ÛÛ "
)
ÛÛ" #
==
ÛÛ$ &
$num
ÛÛ' +
&&
ÛÛ, .
(
ÛÛ/ 0
b2
ÛÛ0 2
&
ÛÛ3 4
$num
ÛÛ5 9
)
ÛÛ9 :
<
ÛÛ; <
$num
ÛÛ= A
)
ÛÛA B
{
ÙÙ 
return
ıı 
false
ıı $
;
ıı$ %
}
ˆˆ 
if
˜˜ 
(
˜˜ 
(
˜˜ 
b1
˜˜ 
&
˜˜ 
$num
˜˜ "
)
˜˜" #
==
˜˜$ &
$num
˜˜' +
&&
˜˜, .
(
˜˜/ 0
b2
˜˜0 2
&
˜˜3 4
$num
˜˜5 9
)
˜˜9 :
>
˜˜; <
$num
˜˜= A
)
˜˜A B
{
¯¯ 
return
˘˘ 
false
˘˘ $
;
˘˘$ %
}
˙˙ 
}
˚˚ 
else
¸¸ 
if
¸¸ 
(
¸¸ 
(
¸¸ 
b1
¸¸ 
&
¸¸ 
$num
¸¸ #
)
¸¸# $
==
¸¸% '
$num
¸¸( ,
)
¸¸, -
{
˝˝ 
if
Ö	Ö	 
(
Ö	Ö	 
index
Ö	Ö	 
>
Ö	Ö	 
endIndex
Ö	Ö	  (
-
Ö	Ö	) *
$num
Ö	Ö	+ ,
)
Ö	Ö	, -
{
Ü	Ü	 
return
á	á	 
false
á	á	 $
;
á	á	$ %
}
à	à	 
b2
â	â	 
=
â	â	 
buf
â	â	 
.
â	â	 
GetByte
â	â	 $
(
â	â	$ %
index
â	â	% *
++
â	â	* ,
)
â	â	, -
;
â	â	- .
b3
ä	ä	 
=
ä	ä	 
buf
ä	ä	 
.
ä	ä	 
GetByte
ä	ä	 $
(
ä	ä	$ %
index
ä	ä	% *
++
ä	ä	* ,
)
ä	ä	, -
;
ä	ä	- .
byte
ã	ã	 
b4
ã	ã	 
=
ã	ã	 
buf
ã	ã	 !
.
ã	ã	! "
GetByte
ã	ã	" )
(
ã	ã	) *
index
ã	ã	* /
++
ã	ã	/ 1
)
ã	ã	1 2
;
ã	ã	2 3
if
å	å	 
(
å	å	 
(
å	å	 
b2
å	å	 
&
å	å	 
$num
å	å	 "
)
å	å	" #
!=
å	å	$ &
$num
å	å	' +
||
å	å	, .
(
å	å	/ 0
b3
å	å	0 2
&
å	å	3 4
$num
å	å	5 9
)
å	å	9 :
!=
å	å	; =
$num
å	å	> B
||
å	å	C E
(
å	å	F G
b4
å	å	G I
&
å	å	J K
$num
å	å	L P
)
å	å	P Q
!=
å	å	R T
$num
å	å	U Y
)
å	å	Y Z
{
ç	ç	 
return
è	è	 
false
è	è	 $
;
è	è	$ %
}
ê	ê	 
if
ë	ë	 
(
ë	ë	 
(
ë	ë	 
b1
ë	ë	 
&
ë	ë	 
$num
ë	ë	 "
)
ë	ë	" #
>
ë	ë	$ %
$num
ë	ë	& *
||
í	í	 
(
í	í	 
b1
í	í	 
&
í	í	  
$num
í	í	! %
)
í	í	% &
==
í	í	' )
$num
í	í	* .
&&
í	í	/ 1
(
í	í	2 3
b2
í	í	3 5
&
í	í	6 7
$num
í	í	8 <
)
í	í	< =
<
í	í	> ?
$num
í	í	@ D
||
ì	ì	 
(
ì	ì	 
b1
ì	ì	 
&
ì	ì	  
$num
ì	ì	! %
)
ì	ì	% &
==
ì	ì	' )
$num
ì	ì	* .
&&
ì	ì	/ 1
(
ì	ì	2 3
b2
ì	ì	3 5
&
ì	ì	6 7
$num
ì	ì	8 <
)
ì	ì	< =
>
ì	ì	> ?
$num
ì	ì	@ D
)
ì	ì	D E
{
î	î	 
return
ï	ï	 
false
ï	ï	 $
;
ï	ï	$ %
}
ñ	ñ	 
}
ó	ó	 
else
ò	ò	 
{
ô	ô	 
return
ö	ö	 
false
ö	ö	  
;
ö	ö	  !
}
õ	õ	 
}
ú	ú	 
return
û	û	 
true
û	û	 
;
û	û	 
}
ü	ü	 	
public
°	°	 
static
°	°	 
unsafe
°	°	 
int
°	°	  
SingleToInt32Bits
°	°	! 2
(
°	°	2 3
float
°	°	3 8
value
°	°	9 >
)
°	°	> ?
{
¢	¢	 	
return
£	£	 
*
£	£	 
(
£	£	 
int
£	£	 
*
£	£	 
)
£	£	 
(
£	£	 
&
£	£	 
value
£	£	 !
)
£	£	! "
;
£	£	" #
}
§	§	 	
public
¶	¶	 
static
¶	¶	 
unsafe
¶	¶	 
float
¶	¶	 "
Int32BitsToSingle
¶	¶	# 4
(
¶	¶	4 5
int
¶	¶	5 8
value
¶	¶	9 >
)
¶	¶	> ?
{
ß	ß	 	
return
®	®	 
*
®	®	 
(
®	®	 
float
®	®	 
*
®	®	 
)
®	®	 
(
®	®	 
&
®	®	 
value
®	®	 #
)
®	®	# $
;
®	®	$ %
}
©	©	 	
public
Æ	Æ	 
static
Æ	Æ	 
long
Æ	Æ	 
SwapLong
Æ	Æ	 #
(
Æ	Æ	# $
long
Æ	Æ	$ (
value
Æ	Æ	) .
)
Æ	Æ	. /
=>
Ø	Ø	 
(
Ø	Ø	 
(
Ø	Ø	 
SwapInt
Ø	Ø	 
(
Ø	Ø	 
(
Ø	Ø	 
int
Ø	Ø	 
)
Ø	Ø	 
value
Ø	Ø	 #
)
Ø	Ø	# $
&
Ø	Ø	% &
$num
Ø	Ø	' 1
)
Ø	Ø	1 2
<<
Ø	Ø	3 5
$num
Ø	Ø	6 8
)
Ø	Ø	8 9
|
∞	∞	 
(
∞	∞	 
SwapInt
∞	∞	 
(
∞	∞	 
(
∞	∞	 
int
∞	∞	 
)
∞	∞	  
(
∞	∞	  !
value
∞	∞	! &
>>
∞	∞	' )
$num
∞	∞	* ,
)
∞	∞	, -
)
∞	∞	- .
&
∞	∞	/ 0
$num
∞	∞	1 ;
)
∞	∞	; <
;
∞	∞	< =
public
µ	µ	 
static
µ	µ	 
int
µ	µ	 
SwapInt
µ	µ	 !
(
µ	µ	! "
int
µ	µ	" %
value
µ	µ	& +
)
µ	µ	+ ,
=>
∂	∂	 
(
∂	∂	 
(
∂	∂	 
	SwapShort
∂	∂	 
(
∂	∂	 
(
∂	∂	 
short
∂	∂	 !
)
∂	∂	! "
value
∂	∂	" '
)
∂	∂	' (
&
∂	∂	) *
$num
∂	∂	+ 1
)
∂	∂	1 2
<<
∂	∂	3 5
$num
∂	∂	6 8
)
∂	∂	8 9
|
∑	∑	 
(
∑	∑	 
	SwapShort
∑	∑	 
(
∑	∑	 
(
∑	∑	 
short
∑	∑	 #
)
∑	∑	# $
(
∑	∑	$ %
value
∑	∑	% *
>>
∑	∑	+ -
$num
∑	∑	. 0
)
∑	∑	0 1
)
∑	∑	1 2
&
∑	∑	3 4
$num
∑	∑	5 ;
)
∑	∑	; <
;
∑	∑	< =
public
º	º	 
static
º	º	 
short
º	º	 
	SwapShort
º	º	 %
(
º	º	% &
short
º	º	& +
value
º	º	, 1
)
º	º	1 2
=>
º	º	3 5
(
º	º	6 7
short
º	º	7 <
)
º	º	< =
(
º	º	= >
(
º	º	> ?
(
º	º	? @
value
º	º	@ E
&
º	º	F G
$num
º	º	H L
)
º	º	L M
<<
º	º	N P
$num
º	º	Q R
)
º	º	R S
|
º	º	T U
(
º	º	V W
value
º	º	W \
>>
º	º	] _
$num
º	º	` a
)
º	º	a b
&
º	º	c d
$num
º	º	e i
)
º	º	i j
;
º	º	j k
}
æ	æ	 
}ø	ø	 §
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ByteOrder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

enum 
	ByteOrder 
{ 
LittleEndian 
= 
$num 
, 
	BigEndian 
= 
$num 
} 
} ãµ
fC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\CompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class 
CompositeByteBuffer $
:% &.
"AbstractReferenceCountedByteBuffer' I
,I J
IEnumerableK V
<V W
IByteBufferW b
>b c
{ 
static 
readonly 
IList 
< 
IByteBuffer )
>) *
	EmptyList+ 4
=5 6
new7 :
ReadOnlyCollection; M
<M N
IByteBufferN Y
>Y Z
(Z [
new[ ^
IByteBuffer_ j
[j k
$numk l
]l m
)m n
;n o
class 
ComponentEntry 
{ 	
public 
readonly 
IByteBuffer '
Buffer( .
;. /
public 
readonly 
int 
Length  &
;& '
public 
int 
Offset 
; 
public 
int 
	EndOffset  
;  !
public 
ComponentEntry !
(! "
IByteBuffer" -
buffer. 4
)4 5
{   
this!! 
.!! 
Buffer!! 
=!! 
buffer!! $
;!!$ %
this"" 
."" 
Length"" 
="" 
buffer"" $
.""$ %
ReadableBytes""% 2
;""2 3
}## 
public%% 
void%% 
FreeIfNecessary%% '
(%%' (
)%%( )
=>%%* ,
this%%- 1
.%%1 2
Buffer%%2 8
.%%8 9
Release%%9 @
(%%@ A
)%%A B
;%%B C
}&& 	
static(( 
readonly(( 
ArraySegment(( $
<(($ %
byte((% )
>(() *
EmptyNioBuffer((+ 9
=((: ;
Unpooled((< D
.((D E
Empty((E J
.((J K
GetIoBuffer((K V
(((V W
)((W X
;((X Y
readonly**  
IByteBufferAllocator** %
	allocator**& /
;**/ 0
readonly++ 
bool++ 
direct++ 
;++ 
readonly,, 
List,, 
<,, 
ComponentEntry,, $
>,,$ %

components,,& 0
;,,0 1
readonly-- 
int-- 
maxNumComponents-- %
;--% &
bool// 
freed// 
;// 
public11 
CompositeByteBuffer11 "
(11" # 
IByteBufferAllocator11# 7
	allocator118 A
,11A B
bool11C G
direct11H N
,11N O
int11P S
maxNumComponents11T d
)11d e
:22 
base22 
(22 '
AbstractByteBufferAllocator22 .
.22. /
DefaultMaxCapacity22/ A
)22A B
{33 	
Contract44 
.44 
Requires44 
(44 
	allocator44 '
!=44( *
null44+ /
)44/ 0
;440 1
Contract55 
.55 
Requires55 
(55 
maxNumComponents55 .
>=55/ 1
$num552 3
)553 4
;554 5
this77 
.77 
	allocator77 
=77 
	allocator77 &
;77& '
this88 
.88 
direct88 
=88 
direct88  
;88  !
this99 
.99 
maxNumComponents99 !
=99" #
maxNumComponents99$ 4
;994 5
this:: 
.:: 

components:: 
=:: 
NewList:: %
(::% &
maxNumComponents::& 6
)::6 7
;::7 8
};; 	
public== 
CompositeByteBuffer== "
(==" # 
IByteBufferAllocator==# 7
	allocator==8 A
,==A B
bool==C G
direct==H N
,==N O
int==P S
maxNumComponents==T d
,==d e
params==f l
IByteBuffer==m x
[==x y
]==y z
buffers	=={ Ç
)
==Ç É
:>> 
this>> 
(>> 
	allocator>> 
,>> 
direct>> $
,>>$ %
maxNumComponents>>& 6
,>>6 7
buffers>>8 ?
,>>? @
$num>>A B
,>>B C
buffers>>D K
.>>K L
Length>>L R
)>>R S
{?? 	
}@@ 	
internalBB 
CompositeByteBufferBB $
(BB$ % 
IByteBufferAllocatorBB% 9
	allocatorBB: C
,BBC D
boolBBE I
directBBJ P
,BBP Q
intBBR U
maxNumComponentsBBV f
,BBf g
IByteBufferBBh s
[BBs t
]BBt u
buffersBBv }
,BB} ~
int	BB Ç
offset
BBÉ â
,
BBâ ä
int
BBã é
length
BBè ï
)
BBï ñ
:CC 
baseCC 
(CC '
AbstractByteBufferAllocatorCC .
.CC. /
DefaultMaxCapacityCC/ A
)CCA B
{DD 	
ContractEE 
.EE 
RequiresEE 
(EE 
	allocatorEE '
!=EE( *
nullEE+ /
)EE/ 0
;EE0 1
ContractFF 
.FF 
RequiresFF 
(FF 
maxNumComponentsFF .
>=FF/ 1
$numFF2 3
)FF3 4
;FF4 5
thisHH 
.HH 
	allocatorHH 
=HH 
	allocatorHH &
;HH& '
thisII 
.II 
directII 
=II 
directII  
;II  !
thisJJ 
.JJ 
maxNumComponentsJJ !
=JJ" #
maxNumComponentsJJ$ 4
;JJ4 5
thisKK 
.KK 

componentsKK 
=KK 
NewListKK %
(KK% &
maxNumComponentsKK& 6
)KK6 7
;KK7 8
thisMM 
.MM 
AddComponents0MM 
(MM  
falseMM  %
,MM% &
$numMM' (
,MM( )
buffersMM* 1
,MM1 2
offsetMM3 9
,MM9 :
lengthMM; A
)MMA B
;MMB C
thisNN 
.NN 
ConsolidateIfNeededNN $
(NN$ %
)NN% &
;NN& '
thisOO 
.OO 
	SetIndex0OO 
(OO 
$numOO 
,OO 
GetCapacityOO )
(OO) *
thisOO* .
.OO. /

componentsOO/ 9
)OO9 :
)OO: ;
;OO; <
}PP 	
publicRR 
CompositeByteBufferRR "
(RR" # 
IByteBufferAllocatorSS  
	allocatorSS! *
,SS* +
boolSS, 0
directSS1 7
,SS7 8
intSS9 <
maxNumComponentsSS= M
,SSM N
IEnumerableSSO Z
<SSZ [
IByteBufferSS[ f
>SSf g
buffersSSh o
)SSo p
:TT 
baseTT 
(TT '
AbstractByteBufferAllocatorTT .
.TT. /
DefaultMaxCapacityTT/ A
)TTA B
{UU 	
ContractVV 
.VV 
RequiresVV 
(VV 
	allocatorVV '
!=VV( *
nullVV+ /
)VV/ 0
;VV0 1
ContractWW 
.WW 
RequiresWW 
(WW 
maxNumComponentsWW .
>=WW/ 1
$numWW2 3
)WW3 4
;WW4 5
thisYY 
.YY 
	allocatorYY 
=YY 
	allocatorYY &
;YY& '
thisZZ 
.ZZ 
directZZ 
=ZZ 
directZZ  
;ZZ  !
this[[ 
.[[ 
maxNumComponents[[ !
=[[" #
maxNumComponents[[$ 4
;[[4 5
this\\ 
.\\ 

components\\ 
=\\ 
NewList\\ %
(\\% &
maxNumComponents\\& 6
)\\6 7
;\\7 8
this^^ 
.^^ 
AddComponents0^^ 
(^^  
false^^  %
,^^% &
$num^^' (
,^^( )
buffers^^* 1
)^^1 2
;^^2 3
this__ 
.__ 
ConsolidateIfNeeded__ $
(__$ %
)__% &
;__& '
this`` 
.`` 
	SetIndex0`` 
(`` 
$num`` 
,`` 
GetCapacity`` )
(``) *
this``* .
.``. /

components``/ 9
)``9 :
)``: ;
;``; <
}aa 	
staticcc 
Listcc 
<cc 
ComponentEntrycc "
>cc" #
NewListcc$ +
(cc+ ,
intcc, /
maxNumComponentscc0 @
)cc@ A
=>ccB D
newdd 
Listdd 
<dd 
ComponentEntrydd #
>dd# $
(dd$ %
Mathdd% )
.dd) *
Mindd* -
(dd- .'
AbstractByteBufferAllocatordd. I
.ddI J 
DefaultMaxComponentsddJ ^
,dd^ _
maxNumComponentsdd` p
)ddp q
)ddq r
;ddr s
internalgg 
CompositeByteBuffergg $
(gg$ % 
IByteBufferAllocatorgg% 9
	allocatorgg: C
)ggC D
:ggE F
baseggG K
(ggK L
intggL O
.ggO P
MaxValueggP X
)ggX Y
{hh 	
thisii 
.ii 
	allocatorii 
=ii 
	allocatorii &
;ii& '
thisjj 
.jj 
directjj 
=jj 
falsejj 
;jj  
thiskk 
.kk 
maxNumComponentskk !
=kk" #
$numkk$ %
;kk% &
thisll 
.ll 

componentsll 
=ll 
newll !
Listll" &
<ll& '
ComponentEntryll' 5
>ll5 6
(ll6 7
$numll7 8
)ll8 9
;ll9 :
}mm 	
publicuu 
virtualuu 
CompositeByteBufferuu *
AddComponentuu+ 7
(uu7 8
IByteBufferuu8 C
bufferuuD J
)uuJ K
=>uuL N
thisuuO S
.uuS T
AddComponentuuT `
(uu` a
falseuua f
,uuf g
bufferuuh n
)uun o
;uuo p
public}} 
virtual}} 
CompositeByteBuffer}} *
AddComponents}}+ 8
(}}8 9
params}}9 ?
IByteBuffer}}@ K
[}}K L
]}}L M
buffers}}N U
)}}U V
=>}}W Y
this}}Z ^
.}}^ _
AddComponents}}_ l
(}}l m
false}}m r
,}}r s
buffers}}t {
)}}{ |
;}}| }
public
ÖÖ 
virtual
ÖÖ !
CompositeByteBuffer
ÖÖ *
AddComponents
ÖÖ+ 8
(
ÖÖ8 9
IEnumerable
ÖÖ9 D
<
ÖÖD E
IByteBuffer
ÖÖE P
>
ÖÖP Q
buffers
ÖÖR Y
)
ÖÖY Z
=>
ÖÖ[ ]
this
ÖÖ^ b
.
ÖÖb c
AddComponents
ÖÖc p
(
ÖÖp q
false
ÖÖq v
,
ÖÖv w
buffers
ÖÖx 
)ÖÖ Ä
;ÖÖÄ Å
public
éé 
virtual
éé !
CompositeByteBuffer
éé *
AddComponent
éé+ 7
(
éé7 8
int
éé8 ;
cIndex
éé< B
,
ééB C
IByteBuffer
ééD O
buffer
ééP V
)
ééV W
=>
ééX Z
this
éé[ _
.
éé_ `
AddComponent
éé` l
(
éél m
false
éém r
,
éér s
cIndex
éét z
,
ééz {
bufferéé| Ç
)ééÇ É
;ééÉ Ñ
public
êê 
virtual
êê !
CompositeByteBuffer
êê *
AddComponent
êê+ 7
(
êê7 8
bool
êê8 <!
increaseWriterIndex
êê= P
,
êêP Q
IByteBuffer
êêR ]
buffer
êê^ d
)
êêd e
{
ëë 	
Contract
íí 
.
íí 
Requires
íí 
(
íí 
buffer
íí $
!=
íí% '
null
íí( ,
)
íí, -
;
íí- .
this
ìì 
.
ìì 
AddComponent0
ìì 
(
ìì !
increaseWriterIndex
ìì 2
,
ìì2 3
this
ìì4 8
.
ìì8 9

components
ìì9 C
.
ììC D
Count
ììD I
,
ììI J
buffer
ììK Q
)
ììQ R
;
ììR S
this
îî 
.
îî !
ConsolidateIfNeeded
îî $
(
îî$ %
)
îî% &
;
îî& '
return
ïï 
this
ïï 
;
ïï 
}
ññ 	
public
òò 
virtual
òò !
CompositeByteBuffer
òò *
AddComponents
òò+ 8
(
òò8 9
bool
òò9 =!
increaseWriterIndex
òò> Q
,
òòQ R
params
òòS Y
IByteBuffer
òòZ e
[
òòe f
]
òòf g
buffers
òòh o
)
òòo p
{
ôô 	
this
öö 
.
öö 
AddComponents0
öö 
(
öö  !
increaseWriterIndex
öö  3
,
öö3 4
this
öö5 9
.
öö9 :

components
öö: D
.
ööD E
Count
ööE J
,
ööJ K
buffers
ööL S
,
ööS T
$num
ööU V
,
ööV W
buffers
ööX _
.
öö_ `
Length
öö` f
)
ööf g
;
öög h
this
õõ 
.
õõ !
ConsolidateIfNeeded
õõ $
(
õõ$ %
)
õõ% &
;
õõ& '
return
úú 
this
úú 
;
úú 
}
ùù 	
public
üü 
virtual
üü !
CompositeByteBuffer
üü *
AddComponents
üü+ 8
(
üü8 9
bool
üü9 =!
increaseWriterIndex
üü> Q
,
üüQ R
IEnumerable
üüS ^
<
üü^ _
IByteBuffer
üü_ j
>
üüj k
buffers
üül s
)
üüs t
{
†† 	
this
°° 
.
°° 
AddComponents0
°° 
(
°°  !
increaseWriterIndex
°°  3
,
°°3 4
this
°°5 9
.
°°9 :

components
°°: D
.
°°D E
Count
°°E J
,
°°J K
buffers
°°L S
)
°°S T
;
°°T U
this
¢¢ 
.
¢¢ !
ConsolidateIfNeeded
¢¢ $
(
¢¢$ %
)
¢¢% &
;
¢¢& '
return
££ 
this
££ 
;
££ 
}
§§ 	
public
¶¶ 
virtual
¶¶ !
CompositeByteBuffer
¶¶ *
AddComponent
¶¶+ 7
(
¶¶7 8
bool
¶¶8 <!
increaseWriterIndex
¶¶= P
,
¶¶P Q
int
¶¶R U
cIndex
¶¶V \
,
¶¶\ ]
IByteBuffer
¶¶^ i
buffer
¶¶j p
)
¶¶p q
{
ßß 	
Contract
®® 
.
®® 
Requires
®® 
(
®® 
buffer
®® $
!=
®®% '
null
®®( ,
)
®®, -
;
®®- .
this
©© 
.
©© 
AddComponent0
©© 
(
©© !
increaseWriterIndex
©© 2
,
©©2 3
cIndex
©©4 :
,
©©: ;
buffer
©©< B
)
©©B C
;
©©C D
this
™™ 
.
™™ !
ConsolidateIfNeeded
™™ $
(
™™$ %
)
™™% &
;
™™& '
return
´´ 
this
´´ 
;
´´ 
}
¨¨ 	
int
ÆÆ 
AddComponent0
ÆÆ 
(
ÆÆ 
bool
ÆÆ !
increaseWriterIndex
ÆÆ 2
,
ÆÆ2 3
int
ÆÆ4 7
cIndex
ÆÆ8 >
,
ÆÆ> ?
IByteBuffer
ÆÆ@ K
buffer
ÆÆL R
)
ÆÆR S
{
ØØ 	
bool
∞∞ 
wasAdded
∞∞ 
=
∞∞ 
false
∞∞ !
;
∞∞! "
try
±± 
{
≤≤ 
this
≥≥ 
.
≥≥ !
CheckComponentIndex
≥≥ (
(
≥≥( )
cIndex
≥≥) /
)
≥≥/ 0
;
≥≥0 1
int
µµ 
readableBytes
µµ !
=
µµ" #
buffer
µµ$ *
.
µµ* +
ReadableBytes
µµ+ 8
;
µµ8 9
var
∏∏ 
c
∏∏ 
=
∏∏ 
new
∏∏ 
ComponentEntry
∏∏ *
(
∏∏* +
buffer
∏∏+ 1
.
∏∏1 2
Slice
∏∏2 7
(
∏∏7 8
)
∏∏8 9
)
∏∏9 :
;
∏∏: ;
if
ππ 
(
ππ 
cIndex
ππ 
==
ππ 
this
ππ "
.
ππ" #

components
ππ# -
.
ππ- .
Count
ππ. 3
)
ππ3 4
{
∫∫ 
this
ªª 
.
ªª 

components
ªª #
.
ªª# $
Add
ªª$ '
(
ªª' (
c
ªª( )
)
ªª) *
;
ªª* +
wasAdded
ºº 
=
ºº 
true
ºº #
;
ºº# $
if
ΩΩ 
(
ΩΩ 
cIndex
ΩΩ 
==
ΩΩ !
$num
ΩΩ" #
)
ΩΩ# $
{
ææ 
c
øø 
.
øø 
	EndOffset
øø #
=
øø$ %
readableBytes
øø& 3
;
øø3 4
}
¿¿ 
else
¡¡ 
{
¬¬ 
ComponentEntry
√√ &
prev
√√' +
=
√√, -
this
√√. 2
.
√√2 3

components
√√3 =
[
√√= >
cIndex
√√> D
-
√√E F
$num
√√G H
]
√√H I
;
√√I J
c
ƒƒ 
.
ƒƒ 
Offset
ƒƒ  
=
ƒƒ! "
prev
ƒƒ# '
.
ƒƒ' (
	EndOffset
ƒƒ( 1
;
ƒƒ1 2
c
≈≈ 
.
≈≈ 
	EndOffset
≈≈ #
=
≈≈$ %
c
≈≈& '
.
≈≈' (
Offset
≈≈( .
+
≈≈/ 0
readableBytes
≈≈1 >
;
≈≈> ?
}
∆∆ 
}
«« 
else
»» 
{
…… 
this
   
.
   

components
   #
.
  # $
Insert
  $ *
(
  * +
cIndex
  + 1
,
  1 2
c
  3 4
)
  4 5
;
  5 6
wasAdded
ÀÀ 
=
ÀÀ 
true
ÀÀ #
;
ÀÀ# $
if
ÃÃ 
(
ÃÃ 
readableBytes
ÃÃ %
!=
ÃÃ& (
$num
ÃÃ) *
)
ÃÃ* +
{
ÕÕ 
this
ŒŒ 
.
ŒŒ $
UpdateComponentOffsets
ŒŒ 3
(
ŒŒ3 4
cIndex
ŒŒ4 :
)
ŒŒ: ;
;
ŒŒ; <
}
œœ 
}
–– 
if
—— 
(
—— !
increaseWriterIndex
—— '
)
——' (
{
““ 
this
”” 
.
”” 
SetWriterIndex
”” '
(
””' (
this
””( ,
.
””, -
WriterIndex
””- 8
+
””9 :
buffer
””; A
.
””A B
ReadableBytes
””B O
)
””O P
;
””P Q
}
‘‘ 
return
’’ 
cIndex
’’ 
;
’’ 
}
÷÷ 
finally
◊◊ 
{
ÿÿ 
if
ŸŸ 
(
ŸŸ 
!
ŸŸ 
wasAdded
ŸŸ 
)
ŸŸ 
{
⁄⁄ 
buffer
€€ 
.
€€ 
Release
€€ "
(
€€" #
)
€€# $
;
€€$ %
}
‹‹ 
}
›› 
}
ﬁﬁ 	
public
ÁÁ 
virtual
ÁÁ !
CompositeByteBuffer
ÁÁ *
AddComponents
ÁÁ+ 8
(
ÁÁ8 9
int
ÁÁ9 <
cIndex
ÁÁ= C
,
ÁÁC D
params
ÁÁE K
IByteBuffer
ÁÁL W
[
ÁÁW X
]
ÁÁX Y
buffers
ÁÁZ a
)
ÁÁa b
{
ËË 	
this
ÈÈ 
.
ÈÈ 
AddComponents0
ÈÈ 
(
ÈÈ  
false
ÈÈ  %
,
ÈÈ% &
cIndex
ÈÈ' -
,
ÈÈ- .
buffers
ÈÈ/ 6
,
ÈÈ6 7
$num
ÈÈ8 9
,
ÈÈ9 :
buffers
ÈÈ; B
.
ÈÈB C
Length
ÈÈC I
)
ÈÈI J
;
ÈÈJ K
this
ÍÍ 
.
ÍÍ !
ConsolidateIfNeeded
ÍÍ $
(
ÍÍ$ %
)
ÍÍ% &
;
ÍÍ& '
return
ÎÎ 
this
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
int
ÓÓ 
AddComponents0
ÓÓ 
(
ÓÓ 
bool
ÓÓ !
increaseWriterIndex
ÓÓ  3
,
ÓÓ3 4
int
ÓÓ5 8
cIndex
ÓÓ9 ?
,
ÓÓ? @
IByteBuffer
ÓÓA L
[
ÓÓL M
]
ÓÓM N
buffers
ÓÓO V
,
ÓÓV W
int
ÓÓX [
offset
ÓÓ\ b
,
ÓÓb c
int
ÓÓd g
len
ÓÓh k
)
ÓÓk l
{
ÔÔ 	
Contract
 
.
 
Requires
 
(
 
buffers
 %
!=
& (
null
) -
)
- .
;
. /
int
ÒÒ 
i
ÒÒ 
=
ÒÒ 
offset
ÒÒ 
;
ÒÒ 
try
ÚÚ 
{
ÛÛ 
this
ÙÙ 
.
ÙÙ !
CheckComponentIndex
ÙÙ (
(
ÙÙ( )
cIndex
ÙÙ) /
)
ÙÙ/ 0
;
ÙÙ0 1
while
˜˜ 
(
˜˜ 
i
˜˜ 
<
˜˜ 
len
˜˜ 
)
˜˜ 
{
¯¯ 
IByteBuffer
˚˚ 
b
˚˚  !
=
˚˚" #
buffers
˚˚$ +
[
˚˚+ ,
i
˚˚, -
++
˚˚- /
]
˚˚/ 0
;
˚˚0 1
if
¸¸ 
(
¸¸ 
b
¸¸ 
==
¸¸ 
null
¸¸ !
)
¸¸! "
{
˝˝ 
break
˛˛ 
;
˛˛ 
}
ˇˇ 
cIndex
ÄÄ 
=
ÄÄ 
this
ÄÄ !
.
ÄÄ! "
AddComponent0
ÄÄ" /
(
ÄÄ/ 0!
increaseWriterIndex
ÄÄ0 C
,
ÄÄC D
cIndex
ÄÄE K
,
ÄÄK L
b
ÄÄM N
)
ÄÄN O
+
ÄÄP Q
$num
ÄÄR S
;
ÄÄS T
int
ÅÅ 
size
ÅÅ 
=
ÅÅ 
this
ÅÅ #
.
ÅÅ# $

components
ÅÅ$ .
.
ÅÅ. /
Count
ÅÅ/ 4
;
ÅÅ4 5
if
ÇÇ 
(
ÇÇ 
cIndex
ÇÇ 
>
ÇÇ  
size
ÇÇ! %
)
ÇÇ% &
{
ÉÉ 
cIndex
ÑÑ 
=
ÑÑ  
size
ÑÑ! %
;
ÑÑ% &
}
ÖÖ 
}
ÜÜ 
return
àà 
cIndex
àà 
;
àà 
}
ââ 
finally
ää 
{
ãã 
for
åå 
(
åå 
;
åå 
i
åå 
<
åå 
len
åå 
;
åå 
++
åå  "
i
åå" #
)
åå# $
{
çç 
IByteBuffer
éé 
b
éé  !
=
éé" #
buffers
éé$ +
[
éé+ ,
i
éé, -
]
éé- .
;
éé. /
if
èè 
(
èè 
b
èè 
!=
èè 
null
èè !
)
èè! "
{
êê 
try
ëë 
{
íí 
b
ìì 
.
ìì 
Release
ìì %
(
ìì% &
)
ìì& '
;
ìì' (
}
îî 
catch
ïï 
{
ññ 
}
òò 
}
ôô 
}
öö 
}
õõ 
}
úú 	
public
•• 
virtual
•• !
CompositeByteBuffer
•• *
AddComponents
••+ 8
(
••8 9
int
••9 <
cIndex
••= C
,
••C D
IEnumerable
••E P
<
••P Q
IByteBuffer
••Q \
>
••\ ]
buffers
••^ e
)
••e f
{
¶¶ 	
this
ßß 
.
ßß 
AddComponents0
ßß 
(
ßß  
false
ßß  %
,
ßß% &
cIndex
ßß' -
,
ßß- .
buffers
ßß/ 6
)
ßß6 7
;
ßß7 8
this
®® 
.
®® !
ConsolidateIfNeeded
®® $
(
®®$ %
)
®®% &
;
®®& '
return
©© 
this
©© 
;
©© 
}
™™ 	
int
¨¨ 
AddComponents0
¨¨ 
(
¨¨ 
bool
¨¨ 
increaseIndex
¨¨  -
,
¨¨- .
int
¨¨/ 2
cIndex
¨¨3 9
,
¨¨9 :
IEnumerable
¨¨; F
<
¨¨F G
IByteBuffer
¨¨G R
>
¨¨R S
buffers
¨¨T [
)
¨¨[ \
{
≠≠ 	
Contract
ÆÆ 
.
ÆÆ 
Requires
ÆÆ 
(
ÆÆ 
buffers
ÆÆ %
!=
ÆÆ& (
null
ÆÆ) -
)
ÆÆ- .
;
ÆÆ. /
if
∞∞ 
(
∞∞ 
buffers
∞∞ 
is
∞∞ 
IByteBuffer
∞∞ &
buffer
∞∞' -
)
∞∞- .
{
±± 
return
≥≥ 
this
≥≥ 
.
≥≥ 
AddComponent0
≥≥ )
(
≥≥) *
increaseIndex
≥≥* 7
,
≥≥7 8
cIndex
≥≥9 ?
,
≥≥? @
buffer
≥≥A G
)
≥≥G H
;
≥≥H I
}
¥¥ 
IByteBuffer
∂∂ 
[
∂∂ 
]
∂∂ 
array
∂∂ 
=
∂∂  !
buffers
∂∂" )
.
∂∂) *
ToArray
∂∂* 1
(
∂∂1 2
)
∂∂2 3
;
∂∂3 4
return
∑∑ 
this
∑∑ 
.
∑∑ 
AddComponents0
∑∑ &
(
∑∑& '
increaseIndex
∑∑' 4
,
∑∑4 5
cIndex
∑∑6 <
,
∑∑< =
array
∑∑> C
,
∑∑C D
$num
∑∑E F
,
∑∑F G
array
∑∑H M
.
∑∑M N
Length
∑∑N T
)
∑∑T U
;
∑∑U V
}
∏∏ 	
void
ææ !
ConsolidateIfNeeded
ææ  
(
ææ  !
)
ææ! "
{
øø 	
int
¬¬ 
numComponents
¬¬ 
=
¬¬ 
this
¬¬  $
.
¬¬$ %

components
¬¬% /
.
¬¬/ 0
Count
¬¬0 5
;
¬¬5 6
if
√√ 
(
√√ 
numComponents
√√ 
>
√√ 
this
√√  $
.
√√$ %
MaxNumComponents
√√% 5
)
√√5 6
{
ƒƒ 
int
≈≈ 
capacity
≈≈ 
=
≈≈ 
this
≈≈ #
.
≈≈# $

components
≈≈$ .
[
≈≈. /
numComponents
≈≈/ <
-
≈≈= >
$num
≈≈? @
]
≈≈@ A
.
≈≈A B
	EndOffset
≈≈B K
;
≈≈K L
IByteBuffer
«« 
consolidated
«« (
=
««) *
this
««+ /
.
««/ 0
AllocateBuffer
««0 >
(
««> ?
capacity
««? G
)
««G H
;
««H I
for
   
(
   
int
   
i
   
=
   
$num
   
;
   
i
    !
<
  " #
numComponents
  $ 1
;
  1 2
i
  3 4
++
  4 6
)
  6 7
{
ÀÀ 
ComponentEntry
ÃÃ "
c1
ÃÃ# %
=
ÃÃ& '
this
ÃÃ( ,
.
ÃÃ, -

components
ÃÃ- 7
[
ÃÃ7 8
i
ÃÃ8 9
]
ÃÃ9 :
;
ÃÃ: ;
IByteBuffer
ÕÕ 
b
ÕÕ  !
=
ÕÕ" #
c1
ÕÕ$ &
.
ÕÕ& '
Buffer
ÕÕ' -
;
ÕÕ- .
consolidated
ŒŒ  
.
ŒŒ  !

WriteBytes
ŒŒ! +
(
ŒŒ+ ,
b
ŒŒ, -
)
ŒŒ- .
;
ŒŒ. /
c1
œœ 
.
œœ 
FreeIfNecessary
œœ &
(
œœ& '
)
œœ' (
;
œœ( )
}
–– 
var
—— 
c
—— 
=
—— 
new
—— 
ComponentEntry
—— *
(
——* +
consolidated
——+ 7
)
——7 8
;
——8 9
c
““ 
.
““ 
	EndOffset
““ 
=
““ 
c
““ 
.
““  
Length
““  &
;
““& '
this
”” 
.
”” 

components
”” 
.
””  
Clear
””  %
(
””% &
)
””& '
;
””' (
this
‘‘ 
.
‘‘ 

components
‘‘ 
.
‘‘  
Add
‘‘  #
(
‘‘# $
c
‘‘$ %
)
‘‘% &
;
‘‘& '
}
’’ 
}
÷÷ 	
void
ÿÿ !
CheckComponentIndex
ÿÿ  
(
ÿÿ  !
int
ÿÿ! $
cIndex
ÿÿ% +
)
ÿÿ+ ,
{
ŸŸ 	
this
⁄⁄ 
.
⁄⁄ 
EnsureAccessible
⁄⁄ !
(
⁄⁄! "
)
⁄⁄" #
;
⁄⁄# $
if
€€ 
(
€€ 
cIndex
€€ 
<
€€ 
$num
€€ 
||
€€ 
cIndex
€€ $
>
€€% &
this
€€' +
.
€€+ ,

components
€€, 6
.
€€6 7
Count
€€7 <
)
€€< =
{
‹‹ 
throw
›› 
new
›› )
ArgumentOutOfRangeException
›› 5
(
››5 6
$"
››6 8
$str
››8 @
{
››@ A
cIndex
››A G
}
››G H
$str
››H m
{
››m n
this
››n r
.
››r s

components
››s }
.
››} ~
Count››~ É
}››É Ñ
$str››Ñ Ü
"››Ü á
)››á à
;››à â
}
ﬁﬁ 
}
ﬂﬂ 	
void
·· !
CheckComponentIndex
··  
(
··  !
int
··! $
cIndex
··% +
,
··+ ,
int
··- 0
numComponents
··1 >
)
··> ?
{
‚‚ 	
this
„„ 
.
„„ 
EnsureAccessible
„„ !
(
„„! "
)
„„" #
;
„„# $
if
‰‰ 
(
‰‰ 
cIndex
‰‰ 
<
‰‰ 
$num
‰‰ 
||
‰‰ 
cIndex
‰‰ $
+
‰‰% &
numComponents
‰‰' 4
>
‰‰5 6
this
‰‰7 ;
.
‰‰; <

components
‰‰< F
.
‰‰F G
Count
‰‰G L
)
‰‰L M
{
ÂÂ 
throw
ÊÊ 
new
ÊÊ )
ArgumentOutOfRangeException
ÊÊ 5
(
ÊÊ5 6
$"
ÊÊ6 8
$str
ÊÊ8 @
{
ÊÊ@ A
cIndex
ÊÊA G
}
ÊÊG H
$str
ÊÊH Y
{
ÊÊY Z
numComponents
ÊÊZ g
}
ÊÊg h
$str
ÊÊh i
"
ÊÊi j
+
ÊÊk l
$"
ÊÊm o
$strÊÊo ∂
{ÊÊ∂ ∑
thisÊÊ∑ ª
.ÊÊª º

componentsÊÊº ∆
.ÊÊ∆ «
CountÊÊ« Ã
}ÊÊÃ Õ
$strÊÊÕ œ
"ÊÊœ –
)ÊÊ– —
;ÊÊ— “
}
ÁÁ 
}
ËË 	
void
ÍÍ $
UpdateComponentOffsets
ÍÍ #
(
ÍÍ# $
int
ÍÍ$ '
cIndex
ÍÍ( .
)
ÍÍ. /
{
ÎÎ 	
int
ÏÏ 
size
ÏÏ 
=
ÏÏ 
this
ÏÏ 
.
ÏÏ 

components
ÏÏ &
.
ÏÏ& '
Count
ÏÏ' ,
;
ÏÏ, -
if
ÌÌ 
(
ÌÌ 
size
ÌÌ 
<=
ÌÌ 
cIndex
ÌÌ 
)
ÌÌ 
{
ÓÓ 
return
ÔÔ 
;
ÔÔ 
}
 
ComponentEntry
ÚÚ 
c
ÚÚ 
=
ÚÚ 
this
ÚÚ #
.
ÚÚ# $

components
ÚÚ$ .
[
ÚÚ. /
cIndex
ÚÚ/ 5
]
ÚÚ5 6
;
ÚÚ6 7
if
ÛÛ 
(
ÛÛ 
cIndex
ÛÛ 
==
ÛÛ 
$num
ÛÛ 
)
ÛÛ 
{
ÙÙ 
c
ıı 
.
ıı 
Offset
ıı 
=
ıı 
$num
ıı 
;
ıı 
c
ˆˆ 
.
ˆˆ 
	EndOffset
ˆˆ 
=
ˆˆ 
c
ˆˆ 
.
ˆˆ  
Length
ˆˆ  &
;
ˆˆ& '
cIndex
˜˜ 
++
˜˜ 
;
˜˜ 
}
¯¯ 
for
˙˙ 
(
˙˙ 
int
˙˙ 
i
˙˙ 
=
˙˙ 
cIndex
˙˙ 
;
˙˙  
i
˙˙! "
<
˙˙# $
size
˙˙% )
;
˙˙) *
i
˙˙+ ,
++
˙˙, .
)
˙˙. /
{
˚˚ 
ComponentEntry
¸¸ 
prev
¸¸ #
=
¸¸$ %
this
¸¸& *
.
¸¸* +

components
¸¸+ 5
[
¸¸5 6
i
¸¸6 7
-
¸¸8 9
$num
¸¸: ;
]
¸¸; <
;
¸¸< =
ComponentEntry
˝˝ 
cur
˝˝ "
=
˝˝# $
this
˝˝% )
.
˝˝) *

components
˝˝* 4
[
˝˝4 5
i
˝˝5 6
]
˝˝6 7
;
˝˝7 8
cur
˛˛ 
.
˛˛ 
Offset
˛˛ 
=
˛˛ 
prev
˛˛ !
.
˛˛! "
	EndOffset
˛˛" +
;
˛˛+ ,
cur
ˇˇ 
.
ˇˇ 
	EndOffset
ˇˇ 
=
ˇˇ 
cur
ˇˇ  #
.
ˇˇ# $
Offset
ˇˇ$ *
+
ˇˇ+ ,
cur
ˇˇ- 0
.
ˇˇ0 1
Length
ˇˇ1 7
;
ˇˇ7 8
}
ÄÄ 
}
ÅÅ 	
public
áá 
virtual
áá !
CompositeByteBuffer
áá *
RemoveComponent
áá+ :
(
áá: ;
int
áá; >
cIndex
áá? E
)
ááE F
{
àà 	
this
ââ 
.
ââ !
CheckComponentIndex
ââ $
(
ââ$ %
cIndex
ââ% +
)
ââ+ ,
;
ââ, -
ComponentEntry
ää 
comp
ää 
=
ää  !
this
ää" &
.
ää& '

components
ää' 1
[
ää1 2
cIndex
ää2 8
]
ää8 9
;
ää9 :
this
ãã 
.
ãã 

components
ãã 
.
ãã 
RemoveAt
ãã $
(
ãã$ %
cIndex
ãã% +
)
ãã+ ,
;
ãã, -
comp
åå 
.
åå 
FreeIfNecessary
åå  
(
åå  !
)
åå! "
;
åå" #
if
çç 
(
çç 
comp
çç 
.
çç 
Length
çç 
>
çç 
$num
çç 
)
çç  
{
éé 
this
êê 
.
êê $
UpdateComponentOffsets
êê +
(
êê+ ,
cIndex
êê, 2
)
êê2 3
;
êê3 4
}
ëë 
return
íí 
this
íí 
;
íí 
}
ìì 	
public
öö 
virtual
öö !
CompositeByteBuffer
öö *
RemoveComponents
öö+ ;
(
öö; <
int
öö< ?
cIndex
öö@ F
,
ööF G
int
ööH K
numComponents
ööL Y
)
ööY Z
{
õõ 	
this
úú 
.
úú !
CheckComponentIndex
úú $
(
úú$ %
cIndex
úú% +
,
úú+ ,
numComponents
úú- :
)
úú: ;
;
úú; <
if
ûû 
(
ûû 
numComponents
ûû 
==
ûû  
$num
ûû! "
)
ûû" #
{
üü 
return
†† 
this
†† 
;
†† 
}
°° 
bool
¢¢ 
needsUpdate
¢¢ 
=
¢¢ 
false
¢¢ $
;
¢¢$ %
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
cIndex
££ 
+
££  !
numComponents
££" /
;
££/ 0
i
££1 2
>=
££3 5
cIndex
££6 <
;
££< =
i
££> ?
--
££? A
)
££A B
{
§§ 
ComponentEntry
•• 
c
••  
=
••! "
this
••# '
.
••' (

components
••( 2
[
••2 3
i
••3 4
]
••4 5
;
••5 6
needsUpdate
¶¶ 
|=
¶¶ 
c
¶¶  
.
¶¶  !
Length
¶¶! '
>
¶¶( )
$num
¶¶* +
;
¶¶+ ,
c
ßß 
.
ßß 
FreeIfNecessary
ßß !
(
ßß! "
)
ßß" #
;
ßß# $
this
®® 
.
®® 

components
®® 
.
®®  
RemoveAt
®®  (
(
®®( )
i
®®) *
)
®®* +
;
®®+ ,
}
©© 
if
´´ 
(
´´ 
needsUpdate
´´ 
)
´´ 
{
¨¨ 
this
ÆÆ 
.
ÆÆ $
UpdateComponentOffsets
ÆÆ +
(
ÆÆ+ ,
cIndex
ÆÆ, 2
)
ÆÆ2 3
;
ÆÆ3 4
}
ØØ 
return
∞∞ 
this
∞∞ 
;
∞∞ 
}
±± 	
public
≥≥ 
virtual
≥≥ 
IEnumerator
≥≥ "
<
≥≥" #
IByteBuffer
≥≥# .
>
≥≥. /
GetEnumerator
≥≥0 =
(
≥≥= >
)
≥≥> ?
{
¥¥ 	
this
µµ 
.
µµ 
EnsureAccessible
µµ !
(
µµ! "
)
µµ" #
;
µµ# $
foreach
∂∂ 
(
∂∂ 
ComponentEntry
∂∂ #
c
∂∂$ %
in
∂∂& (
this
∂∂) -
.
∂∂- .

components
∂∂. 8
)
∂∂8 9
{
∑∑ 
yield
∏∏ 
return
∏∏ 
c
∏∏ 
.
∏∏ 
Buffer
∏∏ %
;
∏∏% &
}
ππ 
}
∫∫ 	
IEnumerator
ºº 
IEnumerable
ºº 
.
ºº  
GetEnumerator
ºº  -
(
ºº- .
)
ºº. /
=>
ºº0 2
this
ºº3 7
.
ºº7 8
GetEnumerator
ºº8 E
(
ººE F
)
ººF G
;
ººG H
public
¡¡ 
virtual
¡¡ 
IList
¡¡ 
<
¡¡ 
IByteBuffer
¡¡ (
>
¡¡( )
	Decompose
¡¡* 3
(
¡¡3 4
int
¡¡4 7
offset
¡¡8 >
,
¡¡> ?
int
¡¡@ C
length
¡¡D J
)
¡¡J K
{
¬¬ 	
this
√√ 
.
√√ 

CheckIndex
√√ 
(
√√ 
offset
√√ "
,
√√" #
length
√√$ *
)
√√* +
;
√√+ ,
if
ƒƒ 
(
ƒƒ 
length
ƒƒ 
==
ƒƒ 
$num
ƒƒ 
)
ƒƒ 
{
≈≈ 
return
∆∆ 
	EmptyList
∆∆  
;
∆∆  !
}
«« 
int
…… 
componentId
…… 
=
…… 
this
…… "
.
……" #
ToComponentIndex
……# 3
(
……3 4
offset
……4 :
)
……: ;
;
……; <
var
   
slice
   
=
   
new
   
List
    
<
    !
IByteBuffer
  ! ,
>
  , -
(
  - .
this
  . 2
.
  2 3

components
  3 =
.
  = >
Count
  > C
)
  C D
;
  D E
ComponentEntry
ÕÕ 
firstC
ÕÕ !
=
ÕÕ" #
this
ÕÕ$ (
.
ÕÕ( )

components
ÕÕ) 3
[
ÕÕ3 4
componentId
ÕÕ4 ?
]
ÕÕ? @
;
ÕÕ@ A
IByteBuffer
ŒŒ 
first
ŒŒ 
=
ŒŒ 
firstC
ŒŒ  &
.
ŒŒ& '
Buffer
ŒŒ' -
.
ŒŒ- .
	Duplicate
ŒŒ. 7
(
ŒŒ7 8
)
ŒŒ8 9
;
ŒŒ9 :
first
œœ 
.
œœ 
SetReaderIndex
œœ  
(
œœ  !
offset
œœ! '
-
œœ( )
firstC
œœ* 0
.
œœ0 1
Offset
œœ1 7
)
œœ7 8
;
œœ8 9
IByteBuffer
—— 
buffer
—— 
=
——  
first
——! &
;
——& '
int
““ 
bytesToSlice
““ 
=
““ 
length
““ %
;
““% &
do
”” 
{
‘‘ 
int
’’ 
readableBytes
’’ !
=
’’" #
buffer
’’$ *
.
’’* +
ReadableBytes
’’+ 8
;
’’8 9
if
÷÷ 
(
÷÷ 
bytesToSlice
÷÷  
<=
÷÷! #
readableBytes
÷÷$ 1
)
÷÷1 2
{
◊◊ 
buffer
ŸŸ 
.
ŸŸ 
SetWriterIndex
ŸŸ )
(
ŸŸ) *
buffer
ŸŸ* 0
.
ŸŸ0 1
ReaderIndex
ŸŸ1 <
+
ŸŸ= >
bytesToSlice
ŸŸ? K
)
ŸŸK L
;
ŸŸL M
slice
⁄⁄ 
.
⁄⁄ 
Add
⁄⁄ 
(
⁄⁄ 
buffer
⁄⁄ $
)
⁄⁄$ %
;
⁄⁄% &
break
€€ 
;
€€ 
}
‹‹ 
else
›› 
{
ﬁﬁ 
slice
‡‡ 
.
‡‡ 
Add
‡‡ 
(
‡‡ 
buffer
‡‡ $
)
‡‡$ %
;
‡‡% &
bytesToSlice
··  
-=
··! #
readableBytes
··$ 1
;
··1 2
componentId
‚‚ 
++
‚‚ !
;
‚‚! "
buffer
ÂÂ 
=
ÂÂ 
this
ÂÂ !
.
ÂÂ! "

components
ÂÂ" ,
[
ÂÂ, -
componentId
ÂÂ- 8
]
ÂÂ8 9
.
ÂÂ9 :
Buffer
ÂÂ: @
.
ÂÂ@ A
	Duplicate
ÂÂA J
(
ÂÂJ K
)
ÂÂK L
;
ÂÂL M
}
ÊÊ 
}
ÁÁ 
while
ËË 
(
ËË 
bytesToSlice
ËË 
>
ËË  !
$num
ËË" #
)
ËË# $
;
ËË$ %
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ 
slice
ÎÎ  %
.
ÎÎ% &
Count
ÎÎ& +
;
ÎÎ+ ,
i
ÎÎ- .
++
ÎÎ. 0
)
ÎÎ0 1
{
ÏÏ 
slice
ÌÌ 
[
ÌÌ 
i
ÌÌ 
]
ÌÌ 
=
ÌÌ 
slice
ÌÌ  
[
ÌÌ  !
i
ÌÌ! "
]
ÌÌ" #
.
ÌÌ# $
Slice
ÌÌ$ )
(
ÌÌ) *
)
ÌÌ* +
;
ÌÌ+ ,
}
ÓÓ 
return
 
slice
 
;
 
}
ÒÒ 	
public
ÛÛ 
override
ÛÛ 
int
ÛÛ 
IoBufferCount
ÛÛ )
{
ÙÙ 	
get
ıı 
{
ˆˆ 
switch
˜˜ 
(
˜˜ 
this
˜˜ 
.
˜˜ 

components
˜˜ '
.
˜˜' (
Count
˜˜( -
)
˜˜- .
{
¯¯ 
case
˘˘ 
$num
˘˘ 
:
˘˘ 
return
˙˙ 
$num
˙˙  
;
˙˙  !
case
˚˚ 
$num
˚˚ 
:
˚˚ 
return
¸¸ 
this
¸¸ #
.
¸¸# $

components
¸¸$ .
[
¸¸. /
$num
¸¸/ 0
]
¸¸0 1
.
¸¸1 2
Buffer
¸¸2 8
.
¸¸8 9
IoBufferCount
¸¸9 F
;
¸¸F G
default
˝˝ 
:
˝˝ 
int
˛˛ 
count
˛˛ !
=
˛˛" #
$num
˛˛$ %
;
˛˛% &
int
ˇˇ 
componentsCount
ˇˇ +
=
ˇˇ, -
this
ˇˇ. 2
.
ˇˇ2 3

components
ˇˇ3 =
.
ˇˇ= >
Count
ˇˇ> C
;
ˇˇC D
for
ÄÄ 
(
ÄÄ 
int
ÄÄ  
i
ÄÄ! "
=
ÄÄ# $
$num
ÄÄ% &
;
ÄÄ& '
i
ÄÄ( )
<
ÄÄ* +
componentsCount
ÄÄ, ;
;
ÄÄ; <
i
ÄÄ= >
++
ÄÄ> @
)
ÄÄ@ A
{
ÅÅ 
ComponentEntry
ÇÇ *
c
ÇÇ+ ,
=
ÇÇ- .
this
ÇÇ/ 3
.
ÇÇ3 4

components
ÇÇ4 >
[
ÇÇ> ?
i
ÇÇ? @
]
ÇÇ@ A
;
ÇÇA B
count
ÉÉ !
+=
ÉÉ" $
c
ÉÉ% &
.
ÉÉ& '
Buffer
ÉÉ' -
.
ÉÉ- .
IoBufferCount
ÉÉ. ;
;
ÉÉ; <
}
ÑÑ 
return
ÖÖ 
count
ÖÖ $
;
ÖÖ$ %
}
ÜÜ 
}
áá 
}
àà 	
public
ää 
override
ää 
ArraySegment
ää $
<
ää$ %
byte
ää% )
>
ää) *
GetIoBuffer
ää+ 6
(
ää6 7
int
ää7 :
index
ää; @
,
ää@ A
int
ääB E
length
ääF L
)
ääL M
{
ãã 	
this
åå 
.
åå 

CheckIndex
åå 
(
åå 
index
åå !
,
åå! "
length
åå# )
)
åå) *
;
åå* +
switch
éé 
(
éé 
this
éé 
.
éé 

components
éé #
.
éé# $
Count
éé$ )
)
éé) *
{
èè 
case
êê 
$num
êê 
:
êê 
return
ëë 
EmptyNioBuffer
ëë )
;
ëë) *
case
íí 
$num
íí 
:
íí 
IByteBuffer
ìì 
buf
ìì  #
=
ìì$ %
this
ìì& *
.
ìì* +

components
ìì+ 5
[
ìì5 6
$num
ìì6 7
]
ìì7 8
.
ìì8 9
Buffer
ìì9 ?
;
ìì? @
if
îî 
(
îî 
buf
îî 
.
îî 
IoBufferCount
îî )
==
îî* ,
$num
îî- .
)
îî. /
{
ïï 
return
ññ 
this
ññ #
.
ññ# $

components
ññ$ .
[
ññ. /
$num
ññ/ 0
]
ññ0 1
.
ññ1 2
Buffer
ññ2 8
.
ññ8 9
GetIoBuffer
ññ9 D
(
ññD E
index
ññE J
,
ññJ K
length
ññL R
)
ññR S
;
ññS T
}
óó 
break
òò 
;
òò 
}
ôô 
var
õõ 
merged
õõ 
=
õõ 
new
õõ 
byte
õõ !
[
õõ! "
length
õõ" (
]
õõ( )
;
õõ) *
ArraySegment
úú 
<
úú 
byte
úú 
>
úú 
[
úú 
]
úú  
buffers
úú! (
=
úú) *
this
úú+ /
.
úú/ 0
GetIoBuffers
úú0 <
(
úú< =
index
úú= B
,
úúB C
length
úúD J
)
úúJ K
;
úúK L
int
ûû 
offset
ûû 
=
ûû 
$num
ûû 
;
ûû 
foreach
üü 
(
üü 
ArraySegment
üü !
<
üü! "
byte
üü" &
>
üü& '
buf
üü( +
in
üü, .
buffers
üü/ 6
)
üü6 7
{
†† 
Contract
°° 
.
°° 
Assert
°° 
(
°°  
merged
°°  &
.
°°& '
Length
°°' -
-
°°. /
offset
°°0 6
>=
°°7 9
buf
°°: =
.
°°= >
Count
°°> C
)
°°C D
;
°°D E
PlatformDependent
££ !
.
££! "

CopyMemory
££" ,
(
££, -
buf
££- 0
.
££0 1
Array
££1 6
,
££6 7
buf
££8 ;
.
££; <
Offset
££< B
,
££B C
merged
££D J
,
££J K
offset
££L R
,
££R S
buf
££T W
.
££W X
Count
££X ]
)
££] ^
;
££^ _
offset
§§ 
+=
§§ 
buf
§§ 
.
§§ 
Count
§§ #
;
§§# $
}
•• 
return
ßß 
new
ßß 
ArraySegment
ßß #
<
ßß# $
byte
ßß$ (
>
ßß( )
(
ßß) *
merged
ßß* 0
)
ßß0 1
;
ßß1 2
}
®® 	
public
™™ 
override
™™ 
ArraySegment
™™ $
<
™™$ %
byte
™™% )
>
™™) *
[
™™* +
]
™™+ ,
GetIoBuffers
™™- 9
(
™™9 :
int
™™: =
index
™™> C
,
™™C D
int
™™E H
length
™™I O
)
™™O P
{
´´ 	
this
¨¨ 
.
¨¨ 

CheckIndex
¨¨ 
(
¨¨ 
index
¨¨ !
,
¨¨! "
length
¨¨# )
)
¨¨) *
;
¨¨* +
if
≠≠ 
(
≠≠ 
length
≠≠ 
==
≠≠ 
$num
≠≠ 
)
≠≠ 
{
ÆÆ 
return
ØØ 
new
ØØ 
[
ØØ 
]
ØØ 
{
ØØ 
EmptyNioBuffer
ØØ -
}
ØØ. /
;
ØØ/ 0
}
∞∞ 
var
≤≤ 
buffers
≤≤ 
=
≤≤ 
new
≤≤ 
List
≤≤ "
<
≤≤" #
ArraySegment
≤≤# /
<
≤≤/ 0
byte
≤≤0 4
>
≤≤4 5
>
≤≤5 6
(
≤≤6 7
this
≤≤7 ;
.
≤≤; <

components
≤≤< F
.
≤≤F G
Count
≤≤G L
)
≤≤L M
;
≤≤M N
int
≥≥ 
i
≥≥ 
=
≥≥ 
this
≥≥ 
.
≥≥ 
ToComponentIndex
≥≥ )
(
≥≥) *
index
≥≥* /
)
≥≥/ 0
;
≥≥0 1
while
¥¥ 
(
¥¥ 
length
¥¥ 
>
¥¥ 
$num
¥¥ 
)
¥¥ 
{
µµ 
ComponentEntry
∂∂ 
c
∂∂  
=
∂∂! "
this
∂∂# '
.
∂∂' (

components
∂∂( 2
[
∂∂2 3
i
∂∂3 4
]
∂∂4 5
;
∂∂5 6
IByteBuffer
∑∑ 
s
∑∑ 
=
∑∑ 
c
∑∑  !
.
∑∑! "
Buffer
∑∑" (
;
∑∑( )
int
∏∏ 

adjustment
∏∏ 
=
∏∏  
c
∏∏! "
.
∏∏" #
Offset
∏∏# )
;
∏∏) *
int
ππ 
localLength
ππ 
=
ππ  !
Math
ππ" &
.
ππ& '
Min
ππ' *
(
ππ* +
length
ππ+ 1
,
ππ1 2
s
ππ3 4
.
ππ4 5
Capacity
ππ5 =
-
ππ> ?
(
ππ@ A
index
ππA F
-
ππG H

adjustment
ππI S
)
ππS T
)
ππT U
;
ππU V
switch
∫∫ 
(
∫∫ 
s
∫∫ 
.
∫∫ 
IoBufferCount
∫∫ '
)
∫∫' (
{
ªª 
case
ºº 
$num
ºº 
:
ºº 
throw
ΩΩ 
new
ΩΩ !#
NotSupportedException
ΩΩ" 7
(
ΩΩ7 8
)
ΩΩ8 9
;
ΩΩ9 :
case
ææ 
$num
ææ 
:
ææ 
buffers
øø 
.
øø  
Add
øø  #
(
øø# $
s
øø$ %
.
øø% &
GetIoBuffer
øø& 1
(
øø1 2
index
øø2 7
-
øø8 9

adjustment
øø: D
,
øøD E
localLength
øøF Q
)
øøQ R
)
øøR S
;
øøS T
break
¿¿ 
;
¿¿ 
default
¡¡ 
:
¡¡ 
buffers
¬¬ 
.
¬¬  
AddRange
¬¬  (
(
¬¬( )
s
¬¬) *
.
¬¬* +
GetIoBuffers
¬¬+ 7
(
¬¬7 8
index
¬¬8 =
-
¬¬> ?

adjustment
¬¬@ J
,
¬¬J K
localLength
¬¬L W
)
¬¬W X
)
¬¬X Y
;
¬¬Y Z
break
√√ 
;
√√ 
}
ƒƒ 
index
∆∆ 
+=
∆∆ 
localLength
∆∆ $
;
∆∆$ %
length
«« 
-=
«« 
localLength
«« %
;
««% &
i
»» 
++
»» 
;
»» 
}
…… 
return
ÀÀ 
buffers
ÀÀ 
.
ÀÀ 
ToArray
ÀÀ "
(
ÀÀ" #
)
ÀÀ# $
;
ÀÀ$ %
}
ÃÃ 	
public
œœ 
override
œœ 
bool
œœ 
IsDirect
œœ %
{
–– 	
get
—— 
{
““ 
int
”” 
size
”” 
=
”” 
this
”” 
.
””  

components
””  *
.
””* +
Count
””+ 0
;
””0 1
if
‘‘ 
(
‘‘ 
size
‘‘ 
==
‘‘ 
$num
‘‘ 
)
‘‘ 
{
’’ 
return
÷÷ 
false
÷÷  
;
÷÷  !
}
◊◊ 
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
i
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
i
ÿÿ  !
<
ÿÿ" #
size
ÿÿ$ (
;
ÿÿ( )
i
ÿÿ* +
++
ÿÿ+ -
)
ÿÿ- .
{
ŸŸ 
if
⁄⁄ 
(
⁄⁄ 
!
⁄⁄ 
this
⁄⁄ 
.
⁄⁄ 

components
⁄⁄ (
[
⁄⁄( )
i
⁄⁄) *
]
⁄⁄* +
.
⁄⁄+ ,
Buffer
⁄⁄, 2
.
⁄⁄2 3
IsDirect
⁄⁄3 ;
)
⁄⁄; <
{
€€ 
return
‹‹ 
false
‹‹ $
;
‹‹$ %
}
›› 
}
ﬁﬁ 
return
ﬂﬂ 
true
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
}
·· 	
public
„„ 
override
„„ 
bool
„„ 
HasArray
„„ %
{
‰‰ 	
get
ÂÂ 
{
ÊÊ 
switch
ÁÁ 
(
ÁÁ 
this
ÁÁ 
.
ÁÁ 

components
ÁÁ '
.
ÁÁ' (
Count
ÁÁ( -
)
ÁÁ- .
{
ËË 
case
ÈÈ 
$num
ÈÈ 
:
ÈÈ 
return
ÍÍ 
true
ÍÍ #
;
ÍÍ# $
case
ÎÎ 
$num
ÎÎ 
:
ÎÎ 
return
ÏÏ 
this
ÏÏ #
.
ÏÏ# $

components
ÏÏ$ .
[
ÏÏ. /
$num
ÏÏ/ 0
]
ÏÏ0 1
.
ÏÏ1 2
Buffer
ÏÏ2 8
.
ÏÏ8 9
HasArray
ÏÏ9 A
;
ÏÏA B
default
ÌÌ 
:
ÌÌ 
return
ÓÓ 
false
ÓÓ $
;
ÓÓ$ %
}
ÔÔ 
}
 
}
ÒÒ 	
public
ÛÛ 
override
ÛÛ 
byte
ÛÛ 
[
ÛÛ 
]
ÛÛ 
Array
ÛÛ $
{
ÙÙ 	
get
ıı 
{
ˆˆ 
switch
˜˜ 
(
˜˜ 
this
˜˜ 
.
˜˜ 

components
˜˜ '
.
˜˜' (
Count
˜˜( -
)
˜˜- .
{
¯¯ 
case
˘˘ 
$num
˘˘ 
:
˘˘ 
return
˙˙ 
ArrayExtensions
˙˙ .
.
˙˙. /
	ZeroBytes
˙˙/ 8
;
˙˙8 9
case
˚˚ 
$num
˚˚ 
:
˚˚ 
return
¸¸ 
this
¸¸ #
.
¸¸# $

components
¸¸$ .
[
¸¸. /
$num
¸¸/ 0
]
¸¸0 1
.
¸¸1 2
Buffer
¸¸2 8
.
¸¸8 9
Array
¸¸9 >
;
¸¸> ?
default
˝˝ 
:
˝˝ 
throw
˛˛ 
new
˛˛ !#
NotSupportedException
˛˛" 7
(
˛˛7 8
)
˛˛8 9
;
˛˛9 :
}
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
override
ÉÉ 
int
ÉÉ 
ArrayOffset
ÉÉ '
{
ÑÑ 	
get
ÖÖ 
{
ÜÜ 
switch
áá 
(
áá 
this
áá 
.
áá 

components
áá '
.
áá' (
Count
áá( -
)
áá- .
{
àà 
case
ââ 
$num
ââ 
:
ââ 
return
ää 
$num
ää  
;
ää  !
case
ãã 
$num
ãã 
:
ãã 
return
åå 
this
åå #
.
åå# $

components
åå$ .
[
åå. /
$num
åå/ 0
]
åå0 1
.
åå1 2
Buffer
åå2 8
.
åå8 9
ArrayOffset
åå9 D
;
ååD E
default
çç 
:
çç 
throw
éé 
new
éé !#
NotSupportedException
éé" 7
(
éé7 8
)
éé8 9
;
éé9 :
}
èè 
}
êê 
}
ëë 	
public
ìì 
override
ìì 
bool
ìì 
HasMemoryAddress
ìì -
{
îî 	
get
ïï 
{
ññ 
switch
óó 
(
óó 
this
óó 
.
óó 

components
óó '
.
óó' (
Count
óó( -
)
óó- .
{
òò 
case
ôô 
$num
ôô 
:
ôô 
return
öö 
this
öö #
.
öö# $

components
öö$ .
[
öö. /
$num
öö/ 0
]
öö0 1
.
öö1 2
Buffer
öö2 8
.
öö8 9
HasMemoryAddress
öö9 I
;
ööI J
default
õõ 
:
õõ 
return
úú 
false
úú $
;
úú$ %
}
ùù 
}
ûû 
}
üü 	
public
°° 
override
°° 
ref
°° 
byte
°°  &
GetPinnableMemoryAddress
°°! 9
(
°°9 :
)
°°: ;
{
¢¢ 	
switch
££ 
(
££ 
this
££ 
.
££ 

components
££ #
.
££# $
Count
££$ )
)
££) *
{
§§ 
case
•• 
$num
•• 
:
•• 
return
¶¶ 
ref
¶¶ 
this
¶¶ #
.
¶¶# $

components
¶¶$ .
[
¶¶. /
$num
¶¶/ 0
]
¶¶0 1
.
¶¶1 2
Buffer
¶¶2 8
.
¶¶8 9&
GetPinnableMemoryAddress
¶¶9 Q
(
¶¶Q R
)
¶¶R S
;
¶¶S T
default
ßß 
:
ßß 
throw
®® 
new
®® #
NotSupportedException
®® 3
(
®®3 4
)
®®4 5
;
®®5 6
}
©© 
}
™™ 	
public
¨¨ 
override
¨¨ 
IntPtr
¨¨ #
AddressOfPinnedMemory
¨¨ 4
(
¨¨4 5
)
¨¨5 6
{
≠≠ 	
switch
ÆÆ 
(
ÆÆ 
this
ÆÆ 
.
ÆÆ 

components
ÆÆ #
.
ÆÆ# $
Count
ÆÆ$ )
)
ÆÆ) *
{
ØØ 
case
∞∞ 
$num
∞∞ 
:
∞∞ 
return
±± 
this
±± 
.
±±  

components
±±  *
[
±±* +
$num
±±+ ,
]
±±, -
.
±±- .
Buffer
±±. 4
.
±±4 5#
AddressOfPinnedMemory
±±5 J
(
±±J K
)
±±K L
;
±±L M
default
≤≤ 
:
≤≤ 
throw
≥≥ 
new
≥≥ #
NotSupportedException
≥≥ 3
(
≥≥3 4
)
≥≥4 5
;
≥≥5 6
}
¥¥ 
}
µµ 	
public
∑∑ 
override
∑∑ 
int
∑∑ 
Capacity
∑∑ $
=>
∑∑% '
GetCapacity
∑∑( 3
(
∑∑3 4
this
∑∑4 8
.
∑∑8 9

components
∑∑9 C
)
∑∑C D
;
∑∑D E
static
ππ 
int
ππ 
GetCapacity
ππ 
(
ππ 
List
ππ #
<
ππ# $
ComponentEntry
ππ$ 2
>
ππ2 3

components
ππ4 >
)
ππ> ?
{
∫∫ 	
int
ªª 
numComponents
ªª 
=
ªª 

components
ªª  *
.
ªª* +
Count
ªª+ 0
;
ªª0 1
if
ºº 
(
ºº 
numComponents
ºº 
==
ºº  
$num
ºº! "
)
ºº" #
{
ΩΩ 
return
ææ 
$num
ææ 
;
ææ 
}
øø 
return
¡¡ 

components
¡¡ 
[
¡¡ 
numComponents
¡¡ +
-
¡¡, -
$num
¡¡. /
]
¡¡/ 0
.
¡¡0 1
	EndOffset
¡¡1 :
;
¡¡: ;
}
¬¬ 	
public
ƒƒ 
override
ƒƒ 
IByteBuffer
ƒƒ #
AdjustCapacity
ƒƒ$ 2
(
ƒƒ2 3
int
ƒƒ3 6
newCapacity
ƒƒ7 B
)
ƒƒB C
{
≈≈ 	
this
∆∆ 
.
∆∆ 
CheckNewCapacity
∆∆ !
(
∆∆! "
newCapacity
∆∆" -
)
∆∆- .
;
∆∆. /
int
»» 
oldCapacity
»» 
=
»» 
this
»» "
.
»»" #
Capacity
»»# +
;
»»+ ,
if
…… 
(
…… 
newCapacity
…… 
>
…… 
oldCapacity
…… )
)
……) *
{
   
int
ÀÀ 
paddingLength
ÀÀ !
=
ÀÀ" #
newCapacity
ÀÀ$ /
-
ÀÀ0 1
oldCapacity
ÀÀ2 =
;
ÀÀ= >
IByteBuffer
ÃÃ 
padding
ÃÃ #
;
ÃÃ# $
int
ÕÕ 
nComponents
ÕÕ 
=
ÕÕ  !
this
ÕÕ" &
.
ÕÕ& '

components
ÕÕ' 1
.
ÕÕ1 2
Count
ÕÕ2 7
;
ÕÕ7 8
if
ŒŒ 
(
ŒŒ 
nComponents
ŒŒ 
<
ŒŒ  !
this
ŒŒ" &
.
ŒŒ& '
MaxNumComponents
ŒŒ' 7
)
ŒŒ7 8
{
œœ 
padding
–– 
=
–– 
this
–– "
.
––" #
AllocateBuffer
––# 1
(
––1 2
paddingLength
––2 ?
)
––? @
;
––@ A
padding
—— 
.
—— 
SetIndex
—— $
(
——$ %
$num
——% &
,
——& '
paddingLength
——( 5
)
——5 6
;
——6 7
this
““ 
.
““ 
AddComponent0
““ &
(
““& '
false
““' ,
,
““, -
this
““. 2
.
““2 3

components
““3 =
.
““= >
Count
““> C
,
““C D
padding
““E L
)
““L M
;
““M N
}
”” 
else
‘‘ 
{
’’ 
padding
÷÷ 
=
÷÷ 
this
÷÷ "
.
÷÷" #
AllocateBuffer
÷÷# 1
(
÷÷1 2
paddingLength
÷÷2 ?
)
÷÷? @
;
÷÷@ A
padding
◊◊ 
.
◊◊ 
SetIndex
◊◊ $
(
◊◊$ %
$num
◊◊% &
,
◊◊& '
paddingLength
◊◊( 5
)
◊◊5 6
;
◊◊6 7
this
⁄⁄ 
.
⁄⁄ 
AddComponent0
⁄⁄ &
(
⁄⁄& '
false
⁄⁄' ,
,
⁄⁄, -
this
⁄⁄. 2
.
⁄⁄2 3

components
⁄⁄3 =
.
⁄⁄= >
Count
⁄⁄> C
,
⁄⁄C D
padding
⁄⁄E L
)
⁄⁄L M
;
⁄⁄M N
this
€€ 
.
€€ !
ConsolidateIfNeeded
€€ ,
(
€€, -
)
€€- .
;
€€. /
}
‹‹ 
}
›› 
else
ﬁﬁ 
if
ﬁﬁ 
(
ﬁﬁ 
newCapacity
ﬁﬁ  
<
ﬁﬁ! "
oldCapacity
ﬁﬁ# .
)
ﬁﬁ. /
{
ﬂﬂ 
int
‡‡ 
bytesToTrim
‡‡ 
=
‡‡  !
oldCapacity
‡‡" -
-
‡‡. /
newCapacity
‡‡0 ;
;
‡‡; <
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
this
·· !
.
··! "

components
··" ,
.
··, -
Count
··- 2
-
··3 4
$num
··5 6
;
··6 7
i
··8 9
>=
··: <
$num
··= >
;
··> ?
i
··@ A
--
··A C
)
··C D
{
‚‚ 
ComponentEntry
„„ "
c
„„# $
=
„„% &
this
„„' +
.
„„+ ,

components
„„, 6
[
„„6 7
i
„„7 8
]
„„8 9
;
„„9 :
if
‰‰ 
(
‰‰ 
bytesToTrim
‰‰ #
>=
‰‰$ &
c
‰‰' (
.
‰‰( )
Length
‰‰) /
)
‰‰/ 0
{
ÂÂ 
bytesToTrim
ÊÊ #
-=
ÊÊ$ &
c
ÊÊ' (
.
ÊÊ( )
Length
ÊÊ) /
;
ÊÊ/ 0
this
ÁÁ 
.
ÁÁ 

components
ÁÁ '
.
ÁÁ' (
RemoveAt
ÁÁ( 0
(
ÁÁ0 1
i
ÁÁ1 2
)
ÁÁ2 3
;
ÁÁ3 4
continue
ËË  
;
ËË  !
}
ÈÈ 
var
ÏÏ 
newC
ÏÏ 
=
ÏÏ 
new
ÏÏ "
ComponentEntry
ÏÏ# 1
(
ÏÏ1 2
c
ÏÏ2 3
.
ÏÏ3 4
Buffer
ÏÏ4 :
.
ÏÏ: ;
Slice
ÏÏ; @
(
ÏÏ@ A
$num
ÏÏA B
,
ÏÏB C
c
ÏÏD E
.
ÏÏE F
Length
ÏÏF L
-
ÏÏM N
bytesToTrim
ÏÏO Z
)
ÏÏZ [
)
ÏÏ[ \
;
ÏÏ\ ]
newC
ÌÌ 
.
ÌÌ 
Offset
ÌÌ 
=
ÌÌ  !
c
ÌÌ" #
.
ÌÌ# $
Offset
ÌÌ$ *
;
ÌÌ* +
newC
ÓÓ 
.
ÓÓ 
	EndOffset
ÓÓ "
=
ÓÓ# $
newC
ÓÓ% )
.
ÓÓ) *
Offset
ÓÓ* 0
+
ÓÓ1 2
newC
ÓÓ3 7
.
ÓÓ7 8
Length
ÓÓ8 >
;
ÓÓ> ?
this
ÔÔ 
.
ÔÔ 

components
ÔÔ #
[
ÔÔ# $
i
ÔÔ$ %
]
ÔÔ% &
=
ÔÔ' (
newC
ÔÔ) -
;
ÔÔ- .
break
 
;
 
}
ÒÒ 
if
ÛÛ 
(
ÛÛ 
this
ÛÛ 
.
ÛÛ 
ReaderIndex
ÛÛ $
>
ÛÛ% &
newCapacity
ÛÛ' 2
)
ÛÛ2 3
{
ÙÙ 
this
ıı 
.
ıı 
SetIndex
ıı !
(
ıı! "
newCapacity
ıı" -
,
ıı- .
newCapacity
ıı/ :
)
ıı: ;
;
ıı; <
}
ˆˆ 
else
˜˜ 
if
˜˜ 
(
˜˜ 
this
˜˜ 
.
˜˜ 
WriterIndex
˜˜ )
>
˜˜* +
newCapacity
˜˜, 7
)
˜˜7 8
{
¯¯ 
this
˘˘ 
.
˘˘ 
SetWriterIndex
˘˘ '
(
˘˘' (
newCapacity
˘˘( 3
)
˘˘3 4
;
˘˘4 5
}
˙˙ 
}
˚˚ 
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
override
ˇˇ "
IByteBufferAllocator
ˇˇ ,
	Allocator
ˇˇ- 6
=>
ˇˇ7 9
this
ˇˇ: >
.
ˇˇ> ?
	allocator
ˇˇ? H
;
ˇˇH I
public
ÑÑ 
virtual
ÑÑ 
int
ÑÑ 
NumComponents
ÑÑ (
=>
ÑÑ) +
this
ÑÑ, 0
.
ÑÑ0 1

components
ÑÑ1 ;
.
ÑÑ; <
Count
ÑÑ< A
;
ÑÑA B
public
ââ 
virtual
ââ 
int
ââ 
MaxNumComponents
ââ +
=>
ââ, .
this
ââ/ 3
.
ââ3 4
maxNumComponents
ââ4 D
;
ââD E
public
éé 
virtual
éé 
int
éé 
ToComponentIndex
éé +
(
éé+ ,
int
éé, /
offset
éé0 6
)
éé6 7
{
èè 	
this
êê 
.
êê 

CheckIndex
êê 
(
êê 
offset
êê "
)
êê" #
;
êê# $
for
íí 
(
íí 
int
íí 
low
íí 
=
íí 
$num
íí 
,
íí 
high
íí "
=
íí# $
this
íí% )
.
íí) *

components
íí* 4
.
íí4 5
Count
íí5 :
;
íí: ;
low
íí< ?
<=
íí@ B
high
ííC G
;
ííG H
)
ííH I
{
ìì 
int
îî 
mid
îî 
=
îî 
(
îî 
low
îî 
+
îî  
high
îî! %
)
îî% &
.
îî& '
RightUShift
îî' 2
(
îî2 3
$num
îî3 4
)
îî4 5
;
îî5 6
ComponentEntry
ïï 
c
ïï  
=
ïï! "
this
ïï# '
.
ïï' (

components
ïï( 2
[
ïï2 3
mid
ïï3 6
]
ïï6 7
;
ïï7 8
if
ññ 
(
ññ 
offset
ññ 
>=
ññ 
c
ññ 
.
ññ  
	EndOffset
ññ  )
)
ññ) *
{
óó 
low
òò 
=
òò 
mid
òò 
+
òò 
$num
òò  !
;
òò! "
}
ôô 
else
öö 
if
öö 
(
öö 
offset
öö 
<
öö  !
c
öö" #
.
öö# $
Offset
öö$ *
)
öö* +
{
õõ 
high
úú 
=
úú 
mid
úú 
-
úú  
$num
úú! "
;
úú" #
}
ùù 
else
ûû 
{
üü 
return
†† 
mid
†† 
;
†† 
}
°° 
}
¢¢ 
throw
§§ 
new
§§ 
	Exception
§§ 
(
§§  
$str
§§  7
)
§§7 8
;
§§8 9
}
•• 	
public
ßß 
virtual
ßß 
int
ßß 
ToByteIndex
ßß &
(
ßß& '
int
ßß' *
cIndex
ßß+ 1
)
ßß1 2
{
®® 	
this
©© 
.
©© !
CheckComponentIndex
©© $
(
©©$ %
cIndex
©©% +
)
©©+ ,
;
©©, -
return
™™ 
this
™™ 
.
™™ 

components
™™ "
[
™™" #
cIndex
™™# )
]
™™) *
.
™™* +
Offset
™™+ 1
;
™™1 2
}
´´ 	
	protected
≠≠ 
internal
≠≠ 
override
≠≠ #
byte
≠≠$ (
_GetByte
≠≠) 1
(
≠≠1 2
int
≠≠2 5
index
≠≠6 ;
)
≠≠; <
{
ÆÆ 	
ComponentEntry
ØØ 
c
ØØ 
=
ØØ 
this
ØØ #
.
ØØ# $
FindComponent
ØØ$ 1
(
ØØ1 2
index
ØØ2 7
)
ØØ7 8
;
ØØ8 9
return
∞∞ 
c
∞∞ 
.
∞∞ 
Buffer
∞∞ 
.
∞∞ 
GetByte
∞∞ #
(
∞∞# $
index
∞∞$ )
-
∞∞* +
c
∞∞, -
.
∞∞- .
Offset
∞∞. 4
)
∞∞4 5
;
∞∞5 6
}
±± 	
	protected
≥≥ 
internal
≥≥ 
override
≥≥ #
short
≥≥$ )
	_GetShort
≥≥* 3
(
≥≥3 4
int
≥≥4 7
index
≥≥8 =
)
≥≥= >
{
¥¥ 	
ComponentEntry
µµ 
c
µµ 
=
µµ 
this
µµ #
.
µµ# $
FindComponent
µµ$ 1
(
µµ1 2
index
µµ2 7
)
µµ7 8
;
µµ8 9
if
∂∂ 
(
∂∂ 
index
∂∂ 
+
∂∂ 
$num
∂∂ 
<=
∂∂ 
c
∂∂ 
.
∂∂ 
	EndOffset
∂∂ (
)
∂∂( )
{
∑∑ 
return
∏∏ 
c
∏∏ 
.
∏∏ 
Buffer
∏∏ 
.
∏∏  
GetShort
∏∏  (
(
∏∏( )
index
∏∏) .
-
∏∏/ 0
c
∏∏1 2
.
∏∏2 3
Offset
∏∏3 9
)
∏∏9 :
;
∏∏: ;
}
ππ 
return
ªª 
(
ªª 
short
ªª 
)
ªª 
(
ªª 
this
ªª 
.
ªª  
_GetByte
ªª  (
(
ªª( )
index
ªª) .
)
ªª. /
<<
ªª0 2
$num
ªª3 4
|
ªª5 6
this
ªª7 ;
.
ªª; <
_GetByte
ªª< D
(
ªªD E
index
ªªE J
+
ªªK L
$num
ªªM N
)
ªªN O
)
ªªO P
;
ªªP Q
}
ºº 	
	protected
ææ 
internal
ææ 
override
ææ #
short
ææ$ )
_GetShortLE
ææ* 5
(
ææ5 6
int
ææ6 9
index
ææ: ?
)
ææ? @
{
øø 	
ComponentEntry
¿¿ 
c
¿¿ 
=
¿¿ 
this
¿¿ #
.
¿¿# $
FindComponent
¿¿$ 1
(
¿¿1 2
index
¿¿2 7
)
¿¿7 8
;
¿¿8 9
if
¡¡ 
(
¡¡ 
index
¡¡ 
+
¡¡ 
$num
¡¡ 
<=
¡¡ 
c
¡¡ 
.
¡¡ 
	EndOffset
¡¡ (
)
¡¡( )
{
¬¬ 
return
√√ 
c
√√ 
.
√√ 
Buffer
√√ 
.
√√  

GetShortLE
√√  *
(
√√* +
index
√√+ 0
-
√√1 2
c
√√3 4
.
√√4 5
Offset
√√5 ;
)
√√; <
;
√√< =
}
ƒƒ 
return
∆∆ 
(
∆∆ 
short
∆∆ 
)
∆∆ 
(
∆∆ 
this
∆∆ 
.
∆∆  
_GetByte
∆∆  (
(
∆∆( )
index
∆∆) .
)
∆∆. /
<<
∆∆0 2
$num
∆∆3 4
|
∆∆5 6
this
∆∆7 ;
.
∆∆; <
_GetByte
∆∆< D
(
∆∆D E
index
∆∆E J
+
∆∆K L
$num
∆∆M N
)
∆∆N O
)
∆∆O P
;
∆∆P Q
}
«« 	
	protected
…… 
internal
…… 
override
…… #
int
……$ ' 
_GetUnsignedMedium
……( :
(
……: ;
int
……; >
index
……? D
)
……D E
{
   	
ComponentEntry
ÀÀ 
c
ÀÀ 
=
ÀÀ 
this
ÀÀ #
.
ÀÀ# $
FindComponent
ÀÀ$ 1
(
ÀÀ1 2
index
ÀÀ2 7
)
ÀÀ7 8
;
ÀÀ8 9
if
ÃÃ 
(
ÃÃ 
index
ÃÃ 
+
ÃÃ 
$num
ÃÃ 
<=
ÃÃ 
c
ÃÃ 
.
ÃÃ 
	EndOffset
ÃÃ (
)
ÃÃ( )
{
ÕÕ 
return
ŒŒ 
c
ŒŒ 
.
ŒŒ 
Buffer
ŒŒ 
.
ŒŒ  
GetUnsignedMedium
ŒŒ  1
(
ŒŒ1 2
index
ŒŒ2 7
-
ŒŒ8 9
c
ŒŒ: ;
.
ŒŒ; <
Offset
ŒŒ< B
)
ŒŒB C
;
ŒŒC D
}
œœ 
return
—— 
(
—— 
this
—— 
.
—— 
	_GetShort
—— "
(
——" #
index
——# (
)
——( )
&
——* +
$num
——, 2
)
——2 3
<<
——4 6
$num
——7 8
|
——9 :
this
——; ?
.
——? @
_GetByte
——@ H
(
——H I
index
——I N
+
——O P
$num
——Q R
)
——R S
;
——S T
}
““ 	
	protected
‘‘ 
internal
‘‘ 
override
‘‘ #
int
‘‘$ '"
_GetUnsignedMediumLE
‘‘( <
(
‘‘< =
int
‘‘= @
index
‘‘A F
)
‘‘F G
{
’’ 	
ComponentEntry
÷÷ 
c
÷÷ 
=
÷÷ 
this
÷÷ #
.
÷÷# $
FindComponent
÷÷$ 1
(
÷÷1 2
index
÷÷2 7
)
÷÷7 8
;
÷÷8 9
if
◊◊ 
(
◊◊ 
index
◊◊ 
+
◊◊ 
$num
◊◊ 
<=
◊◊ 
c
◊◊ 
.
◊◊ 
	EndOffset
◊◊ (
)
◊◊( )
{
ÿÿ 
return
ŸŸ 
c
ŸŸ 
.
ŸŸ 
Buffer
ŸŸ 
.
ŸŸ  !
GetUnsignedMediumLE
ŸŸ  3
(
ŸŸ3 4
index
ŸŸ4 9
-
ŸŸ: ;
c
ŸŸ< =
.
ŸŸ= >
Offset
ŸŸ> D
)
ŸŸD E
;
ŸŸE F
}
⁄⁄ 
return
‹‹ 
(
‹‹ 
this
‹‹ 
.
‹‹ 
_GetShortLE
‹‹ $
(
‹‹$ %
index
‹‹% *
)
‹‹* +
&
‹‹, -
$num
‹‹. 4
)
‹‹4 5
<<
‹‹6 8
$num
‹‹9 :
|
‹‹; <
this
‹‹= A
.
‹‹A B
_GetByte
‹‹B J
(
‹‹J K
index
‹‹K P
+
‹‹Q R
$num
‹‹S T
)
‹‹T U
;
‹‹U V
}
›› 	
	protected
ﬂﬂ 
internal
ﬂﬂ 
override
ﬂﬂ #
int
ﬂﬂ$ '
_GetInt
ﬂﬂ( /
(
ﬂﬂ/ 0
int
ﬂﬂ0 3
index
ﬂﬂ4 9
)
ﬂﬂ9 :
{
‡‡ 	
ComponentEntry
·· 
c
·· 
=
·· 
this
·· #
.
··# $
FindComponent
··$ 1
(
··1 2
index
··2 7
)
··7 8
;
··8 9
if
‚‚ 
(
‚‚ 
index
‚‚ 
+
‚‚ 
$num
‚‚ 
<=
‚‚ 
c
‚‚ 
.
‚‚ 
	EndOffset
‚‚ (
)
‚‚( )
{
„„ 
return
‰‰ 
c
‰‰ 
.
‰‰ 
Buffer
‰‰ 
.
‰‰  
GetInt
‰‰  &
(
‰‰& '
index
‰‰' ,
-
‰‰- .
c
‰‰/ 0
.
‰‰0 1
Offset
‰‰1 7
)
‰‰7 8
;
‰‰8 9
}
ÂÂ 
return
ÁÁ 
this
ÁÁ 
.
ÁÁ 
	_GetShort
ÁÁ !
(
ÁÁ! "
index
ÁÁ" '
)
ÁÁ' (
<<
ÁÁ) +
$num
ÁÁ, .
|
ÁÁ/ 0
(
ÁÁ1 2
ushort
ÁÁ2 8
)
ÁÁ8 9
this
ÁÁ9 =
.
ÁÁ= >
	_GetShort
ÁÁ> G
(
ÁÁG H
index
ÁÁH M
+
ÁÁN O
$num
ÁÁP Q
)
ÁÁQ R
;
ÁÁR S
}
ËË 	
	protected
ÍÍ 
internal
ÍÍ 
override
ÍÍ #
int
ÍÍ$ '
	_GetIntLE
ÍÍ( 1
(
ÍÍ1 2
int
ÍÍ2 5
index
ÍÍ6 ;
)
ÍÍ; <
{
ÎÎ 	
ComponentEntry
ÏÏ 
c
ÏÏ 
=
ÏÏ 
this
ÏÏ #
.
ÏÏ# $
FindComponent
ÏÏ$ 1
(
ÏÏ1 2
index
ÏÏ2 7
)
ÏÏ7 8
;
ÏÏ8 9
if
ÌÌ 
(
ÌÌ 
index
ÌÌ 
+
ÌÌ 
$num
ÌÌ 
<=
ÌÌ 
c
ÌÌ 
.
ÌÌ 
	EndOffset
ÌÌ (
)
ÌÌ( )
{
ÓÓ 
return
ÔÔ 
c
ÔÔ 
.
ÔÔ 
Buffer
ÔÔ 
.
ÔÔ  
GetIntLE
ÔÔ  (
(
ÔÔ( )
index
ÔÔ) .
-
ÔÔ/ 0
c
ÔÔ1 2
.
ÔÔ2 3
Offset
ÔÔ3 9
)
ÔÔ9 :
;
ÔÔ: ;
}
 
return
ÚÚ 
(
ÚÚ 
this
ÚÚ 
.
ÚÚ 
_GetShortLE
ÚÚ $
(
ÚÚ$ %
index
ÚÚ% *
)
ÚÚ* +
<<
ÚÚ, .
$num
ÚÚ/ 1
|
ÚÚ2 3
(
ÚÚ4 5
ushort
ÚÚ5 ;
)
ÚÚ; <
this
ÚÚ< @
.
ÚÚ@ A
_GetShortLE
ÚÚA L
(
ÚÚL M
index
ÚÚM R
+
ÚÚS T
$num
ÚÚU V
)
ÚÚV W
)
ÚÚW X
;
ÚÚX Y
}
ÛÛ 	
	protected
ıı 
internal
ıı 
override
ıı #
long
ıı$ (
_GetLong
ıı) 1
(
ıı1 2
int
ıı2 5
index
ıı6 ;
)
ıı; <
{
ˆˆ 	
ComponentEntry
˜˜ 
c
˜˜ 
=
˜˜ 
this
˜˜ #
.
˜˜# $
FindComponent
˜˜$ 1
(
˜˜1 2
index
˜˜2 7
)
˜˜7 8
;
˜˜8 9
if
¯¯ 
(
¯¯ 
index
¯¯ 
+
¯¯ 
$num
¯¯ 
<=
¯¯ 
c
¯¯ 
.
¯¯ 
	EndOffset
¯¯ (
)
¯¯( )
{
˘˘ 
return
˙˙ 
c
˙˙ 
.
˙˙ 
Buffer
˙˙ 
.
˙˙  
GetLong
˙˙  '
(
˙˙' (
index
˙˙( -
-
˙˙. /
c
˙˙0 1
.
˙˙1 2
Offset
˙˙2 8
)
˙˙8 9
;
˙˙9 :
}
˚˚ 
return
˝˝ 
(
˝˝ 
long
˝˝ 
)
˝˝ 
this
˝˝ 
.
˝˝ 
_GetInt
˝˝ %
(
˝˝% &
index
˝˝& +
)
˝˝+ ,
<<
˝˝- /
$num
˝˝0 2
|
˝˝3 4
(
˝˝5 6
uint
˝˝6 :
)
˝˝: ;
this
˝˝; ?
.
˝˝? @
_GetInt
˝˝@ G
(
˝˝G H
index
˝˝H M
+
˝˝N O
$num
˝˝P Q
)
˝˝Q R
;
˝˝R S
}
˛˛ 	
	protected
ÄÄ 
internal
ÄÄ 
override
ÄÄ #
long
ÄÄ$ (

_GetLongLE
ÄÄ) 3
(
ÄÄ3 4
int
ÄÄ4 7
index
ÄÄ8 =
)
ÄÄ= >
{
ÅÅ 	
ComponentEntry
ÇÇ 
c
ÇÇ 
=
ÇÇ 
this
ÇÇ #
.
ÇÇ# $
FindComponent
ÇÇ$ 1
(
ÇÇ1 2
index
ÇÇ2 7
)
ÇÇ7 8
;
ÇÇ8 9
if
ÉÉ 
(
ÉÉ 
index
ÉÉ 
+
ÉÉ 
$num
ÉÉ 
<=
ÉÉ 
c
ÉÉ 
.
ÉÉ 
	EndOffset
ÉÉ (
)
ÉÉ( )
{
ÑÑ 
return
ÖÖ 
c
ÖÖ 
.
ÖÖ 
Buffer
ÖÖ 
.
ÖÖ  
	GetLongLE
ÖÖ  )
(
ÖÖ) *
index
ÖÖ* /
-
ÖÖ0 1
c
ÖÖ2 3
.
ÖÖ3 4
Offset
ÖÖ4 :
)
ÖÖ: ;
;
ÖÖ; <
}
ÜÜ 
return
àà 
(
àà 
this
àà 
.
àà 
	_GetIntLE
àà "
(
àà" #
index
àà# (
)
àà( )
<<
àà* ,
$num
àà- /
|
àà0 1
this
àà2 6
.
àà6 7
	_GetIntLE
àà7 @
(
àà@ A
index
ààA F
+
ààG H
$num
ààI J
)
ààJ K
)
ààK L
;
ààL M
}
ââ 	
public
ãã 
override
ãã 
IByteBuffer
ãã #
GetBytes
ãã$ ,
(
ãã, -
int
ãã- 0
index
ãã1 6
,
ãã6 7
byte
ãã8 <
[
ãã< =
]
ãã= >
dst
ãã? B
,
ããB C
int
ããD G
dstIndex
ããH P
,
ããP Q
int
ããR U
length
ããV \
)
ãã\ ]
{
åå 	
this
çç 
.
çç 
CheckDstIndex
çç 
(
çç 
index
çç $
,
çç$ %
length
çç& ,
,
çç, -
dstIndex
çç. 6
,
çç6 7
dst
çç8 ;
.
çç; <
Length
çç< B
)
ççB C
;
ççC D
if
éé 
(
éé 
length
éé 
==
éé 
$num
éé 
)
éé 
{
èè 
return
êê 
this
êê 
;
êê 
}
ëë 
int
ìì 
i
ìì 
=
ìì 
this
ìì 
.
ìì 
ToComponentIndex
ìì )
(
ìì) *
index
ìì* /
)
ìì/ 0
;
ìì0 1
while
îî 
(
îî 
length
îî 
>
îî 
$num
îî 
)
îî 
{
ïï 
ComponentEntry
ññ 
c
ññ  
=
ññ! "
this
ññ# '
.
ññ' (

components
ññ( 2
[
ññ2 3
i
ññ3 4
]
ññ4 5
;
ññ5 6
IByteBuffer
óó 
s
óó 
=
óó 
c
óó  !
.
óó! "
Buffer
óó" (
;
óó( )
int
òò 

adjustment
òò 
=
òò  
c
òò! "
.
òò" #
Offset
òò# )
;
òò) *
int
ôô 
localLength
ôô 
=
ôô  !
Math
ôô" &
.
ôô& '
Min
ôô' *
(
ôô* +
length
ôô+ 1
,
ôô1 2
s
ôô3 4
.
ôô4 5
Capacity
ôô5 =
-
ôô> ?
(
ôô@ A
index
ôôA F
-
ôôG H

adjustment
ôôI S
)
ôôS T
)
ôôT U
;
ôôU V
s
öö 
.
öö 
GetBytes
öö 
(
öö 
index
öö  
-
öö! "

adjustment
öö# -
,
öö- .
dst
öö/ 2
,
öö2 3
dstIndex
öö4 <
,
öö< =
localLength
öö> I
)
ööI J
;
ööJ K
index
õõ 
+=
õõ 
localLength
õõ $
;
õõ$ %
dstIndex
úú 
+=
úú 
localLength
úú '
;
úú' (
length
ùù 
-=
ùù 
localLength
ùù %
;
ùù% &
i
ûû 
++
ûû 
;
ûû 
}
üü 
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
override
££ 
IByteBuffer
££ #
GetBytes
££$ ,
(
££, -
int
££- 0
index
££1 6
,
££6 7
Stream
££8 >
destination
££? J
,
££J K
int
££L O
length
££P V
)
££V W
{
§§ 	
this
•• 
.
•• 

CheckIndex
•• 
(
•• 
index
•• !
,
••! "
length
••# )
)
••) *
;
••* +
if
¶¶ 
(
¶¶ 
length
¶¶ 
==
¶¶ 
$num
¶¶ 
)
¶¶ 
{
ßß 
return
®® 
this
®® 
;
®® 
}
©© 
int
´´ 
i
´´ 
=
´´ 
this
´´ 
.
´´ 
ToComponentIndex
´´ )
(
´´) *
index
´´* /
)
´´/ 0
;
´´0 1
while
¨¨ 
(
¨¨ 
length
¨¨ 
>
¨¨ 
$num
¨¨ 
)
¨¨ 
{
≠≠ 
ComponentEntry
ÆÆ 
c
ÆÆ  
=
ÆÆ! "
this
ÆÆ# '
.
ÆÆ' (

components
ÆÆ( 2
[
ÆÆ2 3
i
ÆÆ3 4
]
ÆÆ4 5
;
ÆÆ5 6
IByteBuffer
ØØ 
s
ØØ 
=
ØØ 
c
ØØ  !
.
ØØ! "
Buffer
ØØ" (
;
ØØ( )
int
∞∞ 

adjustment
∞∞ 
=
∞∞  
c
∞∞! "
.
∞∞" #
Offset
∞∞# )
;
∞∞) *
int
±± 
localLength
±± 
=
±±  !
Math
±±" &
.
±±& '
Min
±±' *
(
±±* +
length
±±+ 1
,
±±1 2
s
±±3 4
.
±±4 5
Capacity
±±5 =
-
±±> ?
(
±±@ A
index
±±A F
-
±±G H

adjustment
±±I S
)
±±S T
)
±±T U
;
±±U V
s
≤≤ 
.
≤≤ 
GetBytes
≤≤ 
(
≤≤ 
index
≤≤  
-
≤≤! "

adjustment
≤≤# -
,
≤≤- .
destination
≤≤/ :
,
≤≤: ;
localLength
≤≤< G
)
≤≤G H
;
≤≤H I
index
≥≥ 
+=
≥≥ 
localLength
≥≥ $
;
≥≥$ %
length
¥¥ 
-=
¥¥ 
localLength
¥¥ %
;
¥¥% &
i
µµ 
++
µµ 
;
µµ 
}
∂∂ 
return
∑∑ 
this
∑∑ 
;
∑∑ 
}
∏∏ 	
public
∫∫ 
override
∫∫ 
IByteBuffer
∫∫ #
GetBytes
∫∫$ ,
(
∫∫, -
int
∫∫- 0
index
∫∫1 6
,
∫∫6 7
IByteBuffer
∫∫8 C
dst
∫∫D G
,
∫∫G H
int
∫∫I L
dstIndex
∫∫M U
,
∫∫U V
int
∫∫W Z
length
∫∫[ a
)
∫∫a b
{
ªª 	
this
ºº 
.
ºº 
CheckDstIndex
ºº 
(
ºº 
index
ºº $
,
ºº$ %
length
ºº& ,
,
ºº, -
dstIndex
ºº. 6
,
ºº6 7
dst
ºº8 ;
.
ºº; <
Capacity
ºº< D
)
ººD E
;
ººE F
if
ΩΩ 
(
ΩΩ 
length
ΩΩ 
==
ΩΩ 
$num
ΩΩ 
)
ΩΩ 
{
ææ 
return
øø 
this
øø 
;
øø 
}
¿¿ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
this
¬¬ 
.
¬¬ 
ToComponentIndex
¬¬ )
(
¬¬) *
index
¬¬* /
)
¬¬/ 0
;
¬¬0 1
while
√√ 
(
√√ 
length
√√ 
>
√√ 
$num
√√ 
)
√√ 
{
ƒƒ 
ComponentEntry
≈≈ 
c
≈≈  
=
≈≈! "
this
≈≈# '
.
≈≈' (

components
≈≈( 2
[
≈≈2 3
i
≈≈3 4
]
≈≈4 5
;
≈≈5 6
IByteBuffer
∆∆ 
s
∆∆ 
=
∆∆ 
c
∆∆  !
.
∆∆! "
Buffer
∆∆" (
;
∆∆( )
int
«« 

adjustment
«« 
=
««  
c
««! "
.
««" #
Offset
««# )
;
««) *
int
»» 
localLength
»» 
=
»»  !
Math
»»" &
.
»»& '
Min
»»' *
(
»»* +
length
»»+ 1
,
»»1 2
s
»»3 4
.
»»4 5
Capacity
»»5 =
-
»»> ?
(
»»@ A
index
»»A F
-
»»G H

adjustment
»»I S
)
»»S T
)
»»T U
;
»»U V
s
…… 
.
…… 
GetBytes
…… 
(
…… 
index
……  
-
……! "

adjustment
……# -
,
……- .
dst
……/ 2
,
……2 3
dstIndex
……4 <
,
……< =
localLength
……> I
)
……I J
;
……J K
index
   
+=
   
localLength
   $
;
  $ %
dstIndex
ÀÀ 
+=
ÀÀ 
localLength
ÀÀ '
;
ÀÀ' (
length
ÃÃ 
-=
ÃÃ 
localLength
ÃÃ %
;
ÃÃ% &
i
ÕÕ 
++
ÕÕ 
;
ÕÕ 
}
ŒŒ 
return
œœ 
this
œœ 
;
œœ 
}
–– 	
	protected
““ 
internal
““ 
override
““ #
void
““$ (
_SetByte
““) 1
(
““1 2
int
““2 5
index
““6 ;
,
““; <
int
““= @
value
““A F
)
““F G
{
”” 	
ComponentEntry
‘‘ 
c
‘‘ 
=
‘‘ 
this
‘‘ #
.
‘‘# $
FindComponent
‘‘$ 1
(
‘‘1 2
index
‘‘2 7
)
‘‘7 8
;
‘‘8 9
c
’’ 
.
’’ 
Buffer
’’ 
.
’’ 
SetByte
’’ 
(
’’ 
index
’’ "
-
’’# $
c
’’% &
.
’’& '
Offset
’’' -
,
’’- .
value
’’/ 4
)
’’4 5
;
’’5 6
}
÷÷ 	
	protected
ÿÿ 
internal
ÿÿ 
override
ÿÿ #
void
ÿÿ$ (
	_SetShort
ÿÿ) 2
(
ÿÿ2 3
int
ÿÿ3 6
index
ÿÿ7 <
,
ÿÿ< =
int
ÿÿ> A
value
ÿÿB G
)
ÿÿG H
{
ŸŸ 	
ComponentEntry
⁄⁄ 
c
⁄⁄ 
=
⁄⁄ 
this
⁄⁄ #
.
⁄⁄# $
FindComponent
⁄⁄$ 1
(
⁄⁄1 2
index
⁄⁄2 7
)
⁄⁄7 8
;
⁄⁄8 9
if
€€ 
(
€€ 
index
€€ 
+
€€ 
$num
€€ 
<=
€€ 
c
€€ 
.
€€ 
	EndOffset
€€ (
)
€€( )
{
‹‹ 
c
›› 
.
›› 
Buffer
›› 
.
›› 
SetShort
›› !
(
››! "
index
››" '
-
››( )
c
››* +
.
››+ ,
Offset
››, 2
,
››2 3
value
››4 9
)
››9 :
;
››: ;
}
ﬁﬁ 
else
ﬂﬂ 
{
‡‡ 
this
·· 
.
·· 
_SetByte
·· 
(
·· 
index
·· #
,
··# $
(
··% &
byte
··& *
)
··* +
(
··+ ,
(
··, -
uint
··- 1
)
··1 2
value
··2 7
>>
··8 :
$num
··; <
)
··< =
)
··= >
;
··> ?
this
‚‚ 
.
‚‚ 
_SetByte
‚‚ 
(
‚‚ 
index
‚‚ #
+
‚‚$ %
$num
‚‚& '
,
‚‚' (
(
‚‚) *
byte
‚‚* .
)
‚‚. /
value
‚‚/ 4
)
‚‚4 5
;
‚‚5 6
}
„„ 
}
‰‰ 	
	protected
ÊÊ 
internal
ÊÊ 
override
ÊÊ #
void
ÊÊ$ (
_SetShortLE
ÊÊ) 4
(
ÊÊ4 5
int
ÊÊ5 8
index
ÊÊ9 >
,
ÊÊ> ?
int
ÊÊ@ C
value
ÊÊD I
)
ÊÊI J
{
ÁÁ 	
ComponentEntry
ËË 
c
ËË 
=
ËË 
this
ËË #
.
ËË# $
FindComponent
ËË$ 1
(
ËË1 2
index
ËË2 7
)
ËË7 8
;
ËË8 9
if
ÈÈ 
(
ÈÈ 
index
ÈÈ 
+
ÈÈ 
$num
ÈÈ 
<=
ÈÈ 
c
ÈÈ 
.
ÈÈ 
	EndOffset
ÈÈ (
)
ÈÈ( )
{
ÍÍ 
c
ÎÎ 
.
ÎÎ 
Buffer
ÎÎ 
.
ÎÎ 

SetShortLE
ÎÎ #
(
ÎÎ# $
index
ÎÎ$ )
-
ÎÎ* +
c
ÎÎ, -
.
ÎÎ- .
Offset
ÎÎ. 4
,
ÎÎ4 5
value
ÎÎ6 ;
)
ÎÎ; <
;
ÎÎ< =
}
ÏÏ 
else
ÌÌ 
{
ÓÓ 
this
ÔÔ 
.
ÔÔ 
_SetByte
ÔÔ 
(
ÔÔ 
index
ÔÔ #
,
ÔÔ# $
(
ÔÔ% &
byte
ÔÔ& *
)
ÔÔ* +
(
ÔÔ+ ,
value
ÔÔ, 1
.
ÔÔ1 2
RightUShift
ÔÔ2 =
(
ÔÔ= >
$num
ÔÔ> ?
)
ÔÔ? @
)
ÔÔ@ A
)
ÔÔA B
;
ÔÔB C
this
 
.
 
_SetByte
 
(
 
index
 #
+
$ %
$num
& '
,
' (
(
) *
byte
* .
)
. /
value
/ 4
)
4 5
;
5 6
}
ÒÒ 
}
ÚÚ 	
	protected
ÙÙ 
internal
ÙÙ 
override
ÙÙ #
void
ÙÙ$ (

_SetMedium
ÙÙ) 3
(
ÙÙ3 4
int
ÙÙ4 7
index
ÙÙ8 =
,
ÙÙ= >
int
ÙÙ? B
value
ÙÙC H
)
ÙÙH I
{
ıı 	
ComponentEntry
ˆˆ 
c
ˆˆ 
=
ˆˆ 
this
ˆˆ #
.
ˆˆ# $
FindComponent
ˆˆ$ 1
(
ˆˆ1 2
index
ˆˆ2 7
)
ˆˆ7 8
;
ˆˆ8 9
if
˜˜ 
(
˜˜ 
index
˜˜ 
+
˜˜ 
$num
˜˜ 
<=
˜˜ 
c
˜˜ 
.
˜˜ 
	EndOffset
˜˜ (
)
˜˜( )
{
¯¯ 
c
˘˘ 
.
˘˘ 
Buffer
˘˘ 
.
˘˘ 
	SetMedium
˘˘ "
(
˘˘" #
index
˘˘# (
-
˘˘) *
c
˘˘+ ,
.
˘˘, -
Offset
˘˘- 3
,
˘˘3 4
value
˘˘5 :
)
˘˘: ;
;
˘˘; <
}
˙˙ 
else
˚˚ 
{
¸¸ 
this
˝˝ 
.
˝˝ 
	_SetShort
˝˝ 
(
˝˝ 
index
˝˝ $
,
˝˝$ %
(
˝˝& '
short
˝˝' ,
)
˝˝, -
(
˝˝- .
value
˝˝. 3
>>
˝˝4 6
$num
˝˝7 8
)
˝˝8 9
)
˝˝9 :
;
˝˝: ;
this
˛˛ 
.
˛˛ 
_SetByte
˛˛ 
(
˛˛ 
index
˛˛ #
+
˛˛$ %
$num
˛˛& '
,
˛˛' (
(
˛˛) *
byte
˛˛* .
)
˛˛. /
value
˛˛/ 4
)
˛˛4 5
;
˛˛5 6
}
ˇˇ 
}
ÄÄ 	
	protected
ÇÇ 
internal
ÇÇ 
override
ÇÇ #
void
ÇÇ$ (
_SetMediumLE
ÇÇ) 5
(
ÇÇ5 6
int
ÇÇ6 9
index
ÇÇ: ?
,
ÇÇ? @
int
ÇÇA D
value
ÇÇE J
)
ÇÇJ K
{
ÉÉ 	
ComponentEntry
ÑÑ 
c
ÑÑ 
=
ÑÑ 
this
ÑÑ #
.
ÑÑ# $
FindComponent
ÑÑ$ 1
(
ÑÑ1 2
index
ÑÑ2 7
)
ÑÑ7 8
;
ÑÑ8 9
if
ÖÖ 
(
ÖÖ 
index
ÖÖ 
+
ÖÖ 
$num
ÖÖ 
<=
ÖÖ 
c
ÖÖ 
.
ÖÖ 
	EndOffset
ÖÖ (
)
ÖÖ( )
{
ÜÜ 
c
áá 
.
áá 
Buffer
áá 
.
áá 
SetMediumLE
áá $
(
áá$ %
index
áá% *
-
áá+ ,
c
áá- .
.
áá. /
Offset
áá/ 5
,
áá5 6
value
áá7 <
)
áá< =
;
áá= >
}
àà 
else
ââ 
{
ää 
this
ãã 
.
ãã 
_SetShortLE
ãã  
(
ãã  !
index
ãã! &
,
ãã& '
(
ãã( )
short
ãã) .
)
ãã. /
(
ãã/ 0
value
ãã0 5
>>
ãã6 8
$num
ãã9 :
)
ãã: ;
)
ãã; <
;
ãã< =
this
åå 
.
åå 
_SetByte
åå 
(
åå 
index
åå #
+
åå$ %
$num
åå& '
,
åå' (
(
åå) *
byte
åå* .
)
åå. /
value
åå/ 4
)
åå4 5
;
åå5 6
}
çç 
}
éé 	
	protected
êê 
internal
êê 
override
êê #
void
êê$ (
_SetInt
êê) 0
(
êê0 1
int
êê1 4
index
êê5 :
,
êê: ;
int
êê< ?
value
êê@ E
)
êêE F
{
ëë 	
ComponentEntry
íí 
c
íí 
=
íí 
this
íí #
.
íí# $
FindComponent
íí$ 1
(
íí1 2
index
íí2 7
)
íí7 8
;
íí8 9
if
ìì 
(
ìì 
index
ìì 
+
ìì 
$num
ìì 
<=
ìì 
c
ìì 
.
ìì 
	EndOffset
ìì (
)
ìì( )
{
îî 
c
ïï 
.
ïï 
Buffer
ïï 
.
ïï 
SetInt
ïï 
(
ïï  
index
ïï  %
-
ïï& '
c
ïï( )
.
ïï) *
Offset
ïï* 0
,
ïï0 1
value
ïï2 7
)
ïï7 8
;
ïï8 9
}
ññ 
else
óó 
{
òò 
this
ôô 
.
ôô 
	_SetShort
ôô 
(
ôô 
index
ôô $
,
ôô$ %
(
ôô& '
short
ôô' ,
)
ôô, -
(
ôô- .
(
ôô. /
uint
ôô/ 3
)
ôô3 4
value
ôô4 9
>>
ôô: <
$num
ôô= ?
)
ôô? @
)
ôô@ A
;
ôôA B
this
öö 
.
öö 
	_SetShort
öö 
(
öö 
index
öö $
+
öö% &
$num
öö' (
,
öö( )
(
öö* +
short
öö+ 0
)
öö0 1
value
öö1 6
)
öö6 7
;
öö7 8
}
õõ 
}
úú 	
	protected
ûû 
internal
ûû 
override
ûû #
void
ûû$ (
	_SetIntLE
ûû) 2
(
ûû2 3
int
ûû3 6
index
ûû7 <
,
ûû< =
int
ûû> A
value
ûûB G
)
ûûG H
{
üü 	
ComponentEntry
†† 
c
†† 
=
†† 
this
†† #
.
††# $
FindComponent
††$ 1
(
††1 2
index
††2 7
)
††7 8
;
††8 9
if
°° 
(
°° 
index
°° 
+
°° 
$num
°° 
<=
°° 
c
°° 
.
°° 
	EndOffset
°° (
)
°°( )
{
¢¢ 
c
££ 
.
££ 
Buffer
££ 
.
££ 
SetIntLE
££ !
(
££! "
index
££" '
-
££( )
c
££* +
.
££+ ,
Offset
££, 2
,
££2 3
value
££4 9
)
££9 :
;
££: ;
}
§§ 
else
•• 
{
¶¶ 
this
ßß 
.
ßß 
_SetShortLE
ßß  
(
ßß  !
index
ßß! &
,
ßß& '
(
ßß( )
short
ßß) .
)
ßß. /
value
ßß/ 4
.
ßß4 5
RightUShift
ßß5 @
(
ßß@ A
$num
ßßA C
)
ßßC D
)
ßßD E
;
ßßE F
this
®® 
.
®® 
_SetShortLE
®®  
(
®®  !
index
®®! &
+
®®' (
$num
®®) *
,
®®* +
(
®®, -
short
®®- 2
)
®®2 3
value
®®3 8
)
®®8 9
;
®®9 :
}
©© 
}
™™ 	
	protected
¨¨ 
internal
¨¨ 
override
¨¨ #
void
¨¨$ (
_SetLong
¨¨) 1
(
¨¨1 2
int
¨¨2 5
index
¨¨6 ;
,
¨¨; <
long
¨¨= A
value
¨¨B G
)
¨¨G H
{
≠≠ 	
ComponentEntry
ÆÆ 
c
ÆÆ 
=
ÆÆ 
this
ÆÆ #
.
ÆÆ# $
FindComponent
ÆÆ$ 1
(
ÆÆ1 2
index
ÆÆ2 7
)
ÆÆ7 8
;
ÆÆ8 9
if
ØØ 
(
ØØ 
index
ØØ 
+
ØØ 
$num
ØØ 
<=
ØØ 
c
ØØ 
.
ØØ 
	EndOffset
ØØ (
)
ØØ( )
{
∞∞ 
c
±± 
.
±± 
Buffer
±± 
.
±± 
SetLong
±±  
(
±±  !
index
±±! &
-
±±' (
c
±±) *
.
±±* +
Offset
±±+ 1
,
±±1 2
value
±±3 8
)
±±8 9
;
±±9 :
}
≤≤ 
else
≥≥ 
{
¥¥ 
this
µµ 
.
µµ 
_SetInt
µµ 
(
µµ 
index
µµ "
,
µµ" #
(
µµ$ %
int
µµ% (
)
µµ( )
(
µµ) *
(
µµ* +
ulong
µµ+ 0
)
µµ0 1
value
µµ1 6
>>
µµ7 9
$num
µµ: <
)
µµ< =
)
µµ= >
;
µµ> ?
this
∂∂ 
.
∂∂ 
_SetInt
∂∂ 
(
∂∂ 
index
∂∂ "
+
∂∂# $
$num
∂∂% &
,
∂∂& '
(
∂∂( )
int
∂∂) ,
)
∂∂, -
value
∂∂- 2
)
∂∂2 3
;
∂∂3 4
}
∑∑ 
}
∏∏ 	
	protected
∫∫ 
internal
∫∫ 
override
∫∫ #
void
∫∫$ (

_SetLongLE
∫∫) 3
(
∫∫3 4
int
∫∫4 7
index
∫∫8 =
,
∫∫= >
long
∫∫? C
value
∫∫D I
)
∫∫I J
{
ªª 	
ComponentEntry
ºº 
c
ºº 
=
ºº 
this
ºº #
.
ºº# $
FindComponent
ºº$ 1
(
ºº1 2
index
ºº2 7
)
ºº7 8
;
ºº8 9
if
ΩΩ 
(
ΩΩ 
index
ΩΩ 
+
ΩΩ 
$num
ΩΩ 
<=
ΩΩ 
c
ΩΩ 
.
ΩΩ 
	EndOffset
ΩΩ (
)
ΩΩ( )
{
ææ 
c
øø 
.
øø 
Buffer
øø 
.
øø 
	SetLongLE
øø "
(
øø" #
index
øø# (
-
øø) *
c
øø+ ,
.
øø, -
Offset
øø- 3
,
øø3 4
value
øø5 :
)
øø: ;
;
øø; <
}
¿¿ 
else
¡¡ 
{
¬¬ 
this
√√ 
.
√√ 
	_SetIntLE
√√ 
(
√√ 
index
√√ $
,
√√$ %
(
√√& '
int
√√' *
)
√√* +
value
√√+ 0
.
√√0 1
RightUShift
√√1 <
(
√√< =
$num
√√= ?
)
√√? @
)
√√@ A
;
√√A B
this
ƒƒ 
.
ƒƒ 
	_SetIntLE
ƒƒ 
(
ƒƒ 
index
ƒƒ $
+
ƒƒ% &
$num
ƒƒ' (
,
ƒƒ( )
(
ƒƒ* +
int
ƒƒ+ .
)
ƒƒ. /
value
ƒƒ/ 4
)
ƒƒ4 5
;
ƒƒ5 6
}
≈≈ 
}
∆∆ 	
public
»» 
override
»» 
IByteBuffer
»» #
SetBytes
»»$ ,
(
»», -
int
»»- 0
index
»»1 6
,
»»6 7
byte
»»8 <
[
»»< =
]
»»= >
src
»»? B
,
»»B C
int
»»D G
srcIndex
»»H P
,
»»P Q
int
»»R U
length
»»V \
)
»»\ ]
{
…… 	
this
   
.
   
CheckSrcIndex
   
(
   
index
   $
,
  $ %
length
  & ,
,
  , -
srcIndex
  . 6
,
  6 7
src
  8 ;
.
  ; <
Length
  < B
)
  B C
;
  C D
if
ÀÀ 
(
ÀÀ 
length
ÀÀ 
==
ÀÀ 
$num
ÀÀ 
)
ÀÀ 
{
ÃÃ 
return
ÕÕ 
this
ÕÕ 
;
ÕÕ 
}
ŒŒ 
int
–– 
i
–– 
=
–– 
this
–– 
.
–– 
ToComponentIndex
–– )
(
––) *
index
––* /
)
––/ 0
;
––0 1
while
—— 
(
—— 
length
—— 
>
—— 
$num
—— 
)
—— 
{
““ 
ComponentEntry
”” 
c
””  
=
””! "
this
””# '
.
””' (

components
””( 2
[
””2 3
i
””3 4
]
””4 5
;
””5 6
IByteBuffer
‘‘ 
s
‘‘ 
=
‘‘ 
c
‘‘  !
.
‘‘! "
Buffer
‘‘" (
;
‘‘( )
int
’’ 

adjustment
’’ 
=
’’  
c
’’! "
.
’’" #
Offset
’’# )
;
’’) *
int
÷÷ 
localLength
÷÷ 
=
÷÷  !
Math
÷÷" &
.
÷÷& '
Min
÷÷' *
(
÷÷* +
length
÷÷+ 1
,
÷÷1 2
s
÷÷3 4
.
÷÷4 5
Capacity
÷÷5 =
-
÷÷> ?
(
÷÷@ A
index
÷÷A F
-
÷÷G H

adjustment
÷÷I S
)
÷÷S T
)
÷÷T U
;
÷÷U V
s
◊◊ 
.
◊◊ 
SetBytes
◊◊ 
(
◊◊ 
index
◊◊  
-
◊◊! "

adjustment
◊◊# -
,
◊◊- .
src
◊◊/ 2
,
◊◊2 3
srcIndex
◊◊4 <
,
◊◊< =
localLength
◊◊> I
)
◊◊I J
;
◊◊J K
index
ÿÿ 
+=
ÿÿ 
localLength
ÿÿ $
;
ÿÿ$ %
srcIndex
ŸŸ 
+=
ŸŸ 
localLength
ŸŸ '
;
ŸŸ' (
length
⁄⁄ 
-=
⁄⁄ 
localLength
⁄⁄ %
;
⁄⁄% &
i
€€ 
++
€€ 
;
€€ 
}
‹‹ 
return
›› 
this
›› 
;
›› 
}
ﬁﬁ 	
public
‡‡ 
override
‡‡ 
async
‡‡ 
Task
‡‡ "
<
‡‡" #
int
‡‡# &
>
‡‡& '
SetBytesAsync
‡‡( 5
(
‡‡5 6
int
‡‡6 9
index
‡‡: ?
,
‡‡? @
Stream
‡‡A G
src
‡‡H K
,
‡‡K L
int
‡‡M P
length
‡‡Q W
,
‡‡W X
CancellationToken
‡‡Y j
cancellationToken
‡‡k |
)
‡‡| }
{
·· 	
this
‚‚ 
.
‚‚ 

CheckIndex
‚‚ 
(
‚‚ 
index
‚‚ !
,
‚‚! "
length
‚‚# )
)
‚‚) *
;
‚‚* +
if
„„ 
(
„„ 
length
„„ 
==
„„ 
$num
„„ 
)
„„ 
{
‰‰ 
return
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
}
ÁÁ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
this
ÈÈ 
.
ÈÈ 
ToComponentIndex
ÈÈ )
(
ÈÈ) *
index
ÈÈ* /
)
ÈÈ/ 0
;
ÈÈ0 1
int
ÍÍ 
	readBytes
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
do
ÏÏ 
{
ÌÌ 
ComponentEntry
ÓÓ 
c
ÓÓ  
=
ÓÓ! "
this
ÓÓ# '
.
ÓÓ' (

components
ÓÓ( 2
[
ÓÓ2 3
i
ÓÓ3 4
]
ÓÓ4 5
;
ÓÓ5 6
IByteBuffer
ÔÔ 
s
ÔÔ 
=
ÔÔ 
c
ÔÔ  !
.
ÔÔ! "
Buffer
ÔÔ" (
;
ÔÔ( )
int
 

adjustment
 
=
  
c
! "
.
" #
Offset
# )
;
) *
int
ÒÒ 
localLength
ÒÒ 
=
ÒÒ  !
Math
ÒÒ" &
.
ÒÒ& '
Min
ÒÒ' *
(
ÒÒ* +
length
ÒÒ+ 1
,
ÒÒ1 2
s
ÒÒ3 4
.
ÒÒ4 5
Capacity
ÒÒ5 =
-
ÒÒ> ?
(
ÒÒ@ A
index
ÒÒA F
-
ÒÒG H

adjustment
ÒÒI S
)
ÒÒS T
)
ÒÒT U
;
ÒÒU V
int
ÚÚ 
localReadBytes
ÚÚ "
=
ÚÚ# $
await
ÚÚ% *
s
ÚÚ+ ,
.
ÚÚ, -
SetBytesAsync
ÚÚ- :
(
ÚÚ: ;
index
ÚÚ; @
-
ÚÚA B

adjustment
ÚÚC M
,
ÚÚM N
src
ÚÚO R
,
ÚÚR S
localLength
ÚÚT _
,
ÚÚ_ `
cancellationToken
ÚÚa r
)
ÚÚr s
;
ÚÚs t
if
ÛÛ 
(
ÛÛ 
localReadBytes
ÛÛ "
<
ÛÛ# $
$num
ÛÛ% &
)
ÛÛ& '
{
ÙÙ 
if
ıı 
(
ıı 
	readBytes
ıı !
==
ıı" $
$num
ıı% &
)
ıı& '
{
ˆˆ 
return
˜˜ 
-
˜˜  
$num
˜˜  !
;
˜˜! "
}
¯¯ 
else
˘˘ 
{
˙˙ 
break
˚˚ 
;
˚˚ 
}
¸¸ 
}
˝˝ 
if
ˇˇ 
(
ˇˇ 
localReadBytes
ˇˇ "
==
ˇˇ# %
localLength
ˇˇ& 1
)
ˇˇ1 2
{
Ä	Ä	 
index
Å	Å	 
+=
Å	Å	 
localLength
Å	Å	 (
;
Å	Å	( )
length
Ç	Ç	 
-=
Ç	Ç	 
localLength
Ç	Ç	 )
;
Ç	Ç	) *
	readBytes
É	É	 
+=
É	É	  
localLength
É	É	! ,
;
É	É	, -
i
Ñ	Ñ	 
++
Ñ	Ñ	 
;
Ñ	Ñ	 
}
Ö	Ö	 
else
Ü	Ü	 
{
á	á	 
index
à	à	 
+=
à	à	 
localReadBytes
à	à	 +
;
à	à	+ ,
length
â	â	 
-=
â	â	 
localReadBytes
â	â	 ,
;
â	â	, -
	readBytes
ä	ä	 
+=
ä	ä	  
localReadBytes
ä	ä	! /
;
ä	ä	/ 0
}
ã	ã	 
}
å	å	 
while
ç	ç	 
(
ç	ç	 
length
ç	ç	 
>
ç	ç	 
$num
ç	ç	 
)
ç	ç	 
;
ç	ç	 
return
è	è	 
	readBytes
è	è	 
;
è	è	 
}
ê	ê	 	
public
í	í	 
override
í	í	 
IByteBuffer
í	í	 #
SetBytes
í	í	$ ,
(
í	í	, -
int
í	í	- 0
index
í	í	1 6
,
í	í	6 7
IByteBuffer
í	í	8 C
src
í	í	D G
,
í	í	G H
int
í	í	I L
srcIndex
í	í	M U
,
í	í	U V
int
í	í	W Z
length
í	í	[ a
)
í	í	a b
{
ì	ì	 	
this
î	î	 
.
î	î	 
CheckSrcIndex
î	î	 
(
î	î	 
index
î	î	 $
,
î	î	$ %
length
î	î	& ,
,
î	î	, -
srcIndex
î	î	. 6
,
î	î	6 7
src
î	î	8 ;
.
î	î	; <
Capacity
î	î	< D
)
î	î	D E
;
î	î	E F
if
ï	ï	 
(
ï	ï	 
length
ï	ï	 
==
ï	ï	 
$num
ï	ï	 
)
ï	ï	 
{
ñ	ñ	 
return
ó	ó	 
this
ó	ó	 
;
ó	ó	 
}
ò	ò	 
int
ö	ö	 
i
ö	ö	 
=
ö	ö	 
this
ö	ö	 
.
ö	ö	 
ToComponentIndex
ö	ö	 )
(
ö	ö	) *
index
ö	ö	* /
)
ö	ö	/ 0
;
ö	ö	0 1
while
õ	õ	 
(
õ	õ	 
length
õ	õ	 
>
õ	õ	 
$num
õ	õ	 
)
õ	õ	 
{
ú	ú	 
ComponentEntry
ù	ù	 
c
ù	ù	  
=
ù	ù	! "
this
ù	ù	# '
.
ù	ù	' (

components
ù	ù	( 2
[
ù	ù	2 3
i
ù	ù	3 4
]
ù	ù	4 5
;
ù	ù	5 6
IByteBuffer
û	û	 
s
û	û	 
=
û	û	 
c
û	û	  !
.
û	û	! "
Buffer
û	û	" (
;
û	û	( )
int
ü	ü	 

adjustment
ü	ü	 
=
ü	ü	  
c
ü	ü	! "
.
ü	ü	" #
Offset
ü	ü	# )
;
ü	ü	) *
int
†	†	 
localLength
†	†	 
=
†	†	  !
Math
†	†	" &
.
†	†	& '
Min
†	†	' *
(
†	†	* +
length
†	†	+ 1
,
†	†	1 2
s
†	†	3 4
.
†	†	4 5
Capacity
†	†	5 =
-
†	†	> ?
(
†	†	@ A
index
†	†	A F
-
†	†	G H

adjustment
†	†	I S
)
†	†	S T
)
†	†	T U
;
†	†	U V
s
°	°	 
.
°	°	 
SetBytes
°	°	 
(
°	°	 
index
°	°	  
-
°	°	! "

adjustment
°	°	# -
,
°	°	- .
src
°	°	/ 2
,
°	°	2 3
srcIndex
°	°	4 <
,
°	°	< =
localLength
°	°	> I
)
°	°	I J
;
°	°	J K
index
¢	¢	 
+=
¢	¢	 
localLength
¢	¢	 $
;
¢	¢	$ %
srcIndex
£	£	 
+=
£	£	 
localLength
£	£	 '
;
£	£	' (
length
§	§	 
-=
§	§	 
localLength
§	§	 %
;
§	§	% &
i
•	•	 
++
•	•	 
;
•	•	 
}
¶	¶	 
return
ß	ß	 
this
ß	ß	 
;
ß	ß	 
}
®	®	 	
public
™	™	 
override
™	™	 
IByteBuffer
™	™	 #
SetZero
™	™	$ +
(
™	™	+ ,
int
™	™	, /
index
™	™	0 5
,
™	™	5 6
int
™	™	7 :
length
™	™	; A
)
™	™	A B
{
´	´	 	
this
¨	¨	 
.
¨	¨	 

CheckIndex
¨	¨	 
(
¨	¨	 
index
¨	¨	 !
,
¨	¨	! "
length
¨	¨	# )
)
¨	¨	) *
;
¨	¨	* +
if
≠	≠	 
(
≠	≠	 
length
≠	≠	 
==
≠	≠	 
$num
≠	≠	 
)
≠	≠	 
{
Æ	Æ	 
return
Ø	Ø	 
this
Ø	Ø	 
;
Ø	Ø	 
}
∞	∞	 
int
≤	≤	 
i
≤	≤	 
=
≤	≤	 
this
≤	≤	 
.
≤	≤	 
ToComponentIndex
≤	≤	 )
(
≤	≤	) *
index
≤	≤	* /
)
≤	≤	/ 0
;
≤	≤	0 1
while
≥	≥	 
(
≥	≥	 
length
≥	≥	 
>
≥	≥	 
$num
≥	≥	 
)
≥	≥	 
{
¥	¥	 
ComponentEntry
µ	µ	 
c
µ	µ	  
=
µ	µ	! "
this
µ	µ	# '
.
µ	µ	' (

components
µ	µ	( 2
[
µ	µ	2 3
i
µ	µ	3 4
]
µ	µ	4 5
;
µ	µ	5 6
IByteBuffer
∂	∂	 
s
∂	∂	 
=
∂	∂	 
c
∂	∂	  !
.
∂	∂	! "
Buffer
∂	∂	" (
;
∂	∂	( )
int
∑	∑	 

adjustment
∑	∑	 
=
∑	∑	  
c
∑	∑	! "
.
∑	∑	" #
Offset
∑	∑	# )
;
∑	∑	) *
int
∏	∏	 
localLength
∏	∏	 
=
∏	∏	  !
Math
∏	∏	" &
.
∏	∏	& '
Min
∏	∏	' *
(
∏	∏	* +
length
∏	∏	+ 1
,
∏	∏	1 2
s
∏	∏	3 4
.
∏	∏	4 5
Capacity
∏	∏	5 =
-
∏	∏	> ?
(
∏	∏	@ A
index
∏	∏	A F
-
∏	∏	G H

adjustment
∏	∏	I S
)
∏	∏	S T
)
∏	∏	T U
;
∏	∏	U V
s
π	π	 
.
π	π	 
SetZero
π	π	 
(
π	π	 
index
π	π	 
-
π	π	  !

adjustment
π	π	" ,
,
π	π	, -
localLength
π	π	. 9
)
π	π	9 :
;
π	π	: ;
index
∫	∫	 
+=
∫	∫	 
localLength
∫	∫	 $
;
∫	∫	$ %
length
ª	ª	 
-=
ª	ª	 
localLength
ª	ª	 %
;
ª	ª	% &
i
º	º	 
++
º	º	 
;
º	º	 
}
Ω	Ω	 
return
æ	æ	 
this
æ	æ	 
;
æ	æ	 
}
ø	ø	 	
public
¡	¡	 
override
¡	¡	 
IByteBuffer
¡	¡	 #
Copy
¡	¡	$ (
(
¡	¡	( )
int
¡	¡	) ,
index
¡	¡	- 2
,
¡	¡	2 3
int
¡	¡	4 7
length
¡	¡	8 >
)
¡	¡	> ?
{
¬	¬	 	
this
√	√	 
.
√	√	 

CheckIndex
√	√	 
(
√	√	 
index
√	√	 !
,
√	√	! "
length
√	√	# )
)
√	√	) *
;
√	√	* +
IByteBuffer
ƒ	ƒ	 
dst
ƒ	ƒ	 
=
ƒ	ƒ	 
this
ƒ	ƒ	 "
.
ƒ	ƒ	" #
AllocateBuffer
ƒ	ƒ	# 1
(
ƒ	ƒ	1 2
length
ƒ	ƒ	2 8
)
ƒ	ƒ	8 9
;
ƒ	ƒ	9 :
if
≈	≈	 
(
≈	≈	 
length
≈	≈	 
!=
≈	≈	 
$num
≈	≈	 
)
≈	≈	 
{
∆	∆	 
this
«	«	 
.
«	«	 
CopyTo
«	«	 
(
«	«	 
index
«	«	 !
,
«	«	! "
length
«	«	# )
,
«	«	) *
this
«	«	+ /
.
«	«	/ 0
ToComponentIndex
«	«	0 @
(
«	«	@ A
index
«	«	A F
)
«	«	F G
,
«	«	G H
dst
«	«	I L
)
«	«	L M
;
«	«	M N
}
»	»	 
return
…	…	 
dst
…	…	 
;
…	…	 
}
 	 	 	
void
Ã	Ã	 
CopyTo
Ã	Ã	 
(
Ã	Ã	 
int
Ã	Ã	 
index
Ã	Ã	 
,
Ã	Ã	 
int
Ã	Ã	 "
length
Ã	Ã	# )
,
Ã	Ã	) *
int
Ã	Ã	+ .
componentId
Ã	Ã	/ :
,
Ã	Ã	: ;
IByteBuffer
Ã	Ã	< G
dst
Ã	Ã	H K
)
Ã	Ã	K L
{
Õ	Õ	 	
int
Œ	Œ	 
dstIndex
Œ	Œ	 
=
Œ	Œ	 
$num
Œ	Œ	 
;
Œ	Œ	 
int
œ	œ	 
i
œ	œ	 
=
œ	œ	 
componentId
œ	œ	 
;
œ	œ	  
while
—	—	 
(
—	—	 
length
—	—	 
>
—	—	 
$num
—	—	 
)
—	—	 
{
“	“	 
ComponentEntry
”	”	 
c
”	”	  
=
”	”	! "
this
”	”	# '
.
”	”	' (

components
”	”	( 2
[
”	”	2 3
i
”	”	3 4
]
”	”	4 5
;
”	”	5 6
IByteBuffer
‘	‘	 
s
‘	‘	 
=
‘	‘	 
c
‘	‘	  !
.
‘	‘	! "
Buffer
‘	‘	" (
;
‘	‘	( )
int
’	’	 

adjustment
’	’	 
=
’	’	  
c
’	’	! "
.
’	’	" #
Offset
’	’	# )
;
’	’	) *
int
÷	÷	 
localLength
÷	÷	 
=
÷	÷	  !
Math
÷	÷	" &
.
÷	÷	& '
Min
÷	÷	' *
(
÷	÷	* +
length
÷	÷	+ 1
,
÷	÷	1 2
s
÷	÷	3 4
.
÷	÷	4 5
Capacity
÷	÷	5 =
-
÷	÷	> ?
(
÷	÷	@ A
index
÷	÷	A F
-
÷	÷	G H

adjustment
÷	÷	I S
)
÷	÷	S T
)
÷	÷	T U
;
÷	÷	U V
s
◊	◊	 
.
◊	◊	 
GetBytes
◊	◊	 
(
◊	◊	 
index
◊	◊	  
-
◊	◊	! "

adjustment
◊	◊	# -
,
◊	◊	- .
dst
◊	◊	/ 2
,
◊	◊	2 3
dstIndex
◊	◊	4 <
,
◊	◊	< =
localLength
◊	◊	> I
)
◊	◊	I J
;
◊	◊	J K
index
ÿ	ÿ	 
+=
ÿ	ÿ	 
localLength
ÿ	ÿ	 $
;
ÿ	ÿ	$ %
dstIndex
Ÿ	Ÿ	 
+=
Ÿ	Ÿ	 
localLength
Ÿ	Ÿ	 '
;
Ÿ	Ÿ	' (
length
⁄	⁄	 
-=
⁄	⁄	 
localLength
⁄	⁄	 %
;
⁄	⁄	% &
i
€	€	 
++
€	€	 
;
€	€	 
}
‹	‹	 
dst
ﬁ	ﬁ	 
.
ﬁ	ﬁ	 
SetWriterIndex
ﬁ	ﬁ	 
(
ﬁ	ﬁ	 
dst
ﬁ	ﬁ	 "
.
ﬁ	ﬁ	" #
Capacity
ﬁ	ﬁ	# +
)
ﬁ	ﬁ	+ ,
;
ﬁ	ﬁ	, -
}
ﬂ	ﬂ	 	
public
Ê	Ê	 
virtual
Ê	Ê	 
IByteBuffer
Ê	Ê	 "
this
Ê	Ê	# '
[
Ê	Ê	' (
int
Ê	Ê	( +
cIndex
Ê	Ê	, 2
]
Ê	Ê	2 3
=>
Ê	Ê	4 6
this
Ê	Ê	7 ;
.
Ê	Ê	; <
InternalComponent
Ê	Ê	< M
(
Ê	Ê	M N
cIndex
Ê	Ê	N T
)
Ê	Ê	T U
.
Ê	Ê	U V
	Duplicate
Ê	Ê	V _
(
Ê	Ê	_ `
)
Ê	Ê	` a
;
Ê	Ê	a b
public
Ì	Ì	 
virtual
Ì	Ì	 
IByteBuffer
Ì	Ì	 "
ComponentAtOffset
Ì	Ì	# 4
(
Ì	Ì	4 5
int
Ì	Ì	5 8
offset
Ì	Ì	9 ?
)
Ì	Ì	? @
=>
Ì	Ì	A C
this
Ì	Ì	D H
.
Ì	Ì	H I'
InternalComponentAtOffset
Ì	Ì	I b
(
Ì	Ì	b c
offset
Ì	Ì	c i
)
Ì	Ì	i j
.
Ì	Ì	j k
	Duplicate
Ì	Ì	k t
(
Ì	Ì	t u
)
Ì	Ì	u v
;
Ì	Ì	v w
public
Ù	Ù	 
virtual
Ù	Ù	 
IByteBuffer
Ù	Ù	 "
InternalComponent
Ù	Ù	# 4
(
Ù	Ù	4 5
int
Ù	Ù	5 8
cIndex
Ù	Ù	9 ?
)
Ù	Ù	? @
{
ı	ı	 	
this
ˆ	ˆ	 
.
ˆ	ˆ	 !
CheckComponentIndex
ˆ	ˆ	 $
(
ˆ	ˆ	$ %
cIndex
ˆ	ˆ	% +
)
ˆ	ˆ	+ ,
;
ˆ	ˆ	, -
return
˜	˜	 
this
˜	˜	 
.
˜	˜	 

components
˜	˜	 "
[
˜	˜	" #
cIndex
˜	˜	# )
]
˜	˜	) *
.
˜	˜	* +
Buffer
˜	˜	+ 1
;
˜	˜	1 2
}
¯	¯	 	
public
ˇ	ˇ	 
virtual
ˇ	ˇ	 
IByteBuffer
ˇ	ˇ	 "'
InternalComponentAtOffset
ˇ	ˇ	# <
(
ˇ	ˇ	< =
int
ˇ	ˇ	= @
offset
ˇ	ˇ	A G
)
ˇ	ˇ	G H
=>
ˇ	ˇ	I K
this
ˇ	ˇ	L P
.
ˇ	ˇ	P Q
FindComponent
ˇ	ˇ	Q ^
(
ˇ	ˇ	^ _
offset
ˇ	ˇ	_ e
)
ˇ	ˇ	e f
.
ˇ	ˇ	f g
Buffer
ˇ	ˇ	g m
;
ˇ	ˇ	m n
ComponentEntry
Å
Å
 
FindComponent
Å
Å
 $
(
Å
Å
$ %
int
Å
Å
% (
offset
Å
Å
) /
)
Å
Å
/ 0
{
Ç
Ç
 	
this
É
É
 
.
É
É
 

CheckIndex
É
É
 
(
É
É
 
offset
É
É
 "
)
É
É
" #
;
É
É
# $
for
Ö
Ö
 
(
Ö
Ö
 
int
Ö
Ö
 
low
Ö
Ö
 
=
Ö
Ö
 
$num
Ö
Ö
 
,
Ö
Ö
 
high
Ö
Ö
 "
=
Ö
Ö
# $
this
Ö
Ö
% )
.
Ö
Ö
) *

components
Ö
Ö
* 4
.
Ö
Ö
4 5
Count
Ö
Ö
5 :
;
Ö
Ö
: ;
low
Ö
Ö
< ?
<=
Ö
Ö
@ B
high
Ö
Ö
C G
;
Ö
Ö
G H
)
Ö
Ö
H I
{
Ü
Ü
 
int
á
á
 
mid
á
á
 
=
á
á
 
(
á
á
 
low
á
á
 
+
á
á
  
high
á
á
! %
)
á
á
% &
.
á
á
& '
RightUShift
á
á
' 2
(
á
á
2 3
$num
á
á
3 4
)
á
á
4 5
;
á
á
5 6
ComponentEntry
à
à
 
c
à
à
  
=
à
à
! "
this
à
à
# '
.
à
à
' (

components
à
à
( 2
[
à
à
2 3
mid
à
à
3 6
]
à
à
6 7
;
à
à
7 8
if
â
â
 
(
â
â
 
offset
â
â
 
>=
â
â
 
c
â
â
 
.
â
â
  
	EndOffset
â
â
  )
)
â
â
) *
{
ä
ä
 
low
ã
ã
 
=
ã
ã
 
mid
ã
ã
 
+
ã
ã
 
$num
ã
ã
  !
;
ã
ã
! "
}
å
å
 
else
ç
ç
 
if
ç
ç
 
(
ç
ç
 
offset
ç
ç
 
<
ç
ç
  !
c
ç
ç
" #
.
ç
ç
# $
Offset
ç
ç
$ *
)
ç
ç
* +
{
é
é
 
high
è
è
 
=
è
è
 
mid
è
è
 
-
è
è
  
$num
è
è
! "
;
è
è
" #
}
ê
ê
 
else
ë
ë
 
{
í
í
 
Contract
ì
ì
 
.
ì
ì
 
Assert
ì
ì
 #
(
ì
ì
# $
c
ì
ì
$ %
.
ì
ì
% &
Length
ì
ì
& ,
!=
ì
ì
- /
$num
ì
ì
0 1
)
ì
ì
1 2
;
ì
ì
2 3
return
î
î
 
c
î
î
 
;
î
î
 
}
ï
ï
 
}
ñ
ñ
 
throw
ò
ò
 
new
ò
ò
 
	Exception
ò
ò
 
(
ò
ò
  
$str
ò
ò
  7
)
ò
ò
7 8
;
ò
ò
8 9
}
ô
ô
 	
public
û
û
 
virtual
û
û
 !
CompositeByteBuffer
û
û
 *
Consolidate
û
û
+ 6
(
û
û
6 7
)
û
û
7 8
{
ü
ü
 	
this
†
†
 
.
†
†
 
EnsureAccessible
†
†
 !
(
†
†
! "
)
†
†
" #
;
†
†
# $
int
°
°
 
numComponents
°
°
 
=
°
°
 
this
°
°
  $
.
°
°
$ %
NumComponents
°
°
% 2
;
°
°
2 3
if
¢
¢
 
(
¢
¢
 
numComponents
¢
¢
 
<=
¢
¢
  
$num
¢
¢
! "
)
¢
¢
" #
{
£
£
 
return
§
§
 
this
§
§
 
;
§
§
 
}
•
•
 
ComponentEntry
ß
ß
 
last
ß
ß
 
=
ß
ß
  !
this
ß
ß
" &
.
ß
ß
& '

components
ß
ß
' 1
[
ß
ß
1 2
numComponents
ß
ß
2 ?
-
ß
ß
@ A
$num
ß
ß
B C
]
ß
ß
C D
;
ß
ß
D E
int
®
®
 
capacity
®
®
 
=
®
®
 
last
®
®
 
.
®
®
  
	EndOffset
®
®
  )
;
®
®
) *
IByteBuffer
©
©
 
consolidated
©
©
 $
=
©
©
% &
this
©
©
' +
.
©
©
+ ,
AllocateBuffer
©
©
, :
(
©
©
: ;
capacity
©
©
; C
)
©
©
C D
;
©
©
D E
for
´
´
 
(
´
´
 
int
´
´
 
i
´
´
 
=
´
´
 
$num
´
´
 
;
´
´
 
i
´
´
 
<
´
´
 
numComponents
´
´
  -
;
´
´
- .
i
´
´
/ 0
++
´
´
0 2
)
´
´
2 3
{
¨
¨
 
ComponentEntry
≠
≠
 
c
≠
≠
  
=
≠
≠
! "
this
≠
≠
# '
.
≠
≠
' (

components
≠
≠
( 2
[
≠
≠
2 3
i
≠
≠
3 4
]
≠
≠
4 5
;
≠
≠
5 6
IByteBuffer
Æ
Æ
 
b
Æ
Æ
 
=
Æ
Æ
 
c
Æ
Æ
  !
.
Æ
Æ
! "
Buffer
Æ
Æ
" (
;
Æ
Æ
( )
consolidated
Ø
Ø
 
.
Ø
Ø
 

WriteBytes
Ø
Ø
 '
(
Ø
Ø
' (
b
Ø
Ø
( )
)
Ø
Ø
) *
;
Ø
Ø
* +
c
∞
∞
 
.
∞
∞
 
FreeIfNecessary
∞
∞
 !
(
∞
∞
! "
)
∞
∞
" #
;
∞
∞
# $
}
±
±
 
this
≥
≥
 
.
≥
≥
 

components
≥
≥
 
.
≥
≥
 
Clear
≥
≥
 !
(
≥
≥
! "
)
≥
≥
" #
;
≥
≥
# $
this
¥
¥
 
.
¥
¥
 

components
¥
¥
 
.
¥
¥
 
Add
¥
¥
 
(
¥
¥
  
new
¥
¥
  #
ComponentEntry
¥
¥
$ 2
(
¥
¥
2 3
consolidated
¥
¥
3 ?
)
¥
¥
? @
)
¥
¥
@ A
;
¥
¥
A B
this
µ
µ
 
.
µ
µ
 $
UpdateComponentOffsets
µ
µ
 '
(
µ
µ
' (
$num
µ
µ
( )
)
µ
µ
) *
;
µ
µ
* +
return
∂
∂
 
this
∂
∂
 
;
∂
∂
 
}
∑
∑
 	
public
æ
æ
 
virtual
æ
æ
 !
CompositeByteBuffer
æ
æ
 *
Consolidate
æ
æ
+ 6
(
æ
æ
6 7
int
æ
æ
7 :
cIndex
æ
æ
; A
,
æ
æ
A B
int
æ
æ
C F
numComponents
æ
æ
G T
)
æ
æ
T U
{
ø
ø
 	
this
¿
¿
 
.
¿
¿
 !
CheckComponentIndex
¿
¿
 $
(
¿
¿
$ %
cIndex
¿
¿
% +
,
¿
¿
+ ,
numComponents
¿
¿
- :
)
¿
¿
: ;
;
¿
¿
; <
if
¡
¡
 
(
¡
¡
 
numComponents
¡
¡
 
<=
¡
¡
  
$num
¡
¡
! "
)
¡
¡
" #
{
¬
¬
 
return
√
√
 
this
√
√
 
;
√
√
 
}
ƒ
ƒ
 
int
∆
∆
 
	endCIndex
∆
∆
 
=
∆
∆
 
cIndex
∆
∆
 "
+
∆
∆
# $
numComponents
∆
∆
% 2
;
∆
∆
2 3
ComponentEntry
«
«
 
last
«
«
 
=
«
«
  !
this
«
«
" &
.
«
«
& '

components
«
«
' 1
[
«
«
1 2
	endCIndex
«
«
2 ;
-
«
«
< =
$num
«
«
> ?
]
«
«
? @
;
«
«
@ A
int
»
»
 
capacity
»
»
 
=
»
»
 
last
»
»
 
.
»
»
  
	EndOffset
»
»
  )
-
»
»
* +
this
»
»
, 0
.
»
»
0 1

components
»
»
1 ;
[
»
»
; <
cIndex
»
»
< B
]
»
»
B C
.
»
»
C D
Offset
»
»
D J
;
»
»
J K
IByteBuffer
…
…
 
consolidated
…
…
 $
=
…
…
% &
this
…
…
' +
.
…
…
+ ,
AllocateBuffer
…
…
, :
(
…
…
: ;
capacity
…
…
; C
)
…
…
C D
;
…
…
D E
for
À
À
 
(
À
À
 
int
À
À
 
i
À
À
 
=
À
À
 
cIndex
À
À
 
;
À
À
  
i
À
À
! "
<
À
À
# $
	endCIndex
À
À
% .
;
À
À
. /
i
À
À
0 1
++
À
À
1 3
)
À
À
3 4
{
Ã
Ã
 
ComponentEntry
Õ
Õ
 
c
Õ
Õ
  
=
Õ
Õ
! "
this
Õ
Õ
# '
.
Õ
Õ
' (

components
Õ
Õ
( 2
[
Õ
Õ
2 3
i
Õ
Õ
3 4
]
Õ
Õ
4 5
;
Õ
Õ
5 6
IByteBuffer
Œ
Œ
 
b
Œ
Œ
 
=
Œ
Œ
 
c
Œ
Œ
  !
.
Œ
Œ
! "
Buffer
Œ
Œ
" (
;
Œ
Œ
( )
consolidated
œ
œ
 
.
œ
œ
 

WriteBytes
œ
œ
 '
(
œ
œ
' (
b
œ
œ
( )
)
œ
œ
) *
;
œ
œ
* +
c
–
–
 
.
–
–
 
FreeIfNecessary
–
–
 !
(
–
–
! "
)
–
–
" #
;
–
–
# $
}
—
—
 
this
”
”
 
.
”
”
 

components
”
”
 
.
”
”
 
RemoveRange
”
”
 '
(
”
”
' (
cIndex
”
”
( .
,
”
”
. /
numComponents
”
”
0 =
)
”
”
= >
;
”
”
> ?
this
‘
‘
 
.
‘
‘
 

components
‘
‘
 
.
‘
‘
 
Insert
‘
‘
 "
(
‘
‘
" #
cIndex
‘
‘
# )
,
‘
‘
) *
new
‘
‘
* -
ComponentEntry
‘
‘
. <
(
‘
‘
< =
consolidated
‘
‘
= I
)
‘
‘
I J
)
‘
‘
J K
;
‘
‘
K L
this
’
’
 
.
’
’
 $
UpdateComponentOffsets
’
’
 '
(
’
’
' (
cIndex
’
’
( .
)
’
’
. /
;
’
’
/ 0
return
÷
÷
 
this
÷
÷
 
;
÷
÷
 
}
◊
◊
 	
public
‹
‹
 
virtual
‹
‹
 !
CompositeByteBuffer
‹
‹
 *#
DiscardReadComponents
‹
‹
+ @
(
‹
‹
@ A
)
‹
‹
A B
{
›
›
 	
this
ﬁ
ﬁ
 
.
ﬁ
ﬁ
 
EnsureAccessible
ﬁ
ﬁ
 !
(
ﬁ
ﬁ
! "
)
ﬁ
ﬁ
" #
;
ﬁ
ﬁ
# $
int
ﬂ
ﬂ
 
readerIndex
ﬂ
ﬂ
 
=
ﬂ
ﬂ
 
this
ﬂ
ﬂ
 "
.
ﬂ
ﬂ
" #
ReaderIndex
ﬂ
ﬂ
# .
;
ﬂ
ﬂ
. /
if
‡
‡
 
(
‡
‡
 
readerIndex
‡
‡
 
==
‡
‡
 
$num
‡
‡
  
)
‡
‡
  !
{
·
·
 
return
‚
‚
 
this
‚
‚
 
;
‚
‚
 
}
„
„
 
int
Ê
Ê
 
writerIndex
Ê
Ê
 
=
Ê
Ê
 
this
Ê
Ê
 "
.
Ê
Ê
" #
WriterIndex
Ê
Ê
# .
;
Ê
Ê
. /
if
Á
Á
 
(
Á
Á
 
readerIndex
Á
Á
 
==
Á
Á
 
writerIndex
Á
Á
 *
&&
Á
Á
+ -
writerIndex
Á
Á
. 9
==
Á
Á
: <
this
Á
Á
= A
.
Á
Á
A B
Capacity
Á
Á
B J
)
Á
Á
J K
{
Ë
Ë
 
foreach
È
È
 
(
È
È
 
ComponentEntry
È
È
 '
c
È
È
( )
in
È
È
* ,
this
È
È
- 1
.
È
È
1 2

components
È
È
2 <
)
È
È
< =
{
Í
Í
 
c
Î
Î
 
.
Î
Î
 
FreeIfNecessary
Î
Î
 %
(
Î
Î
% &
)
Î
Î
& '
;
Î
Î
' (
}
Ï
Ï
 
this
Ì
Ì
 
.
Ì
Ì
 

components
Ì
Ì
 
.
Ì
Ì
  
Clear
Ì
Ì
  %
(
Ì
Ì
% &
)
Ì
Ì
& '
;
Ì
Ì
' (
this
Ó
Ó
 
.
Ó
Ó
 
SetIndex
Ó
Ó
 
(
Ó
Ó
 
$num
Ó
Ó
 
,
Ó
Ó
  
$num
Ó
Ó
! "
)
Ó
Ó
" #
;
Ó
Ó
# $
this
Ô
Ô
 
.
Ô
Ô
 
AdjustMarkers
Ô
Ô
 "
(
Ô
Ô
" #
readerIndex
Ô
Ô
# .
)
Ô
Ô
. /
;
Ô
Ô
/ 0
return


 
this


 
;


 
}
Ò
Ò
 
int
Ù
Ù
 
firstComponentId
Ù
Ù
  
=
Ù
Ù
! "
this
Ù
Ù
# '
.
Ù
Ù
' (
ToComponentIndex
Ù
Ù
( 8
(
Ù
Ù
8 9
readerIndex
Ù
Ù
9 D
)
Ù
Ù
D E
;
Ù
Ù
E F
for
ı
ı
 
(
ı
ı
 
int
ı
ı
 
i
ı
ı
 
=
ı
ı
 
$num
ı
ı
 
;
ı
ı
 
i
ı
ı
 
<
ı
ı
 
firstComponentId
ı
ı
  0
;
ı
ı
0 1
i
ı
ı
2 3
++
ı
ı
3 5
)
ı
ı
5 6
{
ˆ
ˆ
 
this
˜
˜
 
.
˜
˜
 

components
˜
˜
 
[
˜
˜
  
i
˜
˜
  !
]
˜
˜
! "
.
˜
˜
" #
FreeIfNecessary
˜
˜
# 2
(
˜
˜
2 3
)
˜
˜
3 4
;
˜
˜
4 5
}
¯
¯
 
this
˘
˘
 
.
˘
˘
 

components
˘
˘
 
.
˘
˘
 
RemoveRange
˘
˘
 '
(
˘
˘
' (
$num
˘
˘
( )
,
˘
˘
) *
firstComponentId
˘
˘
+ ;
)
˘
˘
; <
;
˘
˘
< =
ComponentEntry
¸
¸
 
first
¸
¸
  
=
¸
¸
! "
this
¸
¸
# '
.
¸
¸
' (

components
¸
¸
( 2
[
¸
¸
2 3
$num
¸
¸
3 4
]
¸
¸
4 5
;
¸
¸
5 6
int
˝
˝
 
offset
˝
˝
 
=
˝
˝
 
first
˝
˝
 
.
˝
˝
 
Offset
˝
˝
 %
;
˝
˝
% &
this
˛
˛
 
.
˛
˛
 $
UpdateComponentOffsets
˛
˛
 '
(
˛
˛
' (
$num
˛
˛
( )
)
˛
˛
) *
;
˛
˛
* +
this
ˇ
ˇ
 
.
ˇ
ˇ
 
SetIndex
ˇ
ˇ
 
(
ˇ
ˇ
 
readerIndex
ˇ
ˇ
 %
-
ˇ
ˇ
& '
offset
ˇ
ˇ
( .
,
ˇ
ˇ
. /
writerIndex
ˇ
ˇ
0 ;
-
ˇ
ˇ
< =
offset
ˇ
ˇ
> D
)
ˇ
ˇ
D E
;
ˇ
ˇ
E F
this
ÄÄ 
.
ÄÄ 
AdjustMarkers
ÄÄ 
(
ÄÄ 
offset
ÄÄ %
)
ÄÄ% &
;
ÄÄ& '
return
ÅÅ 
this
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
public
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ #
DiscardReadBytes
ÑÑ$ 4
(
ÑÑ4 5
)
ÑÑ5 6
{
ÖÖ 	
this
ÜÜ 
.
ÜÜ 
EnsureAccessible
ÜÜ !
(
ÜÜ! "
)
ÜÜ" #
;
ÜÜ# $
int
áá 
readerIndex
áá 
=
áá 
this
áá "
.
áá" #
ReaderIndex
áá# .
;
áá. /
if
àà 
(
àà 
readerIndex
àà 
==
àà 
$num
àà  
)
àà  !
{
ââ 
return
ää 
this
ää 
;
ää 
}
ãã 
int
éé 
writerIndex
éé 
=
éé 
this
éé "
.
éé" #
WriterIndex
éé# .
;
éé. /
if
èè 
(
èè 
readerIndex
èè 
==
èè 
writerIndex
èè *
&&
èè+ -
writerIndex
èè. 9
==
èè: <
this
èè= A
.
èèA B
Capacity
èèB J
)
èèJ K
{
êê 
foreach
ëë 
(
ëë 
ComponentEntry
ëë '
c1
ëë( *
in
ëë+ -
this
ëë. 2
.
ëë2 3

components
ëë3 =
)
ëë= >
{
íí 
c1
ìì 
.
ìì 
FreeIfNecessary
ìì &
(
ìì& '
)
ìì' (
;
ìì( )
}
îî 
this
ïï 
.
ïï 

components
ïï 
.
ïï  
Clear
ïï  %
(
ïï% &
)
ïï& '
;
ïï' (
this
ññ 
.
ññ 
SetIndex
ññ 
(
ññ 
$num
ññ 
,
ññ  
$num
ññ! "
)
ññ" #
;
ññ# $
this
óó 
.
óó 
AdjustMarkers
óó "
(
óó" #
readerIndex
óó# .
)
óó. /
;
óó/ 0
return
òò 
this
òò 
;
òò 
}
ôô 
int
úú 
firstComponentId
úú  
=
úú! "
this
úú# '
.
úú' (
ToComponentIndex
úú( 8
(
úú8 9
readerIndex
úú9 D
)
úúD E
;
úúE F
for
ùù 
(
ùù 
int
ùù 
i
ùù 
=
ùù 
$num
ùù 
;
ùù 
i
ùù 
<
ùù 
firstComponentId
ùù  0
;
ùù0 1
i
ùù2 3
++
ùù3 5
)
ùù5 6
{
ûû 
this
üü 
.
üü 

components
üü 
[
üü  
i
üü  !
]
üü! "
.
üü" #
FreeIfNecessary
üü# 2
(
üü2 3
)
üü3 4
;
üü4 5
}
†† 
this
°° 
.
°° 

components
°° 
.
°° 
RemoveRange
°° '
(
°°' (
$num
°°( )
,
°°) *
firstComponentId
°°+ ;
)
°°; <
;
°°< =
ComponentEntry
§§ 
c
§§ 
=
§§ 
this
§§ #
.
§§# $

components
§§$ .
[
§§. /
$num
§§/ 0
]
§§0 1
;
§§1 2
int
•• 

adjustment
•• 
=
•• 
readerIndex
•• (
-
••) *
c
••+ ,
.
••, -
Offset
••- 3
;
••3 4
if
¶¶ 
(
¶¶ 

adjustment
¶¶ 
==
¶¶ 
c
¶¶ 
.
¶¶  
Length
¶¶  &
)
¶¶& '
{
ßß 
this
©© 
.
©© 

components
©© 
.
©©  
RemoveAt
©©  (
(
©©( )
$num
©©) *
)
©©* +
;
©©+ ,
}
™™ 
else
´´ 
{
¨¨ 
var
≠≠ 
newC
≠≠ 
=
≠≠ 
new
≠≠ 
ComponentEntry
≠≠ -
(
≠≠- .
c
≠≠. /
.
≠≠/ 0
Buffer
≠≠0 6
.
≠≠6 7
Slice
≠≠7 <
(
≠≠< =

adjustment
≠≠= G
,
≠≠G H
c
≠≠I J
.
≠≠J K
Length
≠≠K Q
-
≠≠R S

adjustment
≠≠T ^
)
≠≠^ _
)
≠≠_ `
;
≠≠` a
this
ÆÆ 
.
ÆÆ 

components
ÆÆ 
[
ÆÆ  
$num
ÆÆ  !
]
ÆÆ! "
=
ÆÆ# $
newC
ÆÆ% )
;
ÆÆ) *
}
ØØ 
this
≤≤ 
.
≤≤ $
UpdateComponentOffsets
≤≤ '
(
≤≤' (
$num
≤≤( )
)
≤≤) *
;
≤≤* +
this
≥≥ 
.
≥≥ 
SetIndex
≥≥ 
(
≥≥ 
$num
≥≥ 
,
≥≥ 
writerIndex
≥≥ (
-
≥≥) *
readerIndex
≥≥+ 6
)
≥≥6 7
;
≥≥7 8
this
¥¥ 
.
¥¥ 
AdjustMarkers
¥¥ 
(
¥¥ 
readerIndex
¥¥ *
)
¥¥* +
;
¥¥+ ,
return
µµ 
this
µµ 
;
µµ 
}
∂∂ 	
IByteBuffer
∏∏ 
AllocateBuffer
∏∏ "
(
∏∏" #
int
∏∏# &
capacity
∏∏' /
)
∏∏/ 0
=>
∏∏1 3
this
ππ 
.
ππ 
direct
ππ 
?
ππ 
this
ππ 
.
ππ 
	Allocator
ππ (
.
ππ( )
DirectBuffer
ππ) 5
(
ππ5 6
capacity
ππ6 >
)
ππ> ?
:
ππ@ A
this
ππB F
.
ππF G
	Allocator
ππG P
.
ππP Q

HeapBuffer
ππQ [
(
ππ[ \
capacity
ππ\ d
)
ππd e
;
ππe f
public
ªª 
override
ªª 
string
ªª 
ToString
ªª '
(
ªª' (
)
ªª( )
{
ºº 	
string
ΩΩ 
result
ΩΩ 
=
ΩΩ 
base
ΩΩ  
.
ΩΩ  !
ToString
ΩΩ! )
(
ΩΩ) *
)
ΩΩ* +
;
ΩΩ+ ,
result
ææ 
=
ææ 
result
ææ 
.
ææ 
	Substring
ææ %
(
ææ% &
$num
ææ& '
,
ææ' (
result
ææ) /
.
ææ/ 0
Length
ææ0 6
-
ææ7 8
$num
ææ9 :
)
ææ: ;
;
ææ; <
return
øø 
$"
øø 
{
øø 
result
øø 
}
øø 
$str
øø *
{
øø* +
this
øø+ /
.
øø/ 0

components
øø0 :
.
øø: ;
Count
øø; @
}
øø@ A
$str
øøA B
"
øøB C
;
øøC D
}
¿¿ 	
public
¬¬ 
override
¬¬ 
IReferenceCounted
¬¬ )
Touch
¬¬* /
(
¬¬/ 0
)
¬¬0 1
=>
¬¬2 4
this
¬¬5 9
;
¬¬9 :
public
ƒƒ 
override
ƒƒ 
IReferenceCounted
ƒƒ )
Touch
ƒƒ* /
(
ƒƒ/ 0
object
ƒƒ0 6
hint
ƒƒ7 ;
)
ƒƒ; <
=>
ƒƒ= ?
this
ƒƒ@ D
;
ƒƒD E
public
∆∆ 
override
∆∆ 
IByteBuffer
∆∆ #"
DiscardSomeReadBytes
∆∆$ 8
(
∆∆8 9
)
∆∆9 :
=>
∆∆; =
this
∆∆> B
.
∆∆B C#
DiscardReadComponents
∆∆C X
(
∆∆X Y
)
∆∆Y Z
;
∆∆Z [
	protected
»» 
internal
»» 
override
»» #
void
»»$ (

Deallocate
»») 3
(
»»3 4
)
»»4 5
{
…… 	
if
   
(
   
this
   
.
   
freed
   
)
   
{
ÀÀ 
return
ÃÃ 
;
ÃÃ 
}
ÕÕ 
this
œœ 
.
œœ 
freed
œœ 
=
œœ 
true
œœ 
;
œœ 
int
–– 
size
–– 
=
–– 
this
–– 
.
–– 

components
–– &
.
––& '
Count
––' ,
;
––, -
for
”” 
(
”” 
int
”” 
i
”” 
=
”” 
$num
”” 
;
”” 
i
”” 
<
”” 
size
””  $
;
””$ %
i
””& '
++
””' )
)
””) *
{
‘‘ 
this
’’ 
.
’’ 

components
’’ 
[
’’  
i
’’  !
]
’’! "
.
’’" #
FreeIfNecessary
’’# 2
(
’’2 3
)
’’3 4
;
’’4 5
}
÷÷ 
}
◊◊ 	
public
ŸŸ 
override
ŸŸ 
IByteBuffer
ŸŸ #
Unwrap
ŸŸ$ *
(
ŸŸ* +
)
ŸŸ+ ,
=>
ŸŸ- /
null
ŸŸ0 4
;
ŸŸ4 5
}
⁄⁄ 
}€€ ©1
jC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\DefaultByteBufferHolder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public

 

class

 #
DefaultByteBufferHolder

 (
:

) *
IByteBufferHolder

+ <
{ 
readonly 
IByteBuffer 
data !
;! "
public #
DefaultByteBufferHolder &
(& '
IByteBuffer' 2
data3 7
)7 8
{ 	
Contract 
. 
Requires 
( 
data "
!=# %
null& *
)* +
;+ ,
this 
. 
data 
= 
data 
; 
} 	
public 
IByteBuffer 
Content "
{ 	
get 
{ 
if 
( 
this 
. 
data 
. 
ReferenceCount ,
<=- /
$num0 1
)1 2
{ 
throw 
new *
IllegalReferenceCountException <
(< =
this= A
.A B
dataB F
.F G
ReferenceCountG U
)U V
;V W
} 
return 
this 
. 
data  
;  !
} 
}   	
public"" 
IByteBufferHolder""  
Copy""! %
(""% &
)""& '
=>""( *
this""+ /
.""/ 0
Replace""0 7
(""7 8
this""8 <
.""< =
data""= A
.""A B
Copy""B F
(""F G
)""G H
)""H I
;""I J
public$$ 
IByteBufferHolder$$  
	Duplicate$$! *
($$* +
)$$+ ,
=>$$- /
this$$0 4
.$$4 5
Replace$$5 <
($$< =
this$$= A
.$$A B
data$$B F
.$$F G
	Duplicate$$G P
($$P Q
)$$Q R
)$$R S
;$$S T
public&& 
IByteBufferHolder&&  
RetainedDuplicate&&! 2
(&&2 3
)&&3 4
=>&&5 7
this&&8 <
.&&< =
Replace&&= D
(&&D E
this&&E I
.&&I J
data&&J N
.&&N O
RetainedDuplicate&&O `
(&&` a
)&&a b
)&&b c
;&&c d
public(( 
virtual(( 
IByteBufferHolder(( (
Replace(() 0
(((0 1
IByteBuffer((1 <
content((= D
)((D E
=>((F H
new((I L#
DefaultByteBufferHolder((M d
(((d e
content((e l
)((l m
;((m n
public** 
virtual** 
int** 
ReferenceCount** )
=>*** ,
this**- 1
.**1 2
data**2 6
.**6 7
ReferenceCount**7 E
;**E F
public,, 
IReferenceCounted,,  
Retain,,! '
(,,' (
),,( )
{-- 	
this.. 
... 
data.. 
... 
Retain.. 
(.. 
).. 
;.. 
return// 
this// 
;// 
}00 	
public22 
IReferenceCounted22  
Retain22! '
(22' (
int22( +
	increment22, 5
)225 6
{33 	
this44 
.44 
data44 
.44 
Retain44 
(44 
	increment44 &
)44& '
;44' (
return55 
this55 
;55 
}66 	
public88 
IReferenceCounted88  
Touch88! &
(88& '
)88' (
{99 	
this:: 
.:: 
data:: 
.:: 
Touch:: 
(:: 
):: 
;:: 
return;; 
this;; 
;;; 
}<< 	
public>> 
IReferenceCounted>>  
Touch>>! &
(>>& '
object>>' -
hint>>. 2
)>>2 3
{?? 	
this@@ 
.@@ 
data@@ 
.@@ 
Touch@@ 
(@@ 
hint@@  
)@@  !
;@@! "
returnAA 
thisAA 
;AA 
}BB 	
publicDD 
boolDD 
ReleaseDD 
(DD 
)DD 
=>DD  
thisDD! %
.DD% &
dataDD& *
.DD* +
ReleaseDD+ 2
(DD2 3
)DD3 4
;DD4 5
publicFF 
boolFF 
ReleaseFF 
(FF 
intFF 
	decrementFF  )
)FF) *
=>FF+ -
thisFF. 2
.FF2 3
dataFF3 7
.FF7 8
ReleaseFF8 ?
(FF? @
	decrementFF@ I
)FFI J
;FFJ K
	protectedHH 
stringHH 
ContentToStringHH (
(HH( )
)HH) *
=>HH+ -
thisHH. 2
.HH2 3
dataHH3 7
.HH7 8
ToStringHH8 @
(HH@ A
)HHA B
;HHB C
publicJJ 
overrideJJ 
boolJJ 
EqualsJJ #
(JJ# $
objectJJ$ *
objJJ+ .
)JJ. /
{KK 	
ifLL 
(LL 
ReferenceEqualsLL 
(LL  
thisLL  $
,LL$ %
objLL& )
)LL) *
)LL* +
{MM 
returnNN 
trueNN 
;NN 
}OO 
ifQQ 
(QQ 
objQQ 
isQQ 
IByteBufferHolderQQ (
holderQQ) /
)QQ/ 0
{RR 
returnSS 
thisSS 
.SS 
dataSS  
.SS  !
EqualsSS! '
(SS' (
holderSS( .
.SS. /
ContentSS/ 6
)SS6 7
;SS7 8
}TT 
returnVV 
falseVV 
;VV 
}WW 	
publicYY 
overrideYY 
intYY 
GetHashCodeYY '
(YY' (
)YY( )
=>YY* ,
thisYY- 1
.YY1 2
dataYY2 6
.YY6 7
GetHashCodeYY7 B
(YYB C
)YYC D
;YYD E
}ZZ 
}[[  Î
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\EmptyByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class 
EmptyByteBuffer '
:( )
IByteBuffer* 5
{ 
static 
readonly 
ArraySegment $
<$ %
byte% )
>) *
EmptyBuffer+ 6
=7 8
new9 <
ArraySegment= I
<I J
byteJ N
>N O
(O P
ArrayExtensionsP _
._ `
	ZeroBytes` i
)i j
;j k
static 
readonly 
ArraySegment $
<$ %
byte% )
>) *
[* +
]+ ,
EmptyBuffers- 9
=: ;
{< =
EmptyBuffer> I
}J K
;K L
public 
EmptyByteBuffer 
(  
IByteBufferAllocator 3
	allocator4 =
)= >
{ 	
Contract 
. 
Requires 
( 
	allocator '
!=( *
null+ /
)/ 0
;0 1
this 
. 
	Allocator 
= 
	allocator &
;& '
} 	
public 
int 
Capacity 
=> 
$num  
;  !
public!! 
IByteBuffer!! 
AdjustCapacity!! )
(!!) *
int!!* -
newCapacity!!. 9
)!!9 :
=>!!; =
throw!!= B
new!!C F!
NotSupportedException!!G \
(!!\ ]
)!!] ^
;!!^ _
public## 
int## 
MaxCapacity## 
=>## !
$num##" #
;### $
public%%  
IByteBufferAllocator%% #
	Allocator%%$ -
{%%. /
get%%0 3
;%%3 4
}%%5 6
public'' 
IByteBuffer'' 
Unwrap'' !
(''! "
)''" #
=>''$ &
null''' +
;''+ ,
public)) 
bool)) 
IsDirect)) 
=>)) 
true))  $
;))$ %
public++ 
int++ 
ReaderIndex++ 
=>++ !
$num++" #
;++# $
public-- 
IByteBuffer-- 
SetReaderIndex-- )
(--) *
int--* -
readerIndex--. 9
)--9 :
=>--; =
this--> B
.--B C

CheckIndex--C M
(--M N
readerIndex--N Y
)--Y Z
;--Z [
public// 
int// 
WriterIndex// 
=>// !
$num//" #
;//# $
public11 
IByteBuffer11 
SetWriterIndex11 )
(11) *
int11* -
writerIndex11. 9
)119 :
=>11; =
this11> B
.11B C

CheckIndex11C M
(11M N
writerIndex11N Y
)11Y Z
;11Z [
public33 
IByteBuffer33 
SetIndex33 #
(33# $
int33$ '
readerIndex33( 3
,333 4
int335 8
writerIndex339 D
)33D E
{44 	
this55 
.55 

CheckIndex55 
(55 
readerIndex55 '
)55' (
;55( )
this66 
.66 

CheckIndex66 
(66 
writerIndex66 '
)66' (
;66( )
return77 
this77 
;77 
}88 	
public:: 
int:: 
ReadableBytes::  
=>::! #
$num::$ %
;::% &
public<< 
int<< 
WritableBytes<<  
=><<! #
$num<<$ %
;<<% &
public>> 
int>> 
MaxWritableBytes>> #
=>>>$ &
$num>>' (
;>>( )
public@@ 
bool@@ 

IsWritable@@ 
(@@ 
)@@  
=>@@! #
false@@$ )
;@@) *
publicBB 
boolBB 

IsWritableBB 
(BB 
intBB "
sizeBB# '
)BB' (
=>BB) +
falseBB, 1
;BB1 2
publicDD 
IByteBufferDD 
ClearDD  
(DD  !
)DD! "
=>DD# %
thisDD& *
;DD* +
publicFF 
IByteBufferFF 
MarkReaderIndexFF *
(FF* +
)FF+ ,
=>FF- /
thisFF0 4
;FF4 5
publicHH 
IByteBufferHH 
ResetReaderIndexHH +
(HH+ ,
)HH, -
=>HH. 0
thisHH1 5
;HH5 6
publicJJ 
IByteBufferJJ 
MarkWriterIndexJJ *
(JJ* +
)JJ+ ,
=>JJ- /
thisJJ0 4
;JJ4 5
publicLL 
IByteBufferLL 
ResetWriterIndexLL +
(LL+ ,
)LL, -
=>LL. 0
thisLL1 5
;LL5 6
publicNN 
IByteBufferNN 
DiscardReadBytesNN +
(NN+ ,
)NN, -
=>NN. 0
thisNN1 5
;NN5 6
publicPP 
IByteBufferPP  
DiscardSomeReadBytesPP /
(PP/ 0
)PP0 1
=>PP2 4
thisPP5 9
;PP9 :
publicRR 
IByteBufferRR 
EnsureWritableRR )
(RR) *
intRR* -
minWritableBytesRR. >
)RR> ?
{SS 	
ContractTT 
.TT 
RequiresTT 
(TT 
minWritableBytesTT .
>=TT/ 1
$numTT2 3
)TT3 4
;TT4 5
ifVV 
(VV 
minWritableBytesVV  
!=VV! #
$numVV$ %
)VV% &
{WW 
throwXX 
newXX $
IndexOutOfRangeExceptionXX 2
(XX2 3
)XX3 4
;XX4 5
}YY 
returnZZ 
thisZZ 
;ZZ 
}[[ 	
public]] 
int]] 
EnsureWritable]] !
(]]! "
int]]" %
minWritableBytes]]& 6
,]]6 7
bool]]8 <
force]]= B
)]]B C
{^^ 	
Contract__ 
.__ 
Requires__ 
(__ 
minWritableBytes__ .
>=__/ 1
$num__2 3
)__3 4
;__4 5
ifaa 
(aa 
minWritableBytesaa  
==aa! #
$numaa$ %
)aa% &
{bb 
returncc 
$numcc 
;cc 
}dd 
returnff 
$numff 
;ff 
}gg 	
publicii 
boolii 

GetBooleanii 
(ii 
intii "
indexii# (
)ii( )
=>ii* ,
throwii- 2
newii3 6$
IndexOutOfRangeExceptionii7 O
(iiO P
)iiP Q
;iiQ R
publickk 
bytekk 
GetBytekk 
(kk 
intkk 
indexkk  %
)kk% &
=>kk' )
throwkk* /
newkk0 3$
IndexOutOfRangeExceptionkk4 L
(kkL M
)kkM N
;kkN O
publicmm 
shortmm 
GetShortmm 
(mm 
intmm !
indexmm" '
)mm' (
=>mm) +
throwmm, 1
newmm2 5$
IndexOutOfRangeExceptionmm6 N
(mmN O
)mmO P
;mmP Q
publicoo 
shortoo 

GetShortLEoo 
(oo  
intoo  #
indexoo$ )
)oo) *
=>oo+ -
throwoo. 3
newoo4 7$
IndexOutOfRangeExceptionoo8 P
(ooP Q
)ooQ R
;ooR S
publicqq 
ushortqq 
GetUnsignedShortqq &
(qq& '
intqq' *
indexqq+ 0
)qq0 1
=>qq2 4
throwqq5 :
newqq; >$
IndexOutOfRangeExceptionqq? W
(qqW X
)qqX Y
;qqY Z
publicss 
ushortss 
GetUnsignedShortLEss (
(ss( )
intss) ,
indexss- 2
)ss2 3
=>ss4 6
throwss7 <
newss= @$
IndexOutOfRangeExceptionssA Y
(ssY Z
)ssZ [
;ss[ \
publicuu 
intuu 
	GetMediumuu 
(uu 
intuu  
indexuu! &
)uu& '
=>uu( *
throwuu+ 0
newuu1 4$
IndexOutOfRangeExceptionuu5 M
(uuM N
)uuN O
;uuO P
publicww 
intww 
GetMediumLEww 
(ww 
intww "
indexww# (
)ww( )
=>ww* ,
throwww- 2
newww3 6$
IndexOutOfRangeExceptionww7 O
(wwO P
)wwP Q
;wwQ R
publicyy 
intyy 
GetUnsignedMediumyy $
(yy$ %
intyy% (
indexyy) .
)yy. /
=>yy0 2
throwyy3 8
newyy9 <$
IndexOutOfRangeExceptionyy= U
(yyU V
)yyV W
;yyW X
public{{ 
int{{ 
GetUnsignedMediumLE{{ &
({{& '
int{{' *
index{{+ 0
){{0 1
=>{{2 4
throw{{5 :
new{{; >$
IndexOutOfRangeException{{? W
({{W X
){{X Y
;{{Y Z
public}} 
int}} 
GetInt}} 
(}} 
int}} 
index}} #
)}}# $
=>}}% '
throw}}( -
new}}. 1$
IndexOutOfRangeException}}2 J
(}}J K
)}}K L
;}}L M
public 
int 
GetIntLE 
( 
int 
index  %
)% &
=>' )
throw* /
new0 3$
IndexOutOfRangeException4 L
(L M
)M N
;N O
public
ÅÅ 
uint
ÅÅ 
GetUnsignedInt
ÅÅ "
(
ÅÅ" #
int
ÅÅ# &
index
ÅÅ' ,
)
ÅÅ, -
=>
ÅÅ. 0
throw
ÅÅ1 6
new
ÅÅ7 :&
IndexOutOfRangeException
ÅÅ; S
(
ÅÅS T
)
ÅÅT U
;
ÅÅU V
public
ÉÉ 
uint
ÉÉ 
GetUnsignedIntLE
ÉÉ $
(
ÉÉ$ %
int
ÉÉ% (
index
ÉÉ) .
)
ÉÉ. /
=>
ÉÉ0 2
throw
ÉÉ3 8
new
ÉÉ9 <&
IndexOutOfRangeException
ÉÉ= U
(
ÉÉU V
)
ÉÉV W
;
ÉÉW X
public
ÖÖ 
long
ÖÖ 
GetLong
ÖÖ 
(
ÖÖ 
int
ÖÖ 
index
ÖÖ  %
)
ÖÖ% &
=>
ÖÖ' )
throw
ÖÖ* /
new
ÖÖ0 3&
IndexOutOfRangeException
ÖÖ4 L
(
ÖÖL M
)
ÖÖM N
;
ÖÖN O
public
áá 
long
áá 
	GetLongLE
áá 
(
áá 
int
áá !
index
áá" '
)
áá' (
=>
áá) +
throw
áá, 1
new
áá2 5&
IndexOutOfRangeException
áá6 N
(
ááN O
)
ááO P
;
ááP Q
public
ââ 
char
ââ 
GetChar
ââ 
(
ââ 
int
ââ 
index
ââ  %
)
ââ% &
=>
ââ' )
throw
ââ* /
new
ââ0 3&
IndexOutOfRangeException
ââ4 L
(
ââL M
)
ââM N
;
ââN O
public
ãã 
float
ãã 
GetFloat
ãã 
(
ãã 
int
ãã !
index
ãã" '
)
ãã' (
=>
ãã) +
throw
ãã, 1
new
ãã2 5&
IndexOutOfRangeException
ãã6 N
(
ããN O
)
ããO P
;
ããP Q
public
çç 
float
çç 

GetFloatLE
çç 
(
çç  
int
çç  #
index
çç$ )
)
çç) *
=>
çç+ -
throw
çç. 3
new
çç4 7&
IndexOutOfRangeException
çç8 P
(
ççP Q
)
ççQ R
;
ççR S
public
èè 
double
èè 
	GetDouble
èè 
(
èè  
int
èè  #
index
èè$ )
)
èè) *
=>
èè+ -
throw
èè. 3
new
èè4 7&
IndexOutOfRangeException
èè8 P
(
èèP Q
)
èèQ R
;
èèR S
public
ëë 
double
ëë 
GetDoubleLE
ëë !
(
ëë! "
int
ëë" %
index
ëë& +
)
ëë+ ,
=>
ëë- /
throw
ëë0 5
new
ëë6 9&
IndexOutOfRangeException
ëë: R
(
ëëR S
)
ëëS T
;
ëëT U
public
ìì 
IByteBuffer
ìì 
GetBytes
ìì #
(
ìì# $
int
ìì$ '
index
ìì( -
,
ìì- .
IByteBuffer
ìì/ :
destination
ìì; F
)
ììF G
=>
ììH J
this
ììK O
.
ììO P

CheckIndex
ììP Z
(
ììZ [
index
ìì[ `
,
ìì` a
destination
ììb m
.
ììm n
WritableBytes
ììn {
)
ìì{ |
;
ìì| }
public
ïï 
IByteBuffer
ïï 
GetBytes
ïï #
(
ïï# $
int
ïï$ '
index
ïï( -
,
ïï- .
IByteBuffer
ïï/ :
destination
ïï; F
,
ïïF G
int
ïïH K
length
ïïL R
)
ïïR S
=>
ïïT V
this
ïïW [
.
ïï[ \

CheckIndex
ïï\ f
(
ïïf g
index
ïïg l
,
ïïl m
length
ïïn t
)
ïït u
;
ïïu v
public
óó 
IByteBuffer
óó 
GetBytes
óó #
(
óó# $
int
óó$ '
index
óó( -
,
óó- .
IByteBuffer
óó/ :
destination
óó; F
,
óóF G
int
óóH K
dstIndex
óóL T
,
óóT U
int
óóV Y
length
óóZ `
)
óó` a
=>
óób d
this
óóe i
.
óói j

CheckIndex
óój t
(
óót u
index
óóu z
,
óóz {
lengthóó| Ç
)óóÇ É
;óóÉ Ñ
public
ôô 
IByteBuffer
ôô 
GetBytes
ôô #
(
ôô# $
int
ôô$ '
index
ôô( -
,
ôô- .
byte
ôô/ 3
[
ôô3 4
]
ôô4 5
destination
ôô6 A
)
ôôA B
=>
ôôC E
this
ôôF J
.
ôôJ K

CheckIndex
ôôK U
(
ôôU V
index
ôôV [
,
ôô[ \
destination
ôô] h
.
ôôh i
Length
ôôi o
)
ôôo p
;
ôôp q
public
õõ 
IByteBuffer
õõ 
GetBytes
õõ #
(
õõ# $
int
õõ$ '
index
õõ( -
,
õõ- .
byte
õõ/ 3
[
õõ3 4
]
õõ4 5
destination
õõ6 A
,
õõA B
int
õõC F
dstIndex
õõG O
,
õõO P
int
õõQ T
length
õõU [
)
õõ[ \
=>
õõ] _
this
õõ` d
.
õõd e

CheckIndex
õõe o
(
õõo p
index
õõp u
,
õõu v
length
õõw }
)
õõ} ~
;
õõ~ 
public
ùù 
IByteBuffer
ùù 
GetBytes
ùù #
(
ùù# $
int
ùù$ '
index
ùù( -
,
ùù- .
Stream
ùù/ 5
destination
ùù6 A
,
ùùA B
int
ùùC F
length
ùùG M
)
ùùM N
=>
ùùO Q
this
ùùR V
.
ùùV W

CheckIndex
ùùW a
(
ùùa b
index
ùùb g
,
ùùg h
length
ùùi o
)
ùùo p
;
ùùp q
public
üü 
ICharSequence
üü 
GetCharSequence
üü ,
(
üü, -
int
üü- 0
index
üü1 6
,
üü6 7
int
üü8 ;
length
üü< B
,
üüB C
Encoding
üüD L
encoding
üüM U
)
üüU V
{
†† 	
this
°° 
.
°° 

CheckIndex
°° 
(
°° 
index
°° !
,
°°! "
length
°°# )
)
°°) *
;
°°* +
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
string
•• 
	GetString
•• 
(
••  
int
••  #
index
••$ )
,
••) *
int
••+ .
length
••/ 5
,
••5 6
Encoding
••7 ?
encoding
••@ H
)
••H I
{
¶¶ 	
this
ßß 
.
ßß 

CheckIndex
ßß 
(
ßß 
index
ßß !
,
ßß! "
length
ßß# )
)
ßß) *
;
ßß* +
return
®® 
null
®® 
;
®® 
}
©© 	
public
´´ 
IByteBuffer
´´ 

SetBoolean
´´ %
(
´´% &
int
´´& )
index
´´* /
,
´´/ 0
bool
´´1 5
value
´´6 ;
)
´´; <
=>
´´= ?
throw
´´@ E
new
´´F I&
IndexOutOfRangeException
´´J b
(
´´b c
)
´´c d
;
´´d e
public
≠≠ 
IByteBuffer
≠≠ 
SetByte
≠≠ "
(
≠≠" #
int
≠≠# &
index
≠≠' ,
,
≠≠, -
int
≠≠. 1
value
≠≠2 7
)
≠≠7 8
=>
≠≠9 ;
throw
≠≠< A
new
≠≠B E&
IndexOutOfRangeException
≠≠F ^
(
≠≠^ _
)
≠≠_ `
;
≠≠` a
public
ØØ 
IByteBuffer
ØØ 
SetShort
ØØ #
(
ØØ# $
int
ØØ$ '
index
ØØ( -
,
ØØ- .
int
ØØ/ 2
value
ØØ3 8
)
ØØ8 9
=>
ØØ: <
throw
ØØ= B
new
ØØC F&
IndexOutOfRangeException
ØØG _
(
ØØ_ `
)
ØØ` a
;
ØØa b
public
±± 
IByteBuffer
±± 

SetShortLE
±± %
(
±±% &
int
±±& )
index
±±* /
,
±±/ 0
int
±±1 4
value
±±5 :
)
±±: ;
=>
±±< >
throw
±±? D
new
±±E H&
IndexOutOfRangeException
±±I a
(
±±a b
)
±±b c
;
±±c d
public
≥≥ 
IByteBuffer
≥≥ 
SetUnsignedShort
≥≥ +
(
≥≥+ ,
int
≥≥, /
index
≥≥0 5
,
≥≥5 6
ushort
≥≥7 =
value
≥≥> C
)
≥≥C D
=>
≥≥E G
throw
≥≥H M
new
≥≥N Q&
IndexOutOfRangeException
≥≥R j
(
≥≥j k
)
≥≥k l
;
≥≥l m
public
µµ 
IByteBuffer
µµ  
SetUnsignedShortLE
µµ -
(
µµ- .
int
µµ. 1
index
µµ2 7
,
µµ7 8
ushort
µµ9 ?
value
µµ@ E
)
µµE F
=>
µµG I
throw
µµJ O
new
µµP S&
IndexOutOfRangeException
µµT l
(
µµl m
)
µµm n
;
µµn o
public
∑∑ 
IByteBuffer
∑∑ 
	SetMedium
∑∑ $
(
∑∑$ %
int
∑∑% (
index
∑∑) .
,
∑∑. /
int
∑∑0 3
value
∑∑4 9
)
∑∑9 :
=>
∑∑; =
throw
∑∑> C
new
∑∑D G&
IndexOutOfRangeException
∑∑H `
(
∑∑` a
)
∑∑a b
;
∑∑b c
public
ππ 
IByteBuffer
ππ 
SetMediumLE
ππ &
(
ππ& '
int
ππ' *
index
ππ+ 0
,
ππ0 1
int
ππ2 5
value
ππ6 ;
)
ππ; <
=>
ππ= ?
throw
ππ@ E
new
ππF I&
IndexOutOfRangeException
ππJ b
(
ππb c
)
ππc d
;
ππd e
public
ªª 
IByteBuffer
ªª 
SetInt
ªª !
(
ªª! "
int
ªª" %
index
ªª& +
,
ªª+ ,
int
ªª- 0
value
ªª1 6
)
ªª6 7
=>
ªª8 :
throw
ªª; @
new
ªªA D&
IndexOutOfRangeException
ªªE ]
(
ªª] ^
)
ªª^ _
;
ªª_ `
public
ΩΩ 
IByteBuffer
ΩΩ 
SetIntLE
ΩΩ #
(
ΩΩ# $
int
ΩΩ$ '
index
ΩΩ( -
,
ΩΩ- .
int
ΩΩ/ 2
value
ΩΩ3 8
)
ΩΩ8 9
=>
ΩΩ: <
throw
ΩΩ= B
new
ΩΩC F&
IndexOutOfRangeException
ΩΩG _
(
ΩΩ_ `
)
ΩΩ` a
;
ΩΩa b
public
øø 
IByteBuffer
øø 
SetUnsignedInt
øø )
(
øø) *
int
øø* -
index
øø. 3
,
øø3 4
uint
øø5 9
value
øø: ?
)
øø? @
=>
øøA C
throw
øøD I
new
øøJ M&
IndexOutOfRangeException
øøN f
(
øøf g
)
øøg h
;
øøh i
public
¡¡ 
IByteBuffer
¡¡ 
SetUnsignedIntLE
¡¡ +
(
¡¡+ ,
int
¡¡, /
index
¡¡0 5
,
¡¡5 6
uint
¡¡7 ;
value
¡¡< A
)
¡¡A B
=>
¡¡C E
throw
¡¡F K
new
¡¡L O&
IndexOutOfRangeException
¡¡P h
(
¡¡h i
)
¡¡i j
;
¡¡j k
public
√√ 
IByteBuffer
√√ 
SetLong
√√ "
(
√√" #
int
√√# &
index
√√' ,
,
√√, -
long
√√. 2
value
√√3 8
)
√√8 9
=>
√√: <
throw
√√= B
new
√√C F&
IndexOutOfRangeException
√√G _
(
√√_ `
)
√√` a
;
√√a b
public
≈≈ 
IByteBuffer
≈≈ 
	SetLongLE
≈≈ $
(
≈≈$ %
int
≈≈% (
index
≈≈) .
,
≈≈. /
long
≈≈0 4
value
≈≈5 :
)
≈≈: ;
=>
≈≈< >
throw
≈≈? D
new
≈≈E H&
IndexOutOfRangeException
≈≈I a
(
≈≈a b
)
≈≈b c
;
≈≈c d
public
«« 
IByteBuffer
«« 
SetChar
«« "
(
««" #
int
««# &
index
««' ,
,
««, -
char
««. 2
value
««3 8
)
««8 9
=>
««: <
throw
««= B
new
««C F&
IndexOutOfRangeException
««G _
(
««_ `
)
««` a
;
««a b
public
…… 
IByteBuffer
…… 
SetFloat
…… #
(
……# $
int
……$ '
index
……( -
,
……- .
float
……/ 4
value
……5 :
)
……: ;
=>
……< >
throw
……? D
new
……E H&
IndexOutOfRangeException
……I a
(
……a b
)
……b c
;
……c d
public
ÀÀ 
IByteBuffer
ÀÀ 

SetFloatLE
ÀÀ %
(
ÀÀ% &
int
ÀÀ& )
index
ÀÀ* /
,
ÀÀ/ 0
float
ÀÀ1 6
value
ÀÀ7 <
)
ÀÀ< =
=>
ÀÀ> @
throw
ÀÀA F
new
ÀÀG J&
IndexOutOfRangeException
ÀÀK c
(
ÀÀc d
)
ÀÀd e
;
ÀÀe f
public
ÕÕ 
IByteBuffer
ÕÕ 
	SetDouble
ÕÕ $
(
ÕÕ$ %
int
ÕÕ% (
index
ÕÕ) .
,
ÕÕ. /
double
ÕÕ0 6
value
ÕÕ7 <
)
ÕÕ< =
=>
ÕÕ> @
throw
ÕÕA F
new
ÕÕG J&
IndexOutOfRangeException
ÕÕK c
(
ÕÕc d
)
ÕÕd e
;
ÕÕe f
public
œœ 
IByteBuffer
œœ 
SetDoubleLE
œœ &
(
œœ& '
int
œœ' *
index
œœ+ 0
,
œœ0 1
double
œœ2 8
value
œœ9 >
)
œœ> ?
=>
œœ@ B
throw
œœC H
new
œœI L&
IndexOutOfRangeException
œœM e
(
œœe f
)
œœf g
;
œœg h
public
—— 
IByteBuffer
—— 
SetBytes
—— #
(
——# $
int
——$ '
index
——( -
,
——- .
IByteBuffer
——/ :
src
——; >
)
——> ?
=>
——@ B
throw
——C H
new
——I L&
IndexOutOfRangeException
——M e
(
——e f
)
——f g
;
——g h
public
”” 
IByteBuffer
”” 
SetBytes
”” #
(
””# $
int
””$ '
index
””( -
,
””- .
IByteBuffer
””/ :
src
””; >
,
””> ?
int
””@ C
length
””D J
)
””J K
=>
””L N
this
””O S
.
””S T

CheckIndex
””T ^
(
””^ _
index
””_ d
,
””d e
length
””f l
)
””l m
;
””m n
public
’’ 
IByteBuffer
’’ 
SetBytes
’’ #
(
’’# $
int
’’$ '
index
’’( -
,
’’- .
IByteBuffer
’’/ :
src
’’; >
,
’’> ?
int
’’@ C
srcIndex
’’D L
,
’’L M
int
’’N Q
length
’’R X
)
’’X Y
=>
’’Z \
this
’’] a
.
’’a b

CheckIndex
’’b l
(
’’l m
index
’’m r
,
’’r s
length
’’t z
)
’’z {
;
’’{ |
public
◊◊ 
IByteBuffer
◊◊ 
SetBytes
◊◊ #
(
◊◊# $
int
◊◊$ '
index
◊◊( -
,
◊◊- .
byte
◊◊/ 3
[
◊◊3 4
]
◊◊4 5
src
◊◊6 9
)
◊◊9 :
=>
◊◊; =
this
◊◊> B
.
◊◊B C

CheckIndex
◊◊C M
(
◊◊M N
index
◊◊N S
,
◊◊S T
src
◊◊U X
.
◊◊X Y
Length
◊◊Y _
)
◊◊_ `
;
◊◊` a
public
ŸŸ 
IByteBuffer
ŸŸ 
SetBytes
ŸŸ #
(
ŸŸ# $
int
ŸŸ$ '
index
ŸŸ( -
,
ŸŸ- .
byte
ŸŸ/ 3
[
ŸŸ3 4
]
ŸŸ4 5
src
ŸŸ6 9
,
ŸŸ9 :
int
ŸŸ; >
srcIndex
ŸŸ? G
,
ŸŸG H
int
ŸŸI L
length
ŸŸM S
)
ŸŸS T
=>
ŸŸU W
this
ŸŸX \
.
ŸŸ\ ]

CheckIndex
ŸŸ] g
(
ŸŸg h
index
ŸŸh m
,
ŸŸm n
length
ŸŸo u
)
ŸŸu v
;
ŸŸv w
public
€€ 
Task
€€ 
<
€€ 
int
€€ 
>
€€ 
SetBytesAsync
€€ &
(
€€& '
int
€€' *
index
€€+ 0
,
€€0 1
Stream
€€2 8
src
€€9 <
,
€€< =
int
€€> A
length
€€B H
,
€€H I
CancellationToken
€€J [
cancellationToken
€€\ m
)
€€m n
{
‹‹ 	
this
›› 
.
›› 

CheckIndex
›› 
(
›› 
index
›› !
,
››! "
length
››# )
)
››) *
;
››* +
return
ﬁﬁ 
TaskEx
ﬁﬁ 
.
ﬁﬁ 
Zero
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
public
·· 
IByteBuffer
·· 
SetZero
·· "
(
··" #
int
··# &
index
··' ,
,
··, -
int
··. 1
length
··2 8
)
··8 9
=>
··: <
this
··= A
.
··A B

CheckIndex
··B L
(
··L M
index
··M R
,
··R S
length
··T Z
)
··Z [
;
··[ \
public
„„ 
int
„„ 
SetCharSequence
„„ "
(
„„" #
int
„„# &
index
„„' ,
,
„„, -
ICharSequence
„„. ;
sequence
„„< D
,
„„D E
Encoding
„„F N
encoding
„„O W
)
„„W X
=>
„„Y [
throw
„„\ a
new
„„b e&
IndexOutOfRangeException
„„f ~
(
„„~ 
)„„ Ä
;„„Ä Å
public
ÂÂ 
int
ÂÂ 
	SetString
ÂÂ 
(
ÂÂ 
int
ÂÂ  
index
ÂÂ! &
,
ÂÂ& '
string
ÂÂ( .
value
ÂÂ/ 4
,
ÂÂ4 5
Encoding
ÂÂ6 >
encoding
ÂÂ? G
)
ÂÂG H
=>
ÂÂI K
throw
ÂÂL Q
new
ÂÂR U&
IndexOutOfRangeException
ÂÂV n
(
ÂÂn o
)
ÂÂo p
;
ÂÂp q
public
ÁÁ 
bool
ÁÁ 
ReadBoolean
ÁÁ 
(
ÁÁ  
)
ÁÁ  !
=>
ÁÁ" $
throw
ÁÁ% *
new
ÁÁ+ .&
IndexOutOfRangeException
ÁÁ/ G
(
ÁÁG H
)
ÁÁH I
;
ÁÁI J
public
ÈÈ 
byte
ÈÈ 
ReadByte
ÈÈ 
(
ÈÈ 
)
ÈÈ 
=>
ÈÈ !
throw
ÈÈ" '
new
ÈÈ( +&
IndexOutOfRangeException
ÈÈ, D
(
ÈÈD E
)
ÈÈE F
;
ÈÈF G
public
ÎÎ 
short
ÎÎ 
	ReadShort
ÎÎ 
(
ÎÎ 
)
ÎÎ  
=>
ÎÎ! #
throw
ÎÎ$ )
new
ÎÎ* -&
IndexOutOfRangeException
ÎÎ. F
(
ÎÎF G
)
ÎÎG H
;
ÎÎH I
public
ÌÌ 
short
ÌÌ 
ReadShortLE
ÌÌ  
(
ÌÌ  !
)
ÌÌ! "
=>
ÌÌ# %
throw
ÌÌ& +
new
ÌÌ, /&
IndexOutOfRangeException
ÌÌ0 H
(
ÌÌH I
)
ÌÌI J
;
ÌÌJ K
public
ÔÔ 
ushort
ÔÔ 
ReadUnsignedShort
ÔÔ '
(
ÔÔ' (
)
ÔÔ( )
=>
ÔÔ* ,
throw
ÔÔ- 2
new
ÔÔ3 6&
IndexOutOfRangeException
ÔÔ7 O
(
ÔÔO P
)
ÔÔP Q
;
ÔÔQ R
public
ÒÒ 
ushort
ÒÒ !
ReadUnsignedShortLE
ÒÒ )
(
ÒÒ) *
)
ÒÒ* +
=>
ÒÒ, .
throw
ÒÒ/ 4
new
ÒÒ5 8&
IndexOutOfRangeException
ÒÒ9 Q
(
ÒÒQ R
)
ÒÒR S
;
ÒÒS T
public
ÛÛ 
int
ÛÛ 

ReadMedium
ÛÛ 
(
ÛÛ 
)
ÛÛ 
=>
ÛÛ  "
throw
ÛÛ# (
new
ÛÛ) ,&
IndexOutOfRangeException
ÛÛ- E
(
ÛÛE F
)
ÛÛF G
;
ÛÛG H
public
ıı 
int
ıı 
ReadMediumLE
ıı 
(
ıı  
)
ıı  !
=>
ıı" $
throw
ıı% *
new
ıı+ .&
IndexOutOfRangeException
ıı/ G
(
ııG H
)
ııH I
;
ııI J
public
˜˜ 
int
˜˜  
ReadUnsignedMedium
˜˜ %
(
˜˜% &
)
˜˜& '
=>
˜˜( *
throw
˜˜+ 0
new
˜˜1 4&
IndexOutOfRangeException
˜˜5 M
(
˜˜M N
)
˜˜N O
;
˜˜O P
public
˘˘ 
int
˘˘ "
ReadUnsignedMediumLE
˘˘ '
(
˘˘' (
)
˘˘( )
=>
˘˘* ,
throw
˘˘- 2
new
˘˘3 6&
IndexOutOfRangeException
˘˘7 O
(
˘˘O P
)
˘˘P Q
;
˘˘Q R
public
˚˚ 
int
˚˚ 
ReadInt
˚˚ 
(
˚˚ 
)
˚˚ 
=>
˚˚ 
throw
˚˚  %
new
˚˚& )&
IndexOutOfRangeException
˚˚* B
(
˚˚B C
)
˚˚C D
;
˚˚D E
public
˝˝ 
int
˝˝ 
	ReadIntLE
˝˝ 
(
˝˝ 
)
˝˝ 
=>
˝˝ !
throw
˝˝" '
new
˝˝( +&
IndexOutOfRangeException
˝˝, D
(
˝˝D E
)
˝˝E F
;
˝˝F G
public
ˇˇ 
uint
ˇˇ 
ReadUnsignedInt
ˇˇ #
(
ˇˇ# $
)
ˇˇ$ %
=>
ˇˇ& (
throw
ˇˇ) .
new
ˇˇ/ 2&
IndexOutOfRangeException
ˇˇ3 K
(
ˇˇK L
)
ˇˇL M
;
ˇˇM N
public
ÅÅ 
uint
ÅÅ 
ReadUnsignedIntLE
ÅÅ %
(
ÅÅ% &
)
ÅÅ& '
=>
ÅÅ( *
throw
ÅÅ+ 0
new
ÅÅ1 4&
IndexOutOfRangeException
ÅÅ5 M
(
ÅÅM N
)
ÅÅN O
;
ÅÅO P
public
ÉÉ 
long
ÉÉ 
ReadLong
ÉÉ 
(
ÉÉ 
)
ÉÉ 
=>
ÉÉ !
throw
ÉÉ" '
new
ÉÉ( +&
IndexOutOfRangeException
ÉÉ, D
(
ÉÉD E
)
ÉÉE F
;
ÉÉF G
public
ÖÖ 
long
ÖÖ 

ReadLongLE
ÖÖ 
(
ÖÖ 
)
ÖÖ  
=>
ÖÖ! #
throw
ÖÖ$ )
new
ÖÖ* -&
IndexOutOfRangeException
ÖÖ. F
(
ÖÖF G
)
ÖÖG H
;
ÖÖH I
public
áá 
char
áá 
ReadChar
áá 
(
áá 
)
áá 
=>
áá !
throw
áá" '
new
áá( +&
IndexOutOfRangeException
áá, D
(
ááD E
)
ááE F
;
ááF G
public
ââ 
float
ââ 
	ReadFloat
ââ 
(
ââ 
)
ââ  
=>
ââ! #
throw
ââ$ )
new
ââ* -&
IndexOutOfRangeException
ââ. F
(
ââF G
)
ââG H
;
ââH I
public
ãã 
float
ãã 
ReadFloatLE
ãã  
(
ãã  !
)
ãã! "
=>
ãã# %
throw
ãã& +
new
ãã, /&
IndexOutOfRangeException
ãã0 H
(
ããH I
)
ããI J
;
ããJ K
public
çç 
double
çç 

ReadDouble
çç  
(
çç  !
)
çç! "
=>
çç# %
throw
çç& +
new
çç, /&
IndexOutOfRangeException
çç0 H
(
ççH I
)
ççI J
;
ççJ K
public
èè 
double
èè 
ReadDoubleLE
èè "
(
èè" #
)
èè# $
=>
èè% '
throw
èè( -
new
èè. 1&
IndexOutOfRangeException
èè2 J
(
èèJ K
)
èèK L
;
èèL M
public
ëë 
IByteBuffer
ëë 
	ReadBytes
ëë $
(
ëë$ %
int
ëë% (
length
ëë) /
)
ëë/ 0
=>
ëë1 3
this
ëë4 8
.
ëë8 9
CheckLength
ëë9 D
(
ëëD E
length
ëëE K
)
ëëK L
;
ëëL M
public
ìì 
IByteBuffer
ìì 
	ReadBytes
ìì $
(
ìì$ %
IByteBuffer
ìì% 0
destination
ìì1 <
)
ìì< =
=>
ìì> @
this
ììA E
.
ììE F
CheckLength
ììF Q
(
ììQ R
destination
ììR ]
.
ìì] ^
WritableBytes
ìì^ k
)
ììk l
;
ììl m
public
ïï 
IByteBuffer
ïï 
	ReadBytes
ïï $
(
ïï$ %
IByteBuffer
ïï% 0
destination
ïï1 <
,
ïï< =
int
ïï> A
length
ïïB H
)
ïïH I
=>
ïïJ L
this
ïïM Q
.
ïïQ R
CheckLength
ïïR ]
(
ïï] ^
length
ïï^ d
)
ïïd e
;
ïïe f
public
óó 
IByteBuffer
óó 
	ReadBytes
óó $
(
óó$ %
IByteBuffer
óó% 0
destination
óó1 <
,
óó< =
int
óó> A
dstIndex
óóB J
,
óóJ K
int
óóL O
length
óóP V
)
óóV W
=>
óóX Z
this
óó[ _
.
óó_ `
CheckLength
óó` k
(
óók l
length
óól r
)
óór s
;
óós t
public
ôô 
IByteBuffer
ôô 
	ReadBytes
ôô $
(
ôô$ %
byte
ôô% )
[
ôô) *
]
ôô* +
destination
ôô, 7
)
ôô7 8
=>
ôô9 ;
this
ôô< @
.
ôô@ A
CheckLength
ôôA L
(
ôôL M
destination
ôôM X
.
ôôX Y
Length
ôôY _
)
ôô_ `
;
ôô` a
public
õõ 
IByteBuffer
õõ 
	ReadBytes
õõ $
(
õõ$ %
byte
õõ% )
[
õõ) *
]
õõ* +
destination
õõ, 7
,
õõ7 8
int
õõ9 <
dstIndex
õõ= E
,
õõE F
int
õõG J
length
õõK Q
)
õõQ R
=>
õõS U
this
õõV Z
.
õõZ [
CheckLength
õõ[ f
(
õõf g
length
õõg m
)
õõm n
;
õõn o
public
ùù 
IByteBuffer
ùù 
	ReadBytes
ùù $
(
ùù$ %
Stream
ùù% +
destination
ùù, 7
,
ùù7 8
int
ùù9 <
length
ùù= C
)
ùùC D
=>
ùùE G
this
ùùH L
.
ùùL M
CheckLength
ùùM X
(
ùùX Y
length
ùùY _
)
ùù_ `
;
ùù` a
public
üü 
ICharSequence
üü 
ReadCharSequence
üü -
(
üü- .
int
üü. 1
length
üü2 8
,
üü8 9
Encoding
üü: B
encoding
üüC K
)
üüK L
{
†† 	
this
°° 
.
°° 
CheckLength
°° 
(
°° 
length
°° #
)
°°# $
;
°°$ %
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
string
•• 

ReadString
••  
(
••  !
int
••! $
length
••% +
,
••+ ,
Encoding
••- 5
encoding
••6 >
)
••> ?
{
¶¶ 	
this
ßß 
.
ßß 
CheckLength
ßß 
(
ßß 
length
ßß #
)
ßß# $
;
ßß$ %
return
®® 
null
®® 
;
®® 
}
©© 	
public
´´ 
IByteBuffer
´´ 
	SkipBytes
´´ $
(
´´$ %
int
´´% (
length
´´) /
)
´´/ 0
=>
´´1 3
this
´´4 8
.
´´8 9
CheckLength
´´9 D
(
´´D E
length
´´E K
)
´´K L
;
´´L M
public
≠≠ 
IByteBuffer
≠≠ 
WriteBoolean
≠≠ '
(
≠≠' (
bool
≠≠( ,
value
≠≠- 2
)
≠≠2 3
=>
≠≠4 6
throw
≠≠7 <
new
≠≠= @&
IndexOutOfRangeException
≠≠A Y
(
≠≠Y Z
)
≠≠Z [
;
≠≠[ \
public
ØØ 
IByteBuffer
ØØ 
	WriteByte
ØØ $
(
ØØ$ %
int
ØØ% (
value
ØØ) .
)
ØØ. /
=>
ØØ0 2
throw
ØØ3 8
new
ØØ9 <&
IndexOutOfRangeException
ØØ= U
(
ØØU V
)
ØØV W
;
ØØW X
public
±± 
IByteBuffer
±± 

WriteShort
±± %
(
±±% &
int
±±& )
value
±±* /
)
±±/ 0
=>
±±1 3
throw
±±4 9
new
±±: =&
IndexOutOfRangeException
±±> V
(
±±V W
)
±±W X
;
±±X Y
public
≥≥ 
IByteBuffer
≥≥ 
WriteShortLE
≥≥ '
(
≥≥' (
int
≥≥( +
value
≥≥, 1
)
≥≥1 2
=>
≥≥3 5
throw
≥≥6 ;
new
≥≥< ?&
IndexOutOfRangeException
≥≥@ X
(
≥≥X Y
)
≥≥Y Z
;
≥≥Z [
public
µµ 
IByteBuffer
µµ  
WriteUnsignedShort
µµ -
(
µµ- .
ushort
µµ. 4
value
µµ5 :
)
µµ: ;
=>
µµ< >
throw
µµ? D
new
µµE H&
IndexOutOfRangeException
µµI a
(
µµa b
)
µµb c
;
µµc d
public
∑∑ 
IByteBuffer
∑∑ "
WriteUnsignedShortLE
∑∑ /
(
∑∑/ 0
ushort
∑∑0 6
value
∑∑7 <
)
∑∑< =
=>
∑∑> @
throw
∑∑A F
new
∑∑G J&
IndexOutOfRangeException
∑∑K c
(
∑∑c d
)
∑∑d e
;
∑∑e f
public
ππ 
IByteBuffer
ππ 
WriteMedium
ππ &
(
ππ& '
int
ππ' *
value
ππ+ 0
)
ππ0 1
=>
ππ2 4
throw
ππ5 :
new
ππ; >&
IndexOutOfRangeException
ππ? W
(
ππW X
)
ππX Y
;
ππY Z
public
ªª 
IByteBuffer
ªª 
WriteMediumLE
ªª (
(
ªª( )
int
ªª) ,
value
ªª- 2
)
ªª2 3
=>
ªª4 6
throw
ªª7 <
new
ªª= @&
IndexOutOfRangeException
ªªA Y
(
ªªY Z
)
ªªZ [
;
ªª[ \
public
ΩΩ 
IByteBuffer
ΩΩ !
WriteUnsignedMedium
ΩΩ .
(
ΩΩ. /
int
ΩΩ/ 2
value
ΩΩ3 8
)
ΩΩ8 9
=>
ΩΩ: <
throw
ΩΩ= B
new
ΩΩC F&
IndexOutOfRangeException
ΩΩG _
(
ΩΩ_ `
)
ΩΩ` a
;
ΩΩa b
public
øø 
IByteBuffer
øø #
WriteUnsignedMediumLE
øø 0
(
øø0 1
int
øø1 4
value
øø5 :
)
øø: ;
=>
øø< >
throw
øø? D
new
øøE H&
IndexOutOfRangeException
øøI a
(
øøa b
)
øøb c
;
øøc d
public
¡¡ 
IByteBuffer
¡¡ 
WriteInt
¡¡ #
(
¡¡# $
int
¡¡$ '
value
¡¡( -
)
¡¡- .
=>
¡¡/ 1
throw
¡¡2 7
new
¡¡8 ;&
IndexOutOfRangeException
¡¡< T
(
¡¡T U
)
¡¡U V
;
¡¡V W
public
√√ 
IByteBuffer
√√ 

WriteIntLE
√√ %
(
√√% &
int
√√& )
value
√√* /
)
√√/ 0
=>
√√1 3
throw
√√4 9
new
√√: =&
IndexOutOfRangeException
√√> V
(
√√V W
)
√√W X
;
√√X Y
public
≈≈ 
IByteBuffer
≈≈ 
WriteUnsignedInt
≈≈ +
(
≈≈+ ,
uint
≈≈, 0
value
≈≈1 6
)
≈≈6 7
=>
≈≈8 :
throw
≈≈; @
new
≈≈A D&
IndexOutOfRangeException
≈≈E ]
(
≈≈] ^
)
≈≈^ _
;
≈≈_ `
public
«« 
IByteBuffer
««  
WriteUnsignedIntLE
«« -
(
««- .
uint
««. 2
value
««3 8
)
««8 9
=>
««: <
throw
««= B
new
««C F&
IndexOutOfRangeException
««G _
(
««_ `
)
««` a
;
««a b
public
…… 
IByteBuffer
…… 
	WriteLong
…… $
(
……$ %
long
……% )
value
……* /
)
……/ 0
=>
……1 3
throw
……4 9
new
……: =&
IndexOutOfRangeException
……> V
(
……V W
)
……W X
;
……X Y
public
ÀÀ 
IByteBuffer
ÀÀ 
WriteLongLE
ÀÀ &
(
ÀÀ& '
long
ÀÀ' +
value
ÀÀ, 1
)
ÀÀ1 2
=>
ÀÀ3 5
throw
ÀÀ6 ;
new
ÀÀ< ?&
IndexOutOfRangeException
ÀÀ@ X
(
ÀÀX Y
)
ÀÀY Z
;
ÀÀZ [
public
ÕÕ 
IByteBuffer
ÕÕ 
	WriteChar
ÕÕ $
(
ÕÕ$ %
char
ÕÕ% )
value
ÕÕ* /
)
ÕÕ/ 0
=>
ÕÕ1 3
throw
ÕÕ4 9
new
ÕÕ: =&
IndexOutOfRangeException
ÕÕ> V
(
ÕÕV W
)
ÕÕW X
;
ÕÕX Y
public
œœ 
IByteBuffer
œœ 

WriteFloat
œœ %
(
œœ% &
float
œœ& +
value
œœ, 1
)
œœ1 2
=>
œœ3 5
throw
œœ6 ;
new
œœ< ?&
IndexOutOfRangeException
œœ@ X
(
œœX Y
)
œœY Z
;
œœZ [
public
—— 
IByteBuffer
—— 
WriteFloatLE
—— '
(
——' (
float
——( -
value
——. 3
)
——3 4
=>
——5 7
throw
——8 =
new
——> A&
IndexOutOfRangeException
——B Z
(
——Z [
)
——[ \
;
——\ ]
public
”” 
IByteBuffer
”” 
WriteDouble
”” &
(
””& '
double
””' -
value
””. 3
)
””3 4
=>
””5 7
throw
””8 =
new
””> A&
IndexOutOfRangeException
””B Z
(
””Z [
)
””[ \
;
””\ ]
public
’’ 
IByteBuffer
’’ 
WriteDoubleLE
’’ (
(
’’( )
double
’’) /
value
’’0 5
)
’’5 6
=>
’’7 9
throw
’’: ?
new
’’@ C&
IndexOutOfRangeException
’’D \
(
’’\ ]
)
’’] ^
;
’’^ _
public
◊◊ 
IByteBuffer
◊◊ 

WriteBytes
◊◊ %
(
◊◊% &
IByteBuffer
◊◊& 1
src
◊◊2 5
)
◊◊5 6
=>
◊◊7 9
this
◊◊: >
.
◊◊> ?
CheckLength
◊◊? J
(
◊◊J K
src
◊◊K N
.
◊◊N O
ReadableBytes
◊◊O \
)
◊◊\ ]
;
◊◊] ^
public
ŸŸ 
IByteBuffer
ŸŸ 

WriteBytes
ŸŸ %
(
ŸŸ% &
IByteBuffer
ŸŸ& 1
src
ŸŸ2 5
,
ŸŸ5 6
int
ŸŸ7 :
length
ŸŸ; A
)
ŸŸA B
=>
ŸŸC E
this
ŸŸF J
.
ŸŸJ K
CheckLength
ŸŸK V
(
ŸŸV W
length
ŸŸW ]
)
ŸŸ] ^
;
ŸŸ^ _
public
€€ 
IByteBuffer
€€ 

WriteBytes
€€ %
(
€€% &
IByteBuffer
€€& 1
src
€€2 5
,
€€5 6
int
€€7 :
srcIndex
€€; C
,
€€C D
int
€€E H
length
€€I O
)
€€O P
=>
€€Q S
this
€€T X
.
€€X Y
CheckLength
€€Y d
(
€€d e
length
€€e k
)
€€k l
;
€€l m
public
›› 
IByteBuffer
›› 

WriteBytes
›› %
(
››% &
byte
››& *
[
››* +
]
››+ ,
src
››- 0
)
››0 1
=>
››2 4
this
››5 9
.
››9 :
CheckLength
››: E
(
››E F
src
››F I
.
››I J
Length
››J P
)
››P Q
;
››Q R
public
ﬂﬂ 
IByteBuffer
ﬂﬂ 

WriteBytes
ﬂﬂ %
(
ﬂﬂ% &
byte
ﬂﬂ& *
[
ﬂﬂ* +
]
ﬂﬂ+ ,
src
ﬂﬂ- 0
,
ﬂﬂ0 1
int
ﬂﬂ2 5
srcIndex
ﬂﬂ6 >
,
ﬂﬂ> ?
int
ﬂﬂ@ C
length
ﬂﬂD J
)
ﬂﬂJ K
=>
ﬂﬂL N
this
ﬂﬂO S
.
ﬂﬂS T
CheckLength
ﬂﬂT _
(
ﬂﬂ_ `
length
ﬂﬂ` f
)
ﬂﬂf g
;
ﬂﬂg h
public
·· 
IByteBuffer
·· 
	WriteZero
·· $
(
··$ %
int
··% (
length
··) /
)
··/ 0
=>
··1 3
this
··4 8
.
··8 9
CheckLength
··9 D
(
··D E
length
··E K
)
··K L
;
··L M
public
„„ 
int
„„ 
WriteCharSequence
„„ $
(
„„$ %
ICharSequence
„„% 2
sequence
„„3 ;
,
„„; <
Encoding
„„= E
encoding
„„F N
)
„„N O
=>
„„P R
throw
„„S X
new
„„Y \&
IndexOutOfRangeException
„„] u
(
„„u v
)
„„v w
;
„„w x
public
ÂÂ 
int
ÂÂ 
WriteString
ÂÂ 
(
ÂÂ 
string
ÂÂ %
value
ÂÂ& +
,
ÂÂ+ ,
Encoding
ÂÂ- 5
encoding
ÂÂ6 >
)
ÂÂ> ?
=>
ÂÂ@ B
throw
ÂÂC H
new
ÂÂI L&
IndexOutOfRangeException
ÂÂM e
(
ÂÂe f
)
ÂÂf g
;
ÂÂg h
public
ÁÁ 
int
ÁÁ 
IndexOf
ÁÁ 
(
ÁÁ 
int
ÁÁ 
	fromIndex
ÁÁ (
,
ÁÁ( )
int
ÁÁ* -
toIndex
ÁÁ. 5
,
ÁÁ5 6
byte
ÁÁ7 ;
value
ÁÁ< A
)
ÁÁA B
{
ËË 	
this
ÈÈ 
.
ÈÈ 

CheckIndex
ÈÈ 
(
ÈÈ 
	fromIndex
ÈÈ %
)
ÈÈ% &
;
ÈÈ& '
this
ÍÍ 
.
ÍÍ 

CheckIndex
ÍÍ 
(
ÍÍ 
toIndex
ÍÍ #
)
ÍÍ# $
;
ÍÍ$ %
return
ÎÎ 
-
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÓÓ 
int
ÓÓ 
BytesBefore
ÓÓ 
(
ÓÓ 
byte
ÓÓ #
value
ÓÓ$ )
)
ÓÓ) *
=>
ÓÓ+ -
-
ÓÓ. /
$num
ÓÓ/ 0
;
ÓÓ0 1
public
 
int
 
BytesBefore
 
(
 
int
 "
length
# )
,
) *
byte
+ /
value
0 5
)
5 6
{
ÒÒ 	
this
ÚÚ 
.
ÚÚ 
CheckLength
ÚÚ 
(
ÚÚ 
length
ÚÚ #
)
ÚÚ# $
;
ÚÚ$ %
return
ÛÛ 
-
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
}
ÙÙ 	
public
ˆˆ 
int
ˆˆ 
BytesBefore
ˆˆ 
(
ˆˆ 
int
ˆˆ "
index
ˆˆ# (
,
ˆˆ( )
int
ˆˆ* -
length
ˆˆ. 4
,
ˆˆ4 5
byte
ˆˆ6 :
value
ˆˆ; @
)
ˆˆ@ A
{
˜˜ 	
this
¯¯ 
.
¯¯ 

CheckIndex
¯¯ 
(
¯¯ 
index
¯¯ !
,
¯¯! "
length
¯¯# )
)
¯¯) *
;
¯¯* +
return
˘˘ 
-
˘˘ 
$num
˘˘ 
;
˘˘ 
}
˙˙ 	
public
¸¸ 
int
¸¸ 
ForEachByte
¸¸ 
(
¸¸ 
IByteProcessor
¸¸ -
	processor
¸¸. 7
)
¸¸7 8
=>
¸¸9 ;
-
¸¸< =
$num
¸¸= >
;
¸¸> ?
public
˛˛ 
int
˛˛ 
ForEachByte
˛˛ 
(
˛˛ 
int
˛˛ "
index
˛˛# (
,
˛˛( )
int
˛˛* -
length
˛˛. 4
,
˛˛4 5
IByteProcessor
˛˛6 D
	processor
˛˛E N
)
˛˛N O
{
ˇˇ 	
this
ÄÄ 
.
ÄÄ 

CheckIndex
ÄÄ 
(
ÄÄ 
index
ÄÄ !
,
ÄÄ! "
length
ÄÄ# )
)
ÄÄ) *
;
ÄÄ* +
return
ÅÅ 
-
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
public
ÑÑ 
int
ÑÑ 
ForEachByteDesc
ÑÑ "
(
ÑÑ" #
IByteProcessor
ÑÑ# 1
	processor
ÑÑ2 ;
)
ÑÑ; <
=>
ÑÑ= ?
-
ÑÑ@ A
$num
ÑÑA B
;
ÑÑB C
public
ÜÜ 
int
ÜÜ 
ForEachByteDesc
ÜÜ "
(
ÜÜ" #
int
ÜÜ# &
index
ÜÜ' ,
,
ÜÜ, -
int
ÜÜ. 1
length
ÜÜ2 8
,
ÜÜ8 9
IByteProcessor
ÜÜ: H
	processor
ÜÜI R
)
ÜÜR S
{
áá 	
this
àà 
.
àà 

CheckIndex
àà 
(
àà 
index
àà !
,
àà! "
length
àà# )
)
àà) *
;
àà* +
return
ââ 
-
ââ 
$num
ââ 
;
ââ 
}
ää 	
public
åå 
IByteBuffer
åå 
Copy
åå 
(
åå  
)
åå  !
=>
åå" $
this
åå% )
;
åå) *
public
éé 
IByteBuffer
éé 
Copy
éé 
(
éé  
int
éé  #
index
éé$ )
,
éé) *
int
éé+ .
length
éé/ 5
)
éé5 6
{
èè 	
this
êê 
.
êê 

CheckIndex
êê 
(
êê 
index
êê !
,
êê! "
length
êê# )
)
êê) *
;
êê* +
return
ëë 
this
ëë 
;
ëë 
}
íí 	
public
îî 
IByteBuffer
îî 
Slice
îî  
(
îî  !
)
îî! "
=>
îî# %
this
îî& *
;
îî* +
public
ññ 
IByteBuffer
ññ 
RetainedSlice
ññ (
(
ññ( )
)
ññ) *
=>
ññ+ -
this
ññ. 2
;
ññ2 3
public
òò 
IByteBuffer
òò 
Slice
òò  
(
òò  !
int
òò! $
index
òò% *
,
òò* +
int
òò, /
length
òò0 6
)
òò6 7
=>
òò8 :
this
òò; ?
.
òò? @

CheckIndex
òò@ J
(
òòJ K
index
òòK P
,
òòP Q
length
òòR X
)
òòX Y
;
òòY Z
public
öö 
IByteBuffer
öö 
RetainedSlice
öö (
(
öö( )
int
öö) ,
index
öö- 2
,
öö2 3
int
öö4 7
length
öö8 >
)
öö> ?
=>
öö@ B
this
ööC G
.
ööG H

CheckIndex
ööH R
(
ööR S
index
ööS X
,
ööX Y
length
ööZ `
)
öö` a
;
ööa b
public
úú 
IByteBuffer
úú 
	Duplicate
úú $
(
úú$ %
)
úú% &
=>
úú' )
this
úú* .
;
úú. /
public
ûû 
int
ûû 
IoBufferCount
ûû  
=>
ûû! #
$num
ûû$ %
;
ûû% &
public
†† 
ArraySegment
†† 
<
†† 
byte
††  
>
††  !
GetIoBuffer
††" -
(
††- .
)
††. /
=>
††0 2
EmptyBuffer
††3 >
;
††> ?
public
¢¢ 
ArraySegment
¢¢ 
<
¢¢ 
byte
¢¢  
>
¢¢  !
GetIoBuffer
¢¢" -
(
¢¢- .
int
¢¢. 1
index
¢¢2 7
,
¢¢7 8
int
¢¢9 <
length
¢¢= C
)
¢¢C D
{
££ 	
this
§§ 
.
§§ 

CheckIndex
§§ 
(
§§ 
index
§§ !
,
§§! "
length
§§# )
)
§§) *
;
§§* +
return
•• 
this
•• 
.
•• 
GetIoBuffer
•• #
(
••# $
)
••$ %
;
••% &
}
¶¶ 	
public
®® 
ArraySegment
®® 
<
®® 
byte
®®  
>
®®  !
[
®®! "
]
®®" #
GetIoBuffers
®®$ 0
(
®®0 1
)
®®1 2
=>
®®3 5
EmptyBuffers
®®6 B
;
®®B C
public
™™ 
ArraySegment
™™ 
<
™™ 
byte
™™  
>
™™  !
[
™™! "
]
™™" #
GetIoBuffers
™™$ 0
(
™™0 1
int
™™1 4
index
™™5 :
,
™™: ;
int
™™< ?
length
™™@ F
)
™™F G
{
´´ 	
this
¨¨ 
.
¨¨ 

CheckIndex
¨¨ 
(
¨¨ 
index
¨¨ !
,
¨¨! "
length
¨¨# )
)
¨¨) *
;
¨¨* +
return
≠≠ 
this
≠≠ 
.
≠≠ 
GetIoBuffers
≠≠ $
(
≠≠$ %
)
≠≠% &
;
≠≠& '
}
ÆÆ 	
public
∞∞ 
bool
∞∞ 
HasArray
∞∞ 
=>
∞∞ 
true
∞∞  $
;
∞∞$ %
public
≤≤ 
byte
≤≤ 
[
≤≤ 
]
≤≤ 
Array
≤≤ 
=>
≤≤ 
ArrayExtensions
≤≤ .
.
≤≤. /
	ZeroBytes
≤≤/ 8
;
≤≤8 9
public
¥¥ 
byte
¥¥ 
[
¥¥ 
]
¥¥ 
ToArray
¥¥ 
(
¥¥ 
)
¥¥ 
=>
¥¥  "
ArrayExtensions
¥¥# 2
.
¥¥2 3
	ZeroBytes
¥¥3 <
;
¥¥< =
public
∂∂ 
int
∂∂ 
ArrayOffset
∂∂ 
=>
∂∂ !
$num
∂∂" #
;
∂∂# $
public
∏∏ 
bool
∏∏ 
HasMemoryAddress
∏∏ $
=>
∏∏% '
false
∏∏( -
;
∏∏- .
public
∫∫ 
ref
∫∫ 
byte
∫∫ &
GetPinnableMemoryAddress
∫∫ 0
(
∫∫0 1
)
∫∫1 2
=>
∫∫3 5
throw
∫∫6 ;
new
∫∫< ?#
NotSupportedException
∫∫@ U
(
∫∫U V
)
∫∫V W
;
∫∫W X
public
ºº 
IntPtr
ºº #
AddressOfPinnedMemory
ºº +
(
ºº+ ,
)
ºº, -
=>
ºº. 0
IntPtr
ºº1 7
.
ºº7 8
Zero
ºº8 <
;
ºº< =
public
ææ 
string
ææ 
ToString
ææ 
(
ææ 
Encoding
ææ '
encoding
ææ( 0
)
ææ0 1
=>
ææ2 4
string
ææ5 ;
.
ææ; <
Empty
ææ< A
;
ææA B
public
¿¿ 
string
¿¿ 
ToString
¿¿ 
(
¿¿ 
int
¿¿ "
index
¿¿# (
,
¿¿( )
int
¿¿* -
length
¿¿. 4
,
¿¿4 5
Encoding
¿¿6 >
encoding
¿¿? G
)
¿¿G H
{
¡¡ 	
this
¬¬ 
.
¬¬ 

CheckIndex
¬¬ 
(
¬¬ 
index
¬¬ !
,
¬¬! "
length
¬¬# )
)
¬¬) *
;
¬¬* +
return
√√ 
this
√√ 
.
√√ 
ToString
√√  
(
√√  !
encoding
√√! )
)
√√) *
;
√√* +
}
ƒƒ 	
public
∆∆ 
override
∆∆ 
int
∆∆ 
GetHashCode
∆∆ '
(
∆∆' (
)
∆∆( )
=>
∆∆* ,
$num
∆∆- .
;
∆∆. /
public
»» 
bool
»» 
Equals
»» 
(
»» 
IByteBuffer
»» &
buffer
»»' -
)
»»- .
=>
»»/ 1
buffer
»»2 8
!=
»»9 ;
null
»»< @
&&
»»A C
!
»»D E
buffer
»»E K
.
»»K L

IsReadable
»»L V
(
»»V W
)
»»W X
;
»»X Y
public
   
override
   
bool
   
Equals
   #
(
  # $
object
  $ *
obj
  + .
)
  . /
{
ÀÀ 	
var
ÃÃ 
buffer
ÃÃ 
=
ÃÃ 
obj
ÃÃ 
as
ÃÃ 
IByteBuffer
ÃÃ  +
;
ÃÃ+ ,
return
ÕÕ 
this
ÕÕ 
.
ÕÕ 
Equals
ÕÕ 
(
ÕÕ 
buffer
ÕÕ %
)
ÕÕ% &
;
ÕÕ& '
}
ŒŒ 	
public
–– 
int
–– 
	CompareTo
–– 
(
–– 
IByteBuffer
–– (
buffer
––) /
)
––/ 0
=>
––1 3
buffer
––4 :
.
––: ;

IsReadable
––; E
(
––E F
)
––F G
?
––H I
-
––J K
$num
––K L
:
––M N
$num
––O P
;
––P Q
public
““ 
override
““ 
string
““ 
ToString
““ '
(
““' (
)
““( )
=>
““* ,
string
““- 3
.
““3 4
Empty
““4 9
;
““9 :
public
‘‘ 
bool
‘‘ 

IsReadable
‘‘ 
(
‘‘ 
)
‘‘  
=>
‘‘! #
false
‘‘$ )
;
‘‘) *
public
÷÷ 
bool
÷÷ 

IsReadable
÷÷ 
(
÷÷ 
int
÷÷ "
size
÷÷# '
)
÷÷' (
=>
÷÷) +
false
÷÷, 1
;
÷÷1 2
public
ÿÿ 
int
ÿÿ 
ReferenceCount
ÿÿ !
=>
ÿÿ" $
$num
ÿÿ% &
;
ÿÿ& '
public
⁄⁄ 
IReferenceCounted
⁄⁄  
Retain
⁄⁄! '
(
⁄⁄' (
)
⁄⁄( )
=>
⁄⁄* ,
this
⁄⁄- 1
;
⁄⁄1 2
public
‹‹ 
IByteBuffer
‹‹ 
RetainedDuplicate
‹‹ ,
(
‹‹, -
)
‹‹- .
=>
‹‹/ 1
this
‹‹2 6
;
‹‹6 7
public
ﬁﬁ 
IReferenceCounted
ﬁﬁ  
Retain
ﬁﬁ! '
(
ﬁﬁ' (
int
ﬁﬁ( +
	increment
ﬁﬁ, 5
)
ﬁﬁ5 6
=>
ﬁﬁ7 9
this
ﬁﬁ: >
;
ﬁﬁ> ?
public
‡‡ 
IReferenceCounted
‡‡  
Touch
‡‡! &
(
‡‡& '
)
‡‡' (
=>
‡‡) +
this
‡‡, 0
;
‡‡0 1
public
‚‚ 
IReferenceCounted
‚‚  
Touch
‚‚! &
(
‚‚& '
object
‚‚' -
hint
‚‚. 2
)
‚‚2 3
=>
‚‚4 6
this
‚‚7 ;
;
‚‚; <
public
‰‰ 
bool
‰‰ 
Release
‰‰ 
(
‰‰ 
)
‰‰ 
=>
‰‰  
false
‰‰! &
;
‰‰& '
public
ÊÊ 
bool
ÊÊ 
Release
ÊÊ 
(
ÊÊ 
int
ÊÊ 
	decrement
ÊÊ  )
)
ÊÊ) *
=>
ÊÊ+ -
false
ÊÊ. 3
;
ÊÊ3 4
public
ËË 
IByteBuffer
ËË 
	ReadSlice
ËË $
(
ËË$ %
int
ËË% (
length
ËË) /
)
ËË/ 0
=>
ËË1 3
this
ËË4 8
.
ËË8 9
CheckLength
ËË9 D
(
ËËD E
length
ËËE K
)
ËËK L
;
ËËL M
public
ÍÍ 
IByteBuffer
ÍÍ 
ReadRetainedSlice
ÍÍ ,
(
ÍÍ, -
int
ÍÍ- 0
length
ÍÍ1 7
)
ÍÍ7 8
=>
ÍÍ9 ;
this
ÍÍ< @
.
ÍÍ@ A
CheckLength
ÍÍA L
(
ÍÍL M
length
ÍÍM S
)
ÍÍS T
;
ÍÍT U
public
ÏÏ 
Task
ÏÏ 
WriteBytesAsync
ÏÏ #
(
ÏÏ# $
Stream
ÏÏ$ *
stream
ÏÏ+ 1
,
ÏÏ1 2
int
ÏÏ3 6
length
ÏÏ7 =
)
ÏÏ= >
{
ÌÌ 	
this
ÓÓ 
.
ÓÓ 
CheckLength
ÓÓ 
(
ÓÓ 
length
ÓÓ #
)
ÓÓ# $
;
ÓÓ$ %
return
ÔÔ 
TaskEx
ÔÔ 
.
ÔÔ 
	Completed
ÔÔ #
;
ÔÔ# $
}
 	
public
ÚÚ 
Task
ÚÚ 
WriteBytesAsync
ÚÚ #
(
ÚÚ# $
Stream
ÚÚ$ *
stream
ÚÚ+ 1
,
ÚÚ1 2
int
ÚÚ3 6
length
ÚÚ7 =
,
ÚÚ= >
CancellationToken
ÚÚ? P
cancellationToken
ÚÚQ b
)
ÚÚb c
{
ÛÛ 	
this
ÙÙ 
.
ÙÙ 
CheckLength
ÙÙ 
(
ÙÙ 
length
ÙÙ #
)
ÙÙ# $
;
ÙÙ$ %
return
ıı 
TaskEx
ıı 
.
ıı 
	Completed
ıı #
;
ıı# $
}
ˆˆ 	
IByteBuffer
˘˘ 

CheckIndex
˘˘ 
(
˘˘ 
int
˘˘ "
index
˘˘# (
)
˘˘( )
{
˙˙ 	
if
˚˚ 
(
˚˚ 
index
˚˚ 
!=
˚˚ 
$num
˚˚ 
)
˚˚ 
{
¸¸ 
throw
˝˝ 
new
˝˝ &
IndexOutOfRangeException
˝˝ 2
(
˝˝2 3
)
˝˝3 4
;
˝˝4 5
}
˛˛ 
return
ˇˇ 
this
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
IByteBuffer
ÇÇ 

CheckIndex
ÇÇ 
(
ÇÇ 
int
ÇÇ "
index
ÇÇ# (
,
ÇÇ( )
int
ÇÇ* -
length
ÇÇ. 4
)
ÇÇ4 5
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ 
length
ÑÑ 
<
ÑÑ 
$num
ÑÑ 
)
ÑÑ 
{
ÖÖ 
throw
ÜÜ 
new
ÜÜ 
ArgumentException
ÜÜ +
(
ÜÜ+ ,
$str
ÜÜ, 6
+
ÜÜ7 8
length
ÜÜ9 ?
)
ÜÜ? @
;
ÜÜ@ A
}
áá 
if
àà 
(
àà 
index
àà 
!=
àà 
$num
àà 
||
àà 
length
àà $
!=
àà% '
$num
àà( )
)
àà) *
{
ââ 
throw
ää 
new
ää &
IndexOutOfRangeException
ää 2
(
ää2 3
)
ää3 4
;
ää4 5
}
ãã 
return
çç 
this
çç 
;
çç 
}
éé 	
IByteBuffer
ëë 
CheckLength
ëë 
(
ëë  
int
ëë  #
length
ëë$ *
)
ëë* +
{
íí 	
if
ìì 
(
ìì 
length
ìì 
<
ìì 
$num
ìì 
)
ìì 
{
îî 
throw
ïï 
new
ïï 
ArgumentException
ïï +
(
ïï+ ,
$str
ïï, 6
+
ïï7 8
length
ïï9 ?
+
ïï@ A
$str
ïïB U
)
ïïU V
;
ïïV W
}
ññ 
if
óó 
(
óó 
length
óó 
!=
óó 
$num
óó 
)
óó 
{
òò 
throw
ôô 
new
ôô &
IndexOutOfRangeException
ôô 2
(
ôô2 3
)
ôô3 4
;
ôô4 5
}
öö 
return
õõ 
this
õõ 
;
õõ 
}
úú 	
}
ùù 
}ûû ó≈
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\HeapByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

class 
HeapByteBufferUtil #
{		 
[

 	

MethodImpl

	 
(

 
MethodImplOptions

 %
.

% &
AggressiveInlining

& 8
)

8 9
]

9 :
internal 
static 
byte 
GetByte $
($ %
byte% )
[) *
]* +
memory, 2
,2 3
int4 7
index8 =
)= >
=>? A
memoryB H
[H I
indexI N
]N O
;O P
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 
GetShort &
(& '
byte' +
[+ ,
], -
memory. 4
,4 5
int6 9
index: ?
)? @
=>A C
	unchecked 
( 
( 
short 
) 
( 
memory $
[$ %
index% *
]* +
<<, .
$num/ 0
|1 2
memory3 9
[9 :
index: ?
+@ A
$numB C
]C D
)D E
)E F
;F G
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 

GetShortLE (
(( )
byte) -
[- .
]. /
memory0 6
,6 7
int8 ;
index< A
)A B
=>C E
	unchecked 
( 
( 
short 
) 
( 
memory $
[$ %
index% *
]* +
|, -
memory. 4
[4 5
index5 :
+; <
$num= >
]> ?
<<@ B
$numC D
)D E
)E F
;F G
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMedium -
(- .
byte. 2
[2 3
]3 4
memory5 ;
,; <
int= @
indexA F
)F G
=>H J
	unchecked 
( 
memory 
[ 
index 
] 
<<  
$num! #
|$ %
memory 
[ 
index 
+ 
$num  
]  !
<<" $
$num% &
|' (
memory 
[ 
index 
+ 
$num  
]  !
)! "
;" #
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMediumLE /
(/ 0
byte0 4
[4 5
]5 6
memory7 =
,= >
int? B
indexC H
)H I
=>J L
	unchecked 
( 
memory 
[ 
index 
] 
| 
memory   
[   
index   
+   
$num    
]    !
<<  " $
$num  % &
|  ' (
memory!! 
[!! 
index!! 
+!! 
$num!!  
]!!  !
<<!!" $
$num!!% '
)!!' (
;!!( )
[## 	

MethodImpl##	 
(## 
MethodImplOptions## %
.##% &
AggressiveInlining##& 8
)##8 9
]##9 :
internal$$ 
static$$ 
int$$ 
GetInt$$ "
($$" #
byte$$# '
[$$' (
]$$( )
memory$$* 0
,$$0 1
int$$2 5
index$$6 ;
)$$; <
=>$$= ?
	unchecked%% 
(%% 
memory&& 
[&& 
index&& 
]&& 
<<&&  
$num&&! #
|&&$ %
memory'' 
['' 
index'' 
+'' 
$num''  
]''  !
<<''" $
$num''% '
|''( )
memory(( 
[(( 
index(( 
+(( 
$num((  
]((  !
<<((" $
$num((% &
|((' (
memory)) 
[)) 
index)) 
+)) 
$num))  
]))  !
)))! "
;))" #
[++ 	

MethodImpl++	 
(++ 
MethodImplOptions++ %
.++% &
AggressiveInlining++& 8
)++8 9
]++9 :
internal,, 
static,, 
int,, 
GetIntLE,, $
(,,$ %
byte,,% )
[,,) *
],,* +
memory,,, 2
,,,2 3
int,,4 7
index,,8 =
),,= >
=>,,? A
	unchecked-- 
(-- 
memory.. 
[.. 
index.. 
].. 
|.. 
memory// 
[// 
index// 
+// 
$num//  
]//  !
<<//" $
$num//% &
|//' (
memory00 
[00 
index00 
+00 
$num00  
]00  !
<<00" $
$num00% '
|00( )
memory11 
[11 
index11 
+11 
$num11  
]11  !
<<11" $
$num11% '
)11' (
;11( )
[33 	

MethodImpl33	 
(33 
MethodImplOptions33 %
.33% &
AggressiveInlining33& 8
)338 9
]339 :
internal44 
static44 
long44 
GetLong44 $
(44$ %
byte44% )
[44) *
]44* +
memory44, 2
,442 3
int444 7
index448 =
)44= >
=>44? A
	unchecked55 
(55 
(66 
long66 
)66 
memory66 
[66 
index66 "
]66" #
<<66$ &
$num66' )
|66* +
(77 
long77 
)77 
memory77 
[77 
index77 "
+77# $
$num77% &
]77& '
<<77( *
$num77+ -
|77. /
(88 
long88 
)88 
memory88 
[88 
index88 "
+88# $
$num88% &
]88& '
<<88( *
$num88+ -
|88. /
(99 
long99 
)99 
memory99 
[99 
index99 "
+99# $
$num99% &
]99& '
<<99( *
$num99+ -
|99. /
(:: 
long:: 
):: 
memory:: 
[:: 
index:: "
+::# $
$num::% &
]::& '
<<::( *
$num::+ -
|::. /
(;; 
long;; 
);; 
memory;; 
[;; 
index;; "
+;;# $
$num;;% &
];;& '
<<;;( *
$num;;+ -
|;;. /
(<< 
long<< 
)<< 
memory<< 
[<< 
index<< "
+<<# $
$num<<% &
]<<& '
<<<<( *
$num<<+ ,
|<<- .
memory== 
[== 
index== 
+== 
$num==  
]==  !
)==! "
;==" #
[?? 	

MethodImpl??	 
(?? 
MethodImplOptions?? %
.??% &
AggressiveInlining??& 8
)??8 9
]??9 :
internal@@ 
static@@ 
long@@ 
	GetLongLE@@ &
(@@& '
byte@@' +
[@@+ ,
]@@, -
memory@@. 4
,@@4 5
int@@6 9
index@@: ?
)@@? @
=>@@A C
	uncheckedAA 
(AA 
memoryBB 
[BB 
indexBB 
]BB 
|BB 
(CC 
longCC 
)CC 
memoryCC 
[CC 
indexCC "
+CC# $
$numCC% &
]CC& '
<<CC( *
$numCC+ ,
|CC- .
(DD 
longDD 
)DD 
memoryDD 
[DD 
indexDD "
+DD# $
$numDD% &
]DD& '
<<DD( *
$numDD+ -
|DD. /
(EE 
longEE 
)EE 
memoryEE 
[EE 
indexEE "
+EE# $
$numEE% &
]EE& '
<<EE( *
$numEE+ -
|EE. /
(FF 
longFF 
)FF 
memoryFF 
[FF 
indexFF "
+FF# $
$numFF% &
]FF& '
<<FF( *
$numFF+ -
|FF. /
(GG 
longGG 
)GG 
memoryGG 
[GG 
indexGG "
+GG# $
$numGG% &
]GG& '
<<GG( *
$numGG+ -
|GG. /
(HH 
longHH 
)HH 
memoryHH 
[HH 
indexHH "
+HH# $
$numHH% &
]HH& '
<<HH( *
$numHH+ -
|HH. /
(II 
longII 
)II 
memoryII 
[II 
indexII "
+II# $
$numII% &
]II& '
<<II( *
$numII+ -
)II- .
;II. /
[KK 	

MethodImplKK	 
(KK 
MethodImplOptionsKK %
.KK% &
AggressiveInliningKK& 8
)KK8 9
]KK9 :
internalLL 
staticLL 
voidLL 
SetByteLL $
(LL$ %
byteLL% )
[LL) *
]LL* +
memoryLL, 2
,LL2 3
intLL4 7
indexLL8 =
,LL= >
intLL? B
valueLLC H
)LLH I
{MM 	
	uncheckedNN 
{OO 
memoryPP 
[PP 
indexPP 
]PP 
=PP 
(PP  !
bytePP! %
)PP% &
valuePP& +
;PP+ ,
}QQ 
}RR 	
[TT 	

MethodImplTT	 
(TT 
MethodImplOptionsTT %
.TT% &
AggressiveInliningTT& 8
)TT8 9
]TT9 :
internalUU 
staticUU 
voidUU 
SetShortUU %
(UU% &
byteUU& *
[UU* +
]UU+ ,
memoryUU- 3
,UU3 4
intUU5 8
indexUU9 >
,UU> ?
intUU@ C
valueUUD I
)UUI J
{VV 	
	uncheckedWW 
{XX 
memoryYY 
[YY 
indexYY 
]YY 
=YY 
(YY  !
byteYY! %
)YY% &
(YY& '
(YY' (
ushortYY( .
)YY. /
valueYY/ 4
>>YY5 7
$numYY8 9
)YY9 :
;YY: ;
memoryZZ 
[ZZ 
indexZZ 
+ZZ 
$numZZ  
]ZZ  !
=ZZ" #
(ZZ$ %
byteZZ% )
)ZZ) *
valueZZ* /
;ZZ/ 0
}[[ 
}\\ 	
[^^ 	

MethodImpl^^	 
(^^ 
MethodImplOptions^^ %
.^^% &
AggressiveInlining^^& 8
)^^8 9
]^^9 :
internal__ 
static__ 
void__ 

SetShortLE__ '
(__' (
byte__( ,
[__, -
]__- .
memory__/ 5
,__5 6
int__7 :
index__; @
,__@ A
int__B E
value__F K
)__K L
{`` 	
	uncheckedaa 
{bb 
memorycc 
[cc 
indexcc 
]cc 
=cc 
(cc  !
bytecc! %
)cc% &
valuecc& +
;cc+ ,
memorydd 
[dd 
indexdd 
+dd 
$numdd  
]dd  !
=dd" #
(dd$ %
bytedd% )
)dd) *
(dd* +
(dd+ ,
ushortdd, 2
)dd2 3
valuedd3 8
>>dd9 ;
$numdd< =
)dd= >
;dd> ?
}ee 
}ff 	
[hh 	

MethodImplhh	 
(hh 
MethodImplOptionshh %
.hh% &
AggressiveInlininghh& 8
)hh8 9
]hh9 :
internalii 
staticii 
voidii 
	SetMediumii &
(ii& '
byteii' +
[ii+ ,
]ii, -
memoryii. 4
,ii4 5
intii6 9
indexii: ?
,ii? @
intiiA D
valueiiE J
)iiJ K
{jj 	
	uncheckedkk 
{ll 
uintmm 
unsignedValuemm "
=mm# $
(mm% &
uintmm& *
)mm* +
valuemm+ 0
;mm0 1
memorynn 
[nn 
indexnn 
]nn 
=nn 
(nn  !
bytenn! %
)nn% &
(nn& '
unsignedValuenn' 4
>>nn5 7
$numnn8 :
)nn: ;
;nn; <
memoryoo 
[oo 
indexoo 
+oo 
$numoo  
]oo  !
=oo" #
(oo$ %
byteoo% )
)oo) *
(oo* +
unsignedValueoo+ 8
>>oo9 ;
$numoo< =
)oo= >
;oo> ?
memorypp 
[pp 
indexpp 
+pp 
$numpp  
]pp  !
=pp" #
(pp$ %
bytepp% )
)pp) *
unsignedValuepp* 7
;pp7 8
}qq 
}rr 	
[tt 	

MethodImpltt	 
(tt 
MethodImplOptionstt %
.tt% &
AggressiveInliningtt& 8
)tt8 9
]tt9 :
internaluu 
staticuu 
voiduu 
SetMediumLEuu (
(uu( )
byteuu) -
[uu- .
]uu. /
memoryuu0 6
,uu6 7
intuu8 ;
indexuu< A
,uuA B
intuuC F
valueuuG L
)uuL M
{vv 	
	uncheckedww 
{xx 
uintyy 
unsignedValueyy "
=yy# $
(yy% &
uintyy& *
)yy* +
valueyy+ 0
;yy0 1
memoryzz 
[zz 
indexzz 
]zz 
=zz 
(zz  !
bytezz! %
)zz% &
unsignedValuezz& 3
;zz3 4
memory{{ 
[{{ 
index{{ 
+{{ 
$num{{  
]{{  !
={{" #
({{$ %
byte{{% )
){{) *
({{* +
unsignedValue{{+ 8
>>{{9 ;
$num{{< =
){{= >
;{{> ?
memory|| 
[|| 
index|| 
+|| 
$num||  
]||  !
=||" #
(||$ %
byte||% )
)||) *
(||* +
unsignedValue||+ 8
>>||9 ;
$num||< >
)||> ?
;||? @
}}} 
}~~ 	
[
ÄÄ 	

MethodImpl
ÄÄ	 
(
ÄÄ 
MethodImplOptions
ÄÄ %
.
ÄÄ% & 
AggressiveInlining
ÄÄ& 8
)
ÄÄ8 9
]
ÄÄ9 :
internal
ÅÅ 
static
ÅÅ 
void
ÅÅ 
SetInt
ÅÅ #
(
ÅÅ# $
byte
ÅÅ$ (
[
ÅÅ( )
]
ÅÅ) *
memory
ÅÅ+ 1
,
ÅÅ1 2
int
ÅÅ3 6
index
ÅÅ7 <
,
ÅÅ< =
int
ÅÅ> A
value
ÅÅB G
)
ÅÅG H
{
ÇÇ 	
	unchecked
ÉÉ 
{
ÑÑ 
uint
ÖÖ 
unsignedValue
ÖÖ "
=
ÖÖ# $
(
ÖÖ% &
uint
ÖÖ& *
)
ÖÖ* +
value
ÖÖ+ 0
;
ÖÖ0 1
memory
ÜÜ 
[
ÜÜ 
index
ÜÜ 
]
ÜÜ 
=
ÜÜ 
(
ÜÜ  !
byte
ÜÜ! %
)
ÜÜ% &
(
ÜÜ& '
unsignedValue
ÜÜ' 4
>>
ÜÜ5 7
$num
ÜÜ8 :
)
ÜÜ: ;
;
ÜÜ; <
memory
áá 
[
áá 
index
áá 
+
áá 
$num
áá  
]
áá  !
=
áá" #
(
áá$ %
byte
áá% )
)
áá) *
(
áá* +
unsignedValue
áá+ 8
>>
áá9 ;
$num
áá< >
)
áá> ?
;
áá? @
memory
àà 
[
àà 
index
àà 
+
àà 
$num
àà  
]
àà  !
=
àà" #
(
àà$ %
byte
àà% )
)
àà) *
(
àà* +
unsignedValue
àà+ 8
>>
àà9 ;
$num
àà; <
)
àà< =
;
àà= >
memory
ââ 
[
ââ 
index
ââ 
+
ââ 
$num
ââ  
]
ââ  !
=
ââ" #
(
ââ$ %
byte
ââ% )
)
ââ) *
unsignedValue
ââ* 7
;
ââ7 8
}
ää 
}
ãã 	
[
çç 	

MethodImpl
çç	 
(
çç 
MethodImplOptions
çç %
.
çç% & 
AggressiveInlining
çç& 8
)
çç8 9
]
çç9 :
internal
éé 
static
éé 
void
éé 
SetIntLE
éé %
(
éé% &
byte
éé& *
[
éé* +
]
éé+ ,
memory
éé- 3
,
éé3 4
int
éé5 8
index
éé9 >
,
éé> ?
int
éé@ C
value
ééD I
)
ééI J
{
èè 	
	unchecked
êê 
{
ëë 
uint
íí 
unsignedValue
íí "
=
íí# $
(
íí% &
uint
íí& *
)
íí* +
value
íí+ 0
;
íí0 1
memory
ìì 
[
ìì 
index
ìì 
]
ìì 
=
ìì 
(
ìì  !
byte
ìì! %
)
ìì% &
unsignedValue
ìì& 3
;
ìì3 4
memory
îî 
[
îî 
index
îî 
+
îî 
$num
îî  
]
îî  !
=
îî" #
(
îî$ %
byte
îî% )
)
îî) *
(
îî* +
unsignedValue
îî+ 8
>>
îî9 ;
$num
îî< =
)
îî= >
;
îî> ?
memory
ïï 
[
ïï 
index
ïï 
+
ïï 
$num
ïï  
]
ïï  !
=
ïï" #
(
ïï$ %
byte
ïï% )
)
ïï) *
(
ïï* +
unsignedValue
ïï+ 8
>>
ïï9 ;
$num
ïï< >
)
ïï> ?
;
ïï? @
memory
ññ 
[
ññ 
index
ññ 
+
ññ 
$num
ññ  
]
ññ  !
=
ññ" #
(
ññ$ %
byte
ññ% )
)
ññ) *
(
ññ* +
unsignedValue
ññ+ 8
>>
ññ9 ;
$num
ññ< >
)
ññ> ?
;
ññ? @
}
óó 
}
òò 	
[
öö 	

MethodImpl
öö	 
(
öö 
MethodImplOptions
öö %
.
öö% & 
AggressiveInlining
öö& 8
)
öö8 9
]
öö9 :
internal
õõ 
static
õõ 
void
õõ 
SetLong
õõ $
(
õõ$ %
byte
õõ% )
[
õõ) *
]
õõ* +
memory
õõ, 2
,
õõ2 3
int
õõ4 7
index
õõ8 =
,
õõ= >
long
õõ? C
value
õõD I
)
õõI J
{
úú 	
	unchecked
ùù 
{
ûû 
ulong
üü 
unsignedValue
üü #
=
üü$ %
(
üü& '
ulong
üü' ,
)
üü, -
value
üü- 2
;
üü2 3
memory
†† 
[
†† 
index
†† 
]
†† 
=
†† 
(
††  !
byte
††! %
)
††% &
(
††& '
unsignedValue
††' 4
>>
††5 7
$num
††8 :
)
††: ;
;
††; <
memory
°° 
[
°° 
index
°° 
+
°° 
$num
°°  
]
°°  !
=
°°" #
(
°°$ %
byte
°°% )
)
°°) *
(
°°* +
unsignedValue
°°+ 8
>>
°°9 ;
$num
°°< >
)
°°> ?
;
°°? @
memory
¢¢ 
[
¢¢ 
index
¢¢ 
+
¢¢ 
$num
¢¢  
]
¢¢  !
=
¢¢" #
(
¢¢$ %
byte
¢¢% )
)
¢¢) *
(
¢¢* +
unsignedValue
¢¢+ 8
>>
¢¢9 ;
$num
¢¢< >
)
¢¢> ?
;
¢¢? @
memory
££ 
[
££ 
index
££ 
+
££ 
$num
££  
]
££  !
=
££" #
(
££$ %
byte
££% )
)
££) *
(
££* +
unsignedValue
££+ 8
>>
££9 ;
$num
££< >
)
££> ?
;
££? @
memory
§§ 
[
§§ 
index
§§ 
+
§§ 
$num
§§  
]
§§  !
=
§§" #
(
§§$ %
byte
§§% )
)
§§) *
(
§§* +
unsignedValue
§§+ 8
>>
§§9 ;
$num
§§< >
)
§§> ?
;
§§? @
memory
•• 
[
•• 
index
•• 
+
•• 
$num
••  
]
••  !
=
••" #
(
••$ %
byte
••% )
)
••) *
(
••* +
unsignedValue
••+ 8
>>
••9 ;
$num
••< >
)
••> ?
;
••? @
memory
¶¶ 
[
¶¶ 
index
¶¶ 
+
¶¶ 
$num
¶¶  
]
¶¶  !
=
¶¶" #
(
¶¶$ %
byte
¶¶% )
)
¶¶) *
(
¶¶* +
unsignedValue
¶¶+ 8
>>
¶¶9 ;
$num
¶¶< =
)
¶¶= >
;
¶¶> ?
memory
ßß 
[
ßß 
index
ßß 
+
ßß 
$num
ßß  
]
ßß  !
=
ßß" #
(
ßß$ %
byte
ßß% )
)
ßß) *
unsignedValue
ßß* 7
;
ßß7 8
}
®® 
}
©© 	
[
´´ 	

MethodImpl
´´	 
(
´´ 
MethodImplOptions
´´ %
.
´´% & 
AggressiveInlining
´´& 8
)
´´8 9
]
´´9 :
internal
¨¨ 
static
¨¨ 
void
¨¨ 
	SetLongLE
¨¨ &
(
¨¨& '
byte
¨¨' +
[
¨¨+ ,
]
¨¨, -
memory
¨¨. 4
,
¨¨4 5
int
¨¨6 9
index
¨¨: ?
,
¨¨? @
long
¨¨A E
value
¨¨F K
)
¨¨K L
{
≠≠ 	
	unchecked
ÆÆ 
{
ØØ 
ulong
∞∞ 
unsignedValue
∞∞ #
=
∞∞$ %
(
∞∞& '
ulong
∞∞' ,
)
∞∞, -
value
∞∞- 2
;
∞∞2 3
memory
±± 
[
±± 
index
±± 
]
±± 
=
±± 
(
±±  !
byte
±±! %
)
±±% &
unsignedValue
±±& 3
;
±±3 4
memory
≤≤ 
[
≤≤ 
index
≤≤ 
+
≤≤ 
$num
≤≤  
]
≤≤  !
=
≤≤" #
(
≤≤$ %
byte
≤≤% )
)
≤≤) *
(
≤≤* +
unsignedValue
≤≤+ 8
>>
≤≤9 ;
$num
≤≤< =
)
≤≤= >
;
≤≤> ?
memory
≥≥ 
[
≥≥ 
index
≥≥ 
+
≥≥ 
$num
≥≥  
]
≥≥  !
=
≥≥" #
(
≥≥$ %
byte
≥≥% )
)
≥≥) *
(
≥≥* +
unsignedValue
≥≥+ 8
>>
≥≥9 ;
$num
≥≥< >
)
≥≥> ?
;
≥≥? @
memory
¥¥ 
[
¥¥ 
index
¥¥ 
+
¥¥ 
$num
¥¥  
]
¥¥  !
=
¥¥" #
(
¥¥$ %
byte
¥¥% )
)
¥¥) *
(
¥¥* +
unsignedValue
¥¥+ 8
>>
¥¥9 ;
$num
¥¥< >
)
¥¥> ?
;
¥¥? @
memory
µµ 
[
µµ 
index
µµ 
+
µµ 
$num
µµ  
]
µµ  !
=
µµ" #
(
µµ$ %
byte
µµ% )
)
µµ) *
(
µµ* +
unsignedValue
µµ+ 8
>>
µµ9 ;
$num
µµ< >
)
µµ> ?
;
µµ? @
memory
∂∂ 
[
∂∂ 
index
∂∂ 
+
∂∂ 
$num
∂∂  
]
∂∂  !
=
∂∂" #
(
∂∂$ %
byte
∂∂% )
)
∂∂) *
(
∂∂* +
unsignedValue
∂∂+ 8
>>
∂∂9 ;
$num
∂∂< >
)
∂∂> ?
;
∂∂? @
memory
∑∑ 
[
∑∑ 
index
∑∑ 
+
∑∑ 
$num
∑∑  
]
∑∑  !
=
∑∑" #
(
∑∑$ %
byte
∑∑% )
)
∑∑) *
(
∑∑* +
unsignedValue
∑∑+ 8
>>
∑∑9 ;
$num
∑∑< >
)
∑∑> ?
;
∑∑? @
memory
∏∏ 
[
∏∏ 
index
∏∏ 
+
∏∏ 
$num
∏∏  
]
∏∏  !
=
∏∏" #
(
∏∏$ %
byte
∏∏% )
)
∏∏) *
(
∏∏* +
unsignedValue
∏∏+ 8
>>
∏∏9 ;
$num
∏∏< >
)
∏∏> ?
;
∏∏? @
}
ππ 
}
∫∫ 	
}
ªª 
}ºº êÂ
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IByteBuffer  
:! "
IReferenceCounted# 4
,4 5
IComparable6 A
<A B
IByteBufferB M
>M N
,N O

IEquatableP Z
<Z [
IByteBuffer[ f
>f g
{ 
int 
Capacity 
{ 
get 
; 
} 
IByteBuffer 
AdjustCapacity "
(" #
int# &
newCapacity' 2
)2 3
;3 4
int 
MaxCapacity 
{ 
get 
; 
}   
IByteBufferAllocator$$ 
	Allocator$$ &
{$$' (
get$$) ,
;$$, -
}$$. /
bool&& 
IsDirect&& 
{&& 
get&& 
;&& 
}&& 
int(( 
ReaderIndex(( 
{(( 
get(( 
;(( 
}((  
int** 
WriterIndex** 
{** 
get** 
;** 
}**  
IByteBuffer00 
SetWriterIndex00 "
(00" #
int00# &
writerIndex00' 2
)002 3
;003 4
IByteBuffer99 
SetReaderIndex99 "
(99" #
int99# &
readerIndex99' 2
)992 3
;993 4
IByteBufferBB 
SetIndexBB 
(BB 
intBB  
readerIndexBB! ,
,BB, -
intBB. 1
writerIndexBB2 =
)BB= >
;BB> ?
intDD 
ReadableBytesDD 
{DD 
getDD 
;DD  
}DD! "
intFF 
WritableBytesFF 
{FF 
getFF 
;FF  
}FF! "
intHH 
MaxWritableBytesHH 
{HH 
getHH "
;HH" #
}HH$ %
boolMM 

IsReadableMM 
(MM 
)MM 
;MM 
boolSS 

IsReadableSS 
(SS 
intSS 
sizeSS  
)SS  !
;SS! "
boolXX 

IsWritableXX 
(XX 
)XX 
;XX 
bool__ 

IsWritable__ 
(__ 
int__ 
size__  
)__  !
;__! "
IByteBufferff 
Clearff 
(ff 
)ff 
;ff 
IByteBuffernn 
MarkReaderIndexnn #
(nn# $
)nn$ %
;nn% &
IByteBufferww 
ResetReaderIndexww $
(ww$ %
)ww% &
;ww& '
IByteBuffer 
MarkWriterIndex #
(# $
)$ %
;% &
IByteBuffer
àà 
ResetWriterIndex
àà $
(
àà$ %
)
àà% &
;
àà& '
IByteBuffer
êê 
DiscardReadBytes
êê $
(
êê$ %
)
êê% &
;
êê& '
IByteBuffer
òò "
DiscardSomeReadBytes
òò (
(
òò( )
)
òò) *
;
òò* +
IByteBuffer
§§ 
EnsureWritable
§§ "
(
§§" #
int
§§# &
minWritableBytes
§§' 7
)
§§7 8
;
§§8 9
int
ππ 
EnsureWritable
ππ 
(
ππ 
int
ππ 
minWritableBytes
ππ /
,
ππ/ 0
bool
ππ1 5
force
ππ6 ;
)
ππ; <
;
ππ< =
bool
ƒƒ 

GetBoolean
ƒƒ 
(
ƒƒ 
int
ƒƒ 
index
ƒƒ !
)
ƒƒ! "
;
ƒƒ" #
byte
œœ 
GetByte
œœ 
(
œœ 
int
œœ 
index
œœ 
)
œœ 
;
œœ  
short
⁄⁄ 
GetShort
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
index
⁄⁄  
)
⁄⁄  !
;
⁄⁄! "
short
ÂÂ 

GetShortLE
ÂÂ 
(
ÂÂ 
int
ÂÂ 
index
ÂÂ "
)
ÂÂ" #
;
ÂÂ# $
ushort
 
GetUnsignedShort
 
(
  
int
  #
index
$ )
)
) *
;
* +
ushort
˚˚  
GetUnsignedShortLE
˚˚ !
(
˚˚! "
int
˚˚" %
index
˚˚& +
)
˚˚+ ,
;
˚˚, -
int
ÜÜ 
GetInt
ÜÜ 
(
ÜÜ 
int
ÜÜ 
index
ÜÜ 
)
ÜÜ 
;
ÜÜ 
int
ëë 
GetIntLE
ëë 
(
ëë 
int
ëë 
index
ëë 
)
ëë 
;
ëë  
uint
úú 
GetUnsignedInt
úú 
(
úú 
int
úú 
index
úú  %
)
úú% &
;
úú& '
uint
ßß 
GetUnsignedIntLE
ßß 
(
ßß 
int
ßß !
index
ßß" '
)
ßß' (
;
ßß( )
long
≤≤ 
GetLong
≤≤ 
(
≤≤ 
int
≤≤ 
index
≤≤ 
)
≤≤ 
;
≤≤  
long
ΩΩ 
	GetLongLE
ΩΩ 
(
ΩΩ 
int
ΩΩ 
index
ΩΩ  
)
ΩΩ  !
;
ΩΩ! "
int
»» 
	GetMedium
»» 
(
»» 
int
»» 
index
»» 
)
»»  
;
»»  !
int
”” 
GetMediumLE
”” 
(
”” 
int
”” 
index
”” !
)
””! "
;
””" #
int
ﬁﬁ 
GetUnsignedMedium
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ !
index
ﬁﬁ" '
)
ﬁﬁ' (
;
ﬁﬁ( )
int
ÈÈ !
GetUnsignedMediumLE
ÈÈ 
(
ÈÈ  
int
ÈÈ  #
index
ÈÈ$ )
)
ÈÈ) *
;
ÈÈ* +
char
ÙÙ 
GetChar
ÙÙ 
(
ÙÙ 
int
ÙÙ 
index
ÙÙ 
)
ÙÙ 
;
ÙÙ  
float
ˇˇ 
GetFloat
ˇˇ 
(
ˇˇ 
int
ˇˇ 
index
ˇˇ  
)
ˇˇ  !
;
ˇˇ! "
float
ää 

GetFloatLE
ää 
(
ää 
int
ää 
index
ää "
)
ää" #
;
ää# $
double
ïï 
	GetDouble
ïï 
(
ïï 
int
ïï 
index
ïï "
)
ïï" #
;
ïï# $
double
†† 
GetDoubleLE
†† 
(
†† 
int
†† 
index
†† $
)
††$ %
;
††% &
IByteBuffer
™™ 
GetBytes
™™ 
(
™™ 
int
™™  
index
™™! &
,
™™& '
IByteBuffer
™™( 3
destination
™™4 ?
)
™™? @
;
™™@ A
IByteBuffer
¥¥ 
GetBytes
¥¥ 
(
¥¥ 
int
¥¥  
index
¥¥! &
,
¥¥& '
IByteBuffer
¥¥( 3
destination
¥¥4 ?
,
¥¥? @
int
¥¥A D
length
¥¥E K
)
¥¥K L
;
¥¥L M
IByteBuffer
ææ 
GetBytes
ææ 
(
ææ 
int
ææ  
index
ææ! &
,
ææ& '
IByteBuffer
ææ( 3
destination
ææ4 ?
,
ææ? @
int
ææA D
dstIndex
ææE M
,
ææM N
int
ææO R
length
ææS Y
)
ææY Z
;
ææZ [
IByteBuffer
»» 
GetBytes
»» 
(
»» 
int
»»  
index
»»! &
,
»»& '
byte
»»( ,
[
»», -
]
»»- .
destination
»»/ :
)
»»: ;
;
»»; <
IByteBuffer
““ 
GetBytes
““ 
(
““ 
int
““  
index
““! &
,
““& '
byte
““( ,
[
““, -
]
““- .
destination
““/ :
,
““: ;
int
““< ?
dstIndex
““@ H
,
““H I
int
““J M
length
““N T
)
““T U
;
““U V
IByteBuffer
‰‰ 
GetBytes
‰‰ 
(
‰‰ 
int
‰‰  
index
‰‰! &
,
‰‰& '
Stream
‰‰( .
destination
‰‰/ :
,
‰‰: ;
int
‰‰< ?
length
‰‰@ F
)
‰‰F G
;
‰‰G H
ICharSequence
ÁÁ 
GetCharSequence
ÁÁ %
(
ÁÁ% &
int
ÁÁ& )
index
ÁÁ* /
,
ÁÁ/ 0
int
ÁÁ1 4
length
ÁÁ5 ;
,
ÁÁ; <
Encoding
ÁÁ= E
encoding
ÁÁF N
)
ÁÁN O
;
ÁÁO P
string
ÛÛ 
	GetString
ÛÛ 
(
ÛÛ 
int
ÛÛ 
index
ÛÛ "
,
ÛÛ" #
int
ÛÛ$ '
length
ÛÛ( .
,
ÛÛ. /
Encoding
ÛÛ0 8
encoding
ÛÛ9 A
)
ÛÛA B
;
ÛÛB C
IByteBuffer
˝˝ 

SetBoolean
˝˝ 
(
˝˝ 
int
˝˝ "
index
˝˝# (
,
˝˝( )
bool
˝˝* .
value
˝˝/ 4
)
˝˝4 5
;
˝˝5 6
IByteBuffer
áá 
SetByte
áá 
(
áá 
int
áá 
index
áá  %
,
áá% &
int
áá' *
value
áá+ 0
)
áá0 1
;
áá1 2
IByteBuffer
ëë 
SetShort
ëë 
(
ëë 
int
ëë  
index
ëë! &
,
ëë& '
int
ëë( +
value
ëë, 1
)
ëë1 2
;
ëë2 3
IByteBuffer
úú 

SetShortLE
úú 
(
úú 
int
úú "
index
úú# (
,
úú( )
int
úú* -
value
úú. 3
)
úú3 4
;
úú4 5
IByteBuffer
¶¶ 
SetUnsignedShort
¶¶ $
(
¶¶$ %
int
¶¶% (
index
¶¶) .
,
¶¶. /
ushort
¶¶0 6
value
¶¶7 <
)
¶¶< =
;
¶¶= >
IByteBuffer
±±  
SetUnsignedShortLE
±± &
(
±±& '
int
±±' *
index
±±+ 0
,
±±0 1
ushort
±±2 8
value
±±9 >
)
±±> ?
;
±±? @
IByteBuffer
ªª 
SetInt
ªª 
(
ªª 
int
ªª 
index
ªª $
,
ªª$ %
int
ªª& )
value
ªª* /
)
ªª/ 0
;
ªª0 1
IByteBuffer
∆∆ 
SetIntLE
∆∆ 
(
∆∆ 
int
∆∆  
index
∆∆! &
,
∆∆& '
int
∆∆( +
value
∆∆, 1
)
∆∆1 2
;
∆∆2 3
IByteBuffer
–– 
SetUnsignedInt
–– "
(
––" #
int
––# &
index
––' ,
,
––, -
uint
––. 2
value
––3 8
)
––8 9
;
––9 :
IByteBuffer
€€ 
SetUnsignedIntLE
€€ $
(
€€$ %
int
€€% (
index
€€) .
,
€€. /
uint
€€0 4
value
€€5 :
)
€€: ;
;
€€; <
IByteBuffer
ÊÊ 
	SetMedium
ÊÊ 
(
ÊÊ 
int
ÊÊ !
index
ÊÊ" '
,
ÊÊ' (
int
ÊÊ) ,
value
ÊÊ- 2
)
ÊÊ2 3
;
ÊÊ3 4
IByteBuffer
ÒÒ 
SetMediumLE
ÒÒ 
(
ÒÒ  
int
ÒÒ  #
index
ÒÒ$ )
,
ÒÒ) *
int
ÒÒ+ .
value
ÒÒ/ 4
)
ÒÒ4 5
;
ÒÒ5 6
IByteBuffer
˚˚ 
SetLong
˚˚ 
(
˚˚ 
int
˚˚ 
index
˚˚  %
,
˚˚% &
long
˚˚' +
value
˚˚, 1
)
˚˚1 2
;
˚˚2 3
IByteBuffer
ÜÜ 
	SetLongLE
ÜÜ 
(
ÜÜ 
int
ÜÜ !
index
ÜÜ" '
,
ÜÜ' (
long
ÜÜ) -
value
ÜÜ. 3
)
ÜÜ3 4
;
ÜÜ4 5
IByteBuffer
êê 
SetChar
êê 
(
êê 
int
êê 
index
êê  %
,
êê% &
char
êê' +
value
êê, 1
)
êê1 2
;
êê2 3
IByteBuffer
öö 
	SetDouble
öö 
(
öö 
int
öö !
index
öö" '
,
öö' (
double
öö) /
value
öö0 5
)
öö5 6
;
öö6 7
IByteBuffer
§§ 
SetFloat
§§ 
(
§§ 
int
§§  
index
§§! &
,
§§& '
float
§§( -
value
§§. 3
)
§§3 4
;
§§4 5
IByteBuffer
ØØ 
SetDoubleLE
ØØ 
(
ØØ  
int
ØØ  #
index
ØØ$ )
,
ØØ) *
double
ØØ+ 1
value
ØØ2 7
)
ØØ7 8
;
ØØ8 9
IByteBuffer
∫∫ 

SetFloatLE
∫∫ 
(
∫∫ 
int
∫∫ "
index
∫∫# (
,
∫∫( )
float
∫∫* /
value
∫∫0 5
)
∫∫5 6
;
∫∫6 7
IByteBuffer
ƒƒ 
SetBytes
ƒƒ 
(
ƒƒ 
int
ƒƒ  
index
ƒƒ! &
,
ƒƒ& '
IByteBuffer
ƒƒ( 3
src
ƒƒ4 7
)
ƒƒ7 8
;
ƒƒ8 9
IByteBuffer
œœ 
SetBytes
œœ 
(
œœ 
int
œœ  
index
œœ! &
,
œœ& '
IByteBuffer
œœ( 3
src
œœ4 7
,
œœ7 8
int
œœ9 <
length
œœ= C
)
œœC D
;
œœD E
IByteBuffer
‹‹ 
SetBytes
‹‹ 
(
‹‹ 
int
‹‹  
index
‹‹! &
,
‹‹& '
IByteBuffer
‹‹( 3
src
‹‹4 7
,
‹‹7 8
int
‹‹9 <
srcIndex
‹‹= E
,
‹‹E F
int
‹‹G J
length
‹‹K Q
)
‹‹Q R
;
‹‹R S
IByteBuffer
ÊÊ 
SetBytes
ÊÊ 
(
ÊÊ 
int
ÊÊ  
index
ÊÊ! &
,
ÊÊ& '
byte
ÊÊ( ,
[
ÊÊ, -
]
ÊÊ- .
src
ÊÊ/ 2
)
ÊÊ2 3
;
ÊÊ3 4
IByteBuffer
ÛÛ 
SetBytes
ÛÛ 
(
ÛÛ 
int
ÛÛ  
index
ÛÛ! &
,
ÛÛ& '
byte
ÛÛ( ,
[
ÛÛ, -
]
ÛÛ- .
src
ÛÛ/ 2
,
ÛÛ2 3
int
ÛÛ4 7
srcIndex
ÛÛ8 @
,
ÛÛ@ A
int
ÛÛB E
length
ÛÛF L
)
ÛÛL M
;
ÛÛM N
Task
ÑÑ 
<
ÑÑ 
int
ÑÑ 
>
ÑÑ 
SetBytesAsync
ÑÑ 
(
ÑÑ  
int
ÑÑ  #
index
ÑÑ$ )
,
ÑÑ) *
Stream
ÑÑ+ 1
src
ÑÑ2 5
,
ÑÑ5 6
int
ÑÑ7 :
length
ÑÑ; A
,
ÑÑA B
CancellationToken
ÑÑC T
cancellationToken
ÑÑU f
)
ÑÑf g
;
ÑÑg h
IByteBuffer
ëë 
SetZero
ëë 
(
ëë 
int
ëë 
index
ëë  %
,
ëë% &
int
ëë' *
length
ëë+ 1
)
ëë1 2
;
ëë2 3
int
ìì 
SetCharSequence
ìì 
(
ìì 
int
ìì 
index
ìì  %
,
ìì% &
ICharSequence
ìì' 4
sequence
ìì5 =
,
ìì= >
Encoding
ìì? G
encoding
ììH P
)
ììP Q
;
ììQ R
int
†† 
	SetString
†† 
(
†† 
int
†† 
index
†† 
,
††  
string
††! '
value
††( -
,
††- .
Encoding
††/ 7
encoding
††8 @
)
††@ A
;
††A B
bool
ßß 
ReadBoolean
ßß 
(
ßß 
)
ßß 
;
ßß 
byte
ÆÆ 
ReadByte
ÆÆ 
(
ÆÆ 
)
ÆÆ 
;
ÆÆ 
short
µµ 
	ReadShort
µµ 
(
µµ 
)
µµ 
;
µµ 
short
ºº 
ReadShortLE
ºº 
(
ºº 
)
ºº 
;
ºº 
int
√√ 

ReadMedium
√√ 
(
√√ 
)
√√ 
;
√√ 
int
   
ReadMediumLE
   
(
   
)
   
;
   
int
——  
ReadUnsignedMedium
—— 
(
—— 
)
——  
;
——  !
int
ÿÿ "
ReadUnsignedMediumLE
ÿÿ  
(
ÿÿ  !
)
ÿÿ! "
;
ÿÿ" #
ushort
ﬂﬂ 
ReadUnsignedShort
ﬂﬂ  
(
ﬂﬂ  !
)
ﬂﬂ! "
;
ﬂﬂ" #
ushort
ÊÊ !
ReadUnsignedShortLE
ÊÊ "
(
ÊÊ" #
)
ÊÊ# $
;
ÊÊ$ %
int
ÌÌ 
ReadInt
ÌÌ 
(
ÌÌ 
)
ÌÌ 
;
ÌÌ 
int
ÙÙ 
	ReadIntLE
ÙÙ 
(
ÙÙ 
)
ÙÙ 
;
ÙÙ 
uint
˚˚ 
ReadUnsignedInt
˚˚ 
(
˚˚ 
)
˚˚ 
;
˚˚ 
uint
ÇÇ 
ReadUnsignedIntLE
ÇÇ 
(
ÇÇ 
)
ÇÇ  
;
ÇÇ  !
long
ââ 
ReadLong
ââ 
(
ââ 
)
ââ 
;
ââ 
long
êê 

ReadLongLE
êê 
(
êê 
)
êê 
;
êê 
char
òò 
ReadChar
òò 
(
òò 
)
òò 
;
òò 
double
†† 

ReadDouble
†† 
(
†† 
)
†† 
;
†† 
double
ßß 
ReadDoubleLE
ßß 
(
ßß 
)
ßß 
;
ßß 
float
ØØ 
	ReadFloat
ØØ 
(
ØØ 
)
ØØ 
;
ØØ 
float
∂∂ 
ReadFloatLE
∂∂ 
(
∂∂ 
)
∂∂ 
;
∂∂ 
IByteBuffer
ææ 
	ReadBytes
ææ 
(
ææ 
int
ææ !
length
ææ" (
)
ææ( )
;
ææ) *
IByteBuffer
…… 
	ReadBytes
…… 
(
…… 
IByteBuffer
…… )
destination
……* 5
)
……5 6
;
……6 7
IByteBuffer
ÀÀ 
	ReadBytes
ÀÀ 
(
ÀÀ 
IByteBuffer
ÀÀ )
destination
ÀÀ* 5
,
ÀÀ5 6
int
ÀÀ7 :
length
ÀÀ; A
)
ÀÀA B
;
ÀÀB C
IByteBuffer
ÕÕ 
	ReadBytes
ÕÕ 
(
ÕÕ 
IByteBuffer
ÕÕ )
destination
ÕÕ* 5
,
ÕÕ5 6
int
ÕÕ7 :
dstIndex
ÕÕ; C
,
ÕÕC D
int
ÕÕE H
length
ÕÕI O
)
ÕÕO P
;
ÕÕP Q
IByteBuffer
œœ 
	ReadBytes
œœ 
(
œœ 
byte
œœ "
[
œœ" #
]
œœ# $
destination
œœ% 0
)
œœ0 1
;
œœ1 2
IByteBuffer
—— 
	ReadBytes
—— 
(
—— 
byte
—— "
[
——" #
]
——# $
destination
——% 0
,
——0 1
int
——2 5
dstIndex
——6 >
,
——> ?
int
——@ C
length
——D J
)
——J K
;
——K L
IByteBuffer
”” 
	ReadBytes
”” 
(
”” 
Stream
”” $
destination
””% 0
,
””0 1
int
””2 5
length
””6 <
)
””< =
;
””= >
ICharSequence
’’ 
ReadCharSequence
’’ &
(
’’& '
int
’’' *
length
’’+ 1
,
’’1 2
Encoding
’’3 ;
encoding
’’< D
)
’’D E
;
’’E F
string
ﬁﬁ 

ReadString
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
length
ﬁﬁ $
,
ﬁﬁ$ %
Encoding
ﬁﬁ& .
encoding
ﬁﬁ/ 7
)
ﬁﬁ7 8
;
ﬁﬁ8 9
IByteBuffer
‰‰ 
	SkipBytes
‰‰ 
(
‰‰ 
int
‰‰ !
length
‰‰" (
)
‰‰( )
;
‰‰) *
IByteBuffer
ÊÊ 
WriteBoolean
ÊÊ  
(
ÊÊ  !
bool
ÊÊ! %
value
ÊÊ& +
)
ÊÊ+ ,
;
ÊÊ, -
IByteBuffer
ËË 
	WriteByte
ËË 
(
ËË 
int
ËË !
value
ËË" '
)
ËË' (
;
ËË( )
IByteBuffer
ÍÍ 

WriteShort
ÍÍ 
(
ÍÍ 
int
ÍÍ "
value
ÍÍ# (
)
ÍÍ( )
;
ÍÍ) *
IByteBuffer
ÏÏ 
WriteShortLE
ÏÏ  
(
ÏÏ  !
int
ÏÏ! $
value
ÏÏ% *
)
ÏÏ* +
;
ÏÏ+ ,
IByteBuffer
ÓÓ  
WriteUnsignedShort
ÓÓ &
(
ÓÓ& '
ushort
ÓÓ' -
value
ÓÓ. 3
)
ÓÓ3 4
;
ÓÓ4 5
IByteBuffer
 "
WriteUnsignedShortLE
 (
(
( )
ushort
) /
value
0 5
)
5 6
;
6 7
IByteBuffer
ÚÚ 
WriteMedium
ÚÚ 
(
ÚÚ  
int
ÚÚ  #
value
ÚÚ$ )
)
ÚÚ) *
;
ÚÚ* +
IByteBuffer
ÙÙ 
WriteMediumLE
ÙÙ !
(
ÙÙ! "
int
ÙÙ" %
value
ÙÙ& +
)
ÙÙ+ ,
;
ÙÙ, -
IByteBuffer
ˆˆ 
WriteInt
ˆˆ 
(
ˆˆ 
int
ˆˆ  
value
ˆˆ! &
)
ˆˆ& '
;
ˆˆ' (
IByteBuffer
¯¯ 

WriteIntLE
¯¯ 
(
¯¯ 
int
¯¯ "
value
¯¯# (
)
¯¯( )
;
¯¯) *
IByteBuffer
˙˙ 
	WriteLong
˙˙ 
(
˙˙ 
long
˙˙ "
value
˙˙# (
)
˙˙( )
;
˙˙) *
IByteBuffer
¸¸ 
WriteLongLE
¸¸ 
(
¸¸  
long
¸¸  $
value
¸¸% *
)
¸¸* +
;
¸¸+ ,
IByteBuffer
˛˛ 
	WriteChar
˛˛ 
(
˛˛ 
char
˛˛ "
value
˛˛# (
)
˛˛( )
;
˛˛) *
IByteBuffer
ÄÄ 
WriteDouble
ÄÄ 
(
ÄÄ  
double
ÄÄ  &
value
ÄÄ' ,
)
ÄÄ, -
;
ÄÄ- .
IByteBuffer
ÇÇ 
WriteDoubleLE
ÇÇ !
(
ÇÇ! "
double
ÇÇ" (
value
ÇÇ) .
)
ÇÇ. /
;
ÇÇ/ 0
IByteBuffer
ÑÑ 

WriteFloat
ÑÑ 
(
ÑÑ 
float
ÑÑ $
value
ÑÑ% *
)
ÑÑ* +
;
ÑÑ+ ,
IByteBuffer
ÜÜ 
WriteFloatLE
ÜÜ  
(
ÜÜ  !
float
ÜÜ! &
value
ÜÜ' ,
)
ÜÜ, -
;
ÜÜ- .
IByteBuffer
àà 

WriteBytes
àà 
(
àà 
IByteBuffer
àà *
src
àà+ .
)
àà. /
;
àà/ 0
IByteBuffer
ää 

WriteBytes
ää 
(
ää 
IByteBuffer
ää *
src
ää+ .
,
ää. /
int
ää0 3
length
ää4 :
)
ää: ;
;
ää; <
IByteBuffer
åå 

WriteBytes
åå 
(
åå 
IByteBuffer
åå *
src
åå+ .
,
åå. /
int
åå0 3
srcIndex
åå4 <
,
åå< =
int
åå> A
length
ååB H
)
ååH I
;
ååI J
IByteBuffer
éé 

WriteBytes
éé 
(
éé 
byte
éé #
[
éé# $
]
éé$ %
src
éé& )
)
éé) *
;
éé* +
IByteBuffer
êê 

WriteBytes
êê 
(
êê 
byte
êê #
[
êê# $
]
êê$ %
src
êê& )
,
êê) *
int
êê+ .
srcIndex
êê/ 7
,
êê7 8
int
êê9 <
length
êê= C
)
êêC D
;
êêD E
int
°° 
IoBufferCount
°° 
{
°° 
get
°° 
;
°°  
}
°°! "
ArraySegment
≤≤ 
<
≤≤ 
byte
≤≤ 
>
≤≤ 
GetIoBuffer
≤≤ &
(
≤≤& '
)
≤≤' (
;
≤≤( )
ArraySegment
¬¬ 
<
¬¬ 
byte
¬¬ 
>
¬¬ 
GetIoBuffer
¬¬ &
(
¬¬& '
int
¬¬' *
index
¬¬+ 0
,
¬¬0 1
int
¬¬2 5
length
¬¬6 <
)
¬¬< =
;
¬¬= >
ArraySegment
”” 
<
”” 
byte
”” 
>
”” 
[
”” 
]
”” 
GetIoBuffers
”” )
(
””) *
)
””* +
;
””+ ,
ArraySegment
‰‰ 
<
‰‰ 
byte
‰‰ 
>
‰‰ 
[
‰‰ 
]
‰‰ 
GetIoBuffers
‰‰ )
(
‰‰) *
int
‰‰* -
index
‰‰. 3
,
‰‰3 4
int
‰‰5 8
length
‰‰9 ?
)
‰‰? @
;
‰‰@ A
bool
ÈÈ 
HasArray
ÈÈ 
{
ÈÈ 
get
ÈÈ 
;
ÈÈ 
}
ÈÈ 
byte
ÓÓ 
[
ÓÓ 
]
ÓÓ 
Array
ÓÓ 
{
ÓÓ 
get
ÓÓ 
;
ÓÓ 
}
ÓÓ 
bool
ÙÙ 
HasMemoryAddress
ÙÙ 
{
ÙÙ 
get
ÙÙ  #
;
ÙÙ# $
}
ÙÙ% &
ref
˙˙ 
byte
˙˙ &
GetPinnableMemoryAddress
˙˙ )
(
˙˙) *
)
˙˙* +
;
˙˙+ ,
IntPtr
Ä	Ä	 #
AddressOfPinnedMemory
Ä	Ä	 $
(
Ä	Ä	$ %
)
Ä	Ä	% &
;
Ä	Ä	& '
IByteBuffer
Ö	Ö	 
	Duplicate
Ö	Ö	 
(
Ö	Ö	 
)
Ö	Ö	 
;
Ö	Ö	  
IByteBuffer
á	á	 
RetainedDuplicate
á	á	 %
(
á	á	% &
)
á	á	& '
;
á	á	' (
IByteBuffer
å	å	 
Unwrap
å	å	 
(
å	å	 
)
å	å	 
;
å	å	 
IByteBuffer
î	î	 
Copy
î	î	 
(
î	î	 
)
î	î	 
;
î	î	 
IByteBuffer
ñ	ñ	 
Copy
ñ	ñ	 
(
ñ	ñ	 
int
ñ	ñ	 
index
ñ	ñ	 "
,
ñ	ñ	" #
int
ñ	ñ	$ '
length
ñ	ñ	( .
)
ñ	ñ	. /
;
ñ	ñ	/ 0
IByteBuffer
ò	ò	 
Slice
ò	ò	 
(
ò	ò	 
)
ò	ò	 
;
ò	ò	 
IByteBuffer
ö	ö	 
RetainedSlice
ö	ö	 !
(
ö	ö	! "
)
ö	ö	" #
;
ö	ö	# $
IByteBuffer
ú	ú	 
Slice
ú	ú	 
(
ú	ú	 
int
ú	ú	 
index
ú	ú	 #
,
ú	ú	# $
int
ú	ú	% (
length
ú	ú	) /
)
ú	ú	/ 0
;
ú	ú	0 1
IByteBuffer
û	û	 
RetainedSlice
û	û	 !
(
û	û	! "
int
û	û	" %
index
û	û	& +
,
û	û	+ ,
int
û	û	- 0
length
û	û	1 7
)
û	û	7 8
;
û	û	8 9
int
†	†	 
ArrayOffset
†	†	 
{
†	†	 
get
†	†	 
;
†	†	 
}
†	†	  
IByteBuffer
¢	¢	 
	ReadSlice
¢	¢	 
(
¢	¢	 
int
¢	¢	 !
length
¢	¢	" (
)
¢	¢	( )
;
¢	¢	) *
IByteBuffer
§	§	 
ReadRetainedSlice
§	§	 %
(
§	§	% &
int
§	§	& )
length
§	§	* 0
)
§	§	0 1
;
§	§	1 2
Task
¶	¶	 
WriteBytesAsync
¶	¶	 
(
¶	¶	 
Stream
¶	¶	 #
stream
¶	¶	$ *
,
¶	¶	* +
int
¶	¶	, /
length
¶	¶	0 6
)
¶	¶	6 7
;
¶	¶	7 8
Task
®	®	 
WriteBytesAsync
®	®	 
(
®	®	 
Stream
®	®	 #
stream
®	®	$ *
,
®	®	* +
int
®	®	, /
length
®	®	0 6
,
®	®	6 7
CancellationToken
®	®	8 I
cancellationToken
®	®	J [
)
®	®	[ \
;
®	®	\ ]
IByteBuffer
™	™	 
	WriteZero
™	™	 
(
™	™	 
int
™	™	 !
length
™	™	" (
)
™	™	( )
;
™	™	) *
int
¨	¨	 
WriteCharSequence
¨	¨	 
(
¨	¨	 
ICharSequence
¨	¨	 +
sequence
¨	¨	, 4
,
¨	¨	4 5
Encoding
¨	¨	6 >
encoding
¨	¨	? G
)
¨	¨	G H
;
¨	¨	H I
int
Æ	Æ	 
WriteString
Æ	Æ	 
(
Æ	Æ	 
string
Æ	Æ	 
value
Æ	Æ	 $
,
Æ	Æ	$ %
Encoding
Æ	Æ	& .
encoding
Æ	Æ	/ 7
)
Æ	Æ	7 8
;
Æ	Æ	8 9
int
∞	∞	 
IndexOf
∞	∞	 
(
∞	∞	 
int
∞	∞	 
	fromIndex
∞	∞	 !
,
∞	∞	! "
int
∞	∞	# &
toIndex
∞	∞	' .
,
∞	∞	. /
byte
∞	∞	0 4
value
∞	∞	5 :
)
∞	∞	: ;
;
∞	∞	; <
int
≤	≤	 
BytesBefore
≤	≤	 
(
≤	≤	 
byte
≤	≤	 
value
≤	≤	 "
)
≤	≤	" #
;
≤	≤	# $
int
¥	¥	 
BytesBefore
¥	¥	 
(
¥	¥	 
int
¥	¥	 
length
¥	¥	 "
,
¥	¥	" #
byte
¥	¥	$ (
value
¥	¥	) .
)
¥	¥	. /
;
¥	¥	/ 0
int
∂	∂	 
BytesBefore
∂	∂	 
(
∂	∂	 
int
∂	∂	 
index
∂	∂	 !
,
∂	∂	! "
int
∂	∂	# &
length
∂	∂	' -
,
∂	∂	- .
byte
∂	∂	/ 3
value
∂	∂	4 9
)
∂	∂	9 :
;
∂	∂	: ;
string
∏	∏	 
ToString
∏	∏	 
(
∏	∏	 
)
∏	∏	 
;
∏	∏	 
string
∫	∫	 
ToString
∫	∫	 
(
∫	∫	 
Encoding
∫	∫	  
encoding
∫	∫	! )
)
∫	∫	) *
;
∫	∫	* +
string
º	º	 
ToString
º	º	 
(
º	º	 
int
º	º	 
index
º	º	 !
,
º	º	! "
int
º	º	# &
length
º	º	' -
,
º	º	- .
Encoding
º	º	/ 7
encoding
º	º	8 @
)
º	º	@ A
;
º	º	A B
int
∆	∆	 
ForEachByte
∆	∆	 
(
∆	∆	 
IByteProcessor
∆	∆	 &
	processor
∆	∆	' 0
)
∆	∆	0 1
;
∆	∆	1 2
int
”	”	 
ForEachByte
”	”	 
(
”	”	 
int
”	”	 
index
”	”	 !
,
”	”	! "
int
”	”	# &
length
”	”	' -
,
”	”	- .
IByteProcessor
”	”	/ =
	processor
”	”	> G
)
”	”	G H
;
”	”	H I
int
›	›	 
ForEachByteDesc
›	›	 
(
›	›	 
IByteProcessor
›	›	 *
	processor
›	›	+ 4
)
›	›	4 5
;
›	›	5 6
int
Í	Í	 
ForEachByteDesc
Í	Í	 
(
Í	Í	 
int
Í	Í	 
index
Í	Í	  %
,
Í	Í	% &
int
Í	Í	' *
length
Í	Í	+ 1
,
Í	Í	1 2
IByteProcessor
Í	Í	3 A
	processor
Í	Í	B K
)
Í	Í	K L
;
Í	Í	L M
}
Î	Î	 
}Ï	Ï	 ñ
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public		 

	interface		  
IByteBufferAllocator		 )
{

 
IByteBuffer 
Buffer 
( 
) 
; 
IByteBuffer 
Buffer 
( 
int 
initialCapacity .
). /
;/ 0
IByteBuffer 
Buffer 
( 
int 
initialCapacity .
,. /
int0 3
maxCapacity4 ?
)? @
;@ A
IByteBuffer 

HeapBuffer 
( 
)  
;  !
IByteBuffer 

HeapBuffer 
( 
int "
initialCapacity# 2
)2 3
;3 4
IByteBuffer 

HeapBuffer 
( 
int "
initialCapacity# 2
,2 3
int4 7
maxCapacity8 C
)C D
;D E
IByteBuffer 
DirectBuffer  
(  !
)! "
;" #
IByteBuffer 
DirectBuffer  
(  !
int! $
initialCapacity% 4
)4 5
;5 6
IByteBuffer 
DirectBuffer  
(  !
int! $
initialCapacity% 4
,4 5
int6 9
maxCapacity: E
)E F
;F G
CompositeByteBuffer 
CompositeBuffer +
(+ ,
), -
;- .
CompositeByteBuffer 
CompositeBuffer +
(+ ,
int, /
maxComponents0 =
)= >
;> ?
CompositeByteBuffer!! 
CompositeHeapBuffer!! /
(!!/ 0
)!!0 1
;!!1 2
CompositeByteBuffer## 
CompositeHeapBuffer## /
(##/ 0
int##0 3
maxComponents##4 A
)##A B
;##B C
CompositeByteBuffer%% !
CompositeDirectBuffer%% 1
(%%1 2
)%%2 3
;%%3 4
CompositeByteBuffer'' !
CompositeDirectBuffer'' 1
(''1 2
int''2 5
maxComponents''6 C
)''C D
;''D E
bool))  
IsDirectBufferPooled)) !
{))" #
get))$ '
;))' (
}))) *
int++  
CalculateNewCapacity++  
(++  !
int++! $
minNewCapacity++% 3
,++3 4
int++5 8
maxCapacity++9 D
)++D E
;++E F
},, 
}-- £
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocatorMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface &
IByteBufferAllocatorMetric /
{ 
long 
UsedHeapMemory 
{ 
get !
;! "
}# $
long 
UsedDirectMemory 
{ 
get  #
;# $
}% &
} 
} ”
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferAllocatorMetricProvider.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface .
"IByteBufferAllocatorMetricProvider 7
{ &
IByteBufferAllocatorMetric "
Metric# )
{* +
get, /
;/ 0
}1 2
} 
} å
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IByteBufferHolder.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IByteBufferHolder &
:' (
IReferenceCounted) :
{		 
IByteBuffer 
Content 
{ 
get !
;! "
}# $
IByteBufferHolder 
Copy 
( 
)  
;  !
IByteBufferHolder 
	Duplicate #
(# $
)$ %
;% &
IByteBufferHolder 
RetainedDuplicate +
(+ ,
), -
;- .
IByteBufferHolder!! 
Replace!! !
(!!! "
IByteBuffer!!" -
content!!. 5
)!!5 6
;!!6 7
}"" 
}## ô
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolArenaMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolArenaMetric %
{		 
int 
NumThreadCaches 
{ 
get !
;! "
}# $
int 
NumTinySubpages 
{ 
get !
;! "
}# $
int 
NumSmallSubpages 
{ 
get "
;" #
}$ %
int 
NumChunkLists 
{ 
get 
;  
}! "
IReadOnlyList 
< 
IPoolSubpageMetric (
>( )
TinySubpages* 6
{7 8
get9 <
;< =
}> ?
IReadOnlyList 
< 
IPoolSubpageMetric (
>( )
SmallSubpages* 7
{8 9
get: =
;= >
}? @
IReadOnlyList 
<  
IPoolChunkListMetric *
>* +

ChunkLists, 6
{7 8
get9 <
;< =
}> ?
long   
NumAllocations   
{   
get   !
;  ! "
}  # $
long## 
NumTinyAllocations## 
{##  !
get##" %
;##% &
}##' (
long&& 
NumSmallAllocations&&  
{&&! "
get&&# &
;&&& '
}&&( )
long))  
NumNormalAllocations)) !
{))" #
get))$ '
;))' (
}))) *
long,, 
NumHugeAllocations,, 
{,,  !
get,," %
;,,% &
},,' (
long// 
NumDeallocations// 
{// 
get//  #
;//# $
}//% &
long22  
NumTinyDeallocations22 !
{22" #
get22$ '
;22' (
}22) *
long55 !
NumSmallDeallocations55 "
{55# $
get55% (
;55( )
}55* +
long88 "
NumNormalDeallocations88 #
{88$ %
get88& )
;88) *
}88+ ,
long;;  
NumHugeDeallocations;; !
{;;" #
get;;$ '
;;;' (
};;) *
long>>  
NumActiveAllocations>> !
{>>" #
get>>$ '
;>>' (
}>>) *
longAA $
NumActiveTinyAllocationsAA %
{AA& '
getAA( +
;AA+ ,
}AA- .
longDD %
NumActiveSmallAllocationsDD &
{DD' (
getDD) ,
;DD, -
}DD. /
longGG &
NumActiveNormalAllocationsGG '
{GG( )
getGG* -
;GG- .
}GG/ 0
longJJ $
NumActiveHugeAllocationsJJ %
{JJ& '
getJJ( +
;JJ+ ,
}JJ- .
longMM 
NumActiveBytesMM 
{MM 
getMM !
;MM! "
}MM# $
}NN 
}OO Î
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolChunkListMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface  
IPoolChunkListMetric )
:* +
IEnumerable, 7
<7 8
IPoolChunkMetric8 H
>H I
{		 
int 
MinUsage 
{ 
get 
; 
} 
int 
MaxUsage 
{ 
get 
; 
} 
} 
} „
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolChunkMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolChunkMetric %
{ 
int		 
Usage		 
{		 
get		 
;		 
}		 
int 
	ChunkSize 
{ 
get 
; 
} 
int 
	FreeBytes 
{ 
get 
; 
} 
} 
} ⁄
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\IPoolSubpageMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

	interface 
IPoolSubpageMetric '
{ 
int		 
MaxNumElements		 
{		 
get		  
;		  !
}		" #
int 
NumAvailable 
{ 
get 
; 
}  !
int 
ElementSize 
{ 
get 
; 
}  
int 
PageSize 
{ 
get 
; 
} 
} 
} ∞Í
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolArena.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
enum 
	SizeClass	 
{ 
Tiny 
, 
Small 
, 
Normal 
} 
abstract 
class 
	PoolArena 
< 
T 
> 
:  !
IPoolArenaMetric" 2
{ 
internal 
const 
int 
NumTinySubpagePools .
=/ 0
$num1 4
>>5 7
$num8 9
;9 :
internal 
readonly %
PooledByteBufferAllocator 3
Parent4 :
;: ;
readonly 
int 
maxOrder 
; 
internal 
readonly 
int 
PageSize &
;& '
internal   
readonly   
int   

PageShifts   (
;  ( )
internal!! 
readonly!! 
int!! 
	ChunkSize!! '
;!!' (
internal"" 
readonly"" 
int"" 
SubpageOverflowMask"" 1
;""1 2
internal## 
readonly## 
int##  
NumSmallSubpagePools## 2
;##2 3
readonly$$ 
PoolSubpage$$ 
<$$ 
T$$ 
>$$ 
[$$  
]$$  !
tinySubpagePools$$" 2
;$$2 3
readonly%% 
PoolSubpage%% 
<%% 
T%% 
>%% 
[%%  
]%%  !
smallSubpagePools%%" 3
;%%3 4
readonly'' 
PoolChunkList'' 
<'' 
T''  
>''  !
q050''" &
;''& '
readonly(( 
PoolChunkList(( 
<(( 
T((  
>((  !
q025((" &
;((& '
readonly)) 
PoolChunkList)) 
<)) 
T))  
>))  !
q000))" &
;))& '
readonly** 
PoolChunkList** 
<** 
T**  
>**  !
qInit**" '
;**' (
readonly++ 
PoolChunkList++ 
<++ 
T++  
>++  !
q075++" &
;++& '
readonly,, 
PoolChunkList,, 
<,, 
T,,  
>,,  !
q100,," &
;,,& '
readonly.. 
IReadOnlyList.. 
<..  
IPoolChunkListMetric.. 3
>..3 4
chunkListMetrics..5 E
;..E F
long11 
allocationsNormal11 
;11 
long44 
allocationsTiny44 
;44 
long66 
allocationsSmall66 
;66 
long77 
allocationsHuge77 
;77 
long88 
activeBytesHuge88 
;88 
long:: 
deallocationsTiny:: 
;:: 
long;; 
deallocationsSmall;; 
;;;  
long<< 
deallocationsNormal<<  
;<<  !
long?? 
deallocationsHuge?? 
;?? 
intBB 
numThreadCachesBB 
;BB 
	protectedGG 
	PoolArenaGG 
(GG %
PooledByteBufferAllocatorHH %
parentHH& ,
,HH, -
intII 
pageSizeII 
,II 
intJJ 
maxOrderJJ 
,JJ 
intKK 

pageShiftsKK 
,KK 
intLL 
	chunkSizeLL 
)LL 
{MM 	
thisNN 
.NN 
ParentNN 
=NN 
parentNN  
;NN  !
thisOO 
.OO 
PageSizeOO 
=OO 
pageSizeOO $
;OO$ %
thisPP 
.PP 
maxOrderPP 
=PP 
maxOrderPP $
;PP$ %
thisQQ 
.QQ 

PageShiftsQQ 
=QQ 

pageShiftsQQ (
;QQ( )
thisRR 
.RR 
	ChunkSizeRR 
=RR 
	chunkSizeRR &
;RR& '
thisSS 
.SS 
SubpageOverflowMaskSS $
=SS% &
~SS' (
(SS( )
pageSizeSS) 1
-SS2 3
$numSS4 5
)SS5 6
;SS6 7
thisTT 
.TT 
tinySubpagePoolsTT !
=TT" #
thisTT$ (
.TT( )
NewSubpagePoolArrayTT) <
(TT< =
NumTinySubpagePoolsTT= P
)TTP Q
;TTQ R
forUU 
(UU 
intUU 
iUU 
=UU 
$numUU 
;UU 
iUU 
<UU 
thisUU  $
.UU$ %
tinySubpagePoolsUU% 5
.UU5 6
LengthUU6 <
;UU< =
iUU> ?
++UU? A
)UUA B
{VV 
thisWW 
.WW 
tinySubpagePoolsWW %
[WW% &
iWW& '
]WW' (
=WW) *
thisWW+ /
.WW/ 0
NewSubpagePoolHeadWW0 B
(WWB C
pageSizeWWC K
)WWK L
;WWL M
}XX 
thisZZ 
.ZZ  
NumSmallSubpagePoolsZZ %
=ZZ& '

pageShiftsZZ( 2
-ZZ3 4
$numZZ5 6
;ZZ6 7
this[[ 
.[[ 
smallSubpagePools[[ "
=[[# $
this[[% )
.[[) *
NewSubpagePoolArray[[* =
([[= >
this[[> B
.[[B C 
NumSmallSubpagePools[[C W
)[[W X
;[[X Y
for\\ 
(\\ 
int\\ 
i\\ 
=\\ 
$num\\ 
;\\ 
i\\ 
<\\ 
this\\  $
.\\$ %
smallSubpagePools\\% 6
.\\6 7
Length\\7 =
;\\= >
i\\? @
++\\@ B
)\\B C
{]] 
this^^ 
.^^ 
smallSubpagePools^^ &
[^^& '
i^^' (
]^^( )
=^^* +
this^^, 0
.^^0 1
NewSubpagePoolHead^^1 C
(^^C D
pageSize^^D L
)^^L M
;^^M N
}__ 
thisaa 
.aa 
q100aa 
=aa 
newaa 
PoolChunkListaa )
<aa) *
Taa* +
>aa+ ,
(aa, -
thisaa- 1
,aa1 2
nullaa3 7
,aa7 8
$numaa9 <
,aa< =
intaa> A
.aaA B
MaxValueaaB J
,aaJ K
	chunkSizeaaL U
)aaU V
;aaV W
thisbb 
.bb 
q075bb 
=bb 
newbb 
PoolChunkListbb )
<bb) *
Tbb* +
>bb+ ,
(bb, -
thisbb- 1
,bb1 2
thisbb3 7
.bb7 8
q100bb8 <
,bb< =
$numbb> @
,bb@ A
$numbbB E
,bbE F
	chunkSizebbG P
)bbP Q
;bbQ R
thiscc 
.cc 
q050cc 
=cc 
newcc 
PoolChunkListcc )
<cc) *
Tcc* +
>cc+ ,
(cc, -
thiscc- 1
,cc1 2
thiscc3 7
.cc7 8
q075cc8 <
,cc< =
$numcc> @
,cc@ A
$numccB E
,ccE F
	chunkSizeccG P
)ccP Q
;ccQ R
thisdd 
.dd 
q025dd 
=dd 
newdd 
PoolChunkListdd )
<dd) *
Tdd* +
>dd+ ,
(dd, -
thisdd- 1
,dd1 2
thisdd3 7
.dd7 8
q050dd8 <
,dd< =
$numdd> @
,dd@ A
$numddB D
,ddD E
	chunkSizeddF O
)ddO P
;ddP Q
thisee 
.ee 
q000ee 
=ee 
newee 
PoolChunkListee )
<ee) *
Tee* +
>ee+ ,
(ee, -
thisee- 1
,ee1 2
thisee3 7
.ee7 8
q025ee8 <
,ee< =
$numee> ?
,ee? @
$numeeA C
,eeC D
	chunkSizeeeE N
)eeN O
;eeO P
thisff 
.ff 
qInitff 
=ff 
newff 
PoolChunkListff *
<ff* +
Tff+ ,
>ff, -
(ff- .
thisff. 2
,ff2 3
thisff4 8
.ff8 9
q000ff9 =
,ff= >
intff? B
.ffB C
MinValueffC K
,ffK L
$numffM O
,ffO P
	chunkSizeffQ Z
)ffZ [
;ff[ \
thishh 
.hh 
q100hh 
.hh 
PrevListhh 
(hh 
thishh #
.hh# $
q075hh$ (
)hh( )
;hh) *
thisii 
.ii 
q075ii 
.ii 
PrevListii 
(ii 
thisii #
.ii# $
q050ii$ (
)ii( )
;ii) *
thisjj 
.jj 
q050jj 
.jj 
PrevListjj 
(jj 
thisjj #
.jj# $
q025jj$ (
)jj( )
;jj) *
thiskk 
.kk 
q025kk 
.kk 
PrevListkk 
(kk 
thiskk #
.kk# $
q000kk$ (
)kk( )
;kk) *
thisll 
.ll 
q000ll 
.ll 
PrevListll 
(ll 
nullll #
)ll# $
;ll$ %
thismm 
.mm 
qInitmm 
.mm 
PrevListmm 
(mm  
thismm  $
.mm$ %
qInitmm% *
)mm* +
;mm+ ,
varoo 
metricsoo 
=oo 
newoo 
Listoo "
<oo" # 
IPoolChunkListMetricoo# 7
>oo7 8
(oo8 9
$numoo9 :
)oo: ;
;oo; <
metricspp 
.pp 
Addpp 
(pp 
thispp 
.pp 
qInitpp "
)pp" #
;pp# $
metricsqq 
.qq 
Addqq 
(qq 
thisqq 
.qq 
q000qq !
)qq! "
;qq" #
metricsrr 
.rr 
Addrr 
(rr 
thisrr 
.rr 
q025rr !
)rr! "
;rr" #
metricsss 
.ss 
Addss 
(ss 
thisss 
.ss 
q050ss !
)ss! "
;ss" #
metricstt 
.tt 
Addtt 
(tt 
thistt 
.tt 
q075tt !
)tt! "
;tt" #
metricsuu 
.uu 
Adduu 
(uu 
thisuu 
.uu 
q100uu !
)uu! "
;uu" #
thisvv 
.vv 
chunkListMetricsvv !
=vv" #
metricsvv$ +
;vv+ ,
}ww 	
PoolSubpageyy 
<yy 
Tyy 
>yy 
NewSubpagePoolHeadyy )
(yy) *
intyy* -
pageSizeyy. 6
)yy6 7
{zz 	
var{{ 
head{{ 
={{ 
new{{ 
PoolSubpage{{ &
<{{& '
T{{' (
>{{( )
({{) *
pageSize{{* 2
){{2 3
;{{3 4
head|| 
.|| 
Prev|| 
=|| 
head|| 
;|| 
head}} 
.}} 
Next}} 
=}} 
head}} 
;}} 
return~~ 
head~~ 
;~~ 
} 	
PoolSubpage
ÅÅ 
<
ÅÅ 
T
ÅÅ 
>
ÅÅ 
[
ÅÅ 
]
ÅÅ !
NewSubpagePoolArray
ÅÅ ,
(
ÅÅ, -
int
ÅÅ- 0
size
ÅÅ1 5
)
ÅÅ5 6
=>
ÅÅ7 9
new
ÅÅ: =
PoolSubpage
ÅÅ> I
<
ÅÅI J
T
ÅÅJ K
>
ÅÅK L
[
ÅÅL M
size
ÅÅM Q
]
ÅÅQ R
;
ÅÅR S
internal
ÉÉ 
abstract
ÉÉ 
bool
ÉÉ 
IsDirect
ÉÉ '
{
ÉÉ( )
get
ÉÉ* -
;
ÉÉ- .
}
ÉÉ/ 0
internal
ÖÖ 
PooledByteBuffer
ÖÖ !
<
ÖÖ! "
T
ÖÖ" #
>
ÖÖ# $
Allocate
ÖÖ% -
(
ÖÖ- .
PoolThreadCache
ÖÖ. =
<
ÖÖ= >
T
ÖÖ> ?
>
ÖÖ? @
cache
ÖÖA F
,
ÖÖF G
int
ÖÖH K
reqCapacity
ÖÖL W
,
ÖÖW X
int
ÖÖY \
maxCapacity
ÖÖ] h
)
ÖÖh i
{
ÜÜ 	
PooledByteBuffer
áá 
<
áá 
T
áá 
>
áá 
buf
áá  #
=
áá$ %
this
áá& *
.
áá* +

NewByteBuf
áá+ 5
(
áá5 6
maxCapacity
áá6 A
)
ááA B
;
ááB C
this
àà 
.
àà 
Allocate
àà 
(
àà 
cache
àà 
,
àà  
buf
àà! $
,
àà$ %
reqCapacity
àà& 1
)
àà1 2
;
àà2 3
return
ââ 
buf
ââ 
;
ââ 
}
ää 	
internal
åå 
static
åå 
int
åå 
TinyIdx
åå #
(
åå# $
int
åå$ '
normCapacity
åå( 4
)
åå4 5
=>
åå6 8
normCapacity
åå9 E
.
ååE F
RightUShift
ååF Q
(
ååQ R
$num
ååR S
)
ååS T
;
ååT U
internal
éé 
static
éé 
int
éé 
SmallIdx
éé $
(
éé$ %
int
éé% (
normCapacity
éé) 5
)
éé5 6
{
èè 	
int
êê 
tableIdx
êê 
=
êê 
$num
êê 
;
êê 
int
ëë 
i
ëë 
=
ëë 
normCapacity
ëë  
.
ëë  !
RightUShift
ëë! ,
(
ëë, -
$num
ëë- /
)
ëë/ 0
;
ëë0 1
while
íí 
(
íí 
i
íí 
!=
íí 
$num
íí 
)
íí 
{
ìì 
i
îî 
=
îî 
i
îî 
.
îî 
RightUShift
îî !
(
îî! "
$num
îî" #
)
îî# $
;
îî$ %
tableIdx
ïï 
++
ïï 
;
ïï 
}
ññ 
return
óó 
tableIdx
óó 
;
óó 
}
òò 	
internal
õõ 
bool
õõ 
IsTinyOrSmall
õõ #
(
õõ# $
int
õõ$ '
normCapacity
õõ( 4
)
õõ4 5
=>
õõ6 8
(
õõ9 :
normCapacity
õõ: F
&
õõG H
this
õõI M
.
õõM N!
SubpageOverflowMask
õõN a
)
õõa b
==
õõc e
$num
õõf g
;
õõg h
internal
ûû 
static
ûû 
bool
ûû 
IsTiny
ûû #
(
ûû# $
int
ûû$ '
normCapacity
ûû( 4
)
ûû4 5
=>
ûû6 8
(
ûû9 :
normCapacity
ûû: F
&
ûûG H
$num
ûûI S
)
ûûS T
==
ûûU W
$num
ûûX Y
;
ûûY Z
void
†† 
Allocate
†† 
(
†† 
PoolThreadCache
†† %
<
††% &
T
††& '
>
††' (
cache
††) .
,
††. /
PooledByteBuffer
††0 @
<
††@ A
T
††A B
>
††B C
buf
††D G
,
††G H
int
††I L
reqCapacity
††M X
)
††X Y
{
°° 	
int
¢¢ 
normCapacity
¢¢ 
=
¢¢ 
this
¢¢ #
.
¢¢# $
NormalizeCapacity
¢¢$ 5
(
¢¢5 6
reqCapacity
¢¢6 A
)
¢¢A B
;
¢¢B C
if
££ 
(
££ 
this
££ 
.
££ 
IsTinyOrSmall
££ "
(
££" #
normCapacity
££# /
)
££/ 0
)
££0 1
{
§§ 
int
¶¶ 
tableIdx
¶¶ 
;
¶¶ 
PoolSubpage
ßß 
<
ßß 
T
ßß 
>
ßß 
[
ßß 
]
ßß  
table
ßß! &
;
ßß& '
bool
®® 
tiny
®® 
=
®® 
IsTiny
®® "
(
®®" #
normCapacity
®®# /
)
®®/ 0
;
®®0 1
if
©© 
(
©© 
tiny
©© 
)
©© 
{
™™ 
if
¨¨ 
(
¨¨ 
cache
¨¨ 
.
¨¨ 
AllocateTiny
¨¨ *
(
¨¨* +
this
¨¨+ /
,
¨¨/ 0
buf
¨¨1 4
,
¨¨4 5
reqCapacity
¨¨6 A
,
¨¨A B
normCapacity
¨¨C O
)
¨¨O P
)
¨¨P Q
{
≠≠ 
return
ØØ 
;
ØØ 
}
∞∞ 
tableIdx
±± 
=
±± 
TinyIdx
±± &
(
±±& '
normCapacity
±±' 3
)
±±3 4
;
±±4 5
table
≤≤ 
=
≤≤ 
this
≤≤  
.
≤≤  !
tinySubpagePools
≤≤! 1
;
≤≤1 2
}
≥≥ 
else
¥¥ 
{
µµ 
if
∂∂ 
(
∂∂ 
cache
∂∂ 
.
∂∂ 
AllocateSmall
∂∂ +
(
∂∂+ ,
this
∂∂, 0
,
∂∂0 1
buf
∂∂2 5
,
∂∂5 6
reqCapacity
∂∂7 B
,
∂∂B C
normCapacity
∂∂D P
)
∂∂P Q
)
∂∂Q R
{
∑∑ 
return
ππ 
;
ππ 
}
∫∫ 
tableIdx
ªª 
=
ªª 
SmallIdx
ªª '
(
ªª' (
normCapacity
ªª( 4
)
ªª4 5
;
ªª5 6
table
ºº 
=
ºº 
this
ºº  
.
ºº  !
smallSubpagePools
ºº! 2
;
ºº2 3
}
ΩΩ 
PoolSubpage
øø 
<
øø 
T
øø 
>
øø 
head
øø #
=
øø$ %
table
øø& +
[
øø+ ,
tableIdx
øø, 4
]
øø4 5
;
øø5 6
lock
≈≈ 
(
≈≈ 
head
≈≈ 
)
≈≈ 
{
∆∆ 
PoolSubpage
«« 
<
««  
T
««  !
>
««! "
s
««# $
=
««% &
head
««' +
.
««+ ,
Next
««, 0
;
««0 1
if
»» 
(
»» 
s
»» 
!=
»» 
head
»» !
)
»»! "
{
…… 
Debug
   
.
   
Assert
   $
(
  $ %
s
  % &
.
  & '
DoNotDestroy
  ' 3
&&
  4 6
s
  7 8
.
  8 9
ElemSize
  9 A
==
  B D
normCapacity
  E Q
)
  Q R
;
  R S
long
ÀÀ 
handle
ÀÀ #
=
ÀÀ$ %
s
ÀÀ& '
.
ÀÀ' (
Allocate
ÀÀ( 0
(
ÀÀ0 1
)
ÀÀ1 2
;
ÀÀ2 3
Debug
ÃÃ 
.
ÃÃ 
Assert
ÃÃ $
(
ÃÃ$ %
handle
ÃÃ% +
>=
ÃÃ, .
$num
ÃÃ/ 0
)
ÃÃ0 1
;
ÃÃ1 2
s
ÕÕ 
.
ÕÕ 
Chunk
ÕÕ 
.
ÕÕ   
InitBufWithSubpage
ÕÕ  2
(
ÕÕ2 3
buf
ÕÕ3 6
,
ÕÕ6 7
handle
ÕÕ8 >
,
ÕÕ> ?
reqCapacity
ÕÕ@ K
)
ÕÕK L
;
ÕÕL M
this
ŒŒ 
.
ŒŒ $
IncTinySmallAllocation
ŒŒ 3
(
ŒŒ3 4
tiny
ŒŒ4 8
)
ŒŒ8 9
;
ŒŒ9 :
return
œœ 
;
œœ 
}
–– 
}
—— 
lock
”” 
(
”” 
this
”” 
)
”” 
{
‘‘ 
this
’’ 
.
’’ 
AllocateNormal
’’ '
(
’’' (
buf
’’( +
,
’’+ ,
reqCapacity
’’- 8
,
’’8 9
normCapacity
’’: F
)
’’F G
;
’’G H
}
÷÷ 
this
ÿÿ 
.
ÿÿ $
IncTinySmallAllocation
ÿÿ +
(
ÿÿ+ ,
tiny
ÿÿ, 0
)
ÿÿ0 1
;
ÿÿ1 2
return
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
if
€€ 
(
€€ 
normCapacity
€€ 
<=
€€ 
this
€€  $
.
€€$ %
	ChunkSize
€€% .
)
€€. /
{
‹‹ 
if
›› 
(
›› 
cache
›› 
.
›› 
AllocateNormal
›› (
(
››( )
this
››) -
,
››- .
buf
››/ 2
,
››2 3
reqCapacity
››4 ?
,
››? @
normCapacity
››A M
)
››M N
)
››N O
{
ﬁﬁ 
return
‡‡ 
;
‡‡ 
}
·· 
lock
„„ 
(
„„ 
this
„„ 
)
„„ 
{
‰‰ 
this
ÂÂ 
.
ÂÂ 
AllocateNormal
ÂÂ '
(
ÂÂ' (
buf
ÂÂ( +
,
ÂÂ+ ,
reqCapacity
ÂÂ- 8
,
ÂÂ8 9
normCapacity
ÂÂ: F
)
ÂÂF G
;
ÂÂG H
this
ÊÊ 
.
ÊÊ 
allocationsNormal
ÊÊ *
++
ÊÊ* ,
;
ÊÊ, -
}
ÁÁ 
}
ËË 
else
ÈÈ 
{
ÍÍ 
this
ÏÏ 
.
ÏÏ 
AllocateHuge
ÏÏ !
(
ÏÏ! "
buf
ÏÏ" %
,
ÏÏ% &
reqCapacity
ÏÏ' 2
)
ÏÏ2 3
;
ÏÏ3 4
}
ÌÌ 
}
ÓÓ 	
void
 
AllocateNormal
 
(
 
PooledByteBuffer
 ,
<
, -
T
- .
>
. /
buf
0 3
,
3 4
int
5 8
reqCapacity
9 D
,
D E
int
F I
normCapacity
J V
)
V W
{
ÒÒ 	
if
ÚÚ 
(
ÚÚ 
this
ÚÚ 
.
ÚÚ 
q050
ÚÚ 
.
ÚÚ 
Allocate
ÚÚ "
(
ÚÚ" #
buf
ÚÚ# &
,
ÚÚ& '
reqCapacity
ÚÚ( 3
,
ÚÚ3 4
normCapacity
ÚÚ5 A
)
ÚÚA B
||
ÚÚC E
this
ÚÚF J
.
ÚÚJ K
q025
ÚÚK O
.
ÚÚO P
Allocate
ÚÚP X
(
ÚÚX Y
buf
ÚÚY \
,
ÚÚ\ ]
reqCapacity
ÚÚ^ i
,
ÚÚi j
normCapacity
ÚÚk w
)
ÚÚw x
||
ÛÛ 
this
ÛÛ 
.
ÛÛ 
q000
ÛÛ 
.
ÛÛ 
Allocate
ÛÛ %
(
ÛÛ% &
buf
ÛÛ& )
,
ÛÛ) *
reqCapacity
ÛÛ+ 6
,
ÛÛ6 7
normCapacity
ÛÛ8 D
)
ÛÛD E
||
ÛÛF H
this
ÛÛI M
.
ÛÛM N
qInit
ÛÛN S
.
ÛÛS T
Allocate
ÛÛT \
(
ÛÛ\ ]
buf
ÛÛ] `
,
ÛÛ` a
reqCapacity
ÛÛb m
,
ÛÛm n
normCapacity
ÛÛo {
)
ÛÛ{ |
||
ÙÙ 
this
ÙÙ 
.
ÙÙ 
q075
ÙÙ 
.
ÙÙ 
Allocate
ÙÙ %
(
ÙÙ% &
buf
ÙÙ& )
,
ÙÙ) *
reqCapacity
ÙÙ+ 6
,
ÙÙ6 7
normCapacity
ÙÙ8 D
)
ÙÙD E
)
ÙÙE F
{
ıı 
return
ˆˆ 
;
ˆˆ 
}
˜˜ 
	PoolChunk
˙˙ 
<
˙˙ 
T
˙˙ 
>
˙˙ 
c
˙˙ 
=
˙˙ 
this
˙˙ !
.
˙˙! "
NewChunk
˙˙" *
(
˙˙* +
this
˙˙+ /
.
˙˙/ 0
PageSize
˙˙0 8
,
˙˙8 9
this
˙˙: >
.
˙˙> ?
maxOrder
˙˙? G
,
˙˙G H
this
˙˙I M
.
˙˙M N

PageShifts
˙˙N X
,
˙˙X Y
this
˙˙Z ^
.
˙˙^ _
	ChunkSize
˙˙_ h
)
˙˙h i
;
˙˙i j
long
˚˚ 
handle
˚˚ 
=
˚˚ 
c
˚˚ 
.
˚˚ 
Allocate
˚˚ $
(
˚˚$ %
normCapacity
˚˚% 1
)
˚˚1 2
;
˚˚2 3
Debug
¸¸ 
.
¸¸ 
Assert
¸¸ 
(
¸¸ 
handle
¸¸ 
>
¸¸  !
$num
¸¸" #
)
¸¸# $
;
¸¸$ %
c
˝˝ 
.
˝˝ 
InitBuf
˝˝ 
(
˝˝ 
buf
˝˝ 
,
˝˝ 
handle
˝˝ !
,
˝˝! "
reqCapacity
˝˝# .
)
˝˝. /
;
˝˝/ 0
this
˛˛ 
.
˛˛ 
qInit
˛˛ 
.
˛˛ 
Add
˛˛ 
(
˛˛ 
c
˛˛ 
)
˛˛ 
;
˛˛ 
}
ˇˇ 	
void
ÅÅ $
IncTinySmallAllocation
ÅÅ #
(
ÅÅ# $
bool
ÅÅ$ (
tiny
ÅÅ) -
)
ÅÅ- .
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
tiny
ÉÉ 
)
ÉÉ 
{
ÑÑ 
Interlocked
ÖÖ 
.
ÖÖ 
	Increment
ÖÖ %
(
ÖÖ% &
ref
ÖÖ& )
this
ÖÖ* .
.
ÖÖ. /
allocationsTiny
ÖÖ/ >
)
ÖÖ> ?
;
ÖÖ? @
}
ÜÜ 
else
áá 
{
àà 
Interlocked
ââ 
.
ââ 
	Increment
ââ %
(
ââ% &
ref
ââ& )
this
ââ* .
.
ââ. /
allocationsSmall
ââ/ ?
)
ââ? @
;
ââ@ A
}
ää 
}
ãã 	
void
çç 
AllocateHuge
çç 
(
çç 
PooledByteBuffer
çç *
<
çç* +
T
çç+ ,
>
çç, -
buf
çç. 1
,
çç1 2
int
çç3 6
reqCapacity
çç7 B
)
ççB C
{
éé 	
	PoolChunk
èè 
<
èè 
T
èè 
>
èè 
chunk
èè 
=
èè  
this
èè! %
.
èè% &
NewUnpooledChunk
èè& 6
(
èè6 7
reqCapacity
èè7 B
)
èèB C
;
èèC D
Interlocked
êê 
.
êê 
Add
êê 
(
êê 
ref
êê 
this
êê  $
.
êê$ %
activeBytesHuge
êê% 4
,
êê4 5
chunk
êê6 ;
.
êê; <
	ChunkSize
êê< E
)
êêE F
;
êêF G
buf
ëë 
.
ëë 
InitUnpooled
ëë 
(
ëë 
chunk
ëë "
,
ëë" #
reqCapacity
ëë$ /
)
ëë/ 0
;
ëë0 1
Interlocked
íí 
.
íí 
	Increment
íí !
(
íí! "
ref
íí" %
this
íí& *
.
íí* +
allocationsHuge
íí+ :
)
íí: ;
;
íí; <
}
ìì 	
internal
ïï 
void
ïï 
Free
ïï 
(
ïï 
	PoolChunk
ïï $
<
ïï$ %
T
ïï% &
>
ïï& '
chunk
ïï( -
,
ïï- .
long
ïï/ 3
handle
ïï4 :
,
ïï: ;
int
ïï< ?
normCapacity
ïï@ L
,
ïïL M
PoolThreadCache
ïïN ]
<
ïï] ^
T
ïï^ _
>
ïï_ `
cache
ïïa f
)
ïïf g
{
ññ 	
if
óó 
(
óó 
chunk
óó 
.
óó 
Unpooled
óó 
)
óó 
{
òò 
int
ôô 
size
ôô 
=
ôô 
chunk
ôô  
.
ôô  !
	ChunkSize
ôô! *
;
ôô* +
this
öö 
.
öö 
DestroyChunk
öö !
(
öö! "
chunk
öö" '
)
öö' (
;
öö( )
Interlocked
õõ 
.
õõ 
Add
õõ 
(
õõ  
ref
õõ  #
this
õõ$ (
.
õõ( )
activeBytesHuge
õõ) 8
,
õõ8 9
-
õõ: ;
size
õõ; ?
)
õõ? @
;
õõ@ A
Interlocked
úú 
.
úú 
	Increment
úú %
(
úú% &
ref
úú& )
this
úú* .
.
úú. /
deallocationsHuge
úú/ @
)
úú@ A
;
úúA B
}
ùù 
else
ûû 
{
üü 
	SizeClass
†† 
	sizeClass
†† #
=
††$ %
this
††& *
.
††* +
	SizeClass
††+ 4
(
††4 5
normCapacity
††5 A
)
††A B
;
††B C
if
°° 
(
°° 
cache
°° 
!=
°° 
null
°° !
&&
°°" $
cache
°°% *
.
°°* +
Add
°°+ .
(
°°. /
this
°°/ 3
,
°°3 4
chunk
°°5 :
,
°°: ;
handle
°°< B
,
°°B C
normCapacity
°°D P
,
°°P Q
	sizeClass
°°R [
)
°°[ \
)
°°\ ]
{
¢¢ 
return
§§ 
;
§§ 
}
•• 
this
ßß 
.
ßß 
	FreeChunk
ßß 
(
ßß 
chunk
ßß $
,
ßß$ %
handle
ßß& ,
,
ßß, -
	sizeClass
ßß. 7
)
ßß7 8
;
ßß8 9
}
®® 
}
©© 	
	SizeClass
´´ 
	SizeClass
´´ 
(
´´ 
int
´´ 
normCapacity
´´  ,
)
´´, -
{
¨¨ 	
if
≠≠ 
(
≠≠ 
!
≠≠ 
this
≠≠ 
.
≠≠ 
IsTinyOrSmall
≠≠ #
(
≠≠# $
normCapacity
≠≠$ 0
)
≠≠0 1
)
≠≠1 2
{
ÆÆ 
return
ØØ 
Buffers
ØØ 
.
ØØ 
	SizeClass
ØØ (
.
ØØ( )
Normal
ØØ) /
;
ØØ/ 0
}
∞∞ 
return
≤≤ 
IsTiny
≤≤ 
(
≤≤ 
normCapacity
≤≤ &
)
≤≤& '
?
≤≤( )
Buffers
≤≤* 1
.
≤≤1 2
	SizeClass
≤≤2 ;
.
≤≤; <
Tiny
≤≤< @
:
≤≤A B
Buffers
≤≤C J
.
≤≤J K
	SizeClass
≤≤K T
.
≤≤T U
Small
≤≤U Z
;
≤≤Z [
}
≥≥ 	
internal
µµ 
void
µµ 
	FreeChunk
µµ 
(
µµ  
	PoolChunk
µµ  )
<
µµ) *
T
µµ* +
>
µµ+ ,
chunk
µµ- 2
,
µµ2 3
long
µµ4 8
handle
µµ9 ?
,
µµ? @
	SizeClass
µµA J
	sizeClass
µµK T
)
µµT U
{
∂∂ 	
bool
∑∑ 
destroyChunk
∑∑ 
;
∑∑ 
lock
∏∏ 
(
∏∏ 
this
∏∏ 
)
∏∏ 
{
ππ 
switch
∫∫ 
(
∫∫ 
	sizeClass
∫∫ !
)
∫∫! "
{
ªª 
case
ºº 
Buffers
ºº  
.
ºº  !
	SizeClass
ºº! *
.
ºº* +
Normal
ºº+ 1
:
ºº1 2
++
ΩΩ 
this
ΩΩ 
.
ΩΩ !
deallocationsNormal
ΩΩ 2
;
ΩΩ2 3
break
ææ 
;
ææ 
case
øø 
Buffers
øø  
.
øø  !
	SizeClass
øø! *
.
øø* +
Small
øø+ 0
:
øø0 1
++
¿¿ 
this
¿¿ 
.
¿¿  
deallocationsSmall
¿¿ 1
;
¿¿1 2
break
¡¡ 
;
¡¡ 
case
¬¬ 
Buffers
¬¬  
.
¬¬  !
	SizeClass
¬¬! *
.
¬¬* +
Tiny
¬¬+ /
:
¬¬/ 0
++
√√ 
this
√√ 
.
√√ 
deallocationsTiny
√√ 0
;
√√0 1
break
ƒƒ 
;
ƒƒ 
default
≈≈ 
:
≈≈ 
throw
∆∆ 
new
∆∆ !)
ArgumentOutOfRangeException
∆∆" =
(
∆∆= >
)
∆∆> ?
;
∆∆? @
}
«« 
destroyChunk
»» 
=
»» 
!
»»  
chunk
»»  %
.
»»% &
Parent
»»& ,
.
»», -
Free
»»- 1
(
»»1 2
chunk
»»2 7
,
»»7 8
handle
»»9 ?
)
»»? @
;
»»@ A
}
…… 
if
   
(
   
destroyChunk
   
)
   
{
ÀÀ 
this
ÕÕ 
.
ÕÕ 
DestroyChunk
ÕÕ !
(
ÕÕ! "
chunk
ÕÕ" '
)
ÕÕ' (
;
ÕÕ( )
}
ŒŒ 
}
œœ 	
internal
—— 
PoolSubpage
—— 
<
—— 
T
—— 
>
—— !
FindSubpagePoolHead
——  3
(
——3 4
int
——4 7
elemSize
——8 @
)
——@ A
{
““ 	
int
”” 
tableIdx
”” 
;
”” 
PoolSubpage
‘‘ 
<
‘‘ 
T
‘‘ 
>
‘‘ 
[
‘‘ 
]
‘‘ 
table
‘‘ "
;
‘‘" #
if
’’ 
(
’’ 
IsTiny
’’ 
(
’’ 
elemSize
’’ 
)
’’  
)
’’  !
{
÷÷ 
tableIdx
ÿÿ 
=
ÿÿ 
elemSize
ÿÿ #
.
ÿÿ# $
RightUShift
ÿÿ$ /
(
ÿÿ/ 0
$num
ÿÿ0 1
)
ÿÿ1 2
;
ÿÿ2 3
table
ŸŸ 
=
ŸŸ 
this
ŸŸ 
.
ŸŸ 
tinySubpagePools
ŸŸ -
;
ŸŸ- .
}
⁄⁄ 
else
€€ 
{
‹‹ 
tableIdx
›› 
=
›› 
$num
›› 
;
›› 
elemSize
ﬁﬁ 
=
ﬁﬁ 
elemSize
ﬁﬁ #
.
ﬁﬁ# $
RightUShift
ﬁﬁ$ /
(
ﬁﬁ/ 0
$num
ﬁﬁ0 2
)
ﬁﬁ2 3
;
ﬁﬁ3 4
while
ﬂﬂ 
(
ﬂﬂ 
elemSize
ﬂﬂ 
!=
ﬂﬂ  "
$num
ﬂﬂ# $
)
ﬂﬂ$ %
{
‡‡ 
elemSize
·· 
=
·· 
elemSize
·· '
.
··' (
RightUShift
··( 3
(
··3 4
$num
··4 5
)
··5 6
;
··6 7
tableIdx
‚‚ 
++
‚‚ 
;
‚‚ 
}
„„ 
table
‰‰ 
=
‰‰ 
this
‰‰ 
.
‰‰ 
smallSubpagePools
‰‰ .
;
‰‰. /
}
ÂÂ 
return
ÁÁ 
table
ÁÁ 
[
ÁÁ 
tableIdx
ÁÁ !
]
ÁÁ! "
;
ÁÁ" #
}
ËË 	
internal
ÍÍ 
int
ÍÍ 
NormalizeCapacity
ÍÍ &
(
ÍÍ& '
int
ÍÍ' *
reqCapacity
ÍÍ+ 6
)
ÍÍ6 7
{
ÎÎ 	
Contract
ÏÏ 
.
ÏÏ 
Requires
ÏÏ 
(
ÏÏ 
reqCapacity
ÏÏ )
>=
ÏÏ* ,
$num
ÏÏ- .
&&
ÏÏ/ 1
reqCapacity
ÏÏ2 =
>=
ÏÏ> @
this
ÏÏA E
.
ÏÏE F
	ChunkSize
ÏÏF O
)
ÏÏO P
;
ÏÏP Q
if
ÓÓ 
(
ÓÓ 
reqCapacity
ÓÓ 
>=
ÓÓ 
this
ÓÓ #
.
ÓÓ# $
	ChunkSize
ÓÓ$ -
)
ÓÓ- .
{
ÔÔ 
return
 
reqCapacity
 "
;
" #
}
ÒÒ 
if
ÛÛ 
(
ÛÛ 
!
ÛÛ 
IsTiny
ÛÛ 
(
ÛÛ 
reqCapacity
ÛÛ #
)
ÛÛ# $
)
ÛÛ$ %
{
ÙÙ 
int
¯¯  
normalizedCapacity
¯¯ &
=
¯¯' (
reqCapacity
¯¯) 4
;
¯¯4 5 
normalizedCapacity
˘˘ "
--
˘˘" $
;
˘˘$ % 
normalizedCapacity
˙˙ "
|=
˙˙# % 
normalizedCapacity
˙˙& 8
.
˙˙8 9
RightUShift
˙˙9 D
(
˙˙D E
$num
˙˙E F
)
˙˙F G
;
˙˙G H 
normalizedCapacity
˚˚ "
|=
˚˚# % 
normalizedCapacity
˚˚& 8
.
˚˚8 9
RightUShift
˚˚9 D
(
˚˚D E
$num
˚˚E F
)
˚˚F G
;
˚˚G H 
normalizedCapacity
¸¸ "
|=
¸¸# % 
normalizedCapacity
¸¸& 8
.
¸¸8 9
RightUShift
¸¸9 D
(
¸¸D E
$num
¸¸E F
)
¸¸F G
;
¸¸G H 
normalizedCapacity
˝˝ "
|=
˝˝# % 
normalizedCapacity
˝˝& 8
.
˝˝8 9
RightUShift
˝˝9 D
(
˝˝D E
$num
˝˝E F
)
˝˝F G
;
˝˝G H 
normalizedCapacity
˛˛ "
|=
˛˛# % 
normalizedCapacity
˛˛& 8
.
˛˛8 9
RightUShift
˛˛9 D
(
˛˛D E
$num
˛˛E G
)
˛˛G H
;
˛˛H I 
normalizedCapacity
ˇˇ "
++
ˇˇ" $
;
ˇˇ$ %
if
ÅÅ 
(
ÅÅ  
normalizedCapacity
ÅÅ &
<
ÅÅ' (
$num
ÅÅ) *
)
ÅÅ* +
{
ÇÇ  
normalizedCapacity
ÉÉ &
=
ÉÉ' ( 
normalizedCapacity
ÉÉ) ;
.
ÉÉ; <
RightUShift
ÉÉ< G
(
ÉÉG H
$num
ÉÉH I
)
ÉÉI J
;
ÉÉJ K
}
ÑÑ 
return
ÜÜ  
normalizedCapacity
ÜÜ )
;
ÜÜ) *
}
áá 
if
ää 
(
ää 
(
ää 
reqCapacity
ää 
&
ää 
$num
ää !
)
ää! "
==
ää# %
$num
ää& '
)
ää' (
{
ãã 
return
åå 
reqCapacity
åå "
;
åå" #
}
çç 
return
èè 
(
èè 
reqCapacity
èè 
&
èè  !
~
èè" #
$num
èè# %
)
èè% &
+
èè' (
$num
èè) +
;
èè+ ,
}
êê 	
internal
íí 
void
íí 

Reallocate
íí  
(
íí  !
PooledByteBuffer
íí! 1
<
íí1 2
T
íí2 3
>
íí3 4
buf
íí5 8
,
íí8 9
int
íí: =
newCapacity
íí> I
,
ííI J
bool
ííK O
freeOldMemory
ííP ]
)
íí] ^
{
ìì 	
Contract
îî 
.
îî 
Requires
îî 
(
îî 
newCapacity
îî )
>=
îî* ,
$num
îî- .
&&
îî/ 1
newCapacity
îî2 =
<=
îî> @
buf
îîA D
.
îîD E
MaxCapacity
îîE P
)
îîP Q
;
îîQ R
int
ññ 
oldCapacity
ññ 
=
ññ 
buf
ññ !
.
ññ! "
Length
ññ" (
;
ññ( )
if
óó 
(
óó 
oldCapacity
óó 
==
óó 
newCapacity
óó *
)
óó* +
{
òò 
return
ôô 
;
ôô 
}
öö 
	PoolChunk
úú 
<
úú 
T
úú 
>
úú 
oldChunk
úú !
=
úú" #
buf
úú$ '
.
úú' (
Chunk
úú( -
;
úú- .
long
ùù 
	oldHandle
ùù 
=
ùù 
buf
ùù  
.
ùù  !
Handle
ùù! '
;
ùù' (
T
ûû 
	oldMemory
ûû 
=
ûû 
buf
ûû 
.
ûû 
Memory
ûû $
;
ûû$ %
int
üü 
	oldOffset
üü 
=
üü 
buf
üü 
.
üü  
Offset
üü  &
;
üü& '
int
†† 
oldMaxLength
†† 
=
†† 
buf
†† "
.
††" #
	MaxLength
††# ,
;
††, -
int
°° 
readerIndex
°° 
=
°° 
buf
°° !
.
°°! "
ReaderIndex
°°" -
;
°°- .
int
¢¢ 
writerIndex
¢¢ 
=
¢¢ 
buf
¢¢ !
.
¢¢! "
WriterIndex
¢¢" -
;
¢¢- .
this
§§ 
.
§§ 
Allocate
§§ 
(
§§ 
this
§§ 
.
§§ 
Parent
§§ %
.
§§% &
ThreadCache
§§& 1
<
§§1 2
T
§§2 3
>
§§3 4
(
§§4 5
)
§§5 6
,
§§6 7
buf
§§8 ;
,
§§; <
newCapacity
§§= H
)
§§H I
;
§§I J
if
•• 
(
•• 
newCapacity
•• 
>
•• 
oldCapacity
•• )
)
••) *
{
¶¶ 
this
ßß 
.
ßß 

MemoryCopy
ßß 
(
ßß  
	oldMemory
®® 
,
®® 
	oldOffset
®® (
,
®®( )
buf
©© 
.
©© 
Memory
©© 
,
©© 
buf
©©  #
.
©©# $
Offset
©©$ *
,
©©* +
oldCapacity
©©, 7
)
©©7 8
;
©©8 9
}
™™ 
else
´´ 
if
´´ 
(
´´ 
newCapacity
´´  
<
´´! "
oldCapacity
´´# .
)
´´. /
{
¨¨ 
if
≠≠ 
(
≠≠ 
readerIndex
≠≠ 
<
≠≠  !
newCapacity
≠≠" -
)
≠≠- .
{
ÆÆ 
if
ØØ 
(
ØØ 
writerIndex
ØØ #
>
ØØ$ %
newCapacity
ØØ& 1
)
ØØ1 2
{
∞∞ 
writerIndex
±± #
=
±±$ %
newCapacity
±±& 1
;
±±1 2
}
≤≤ 
this
≥≥ 
.
≥≥ 

MemoryCopy
≥≥ #
(
≥≥# $
	oldMemory
¥¥ !
,
¥¥! "
	oldOffset
¥¥# ,
+
¥¥- .
readerIndex
¥¥/ :
,
¥¥: ;
buf
µµ 
.
µµ 
Memory
µµ "
,
µµ" #
buf
µµ$ '
.
µµ' (
Offset
µµ( .
+
µµ/ 0
readerIndex
µµ1 <
,
µµ< =
writerIndex
µµ> I
-
µµJ K
readerIndex
µµL W
)
µµW X
;
µµX Y
}
∂∂ 
else
∑∑ 
{
∏∏ 
readerIndex
ππ 
=
ππ  !
writerIndex
ππ" -
=
ππ. /
newCapacity
ππ0 ;
;
ππ; <
}
∫∫ 
}
ªª 
buf
ΩΩ 
.
ΩΩ 
SetIndex
ΩΩ 
(
ΩΩ 
readerIndex
ΩΩ $
,
ΩΩ$ %
writerIndex
ΩΩ& 1
)
ΩΩ1 2
;
ΩΩ2 3
if
øø 
(
øø 
freeOldMemory
øø 
)
øø 
{
¿¿ 
this
¡¡ 
.
¡¡ 
Free
¡¡ 
(
¡¡ 
oldChunk
¡¡ "
,
¡¡" #
	oldHandle
¡¡$ -
,
¡¡- .
oldMaxLength
¡¡/ ;
,
¡¡; <
buf
¡¡= @
.
¡¡@ A
Cache
¡¡A F
)
¡¡F G
;
¡¡G H
}
¬¬ 
}
√√ 	
internal
≈≈ 
void
≈≈ &
IncrementNumThreadCaches
≈≈ .
(
≈≈. /
)
≈≈/ 0
=>
≈≈1 3
Interlocked
≈≈4 ?
.
≈≈? @
	Increment
≈≈@ I
(
≈≈I J
ref
≈≈J M
this
≈≈N R
.
≈≈R S
numThreadCaches
≈≈S b
)
≈≈b c
;
≈≈c d
internal
«« 
void
«« &
DecrementNumThreadCaches
«« .
(
««. /
)
««/ 0
=>
««1 3
Interlocked
««4 ?
.
««? @
	Decrement
««@ I
(
««I J
ref
««J M
this
««N R
.
««R S
numThreadCaches
««S b
)
««b c
;
««c d
public
…… 
int
…… 
NumThreadCaches
…… "
=>
……# %
Volatile
……& .
.
……. /
Read
……/ 3
(
……3 4
ref
……4 7
this
……8 <
.
……< =
numThreadCaches
……= L
)
……L M
;
……M N
public
ÀÀ 
int
ÀÀ 
NumTinySubpages
ÀÀ "
=>
ÀÀ# %
this
ÀÀ& *
.
ÀÀ* +
tinySubpagePools
ÀÀ+ ;
.
ÀÀ; <
Length
ÀÀ< B
;
ÀÀB C
public
ÕÕ 
int
ÕÕ 
NumSmallSubpages
ÕÕ #
=>
ÕÕ$ &
this
ÕÕ' +
.
ÕÕ+ ,
smallSubpagePools
ÕÕ, =
.
ÕÕ= >
Length
ÕÕ> D
;
ÕÕD E
public
œœ 
int
œœ 
NumChunkLists
œœ  
=>
œœ! #
this
œœ$ (
.
œœ( )
chunkListMetrics
œœ) 9
.
œœ9 :
Count
œœ: ?
;
œœ? @
public
—— 
IReadOnlyList
—— 
<
——  
IPoolSubpageMetric
—— /
>
——/ 0
TinySubpages
——1 =
=>
——> @
SubPageMetricList
——A R
(
——R S
this
——S W
.
——W X
tinySubpagePools
——X h
)
——h i
;
——i j
public
”” 
IReadOnlyList
”” 
<
””  
IPoolSubpageMetric
”” /
>
””/ 0
SmallSubpages
””1 >
=>
””? A
SubPageMetricList
””B S
(
””S T
this
””T X
.
””X Y
smallSubpagePools
””Y j
)
””j k
;
””k l
public
’’ 
IReadOnlyList
’’ 
<
’’ "
IPoolChunkListMetric
’’ 1
>
’’1 2

ChunkLists
’’3 =
=>
’’> @
this
’’A E
.
’’E F
chunkListMetrics
’’F V
;
’’V W
static
◊◊ 
List
◊◊ 
<
◊◊  
IPoolSubpageMetric
◊◊ &
>
◊◊& '
SubPageMetricList
◊◊( 9
(
◊◊9 :
PoolSubpage
◊◊: E
<
◊◊E F
T
◊◊F G
>
◊◊G H
[
◊◊H I
]
◊◊I J
pages
◊◊K P
)
◊◊P Q
{
ÿÿ 	
var
ŸŸ 
metrics
ŸŸ 
=
ŸŸ 
new
ŸŸ 
List
ŸŸ "
<
ŸŸ" # 
IPoolSubpageMetric
ŸŸ# 5
>
ŸŸ5 6
(
ŸŸ6 7
)
ŸŸ7 8
;
ŸŸ8 9
foreach
⁄⁄ 
(
⁄⁄ 
PoolSubpage
⁄⁄  
<
⁄⁄  !
T
⁄⁄! "
>
⁄⁄" #
head
⁄⁄$ (
in
⁄⁄) +
pages
⁄⁄, 1
)
⁄⁄1 2
{
€€ 
if
‹‹ 
(
‹‹ 
head
‹‹ 
.
‹‹ 
Next
‹‹ 
==
‹‹  
head
‹‹! %
)
‹‹% &
{
›› 
continue
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
PoolSubpage
‡‡ 
<
‡‡ 
T
‡‡ 
>
‡‡ 
s
‡‡  
=
‡‡! "
head
‡‡# '
.
‡‡' (
Next
‡‡( ,
;
‡‡, -
for
·· 
(
·· 
;
·· 
;
·· 
)
·· 
{
‚‚ 
metrics
„„ 
.
„„ 
Add
„„ 
(
„„  
s
„„  !
)
„„! "
;
„„" #
s
‰‰ 
=
‰‰ 
s
‰‰ 
.
‰‰ 
Next
‰‰ 
;
‰‰ 
if
ÂÂ 
(
ÂÂ 
s
ÂÂ 
==
ÂÂ 
head
ÂÂ !
)
ÂÂ! "
{
ÊÊ 
break
ÁÁ 
;
ÁÁ 
}
ËË 
}
ÈÈ 
}
ÍÍ 
return
ÎÎ 
metrics
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÓÓ 
long
ÓÓ 
NumAllocations
ÓÓ "
{
ÔÔ 	
get
 
{
ÒÒ 
long
ÚÚ 
allocsNormal
ÚÚ !
;
ÚÚ! "
lock
ÛÛ 
(
ÛÛ 
this
ÛÛ 
)
ÛÛ 
{
ÙÙ 
allocsNormal
ıı  
=
ıı! "
this
ıı# '
.
ıı' (
allocationsNormal
ıı( 9
;
ıı9 :
}
ˆˆ 
return
¯¯ 
this
¯¯ 
.
¯¯  
NumTinyAllocations
¯¯ .
+
¯¯/ 0
this
¯¯1 5
.
¯¯5 6!
NumSmallAllocations
¯¯6 I
+
¯¯J K
allocsNormal
¯¯L X
+
¯¯Y Z
this
¯¯[ _
.
¯¯_ ` 
NumHugeAllocations
¯¯` r
;
¯¯r s
}
˘˘ 
}
˙˙ 	
public
¸¸ 
long
¸¸  
NumTinyAllocations
¸¸ &
=>
¸¸' )
Volatile
¸¸* 2
.
¸¸2 3
Read
¸¸3 7
(
¸¸7 8
ref
¸¸8 ;
this
¸¸< @
.
¸¸@ A
allocationsTiny
¸¸A P
)
¸¸P Q
;
¸¸Q R
public
˛˛ 
long
˛˛ !
NumSmallAllocations
˛˛ '
=>
˛˛( *
Volatile
˛˛+ 3
.
˛˛3 4
Read
˛˛4 8
(
˛˛8 9
ref
˛˛9 <
this
˛˛= A
.
˛˛A B
allocationsSmall
˛˛B R
)
˛˛R S
;
˛˛S T
public
ÄÄ 
long
ÄÄ "
NumNormalAllocations
ÄÄ (
=>
ÄÄ) +
Volatile
ÄÄ, 4
.
ÄÄ4 5
Read
ÄÄ5 9
(
ÄÄ9 :
ref
ÄÄ: =
this
ÄÄ> B
.
ÄÄB C
allocationsNormal
ÄÄC T
)
ÄÄT U
;
ÄÄU V
public
ÇÇ 
long
ÇÇ 
NumDeallocations
ÇÇ $
{
ÉÉ 	
get
ÑÑ 
{
ÖÖ 
long
ÜÜ 
deallocs
ÜÜ 
;
ÜÜ 
lock
áá 
(
áá 
this
áá 
)
áá 
{
àà 
deallocs
ââ 
=
ââ 
this
ââ #
.
ââ# $
deallocationsTiny
ââ$ 5
+
ââ6 7
this
ââ8 <
.
ââ< = 
deallocationsSmall
ââ= O
+
ââP Q
this
ââR V
.
ââV W!
deallocationsNormal
ââW j
;
ââj k
}
ää 
return
åå 
deallocs
åå 
+
åå  !
this
åå" &
.
åå& '"
NumHugeDeallocations
åå' ;
;
åå; <
}
çç 
}
éé 	
public
êê 
long
êê "
NumTinyDeallocations
êê (
=>
êê) +
Volatile
êê, 4
.
êê4 5
Read
êê5 9
(
êê9 :
ref
êê: =
this
êê> B
.
êêB C
deallocationsTiny
êêC T
)
êêT U
;
êêU V
public
íí 
long
íí #
NumSmallDeallocations
íí )
=>
íí* ,
Volatile
íí- 5
.
íí5 6
Read
íí6 :
(
íí: ;
ref
íí; >
this
íí? C
.
ííC D 
deallocationsSmall
ííD V
)
ííV W
;
ííW X
public
îî 
long
îî $
NumNormalDeallocations
îî *
=>
îî+ -
Volatile
îî. 6
.
îî6 7
Read
îî7 ;
(
îî; <
ref
îî< ?
this
îî@ D
.
îîD E!
deallocationsNormal
îîE X
)
îîX Y
;
îîY Z
public
ññ 
long
ññ  
NumHugeAllocations
ññ &
=>
ññ' )
Volatile
ññ* 2
.
ññ2 3
Read
ññ3 7
(
ññ7 8
ref
ññ8 ;
this
ññ< @
.
ññ@ A
allocationsHuge
ññA P
)
ññP Q
;
ññQ R
public
òò 
long
òò "
NumHugeDeallocations
òò (
=>
òò) +
Volatile
òò, 4
.
òò4 5
Read
òò5 9
(
òò9 :
ref
òò: =
this
òò> B
.
òòB C
deallocationsHuge
òòC T
)
òòT U
;
òòU V
public
öö 
long
öö "
NumActiveAllocations
öö (
{
õõ 	
get
úú 
{
ùù 
long
ûû 
val
ûû 
=
ûû 
this
ûû 
.
ûû   
NumTinyAllocations
ûû  2
+
ûû3 4
this
ûû5 9
.
ûû9 :!
NumSmallAllocations
ûû: M
+
ûûN O
this
ûûP T
.
ûûT U 
NumHugeAllocations
ûûU g
-
üü 
this
üü 
.
üü "
NumHugeDeallocations
üü /
;
üü/ 0
lock
†† 
(
†† 
this
†† 
)
†† 
{
°° 
val
¢¢ 
+=
¢¢ 
this
¢¢ 
.
¢¢  
allocationsNormal
¢¢  1
-
¢¢2 3
(
¢¢4 5
this
¢¢5 9
.
¢¢9 :
deallocationsTiny
¢¢: K
+
¢¢L M
this
¢¢N R
.
¢¢R S 
deallocationsSmall
¢¢S e
+
¢¢f g
this
¢¢h l
.
¢¢l m"
deallocationsNormal¢¢m Ä
)¢¢Ä Å
;¢¢Å Ç
}
££ 
return
§§ 
Math
§§ 
.
§§ 
Max
§§ 
(
§§  
val
§§  #
,
§§# $
$num
§§% &
)
§§& '
;
§§' (
}
•• 
}
¶¶ 	
public
®® 
long
®® &
NumActiveTinyAllocations
®® ,
=>
®®- /
Math
®®0 4
.
®®4 5
Max
®®5 8
(
®®8 9
this
®®9 =
.
®®= > 
NumTinyAllocations
®®> P
-
®®Q R
this
®®S W
.
®®W X"
NumTinyDeallocations
®®X l
,
®®l m
$num
®®n o
)
®®o p
;
®®p q
public
™™ 
long
™™ '
NumActiveSmallAllocations
™™ -
=>
™™. 0
Math
™™1 5
.
™™5 6
Max
™™6 9
(
™™9 :
this
™™: >
.
™™> ?!
NumSmallAllocations
™™? R
-
™™S T
this
™™U Y
.
™™Y Z#
NumSmallDeallocations
™™Z o
,
™™o p
$num
™™q r
)
™™r s
;
™™s t
public
¨¨ 
long
¨¨ (
NumActiveNormalAllocations
¨¨ .
{
≠≠ 	
get
ÆÆ 
{
ØØ 
long
∞∞ 
val
∞∞ 
;
∞∞ 
lock
±± 
(
±± 
this
±± 
)
±± 
{
≤≤ 
val
≥≥ 
=
≥≥ 
this
≥≥ 
.
≥≥ 
allocationsNormal
≥≥ 0
-
≥≥1 2
this
≥≥3 7
.
≥≥7 8!
deallocationsNormal
≥≥8 K
;
≥≥K L
}
¥¥ 
return
µµ 
Math
µµ 
.
µµ 
Max
µµ 
(
µµ  
val
µµ  #
,
µµ# $
$num
µµ% &
)
µµ& '
;
µµ' (
}
∂∂ 
}
∑∑ 	
public
ππ 
long
ππ &
NumActiveHugeAllocations
ππ ,
=>
ππ- /
Math
ππ0 4
.
ππ4 5
Max
ππ5 8
(
ππ8 9
this
ππ9 =
.
ππ= > 
NumHugeAllocations
ππ> P
-
ππQ R
this
ππS W
.
ππW X"
NumHugeDeallocations
ππX l
,
ππl m
$num
ππn o
)
ππo p
;
ππp q
public
ªª 
long
ªª 
NumActiveBytes
ªª "
{
ºº 	
get
ΩΩ 
{
ææ 
long
øø 
val
øø 
=
øø 
Volatile
øø #
.
øø# $
Read
øø$ (
(
øø( )
ref
øø) ,
this
øø- 1
.
øø1 2
activeBytesHuge
øø2 A
)
øøA B
;
øøB C
lock
¿¿ 
(
¿¿ 
this
¿¿ 
)
¿¿ 
{
¡¡ 
foreach
¬¬ 
(
¬¬ "
IPoolChunkListMetric
¬¬ 1
t
¬¬2 3
in
¬¬4 6
this
¬¬7 ;
.
¬¬; <
chunkListMetrics
¬¬< L
)
¬¬L M
{
√√ 
foreach
ƒƒ 
(
ƒƒ  !
IPoolChunkMetric
ƒƒ! 1
m
ƒƒ2 3
in
ƒƒ4 6
t
ƒƒ7 8
)
ƒƒ8 9
{
≈≈ 
val
∆∆ 
+=
∆∆  "
m
∆∆# $
.
∆∆$ %
	ChunkSize
∆∆% .
;
∆∆. /
}
«« 
}
»» 
}
…… 
return
   
Math
   
.
   
Max
   
(
    
$num
    !
,
  ! "
val
  # &
)
  & '
;
  ' (
}
ÀÀ 
}
ÃÃ 	
	protected
ŒŒ 
abstract
ŒŒ 
	PoolChunk
ŒŒ $
<
ŒŒ$ %
T
ŒŒ% &
>
ŒŒ& '
NewChunk
ŒŒ( 0
(
ŒŒ0 1
int
ŒŒ1 4
pageSize
ŒŒ5 =
,
ŒŒ= >
int
ŒŒ? B
maxOrder
ŒŒC K
,
ŒŒK L
int
ŒŒM P

pageShifts
ŒŒQ [
,
ŒŒ[ \
int
ŒŒ] `
	chunkSize
ŒŒa j
)
ŒŒj k
;
ŒŒk l
	protected
–– 
abstract
–– 
	PoolChunk
–– $
<
––$ %
T
––% &
>
––& '
NewUnpooledChunk
––( 8
(
––8 9
int
––9 <
capacity
––= E
)
––E F
;
––F G
	protected
““ 
abstract
““ 
PooledByteBuffer
““ +
<
““+ ,
T
““, -
>
““- .

NewByteBuf
““/ 9
(
““9 :
int
““: =
maxCapacity
““> I
)
““I J
;
““J K
	protected
‘‘ 
abstract
‘‘ 
void
‘‘ 

MemoryCopy
‘‘  *
(
‘‘* +
T
‘‘+ ,
src
‘‘- 0
,
‘‘0 1
int
‘‘2 5
	srcOffset
‘‘6 ?
,
‘‘? @
T
‘‘A B
dst
‘‘C F
,
‘‘F G
int
‘‘H K
	dstOffset
‘‘L U
,
‘‘U V
int
‘‘W Z
length
‘‘[ a
)
‘‘a b
;
‘‘b c
	protected
÷÷ 
internal
÷÷ 
abstract
÷÷ #
void
÷÷$ (
DestroyChunk
÷÷) 5
(
÷÷5 6
	PoolChunk
÷÷6 ?
<
÷÷? @
T
÷÷@ A
>
÷÷A B
chunk
÷÷C H
)
÷÷H I
;
÷÷I J
public
ÿÿ 
override
ÿÿ 
string
ÿÿ 
ToString
ÿÿ '
(
ÿÿ' (
)
ÿÿ( )
{
ŸŸ 	
StringBuilder
⁄⁄ 
buf
⁄⁄ 
=
⁄⁄ 
new
⁄⁄  #
StringBuilder
⁄⁄$ 1
(
⁄⁄1 2
)
⁄⁄2 3
.
€€ 
Append
€€ 
(
€€ 
$str
€€ ,
)
€€, -
.
‹‹ 
Append
‹‹ 
(
‹‹ 

StringUtil
‹‹ "
.
‹‹" #
Newline
‹‹# *
)
‹‹* +
.
›› 
Append
›› 
(
›› 
this
›› 
.
›› 
qInit
›› "
)
››" #
.
ﬁﬁ 
Append
ﬁﬁ 
(
ﬁﬁ 

StringUtil
ﬁﬁ "
.
ﬁﬁ" #
Newline
ﬁﬁ# *
)
ﬁﬁ* +
.
ﬂﬂ 
Append
ﬂﬂ 
(
ﬂﬂ 
$str
ﬂﬂ ,
)
ﬂﬂ, -
.
‡‡ 
Append
‡‡ 
(
‡‡ 

StringUtil
‡‡ "
.
‡‡" #
Newline
‡‡# *
)
‡‡* +
.
·· 
Append
·· 
(
·· 
this
·· 
.
·· 
q000
·· !
)
··! "
.
‚‚ 
Append
‚‚ 
(
‚‚ 

StringUtil
‚‚ "
.
‚‚" #
Newline
‚‚# *
)
‚‚* +
.
„„ 
Append
„„ 
(
„„ 
$str
„„ -
)
„„- .
.
‰‰ 
Append
‰‰ 
(
‰‰ 

StringUtil
‰‰ "
.
‰‰" #
Newline
‰‰# *
)
‰‰* +
.
ÂÂ 
Append
ÂÂ 
(
ÂÂ 
this
ÂÂ 
.
ÂÂ 
q025
ÂÂ !
)
ÂÂ! "
.
ÊÊ 
Append
ÊÊ 
(
ÊÊ 

StringUtil
ÊÊ "
.
ÊÊ" #
Newline
ÊÊ# *
)
ÊÊ* +
.
ÁÁ 
Append
ÁÁ 
(
ÁÁ 
$str
ÁÁ .
)
ÁÁ. /
.
ËË 
Append
ËË 
(
ËË 

StringUtil
ËË "
.
ËË" #
Newline
ËË# *
)
ËË* +
.
ÈÈ 
Append
ÈÈ 
(
ÈÈ 
this
ÈÈ 
.
ÈÈ 
q050
ÈÈ !
)
ÈÈ! "
.
ÍÍ 
Append
ÍÍ 
(
ÍÍ 

StringUtil
ÍÍ "
.
ÍÍ" #
Newline
ÍÍ# *
)
ÍÍ* +
.
ÎÎ 
Append
ÎÎ 
(
ÎÎ 
$str
ÎÎ .
)
ÎÎ. /
.
ÏÏ 
Append
ÏÏ 
(
ÏÏ 

StringUtil
ÏÏ "
.
ÏÏ" #
Newline
ÏÏ# *
)
ÏÏ* +
.
ÌÌ 
Append
ÌÌ 
(
ÌÌ 
this
ÌÌ 
.
ÌÌ 
q075
ÌÌ !
)
ÌÌ! "
.
ÓÓ 
Append
ÓÓ 
(
ÓÓ 

StringUtil
ÓÓ "
.
ÓÓ" #
Newline
ÓÓ# *
)
ÓÓ* +
.
ÔÔ 
Append
ÔÔ 
(
ÔÔ 
$str
ÔÔ +
)
ÔÔ+ ,
.
 
Append
 
(
 

StringUtil
 "
.
" #
Newline
# *
)
* +
.
ÒÒ 
Append
ÒÒ 
(
ÒÒ 
this
ÒÒ 
.
ÒÒ 
q100
ÒÒ !
)
ÒÒ! "
.
ÚÚ 
Append
ÚÚ 
(
ÚÚ 

StringUtil
ÚÚ "
.
ÚÚ" #
Newline
ÚÚ# *
)
ÚÚ* +
.
ÛÛ 
Append
ÛÛ 
(
ÛÛ 
$str
ÛÛ (
)
ÛÛ( )
;
ÛÛ) * 
AppendPoolSubPages
ÙÙ 
(
ÙÙ 
buf
ÙÙ "
,
ÙÙ" #
this
ÙÙ$ (
.
ÙÙ( )
tinySubpagePools
ÙÙ) 9
)
ÙÙ9 :
;
ÙÙ: ;
buf
ıı 
.
ıı 
Append
ıı 
(
ıı 

StringUtil
ıı !
.
ıı! "
Newline
ıı" )
)
ıı) *
.
ˆˆ 
Append
ˆˆ 
(
ˆˆ 
$str
ˆˆ )
)
ˆˆ) *
;
ˆˆ* + 
AppendPoolSubPages
˜˜ 
(
˜˜ 
buf
˜˜ "
,
˜˜" #
this
˜˜$ (
.
˜˜( )
smallSubpagePools
˜˜) :
)
˜˜: ;
;
˜˜; <
buf
¯¯ 
.
¯¯ 
Append
¯¯ 
(
¯¯ 

StringUtil
¯¯ !
.
¯¯! "
Newline
¯¯" )
)
¯¯) *
;
¯¯* +
return
˙˙ 
buf
˙˙ 
.
˙˙ 
ToString
˙˙ 
(
˙˙  
)
˙˙  !
;
˙˙! "
}
˚˚ 	
static
˝˝ 
void
˝˝  
AppendPoolSubPages
˝˝ &
(
˝˝& '
StringBuilder
˝˝' 4
buf
˝˝5 8
,
˝˝8 9
PoolSubpage
˝˝: E
<
˝˝E F
T
˝˝F G
>
˝˝G H
[
˝˝H I
]
˝˝I J
subpages
˝˝K S
)
˝˝S T
{
˛˛ 	
for
ˇˇ 
(
ˇˇ 
int
ˇˇ 
i
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
i
ˇˇ 
<
ˇˇ 
subpages
ˇˇ  (
.
ˇˇ( )
Length
ˇˇ) /
;
ˇˇ/ 0
i
ˇˇ1 2
++
ˇˇ2 4
)
ˇˇ4 5
{
ÄÄ 
PoolSubpage
ÅÅ 
<
ÅÅ 
T
ÅÅ 
>
ÅÅ 
head
ÅÅ #
=
ÅÅ$ %
subpages
ÅÅ& .
[
ÅÅ. /
i
ÅÅ/ 0
]
ÅÅ0 1
;
ÅÅ1 2
if
ÇÇ 
(
ÇÇ 
head
ÇÇ 
.
ÇÇ 
Next
ÇÇ 
==
ÇÇ  
head
ÇÇ! %
)
ÇÇ% &
{
ÉÉ 
continue
ÑÑ 
;
ÑÑ 
}
ÖÖ 
buf
áá 
.
áá 
Append
áá 
(
áá 

StringUtil
áá %
.
áá% &
Newline
áá& -
)
áá- .
.
àà 
Append
àà 
(
àà 
i
àà 
)
àà 
.
ââ 
Append
ââ 
(
ââ 
$str
ââ  
)
ââ  !
;
ââ! "
PoolSubpage
ää 
<
ää 
T
ää 
>
ää 
s
ää  
=
ää! "
head
ää# '
.
ää' (
Next
ää( ,
;
ää, -
for
ãã 
(
ãã 
;
ãã 
;
ãã 
)
ãã 
{
åå 
buf
çç 
.
çç 
Append
çç 
(
çç 
s
çç  
)
çç  !
;
çç! "
s
éé 
=
éé 
s
éé 
.
éé 
Next
éé 
;
éé 
if
èè 
(
èè 
s
èè 
==
èè 
head
èè !
)
èè! "
{
êê 
break
ëë 
;
ëë 
}
íí 
}
ìì 
}
îî 
}
ïï 	
~
óó 	
	PoolArena
óó	 
(
óó 
)
óó 
{
òò 	!
DestroyPoolSubPages
ôô 
(
ôô  
this
ôô  $
.
ôô$ %
smallSubpagePools
ôô% 6
)
ôô6 7
;
ôô7 8!
DestroyPoolSubPages
öö 
(
öö  
this
öö  $
.
öö$ %
tinySubpagePools
öö% 5
)
öö5 6
;
öö6 7
this
õõ 
.
õõ #
DestroyPoolChunkLists
õõ &
(
õõ& '
this
õõ' +
.
õõ+ ,
qInit
õõ, 1
,
õõ1 2
this
õõ3 7
.
õõ7 8
q000
õõ8 <
,
õõ< =
this
õõ> B
.
õõB C
q025
õõC G
,
õõG H
this
õõI M
.
õõM N
q050
õõN R
,
õõR S
this
õõT X
.
õõX Y
q075
õõY ]
,
õõ] ^
this
õõ_ c
.
õõc d
q100
õõd h
)
õõh i
;
õõi j
}
úú 	
static
ûû 
void
ûû !
DestroyPoolSubPages
ûû '
(
ûû' (
PoolSubpage
ûû( 3
<
ûû3 4
T
ûû4 5
>
ûû5 6
[
ûû6 7
]
ûû7 8
pages
ûû9 >
)
ûû> ?
{
üü 	
foreach
†† 
(
†† 
PoolSubpage
††  
<
††  !
T
††! "
>
††" #
page
††$ (
in
††) +
pages
††, 1
)
††1 2
{
°° 
page
¢¢ 
.
¢¢ 
Destroy
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
}
££ 
}
§§ 	
void
¶¶ #
DestroyPoolChunkLists
¶¶ "
(
¶¶" #
params
¶¶# )
PoolChunkList
¶¶* 7
<
¶¶7 8
T
¶¶8 9
>
¶¶9 :
[
¶¶: ;
]
¶¶; <

chunkLists
¶¶= G
)
¶¶G H
{
ßß 	
foreach
®® 
(
®® 
PoolChunkList
®® "
<
®®" #
T
®®# $
>
®®$ %
	chunkList
®®& /
in
®®0 2

chunkLists
®®3 =
)
®®= >
{
©© 
	chunkList
™™ 
.
™™ 
Destroy
™™ !
(
™™! "
this
™™" &
)
™™& '
;
™™' (
}
´´ 
}
¨¨ 	
}
≠≠ 
sealed
ØØ 

class
ØØ 
	HeapArena
ØØ 
:
ØØ 
	PoolArena
ØØ &
<
ØØ& '
byte
ØØ' +
[
ØØ+ ,
]
ØØ, -
>
ØØ- .
{
∞∞ 
public
±± 
	HeapArena
±± 
(
±± '
PooledByteBufferAllocator
±± 2
parent
±±3 9
,
±±9 :
int
±±; >
pageSize
±±? G
,
±±G H
int
±±I L
maxOrder
±±M U
,
±±U V
int
±±W Z

pageShifts
±±[ e
,
±±e f
int
±±g j
	chunkSize
±±k t
)
±±t u
:
≤≤ 
base
≤≤ 
(
≤≤ 
parent
≤≤ 
,
≤≤ 
pageSize
≤≤ #
,
≤≤# $
maxOrder
≤≤% -
,
≤≤- .

pageShifts
≤≤/ 9
,
≤≤9 :
	chunkSize
≤≤; D
)
≤≤D E
{
≥≥ 	
}
¥¥ 	
static
∂∂ 
byte
∂∂ 
[
∂∂ 
]
∂∂ 
NewByteArray
∂∂ "
(
∂∂" #
int
∂∂# &
size
∂∂' +
)
∂∂+ ,
=>
∂∂- /
new
∂∂0 3
byte
∂∂4 8
[
∂∂8 9
size
∂∂9 =
]
∂∂= >
;
∂∂> ?
internal
∏∏ 
override
∏∏ 
bool
∏∏ 
IsDirect
∏∏ '
=>
∏∏( *
false
∏∏+ 0
;
∏∏0 1
	protected
∫∫ 
override
∫∫ 
	PoolChunk
∫∫ $
<
∫∫$ %
byte
∫∫% )
[
∫∫) *
]
∫∫* +
>
∫∫+ ,
NewChunk
∫∫- 5
(
∫∫5 6
int
∫∫6 9
pageSize
∫∫: B
,
∫∫B C
int
∫∫D G
maxOrder
∫∫H P
,
∫∫P Q
int
∫∫R U

pageShifts
∫∫V `
,
∫∫` a
int
∫∫b e
	chunkSize
∫∫f o
)
∫∫o p
=>
∫∫q s
new
ªª 
	PoolChunk
ªª 
<
ªª 
byte
ªª 
[
ªª 
]
ªª  
>
ªª  !
(
ªª! "
this
ªª" &
,
ªª& '
NewByteArray
ªª( 4
(
ªª4 5
	chunkSize
ªª5 >
)
ªª> ?
,
ªª? @
pageSize
ªªA I
,
ªªI J
maxOrder
ªªK S
,
ªªS T

pageShifts
ªªU _
,
ªª_ `
	chunkSize
ªªa j
,
ªªj k
$num
ªªl m
)
ªªm n
;
ªªn o
	protected
ΩΩ 
override
ΩΩ 
	PoolChunk
ΩΩ $
<
ΩΩ$ %
byte
ΩΩ% )
[
ΩΩ) *
]
ΩΩ* +
>
ΩΩ+ ,
NewUnpooledChunk
ΩΩ- =
(
ΩΩ= >
int
ΩΩ> A
capacity
ΩΩB J
)
ΩΩJ K
=>
ΩΩL N
new
ææ 
	PoolChunk
ææ 
<
ææ 
byte
ææ 
[
ææ 
]
ææ  
>
ææ  !
(
ææ! "
this
ææ" &
,
ææ& '
NewByteArray
ææ( 4
(
ææ4 5
capacity
ææ5 =
)
ææ= >
,
ææ> ?
capacity
ææ@ H
,
ææH I
$num
ææJ K
)
ææK L
;
ææL M
	protected
¿¿ 
internal
¿¿ 
override
¿¿ #
void
¿¿$ (
DestroyChunk
¿¿) 5
(
¿¿5 6
	PoolChunk
¿¿6 ?
<
¿¿? @
byte
¿¿@ D
[
¿¿D E
]
¿¿E F
>
¿¿F G
chunk
¿¿H M
)
¿¿M N
{
¡¡ 	
}
√√ 	
	protected
≈≈ 
override
≈≈ 
PooledByteBuffer
≈≈ +
<
≈≈+ ,
byte
≈≈, 0
[
≈≈0 1
]
≈≈1 2
>
≈≈2 3

NewByteBuf
≈≈4 >
(
≈≈> ?
int
≈≈? B
maxCapacity
≈≈C N
)
≈≈N O
=>
≈≈P R"
PooledHeapByteBuffer
∆∆  
.
∆∆  !
NewInstance
∆∆! ,
(
∆∆, -
maxCapacity
∆∆- 8
)
∆∆8 9
;
∆∆9 :
	protected
»» 
override
»» 
void
»» 

MemoryCopy
»»  *
(
»»* +
byte
»»+ /
[
»»/ 0
]
»»0 1
src
»»2 5
,
»»5 6
int
»»7 :
	srcOffset
»»; D
,
»»D E
byte
»»F J
[
»»J K
]
»»K L
dst
»»M P
,
»»P Q
int
»»R U
	dstOffset
»»V _
,
»»_ `
int
»»a d
length
»»e k
)
»»k l
{
…… 	
if
   
(
   
length
   
==
   
$num
   
)
   
{
ÀÀ 
return
ÃÃ 
;
ÃÃ 
}
ÕÕ 
PlatformDependent
œœ 
.
œœ 

CopyMemory
œœ (
(
œœ( )
src
œœ) ,
,
œœ, -
	srcOffset
œœ. 7
,
œœ7 8
dst
œœ9 <
,
œœ< =
	dstOffset
œœ> G
,
œœG H
length
œœI O
)
œœO P
;
œœP Q
}
–– 	
}
—— 
sealed
‘‘ 

class
‘‘ 
DirectArena
‘‘ 
:
‘‘ 
	PoolArena
‘‘ (
<
‘‘( )
byte
‘‘) -
[
‘‘- .
]
‘‘. /
>
‘‘/ 0
{
’’ 
readonly
÷÷ 
List
÷÷ 
<
÷÷ 
MemoryChunk
÷÷ !
>
÷÷! "
memoryChunks
÷÷# /
;
÷÷/ 0
public
ÿÿ 
DirectArena
ÿÿ 
(
ÿÿ '
PooledByteBufferAllocator
ÿÿ 4
parent
ÿÿ5 ;
,
ÿÿ; <
int
ÿÿ= @
pageSize
ÿÿA I
,
ÿÿI J
int
ÿÿK N
maxOrder
ÿÿO W
,
ÿÿW X
int
ÿÿY \

pageShifts
ÿÿ] g
,
ÿÿg h
int
ÿÿi l
	chunkSize
ÿÿm v
)
ÿÿv w
:
ŸŸ 
base
ŸŸ 
(
ŸŸ 
parent
ŸŸ 
,
ŸŸ 
pageSize
ŸŸ #
,
ŸŸ# $
maxOrder
ŸŸ% -
,
ŸŸ- .

pageShifts
ŸŸ/ 9
,
ŸŸ9 :
	chunkSize
ŸŸ; D
)
ŸŸD E
{
⁄⁄ 	
this
€€ 
.
€€ 
memoryChunks
€€ 
=
€€ 
new
€€  #
List
€€$ (
<
€€( )
MemoryChunk
€€) 4
>
€€4 5
(
€€5 6
)
€€6 7
;
€€7 8
}
‹‹ 	
static
ﬁﬁ 
MemoryChunk
ﬁﬁ 
NewMemoryChunk
ﬁﬁ )
(
ﬁﬁ) *
int
ﬁﬁ* -
size
ﬁﬁ. 2
)
ﬁﬁ2 3
=>
ﬁﬁ4 6
new
ﬁﬁ7 :
MemoryChunk
ﬁﬁ; F
(
ﬁﬁF G
size
ﬁﬁG K
)
ﬁﬁK L
;
ﬁﬁL M
internal
‡‡ 
override
‡‡ 
bool
‡‡ 
IsDirect
‡‡ '
=>
‡‡( *
true
‡‡+ /
;
‡‡/ 0
	protected
‚‚ 
override
‚‚ 
	PoolChunk
‚‚ $
<
‚‚$ %
byte
‚‚% )
[
‚‚) *
]
‚‚* +
>
‚‚+ ,
NewChunk
‚‚- 5
(
‚‚5 6
int
‚‚6 9
pageSize
‚‚: B
,
‚‚B C
int
‚‚D G
maxOrder
‚‚H P
,
‚‚P Q
int
‚‚R U

pageShifts
‚‚V `
,
‚‚` a
int
‚‚b e
	chunkSize
‚‚f o
)
‚‚o p
{
„„ 	
MemoryChunk
‰‰ 
memoryChunk
‰‰ #
=
‰‰$ %
NewMemoryChunk
‰‰& 4
(
‰‰4 5
	chunkSize
‰‰5 >
)
‰‰> ?
;
‰‰? @
this
ÂÂ 
.
ÂÂ 
memoryChunks
ÂÂ 
.
ÂÂ 
Add
ÂÂ !
(
ÂÂ! "
memoryChunk
ÂÂ" -
)
ÂÂ- .
;
ÂÂ. /
var
ÊÊ 
chunk
ÊÊ 
=
ÊÊ 
new
ÊÊ 
	PoolChunk
ÊÊ %
<
ÊÊ% &
byte
ÊÊ& *
[
ÊÊ* +
]
ÊÊ+ ,
>
ÊÊ, -
(
ÊÊ- .
this
ÊÊ. 2
,
ÊÊ2 3
memoryChunk
ÊÊ4 ?
.
ÊÊ? @
Bytes
ÊÊ@ E
,
ÊÊE F
pageSize
ÊÊG O
,
ÊÊO P
maxOrder
ÊÊQ Y
,
ÊÊY Z

pageShifts
ÊÊ[ e
,
ÊÊe f
	chunkSize
ÊÊg p
,
ÊÊp q
$num
ÊÊr s
)
ÊÊs t
;
ÊÊt u
return
ÁÁ 
chunk
ÁÁ 
;
ÁÁ 
}
ËË 	
	protected
ÍÍ 
override
ÍÍ 
	PoolChunk
ÍÍ $
<
ÍÍ$ %
byte
ÍÍ% )
[
ÍÍ) *
]
ÍÍ* +
>
ÍÍ+ ,
NewUnpooledChunk
ÍÍ- =
(
ÍÍ= >
int
ÍÍ> A
capacity
ÍÍB J
)
ÍÍJ K
{
ÎÎ 	
MemoryChunk
ÏÏ 
memoryChunk
ÏÏ #
=
ÏÏ$ %
NewMemoryChunk
ÏÏ& 4
(
ÏÏ4 5
capacity
ÏÏ5 =
)
ÏÏ= >
;
ÏÏ> ?
this
ÌÌ 
.
ÌÌ 
memoryChunks
ÌÌ 
.
ÌÌ 
Add
ÌÌ !
(
ÌÌ! "
memoryChunk
ÌÌ" -
)
ÌÌ- .
;
ÌÌ. /
var
ÓÓ 
chunk
ÓÓ 
=
ÓÓ 
new
ÓÓ 
	PoolChunk
ÓÓ %
<
ÓÓ% &
byte
ÓÓ& *
[
ÓÓ* +
]
ÓÓ+ ,
>
ÓÓ, -
(
ÓÓ- .
this
ÓÓ. 2
,
ÓÓ2 3
memoryChunk
ÓÓ4 ?
.
ÓÓ? @
Bytes
ÓÓ@ E
,
ÓÓE F
capacity
ÓÓG O
,
ÓÓO P
$num
ÓÓQ R
)
ÓÓR S
;
ÓÓS T
return
ÔÔ 
chunk
ÔÔ 
;
ÔÔ 
}
 	
	protected
ÚÚ 
override
ÚÚ 
PooledByteBuffer
ÚÚ +
<
ÚÚ+ ,
byte
ÚÚ, 0
[
ÚÚ0 1
]
ÚÚ1 2
>
ÚÚ2 3

NewByteBuf
ÚÚ4 >
(
ÚÚ> ?
int
ÚÚ? B
maxCapacity
ÚÚC N
)
ÚÚN O
=>
ÚÚP R*
PooledUnsafeDirectByteBuffer
ÛÛ (
.
ÛÛ( )
NewInstance
ÛÛ) 4
(
ÛÛ4 5
maxCapacity
ÛÛ5 @
)
ÛÛ@ A
;
ÛÛA B
	protected
ıı 
override
ıı 
unsafe
ıı !
void
ıı" &

MemoryCopy
ıı' 1
(
ıı1 2
byte
ıı2 6
[
ıı6 7
]
ıı7 8
src
ıı9 <
,
ıı< =
int
ıı> A
	srcOffset
ııB K
,
ııK L
byte
ııM Q
[
ııQ R
]
ııR S
dst
ııT W
,
ııW X
int
ııY \
	dstOffset
ıı] f
,
ııf g
int
ııh k
length
ııl r
)
ıır s
=>
ııt v
PlatformDependent
ˆˆ !
.
ˆˆ! "

CopyMemory
ˆˆ" ,
(
ˆˆ, -
(
ˆˆ- .
byte
ˆˆ. 2
*
ˆˆ2 3
)
ˆˆ3 4
Unsafe
ˆˆ4 :
.
ˆˆ: ;
	AsPointer
ˆˆ; D
(
ˆˆD E
ref
ˆˆE H
src
ˆˆI L
[
ˆˆL M
	srcOffset
ˆˆM V
]
ˆˆV W
)
ˆˆW X
,
ˆˆX Y
(
ˆˆZ [
byte
ˆˆ[ _
*
ˆˆ_ `
)
ˆˆ` a
Unsafe
ˆˆa g
.
ˆˆg h
	AsPointer
ˆˆh q
(
ˆˆq r
ref
ˆˆr u
dst
ˆˆv y
[
ˆˆy z
	dstOffsetˆˆz É
]ˆˆÉ Ñ
)ˆˆÑ Ö
,ˆˆÖ Ü
lengthˆˆá ç
)ˆˆç é
;ˆˆé è
	protected
¯¯ 
internal
¯¯ 
override
¯¯ #
void
¯¯$ (
DestroyChunk
¯¯) 5
(
¯¯5 6
	PoolChunk
¯¯6 ?
<
¯¯? @
byte
¯¯@ D
[
¯¯D E
]
¯¯E F
>
¯¯F G
chunk
¯¯H M
)
¯¯M N
{
˘˘ 	
for
˙˙ 
(
˙˙ 
int
˙˙ 
i
˙˙ 
=
˙˙ 
$num
˙˙ 
;
˙˙ 
i
˙˙ 
<
˙˙ 
this
˙˙  $
.
˙˙$ %
memoryChunks
˙˙% 1
.
˙˙1 2
Count
˙˙2 7
;
˙˙7 8
i
˙˙9 :
++
˙˙: <
)
˙˙< =
{
˚˚ 
MemoryChunk
¸¸ 
memoryChunk
¸¸ '
=
¸¸( )
this
¸¸* .
.
¸¸. /
memoryChunks
¸¸/ ;
[
¸¸; <
i
¸¸< =
]
¸¸= >
;
¸¸> ?
if
˝˝ 
(
˝˝ 
ReferenceEquals
˝˝ #
(
˝˝# $
chunk
˝˝$ )
.
˝˝) *
Memory
˝˝* 0
,
˝˝0 1
memoryChunk
˝˝2 =
.
˝˝= >
Bytes
˝˝> C
)
˝˝C D
)
˝˝D E
{
˛˛ 
this
ˇˇ 
.
ˇˇ 
memoryChunks
ˇˇ %
.
ˇˇ% &
Remove
ˇˇ& ,
(
ˇˇ, -
memoryChunk
ˇˇ- 8
)
ˇˇ8 9
;
ˇˇ9 :
memoryChunk
ÄÄ 
.
ÄÄ  
Dispose
ÄÄ  '
(
ÄÄ' (
)
ÄÄ( )
;
ÄÄ) *
break
ÅÅ 
;
ÅÅ 
}
ÇÇ 
}
ÉÉ 
}
ÑÑ 	
sealed
ÜÜ 
class
ÜÜ 
MemoryChunk
ÜÜ  
:
ÜÜ! "
IDisposable
ÜÜ# .
{
áá 	
internal
àà 
byte
àà 
[
àà 
]
àà 
Bytes
àà !
;
àà! "
GCHandle
ââ 
handle
ââ 
;
ââ 
internal
ãã 
MemoryChunk
ãã  
(
ãã  !
int
ãã! $
size
ãã% )
)
ãã) *
{
åå 
this
çç 
.
çç 
Bytes
çç 
=
çç 
new
çç  
byte
çç! %
[
çç% &
size
çç& *
]
çç* +
;
çç+ ,
this
éé 
.
éé 
handle
éé 
=
éé 
GCHandle
éé &
.
éé& '
Alloc
éé' ,
(
éé, -
this
éé- 1
.
éé1 2
Bytes
éé2 7
,
éé7 8
GCHandleType
éé9 E
.
ééE F
Pinned
ééF L
)
ééL M
;
ééM N
}
èè 
void
ëë 
Release
ëë 
(
ëë 
)
ëë 
{
íí 
if
ìì 
(
ìì 
this
ìì 
.
ìì 
handle
ìì 
.
ìì  
IsAllocated
ìì  +
)
ìì+ ,
{
îî 
try
ïï 
{
ññ 
this
óó 
.
óó 
handle
óó #
.
óó# $
Free
óó$ (
(
óó( )
)
óó) *
;
óó* +
}
òò 
catch
ôô 
(
ôô '
InvalidOperationException
ôô 4
)
ôô4 5
{
öö 
}
úú 
}
ùù 
this
ûû 
.
ûû 
Bytes
ûû 
=
ûû 
null
ûû !
;
ûû! "
}
üü 
public
°° 
void
°° 
Dispose
°° 
(
°°  
)
°°  !
{
¢¢ 
this
££ 
.
££ 
Release
££ 
(
££ 
)
££ 
;
££ 
GC
§§ 
.
§§ 
SuppressFinalize
§§ #
(
§§# $
this
§§$ (
)
§§( )
;
§§) *
}
•• 
~
ßß 
MemoryChunk
ßß 
(
ßß 
)
ßß 
{
®® 
this
©© 
.
©© 
Release
©© 
(
©© 
)
©© 
;
©© 
}
™™ 
}
´´ 	
}
¨¨ 
}≠≠ ¿¢
\C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolChunk.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealedPP 

classPP 
	PoolChunkPP 
<PP 
TPP 
>PP 
:PP 
IPoolChunkMetricPP  0
{QQ 
constRR 
intRR 
IntegerSizeMinusOneRR %
=RR& '
sizeofRR( .
(RR. /
intRR/ 2
)RR2 3
*RR4 5
$numRR6 7
-RR8 9
$numRR: ;
;RR; <
internalTT 
readonlyTT 
	PoolArenaTT #
<TT# $
TTT$ %
>TT% &
ArenaTT' ,
;TT, -
internalUU 
readonlyUU 
TUU 
MemoryUU "
;UU" #
internalVV 
readonlyVV 
boolVV 
UnpooledVV '
;VV' (
internalWW 
readonlyWW 
intWW 
OffsetWW $
;WW$ %
readonlyYY 
sbyteYY 
[YY 
]YY 
	memoryMapYY "
;YY" #
readonlyZZ 
sbyteZZ 
[ZZ 
]ZZ 
depthMapZZ !
;ZZ! "
readonly[[ 
PoolSubpage[[ 
<[[ 
T[[ 
>[[ 
[[[  
][[  !
subpages[[" *
;[[* +
readonly]] 
int]] 
subpageOverflowMask]] (
;]]( )
readonly^^ 
int^^ 
pageSize^^ 
;^^ 
readonly__ 
int__ 

pageShifts__ 
;__  
readonly`` 
int`` 
maxOrder`` 
;`` 
readonlyaa 
intaa 
	chunkSizeaa 
;aa 
readonlybb 
intbb 
log2ChunkSizebb "
;bb" #
readonlycc 
intcc 
maxSubpageAllocscc %
;cc% &
readonlyee 
sbyteee 
unusableee 
;ee  
intgg 
	freeBytesgg 
;gg 
internalii 
PoolChunkListii 
<ii 
Tii  
>ii  !
Parentii" (
;ii( )
internaljj 
	PoolChunkjj 
<jj 
Tjj 
>jj 
Prevjj "
;jj" #
internalkk 
	PoolChunkkk 
<kk 
Tkk 
>kk 
Nextkk "
;kk" #
internalpp 
	PoolChunkpp 
(pp 
	PoolArenapp $
<pp$ %
Tpp% &
>pp& '
arenapp( -
,pp- .
Tpp/ 0
memorypp1 7
,pp7 8
intpp9 <
pageSizepp= E
,ppE F
intppG J
maxOrderppK S
,ppS T
intppU X

pageShiftsppY c
,ppc d
intppe h
	chunkSizeppi r
,ppr s
intppt w
offsetppx ~
)pp~ 
{qq 	
Contractrr 
.rr 
Requiresrr 
(rr 
maxOrderrr &
<rr' (
$numrr) +
,rr+ ,
$strrr- P
+rrQ R
maxOrderrrS [
)rr[ \
;rr\ ]
thistt 
.tt 
Unpooledtt 
=tt 
falsett !
;tt! "
thisuu 
.uu 
Arenauu 
=uu 
arenauu 
;uu 
thisvv 
.vv 
Memoryvv 
=vv 
memoryvv  
;vv  !
thisww 
.ww 
pageSizeww 
=ww 
pageSizeww $
;ww$ %
thisxx 
.xx 

pageShiftsxx 
=xx 

pageShiftsxx (
;xx( )
thisyy 
.yy 
maxOrderyy 
=yy 
maxOrderyy $
;yy$ %
thiszz 
.zz 
	chunkSizezz 
=zz 
	chunkSizezz &
;zz& '
this{{ 
.{{ 
Offset{{ 
={{ 
offset{{  
;{{  !
this|| 
.|| 
unusable|| 
=|| 
(|| 
sbyte|| "
)||" #
(||# $
maxOrder||$ ,
+||- .
$num||/ 0
)||0 1
;||1 2
this}} 
.}} 
log2ChunkSize}} 
=}}  
Log2}}! %
(}}% &
	chunkSize}}& /
)}}/ 0
;}}0 1
this~~ 
.~~ 
subpageOverflowMask~~ $
=~~% &
~~~' (
(~~( )
pageSize~~) 1
-~~2 3
$num~~4 5
)~~5 6
;~~6 7
this 
. 
	freeBytes 
= 
	chunkSize &
;& '
Contract
ÅÅ 
.
ÅÅ 
Assert
ÅÅ 
(
ÅÅ 
maxOrder
ÅÅ $
<
ÅÅ% &
$num
ÅÅ' )
,
ÅÅ) *
$str
ÅÅ+ N
+
ÅÅO P
maxOrder
ÅÅQ Y
)
ÅÅY Z
;
ÅÅZ [
this
ÇÇ 
.
ÇÇ 
maxSubpageAllocs
ÇÇ !
=
ÇÇ" #
$num
ÇÇ$ %
<<
ÇÇ& (
maxOrder
ÇÇ) 1
;
ÇÇ1 2
this
ÖÖ 
.
ÖÖ 
	memoryMap
ÖÖ 
=
ÖÖ 
new
ÖÖ  
sbyte
ÖÖ! &
[
ÖÖ& '
this
ÖÖ' +
.
ÖÖ+ ,
maxSubpageAllocs
ÖÖ, <
<<
ÖÖ= ?
$num
ÖÖ@ A
]
ÖÖA B
;
ÖÖB C
this
ÜÜ 
.
ÜÜ 
depthMap
ÜÜ 
=
ÜÜ 
new
ÜÜ 
sbyte
ÜÜ  %
[
ÜÜ% &
this
ÜÜ& *
.
ÜÜ* +
	memoryMap
ÜÜ+ 4
.
ÜÜ4 5
Length
ÜÜ5 ;
]
ÜÜ; <
;
ÜÜ< =
int
áá 
memoryMapIndex
áá 
=
áá  
$num
áá! "
;
áá" #
for
àà 
(
àà 
int
àà 
d
àà 
=
àà 
$num
àà 
;
àà 
d
àà 
<=
àà  
maxOrder
àà! )
;
àà) *
++
àà+ -
d
àà- .
)
àà. /
{
ââ 
int
ãã 
depth
ãã 
=
ãã 
$num
ãã 
<<
ãã  
d
ãã! "
;
ãã" #
for
åå 
(
åå 
int
åå 
p
åå 
=
åå 
$num
åå 
;
åå 
p
åå  !
<
åå" #
depth
åå$ )
;
åå) *
++
åå+ -
p
åå- .
)
åå. /
{
çç 
this
èè 
.
èè 
	memoryMap
èè "
[
èè" #
memoryMapIndex
èè# 1
]
èè1 2
=
èè3 4
(
èè5 6
sbyte
èè6 ;
)
èè; <
d
èè< =
;
èè= >
this
êê 
.
êê 
depthMap
êê !
[
êê! "
memoryMapIndex
êê" 0
]
êê0 1
=
êê2 3
(
êê4 5
sbyte
êê5 :
)
êê: ;
d
êê; <
;
êê< =
memoryMapIndex
ëë "
++
ëë" $
;
ëë$ %
}
íí 
}
ìì 
this
ïï 
.
ïï 
subpages
ïï 
=
ïï 
this
ïï  
.
ïï  !
NewSubpageArray
ïï! 0
(
ïï0 1
this
ïï1 5
.
ïï5 6
maxSubpageAllocs
ïï6 F
)
ïïF G
;
ïïG H
}
ññ 	
internal
öö 
	PoolChunk
öö 
(
öö 
	PoolArena
öö $
<
öö$ %
T
öö% &
>
öö& '
arena
öö( -
,
öö- .
T
öö/ 0
memory
öö1 7
,
öö7 8
int
öö9 <
size
öö= A
,
ööA B
int
ööC F
offset
ööG M
)
ööM N
{
õõ 	
this
úú 
.
úú 
Unpooled
úú 
=
úú 
true
úú  
;
úú  !
this
ùù 
.
ùù 
Arena
ùù 
=
ùù 
arena
ùù 
;
ùù 
this
ûû 
.
ûû 
Memory
ûû 
=
ûû 
memory
ûû  
;
ûû  !
this
üü 
.
üü 
Offset
üü 
=
üü 
offset
üü  
;
üü  !
this
†† 
.
†† 
	memoryMap
†† 
=
†† 
null
†† !
;
††! "
this
°° 
.
°° 
depthMap
°° 
=
°° 
null
°°  
;
°°  !
this
¢¢ 
.
¢¢ 
subpages
¢¢ 
=
¢¢ 
null
¢¢  
;
¢¢  !
this
££ 
.
££ !
subpageOverflowMask
££ $
=
££% &
$num
££' (
;
££( )
this
§§ 
.
§§ 
pageSize
§§ 
=
§§ 
$num
§§ 
;
§§ 
this
•• 
.
•• 

pageShifts
•• 
=
•• 
$num
•• 
;
••  
this
¶¶ 
.
¶¶ 
maxOrder
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
this
ßß 
.
ßß 
unusable
ßß 
=
ßß 
(
ßß 
sbyte
ßß "
)
ßß" #
(
ßß# $
this
ßß$ (
.
ßß( )
maxOrder
ßß) 1
+
ßß2 3
$num
ßß4 5
)
ßß5 6
;
ßß6 7
this
®® 
.
®® 
	chunkSize
®® 
=
®® 
size
®® !
;
®®! "
this
©© 
.
©© 
log2ChunkSize
©© 
=
©©  
IntegerExtensions
©©! 2
.
©©2 3
Log2
©©3 7
(
©©7 8
this
©©8 <
.
©©< =
	chunkSize
©©= F
)
©©F G
;
©©G H
this
™™ 
.
™™ 
maxSubpageAllocs
™™ !
=
™™" #
$num
™™$ %
;
™™% &
}
´´ 	
PoolSubpage
≠≠ 
<
≠≠ 
T
≠≠ 
>
≠≠ 
[
≠≠ 
]
≠≠ 
NewSubpageArray
≠≠ (
(
≠≠( )
int
≠≠) ,
size
≠≠- 1
)
≠≠1 2
=>
≠≠3 5
new
≠≠6 9
PoolSubpage
≠≠: E
<
≠≠E F
T
≠≠F G
>
≠≠G H
[
≠≠H I
size
≠≠I M
]
≠≠M N
;
≠≠N O
public
ØØ 
int
ØØ 
Usage
ØØ 
{
∞∞ 	
get
±± 
{
≤≤ 
int
≥≥ 
bytes
≥≥ 
;
≥≥ 
lock
¥¥ 
(
¥¥ 
this
¥¥ 
.
¥¥ 
Arena
¥¥  
)
¥¥  !
{
µµ 
bytes
∂∂ 
=
∂∂ 
this
∂∂  
.
∂∂  !
	freeBytes
∂∂! *
;
∂∂* +
}
∑∑ 
return
ππ 
this
ππ 
.
ππ 
GetUsage
ππ $
(
ππ$ %
bytes
ππ% *
)
ππ* +
;
ππ+ ,
}
∫∫ 
}
ªª 	
int
ΩΩ 
GetUsage
ΩΩ 
(
ΩΩ 
int
ΩΩ 
bytes
ΩΩ 
)
ΩΩ 
{
ææ 	
if
øø 
(
øø 
bytes
øø 
==
øø 
$num
øø 
)
øø 
{
¿¿ 
return
¡¡ 
$num
¡¡ 
;
¡¡ 
}
¬¬ 
int
ƒƒ 
freePercentage
ƒƒ 
=
ƒƒ  
(
ƒƒ! "
int
ƒƒ" %
)
ƒƒ% &
(
ƒƒ& '
bytes
ƒƒ' ,
*
ƒƒ- .
$num
ƒƒ/ 3
/
ƒƒ4 5
this
ƒƒ6 :
.
ƒƒ: ;
	ChunkSize
ƒƒ; D
)
ƒƒD E
;
ƒƒE F
if
≈≈ 
(
≈≈ 
freePercentage
≈≈ 
==
≈≈ !
$num
≈≈" #
)
≈≈# $
{
∆∆ 
return
«« 
$num
«« 
;
«« 
}
»» 
return
   
$num
   
-
   
freePercentage
   '
;
  ' (
}
ÀÀ 	
internal
ŒŒ 
long
ŒŒ 
Allocate
ŒŒ 
(
ŒŒ 
int
ŒŒ "
normCapacity
ŒŒ# /
)
ŒŒ/ 0
{
œœ 	
if
–– 
(
–– 
(
–– 
normCapacity
–– 
&
–– 
this
––  $
.
––$ %!
subpageOverflowMask
––% 8
)
––8 9
!=
––: <
$num
––= >
)
––> ?
{
—— 
return
”” 
this
”” 
.
”” 
AllocateRun
”” '
(
””' (
normCapacity
””( 4
)
””4 5
;
””5 6
}
‘‘ 
else
’’ 
{
÷÷ 
return
◊◊ 
this
◊◊ 
.
◊◊ 
AllocateSubpage
◊◊ +
(
◊◊+ ,
normCapacity
◊◊, 8
)
◊◊8 9
;
◊◊9 :
}
ÿÿ 
}
ŸŸ 	
void
‰‰  
UpdateParentsAlloc
‰‰ 
(
‰‰  
int
‰‰  #
id
‰‰$ &
)
‰‰& '
{
ÂÂ 	
while
ÊÊ 
(
ÊÊ 
id
ÊÊ 
>
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
{
ÁÁ 
int
ËË 
parentId
ËË 
=
ËË 
id
ËË !
.
ËË! "
RightUShift
ËË" -
(
ËË- .
$num
ËË. /
)
ËË/ 0
;
ËË0 1
sbyte
ÈÈ 
val1
ÈÈ 
=
ÈÈ 
this
ÈÈ !
.
ÈÈ! "
Value
ÈÈ" '
(
ÈÈ' (
id
ÈÈ( *
)
ÈÈ* +
;
ÈÈ+ ,
sbyte
ÍÍ 
val2
ÍÍ 
=
ÍÍ 
this
ÍÍ !
.
ÍÍ! "
Value
ÍÍ" '
(
ÍÍ' (
id
ÍÍ( *
^
ÍÍ+ ,
$num
ÍÍ- .
)
ÍÍ. /
;
ÍÍ/ 0
sbyte
ÎÎ 
val
ÎÎ 
=
ÎÎ 
val1
ÎÎ  
<
ÎÎ! "
val2
ÎÎ# '
?
ÎÎ( )
val1
ÎÎ* .
:
ÎÎ/ 0
val2
ÎÎ1 5
;
ÎÎ5 6
this
ÏÏ 
.
ÏÏ 
SetValue
ÏÏ 
(
ÏÏ 
parentId
ÏÏ &
,
ÏÏ& '
val
ÏÏ( +
)
ÏÏ+ ,
;
ÏÏ, -
id
ÌÌ 
=
ÌÌ 
parentId
ÌÌ 
;
ÌÌ 
}
ÓÓ 
}
ÔÔ 	
void
˘˘ 
UpdateParentsFree
˘˘ 
(
˘˘ 
int
˘˘ "
id
˘˘# %
)
˘˘% &
{
˙˙ 	
int
˚˚ 
logChild
˚˚ 
=
˚˚ 
this
˚˚ 
.
˚˚  
Depth
˚˚  %
(
˚˚% &
id
˚˚& (
)
˚˚( )
+
˚˚* +
$num
˚˚, -
;
˚˚- .
while
¸¸ 
(
¸¸ 
id
¸¸ 
>
¸¸ 
$num
¸¸ 
)
¸¸ 
{
˝˝ 
int
˛˛ 
parentId
˛˛ 
=
˛˛ 
id
˛˛ !
.
˛˛! "
RightUShift
˛˛" -
(
˛˛- .
$num
˛˛. /
)
˛˛/ 0
;
˛˛0 1
sbyte
ˇˇ 
val1
ˇˇ 
=
ˇˇ 
this
ˇˇ !
.
ˇˇ! "
Value
ˇˇ" '
(
ˇˇ' (
id
ˇˇ( *
)
ˇˇ* +
;
ˇˇ+ ,
sbyte
ÄÄ 
val2
ÄÄ 
=
ÄÄ 
this
ÄÄ !
.
ÄÄ! "
Value
ÄÄ" '
(
ÄÄ' (
id
ÄÄ( *
^
ÄÄ+ ,
$num
ÄÄ- .
)
ÄÄ. /
;
ÄÄ/ 0
logChild
ÅÅ 
-=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
if
ÉÉ 
(
ÉÉ 
val1
ÉÉ 
==
ÉÉ 
logChild
ÉÉ $
&&
ÉÉ% '
val2
ÉÉ( ,
==
ÉÉ- /
logChild
ÉÉ0 8
)
ÉÉ8 9
{
ÑÑ 
this
ÖÖ 
.
ÖÖ 
SetValue
ÖÖ !
(
ÖÖ! "
parentId
ÖÖ" *
,
ÖÖ* +
(
ÖÖ, -
sbyte
ÖÖ- 2
)
ÖÖ2 3
(
ÖÖ3 4
logChild
ÖÖ4 <
-
ÖÖ= >
$num
ÖÖ? @
)
ÖÖ@ A
)
ÖÖA B
;
ÖÖB C
}
ÜÜ 
else
áá 
{
àà 
sbyte
ââ 
val
ââ 
=
ââ 
val1
ââ  $
<
ââ% &
val2
ââ' +
?
ââ, -
val1
ââ. 2
:
ââ3 4
val2
ââ5 9
;
ââ9 :
this
ää 
.
ää 
SetValue
ää !
(
ää! "
parentId
ää" *
,
ää* +
val
ää, /
)
ää/ 0
;
ää0 1
}
ãã 
id
çç 
=
çç 
parentId
çç 
;
çç 
}
éé 
}
èè 	
int
ôô 
AllocateNode
ôô 
(
ôô 
int
ôô 
d
ôô 
)
ôô 
{
öö 	
int
õõ 
id
õõ 
=
õõ 
$num
õõ 
;
õõ 
int
úú 
initial
úú 
=
úú 
-
úú 
(
úú 
$num
úú 
<<
úú  
d
úú! "
)
úú" #
;
úú# $
sbyte
ùù 
val
ùù 
=
ùù 
this
ùù 
.
ùù 
Value
ùù "
(
ùù" #
id
ùù# %
)
ùù% &
;
ùù& '
if
ûû 
(
ûû 
val
ûû 
>
ûû 
d
ûû 
)
ûû 
{
üü 
return
°° 
-
°° 
$num
°° 
;
°° 
}
¢¢ 
while
££ 
(
££ 
val
££ 
<
££ 
d
££ 
||
££ 
(
££ 
id
££ !
&
££" #
initial
££$ +
)
££+ ,
==
££- /
$num
££0 1
)
££1 2
{
§§ 
id
¶¶ 
<<=
¶¶ 
$num
¶¶ 
;
¶¶ 
val
ßß 
=
ßß 
this
ßß 
.
ßß 
Value
ßß  
(
ßß  !
id
ßß! #
)
ßß# $
;
ßß$ %
if
®® 
(
®® 
val
®® 
>
®® 
d
®® 
)
®® 
{
©© 
id
™™ 
^=
™™ 
$num
™™ 
;
™™ 
val
´´ 
=
´´ 
this
´´ 
.
´´ 
Value
´´ $
(
´´$ %
id
´´% '
)
´´' (
;
´´( )
}
¨¨ 
}
≠≠ 
sbyte
ÆÆ 
value
ÆÆ 
=
ÆÆ 
this
ÆÆ 
.
ÆÆ 
Value
ÆÆ $
(
ÆÆ$ %
id
ÆÆ% '
)
ÆÆ' (
;
ÆÆ( )
Debug
ØØ 
.
ØØ 
Assert
ØØ 
(
ØØ 
value
ØØ 
==
ØØ !
d
ØØ" #
&&
ØØ$ &
(
ØØ' (
id
ØØ( *
&
ØØ+ ,
initial
ØØ- 4
)
ØØ4 5
==
ØØ6 8
$num
ØØ9 :
<<
ØØ; =
d
ØØ> ?
,
ØØ? @
$"
ØØA C
$str
ØØC I
{
ØØI J
value
ØØJ O
}
ØØO P
$str
ØØP a
{
ØØa b
id
ØØb d
&
ØØe f
initial
ØØg n
}
ØØn o
$str
ØØo u
{
ØØu v
d
ØØv w
}
ØØw x
"
ØØx y
)
ØØy z
;
ØØz {
this
∞∞ 
.
∞∞ 
SetValue
∞∞ 
(
∞∞ 
id
∞∞ 
,
∞∞ 
this
∞∞ "
.
∞∞" #
unusable
∞∞# +
)
∞∞+ ,
;
∞∞, -
this
±± 
.
±±  
UpdateParentsAlloc
±± #
(
±±# $
id
±±$ &
)
±±& '
;
±±' (
return
≤≤ 
id
≤≤ 
;
≤≤ 
}
≥≥ 	
long
ºº 
AllocateRun
ºº 
(
ºº 
int
ºº 
normCapacity
ºº )
)
ºº) *
{
ΩΩ 	
int
ææ 
d
ææ 
=
ææ 
this
ææ 
.
ææ 
maxOrder
ææ !
-
ææ" #
(
ææ$ %
IntegerExtensions
ææ% 6
.
ææ6 7
Log2
ææ7 ;
(
ææ; <
normCapacity
ææ< H
)
ææH I
-
ææJ K
this
ææL P
.
ææP Q

pageShifts
ææQ [
)
ææ[ \
;
ææ\ ]
int
øø 
id
øø 
=
øø 
this
øø 
.
øø 
AllocateNode
øø &
(
øø& '
d
øø' (
)
øø( )
;
øø) *
if
¿¿ 
(
¿¿ 
id
¿¿ 
<
¿¿ 
$num
¿¿ 
)
¿¿ 
{
¡¡ 
return
¬¬ 
id
¬¬ 
;
¬¬ 
}
√√ 
this
ƒƒ 
.
ƒƒ 
	freeBytes
ƒƒ 
-=
ƒƒ 
this
ƒƒ "
.
ƒƒ" #
	RunLength
ƒƒ# ,
(
ƒƒ, -
id
ƒƒ- /
)
ƒƒ/ 0
;
ƒƒ0 1
return
≈≈ 
id
≈≈ 
;
≈≈ 
}
∆∆ 	
long
–– 
AllocateSubpage
–– 
(
–– 
int
––  
normCapacity
––! -
)
––- .
{
—— 	
PoolSubpage
‘‘ 
<
‘‘ 
T
‘‘ 
>
‘‘ 
head
‘‘ 
=
‘‘  !
this
‘‘" &
.
‘‘& '
Arena
‘‘' ,
.
‘‘, -!
FindSubpagePoolHead
‘‘- @
(
‘‘@ A
normCapacity
‘‘A M
)
‘‘M N
;
‘‘N O
lock
’’ 
(
’’ 
head
’’ 
)
’’ 
{
÷÷ 
int
◊◊ 
d
◊◊ 
=
◊◊ 
this
◊◊ 
.
◊◊ 
maxOrder
◊◊ %
;
◊◊% &
int
ÿÿ 
id
ÿÿ 
=
ÿÿ 
this
ÿÿ 
.
ÿÿ 
AllocateNode
ÿÿ *
(
ÿÿ* +
d
ÿÿ+ ,
)
ÿÿ, -
;
ÿÿ- .
if
ŸŸ 
(
ŸŸ 
id
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
{
⁄⁄ 
return
€€ 
id
€€ 
;
€€ 
}
‹‹ 
PoolSubpage
ﬁﬁ 
<
ﬁﬁ 
T
ﬁﬁ 
>
ﬁﬁ 
[
ﬁﬁ 
]
ﬁﬁ  
subpages
ﬁﬁ! )
=
ﬁﬁ* +
this
ﬁﬁ, 0
.
ﬁﬁ0 1
subpages
ﬁﬁ1 9
;
ﬁﬁ9 :
int
ﬂﬂ 
pageSize
ﬂﬂ 
=
ﬂﬂ 
this
ﬂﬂ #
.
ﬂﬂ# $
pageSize
ﬂﬂ$ ,
;
ﬂﬂ, -
this
·· 
.
·· 
	freeBytes
·· 
-=
·· !
pageSize
··" *
;
··* +
int
„„ 

subpageIdx
„„ 
=
„„  
this
„„! %
.
„„% &

SubpageIdx
„„& 0
(
„„0 1
id
„„1 3
)
„„3 4
;
„„4 5
PoolSubpage
‰‰ 
<
‰‰ 
T
‰‰ 
>
‰‰ 
subpage
‰‰ &
=
‰‰' (
subpages
‰‰) 1
[
‰‰1 2

subpageIdx
‰‰2 <
]
‰‰< =
;
‰‰= >
if
ÂÂ 
(
ÂÂ 
subpage
ÂÂ 
==
ÂÂ 
null
ÂÂ #
)
ÂÂ# $
{
ÊÊ 
subpage
ÁÁ 
=
ÁÁ 
new
ÁÁ !
PoolSubpage
ÁÁ" -
<
ÁÁ- .
T
ÁÁ. /
>
ÁÁ/ 0
(
ÁÁ0 1
head
ÁÁ1 5
,
ÁÁ5 6
this
ÁÁ7 ;
,
ÁÁ; <
id
ÁÁ= ?
,
ÁÁ? @
this
ÁÁA E
.
ÁÁE F
	RunOffset
ÁÁF O
(
ÁÁO P
id
ÁÁP R
)
ÁÁR S
,
ÁÁS T
pageSize
ÁÁU ]
,
ÁÁ] ^
normCapacity
ÁÁ_ k
)
ÁÁk l
;
ÁÁl m
subpages
ËË 
[
ËË 

subpageIdx
ËË '
]
ËË' (
=
ËË) *
subpage
ËË+ 2
;
ËË2 3
}
ÈÈ 
else
ÍÍ 
{
ÎÎ 
subpage
ÏÏ 
.
ÏÏ 
Init
ÏÏ  
(
ÏÏ  !
head
ÏÏ! %
,
ÏÏ% &
normCapacity
ÏÏ' 3
)
ÏÏ3 4
;
ÏÏ4 5
}
ÌÌ 
return
ÔÔ 
subpage
ÔÔ 
.
ÔÔ 
Allocate
ÔÔ '
(
ÔÔ' (
)
ÔÔ( )
;
ÔÔ) *
}
 
}
ÒÒ 	
internal
¸¸ 
void
¸¸ 
Free
¸¸ 
(
¸¸ 
long
¸¸ 
handle
¸¸  &
)
¸¸& '
{
˝˝ 	
int
˛˛ 
memoryMapIdx
˛˛ 
=
˛˛ 
MemoryMapIdx
˛˛ +
(
˛˛+ ,
handle
˛˛, 2
)
˛˛2 3
;
˛˛3 4
int
ˇˇ 
	bitmapIdx
ˇˇ 
=
ˇˇ 
	BitmapIdx
ˇˇ %
(
ˇˇ% &
handle
ˇˇ& ,
)
ˇˇ, -
;
ˇˇ- .
if
ÅÅ 
(
ÅÅ 
	bitmapIdx
ÅÅ 
!=
ÅÅ 
$num
ÅÅ 
)
ÅÅ 
{
ÇÇ 
PoolSubpage
ÑÑ 
<
ÑÑ 
T
ÑÑ 
>
ÑÑ 
subpage
ÑÑ &
=
ÑÑ' (
this
ÑÑ) -
.
ÑÑ- .
subpages
ÑÑ. 6
[
ÑÑ6 7
this
ÑÑ7 ;
.
ÑÑ; <

SubpageIdx
ÑÑ< F
(
ÑÑF G
memoryMapIdx
ÑÑG S
)
ÑÑS T
]
ÑÑT U
;
ÑÑU V
Debug
ÖÖ 
.
ÖÖ 
Assert
ÖÖ 
(
ÖÖ 
subpage
ÖÖ $
!=
ÖÖ% '
null
ÖÖ( ,
&&
ÖÖ- /
subpage
ÖÖ0 7
.
ÖÖ7 8
DoNotDestroy
ÖÖ8 D
)
ÖÖD E
;
ÖÖE F
PoolSubpage
ââ 
<
ââ 
T
ââ 
>
ââ 
head
ââ #
=
ââ$ %
this
ââ& *
.
ââ* +
Arena
ââ+ 0
.
ââ0 1!
FindSubpagePoolHead
ââ1 D
(
ââD E
subpage
ââE L
.
ââL M
ElemSize
ââM U
)
ââU V
;
ââV W
lock
ää 
(
ää 
head
ää 
)
ää 
{
ãã 
if
åå 
(
åå 
subpage
åå 
.
åå  
Free
åå  $
(
åå$ %
head
åå% )
,
åå) *
	bitmapIdx
åå+ 4
&
åå5 6
$num
åå7 A
)
ååA B
)
ååB C
{
çç 
return
éé 
;
éé 
}
èè 
}
êê 
}
ëë 
this
íí 
.
íí 
	freeBytes
íí 
+=
íí 
this
íí "
.
íí" #
	RunLength
íí# ,
(
íí, -
memoryMapIdx
íí- 9
)
íí9 :
;
íí: ;
this
ìì 
.
ìì 
SetValue
ìì 
(
ìì 
memoryMapIdx
ìì &
,
ìì& '
this
ìì( ,
.
ìì, -
Depth
ìì- 2
(
ìì2 3
memoryMapIdx
ìì3 ?
)
ìì? @
)
ìì@ A
;
ììA B
this
îî 
.
îî 
UpdateParentsFree
îî "
(
îî" #
memoryMapIdx
îî# /
)
îî/ 0
;
îî0 1
}
ïï 	
internal
óó 
void
óó 
InitBuf
óó 
(
óó 
PooledByteBuffer
óó .
<
óó. /
T
óó/ 0
>
óó0 1
buf
óó2 5
,
óó5 6
long
óó7 ;
handle
óó< B
,
óóB C
int
óóD G
reqCapacity
óóH S
)
óóS T
{
òò 	
int
ôô 
memoryMapIdx
ôô 
=
ôô 
MemoryMapIdx
ôô +
(
ôô+ ,
handle
ôô, 2
)
ôô2 3
;
ôô3 4
int
öö 
	bitmapIdx
öö 
=
öö 
	BitmapIdx
öö %
(
öö% &
handle
öö& ,
)
öö, -
;
öö- .
if
õõ 
(
õõ 
	bitmapIdx
õõ 
==
õõ 
$num
õõ 
)
õõ 
{
úú 
sbyte
ùù 
val
ùù 
=
ùù 
this
ùù  
.
ùù  !
Value
ùù! &
(
ùù& '
memoryMapIdx
ùù' 3
)
ùù3 4
;
ùù4 5
Debug
ûû 
.
ûû 
Assert
ûû 
(
ûû 
val
ûû  
==
ûû! #
this
ûû$ (
.
ûû( )
unusable
ûû) 1
,
ûû1 2
val
ûû3 6
.
ûû6 7
ToString
ûû7 ?
(
ûû? @
)
ûû@ A
)
ûûA B
;
ûûB C
buf
üü 
.
üü 
Init
üü 
(
üü 
this
üü 
,
üü 
handle
üü %
,
üü% &
this
üü' +
.
üü+ ,
	RunOffset
üü, 5
(
üü5 6
memoryMapIdx
üü6 B
)
üüB C
+
üüD E
this
üüF J
.
üüJ K
Offset
üüK Q
,
üüQ R
reqCapacity
üüS ^
,
üü^ _
this
üü` d
.
üüd e
	RunLength
üüe n
(
üün o
memoryMapIdx
üüo {
)
üü{ |
,
üü| }
this
†† 
.
†† 
Arena
†† 
.
†† 
Parent
†† %
.
††% &
ThreadCache
††& 1
<
††1 2
T
††2 3
>
††3 4
(
††4 5
)
††5 6
)
††6 7
;
††7 8
}
°° 
else
¢¢ 
{
££ 
this
§§ 
.
§§  
InitBufWithSubpage
§§ '
(
§§' (
buf
§§( +
,
§§+ ,
handle
§§- 3
,
§§3 4
	bitmapIdx
§§5 >
,
§§> ?
reqCapacity
§§@ K
)
§§K L
;
§§L M
}
•• 
}
¶¶ 	
internal
®® 
void
®®  
InitBufWithSubpage
®® (
(
®®( )
PooledByteBuffer
®®) 9
<
®®9 :
T
®®: ;
>
®®; <
buf
®®= @
,
®®@ A
long
®®B F
handle
®®G M
,
®®M N
int
®®O R
reqCapacity
®®S ^
)
®®^ _
=>
®®` b
this
©© 
.
©©  
InitBufWithSubpage
©© #
(
©©# $
buf
©©$ '
,
©©' (
handle
©©) /
,
©©/ 0
	BitmapIdx
©©1 :
(
©©: ;
handle
©©; A
)
©©A B
,
©©B C
reqCapacity
©©D O
)
©©O P
;
©©P Q
void
´´  
InitBufWithSubpage
´´ 
(
´´  
PooledByteBuffer
´´  0
<
´´0 1
T
´´1 2
>
´´2 3
buf
´´4 7
,
´´7 8
long
´´9 =
handle
´´> D
,
´´D E
int
´´F I
	bitmapIdx
´´J S
,
´´S T
int
´´U X
reqCapacity
´´Y d
)
´´d e
{
¨¨ 	
Contract
≠≠ 
.
≠≠ 
Assert
≠≠ 
(
≠≠ 
	bitmapIdx
≠≠ %
!=
≠≠& (
$num
≠≠) *
)
≠≠* +
;
≠≠+ ,
int
ØØ 
memoryMapIdx
ØØ 
=
ØØ 
MemoryMapIdx
ØØ +
(
ØØ+ ,
handle
ØØ, 2
)
ØØ2 3
;
ØØ3 4
PoolSubpage
±± 
<
±± 
T
±± 
>
±± 
subpage
±± "
=
±±# $
this
±±% )
.
±±) *
subpages
±±* 2
[
±±2 3
this
±±3 7
.
±±7 8

SubpageIdx
±±8 B
(
±±B C
memoryMapIdx
±±C O
)
±±O P
]
±±P Q
;
±±Q R
Contract
≤≤ 
.
≤≤ 
Assert
≤≤ 
(
≤≤ 
subpage
≤≤ #
.
≤≤# $
DoNotDestroy
≤≤$ 0
)
≤≤0 1
;
≤≤1 2
Contract
≥≥ 
.
≥≥ 
Assert
≥≥ 
(
≥≥ 
reqCapacity
≥≥ '
<=
≥≥( *
subpage
≥≥+ 2
.
≥≥2 3
ElemSize
≥≥3 ;
)
≥≥; <
;
≥≥< =
buf
µµ 
.
µµ 
Init
µµ 
(
µµ 
this
∂∂ 
,
∂∂ 
handle
∂∂ 
,
∂∂ 
this
∑∑ 
.
∑∑ 
	RunOffset
∑∑ 
(
∑∑ 
memoryMapIdx
∑∑ +
)
∑∑+ ,
+
∑∑- .
(
∑∑/ 0
	bitmapIdx
∑∑0 9
&
∑∑: ;
$num
∑∑< F
)
∑∑F G
*
∑∑H I
subpage
∑∑J Q
.
∑∑Q R
ElemSize
∑∑R Z
+
∑∑[ \
this
∑∑] a
.
∑∑a b
Offset
∑∑b h
,
∑∑h i
reqCapacity
∏∏ 
,
∏∏ 
subpage
∏∏ $
.
∏∏$ %
ElemSize
∏∏% -
,
∏∏- .
this
∏∏/ 3
.
∏∏3 4
Arena
∏∏4 9
.
∏∏9 :
Parent
∏∏: @
.
∏∏@ A
ThreadCache
∏∏A L
<
∏∏L M
T
∏∏M N
>
∏∏N O
(
∏∏O P
)
∏∏P Q
)
∏∏Q R
;
∏∏R S
}
ππ 	
sbyte
ªª 
Value
ªª 
(
ªª 
int
ªª 
id
ªª 
)
ªª 
=>
ªª 
this
ªª #
.
ªª# $
	memoryMap
ªª$ -
[
ªª- .
id
ªª. 0
]
ªª0 1
;
ªª1 2
void
ΩΩ 
SetValue
ΩΩ 
(
ΩΩ 
int
ΩΩ 
id
ΩΩ 
,
ΩΩ 
sbyte
ΩΩ #
val
ΩΩ$ '
)
ΩΩ' (
=>
ΩΩ) +
this
ΩΩ, 0
.
ΩΩ0 1
	memoryMap
ΩΩ1 :
[
ΩΩ: ;
id
ΩΩ; =
]
ΩΩ= >
=
ΩΩ? @
val
ΩΩA D
;
ΩΩD E
sbyte
øø 
Depth
øø 
(
øø 
int
øø 
id
øø 
)
øø 
=>
øø 
this
øø #
.
øø# $
depthMap
øø$ ,
[
øø, -
id
øø- /
]
øø/ 0
;
øø0 1
static
¬¬ 
int
¬¬ 
Log2
¬¬ 
(
¬¬ 
int
¬¬ 
val
¬¬ 
)
¬¬  
=>
¬¬! #!
IntegerSizeMinusOne
¬¬$ 7
-
¬¬8 9
val
¬¬: =
.
¬¬= >"
NumberOfLeadingZeros
¬¬> R
(
¬¬R S
)
¬¬S T
;
¬¬T U
int
≈≈ 
	RunLength
≈≈ 
(
≈≈ 
int
≈≈ 
id
≈≈ 
)
≈≈ 
=>
≈≈  
$num
≈≈! "
<<
≈≈# %
this
≈≈& *
.
≈≈* +
log2ChunkSize
≈≈+ 8
-
≈≈9 :
this
≈≈; ?
.
≈≈? @
Depth
≈≈@ E
(
≈≈E F
id
≈≈F H
)
≈≈H I
;
≈≈I J
int
«« 
	RunOffset
«« 
(
«« 
int
«« 
id
«« 
)
«« 
{
»» 	
int
   
shift
   
=
   
id
   
^
   
$num
   
<<
   !
this
  " &
.
  & '
Depth
  ' ,
(
  , -
id
  - /
)
  / 0
;
  0 1
return
ÀÀ 
shift
ÀÀ 
*
ÀÀ 
this
ÀÀ 
.
ÀÀ  
	RunLength
ÀÀ  )
(
ÀÀ) *
id
ÀÀ* ,
)
ÀÀ, -
;
ÀÀ- .
}
ÃÃ 	
int
ŒŒ 

SubpageIdx
ŒŒ 
(
ŒŒ 
int
ŒŒ 
memoryMapIdx
ŒŒ '
)
ŒŒ' (
=>
ŒŒ) +
memoryMapIdx
ŒŒ, 8
^
ŒŒ9 :
this
ŒŒ; ?
.
ŒŒ? @
maxSubpageAllocs
ŒŒ@ P
;
ŒŒP Q
static
–– 
int
–– 
MemoryMapIdx
–– 
(
––  
long
––  $
handle
––% +
)
––+ ,
=>
––- /
(
––0 1
int
––1 4
)
––4 5
handle
––5 ;
;
––; <
static
““ 
int
““ 
	BitmapIdx
““ 
(
““ 
long
““ !
handle
““" (
)
““( )
=>
““* ,
(
““- .
int
““. 1
)
““1 2
handle
““2 8
.
““8 9
RightUShift
““9 D
(
““D E
IntegerExtensions
““E V
.
““V W

SizeInBits
““W a
)
““a b
;
““b c
public
‘‘ 
int
‘‘ 
	ChunkSize
‘‘ 
=>
‘‘ 
this
‘‘  $
.
‘‘$ %
	chunkSize
‘‘% .
;
‘‘. /
public
÷÷ 
int
÷÷ 
	FreeBytes
÷÷ 
=>
÷÷ 
this
÷÷  $
.
÷÷$ %
	freeBytes
÷÷% .
;
÷÷. /
public
ÿÿ 
override
ÿÿ 
string
ÿÿ 
ToString
ÿÿ '
(
ÿÿ' (
)
ÿÿ( )
{
ŸŸ 	
return
⁄⁄ 
new
⁄⁄ 
StringBuilder
⁄⁄ $
(
⁄⁄$ %
)
⁄⁄% &
.
€€ 
Append
€€ 
(
€€ 
$str
€€  
)
€€  !
.
‹‹ 
Append
‹‹ 
(
‹‹ 
RuntimeHelpers
‹‹ &
.
‹‹& '
GetHashCode
‹‹' 2
(
‹‹2 3
this
‹‹3 7
)
‹‹7 8
.
‹‹8 9
ToString
‹‹9 A
(
‹‹A B
$str
‹‹B E
)
‹‹E F
)
‹‹F G
.
›› 
Append
›› 
(
›› 
$str
›› 
)
›› 
.
ﬁﬁ 
Append
ﬁﬁ 
(
ﬁﬁ 
this
ﬁﬁ 
.
ﬁﬁ 
Usage
ﬁﬁ "
)
ﬁﬁ" #
.
ﬂﬂ 
Append
ﬂﬂ 
(
ﬂﬂ 
$str
ﬂﬂ 
)
ﬂﬂ 
.
‡‡ 
Append
‡‡ 
(
‡‡ 
this
‡‡ 
.
‡‡ 
	chunkSize
‡‡ &
-
‡‡' (
this
‡‡) -
.
‡‡- .
	freeBytes
‡‡. 7
)
‡‡7 8
.
·· 
Append
·· 
(
·· 
$char
·· 
)
·· 
.
‚‚ 
Append
‚‚ 
(
‚‚ 
this
‚‚ 
.
‚‚ 
	chunkSize
‚‚ &
)
‚‚& '
.
„„ 
Append
„„ 
(
„„ 
$char
„„ 
)
„„ 
.
‰‰ 
ToString
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰ 
}
ÂÂ 	
internal
ÁÁ 
void
ÁÁ 
Destroy
ÁÁ 
(
ÁÁ 
)
ÁÁ 
=>
ÁÁ  "
this
ÁÁ" &
.
ÁÁ& '
Arena
ÁÁ' ,
.
ÁÁ, -
DestroyChunk
ÁÁ- 9
(
ÁÁ9 :
this
ÁÁ: >
)
ÁÁ> ?
;
ÁÁ? @
}
ËË 
}ÈÈ €â
`C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolChunkList.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 
PoolChunkList 
< 
T  
>  !
:" # 
IPoolChunkListMetric$ 8
{ 
readonly 
	PoolArena 
< 
T 
> 
arena #
;# $
readonly 
PoolChunkList 
< 
T  
>  !
nextList" *
;* +
readonly 
int 
minUsage 
; 
readonly 
int 
maxUsage 
; 
readonly 
int 
maxCapacity  
;  !
	PoolChunk 
< 
T 
> 
head 
; 
PoolChunkList 
< 
T 
> 
prevList !
;! "
public 
PoolChunkList 
( 
	PoolArena &
<& '
T' (
>( )
arena* /
,/ 0
PoolChunkList1 >
<> ?
T? @
>@ A
nextListB J
,J K
intL O
minUsageP X
,X Y
intZ ]
maxUsage^ f
,f g
inth k
	chunkSizel u
)u v
{ 	
Contract   
.   
Assert   
(   
minUsage   $
<=  % '
maxUsage  ( 0
)  0 1
;  1 2
this!! 
.!! 
arena!! 
=!! 
arena!! 
;!! 
this"" 
."" 
nextList"" 
="" 
nextList"" $
;""$ %
this## 
.## 
minUsage## 
=## 
minUsage## $
;##$ %
this$$ 
.$$ 
maxUsage$$ 
=$$ 
maxUsage$$ $
;$$$ %
this%% 
.%% 
maxCapacity%% 
=%%  
CalculateMaxCapacity%% 3
(%%3 4
minUsage%%4 <
,%%< =
	chunkSize%%> G
)%%G H
;%%H I
}&& 	
static** 
int**  
CalculateMaxCapacity** '
(**' (
int**( +
minUsage**, 4
,**4 5
int**6 9
	chunkSize**: C
)**C D
{++ 	
minUsage,, 
=,, 
	MinUsage0,,  
(,,  !
minUsage,,! )
),,) *
;,,* +
if.. 
(.. 
minUsage.. 
==.. 
$num.. 
)..  
{// 
return11 
$num11 
;11 
}22 
return99 
(99 
int99 
)99 
(99 
	chunkSize99 "
*99# $
(99% &
$num99& *
-99+ ,
minUsage99- 5
)995 6
/997 8
$num999 =
)99= >
;99> ?
}:: 	
internal<< 
void<< 
PrevList<< 
(<< 
PoolChunkList<< ,
<<<, -
T<<- .
><<. /
list<<0 4
)<<4 5
{== 	
Debug>> 
.>> 
Assert>> 
(>> 
this>> 
.>> 
prevList>> &
==>>' )
null>>* .
)>>. /
;>>/ 0
this?? 
.?? 
prevList?? 
=?? 
list??  
;??  !
}@@ 	
internalBB 
boolBB 
AllocateBB 
(BB 
PooledByteBufferBB /
<BB/ 0
TBB0 1
>BB1 2
bufBB3 6
,BB6 7
intBB8 ;
reqCapacityBB< G
,BBG H
intBBI L
normCapacityBBM Y
)BBY Z
{CC 	
ifDD 
(DD 
thisDD 
.DD 
headDD 
==DD 
nullDD !
||DD" $
normCapacityDD% 1
>DD2 3
thisDD4 8
.DD8 9
maxCapacityDD9 D
)DDD E
{EE 
returnHH 
falseHH 
;HH 
}II 
forKK 
(KK 
	PoolChunkKK 
<KK 
TKK 
>KK 
curKK !
=KK" #
thisKK$ (
.KK( )
headKK) -
;KK- .
;KK. /
)KK/ 0
{LL 
longMM 
handleMM 
=MM 
curMM !
.MM! "
AllocateMM" *
(MM* +
normCapacityMM+ 7
)MM7 8
;MM8 9
ifNN 
(NN 
handleNN 
<NN 
$numNN 
)NN 
{OO 
curPP 
=PP 
curPP 
.PP 
NextPP "
;PP" #
ifQQ 
(QQ 
curQQ 
==QQ 
nullQQ #
)QQ# $
{RR 
returnSS 
falseSS $
;SS$ %
}TT 
}UU 
elseVV 
{WW 
curXX 
.XX 
InitBufXX 
(XX  
bufXX  #
,XX# $
handleXX% +
,XX+ ,
reqCapacityXX- 8
)XX8 9
;XX9 :
ifYY 
(YY 
curYY 
.YY 
UsageYY !
>=YY" $
thisYY% )
.YY) *
maxUsageYY* 2
)YY2 3
{ZZ 
this[[ 
.[[ 
Remove[[ #
([[# $
cur[[$ '
)[[' (
;[[( )
this\\ 
.\\ 
nextList\\ %
.\\% &
Add\\& )
(\\) *
cur\\* -
)\\- .
;\\. /
}]] 
return^^ 
true^^ 
;^^  
}__ 
}`` 
}aa 	
internalcc 
boolcc 
Freecc 
(cc 
	PoolChunkcc $
<cc$ %
Tcc% &
>cc& '
chunkcc( -
,cc- .
longcc/ 3
handlecc4 :
)cc: ;
{dd 	
chunkee 
.ee 
Freeee 
(ee 
handleee 
)ee 
;ee 
ifff 
(ff 
chunkff 
.ff 
Usageff 
<ff 
thisff "
.ff" #
minUsageff# +
)ff+ ,
{gg 
thishh 
.hh 
Removehh 
(hh 
chunkhh !
)hh! "
;hh" #
returnjj 
thisjj 
.jj 
Move0jj !
(jj! "
chunkjj" '
)jj' (
;jj( )
}kk 
returnll 
truell 
;ll 
}mm 	
booloo 
Moveoo 
(oo 
	PoolChunkoo 
<oo 
Too 
>oo 
chunkoo $
)oo$ %
{pp 	
Contractqq 
.qq 
Assertqq 
(qq 
chunkqq !
.qq! "
Usageqq" '
<qq( )
thisqq* .
.qq. /
maxUsageqq/ 7
)qq7 8
;qq8 9
ifss 
(ss 
chunkss 
.ss 
Usagess 
<ss 
thisss "
.ss" #
minUsagess# +
)ss+ ,
{tt 
returnvv 
thisvv 
.vv 
Move0vv !
(vv! "
chunkvv" '
)vv' (
;vv( )
}ww 
thiszz 
.zz 
Add0zz 
(zz 
chunkzz 
)zz 
;zz 
return{{ 
true{{ 
;{{ 
}|| 	
bool
ÄÄ 
Move0
ÄÄ 
(
ÄÄ 
	PoolChunk
ÄÄ 
<
ÄÄ 
T
ÄÄ 
>
ÄÄ 
chunk
ÄÄ  %
)
ÄÄ% &
{
ÅÅ 	
if
ÇÇ 
(
ÇÇ 
this
ÇÇ 
.
ÇÇ 
prevList
ÇÇ 
==
ÇÇ  
null
ÇÇ! %
)
ÇÇ% &
{
ÉÉ 
Debug
ÜÜ 
.
ÜÜ 
Assert
ÜÜ 
(
ÜÜ 
chunk
ÜÜ "
.
ÜÜ" #
Usage
ÜÜ# (
==
ÜÜ) +
$num
ÜÜ, -
)
ÜÜ- .
;
ÜÜ. /
return
áá 
false
áá 
;
áá 
}
àà 
return
ââ 
this
ââ 
.
ââ 
prevList
ââ  
.
ââ  !
Move
ââ! %
(
ââ% &
chunk
ââ& +
)
ââ+ ,
;
ââ, -
}
ää 	
internal
åå 
void
åå 
Add
åå 
(
åå 
	PoolChunk
åå #
<
åå# $
T
åå$ %
>
åå% &
chunk
åå' ,
)
åå, -
{
çç 	
if
éé 
(
éé 
chunk
éé 
.
éé 
Usage
éé 
>=
éé 
this
éé #
.
éé# $
maxUsage
éé$ ,
)
éé, -
{
èè 
this
êê 
.
êê 
nextList
êê 
.
êê 
Add
êê !
(
êê! "
chunk
êê" '
)
êê' (
;
êê( )
return
ëë 
;
ëë 
}
íí 
this
ìì 
.
ìì 
Add0
ìì 
(
ìì 
chunk
ìì 
)
ìì 
;
ìì 
}
îî 	
void
óó 
Add0
óó 
(
óó 
	PoolChunk
óó 
<
óó 
T
óó 
>
óó 
chunk
óó $
)
óó$ %
{
òò 	
chunk
ôô 
.
ôô 
Parent
ôô 
=
ôô 
this
ôô 
;
ôô  
if
öö 
(
öö 
this
öö 
.
öö 
head
öö 
==
öö 
null
öö !
)
öö! "
{
õõ 
this
úú 
.
úú 
head
úú 
=
úú 
chunk
úú !
;
úú! "
chunk
ùù 
.
ùù 
Prev
ùù 
=
ùù 
null
ùù !
;
ùù! "
chunk
ûû 
.
ûû 
Next
ûû 
=
ûû 
null
ûû !
;
ûû! "
}
üü 
else
†† 
{
°° 
chunk
¢¢ 
.
¢¢ 
Prev
¢¢ 
=
¢¢ 
null
¢¢ !
;
¢¢! "
chunk
££ 
.
££ 
Next
££ 
=
££ 
this
££ !
.
££! "
head
££" &
;
££& '
this
§§ 
.
§§ 
head
§§ 
.
§§ 
Prev
§§ 
=
§§  
chunk
§§! &
;
§§& '
this
•• 
.
•• 
head
•• 
=
•• 
chunk
•• !
;
••! "
}
¶¶ 
}
ßß 	
void
©© 
Remove
©© 
(
©© 
	PoolChunk
©© 
<
©© 
T
©© 
>
©©  
cur
©©! $
)
©©$ %
{
™™ 	
if
´´ 
(
´´ 
cur
´´ 
==
´´ 
this
´´ 
.
´´ 
head
´´  
)
´´  !
{
¨¨ 
this
≠≠ 
.
≠≠ 
head
≠≠ 
=
≠≠ 
cur
≠≠ 
.
≠≠  
Next
≠≠  $
;
≠≠$ %
if
ÆÆ 
(
ÆÆ 
this
ÆÆ 
.
ÆÆ 
head
ÆÆ 
!=
ÆÆ  
null
ÆÆ! %
)
ÆÆ% &
{
ØØ 
this
∞∞ 
.
∞∞ 
head
∞∞ 
.
∞∞ 
Prev
∞∞ "
=
∞∞# $
null
∞∞% )
;
∞∞) *
}
±± 
}
≤≤ 
else
≥≥ 
{
¥¥ 
	PoolChunk
µµ 
<
µµ 
T
µµ 
>
µµ 
next
µµ !
=
µµ" #
cur
µµ$ '
.
µµ' (
Next
µµ( ,
;
µµ, -
cur
∂∂ 
.
∂∂ 
Prev
∂∂ 
.
∂∂ 
Next
∂∂ 
=
∂∂ 
next
∂∂  $
;
∂∂$ %
if
∑∑ 
(
∑∑ 
next
∑∑ 
!=
∑∑ 
null
∑∑  
)
∑∑  !
{
∏∏ 
next
ππ 
.
ππ 
Prev
ππ 
=
ππ 
cur
ππ  #
.
ππ# $
Prev
ππ$ (
;
ππ( )
}
∫∫ 
}
ªª 
}
ºº 	
public
ææ 
int
ææ 
MinUsage
ææ 
=>
ææ 
	MinUsage0
ææ (
(
ææ( )
this
ææ) -
.
ææ- .
minUsage
ææ. 6
)
ææ6 7
;
ææ7 8
public
¿¿ 
int
¿¿ 
MaxUsage
¿¿ 
=>
¿¿ 
Math
¿¿ #
.
¿¿# $
Min
¿¿$ '
(
¿¿' (
this
¿¿( ,
.
¿¿, -
maxUsage
¿¿- 5
,
¿¿5 6
$num
¿¿7 :
)
¿¿: ;
;
¿¿; <
static
¬¬ 
int
¬¬ 
	MinUsage0
¬¬ 
(
¬¬ 
int
¬¬  
value
¬¬! &
)
¬¬& '
=>
¬¬( *
Math
¬¬+ /
.
¬¬/ 0
Max
¬¬0 3
(
¬¬3 4
$num
¬¬4 5
,
¬¬5 6
value
¬¬7 <
)
¬¬< =
;
¬¬= >
public
ƒƒ 
IEnumerator
ƒƒ 
<
ƒƒ 
IPoolChunkMetric
ƒƒ +
>
ƒƒ+ ,
GetEnumerator
ƒƒ- :
(
ƒƒ: ;
)
ƒƒ; <
=>
ƒƒ= ?
this
≈≈ 
.
≈≈ 
head
≈≈ 
==
≈≈ 
null
≈≈ 
?
≈≈ 

Enumerable
≈≈  *
.
≈≈* +
Empty
≈≈+ 0
<
≈≈0 1
IPoolChunkMetric
≈≈1 A
>
≈≈A B
(
≈≈B C
)
≈≈C D
.
≈≈D E
GetEnumerator
≈≈E R
(
≈≈R S
)
≈≈S T
:
≈≈U V
this
≈≈W [
.
≈≈[ \#
GetEnumeratorInternal
≈≈\ q
(
≈≈q r
)
≈≈r s
;
≈≈s t
IEnumerator
«« 
IEnumerable
«« 
.
««  
GetEnumerator
««  -
(
««- .
)
««. /
=>
««0 2
this
««3 7
.
««7 8
GetEnumerator
««8 E
(
««E F
)
««F G
;
««G H
IEnumerator
…… 
<
…… 
IPoolChunkMetric
…… $
>
……$ %#
GetEnumeratorInternal
……& ;
(
……; <
)
……< =
{
   	
lock
ÀÀ 
(
ÀÀ 
this
ÀÀ 
.
ÀÀ 
arena
ÀÀ 
)
ÀÀ 
{
ÃÃ 
for
ÕÕ 
(
ÕÕ 
	PoolChunk
ÕÕ 
<
ÕÕ 
T
ÕÕ  
>
ÕÕ  !
cur
ÕÕ" %
=
ÕÕ& '
this
ÕÕ( ,
.
ÕÕ, -
head
ÕÕ- 1
;
ÕÕ1 2
cur
ÕÕ3 6
!=
ÕÕ7 9
null
ÕÕ: >
;
ÕÕ> ?
)
ÕÕ? @
{
ŒŒ 
yield
œœ 
return
œœ  
cur
œœ! $
;
œœ$ %
cur
–– 
=
–– 
cur
–– 
.
–– 
Next
–– "
;
––" #
}
—— 
}
““ 
}
”” 	
public
’’ 
override
’’ 
string
’’ 
ToString
’’ '
(
’’' (
)
’’( )
{
÷÷ 	
var
◊◊ 
buf
◊◊ 
=
◊◊ 
new
◊◊ 
StringBuilder
◊◊ '
(
◊◊' (
)
◊◊( )
;
◊◊) *
lock
ÿÿ 
(
ÿÿ 
this
ÿÿ 
.
ÿÿ 
arena
ÿÿ 
)
ÿÿ 
{
ŸŸ 
if
⁄⁄ 
(
⁄⁄ 
this
⁄⁄ 
.
⁄⁄ 
head
⁄⁄ 
==
⁄⁄  
null
⁄⁄! %
)
⁄⁄% &
{
€€ 
return
‹‹ 
$str
‹‹ !
;
‹‹! "
}
›› 
for
ﬂﬂ 
(
ﬂﬂ 
	PoolChunk
ﬂﬂ 
<
ﬂﬂ 
T
ﬂﬂ  
>
ﬂﬂ  !
cur
ﬂﬂ" %
=
ﬂﬂ& '
this
ﬂﬂ( ,
.
ﬂﬂ, -
head
ﬂﬂ- 1
;
ﬂﬂ1 2
;
ﬂﬂ3 4
)
ﬂﬂ4 5
{
‡‡ 
buf
·· 
.
·· 
Append
·· 
(
·· 
cur
·· "
)
··" #
;
··# $
cur
‚‚ 
=
‚‚ 
cur
‚‚ 
.
‚‚ 
Next
‚‚ "
;
‚‚" #
if
„„ 
(
„„ 
cur
„„ 
==
„„ 
null
„„ #
)
„„# $
{
‰‰ 
break
ÂÂ 
;
ÂÂ 
}
ÊÊ 
buf
ÁÁ 
.
ÁÁ 
Append
ÁÁ 
(
ÁÁ 

StringUtil
ÁÁ )
.
ÁÁ) *
Newline
ÁÁ* 1
)
ÁÁ1 2
;
ÁÁ2 3
}
ËË 
}
ÈÈ 
return
ÎÎ 
buf
ÎÎ 
.
ÎÎ 
ToString
ÎÎ 
(
ÎÎ  
)
ÎÎ  !
;
ÎÎ! "
}
ÏÏ 	
internal
ÓÓ 
void
ÓÓ 
Destroy
ÓÓ 
(
ÓÓ 
	PoolArena
ÓÓ '
<
ÓÓ' (
T
ÓÓ( )
>
ÓÓ) *
	poolArena
ÓÓ+ 4
)
ÓÓ4 5
{
ÔÔ 	
	PoolChunk
 
<
 
T
 
>
 
chunk
 
=
  
this
! %
.
% &
head
& *
;
* +
while
ÒÒ 
(
ÒÒ 
chunk
ÒÒ 
!=
ÒÒ 
null
ÒÒ  
)
ÒÒ  !
{
ÚÚ 
	poolArena
ÛÛ 
.
ÛÛ 
DestroyChunk
ÛÛ &
(
ÛÛ& '
chunk
ÛÛ' ,
)
ÛÛ, -
;
ÛÛ- .
chunk
ÙÙ 
=
ÙÙ 
chunk
ÙÙ 
.
ÙÙ 
Next
ÙÙ "
;
ÙÙ" #
}
ıı 
this
˜˜ 
.
˜˜ 
head
˜˜ 
=
˜˜ 
null
˜˜ 
;
˜˜ 
}
¯¯ 	
}
˘˘ 
}˙˙ ˛a
cC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
abstract 
class 
PooledByteBuffer #
<# $
T$ %
>% &
:' (.
"AbstractReferenceCountedByteBuffer) K
{ 
	protected 
internal 
	PoolChunk $
<$ %
T% &
>& '
Chunk( -
;- .
	protected 
internal 
long 
Handle  &
;& '
	protected 
internal 
T 
Memory #
;# $
	protected 
internal 
int 
Offset %
;% &
	protected 
internal 
int 
Length %
;% &
internal 
int 
	MaxLength 
; 
internal 
PoolThreadCache  
<  !
T! "
>" #
Cache$ )
;) *%
PooledByteBufferAllocator !
	allocator" +
;+ ,
	protected 
PooledByteBuffer "
(" #
int# &
maxCapacity' 2
)2 3
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
internal 
virtual 
void 
Init "
(" #
	PoolChunk# ,
<, -
T- .
>. /
chunk0 5
,5 6
long7 ;
handle< B
,B C
intD G
offsetH N
,N O
intP S
lengthT Z
,Z [
int\ _
	maxLength` i
,i j
PoolThreadCachek z
<z {
T{ |
>| }
cache	~ É
)
É Ñ
=>
Ö á
this 
. 
Init0 
( 
chunk 
, 
handle $
,$ %
offset& ,
,, -
length. 4
,4 5
	maxLength6 ?
,? @
cacheA F
)F G
;G H
internal 
virtual 
void 
InitUnpooled *
(* +
	PoolChunk+ 4
<4 5
T5 6
>6 7
chunk8 =
,= >
int? B
lengthC I
)I J
=>K M
thisN R
.R S
Init0S X
(X Y
chunkY ^
,^ _
$num` a
,a b
$numc d
,d e
lengthf l
,l m
lengthn t
,t u
nullv z
)z {
;{ |
void   
Init0   
(   
	PoolChunk   
<   
T   
>   
chunk    %
,  % &
long  ' +
handle  , 2
,  2 3
int  4 7
offset  8 >
,  > ?
int  @ C
length  D J
,  J K
int  L O
	maxLength  P Y
,  Y Z
PoolThreadCache  [ j
<  j k
T  k l
>  l m
cache  n s
)  s t
{!! 	
Debug"" 
."" 
Assert"" 
("" 
handle"" 
>=""  "
$num""# $
)""$ %
;""% &
Debug## 
.## 
Assert## 
(## 
chunk## 
!=## !
null##" &
)##& '
;##' (
this%% 
.%% 
Chunk%% 
=%% 
chunk%% 
;%% 
this&& 
.&& 
Memory&& 
=&& 
chunk&& 
.&&  
Memory&&  &
;&&& '
this'' 
.'' 
	allocator'' 
='' 
chunk'' "
.''" #
Arena''# (
.''( )
Parent'') /
;''/ 0
this(( 
.(( 
Cache(( 
=(( 
cache(( 
;(( 
this)) 
.)) 
Handle)) 
=)) 
handle))  
;))  !
this** 
.** 
Offset** 
=** 
offset**  
;**  !
this++ 
.++ 
Length++ 
=++ 
length++  
;++  !
this,, 
.,, 
	MaxLength,, 
=,, 
	maxLength,, &
;,,& '
}-- 	
public22 
override22 
int22 
Capacity22 $
{33 	
[44 

MethodImpl44 
(44 
MethodImplOptions44 )
.44) *
AggressiveInlining44* <
)44< =
]44= >
get55 
=>55 
this55 
.55 
Length55 
;55 
}66 	
public88 
sealed88 
override88 
IByteBuffer88 *
AdjustCapacity88+ 9
(889 :
int88: =
newCapacity88> I
)88I J
{99 	
this:: 
.:: 
CheckNewCapacity:: !
(::! "
newCapacity::" -
)::- .
;::. /
if== 
(== 
this== 
.== 
Chunk== 
.== 
Unpooled== #
)==# $
{>> 
if?? 
(?? 
newCapacity?? 
==??  "
this??# '
.??' (
Length??( .
)??. /
{@@ 
returnAA 
thisAA 
;AA  
}BB 
}CC 
elseDD 
{EE 
ifFF 
(FF 
newCapacityFF 
>FF  !
thisFF" &
.FF& '
LengthFF' -
)FF- .
{GG 
ifHH 
(HH 
newCapacityHH #
<=HH$ &
thisHH' +
.HH+ ,
	MaxLengthHH, 5
)HH5 6
{II 
thisJJ 
.JJ 
LengthJJ #
=JJ$ %
newCapacityJJ& 1
;JJ1 2
returnKK 
thisKK #
;KK# $
}LL 
}MM 
elseNN 
ifNN 
(NN 
newCapacityNN $
<NN% &
thisNN' +
.NN+ ,
LengthNN, 2
)NN2 3
{OO 
ifPP 
(PP 
newCapacityPP #
>PP$ %
thisPP& *
.PP* +
	MaxLengthPP+ 4
.PP4 5
RightUShiftPP5 @
(PP@ A
$numPPA B
)PPB C
)PPC D
{QQ 
ifRR 
(RR 
thisRR  
.RR  !
	MaxLengthRR! *
<=RR+ -
$numRR. 1
)RR1 2
{SS 
ifTT 
(TT  
newCapacityTT  +
>TT, -
thisTT. 2
.TT2 3
	MaxLengthTT3 <
-TT= >
$numTT? A
)TTA B
{UU 
thisVV  $
.VV$ %
LengthVV% +
=VV, -
newCapacityVV. 9
;VV9 :
thisWW  $
.WW$ %
SetIndexWW% -
(WW- .
MathWW. 2
.WW2 3
MinWW3 6
(WW6 7
thisWW7 ;
.WW; <
ReaderIndexWW< G
,WWG H
newCapacityWWI T
)WWT U
,WWU V
MathWWW [
.WW[ \
MinWW\ _
(WW_ `
thisWW` d
.WWd e
WriterIndexWWe p
,WWp q
newCapacityWWr }
)WW} ~
)WW~ 
;	WW Ä
returnXX  &
thisXX' +
;XX+ ,
}YY 
}ZZ 
else[[ 
{\\ 
this^^  
.^^  !
Length^^! '
=^^( )
newCapacity^^* 5
;^^5 6
this__  
.__  !
SetIndex__! )
(__) *
Math__* .
.__. /
Min__/ 2
(__2 3
this__3 7
.__7 8
ReaderIndex__8 C
,__C D
newCapacity__E P
)__P Q
,__Q R
Math__S W
.__W X
Min__X [
(__[ \
this__\ `
.__` a
WriterIndex__a l
,__l m
newCapacity__n y
)__y z
)__z {
;__{ |
return`` "
this``# '
;``' (
}aa 
}bb 
}cc 
elsedd 
{ee 
returnff 
thisff 
;ff  
}gg 
}hh 
thiskk 
.kk 
Chunkkk 
.kk 
Arenakk 
.kk 

Reallocatekk '
(kk' (
thiskk( ,
,kk, -
newCapacitykk. 9
,kk9 :
truekk; ?
)kk? @
;kk@ A
returnll 
thisll 
;ll 
}mm 	
publicoo 
sealedoo 
overrideoo  
IByteBufferAllocatoroo 3
	Allocatoroo4 =
=>oo> @
thisooA E
.ooE F
	allocatorooF O
;ooO P
publicqq 
sealedqq 
overrideqq 
IByteBufferqq *
Unwrapqq+ 1
(qq1 2
)qq2 3
=>qq4 6
nullqq7 ;
;qq; <
publicss 
sealedss 
overridess 
IByteBufferss *
RetainedDuplicatess+ <
(ss< =
)ss= >
=>ss? A&
PooledDuplicatedByteBufferssB \
.ss\ ]
NewInstancess] h
(ssh i
thisssi m
,ssm n
thissso s
,sss t
thisssu y
.ssy z
ReaderIndex	ssz Ö
,
ssÖ Ü
this
ssá ã
.
ssã å
WriterIndex
sså ó
)
ssó ò
;
ssò ô
publicuu 
sealeduu 
overrideuu 
IByteBufferuu *
RetainedSliceuu+ 8
(uu8 9
)uu9 :
{vv 	
intww 
indexww 
=ww 
thisww 
.ww 
ReaderIndexww (
;ww( )
returnxx 
thisxx 
.xx 
RetainedSlicexx %
(xx% &
indexxx& +
,xx+ ,
thisxx- 1
.xx1 2
WriterIndexxx2 =
-xx> ?
indexxx@ E
)xxE F
;xxF G
}yy 	
public{{ 
sealed{{ 
override{{ 
IByteBuffer{{ *
RetainedSlice{{+ 8
({{8 9
int{{9 <
index{{= B
,{{B C
int{{D G
length{{H N
){{N O
=>{{P R"
PooledSlicedByteBuffer{{S i
.{{i j
NewInstance{{j u
({{u v
this{{v z
,{{z {
this	{{| Ä
,
{{Ä Å
index
{{Ç á
,
{{á à
length
{{â è
)
{{è ê
;
{{ê ë
	protected}} 
internal}} 
sealed}} !
override}}" *
void}}+ /

Deallocate}}0 :
(}}: ;
)}}; <
{~~ 	
if 
( 
this 
. 
Handle 
>= 
$num  
)  !
{
ÄÄ 
long
ÅÅ 
handle
ÅÅ 
=
ÅÅ 
this
ÅÅ "
.
ÅÅ" #
Handle
ÅÅ# )
;
ÅÅ) *
this
ÇÇ 
.
ÇÇ 
Handle
ÇÇ 
=
ÇÇ 
-
ÇÇ 
$num
ÇÇ  
;
ÇÇ  !
this
ÉÉ 
.
ÉÉ 
Memory
ÉÉ 
=
ÉÉ 
default
ÉÉ %
(
ÉÉ% &
T
ÉÉ& '
)
ÉÉ' (
;
ÉÉ( )
this
ÑÑ 
.
ÑÑ 
Chunk
ÑÑ 
.
ÑÑ 
Arena
ÑÑ  
.
ÑÑ  !
Free
ÑÑ! %
(
ÑÑ% &
this
ÑÑ& *
.
ÑÑ* +
Chunk
ÑÑ+ 0
,
ÑÑ0 1
handle
ÑÑ2 8
,
ÑÑ8 9
this
ÑÑ: >
.
ÑÑ> ?
	MaxLength
ÑÑ? H
,
ÑÑH I
this
ÑÑJ N
.
ÑÑN O
Cache
ÑÑO T
)
ÑÑT U
;
ÑÑU V
this
ÖÖ 
.
ÖÖ 
Chunk
ÖÖ 
=
ÖÖ 
null
ÖÖ !
;
ÖÖ! "
}
ÜÜ 
}
áá 	
[
ââ 	

MethodImpl
ââ	 
(
ââ 
MethodImplOptions
ââ %
.
ââ% & 
AggressiveInlining
ââ& 8
)
ââ8 9
]
ââ9 :
	protected
ää 
int
ää 
Idx
ää 
(
ää 
int
ää 
index
ää #
)
ää# $
=>
ää% '
this
ää( ,
.
ää, -
Offset
ää- 3
+
ää4 5
index
ää6 ;
;
ää; <
}
ãã 
}åå ¬≥
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class %
PooledByteBufferAllocator *
:+ ,'
AbstractByteBufferAllocator- H
,H I.
"IByteBufferAllocatorMetricProviderJ l
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S%
PooledByteBufferAllocatorS l
>l m
(m n
)n o
;o p
public 
static 
readonly 
int "
DefaultNumHeapArena# 6
;6 7
public 
static 
readonly 
int "!
DefaultNumDirectArena# 8
;8 9
public 
static 
readonly 
int "
DefaultPageSize# 2
;2 3
public 
static 
readonly 
int "
DefaultMaxOrder# 2
;2 3
public 
static 
readonly 
int " 
DefaultTinyCacheSize# 7
;7 8
public 
static 
readonly 
int "!
DefaultSmallCacheSize# 8
;8 9
public 
static 
readonly 
int ""
DefaultNormalCacheSize# 9
;9 :
static 
readonly 
int *
DefaultMaxCachedBufferCapacity :
;: ;
static 
readonly 
int $
DefaultCacheTrimInterval 4
;4 5
const!! 
int!! 
MinPageSize!! 
=!! 
$num!!  $
;!!$ %
const"" 
int"" 
MaxChunkSize"" 
=""  
(""! "
int""" %
)""% &
(""& '
(""' (
(""( )
long"") -
)""- .
int"". 1
.""1 2
MaxValue""2 :
+""; <
$num""= >
)""> ?
/""@ A
$num""B C
)""C D
;""D E
static$$ %
PooledByteBufferAllocator$$ (
($$( )
)$$) *
{%% 	
int&& 
defaultPageSize&& 
=&&  !
SystemPropertyUtil&&" 4
.&&4 5
GetInt&&5 ;
(&&; <
$str&&< Y
,&&Y Z
$num&&[ _
)&&_ `
;&&` a
	Exception'' !
pageSizeFallbackCause'' +
='', -
null''. 2
;''2 3
try(( 
{)) *
ValidateAndCalculatePageShifts** .
(**. /
defaultPageSize**/ >
)**> ?
;**? @
}++ 
catch,, 
(,, 
	Exception,, 
t,, 
),, 
{-- !
pageSizeFallbackCause.. %
=..& '
t..( )
;..) *
defaultPageSize// 
=//  !
$num//" &
;//& '
}00 
DefaultPageSize11 
=11 
defaultPageSize11 -
;11- .
int33 
defaultMaxOrder33 
=33  !
SystemPropertyUtil33" 4
.334 5
GetInt335 ;
(33; <
$str33< Y
,33Y Z
$num33[ ]
)33] ^
;33^ _
	Exception44 !
maxOrderFallbackCause44 +
=44, -
null44. 2
;442 3
try55 
{66 )
ValidateAndCalculateChunkSize77 -
(77- .
DefaultPageSize77. =
,77= >
defaultMaxOrder77? N
)77N O
;77O P
}88 
catch99 
(99 
	Exception99 
t99 
)99 
{:: !
maxOrderFallbackCause;; %
=;;& '
t;;( )
;;;) *
defaultMaxOrder<< 
=<<  !
$num<<" $
;<<$ %
}== 
DefaultMaxOrder>> 
=>> 
defaultMaxOrder>> -
;>>- .
intGG 
defaultMinNumArenaGG "
=GG# $
EnvironmentGG% 0
.GG0 1
ProcessorCountGG1 ?
*GG@ A
$numGGB C
;GGC D
DefaultNumHeapArenaHH 
=HH  !
MathHH" &
.HH& '
MaxHH' *
(HH* +
$numHH+ ,
,HH, -
SystemPropertyUtilHH. @
.HH@ A
GetIntHHA G
(HHG H
$strHHH j
,HHj k
defaultMinNumArenaHHl ~
)HH~ 
)	HH Ä
;
HHÄ Å!
DefaultNumDirectArenaII !
=II" #
MathII$ (
.II( )
MaxII) ,
(II, -
$numII- .
,II. /
SystemPropertyUtilII0 B
.IIB C
GetIntIIC I
(III J
$strIIJ n
,IIn o
defaultMinNumArena	IIp Ç
)
IIÇ É
)
IIÉ Ñ
;
IIÑ Ö 
DefaultTinyCacheSizeLL  
=LL! "
SystemPropertyUtilLL# 5
.LL5 6
GetIntLL6 <
(LL< =
$strLL= _
,LL_ `
$numLLa d
)LLd e
;LLe f!
DefaultSmallCacheSizeMM !
=MM" #
SystemPropertyUtilMM$ 6
.MM6 7
GetIntMM7 =
(MM= >
$strMM> a
,MMa b
$numMMc f
)MMf g
;MMg h"
DefaultNormalCacheSizeNN "
=NN# $
SystemPropertyUtilNN% 7
.NN7 8
GetIntNN8 >
(NN> ?
$strNN? c
,NNc d
$numNNe g
)NNg h
;NNh i*
DefaultMaxCachedBufferCapacityRR *
=RR+ ,
SystemPropertyUtilRR- ?
.RR? @
GetIntRR@ F
(RRF G
$strRRG s
,RRs t
$numRRu w
*RRx y
$numRRz ~
)RR~ 
;	RR Ä$
DefaultCacheTrimIntervalUU $
=UU% &
SystemPropertyUtilUU' 9
.UU9 :
GetIntUU: @
(UU@ A
$strVV 6
,VV6 7
$numVV8 <
)VV< =
;VV= >
ifXX 
(XX 
LoggerXX 
.XX 
DebugEnabledXX #
)XX# $
{YY 
LoggerZZ 
.ZZ 
DebugZZ 
(ZZ 
$strZZ E
,ZZE F
DefaultNumHeapArenaZZG Z
)ZZZ [
;ZZ[ \
Logger[[ 
.[[ 
Debug[[ 
([[ 
$str[[ G
,[[G H!
DefaultNumDirectArena[[I ^
)[[^ _
;[[_ `
if\\ 
(\\ !
pageSizeFallbackCause\\ )
==\\* ,
null\\- 1
)\\1 2
{]] 
Logger^^ 
.^^ 
Debug^^  
(^^  !
$str^^! D
,^^D E
DefaultPageSize^^F U
)^^U V
;^^V W
}__ 
else`` 
{aa 
Loggerbb 
.bb 
Debugbb  
(bb  !
$strbb! D
,bbD E
DefaultPageSizebbF U
,bbU V!
pageSizeFallbackCausebbW l
)bbl m
;bbm n
}cc 
ifdd 
(dd !
maxOrderFallbackCausedd )
==dd* ,
nulldd- 1
)dd1 2
{ee 
Loggerff 
.ff 
Debugff  
(ff  !
$strff! D
,ffD E
DefaultMaxOrderffF U
)ffU V
;ffV W
}gg 
elsehh 
{ii 
Loggerjj 
.jj 
Debugjj  
(jj  !
$strjj! D
,jjD E
DefaultMaxOrderjjF U
,jjU V!
maxOrderFallbackCausejjW l
)jjl m
;jjm n
}kk 
Loggerll 
.ll 
Debugll 
(ll 
$strll A
,llA B
DefaultPageSizellC R
<<llS U
DefaultMaxOrderllV e
)lle f
;llf g
Loggermm 
.mm 
Debugmm 
(mm 
$strmm E
,mmE F 
DefaultTinyCacheSizemmG [
)mm[ \
;mm\ ]
Loggernn 
.nn 
Debugnn 
(nn 
$strnn F
,nnF G!
DefaultSmallCacheSizennH ]
)nn] ^
;nn^ _
Loggeroo 
.oo 
Debugoo 
(oo 
$stroo G
,ooG H"
DefaultNormalCacheSizeooI _
)oo_ `
;oo` a
Loggerpp 
.pp 
Debugpp 
(pp 
$strpp O
,ppO P*
DefaultMaxCachedBufferCapacityppQ o
)ppo p
;ppp q
Loggerqq 
.qq 
Debugqq 
(qq 
$strqq I
,qqI J$
DefaultCacheTrimIntervalqqK c
)qqc d
;qqd e
}rr 
Defaulttt 
=tt 
newtt %
PooledByteBufferAllocatortt 3
(tt3 4
PlatformDependenttt4 E
.ttE F!
DirectBufferPreferredttF [
)tt[ \
;tt\ ]
}uu 	
publicww 
staticww 
readonlyww %
PooledByteBufferAllocatorww 8
Defaultww9 @
;ww@ A
readonlyyy 
	PoolArenayy 
<yy 
byteyy 
[yy  
]yy  !
>yy! "
[yy" #
]yy# $

heapArenasyy% /
;yy/ 0
readonlyzz 
	PoolArenazz 
<zz 
bytezz 
[zz  
]zz  !
>zz! "
[zz" #
]zz# $
directArenaszz% 1
;zz1 2
readonly{{ 
int{{ 
tinyCacheSize{{ "
;{{" #
readonly|| 
int|| 
smallCacheSize|| #
;||# $
readonly}} 
int}} 
normalCacheSize}} $
;}}$ %
readonly~~ 
IReadOnlyList~~ 
<~~ 
IPoolArenaMetric~~ /
>~~/ 0
heapArenaMetrics~~1 A
;~~A B
readonly 
IReadOnlyList 
< 
IPoolArenaMetric /
>/ 0
directArenaMetrics1 C
;C D
readonly
ÄÄ "
PoolThreadLocalCache
ÄÄ %
threadCache
ÄÄ& 1
;
ÄÄ1 2
readonly
ÅÅ 
int
ÅÅ 
	chunkSize
ÅÅ 
;
ÅÅ 
readonly
ÇÇ -
PooledByteBufferAllocatorMetric
ÇÇ 0
metric
ÇÇ1 7
;
ÇÇ7 8
public
ÑÑ '
PooledByteBufferAllocator
ÑÑ (
(
ÑÑ( )
)
ÑÑ) *
:
ÑÑ+ ,
this
ÑÑ- 1
(
ÑÑ1 2
false
ÑÑ2 7
)
ÑÑ7 8
{
ÖÖ 	
}
ÜÜ 	
public
àà 
unsafe
àà '
PooledByteBufferAllocator
àà /
(
àà/ 0
bool
àà0 4
preferDirect
àà5 A
)
ààA B
:
ââ 
this
ââ 
(
ââ 
preferDirect
ââ 
,
ââ  !
DefaultNumHeapArena
ââ! 4
,
ââ4 5#
DefaultNumDirectArena
ââ6 K
,
ââK L
DefaultPageSize
ââM \
,
ââ\ ]
DefaultMaxOrder
ââ^ m
)
ââm n
{
ää 	
}
ãã 	
public
çç '
PooledByteBufferAllocator
çç (
(
çç( )
int
çç) ,

nHeapArena
çç- 7
,
çç7 8
int
çç9 <
nDirectArena
çç= I
,
ççI J
int
ççK N
pageSize
ççO W
,
ççW X
int
ççY \
maxOrder
çç] e
)
ççe f
:
éé 
this
éé 
(
éé 
false
éé 
,
éé 

nHeapArena
éé $
,
éé$ %
nDirectArena
éé& 2
,
éé2 3
pageSize
éé4 <
,
éé< =
maxOrder
éé> F
)
ééF G
{
èè 	
}
êê 	
public
íí 
unsafe
íí '
PooledByteBufferAllocator
íí /
(
íí/ 0
bool
íí0 4
preferDirect
íí5 A
,
ííA B
int
ííC F

nHeapArena
ííG Q
,
ííQ R
int
ííS V
nDirectArena
ííW c
,
ííc d
int
ííe h
pageSize
ííi q
,
ííq r
int
íís v
maxOrder
ííw 
)íí Ä
:
ìì 
this
ìì 
(
ìì 
preferDirect
ìì 
,
ìì  

nHeapArena
ìì! +
,
ìì+ ,
nDirectArena
ìì- 9
,
ìì9 :
pageSize
ìì; C
,
ììC D
maxOrder
ììE M
,
ììM N"
DefaultTinyCacheSize
îî $
,
îî$ %#
DefaultSmallCacheSize
îî& ;
,
îî; <$
DefaultNormalCacheSize
îî= S
)
îîS T
{
ïï 	
}
ññ 	
public
òò '
PooledByteBufferAllocator
òò (
(
òò( )
int
òò) ,

nHeapArena
òò- 7
,
òò7 8
int
òò9 <
nDirectArena
òò= I
,
òòI J
int
òòK N
pageSize
òòO W
,
òòW X
int
òòY \
maxOrder
òò] e
,
òòe f
int
ôô 
tinyCacheSize
ôô 
,
ôô 
int
ôô "
smallCacheSize
ôô# 1
,
ôô1 2
int
ôô3 6
normalCacheSize
ôô7 F
)
ôôF G
:
öö 
this
öö 
(
öö 
false
öö 
,
öö 

nHeapArena
öö $
,
öö$ %
nDirectArena
öö& 2
,
öö2 3
pageSize
öö4 <
,
öö< =
maxOrder
öö> F
,
ööF G
tinyCacheSize
ööH U
,
ööU V
smallCacheSize
ööW e
,
ööe f
normalCacheSize
öög v
)
ööv w
{
õõ 	
}
õõ
 
public
ùù 
unsafe
ùù '
PooledByteBufferAllocator
ùù /
(
ùù/ 0
bool
ùù0 4
preferDirect
ùù5 A
,
ùùA B
int
ùùC F

nHeapArena
ùùG Q
,
ùùQ R
int
ùùS V
nDirectArena
ùùW c
,
ùùc d
int
ùùe h
pageSize
ùùi q
,
ùùq r
int
ùùs v
maxOrder
ùùw 
,ùù Ä
int
ûû 
tinyCacheSize
ûû 
,
ûû 
int
ûû "
smallCacheSize
ûû# 1
,
ûû1 2
int
ûû3 6
normalCacheSize
ûû7 F
)
ûûF G
:
üü 
base
üü 
(
üü 
preferDirect
üü 
)
üü  
{
†† 	
Contract
°° 
.
°° 
Requires
°° 
(
°° 

nHeapArena
°° (
>=
°°) +
$num
°°, -
)
°°- .
;
°°. /
Contract
¢¢ 
.
¢¢ 
Requires
¢¢ 
(
¢¢ 
nDirectArena
¢¢ *
>=
¢¢+ -
$num
¢¢. /
)
¢¢/ 0
;
¢¢0 1
this
§§ 
.
§§ 
threadCache
§§ 
=
§§ 
new
§§ ""
PoolThreadLocalCache
§§# 7
(
§§7 8
this
§§8 <
)
§§< =
;
§§= >
this
•• 
.
•• 
tinyCacheSize
•• 
=
••  
tinyCacheSize
••! .
;
••. /
this
¶¶ 
.
¶¶ 
smallCacheSize
¶¶ 
=
¶¶  !
smallCacheSize
¶¶" 0
;
¶¶0 1
this
ßß 
.
ßß 
normalCacheSize
ßß  
=
ßß! "
normalCacheSize
ßß# 2
;
ßß2 3
this
®® 
.
®® 
	chunkSize
®® 
=
®® +
ValidateAndCalculateChunkSize
®® :
(
®®: ;
pageSize
®®; C
,
®®C D
maxOrder
®®E M
)
®®M N
;
®®N O
int
™™ 

pageShifts
™™ 
=
™™ ,
ValidateAndCalculatePageShifts
™™ ;
(
™™; <
pageSize
™™< D
)
™™D E
;
™™E F
if
¨¨ 
(
¨¨ 

nHeapArena
¨¨ 
>
¨¨ 
$num
¨¨ 
)
¨¨ 
{
≠≠ 
this
ÆÆ 
.
ÆÆ 

heapArenas
ÆÆ 
=
ÆÆ  !
NewArenaArray
ÆÆ" /
<
ÆÆ/ 0
byte
ÆÆ0 4
[
ÆÆ4 5
]
ÆÆ5 6
>
ÆÆ6 7
(
ÆÆ7 8

nHeapArena
ÆÆ8 B
)
ÆÆB C
;
ÆÆC D
var
ØØ 
metrics
ØØ 
=
ØØ 
new
ØØ !
List
ØØ" &
<
ØØ& '
IPoolArenaMetric
ØØ' 7
>
ØØ7 8
(
ØØ8 9
this
ØØ9 =
.
ØØ= >

heapArenas
ØØ> H
.
ØØH I
Length
ØØI O
)
ØØO P
;
ØØP Q
for
∞∞ 
(
∞∞ 
int
∞∞ 
i
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 
i
∞∞  !
<
∞∞" #
this
∞∞$ (
.
∞∞( )

heapArenas
∞∞) 3
.
∞∞3 4
Length
∞∞4 :
;
∞∞: ;
i
∞∞< =
++
∞∞= ?
)
∞∞? @
{
±± 
var
≤≤ 
arena
≤≤ 
=
≤≤ 
new
≤≤  #
	HeapArena
≤≤$ -
(
≤≤- .
this
≤≤. 2
,
≤≤2 3
pageSize
≤≤4 <
,
≤≤< =
maxOrder
≤≤> F
,
≤≤F G

pageShifts
≤≤H R
,
≤≤R S
this
≤≤T X
.
≤≤X Y
	chunkSize
≤≤Y b
)
≤≤b c
;
≤≤c d
this
≥≥ 
.
≥≥ 

heapArenas
≥≥ #
[
≥≥# $
i
≥≥$ %
]
≥≥% &
=
≥≥' (
arena
≥≥) .
;
≥≥. /
metrics
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥  
arena
¥¥  %
)
¥¥% &
;
¥¥& '
}
µµ 
this
∂∂ 
.
∂∂ 
heapArenaMetrics
∂∂ %
=
∂∂& '
metrics
∂∂( /
.
∂∂/ 0

AsReadOnly
∂∂0 :
(
∂∂: ;
)
∂∂; <
;
∂∂< =
}
∑∑ 
else
∏∏ 
{
ππ 
this
∫∫ 
.
∫∫ 

heapArenas
∫∫ 
=
∫∫  !
null
∫∫" &
;
∫∫& '
this
ªª 
.
ªª 
heapArenaMetrics
ªª %
=
ªª& '
new
ªª( +
IPoolArenaMetric
ªª, <
[
ªª< =
$num
ªª= >
]
ªª> ?
;
ªª? @
}
ºº 
if
ææ 
(
ææ 
nDirectArena
ææ 
>
ææ 
$num
ææ  
)
ææ  !
{
øø 
this
¿¿ 
.
¿¿ 
directArenas
¿¿ !
=
¿¿" #
NewArenaArray
¿¿$ 1
<
¿¿1 2
byte
¿¿2 6
[
¿¿6 7
]
¿¿7 8
>
¿¿8 9
(
¿¿9 :
nDirectArena
¿¿: F
)
¿¿F G
;
¿¿G H
var
¡¡ 
metrics
¡¡ 
=
¡¡ 
new
¡¡ !
List
¡¡" &
<
¡¡& '
IPoolArenaMetric
¡¡' 7
>
¡¡7 8
(
¡¡8 9
this
¡¡9 =
.
¡¡= >
directArenas
¡¡> J
.
¡¡J K
Length
¡¡K Q
)
¡¡Q R
;
¡¡R S
for
¬¬ 
(
¬¬ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
i
¬¬  !
<
¬¬" #
this
¬¬$ (
.
¬¬( )
directArenas
¬¬) 5
.
¬¬5 6
Length
¬¬6 <
;
¬¬< =
i
¬¬> ?
++
¬¬? A
)
¬¬A B
{
√√ 
var
ƒƒ 
arena
ƒƒ 
=
ƒƒ 
new
ƒƒ  #
DirectArena
ƒƒ$ /
(
ƒƒ/ 0
this
ƒƒ0 4
,
ƒƒ4 5
pageSize
ƒƒ6 >
,
ƒƒ> ?
maxOrder
ƒƒ@ H
,
ƒƒH I

pageShifts
ƒƒJ T
,
ƒƒT U
this
ƒƒV Z
.
ƒƒZ [
	chunkSize
ƒƒ[ d
)
ƒƒd e
;
ƒƒe f
this
≈≈ 
.
≈≈ 
directArenas
≈≈ %
[
≈≈% &
i
≈≈& '
]
≈≈' (
=
≈≈) *
arena
≈≈+ 0
;
≈≈0 1
metrics
∆∆ 
.
∆∆ 
Add
∆∆ 
(
∆∆  
arena
∆∆  %
)
∆∆% &
;
∆∆& '
}
«« 
this
»» 
.
»»  
directArenaMetrics
»» '
=
»»( )
metrics
»»* 1
.
»»1 2

AsReadOnly
»»2 <
(
»»< =
)
»»= >
;
»»> ?
}
…… 
else
   
{
ÀÀ 
this
ÃÃ 
.
ÃÃ 
directArenas
ÃÃ !
=
ÃÃ" #
null
ÃÃ$ (
;
ÃÃ( )
this
ÕÕ 
.
ÕÕ  
directArenaMetrics
ÕÕ '
=
ÕÕ( )
new
ÕÕ* -
IPoolArenaMetric
ÕÕ. >
[
ÕÕ> ?
$num
ÕÕ? @
]
ÕÕ@ A
;
ÕÕA B
}
ŒŒ 
this
–– 
.
–– 
metric
–– 
=
–– 
new
–– -
PooledByteBufferAllocatorMetric
–– =
(
––= >
this
––> B
)
––B C
;
––C D
}
—— 	
static
”” 
	PoolArena
”” 
<
”” 
T
”” 
>
”” 
[
”” 
]
”” 
NewArenaArray
”” +
<
””+ ,
T
””, -
>
””- .
(
””. /
int
””/ 2
size
””3 7
)
””7 8
=>
””9 ;
new
””< ?
	PoolArena
””@ I
<
””I J
T
””J K
>
””K L
[
””L M
size
””M Q
]
””Q R
;
””R S
static
’’ 
int
’’ ,
ValidateAndCalculatePageShifts
’’ 1
(
’’1 2
int
’’2 5
pageSize
’’6 >
)
’’> ?
{
÷÷ 	
Contract
◊◊ 
.
◊◊ 
Requires
◊◊ 
(
◊◊ 
pageSize
◊◊ &
>=
◊◊' )
MinPageSize
◊◊* 5
)
◊◊5 6
;
◊◊6 7
Contract
ÿÿ 
.
ÿÿ 
Requires
ÿÿ 
(
ÿÿ 
(
ÿÿ 
pageSize
ÿÿ '
&
ÿÿ( )
pageSize
ÿÿ* 2
-
ÿÿ3 4
$num
ÿÿ5 6
)
ÿÿ6 7
==
ÿÿ8 :
$num
ÿÿ; <
,
ÿÿ< =
$str
ÿÿ> S
)
ÿÿS T
;
ÿÿT U
return
€€ 
(
€€ 
sizeof
€€ 
(
€€ 
int
€€ 
)
€€ 
*
€€  !
$num
€€" #
-
€€$ %
$num
€€& '
)
€€' (
-
€€) *
pageSize
€€+ 3
.
€€3 4"
NumberOfLeadingZeros
€€4 H
(
€€H I
)
€€I J
;
€€J K
}
‹‹ 	
static
ﬁﬁ 
int
ﬁﬁ +
ValidateAndCalculateChunkSize
ﬁﬁ 0
(
ﬁﬁ0 1
int
ﬁﬁ1 4
pageSize
ﬁﬁ5 =
,
ﬁﬁ= >
int
ﬁﬁ? B
maxOrder
ﬁﬁC K
)
ﬁﬁK L
{
ﬂﬂ 	
Contract
‡‡ 
.
‡‡ 
Requires
‡‡ 
(
‡‡ 
maxOrder
‡‡ &
<=
‡‡' )
$num
‡‡* ,
)
‡‡, -
;
‡‡- .
int
„„ 
	chunkSize
„„ 
=
„„ 
pageSize
„„ $
;
„„$ %
for
‰‰ 
(
‰‰ 
int
‰‰ 
i
‰‰ 
=
‰‰ 
maxOrder
‰‰ !
;
‰‰! "
i
‰‰# $
>
‰‰% &
$num
‰‰' (
;
‰‰( )
i
‰‰* +
--
‰‰+ -
)
‰‰- .
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
	chunkSize
ÊÊ 
>
ÊÊ 
MaxChunkSize
ÊÊ  ,
>>
ÊÊ- /
$num
ÊÊ0 1
)
ÊÊ1 2
{
ÁÁ 
throw
ËË 
new
ËË 
ArgumentException
ËË /
(
ËË/ 0
$"
ËË0 2
$str
ËË2 <
{
ËË< =
pageSize
ËË= E
}
ËËE F
$str
ËËF U
{
ËËU V
maxOrder
ËËV ^
}
ËË^ _
$str
ËË_ q
{
ËËq r
MaxChunkSize
ËËr ~
}
ËË~ 
"ËË Ä
)ËËÄ Å
;ËËÅ Ç
}
ÈÈ 
	chunkSize
ÍÍ 
<<=
ÍÍ 
$num
ÍÍ 
;
ÍÍ  
}
ÎÎ 
return
ÏÏ 
	chunkSize
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
	protected
ÔÔ 
override
ÔÔ 
IByteBuffer
ÔÔ &
NewHeapBuffer
ÔÔ' 4
(
ÔÔ4 5
int
ÔÔ5 8
initialCapacity
ÔÔ9 H
,
ÔÔH I
int
ÔÔJ M
maxCapacity
ÔÔN Y
)
ÔÔY Z
{
 	
PoolThreadCache
ÒÒ 
<
ÒÒ 
byte
ÒÒ  
[
ÒÒ  !
]
ÒÒ! "
>
ÒÒ" #
cache
ÒÒ$ )
=
ÒÒ* +
this
ÒÒ, 0
.
ÒÒ0 1
threadCache
ÒÒ1 <
.
ÒÒ< =
Value
ÒÒ= B
;
ÒÒB C
	PoolArena
ÚÚ 
<
ÚÚ 
byte
ÚÚ 
[
ÚÚ 
]
ÚÚ 
>
ÚÚ 
	heapArena
ÚÚ '
=
ÚÚ( )
cache
ÚÚ* /
.
ÚÚ/ 0
	HeapArena
ÚÚ0 9
;
ÚÚ9 :
IByteBuffer
ÙÙ 
buf
ÙÙ 
;
ÙÙ 
if
ıı 
(
ıı 
	heapArena
ıı 
!=
ıı 
null
ıı !
)
ıı! "
{
ˆˆ 
buf
˜˜ 
=
˜˜ 
	heapArena
˜˜ 
.
˜˜  
Allocate
˜˜  (
(
˜˜( )
cache
˜˜) .
,
˜˜. /
initialCapacity
˜˜0 ?
,
˜˜? @
maxCapacity
˜˜A L
)
˜˜L M
;
˜˜M N
}
¯¯ 
else
˘˘ 
{
˙˙ 
buf
˚˚ 
=
˚˚ 
new
˚˚ $
UnpooledHeapByteBuffer
˚˚ 0
(
˚˚0 1
this
˚˚1 5
,
˚˚5 6
initialCapacity
˚˚7 F
,
˚˚F G
maxCapacity
˚˚H S
)
˚˚S T
;
˚˚T U
}
¸¸ 
return
˛˛ 
ToLeakAwareBuffer
˛˛ $
(
˛˛$ %
buf
˛˛% (
)
˛˛( )
;
˛˛) *
}
ˇˇ 	
	protected
ÅÅ 
unsafe
ÅÅ 
override
ÅÅ !
IByteBuffer
ÅÅ" -
NewDirectBuffer
ÅÅ. =
(
ÅÅ= >
int
ÅÅ> A
initialCapacity
ÅÅB Q
,
ÅÅQ R
int
ÅÅS V
maxCapacity
ÅÅW b
)
ÅÅb c
{
ÇÇ 	
PoolThreadCache
ÉÉ 
<
ÉÉ 
byte
ÉÉ  
[
ÉÉ  !
]
ÉÉ! "
>
ÉÉ" #
cache
ÉÉ$ )
=
ÉÉ* +
this
ÉÉ, 0
.
ÉÉ0 1
threadCache
ÉÉ1 <
.
ÉÉ< =
Value
ÉÉ= B
;
ÉÉB C
	PoolArena
ÑÑ 
<
ÑÑ 
byte
ÑÑ 
[
ÑÑ 
]
ÑÑ 
>
ÑÑ 
directArena
ÑÑ )
=
ÑÑ* +
cache
ÑÑ, 1
.
ÑÑ1 2
DirectArena
ÑÑ2 =
;
ÑÑ= >
IByteBuffer
ÜÜ 
buf
ÜÜ 
;
ÜÜ 
if
áá 
(
áá 
directArena
áá 
!=
áá 
null
áá #
)
áá# $
{
àà 
buf
ââ 
=
ââ 
directArena
ââ !
.
ââ! "
Allocate
ââ" *
(
ââ* +
cache
ââ+ 0
,
ââ0 1
initialCapacity
ââ2 A
,
ââA B
maxCapacity
ââC N
)
ââN O
;
ââO P
}
ää 
else
ãã 
{
åå 
buf
çç 
=
çç "
UnsafeByteBufferUtil
çç *
.
çç* +'
NewUnsafeDirectByteBuffer
çç+ D
(
ççD E
this
ççE I
,
ççI J
initialCapacity
ççK Z
,
ççZ [
maxCapacity
çç\ g
)
ççg h
;
ççh i
}
éé 
return
êê 
ToLeakAwareBuffer
êê $
(
êê$ %
buf
êê% (
)
êê( )
;
êê) *
}
ëë 	
public
ìì 
static
ìì 
bool
ìì !
DefaultPreferDirect
ìì .
=>
ìì/ 1
PlatformDependent
ìì2 C
.
ììC D#
DirectBufferPreferred
ììD Y
;
ììY Z
public
ïï 
override
ïï 
bool
ïï "
IsDirectBufferPooled
ïï 1
=>
ïï2 4
this
ïï5 9
.
ïï9 :
directArenas
ïï: F
!=
ïïG I
null
ïïJ N
;
ïïN O
sealed
óó 
class
óó "
PoolThreadLocalCache
óó )
:
óó* +
FastThreadLocal
óó, ;
<
óó; <
PoolThreadCache
óó< K
<
óóK L
byte
óóL P
[
óóP Q
]
óóQ R
>
óóR S
>
óóS T
{
òò 	
readonly
ôô '
PooledByteBufferAllocator
ôô .
owner
ôô/ 4
;
ôô4 5
public
õõ "
PoolThreadLocalCache
õõ '
(
õõ' ('
PooledByteBufferAllocator
õõ( A
owner
õõB G
)
õõG H
{
úú 
this
ùù 
.
ùù 
owner
ùù 
=
ùù 
owner
ùù "
;
ùù" #
}
ûû 
	protected
†† 
override
†† 
PoolThreadCache
†† .
<
††. /
byte
††/ 3
[
††3 4
]
††4 5
>
††5 6
GetInitialValue
††7 F
(
††F G
)
††G H
{
°° 
lock
¢¢ 
(
¢¢ 
this
¢¢ 
)
¢¢ 
{
££ 
	PoolArena
§§ 
<
§§ 
byte
§§ "
[
§§" #
]
§§# $
>
§§$ %
	heapArena
§§& /
=
§§0 1
this
§§2 6
.
§§6 7
LeastUsedArena
§§7 E
(
§§E F
this
§§F J
.
§§J K
owner
§§K P
.
§§P Q

heapArenas
§§Q [
)
§§[ \
;
§§\ ]
	PoolArena
•• 
<
•• 
byte
•• "
[
••" #
]
••# $
>
••$ %
directArena
••& 1
=
••2 3
this
••4 8
.
••8 9
LeastUsedArena
••9 G
(
••G H
this
••H L
.
••L M
owner
••M R
.
••R S
directArenas
••S _
)
••_ `
;
••` a
return
ßß 
new
ßß 
PoolThreadCache
ßß .
<
ßß. /
byte
ßß/ 3
[
ßß3 4
]
ßß4 5
>
ßß5 6
(
ßß6 7
	heapArena
®® %
,
®®% &
directArena
®®' 2
,
®®2 3
this
©©  
.
©©  !
owner
©©! &
.
©©& '
tinyCacheSize
©©' 4
,
©©4 5
this
©©6 :
.
©©: ;
owner
©©; @
.
©©@ A
smallCacheSize
©©A O
,
©©O P
this
©©Q U
.
©©U V
owner
©©V [
.
©©[ \
normalCacheSize
©©\ k
,
©©k l,
DefaultMaxCachedBufferCapacity
™™ :
,
™™: ;&
DefaultCacheTrimInterval
™™< T
)
™™T U
;
™™U V
}
´´ 
}
¨¨ 
	protected
ÆÆ 
override
ÆÆ 
void
ÆÆ #
	OnRemoval
ÆÆ$ -
(
ÆÆ- .
PoolThreadCache
ÆÆ. =
<
ÆÆ= >
byte
ÆÆ> B
[
ÆÆB C
]
ÆÆC D
>
ÆÆD E
threadCache
ÆÆF Q
)
ÆÆQ R
=>
ÆÆS U
threadCache
ÆÆV a
.
ÆÆa b
Free
ÆÆb f
(
ÆÆf g
)
ÆÆg h
;
ÆÆh i
	PoolArena
∞∞ 
<
∞∞ 
T
∞∞ 
>
∞∞ 
LeastUsedArena
∞∞ '
<
∞∞' (
T
∞∞( )
>
∞∞) *
(
∞∞* +
	PoolArena
∞∞+ 4
<
∞∞4 5
T
∞∞5 6
>
∞∞6 7
[
∞∞7 8
]
∞∞8 9
arenas
∞∞: @
)
∞∞@ A
{
±± 
if
≤≤ 
(
≤≤ 
arenas
≤≤ 
==
≤≤ 
null
≤≤ "
||
≤≤# %
arenas
≤≤& ,
.
≤≤, -
Length
≤≤- 3
==
≤≤4 6
$num
≤≤7 8
)
≤≤8 9
{
≥≥ 
return
¥¥ 
null
¥¥ 
;
¥¥  
}
µµ 
	PoolArena
∑∑ 
<
∑∑ 
T
∑∑ 
>
∑∑ 
minArena
∑∑ %
=
∑∑& '
arenas
∑∑( .
[
∑∑. /
$num
∑∑/ 0
]
∑∑0 1
;
∑∑1 2
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏  !
<
∏∏" #
arenas
∏∏$ *
.
∏∏* +
Length
∏∏+ 1
;
∏∏1 2
i
∏∏3 4
++
∏∏4 6
)
∏∏6 7
{
ππ 
	PoolArena
∫∫ 
<
∫∫ 
T
∫∫ 
>
∫∫  
arena
∫∫! &
=
∫∫' (
arenas
∫∫) /
[
∫∫/ 0
i
∫∫0 1
]
∫∫1 2
;
∫∫2 3
if
ªª 
(
ªª 
arena
ªª 
.
ªª 
NumThreadCaches
ªª -
<
ªª. /
minArena
ªª0 8
.
ªª8 9
NumThreadCaches
ªª9 H
)
ªªH I
{
ºº 
minArena
ΩΩ  
=
ΩΩ! "
arena
ΩΩ# (
;
ΩΩ( )
}
ææ 
}
øø 
return
¡¡ 
minArena
¡¡ 
;
¡¡  
}
¬¬ 
}
√√ 	
internal
≈≈ 
IReadOnlyList
≈≈ 
<
≈≈ 
IPoolArenaMetric
≈≈ /
>
≈≈/ 0

HeapArenas
≈≈1 ;
(
≈≈; <
)
≈≈< =
=>
≈≈> @
this
≈≈A E
.
≈≈E F
heapArenaMetrics
≈≈F V
;
≈≈V W
internal
«« 
IReadOnlyList
«« 
<
«« 
IPoolArenaMetric
«« /
>
««/ 0
DirectArenas
««1 =
(
««= >
)
««> ?
=>
««@ B
this
««C G
.
««G H 
directArenaMetrics
««H Z
;
««Z [
internal
…… 
int
…… 
TinyCacheSize
…… "
=>
……# %
this
……& *
.
……* +
tinyCacheSize
……+ 8
;
……8 9
internal
ÀÀ 
int
ÀÀ 
SmallCacheSize
ÀÀ #
=>
ÀÀ$ &
this
ÀÀ' +
.
ÀÀ+ ,
smallCacheSize
ÀÀ, :
;
ÀÀ: ;
internal
ÕÕ 
int
ÕÕ 
NormalCacheSize
ÕÕ $
=>
ÕÕ% '
this
ÕÕ( ,
.
ÕÕ, -
normalCacheSize
ÕÕ- <
;
ÕÕ< =
internal
œœ 
int
œœ 
	ChunkSize
œœ 
=>
œœ !
this
œœ" &
.
œœ& '
	chunkSize
œœ' 0
;
œœ0 1
public
—— -
PooledByteBufferAllocatorMetric
—— .
Metric
——/ 5
=>
——6 8
this
——9 =
.
——= >
metric
——> D
;
——D E(
IByteBufferAllocatorMetric
”” "0
"IByteBufferAllocatorMetricProvider
””# E
.
””E F
Metric
””F L
=>
””M O
this
””P T
.
””T U
Metric
””U [
;
””[ \
internal
’’ 
long
’’ 
UsedHeapMemory
’’ $
=>
’’% '

UsedMemory
’’( 2
(
’’2 3
this
’’3 7
.
’’7 8

heapArenas
’’8 B
)
’’B C
;
’’C D
internal
◊◊ 
long
◊◊ 
UsedDirectMemory
◊◊ &
=>
◊◊' )

UsedMemory
◊◊* 4
(
◊◊4 5
this
◊◊5 9
.
◊◊9 :
directArenas
◊◊: F
)
◊◊F G
;
◊◊G H
static
ŸŸ 
long
ŸŸ 

UsedMemory
ŸŸ 
(
ŸŸ 
	PoolArena
ŸŸ (
<
ŸŸ( )
byte
ŸŸ) -
[
ŸŸ- .
]
ŸŸ. /
>
ŸŸ/ 0
[
ŸŸ0 1
]
ŸŸ1 2
arenas
ŸŸ3 9
)
ŸŸ9 :
{
⁄⁄ 	
if
€€ 
(
€€ 
arenas
€€ 
==
€€ 
null
€€ 
)
€€ 
{
‹‹ 
return
›› 
-
›› 
$num
›› 
;
›› 
}
ﬁﬁ 
long
ﬂﬂ 
used
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
foreach
‡‡ 
(
‡‡ 
	PoolArena
‡‡ 
<
‡‡ 
byte
‡‡ #
[
‡‡# $
]
‡‡$ %
>
‡‡% &
arena
‡‡' ,
in
‡‡- /
arenas
‡‡0 6
)
‡‡6 7
{
·· 
used
‚‚ 
+=
‚‚ 
arena
‚‚ 
.
‚‚ 
NumActiveBytes
‚‚ ,
;
‚‚, -
if
„„ 
(
„„ 
used
„„ 
<
„„ 
$num
„„ 
)
„„ 
{
‰‰ 
return
ÂÂ 
long
ÂÂ 
.
ÂÂ  
MaxValue
ÂÂ  (
;
ÂÂ( )
}
ÊÊ 
}
ÁÁ 
return
ÈÈ 
used
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
internal
ÏÏ 
PoolThreadCache
ÏÏ  
<
ÏÏ  !
T
ÏÏ! "
>
ÏÏ" #
ThreadCache
ÏÏ$ /
<
ÏÏ/ 0
T
ÏÏ0 1
>
ÏÏ1 2
(
ÏÏ2 3
)
ÏÏ3 4
=>
ÏÏ5 7
(
ÏÏ8 9
PoolThreadCache
ÏÏ9 H
<
ÏÏH I
T
ÏÏI J
>
ÏÏJ K
)
ÏÏK L
(
ÏÏL M
object
ÏÏM S
)
ÏÏS T
this
ÏÏT X
.
ÏÏX Y
threadCache
ÏÏY d
.
ÏÏd e
Value
ÏÏe j
;
ÏÏj k
public
 
string
 
	DumpStats
 
(
  
)
  !
{
ÒÒ 	
int
ÚÚ 
heapArenasLen
ÚÚ 
=
ÚÚ 
this
ÚÚ  $
.
ÚÚ$ %

heapArenas
ÚÚ% /
?
ÚÚ/ 0
.
ÚÚ0 1
Length
ÚÚ1 7
??
ÚÚ8 :
$num
ÚÚ; <
;
ÚÚ< =
StringBuilder
ÛÛ 
buf
ÛÛ 
=
ÛÛ 
new
ÛÛ  #
StringBuilder
ÛÛ$ 1
(
ÛÛ1 2
$num
ÛÛ2 5
)
ÛÛ5 6
.
ÙÙ 
Append
ÙÙ 
(
ÙÙ 
heapArenasLen
ÙÙ )
)
ÙÙ) *
.
ıı 
Append
ıı 
(
ıı 
$str
ıı -
)
ıı- .
.
ˆˆ 
Append
ˆˆ 
(
ˆˆ 

StringUtil
ˆˆ &
.
ˆˆ& '
Newline
ˆˆ' .
)
ˆˆ. /
;
ˆˆ/ 0
if
˜˜ 
(
˜˜ 
heapArenasLen
˜˜ 
>
˜˜ 
$num
˜˜  !
)
˜˜! "
{
¯¯ 
foreach
˙˙ 
(
˙˙ 
	PoolArena
˙˙ "
<
˙˙" #
byte
˙˙# '
[
˙˙' (
]
˙˙( )
>
˙˙) *
a
˙˙+ ,
in
˙˙- /
this
˙˙0 4
.
˙˙4 5

heapArenas
˙˙5 ?
)
˙˙? @
{
˚˚ 
buf
¸¸ 
.
¸¸ 
Append
¸¸ 
(
¸¸ 
a
¸¸  
)
¸¸  !
;
¸¸! "
}
˝˝ 
}
˛˛ 
int
ÄÄ 
directArenasLen
ÄÄ 
=
ÄÄ  !
this
ÄÄ" &
.
ÄÄ& '
directArenas
ÄÄ' 3
?
ÄÄ3 4
.
ÄÄ4 5
Length
ÄÄ5 ;
??
ÄÄ< >
$num
ÄÄ? @
;
ÄÄ@ A
buf
ÅÅ 
.
ÅÅ 
Append
ÅÅ 
(
ÅÅ 
directArenasLen
ÅÅ &
)
ÅÅ& '
.
ÇÇ 
Append
ÇÇ 
(
ÇÇ 
$str
ÇÇ +
)
ÇÇ+ ,
.
ÉÉ 
Append
ÉÉ 
(
ÉÉ 

StringUtil
ÉÉ "
.
ÉÉ" #
Newline
ÉÉ# *
)
ÉÉ* +
;
ÉÉ+ ,
if
ÑÑ 
(
ÑÑ 
directArenasLen
ÑÑ 
>
ÑÑ  !
$num
ÑÑ" #
)
ÑÑ# $
{
ÖÖ 
foreach
áá 
(
áá 
	PoolArena
áá "
<
áá" #
byte
áá# '
[
áá' (
]
áá( )
>
áá) *
a
áá+ ,
in
áá- /
this
áá0 4
.
áá4 5
directArenas
áá5 A
)
ááA B
{
àà 
buf
ââ 
.
ââ 
Append
ââ 
(
ââ 
a
ââ  
)
ââ  !
;
ââ! "
}
ää 
}
ãã 
return
çç 
buf
çç 
.
çç 
ToString
çç 
(
çç  
)
çç  !
;
çç! "
}
éé 	
}
èè 
}êê û5
rC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledByteBufferAllocatorMetric.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public

 

sealed

 
class

 +
PooledByteBufferAllocatorMetric

 7
:

8 9&
IByteBufferAllocatorMetric

: T
{ 
readonly %
PooledByteBufferAllocator *
	allocator+ 4
;4 5
internal +
PooledByteBufferAllocatorMetric 0
(0 1%
PooledByteBufferAllocator1 J
	allocatorK T
)T U
{ 	
this 
. 
	allocator 
= 
	allocator &
;& '
} 	
public 
IReadOnlyList 
< 
IPoolArenaMetric -
>- .

HeapArenas/ 9
(9 :
): ;
=>< >
this? C
.C D
	allocatorD M
.M N

HeapArenasN X
(X Y
)Y Z
;Z [
public 
IReadOnlyList 
< 
IPoolArenaMetric -
>- .
DirectArenas/ ;
(; <
)< =
=>> @
thisA E
.E F
	allocatorF O
.O P
DirectArenasP \
(\ ]
)] ^
;^ _
public 
int 
TinyCacheSize  
=>! #
this$ (
.( )
	allocator) 2
.2 3
TinyCacheSize3 @
;@ A
public 
int 
SmallCacheSize !
=>" $
this% )
.) *
	allocator* 3
.3 4
SmallCacheSize4 B
;B C
public 
int 
NormalCacheSize "
=># %
this& *
.* +
	allocator+ 4
.4 5
NormalCacheSize5 D
;D E
public 
int 
	ChunkSize 
=> 
this  $
.$ %
	allocator% .
.. /
	ChunkSize/ 8
;8 9
public 
long 
UsedHeapMemory "
=># %
this& *
.* +
	allocator+ 4
.4 5
UsedHeapMemory5 C
;C D
public!! 
long!! 
UsedDirectMemory!! $
=>!!% '
this!!( ,
.!!, -
	allocator!!- 6
.!!6 7
UsedDirectMemory!!7 G
;!!G H
public## 
int##  
NumThreadLocalCaches## '
(##' (
)##( )
{$$ 	
int%% 
total%% 
=%% 
$num%% 
;%% 
IReadOnlyList&& 
<&& 
IPoolArenaMetric&& *
>&&* +
arenas&&, 2
=&&3 4
this&&5 9
.&&9 :

HeapArenas&&: D
(&&D E
)&&E F
;&&F G
if'' 
('' 
arenas'' 
!='' 
null'' 
)'' 
{(( 
foreach)) 
()) 
IPoolArenaMetric)) )
metric))* 0
in))1 3
arenas))4 :
))): ;
{** 
total++ 
+=++ 
metric++ #
.++# $
NumThreadCaches++$ 3
;++3 4
},, 
}-- 
arenas// 
=// 
this// 
.// 
DirectArenas// &
(//& '
)//' (
;//( )
if00 
(00 
arenas00 
!=00 
null00 
)00 
{11 
foreach22 
(22 
IPoolArenaMetric22 )
metric22* 0
in221 3
arenas224 :
)22: ;
{33 
total44 
+=44 
metric44 #
.44# $
NumThreadCaches44$ 3
;443 4
}55 
}66 
return88 
total88 
;88 
}99 	
public;; 
override;; 
string;; 
ToString;; '
(;;' (
);;( )
{<< 	
var== 
sb== 
=== 
new== 
StringBuilder== &
(==& '
$num==' *
)==* +
;==+ ,
sb>> 
.>> 
Append>> 
(>> 

StringUtil>>  
.>>  !
SimpleClassName>>! 0
(>>0 1
this>>1 5
)>>5 6
)>>6 7
.?? 
Append?? 
(?? 
$str?? +
)??+ ,
.??, -
Append??- 3
(??3 4
this??4 8
.??8 9
UsedHeapMemory??9 G
)??G H
.@@ 
Append@@ 
(@@ 
$str@@ .
)@@. /
.@@/ 0
Append@@0 6
(@@6 7
this@@7 ;
.@@; <
UsedDirectMemory@@< L
)@@L M
.AA 
AppendAA 
(AA 
$strAA +
)AA+ ,
.AA, -
AppendAA- 3
(AA3 4
thisAA4 8
.AA8 9

HeapArenasAA9 C
(AAC D
)AAD E
.AAE F
CountAAF K
)AAK L
.BB 
AppendBB 
(BB 
$strBB -
)BB- .
.BB. /
AppendBB/ 5
(BB5 6
thisBB6 :
.BB: ;
DirectArenasBB; G
(BBG H
)BBH I
.BBI J
CountBBJ O
)BBO P
.CC 
AppendCC 
(CC 
$strCC +
)CC+ ,
.CC, -
AppendCC- 3
(CC3 4
thisCC4 8
.CC8 9
TinyCacheSizeCC9 F
)CCF G
.DD 
AppendDD 
(DD 
$strDD ,
)DD, -
.DD- .
AppendDD. 4
(DD4 5
thisDD5 9
.DD9 :
SmallCacheSizeDD: H
)DDH I
.EE 
AppendEE 
(EE 
$strEE -
)EE- .
.EE. /
AppendEE/ 5
(EE5 6
thisEE6 :
.EE: ;
NormalCacheSizeEE; J
)EEJ K
.FF 
AppendFF 
(FF 
$strFF 2
)FF2 3
.FF3 4
AppendFF4 :
(FF: ;
thisFF; ?
.FF? @ 
NumThreadLocalCachesFF@ T
(FFT U
)FFU V
)FFV W
.GG 
AppendGG 
(GG 
$strGG '
)GG' (
.GG( )
AppendGG) /
(GG/ 0
thisGG0 4
.GG4 5
	ChunkSizeGG5 >
)GG> ?
.GG? @
AppendGG@ F
(GGF G
$charGGG J
)GGJ K
;GGK L
returnHH 
sbHH 
.HH 
ToStringHH 
(HH 
)HH  
;HH  !
}II 	
}JJ 
}KK Ÿê
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledDuplicatedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class &
PooledDuplicatedByteBuffer +
:, -+
AbstractPooledDerivedByteBuffer. M
{ 
static 
readonly 
ThreadLocalPool '
<' (&
PooledDuplicatedByteBuffer( B
>B C
RecyclerD L
=M N
newO R
ThreadLocalPoolS b
<b c&
PooledDuplicatedByteBufferc }
>} ~
(~ 
handle	 Ö
=>
Ü à
new
â å(
PooledDuplicatedByteBuffer
ç ß
(
ß ®
handle
® Æ
)
Æ Ø
)
Ø ∞
;
∞ ±
internal 
static &
PooledDuplicatedByteBuffer 2
NewInstance3 >
(> ?
AbstractByteBuffer? Q
	unwrappedR [
,[ \
IByteBuffer] h
wrappedi p
,p q
intr u
readerIndex	v Å
,
Å Ç
int
É Ü
writerIndex
á í
)
í ì
{ 	&
PooledDuplicatedByteBuffer &
	duplicate' 0
=1 2
Recycler3 ;
.; <
Take< @
(@ A
)A B
;B C
	duplicate 
. 
Init 
< &
PooledDuplicatedByteBuffer 5
>5 6
(6 7
	unwrapped7 @
,@ A
wrappedB I
,I J
readerIndexK V
,V W
writerIndexX c
,c d
	unwrappede n
.n o
MaxCapacityo z
)z {
;{ |
	duplicate 
. 
MarkReaderIndex %
(% &
)& '
;' (
	duplicate 
. 
MarkWriterIndex %
(% &
)& '
;' (
return 
	duplicate 
; 
} 	
public &
PooledDuplicatedByteBuffer )
() *
ThreadLocalPool* 9
.9 :
Handle: @
recyclerHandleA O
)O P
: 
base 
( 
recyclerHandle !
)! "
{ 	
} 	
public 
override 
int 
Capacity $
=>% '
this( ,
., -
Unwrap- 3
(3 4
)4 5
.5 6
Capacity6 >
;> ?
public!! 
override!! 
IByteBuffer!! #
AdjustCapacity!!$ 2
(!!2 3
int!!3 6
newCapacity!!7 B
)!!B C
{"" 	
this## 
.## 
Unwrap## 
(## 
)## 
.## 
AdjustCapacity## (
(##( )
newCapacity##) 4
)##4 5
;##5 6
return$$ 
this$$ 
;$$ 
}%% 	
public'' 
override'' 
int'' 
ArrayOffset'' '
=>''( *
this''+ /
.''/ 0
Unwrap''0 6
(''6 7
)''7 8
.''8 9
ArrayOffset''9 D
;''D E
public)) 
override)) 
ref)) 
byte))  $
GetPinnableMemoryAddress))! 9
())9 :
))): ;
=>))< >
ref))? B
this))C G
.))G H
Unwrap))H N
())N O
)))O P
.))P Q$
GetPinnableMemoryAddress))Q i
())i j
)))j k
;))k l
public++ 
override++ 
IntPtr++ !
AddressOfPinnedMemory++ 4
(++4 5
)++5 6
=>++7 9
this++: >
.++> ?
Unwrap++? E
(++E F
)++F G
.++G H!
AddressOfPinnedMemory++H ]
(++] ^
)++^ _
;++_ `
public-- 
override-- 
ArraySegment-- $
<--$ %
byte--% )
>--) *
GetIoBuffer--+ 6
(--6 7
int--7 :
index--; @
,--@ A
int--B E
length--F L
)--L M
=>--N P
this--Q U
.--U V
Unwrap--V \
(--\ ]
)--] ^
.--^ _
GetIoBuffer--_ j
(--j k
index--k p
,--p q
length--r x
)--x y
;--y z
public// 
override// 
ArraySegment// $
<//$ %
byte//% )
>//) *
[//* +
]//+ ,
GetIoBuffers//- 9
(//9 :
int//: =
index//> C
,//C D
int//E H
length//I O
)//O P
=>//Q S
this//T X
.//X Y
Unwrap//Y _
(//_ `
)//` a
.//a b
GetIoBuffers//b n
(//n o
index//o t
,//t u
length//v |
)//| }
;//} ~
public11 
override11 
IByteBuffer11 #
Copy11$ (
(11( )
int11) ,
index11- 2
,112 3
int114 7
length118 >
)11> ?
=>11@ B
this11C G
.11G H
Unwrap11H N
(11N O
)11O P
.11P Q
Copy11Q U
(11U V
index11V [
,11[ \
length11] c
)11c d
;11d e
public33 
override33 
IByteBuffer33 #
RetainedSlice33$ 1
(331 2
int332 5
index336 ;
,33; <
int33= @
length33A G
)33G H
=>33I K"
PooledSlicedByteBuffer33L b
.33b c
NewInstance33c n
(33n o
this33o s
.33s t

UnwrapCore33t ~
(33~ 
)	33 Ä
,
33Ä Å
this
33Ç Ü
,
33Ü á
index
33à ç
,
33ç é
length
33è ï
)
33ï ñ
;
33ñ ó
public55 
override55 
IByteBuffer55 #
	Duplicate55$ -
(55- .
)55. /
=>550 2
this553 7
.557 8

Duplicate0558 B
(55B C
)55C D
.55D E
SetIndex55E M
(55M N
this55N R
.55R S
ReaderIndex55S ^
,55^ _
this55` d
.55d e
WriterIndex55e p
)55p q
;55q r
public77 
override77 
IByteBuffer77 #
RetainedDuplicate77$ 5
(775 6
)776 7
=>778 :
NewInstance77; F
(77F G
this77G K
.77K L

UnwrapCore77L V
(77V W
)77W X
,77X Y
this77Z ^
,77^ _
this77` d
.77d e
ReaderIndex77e p
,77p q
this77r v
.77v w
WriterIndex	77w Ç
)
77Ç É
;
77É Ñ
	protected99 
internal99 
override99 #
byte99$ (
_GetByte99) 1
(991 2
int992 5
index996 ;
)99; <
=>99= ?
this99@ D
.99D E

UnwrapCore99E O
(99O P
)99P Q
.99Q R
_GetByte99R Z
(99Z [
index99[ `
)99` a
;99a b
	protected;; 
internal;; 
override;; #
short;;$ )
	_GetShort;;* 3
(;;3 4
int;;4 7
index;;8 =
);;= >
=>;;? A
this;;B F
.;;F G

UnwrapCore;;G Q
(;;Q R
);;R S
.;;S T
	_GetShort;;T ]
(;;] ^
index;;^ c
);;c d
;;;d e
	protected== 
internal== 
override== #
short==$ )
_GetShortLE==* 5
(==5 6
int==6 9
index==: ?
)==? @
=>==A C
this==D H
.==H I

UnwrapCore==I S
(==S T
)==T U
.==U V
_GetShortLE==V a
(==a b
index==b g
)==g h
;==h i
	protected?? 
internal?? 
override?? #
int??$ '
_GetUnsignedMedium??( :
(??: ;
int??; >
index??? D
)??D E
=>??F H
this??I M
.??M N

UnwrapCore??N X
(??X Y
)??Y Z
.??Z [
_GetUnsignedMedium??[ m
(??m n
index??n s
)??s t
;??t u
	protectedAA 
internalAA 
overrideAA #
intAA$ ' 
_GetUnsignedMediumLEAA( <
(AA< =
intAA= @
indexAAA F
)AAF G
=>AAH J
thisAAK O
.AAO P

UnwrapCoreAAP Z
(AAZ [
)AA[ \
.AA\ ] 
_GetUnsignedMediumLEAA] q
(AAq r
indexAAr w
)AAw x
;AAx y
	protectedCC 
internalCC 
overrideCC #
intCC$ '
_GetIntCC( /
(CC/ 0
intCC0 3
indexCC4 9
)CC9 :
=>CC; =
thisCC> B
.CCB C

UnwrapCoreCCC M
(CCM N
)CCN O
.CCO P
_GetIntCCP W
(CCW X
indexCCX ]
)CC] ^
;CC^ _
	protectedEE 
internalEE 
overrideEE #
intEE$ '
	_GetIntLEEE( 1
(EE1 2
intEE2 5
indexEE6 ;
)EE; <
=>EE= ?
thisEE@ D
.EED E

UnwrapCoreEEE O
(EEO P
)EEP Q
.EEQ R
	_GetIntLEEER [
(EE[ \
indexEE\ a
)EEa b
;EEb c
	protectedGG 
internalGG 
overrideGG #
longGG$ (
_GetLongGG) 1
(GG1 2
intGG2 5
indexGG6 ;
)GG; <
=>GG= ?
thisGG@ D
.GGD E

UnwrapCoreGGE O
(GGO P
)GGP Q
.GGQ R
_GetLongGGR Z
(GGZ [
indexGG[ `
)GG` a
;GGa b
	protectedII 
internalII 
overrideII #
longII$ (

_GetLongLEII) 3
(II3 4
intII4 7
indexII8 =
)II= >
=>II? A
thisIIB F
.IIF G

UnwrapCoreIIG Q
(IIQ R
)IIR S
.IIS T

_GetLongLEIIT ^
(II^ _
indexII_ d
)IId e
;IIe f
publicKK 
overrideKK 
IByteBufferKK #
GetBytesKK$ ,
(KK, -
intKK- 0
indexKK1 6
,KK6 7
IByteBufferKK8 C
destinationKKD O
,KKO P
intKKQ T
dstIndexKKU ]
,KK] ^
intKK_ b
lengthKKc i
)KKi j
=>KKk m
thisKKn r
.KKr s
UnwrapKKs y
(KKy z
)KKz {
.KK{ |
GetBytes	KK| Ñ
(
KKÑ Ö
index
KKÖ ä
,
KKä ã
destination
KKå ó
,
KKó ò
dstIndex
KKô °
,
KK° ¢
length
KK£ ©
)
KK© ™
;
KK™ ´
publicMM 
overrideMM 
IByteBufferMM #
GetBytesMM$ ,
(MM, -
intMM- 0
indexMM1 6
,MM6 7
byteMM8 <
[MM< =
]MM= >
destinationMM? J
,MMJ K
intMML O
dstIndexMMP X
,MMX Y
intMMZ ]
lengthMM^ d
)MMd e
=>MMf h
thisMMi m
.MMm n
UnwrapMMn t
(MMt u
)MMu v
.MMv w
GetBytesMMw 
(	MM Ä
index
MMÄ Ö
,
MMÖ Ü
destination
MMá í
,
MMí ì
dstIndex
MMî ú
,
MMú ù
length
MMû §
)
MM§ •
;
MM• ¶
publicOO 
overrideOO 
IByteBufferOO #
GetBytesOO$ ,
(OO, -
intOO- 0
indexOO1 6
,OO6 7
StreamOO8 >
destinationOO? J
,OOJ K
intOOL O
lengthOOP V
)OOV W
=>OOX Z
thisOO[ _
.OO_ `
UnwrapOO` f
(OOf g
)OOg h
.OOh i
GetBytesOOi q
(OOq r
indexOOr w
,OOw x
destination	OOy Ñ
,
OOÑ Ö
length
OOÜ å
)
OOå ç
;
OOç é
	protectedQQ 
internalQQ 
overrideQQ #
voidQQ$ (
_SetByteQQ) 1
(QQ1 2
intQQ2 5
indexQQ6 ;
,QQ; <
intQQ= @
valueQQA F
)QQF G
=>QQH J
thisQQK O
.QQO P

UnwrapCoreQQP Z
(QQZ [
)QQ[ \
.QQ\ ]
_SetByteQQ] e
(QQe f
indexQQf k
,QQk l
valueQQm r
)QQr s
;QQs t
	protectedSS 
internalSS 
overrideSS #
voidSS$ (
	_SetShortSS) 2
(SS2 3
intSS3 6
indexSS7 <
,SS< =
intSS> A
valueSSB G
)SSG H
=>SSI K
thisSSL P
.SSP Q

UnwrapCoreSSQ [
(SS[ \
)SS\ ]
.SS] ^
	_SetShortSS^ g
(SSg h
indexSSh m
,SSm n
valueSSo t
)SSt u
;SSu v
	protectedUU 
internalUU 
overrideUU #
voidUU$ (
_SetShortLEUU) 4
(UU4 5
intUU5 8
indexUU9 >
,UU> ?
intUU@ C
valueUUD I
)UUI J
=>UUK M
thisUUN R
.UUR S

UnwrapCoreUUS ]
(UU] ^
)UU^ _
.UU_ `
_SetShortLEUU` k
(UUk l
indexUUl q
,UUq r
valueUUs x
)UUx y
;UUy z
	protectedWW 
internalWW 
overrideWW #
voidWW$ (

_SetMediumWW) 3
(WW3 4
intWW4 7
indexWW8 =
,WW= >
intWW? B
valueWWC H
)WWH I
=>WWJ L
thisWWM Q
.WWQ R

UnwrapCoreWWR \
(WW\ ]
)WW] ^
.WW^ _

_SetMediumWW_ i
(WWi j
indexWWj o
,WWo p
valueWWq v
)WWv w
;WWw x
	protectedYY 
internalYY 
overrideYY #
voidYY$ (
_SetMediumLEYY) 5
(YY5 6
intYY6 9
indexYY: ?
,YY? @
intYYA D
valueYYE J
)YYJ K
=>YYL N
thisYYO S
.YYS T

UnwrapCoreYYT ^
(YY^ _
)YY_ `
.YY` a
_SetMediumLEYYa m
(YYm n
indexYYn s
,YYs t
valueYYu z
)YYz {
;YY{ |
public[[ 
override[[ 
IByteBuffer[[ #
SetBytes[[$ ,
([[, -
int[[- 0
index[[1 6
,[[6 7
IByteBuffer[[8 C
src[[D G
,[[G H
int[[I L
srcIndex[[M U
,[[U V
int[[W Z
length[[[ a
)[[a b
=>[[c e
this[[f j
.[[j k
Unwrap[[k q
([[q r
)[[r s
.[[s t
SetBytes[[t |
([[| }
index	[[} Ç
,
[[Ç É
src
[[Ñ á
,
[[á à
srcIndex
[[â ë
,
[[ë í
length
[[ì ô
)
[[ô ö
;
[[ö õ
public]] 
override]] 
Task]] 
<]] 
int]]  
>]]  !
SetBytesAsync]]" /
(]]/ 0
int]]0 3
index]]4 9
,]]9 :
Stream]]; A
src]]B E
,]]E F
int]]G J
length]]K Q
,]]Q R
CancellationToken]]S d
cancellationToken]]e v
)]]v w
=>]]x z
this]]{ 
.	]] Ä
Unwrap
]]Ä Ü
(
]]Ü á
)
]]á à
.
]]à â
SetBytesAsync
]]â ñ
(
]]ñ ó
index
]]ó ú
,
]]ú ù
src
]]û °
,
]]° ¢
length
]]£ ©
,
]]© ™
cancellationToken
]]´ º
)
]]º Ω
;
]]Ω æ
public__ 
override__ 
IByteBuffer__ #
SetBytes__$ ,
(__, -
int__- 0
index__1 6
,__6 7
byte__8 <
[__< =
]__= >
src__? B
,__B C
int__D G
srcIndex__H P
,__P Q
int__R U
length__V \
)__\ ]
=>__^ `
this__a e
.__e f
Unwrap__f l
(__l m
)__m n
.__n o
SetBytes__o w
(__w x
index__x }
,__} ~
src	__ Ç
,
__Ç É
srcIndex
__Ñ å
,
__å ç
length
__é î
)
__î ï
;
__ï ñ
	protectedaa 
internalaa 
overrideaa #
voidaa$ (
_SetIntaa) 0
(aa0 1
intaa1 4
indexaa5 :
,aa: ;
intaa< ?
valueaa@ E
)aaE F
=>aaG I
thisaaJ N
.aaN O

UnwrapCoreaaO Y
(aaY Z
)aaZ [
.aa[ \
_SetIntaa\ c
(aac d
indexaad i
,aai j
valueaak p
)aap q
;aaq r
	protectedcc 
internalcc 
overridecc #
voidcc$ (
	_SetIntLEcc) 2
(cc2 3
intcc3 6
indexcc7 <
,cc< =
intcc> A
valueccB G
)ccG H
=>ccI K
thisccL P
.ccP Q

UnwrapCoreccQ [
(cc[ \
)cc\ ]
.cc] ^
	_SetIntLEcc^ g
(ccg h
indexcch m
,ccm n
valuecco t
)cct u
;ccu v
	protectedee 
internalee 
overrideee #
voidee$ (
_SetLongee) 1
(ee1 2
intee2 5
indexee6 ;
,ee; <
longee= A
valueeeB G
)eeG H
=>eeI K
thiseeL P
.eeP Q

UnwrapCoreeeQ [
(ee[ \
)ee\ ]
.ee] ^
_SetLongee^ f
(eef g
indexeeg l
,eel m
valueeen s
)ees t
;eet u
	protectedgg 
internalgg 
overridegg #
voidgg$ (

_SetLongLEgg) 3
(gg3 4
intgg4 7
indexgg8 =
,gg= >
longgg? C
valueggD I
)ggI J
=>ggK M
thisggN R
.ggR S

UnwrapCoreggS ]
(gg] ^
)gg^ _
.gg_ `

_SetLongLEgg` j
(ggj k
indexggk p
,ggp q
valueggr w
)ggw x
;ggx y
}ii 
}jj ∆∏
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledHeapByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class  
PooledHeapByteBuffer %
:& '
PooledByteBuffer( 8
<8 9
byte9 =
[= >
]> ?
>? @
{ 
internal 
static  
PooledHeapByteBuffer ,
NewInstance- 8
(8 9
int9 <
maxCapacity= H
)H I
{ 	
return 
new  
PooledHeapByteBuffer +
(+ ,
maxCapacity, 7
)7 8
;8 9
} 	
internal  
PooledHeapByteBuffer %
(% &
int& )
maxCapacity* 5
)5 6
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
public 
override 
bool 
IsDirect %
=>& (
false) .
;. /
	protected 
internal 
override #
byte$ (
_GetByte) 1
(1 2
int2 5
index6 ;
); <
=>= ?
HeapByteBufferUtil@ R
.R S
GetByteS Z
(Z [
this[ _
._ `
Memory` f
,f g
thish l
.l m
Idxm p
(p q
indexq v
)v w
)w x
;x y
	protected 
internal 
override #
short$ )
	_GetShort* 3
(3 4
int4 7
index8 =
)= >
=>? A
HeapByteBufferUtilB T
.T U
GetShortU ]
(] ^
this^ b
.b c
Memoryc i
,i j
thisk o
.o p
Idxp s
(s t
indext y
)y z
)z {
;{ |
	protected 
internal 
override #
short$ )
_GetShortLE* 5
(5 6
int6 9
index: ?
)? @
=>A C
HeapByteBufferUtilD V
.V W

GetShortLEW a
(a b
thisb f
.f g
Memoryg m
,m n
thiso s
.s t
Idxt w
(w x
indexx }
)} ~
)~ 
;	 Ä
	protected   
internal   
override   #
int  $ '
_GetUnsignedMedium  ( :
(  : ;
int  ; >
index  ? D
)  D E
=>  F H
HeapByteBufferUtil  I [
.  [ \
GetUnsignedMedium  \ m
(  m n
this  n r
.  r s
Memory  s y
,  y z
this  { 
.	   Ä
Idx
  Ä É
(
  É Ñ
index
  Ñ â
)
  â ä
)
  ä ã
;
  ã å
	protected"" 
internal"" 
override"" #
int""$ ' 
_GetUnsignedMediumLE""( <
(""< =
int""= @
index""A F
)""F G
=>""H J
HeapByteBufferUtil""K ]
.""] ^
GetUnsignedMediumLE""^ q
(""q r
this""r v
.""v w
Memory""w }
,""} ~
this	"" É
.
""É Ñ
Idx
""Ñ á
(
""á à
index
""à ç
)
""ç é
)
""é è
;
""è ê
	protected$$ 
internal$$ 
override$$ #
int$$$ '
_GetInt$$( /
($$/ 0
int$$0 3
index$$4 9
)$$9 :
=>$$; =
HeapByteBufferUtil$$> P
.$$P Q
GetInt$$Q W
($$W X
this$$X \
.$$\ ]
Memory$$] c
,$$c d
this$$e i
.$$i j
Idx$$j m
($$m n
index$$n s
)$$s t
)$$t u
;$$u v
	protected&& 
internal&& 
override&& #
int&&$ '
	_GetIntLE&&( 1
(&&1 2
int&&2 5
index&&6 ;
)&&; <
=>&&= ?
HeapByteBufferUtil&&@ R
.&&R S
GetIntLE&&S [
(&&[ \
this&&\ `
.&&` a
Memory&&a g
,&&g h
this&&i m
.&&m n
Idx&&n q
(&&q r
index&&r w
)&&w x
)&&x y
;&&y z
	protected(( 
internal(( 
override(( #
long(($ (
_GetLong(() 1
(((1 2
int((2 5
index((6 ;
)((; <
=>((= ?
HeapByteBufferUtil((@ R
.((R S
GetLong((S Z
(((Z [
this(([ _
.((_ `
Memory((` f
,((f g
this((h l
.((l m
Idx((m p
(((p q
index((q v
)((v w
)((w x
;((x y
	protected** 
internal** 
override** #
long**$ (

_GetLongLE**) 3
(**3 4
int**4 7
index**8 =
)**= >
=>**? A
HeapByteBufferUtil**B T
.**T U
	GetLongLE**U ^
(**^ _
this**_ c
.**c d
Memory**d j
,**j k
this**l p
.**p q
Idx**q t
(**t u
index**u z
)**z {
)**{ |
;**| }
public,, 
override,, 
IByteBuffer,, #
GetBytes,,$ ,
(,,, -
int,,- 0
index,,1 6
,,,6 7
IByteBuffer,,8 C
dst,,D G
,,,G H
int,,I L
dstIndex,,M U
,,,U V
int,,W Z
length,,[ a
),,a b
{-- 	
this.. 
... 
CheckDstIndex.. 
(.. 
index.. $
,..$ %
length..& ,
,.., -
dstIndex... 6
,..6 7
dst..8 ;
...; <
Capacity..< D
)..D E
;..E F
if// 
(// 
dst// 
.// 
HasArray// 
)// 
{00 
this11 
.11 
GetBytes11 
(11 
index11 #
,11# $
dst11% (
.11( )
Array11) .
,11. /
dst110 3
.113 4
ArrayOffset114 ?
+11@ A
dstIndex11B J
,11J K
length11L R
)11R S
;11S T
}22 
else33 
{44 
dst55 
.55 
SetBytes55 
(55 
dstIndex55 %
,55% &
this55' +
.55+ ,
Memory55, 2
,552 3
this554 8
.558 9
Idx559 <
(55< =
index55= B
)55B C
,55C D
length55E K
)55K L
;55L M
}66 
return77 
this77 
;77 
}88 	
public:: 
override:: 
IByteBuffer:: #
GetBytes::$ ,
(::, -
int::- 0
index::1 6
,::6 7
byte::8 <
[::< =
]::= >
dst::? B
,::B C
int::D G
dstIndex::H P
,::P Q
int::R U
length::V \
)::\ ]
{;; 	
this<< 
.<< 
CheckDstIndex<< 
(<< 
index<< $
,<<$ %
length<<& ,
,<<, -
dstIndex<<. 6
,<<6 7
dst<<8 ;
.<<; <
Length<<< B
)<<B C
;<<C D
PlatformDependent== 
.== 

CopyMemory== (
(==( )
this==) -
.==- .
Memory==. 4
,==4 5
this==6 :
.==: ;
Idx==; >
(==> ?
index==? D
)==D E
,==E F
dst==G J
,==J K
dstIndex==L T
,==T U
length==V \
)==\ ]
;==] ^
return>> 
this>> 
;>> 
}?? 	
publicAA 
overrideAA 
IByteBufferAA #
GetBytesAA$ ,
(AA, -
intAA- 0
indexAA1 6
,AA6 7
StreamAA8 >
destinationAA? J
,AAJ K
intAAL O
lengthAAP V
)AAV W
{BB 	
thisCC 
.CC 

CheckIndexCC 
(CC 
indexCC !
,CC! "
lengthCC# )
)CC) *
;CC* +
destinationDD 
.DD 
WriteDD 
(DD 
thisDD "
.DD" #
MemoryDD# )
,DD) *
thisDD+ /
.DD/ 0
IdxDD0 3
(DD3 4
indexDD4 9
)DD9 :
,DD: ;
lengthDD< B
)DDB C
;DDC D
returnEE 
thisEE 
;EE 
}FF 	
	protectedHH 
internalHH 
overrideHH #
voidHH$ (
_SetByteHH) 1
(HH1 2
intHH2 5
indexHH6 ;
,HH; <
intHH= @
valueHHA F
)HHF G
=>HHH J
HeapByteBufferUtilHHK ]
.HH] ^
SetByteHH^ e
(HHe f
thisHHf j
.HHj k
MemoryHHk q
,HHq r
thisHHs w
.HHw x
IdxHHx {
(HH{ |
index	HH| Å
)
HHÅ Ç
,
HHÇ É
value
HHÑ â
)
HHâ ä
;
HHä ã
	protectedJJ 
internalJJ 
overrideJJ #
voidJJ$ (
	_SetShortJJ) 2
(JJ2 3
intJJ3 6
indexJJ7 <
,JJ< =
intJJ> A
valueJJB G
)JJG H
=>JJI K
HeapByteBufferUtilJJL ^
.JJ^ _
SetShortJJ_ g
(JJg h
thisJJh l
.JJl m
MemoryJJm s
,JJs t
thisJJu y
.JJy z
IdxJJz }
(JJ} ~
index	JJ~ É
)
JJÉ Ñ
,
JJÑ Ö
value
JJÜ ã
)
JJã å
;
JJå ç
	protectedLL 
internalLL 
overrideLL #
voidLL$ (
_SetShortLELL) 4
(LL4 5
intLL5 8
indexLL9 >
,LL> ?
intLL@ C
valueLLD I
)LLI J
=>LLK M
HeapByteBufferUtilLLN `
.LL` a

SetShortLELLa k
(LLk l
thisLLl p
.LLp q
MemoryLLq w
,LLw x
thisLLy }
.LL} ~
Idx	LL~ Å
(
LLÅ Ç
index
LLÇ á
)
LLá à
,
LLà â
value
LLä è
)
LLè ê
;
LLê ë
	protectedNN 
internalNN 
overrideNN #
voidNN$ (

_SetMediumNN) 3
(NN3 4
intNN4 7
indexNN8 =
,NN= >
intNN? B
valueNNC H
)NNH I
=>NNJ L
HeapByteBufferUtilNNM _
.NN_ `
	SetMediumNN` i
(NNi j
thisNNj n
.NNn o
MemoryNNo u
,NNu v
thisNNw {
.NN{ |
IdxNN| 
(	NN Ä
index
NNÄ Ö
)
NNÖ Ü
,
NNÜ á
value
NNà ç
)
NNç é
;
NNé è
	protectedPP 
internalPP 
overridePP #
voidPP$ (
_SetMediumLEPP) 5
(PP5 6
intPP6 9
indexPP: ?
,PP? @
intPPA D
valuePPE J
)PPJ K
=>PPL N
HeapByteBufferUtilPPO a
.PPa b
SetMediumLEPPb m
(PPm n
thisPPn r
.PPr s
MemoryPPs y
,PPy z
thisPP{ 
.	PP Ä
Idx
PPÄ É
(
PPÉ Ñ
index
PPÑ â
)
PPâ ä
,
PPä ã
value
PPå ë
)
PPë í
;
PPí ì
	protectedRR 
internalRR 
overrideRR #
voidRR$ (
_SetIntRR) 0
(RR0 1
intRR1 4
indexRR5 :
,RR: ;
intRR< ?
valueRR@ E
)RRE F
=>RRG I
HeapByteBufferUtilRRJ \
.RR\ ]
SetIntRR] c
(RRc d
thisRRd h
.RRh i
MemoryRRi o
,RRo p
thisRRq u
.RRu v
IdxRRv y
(RRy z
indexRRz 
)	RR Ä
,
RRÄ Å
value
RRÇ á
)
RRá à
;
RRà â
	protectedTT 
internalTT 
overrideTT #
voidTT$ (
	_SetIntLETT) 2
(TT2 3
intTT3 6
indexTT7 <
,TT< =
intTT> A
valueTTB G
)TTG H
=>TTI K
HeapByteBufferUtilTTL ^
.TT^ _
SetIntLETT_ g
(TTg h
thisTTh l
.TTl m
MemoryTTm s
,TTs t
thisTTu y
.TTy z
IdxTTz }
(TT} ~
index	TT~ É
)
TTÉ Ñ
,
TTÑ Ö
value
TTÜ ã
)
TTã å
;
TTå ç
	protectedVV 
internalVV 
overrideVV #
voidVV$ (
_SetLongVV) 1
(VV1 2
intVV2 5
indexVV6 ;
,VV; <
longVV= A
valueVVB G
)VVG H
=>VVI K
HeapByteBufferUtilVVL ^
.VV^ _
SetLongVV_ f
(VVf g
thisVVg k
.VVk l
MemoryVVl r
,VVr s
thisVVt x
.VVx y
IdxVVy |
(VV| }
index	VV} Ç
)
VVÇ É
,
VVÉ Ñ
value
VVÖ ä
)
VVä ã
;
VVã å
	protectedXX 
internalXX 
overrideXX #
voidXX$ (

_SetLongLEXX) 3
(XX3 4
intXX4 7
indexXX8 =
,XX= >
longXX? C
valueXXD I
)XXI J
=>XXK M
HeapByteBufferUtilXXN `
.XX` a
	SetLongLEXXa j
(XXj k
thisXXk o
.XXo p
MemoryXXp v
,XXv w
thisXXx |
.XX| }
Idx	XX} Ä
(
XXÄ Å
index
XXÅ Ü
)
XXÜ á
,
XXá à
value
XXâ é
)
XXé è
;
XXè ê
publicZZ 
overrideZZ 
IByteBufferZZ #
SetBytesZZ$ ,
(ZZ, -
intZZ- 0
indexZZ1 6
,ZZ6 7
IByteBufferZZ8 C
srcZZD G
,ZZG H
intZZI L
srcIndexZZM U
,ZZU V
intZZW Z
lengthZZ[ a
)ZZa b
{[[ 	
this\\ 
.\\ 
CheckSrcIndex\\ 
(\\ 
index\\ $
,\\$ %
length\\& ,
,\\, -
srcIndex\\. 6
,\\6 7
src\\8 ;
.\\; <
Capacity\\< D
)\\D E
;\\E F
if]] 
(]] 
src]] 
.]] 
HasArray]] 
)]] 
{^^ 
this__ 
.__ 
SetBytes__ 
(__ 
index__ #
,__# $
src__% (
.__( )
Array__) .
,__. /
src__0 3
.__3 4
ArrayOffset__4 ?
+__@ A
srcIndex__B J
,__J K
length__L R
)__R S
;__S T
}`` 
elseaa 
{bb 
srccc 
.cc 
GetBytescc 
(cc 
srcIndexcc %
,cc% &
thiscc' +
.cc+ ,
Memorycc, 2
,cc2 3
thiscc4 8
.cc8 9
Idxcc9 <
(cc< =
indexcc= B
)ccB C
,ccC D
lengthccE K
)ccK L
;ccL M
}dd 
returnee 
thisee 
;ee 
}ff 	
publichh 
overridehh 
asynchh 
Taskhh "
<hh" #
inthh# &
>hh& '
SetBytesAsynchh( 5
(hh5 6
inthh6 9
indexhh: ?
,hh? @
StreamhhA G
srchhH K
,hhK L
inthhM P
lengthhhQ W
,hhW X
CancellationTokenhhY j
cancellationTokenhhk |
)hh| }
{ii 	
ifjj 
(jj 
lengthjj 
==jj 
$numjj 
)jj 
{kk 
returnll 
$numll 
;ll 
}mm 
intoo 
	readTotaloo 
=oo 
$numoo 
;oo 
intpp 
readpp 
;pp 
intqq 
offsetqq 
=qq 
thisqq 
.qq 
ArrayOffsetqq )
+qq* +
indexqq, 1
;qq1 2
dorr 
{ss 
readtt 
=tt 
awaittt 
srctt  
.tt  !
	ReadAsynctt! *
(tt* +
thistt+ /
.tt/ 0
Arraytt0 5
,tt5 6
offsettt7 =
+tt> ?
	readTotaltt@ I
,ttI J
lengthttK Q
-ttR S
	readTotalttT ]
,tt] ^
cancellationTokentt_ p
)ttp q
;ttq r
	readTotaluu 
+=uu 
readuu !
;uu! "
}vv 
whileww 
(ww 
readww 
>ww 
$numww 
&&ww 
	readTotalww (
<ww) *
lengthww+ 1
)ww1 2
;ww2 3
returnyy 
	readTotalyy 
;yy 
}zz 	
public|| 
override|| 
IByteBuffer|| #
SetBytes||$ ,
(||, -
int||- 0
index||1 6
,||6 7
byte||8 <
[||< =
]||= >
src||? B
,||B C
int||D G
srcIndex||H P
,||P Q
int||R U
length||V \
)||\ ]
{}} 	
this~~ 
.~~ 
CheckSrcIndex~~ 
(~~ 
index~~ $
,~~$ %
length~~& ,
,~~, -
srcIndex~~. 6
,~~6 7
src~~8 ;
.~~; <
Length~~< B
)~~B C
;~~C D
PlatformDependent 
. 

CopyMemory (
(( )
src) ,
,, -
srcIndex. 6
,6 7
this8 <
.< =
Memory= C
,C D
thisE I
.I J
IdxJ M
(M N
indexN S
)S T
,T U
lengthV \
)\ ]
;] ^
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
Copy
ÉÉ$ (
(
ÉÉ( )
int
ÉÉ) ,
index
ÉÉ- 2
,
ÉÉ2 3
int
ÉÉ4 7
length
ÉÉ8 >
)
ÉÉ> ?
{
ÑÑ 	
this
ÖÖ 
.
ÖÖ 

CheckIndex
ÖÖ 
(
ÖÖ 
index
ÖÖ !
,
ÖÖ! "
length
ÖÖ# )
)
ÖÖ) *
;
ÖÖ* +
IByteBuffer
ÜÜ 
copy
ÜÜ 
=
ÜÜ 
this
ÜÜ #
.
ÜÜ# $
	Allocator
ÜÜ$ -
.
ÜÜ- .

HeapBuffer
ÜÜ. 8
(
ÜÜ8 9
length
ÜÜ9 ?
,
ÜÜ? @
this
ÜÜA E
.
ÜÜE F
MaxCapacity
ÜÜF Q
)
ÜÜQ R
;
ÜÜR S
copy
áá 
.
áá 

WriteBytes
áá 
(
áá 
this
áá  
.
áá  !
Memory
áá! '
,
áá' (
this
áá) -
.
áá- .
Idx
áá. 1
(
áá1 2
index
áá2 7
)
áá7 8
,
áá8 9
length
áá: @
)
áá@ A
;
ááA B
return
àà 
copy
àà 
;
àà 
}
ââ 	
public
åå 
override
åå 
IByteBuffer
åå #
SetZero
åå$ +
(
åå+ ,
int
åå, /
index
åå0 5
,
åå5 6
int
åå7 :
length
åå; A
)
ååA B
{
çç 	
this
éé 
.
éé 

CheckIndex
éé 
(
éé 
index
éé !
,
éé! "
length
éé# )
)
éé) *
;
éé* +
PlatformDependent
èè 
.
èè 
Clear
èè #
(
èè# $
this
èè$ (
.
èè( )
Memory
èè) /
,
èè/ 0
this
èè1 5
.
èè5 6
Idx
èè6 9
(
èè9 :
index
èè: ?
)
èè? @
,
èè@ A
length
èèB H
)
èèH I
;
èèI J
return
êê 
this
êê 
;
êê 
}
ëë 	
public
ìì 
override
ìì 
int
ìì 
IoBufferCount
ìì )
=>
ìì* ,
$num
ìì- .
;
ìì. /
public
ïï 
override
ïï 
ArraySegment
ïï $
<
ïï$ %
byte
ïï% )
>
ïï) *
GetIoBuffer
ïï+ 6
(
ïï6 7
int
ïï7 :
index
ïï; @
,
ïï@ A
int
ïïB E
length
ïïF L
)
ïïL M
{
ññ 	
this
óó 
.
óó 

CheckIndex
óó 
(
óó 
index
óó !
,
óó! "
length
óó# )
)
óó) *
;
óó* +
index
òò 
=
òò 
index
òò 
+
òò 
this
òò  
.
òò  !
Offset
òò! '
;
òò' (
return
ôô 
new
ôô 
ArraySegment
ôô #
<
ôô# $
byte
ôô$ (
>
ôô( )
(
ôô) *
this
ôô* .
.
ôô. /
Memory
ôô/ 5
,
ôô5 6
index
ôô7 <
,
ôô< =
length
ôô> D
)
ôôD E
;
ôôE F
}
öö 	
public
úú 
override
úú 
ArraySegment
úú $
<
úú$ %
byte
úú% )
>
úú) *
[
úú* +
]
úú+ ,
GetIoBuffers
úú- 9
(
úú9 :
int
úú: =
index
úú> C
,
úúC D
int
úúE H
length
úúI O
)
úúO P
=>
úúQ S
new
úúT W
[
úúW X
]
úúX Y
{
úúZ [
this
úú\ `
.
úú` a
GetIoBuffer
úúa l
(
úúl m
index
úúm r
,
úúr s
length
úút z
)
úúz {
}
úú| }
;
úú} ~
public
ûû 
override
ûû 
bool
ûû 
HasArray
ûû %
=>
ûû& (
true
ûû) -
;
ûû- .
public
†† 
override
†† 
byte
†† 
[
†† 
]
†† 
Array
†† $
{
°° 	
get
¢¢ 
{
££ 
this
§§ 
.
§§ 
EnsureAccessible
§§ %
(
§§% &
)
§§& '
;
§§' (
return
•• 
this
•• 
.
•• 
Memory
•• "
;
••" #
}
¶¶ 
}
ßß 	
public
©© 
override
©© 
int
©© 
ArrayOffset
©© '
=>
©©( *
this
©©+ /
.
©©/ 0
Offset
©©0 6
;
©©6 7
public
´´ 
override
´´ 
bool
´´ 
HasMemoryAddress
´´ -
=>
´´. 0
true
´´1 5
;
´´5 6
public
≠≠ 
override
≠≠ 
ref
≠≠ 
byte
≠≠  &
GetPinnableMemoryAddress
≠≠! 9
(
≠≠9 :
)
≠≠: ;
{
ÆÆ 	
this
ØØ 
.
ØØ 
EnsureAccessible
ØØ !
(
ØØ! "
)
ØØ" #
;
ØØ# $
return
∞∞ 
ref
∞∞ 
this
∞∞ 
.
∞∞ 
Memory
∞∞ "
[
∞∞" #
this
∞∞# '
.
∞∞' (
Offset
∞∞( .
]
∞∞. /
;
∞∞/ 0
}
±± 	
public
≥≥ 
override
≥≥ 
IntPtr
≥≥ #
AddressOfPinnedMemory
≥≥ 4
(
≥≥4 5
)
≥≥5 6
=>
≥≥7 9
IntPtr
≥≥: @
.
≥≥@ A
Zero
≥≥A E
;
≥≥E F
}
¥¥ 
}µµ ‘Ã
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class "
PooledSlicedByteBuffer '
:( )+
AbstractPooledDerivedByteBuffer* I
{ 
static 
readonly 
ThreadLocalPool '
<' ("
PooledSlicedByteBuffer( >
>> ?
Recycler@ H
=I J
newK N
ThreadLocalPoolO ^
<^ _"
PooledSlicedByteBuffer_ u
>u v
(v w
handlew }
=>	~ Ä
new
Å Ñ$
PooledSlicedByteBuffer
Ö õ
(
õ ú
handle
ú ¢
)
¢ £
)
£ §
;
§ •
internal 
static "
PooledSlicedByteBuffer .
NewInstance/ :
(: ;
AbstractByteBuffer; M
	unwrappedN W
,W X
IByteBufferY d
wrappede l
,l m
intn q
indexr w
,w x
inty |
length	} É
)
É Ñ
{ 	!
CheckSliceOutOfBounds !
(! "
index" '
,' (
length) /
,/ 0
	unwrapped1 :
): ;
;; <
return 
NewInstance0 
(  
	unwrapped  )
,) *
wrapped+ 2
,2 3
index4 9
,9 :
length; A
)A B
;B C
} 	
static "
PooledSlicedByteBuffer %
NewInstance0& 2
(2 3
AbstractByteBuffer3 E
	unwrappedF O
,O P
IByteBufferQ \
wrapped] d
,d e
intf i

adjustmentj t
,t u
intv y
length	z Ä
)
Ä Å
{ 	"
PooledSlicedByteBuffer "
slice# (
=) *
Recycler+ 3
.3 4
Take4 8
(8 9
)9 :
;: ;
slice 
. 
Init 
< "
PooledSlicedByteBuffer -
>- .
(. /
	unwrapped/ 8
,8 9
wrapped: A
,A B
$numC D
,D E
lengthF L
,L M
lengthN T
)T U
;U V
slice 
. 
DiscardMarks 
( 
)  
;  !
slice 
. 

adjustment 
= 

adjustment )
;) *
return   
slice   
;   
}!! 	
int## 

adjustment## 
;## "
PooledSlicedByteBuffer%% 
(%% 
ThreadLocalPool%% .
.%%. /
Handle%%/ 5
handle%%6 <
)%%< =
:&& 
base&& 
(&& 
handle&& 
)&& 
{'' 	
}(( 	
public** 
override** 
int** 
Capacity** $
=>**% '
this**( ,
.**, -
MaxCapacity**- 8
;**8 9
public,, 
override,, 
IByteBuffer,, #
AdjustCapacity,,$ 2
(,,2 3
int,,3 6
newCapacity,,7 B
),,B C
=>,,D F
throw,,G L
new,,M P!
NotSupportedException,,Q f
(,,f g
$str,,g v
),,v w
;,,w x
public.. 
override.. 
int.. 
ArrayOffset.. '
=>..( *
this..+ /
.../ 0
Idx..0 3
(..3 4
this..4 8
...8 9
Unwrap..9 ?
(..? @
)..@ A
...A B
ArrayOffset..B M
)..M N
;..N O
public00 
override00 
ref00 
byte00  $
GetPinnableMemoryAddress00! 9
(009 :
)00: ;
=>00< >
ref00? B
Unsafe00C I
.00I J
Add00J M
(00M N
ref00N Q
this00R V
.00V W
Unwrap00W ]
(00] ^
)00^ _
.00_ `$
GetPinnableMemoryAddress00` x
(00x y
)00y z
,00z {
this	00| Ä
.
00Ä Å

adjustment
00Å ã
)
00ã å
;
00å ç
public22 
override22 
IntPtr22 !
AddressOfPinnedMemory22 4
(224 5
)225 6
{33 	
IntPtr44 
ptr44 
=44 
this44 
.44 
Unwrap44 $
(44$ %
)44% &
.44& '!
AddressOfPinnedMemory44' <
(44< =
)44= >
;44> ?
if55 
(55 
ptr55 
==55 
IntPtr55 
.55 
Zero55 "
)55" #
{66 
return77 
ptr77 
;77 
}88 
return99 
ptr99 
+99 
this99 
.99 

adjustment99 (
;99( )
}:: 	
public<< 
override<< 
ArraySegment<< $
<<<$ %
byte<<% )
><<) *
GetIoBuffer<<+ 6
(<<6 7
int<<7 :
index<<; @
,<<@ A
int<<B E
length<<F L
)<<L M
{== 	
this>> 
.>> 
CheckIndex0>> 
(>> 
index>> "
,>>" #
length>>$ *
)>>* +
;>>+ ,
return?? 
this?? 
.?? 
Unwrap?? 
(?? 
)??  
.??  !
GetIoBuffer??! ,
(??, -
this??- 1
.??1 2
Idx??2 5
(??5 6
index??6 ;
)??; <
,??< =
length??> D
)??D E
;??E F
}@@ 	
publicBB 
overrideBB 
ArraySegmentBB $
<BB$ %
byteBB% )
>BB) *
[BB* +
]BB+ ,
GetIoBuffersBB- 9
(BB9 :
intBB: =
indexBB> C
,BBC D
intBBE H
lengthBBI O
)BBO P
{CC 	
thisDD 
.DD 
CheckIndex0DD 
(DD 
indexDD "
,DD" #
lengthDD$ *
)DD* +
;DD+ ,
returnEE 
thisEE 
.EE 
UnwrapEE 
(EE 
)EE  
.EE  !
GetIoBuffersEE! -
(EE- .
thisEE. 2
.EE2 3
IdxEE3 6
(EE6 7
indexEE7 <
)EE< =
,EE= >
lengthEE? E
)EEE F
;EEF G
}FF 	
publicHH 
overrideHH 
IByteBufferHH #
CopyHH$ (
(HH( )
intHH) ,
indexHH- 2
,HH2 3
intHH4 7
lengthHH8 >
)HH> ?
{II 	
thisJJ 
.JJ 
CheckIndex0JJ 
(JJ 
indexJJ "
,JJ" #
lengthJJ$ *
)JJ* +
;JJ+ ,
returnKK 
thisKK 
.KK 
UnwrapKK 
(KK 
)KK  
.KK  !
CopyKK! %
(KK% &
thisKK& *
.KK* +
IdxKK+ .
(KK. /
indexKK/ 4
)KK4 5
,KK5 6
lengthKK7 =
)KK= >
;KK> ?
}LL 	
publicNN 
overrideNN 
IByteBufferNN #
SliceNN$ )
(NN) *
intNN* -
indexNN. 3
,NN3 4
intNN5 8
lengthNN9 ?
)NN? @
{OO 	
thisPP 
.PP 
CheckIndex0PP 
(PP 
indexPP "
,PP" #
lengthPP$ *
)PP* +
;PP+ ,
returnQQ 
baseQQ 
.QQ 
SliceQQ 
(QQ 
thisQQ "
.QQ" #
IdxQQ# &
(QQ& '
indexQQ' ,
)QQ, -
,QQ- .
lengthQQ/ 5
)QQ5 6
;QQ6 7
}RR 	
publicTT 
overrideTT 
IByteBufferTT #
RetainedSliceTT$ 1
(TT1 2
intTT2 5
indexTT6 ;
,TT; <
intTT= @
lengthTTA G
)TTG H
{UU 	
thisVV 
.VV 
CheckIndex0VV 
(VV 
indexVV "
,VV" #
lengthVV$ *
)VV* +
;VV+ ,
returnWW 
NewInstance0WW 
(WW  
thisWW  $
.WW$ %

UnwrapCoreWW% /
(WW/ 0
)WW0 1
,WW1 2
thisWW3 7
,WW7 8
thisWW9 =
.WW= >
IdxWW> A
(WWA B
indexWWB G
)WWG H
,WWH I
lengthWWJ P
)WWP Q
;WWQ R
}XX 	
publicZZ 
overrideZZ 
IByteBufferZZ #
	DuplicateZZ$ -
(ZZ- .
)ZZ. /
=>ZZ0 2
thisZZ3 7
.ZZ7 8

Duplicate0ZZ8 B
(ZZB C
)ZZC D
.ZZD E
SetIndexZZE M
(ZZM N
thisZZN R
.ZZR S
IdxZZS V
(ZZV W
thisZZW [
.ZZ[ \
ReaderIndexZZ\ g
)ZZg h
,ZZh i
thisZZj n
.ZZn o
IdxZZo r
(ZZr s
thisZZs w
.ZZw x
WriterIndex	ZZx É
)
ZZÉ Ñ
)
ZZÑ Ö
;
ZZÖ Ü
public\\ 
override\\ 
IByteBuffer\\ #
RetainedDuplicate\\$ 5
(\\5 6
)\\6 7
=>\\8 :&
PooledDuplicatedByteBuffer\\; U
.\\U V
NewInstance\\V a
(\\a b
this\\b f
.\\f g

UnwrapCore\\g q
(\\q r
)\\r s
,\\s t
this\\u y
,\\y z
this\\{ 
.	\\ Ä
Idx
\\Ä É
(
\\É Ñ
this
\\Ñ à
.
\\à â
ReaderIndex
\\â î
)
\\î ï
,
\\ï ñ
this
\\ó õ
.
\\õ ú
Idx
\\ú ü
(
\\ü †
this
\\† §
.
\\§ •
WriterIndex
\\• ∞
)
\\∞ ±
)
\\± ≤
;
\\≤ ≥
public^^ 
override^^ 
byte^^ 
GetByte^^ $
(^^$ %
int^^% (
index^^) .
)^^. /
{__ 	
this`` 
.`` 
CheckIndex0`` 
(`` 
index`` "
,``" #
$num``$ %
)``% &
;``& '
returnaa 
thisaa 
.aa 
Unwrapaa 
(aa 
)aa  
.aa  !
GetByteaa! (
(aa( )
thisaa) -
.aa- .
Idxaa. 1
(aa1 2
indexaa2 7
)aa7 8
)aa8 9
;aa9 :
}bb 	
	protecteddd 
internaldd 
overridedd #
bytedd$ (
_GetBytedd) 1
(dd1 2
intdd2 5
indexdd6 ;
)dd; <
=>dd= ?
thisdd@ D
.ddD E

UnwrapCoreddE O
(ddO P
)ddP Q
.ddQ R
_GetByteddR Z
(ddZ [
thisdd[ _
.dd_ `
Idxdd` c
(ddc d
indexddd i
)ddi j
)ddj k
;ddk l
publicff 
overrideff 
shortff 
GetShortff &
(ff& '
intff' *
indexff+ 0
)ff0 1
{gg 	
thishh 
.hh 
CheckIndex0hh 
(hh 
indexhh "
,hh" #
$numhh$ %
)hh% &
;hh& '
returnii 
thisii 
.ii 
Unwrapii 
(ii 
)ii  
.ii  !
GetShortii! )
(ii) *
thisii* .
.ii. /
Idxii/ 2
(ii2 3
indexii3 8
)ii8 9
)ii9 :
;ii: ;
}jj 	
	protectedll 
internalll 
overridell #
shortll$ )
	_GetShortll* 3
(ll3 4
intll4 7
indexll8 =
)ll= >
=>ll? A
thisllB F
.llF G

UnwrapCorellG Q
(llQ R
)llR S
.llS T
	_GetShortllT ]
(ll] ^
thisll^ b
.llb c
Idxllc f
(llf g
indexllg l
)lll m
)llm n
;lln o
publicnn 
overridenn 
shortnn 

GetShortLEnn (
(nn( )
intnn) ,
indexnn- 2
)nn2 3
{oo 	
thispp 
.pp 
CheckIndex0pp 
(pp 
indexpp "
,pp" #
$numpp$ %
)pp% &
;pp& '
returnqq 
thisqq 
.qq 
Unwrapqq 
(qq 
)qq  
.qq  !

GetShortLEqq! +
(qq+ ,
thisqq, 0
.qq0 1
Idxqq1 4
(qq4 5
indexqq5 :
)qq: ;
)qq; <
;qq< =
}rr 	
	protectedtt 
internaltt 
overridett #
shorttt$ )
_GetShortLEtt* 5
(tt5 6
inttt6 9
indextt: ?
)tt? @
=>ttA C
thisttD H
.ttH I

UnwrapCorettI S
(ttS T
)ttT U
.ttU V
_GetShortLEttV a
(tta b
thisttb f
.ttf g
Idxttg j
(ttj k
indexttk p
)ttp q
)ttq r
;ttr s
publicvv 
overridevv 
intvv 
GetUnsignedMediumvv -
(vv- .
intvv. 1
indexvv2 7
)vv7 8
{ww 	
thisxx 
.xx 
CheckIndex0xx 
(xx 
indexxx "
,xx" #
$numxx$ %
)xx% &
;xx& '
returnyy 
thisyy 
.yy 
Unwrapyy 
(yy 
)yy  
.yy  !
GetUnsignedMediumyy! 2
(yy2 3
thisyy3 7
.yy7 8
Idxyy8 ;
(yy; <
indexyy< A
)yyA B
)yyB C
;yyC D
}zz 	
	protected|| 
internal|| 
override|| #
int||$ '
_GetUnsignedMedium||( :
(||: ;
int||; >
index||? D
)||D E
=>||F H
this||I M
.||M N

UnwrapCore||N X
(||X Y
)||Y Z
.||Z [
_GetUnsignedMedium||[ m
(||m n
this||n r
.||r s
Idx||s v
(||v w
index||w |
)||| }
)||} ~
;||~ 
public~~ 
override~~ 
int~~ 
GetUnsignedMediumLE~~ /
(~~/ 0
int~~0 3
index~~4 9
)~~9 :
{ 	
this
ÄÄ 
.
ÄÄ 
CheckIndex0
ÄÄ 
(
ÄÄ 
index
ÄÄ "
,
ÄÄ" #
$num
ÄÄ$ %
)
ÄÄ% &
;
ÄÄ& '
return
ÅÅ 
this
ÅÅ 
.
ÅÅ 
Unwrap
ÅÅ 
(
ÅÅ 
)
ÅÅ  
.
ÅÅ  !!
GetUnsignedMediumLE
ÅÅ! 4
(
ÅÅ4 5
this
ÅÅ5 9
.
ÅÅ9 :
Idx
ÅÅ: =
(
ÅÅ= >
index
ÅÅ> C
)
ÅÅC D
)
ÅÅD E
;
ÅÅE F
}
ÇÇ 	
	protected
ÑÑ 
internal
ÑÑ 
override
ÑÑ #
int
ÑÑ$ '"
_GetUnsignedMediumLE
ÑÑ( <
(
ÑÑ< =
int
ÑÑ= @
index
ÑÑA F
)
ÑÑF G
=>
ÑÑH J
this
ÑÑK O
.
ÑÑO P

UnwrapCore
ÑÑP Z
(
ÑÑZ [
)
ÑÑ[ \
.
ÑÑ\ ]"
_GetUnsignedMediumLE
ÑÑ] q
(
ÑÑq r
this
ÑÑr v
.
ÑÑv w
Idx
ÑÑw z
(
ÑÑz {
indexÑÑ{ Ä
)ÑÑÄ Å
)ÑÑÅ Ç
;ÑÑÇ É
public
ÜÜ 
override
ÜÜ 
int
ÜÜ 
GetInt
ÜÜ "
(
ÜÜ" #
int
ÜÜ# &
index
ÜÜ' ,
)
ÜÜ, -
{
áá 	
this
àà 
.
àà 
CheckIndex0
àà 
(
àà 
index
àà "
,
àà" #
$num
àà$ %
)
àà% &
;
àà& '
return
ââ 
this
ââ 
.
ââ 
Unwrap
ââ 
(
ââ 
)
ââ  
.
ââ  !
GetInt
ââ! '
(
ââ' (
this
ââ( ,
.
ââ, -
Idx
ââ- 0
(
ââ0 1
index
ââ1 6
)
ââ6 7
)
ââ7 8
;
ââ8 9
}
ää 	
	protected
åå 
internal
åå 
override
åå #
int
åå$ '
_GetInt
åå( /
(
åå/ 0
int
åå0 3
index
åå4 9
)
åå9 :
=>
åå; =
this
åå> B
.
ååB C

UnwrapCore
ååC M
(
ååM N
)
ååN O
.
ååO P
_GetInt
ååP W
(
ååW X
this
ååX \
.
åå\ ]
Idx
åå] `
(
åå` a
index
ååa f
)
ååf g
)
ååg h
;
ååh i
public
éé 
override
éé 
int
éé 
GetIntLE
éé $
(
éé$ %
int
éé% (
index
éé) .
)
éé. /
{
èè 	
this
êê 
.
êê 
CheckIndex0
êê 
(
êê 
index
êê "
,
êê" #
$num
êê$ %
)
êê% &
;
êê& '
return
ëë 
this
ëë 
.
ëë 
Unwrap
ëë 
(
ëë 
)
ëë  
.
ëë  !
GetIntLE
ëë! )
(
ëë) *
this
ëë* .
.
ëë. /
Idx
ëë/ 2
(
ëë2 3
index
ëë3 8
)
ëë8 9
)
ëë9 :
;
ëë: ;
}
íí 	
	protected
îî 
internal
îî 
override
îî #
int
îî$ '
	_GetIntLE
îî( 1
(
îî1 2
int
îî2 5
index
îî6 ;
)
îî; <
=>
îî= ?
this
îî@ D
.
îîD E

UnwrapCore
îîE O
(
îîO P
)
îîP Q
.
îîQ R
	_GetIntLE
îîR [
(
îî[ \
this
îî\ `
.
îî` a
Idx
îîa d
(
îîd e
index
îîe j
)
îîj k
)
îîk l
;
îîl m
public
ññ 
override
ññ 
long
ññ 
GetLong
ññ $
(
ññ$ %
int
ññ% (
index
ññ) .
)
ññ. /
{
óó 	
this
òò 
.
òò 
CheckIndex0
òò 
(
òò 
index
òò "
,
òò" #
$num
òò$ %
)
òò% &
;
òò& '
return
ôô 
this
ôô 
.
ôô 
Unwrap
ôô 
(
ôô 
)
ôô  
.
ôô  !
GetLong
ôô! (
(
ôô( )
this
ôô) -
.
ôô- .
Idx
ôô. 1
(
ôô1 2
index
ôô2 7
)
ôô7 8
)
ôô8 9
;
ôô9 :
}
öö 	
	protected
úú 
internal
úú 
override
úú #
long
úú$ (
_GetLong
úú) 1
(
úú1 2
int
úú2 5
index
úú6 ;
)
úú; <
=>
úú= ?
this
úú@ D
.
úúD E

UnwrapCore
úúE O
(
úúO P
)
úúP Q
.
úúQ R
_GetLong
úúR Z
(
úúZ [
this
úú[ _
.
úú_ `
Idx
úú` c
(
úúc d
index
úúd i
)
úúi j
)
úúj k
;
úúk l
public
ûû 
override
ûû 
long
ûû 
	GetLongLE
ûû &
(
ûû& '
int
ûû' *
index
ûû+ 0
)
ûû0 1
{
üü 	
this
†† 
.
†† 
CheckIndex0
†† 
(
†† 
index
†† "
,
††" #
$num
††$ %
)
††% &
;
††& '
return
°° 
this
°° 
.
°° 
Unwrap
°° 
(
°° 
)
°°  
.
°°  !
	GetLongLE
°°! *
(
°°* +
this
°°+ /
.
°°/ 0
Idx
°°0 3
(
°°3 4
index
°°4 9
)
°°9 :
)
°°: ;
;
°°; <
}
¢¢ 	
	protected
§§ 
internal
§§ 
override
§§ #
long
§§$ (

_GetLongLE
§§) 3
(
§§3 4
int
§§4 7
index
§§8 =
)
§§= >
=>
§§? A
this
§§B F
.
§§F G

UnwrapCore
§§G Q
(
§§Q R
)
§§R S
.
§§S T

_GetLongLE
§§T ^
(
§§^ _
this
§§_ c
.
§§c d
Idx
§§d g
(
§§g h
index
§§h m
)
§§m n
)
§§n o
;
§§o p
public
¶¶ 
override
¶¶ 
IByteBuffer
¶¶ #
GetBytes
¶¶$ ,
(
¶¶, -
int
¶¶- 0
index
¶¶1 6
,
¶¶6 7
IByteBuffer
¶¶8 C
dst
¶¶D G
,
¶¶G H
int
¶¶I L
dstIndex
¶¶M U
,
¶¶U V
int
¶¶W Z
length
¶¶[ a
)
¶¶a b
{
ßß 	
this
®® 
.
®® 
CheckIndex0
®® 
(
®® 
index
®® "
,
®®" #
length
®®$ *
)
®®* +
;
®®+ ,
this
©© 
.
©© 
Unwrap
©© 
(
©© 
)
©© 
.
©© 
GetBytes
©© "
(
©©" #
this
©©# '
.
©©' (
Idx
©©( +
(
©©+ ,
index
©©, 1
)
©©1 2
,
©©2 3
dst
©©4 7
,
©©7 8
dstIndex
©©9 A
,
©©A B
length
©©C I
)
©©I J
;
©©J K
return
™™ 
this
™™ 
;
™™ 
}
´´ 	
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #
GetBytes
≠≠$ ,
(
≠≠, -
int
≠≠- 0
index
≠≠1 6
,
≠≠6 7
byte
≠≠8 <
[
≠≠< =
]
≠≠= >
dst
≠≠? B
,
≠≠B C
int
≠≠D G
dstIndex
≠≠H P
,
≠≠P Q
int
≠≠R U
length
≠≠V \
)
≠≠\ ]
{
ÆÆ 	
this
ØØ 
.
ØØ 
CheckIndex0
ØØ 
(
ØØ 
index
ØØ "
,
ØØ" #
length
ØØ$ *
)
ØØ* +
;
ØØ+ ,
this
∞∞ 
.
∞∞ 
Unwrap
∞∞ 
(
∞∞ 
)
∞∞ 
.
∞∞ 
GetBytes
∞∞ "
(
∞∞" #
this
∞∞# '
.
∞∞' (
Idx
∞∞( +
(
∞∞+ ,
index
∞∞, 1
)
∞∞1 2
,
∞∞2 3
dst
∞∞4 7
,
∞∞7 8
dstIndex
∞∞9 A
,
∞∞A B
length
∞∞C I
)
∞∞I J
;
∞∞J K
return
±± 
this
±± 
;
±± 
}
≤≤ 	
public
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ #
SetByte
¥¥$ +
(
¥¥+ ,
int
¥¥, /
index
¥¥0 5
,
¥¥5 6
int
¥¥7 :
value
¥¥; @
)
¥¥@ A
{
µµ 	
this
∂∂ 
.
∂∂ 
CheckIndex0
∂∂ 
(
∂∂ 
index
∂∂ "
,
∂∂" #
$num
∂∂$ %
)
∂∂% &
;
∂∂& '
this
∑∑ 
.
∑∑ 
Unwrap
∑∑ 
(
∑∑ 
)
∑∑ 
.
∑∑ 
SetByte
∑∑ !
(
∑∑! "
this
∑∑" &
.
∑∑& '
Idx
∑∑' *
(
∑∑* +
index
∑∑+ 0
)
∑∑0 1
,
∑∑1 2
value
∑∑3 8
)
∑∑8 9
;
∑∑9 :
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
	protected
ªª 
internal
ªª 
override
ªª #
void
ªª$ (
_SetByte
ªª) 1
(
ªª1 2
int
ªª2 5
index
ªª6 ;
,
ªª; <
int
ªª= @
value
ªªA F
)
ªªF G
=>
ªªH J
this
ªªK O
.
ªªO P

UnwrapCore
ªªP Z
(
ªªZ [
)
ªª[ \
.
ªª\ ]
_SetByte
ªª] e
(
ªªe f
this
ªªf j
.
ªªj k
Idx
ªªk n
(
ªªn o
index
ªªo t
)
ªªt u
,
ªªu v
value
ªªw |
)
ªª| }
;
ªª} ~
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
SetShort
ΩΩ$ ,
(
ΩΩ, -
int
ΩΩ- 0
index
ΩΩ1 6
,
ΩΩ6 7
int
ΩΩ8 ;
value
ΩΩ< A
)
ΩΩA B
{
ææ 	
this
øø 
.
øø 
CheckIndex0
øø 
(
øø 
index
øø "
,
øø" #
$num
øø$ %
)
øø% &
;
øø& '
this
¿¿ 
.
¿¿ 
Unwrap
¿¿ 
(
¿¿ 
)
¿¿ 
.
¿¿ 
SetShort
¿¿ "
(
¿¿" #
this
¿¿# '
.
¿¿' (
Idx
¿¿( +
(
¿¿+ ,
index
¿¿, 1
)
¿¿1 2
,
¿¿2 3
value
¿¿4 9
)
¿¿9 :
;
¿¿: ;
return
¡¡ 
this
¡¡ 
;
¡¡ 
}
¬¬ 	
	protected
ƒƒ 
internal
ƒƒ 
override
ƒƒ #
void
ƒƒ$ (
	_SetShort
ƒƒ) 2
(
ƒƒ2 3
int
ƒƒ3 6
index
ƒƒ7 <
,
ƒƒ< =
int
ƒƒ> A
value
ƒƒB G
)
ƒƒG H
=>
ƒƒI K
this
ƒƒL P
.
ƒƒP Q

UnwrapCore
ƒƒQ [
(
ƒƒ[ \
)
ƒƒ\ ]
.
ƒƒ] ^
	_SetShort
ƒƒ^ g
(
ƒƒg h
this
ƒƒh l
.
ƒƒl m
Idx
ƒƒm p
(
ƒƒp q
index
ƒƒq v
)
ƒƒv w
,
ƒƒw x
value
ƒƒy ~
)
ƒƒ~ 
;ƒƒ Ä
public
∆∆ 
override
∆∆ 
IByteBuffer
∆∆ #

SetShortLE
∆∆$ .
(
∆∆. /
int
∆∆/ 2
index
∆∆3 8
,
∆∆8 9
int
∆∆: =
value
∆∆> C
)
∆∆C D
{
«« 	
this
»» 
.
»» 
CheckIndex0
»» 
(
»» 
index
»» "
,
»»" #
$num
»»$ %
)
»»% &
;
»»& '
this
…… 
.
…… 
Unwrap
…… 
(
…… 
)
…… 
.
…… 

SetShortLE
…… $
(
……$ %
this
……% )
.
……) *
Idx
……* -
(
……- .
index
……. 3
)
……3 4
,
……4 5
value
……6 ;
)
……; <
;
……< =
return
   
this
   
;
   
}
ÀÀ 	
	protected
ÕÕ 
internal
ÕÕ 
override
ÕÕ #
void
ÕÕ$ (
_SetShortLE
ÕÕ) 4
(
ÕÕ4 5
int
ÕÕ5 8
index
ÕÕ9 >
,
ÕÕ> ?
int
ÕÕ@ C
value
ÕÕD I
)
ÕÕI J
=>
ÕÕK M
this
ÕÕN R
.
ÕÕR S

UnwrapCore
ÕÕS ]
(
ÕÕ] ^
)
ÕÕ^ _
.
ÕÕ_ `
_SetShortLE
ÕÕ` k
(
ÕÕk l
this
ÕÕl p
.
ÕÕp q
Idx
ÕÕq t
(
ÕÕt u
index
ÕÕu z
)
ÕÕz {
,
ÕÕ{ |
valueÕÕ} Ç
)ÕÕÇ É
;ÕÕÉ Ñ
public
œœ 
override
œœ 
IByteBuffer
œœ #
	SetMedium
œœ$ -
(
œœ- .
int
œœ. 1
index
œœ2 7
,
œœ7 8
int
œœ9 <
value
œœ= B
)
œœB C
{
–– 	
this
—— 
.
—— 
CheckIndex0
—— 
(
—— 
index
—— "
,
——" #
$num
——$ %
)
——% &
;
——& '
this
““ 
.
““ 
Unwrap
““ 
(
““ 
)
““ 
.
““ 
	SetMedium
““ #
(
““# $
this
““$ (
.
““( )
Idx
““) ,
(
““, -
index
““- 2
)
““2 3
,
““3 4
value
““5 :
)
““: ;
;
““; <
return
”” 
this
”” 
;
”” 
}
‘‘ 	
	protected
÷÷ 
internal
÷÷ 
override
÷÷ #
void
÷÷$ (

_SetMedium
÷÷) 3
(
÷÷3 4
int
÷÷4 7
index
÷÷8 =
,
÷÷= >
int
÷÷? B
value
÷÷C H
)
÷÷H I
=>
÷÷J L
this
÷÷M Q
.
÷÷Q R

UnwrapCore
÷÷R \
(
÷÷\ ]
)
÷÷] ^
.
÷÷^ _

_SetMedium
÷÷_ i
(
÷÷i j
this
÷÷j n
.
÷÷n o
Idx
÷÷o r
(
÷÷r s
index
÷÷s x
)
÷÷x y
,
÷÷y z
value÷÷{ Ä
)÷÷Ä Å
;÷÷Å Ç
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
SetMediumLE
ÿÿ$ /
(
ÿÿ/ 0
int
ÿÿ0 3
index
ÿÿ4 9
,
ÿÿ9 :
int
ÿÿ; >
value
ÿÿ? D
)
ÿÿD E
{
ŸŸ 	
this
⁄⁄ 
.
⁄⁄ 
CheckIndex0
⁄⁄ 
(
⁄⁄ 
index
⁄⁄ "
,
⁄⁄" #
$num
⁄⁄$ %
)
⁄⁄% &
;
⁄⁄& '
this
€€ 
.
€€ 
Unwrap
€€ 
(
€€ 
)
€€ 
.
€€ 
SetMediumLE
€€ %
(
€€% &
this
€€& *
.
€€* +
Idx
€€+ .
(
€€. /
index
€€/ 4
)
€€4 5
,
€€5 6
value
€€7 <
)
€€< =
;
€€= >
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
›› 	
	protected
ﬂﬂ 
internal
ﬂﬂ 
override
ﬂﬂ #
void
ﬂﬂ$ (
_SetMediumLE
ﬂﬂ) 5
(
ﬂﬂ5 6
int
ﬂﬂ6 9
index
ﬂﬂ: ?
,
ﬂﬂ? @
int
ﬂﬂA D
value
ﬂﬂE J
)
ﬂﬂJ K
=>
ﬂﬂL N
this
ﬂﬂO S
.
ﬂﬂS T

UnwrapCore
ﬂﬂT ^
(
ﬂﬂ^ _
)
ﬂﬂ_ `
.
ﬂﬂ` a
_SetMediumLE
ﬂﬂa m
(
ﬂﬂm n
this
ﬂﬂn r
.
ﬂﬂr s
Idx
ﬂﬂs v
(
ﬂﬂv w
index
ﬂﬂw |
)
ﬂﬂ| }
,
ﬂﬂ} ~
valueﬂﬂ Ñ
)ﬂﬂÑ Ö
;ﬂﬂÖ Ü
public
·· 
override
·· 
IByteBuffer
·· #
SetInt
··$ *
(
··* +
int
··+ .
index
··/ 4
,
··4 5
int
··6 9
value
··: ?
)
··? @
{
‚‚ 	
this
„„ 
.
„„ 
CheckIndex0
„„ 
(
„„ 
index
„„ "
,
„„" #
$num
„„$ %
)
„„% &
;
„„& '
this
‰‰ 
.
‰‰ 
Unwrap
‰‰ 
(
‰‰ 
)
‰‰ 
.
‰‰ 
SetInt
‰‰  
(
‰‰  !
this
‰‰! %
.
‰‰% &
Idx
‰‰& )
(
‰‰) *
index
‰‰* /
)
‰‰/ 0
,
‰‰0 1
value
‰‰2 7
)
‰‰7 8
;
‰‰8 9
return
ÂÂ 
this
ÂÂ 
;
ÂÂ 
}
ÊÊ 	
	protected
ËË 
internal
ËË 
override
ËË #
void
ËË$ (
_SetInt
ËË) 0
(
ËË0 1
int
ËË1 4
index
ËË5 :
,
ËË: ;
int
ËË< ?
value
ËË@ E
)
ËËE F
=>
ËËG I
this
ËËJ N
.
ËËN O

UnwrapCore
ËËO Y
(
ËËY Z
)
ËËZ [
.
ËË[ \
_SetInt
ËË\ c
(
ËËc d
this
ËËd h
.
ËËh i
Idx
ËËi l
(
ËËl m
index
ËËm r
)
ËËr s
,
ËËs t
value
ËËu z
)
ËËz {
;
ËË{ |
public
ÍÍ 
override
ÍÍ 
IByteBuffer
ÍÍ #
SetIntLE
ÍÍ$ ,
(
ÍÍ, -
int
ÍÍ- 0
index
ÍÍ1 6
,
ÍÍ6 7
int
ÍÍ8 ;
value
ÍÍ< A
)
ÍÍA B
{
ÎÎ 	
this
ÏÏ 
.
ÏÏ 
CheckIndex0
ÏÏ 
(
ÏÏ 
index
ÏÏ "
,
ÏÏ" #
$num
ÏÏ$ %
)
ÏÏ% &
;
ÏÏ& '
this
ÌÌ 
.
ÌÌ 
Unwrap
ÌÌ 
(
ÌÌ 
)
ÌÌ 
.
ÌÌ 
SetIntLE
ÌÌ "
(
ÌÌ" #
this
ÌÌ# '
.
ÌÌ' (
Idx
ÌÌ( +
(
ÌÌ+ ,
index
ÌÌ, 1
)
ÌÌ1 2
,
ÌÌ2 3
value
ÌÌ4 9
)
ÌÌ9 :
;
ÌÌ: ;
return
ÓÓ 
this
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
	protected
ÒÒ 
internal
ÒÒ 
override
ÒÒ #
void
ÒÒ$ (
	_SetIntLE
ÒÒ) 2
(
ÒÒ2 3
int
ÒÒ3 6
index
ÒÒ7 <
,
ÒÒ< =
int
ÒÒ> A
value
ÒÒB G
)
ÒÒG H
=>
ÒÒI K
this
ÒÒL P
.
ÒÒP Q

UnwrapCore
ÒÒQ [
(
ÒÒ[ \
)
ÒÒ\ ]
.
ÒÒ] ^
	_SetIntLE
ÒÒ^ g
(
ÒÒg h
this
ÒÒh l
.
ÒÒl m
Idx
ÒÒm p
(
ÒÒp q
index
ÒÒq v
)
ÒÒv w
,
ÒÒw x
value
ÒÒy ~
)
ÒÒ~ 
;ÒÒ Ä
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #
SetLong
ÛÛ$ +
(
ÛÛ+ ,
int
ÛÛ, /
index
ÛÛ0 5
,
ÛÛ5 6
long
ÛÛ7 ;
value
ÛÛ< A
)
ÛÛA B
{
ÙÙ 	
this
ıı 
.
ıı 
CheckIndex0
ıı 
(
ıı 
index
ıı "
,
ıı" #
$num
ıı$ %
)
ıı% &
;
ıı& '
this
ˆˆ 
.
ˆˆ 
Unwrap
ˆˆ 
(
ˆˆ 
)
ˆˆ 
.
ˆˆ 
SetLong
ˆˆ !
(
ˆˆ! "
this
ˆˆ" &
.
ˆˆ& '
Idx
ˆˆ' *
(
ˆˆ* +
index
ˆˆ+ 0
)
ˆˆ0 1
,
ˆˆ1 2
value
ˆˆ3 8
)
ˆˆ8 9
;
ˆˆ9 :
return
˜˜ 
this
˜˜ 
;
˜˜ 
}
¯¯ 	
	protected
˙˙ 
internal
˙˙ 
override
˙˙ #
void
˙˙$ (
_SetLong
˙˙) 1
(
˙˙1 2
int
˙˙2 5
index
˙˙6 ;
,
˙˙; <
long
˙˙= A
value
˙˙B G
)
˙˙G H
=>
˙˙I K
this
˙˙L P
.
˙˙P Q

UnwrapCore
˙˙Q [
(
˙˙[ \
)
˙˙\ ]
.
˙˙] ^
_SetLong
˙˙^ f
(
˙˙f g
this
˙˙g k
.
˙˙k l
Idx
˙˙l o
(
˙˙o p
index
˙˙p u
)
˙˙u v
,
˙˙v w
value
˙˙x }
)
˙˙} ~
;
˙˙~ 
public
¸¸ 
override
¸¸ 
IByteBuffer
¸¸ #
	SetLongLE
¸¸$ -
(
¸¸- .
int
¸¸. 1
index
¸¸2 7
,
¸¸7 8
long
¸¸9 =
value
¸¸> C
)
¸¸C D
{
˝˝ 	
this
˛˛ 
.
˛˛ 
CheckIndex0
˛˛ 
(
˛˛ 
index
˛˛ "
,
˛˛" #
$num
˛˛$ %
)
˛˛% &
;
˛˛& '
this
ˇˇ 
.
ˇˇ 
Unwrap
ˇˇ 
(
ˇˇ 
)
ˇˇ 
.
ˇˇ 
	SetLongLE
ˇˇ #
(
ˇˇ# $
this
ˇˇ$ (
.
ˇˇ( )
Idx
ˇˇ) ,
(
ˇˇ, -
index
ˇˇ- 2
)
ˇˇ2 3
,
ˇˇ3 4
value
ˇˇ5 :
)
ˇˇ: ;
;
ˇˇ; <
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
	protected
ÉÉ 
internal
ÉÉ 
override
ÉÉ #
void
ÉÉ$ (

_SetLongLE
ÉÉ) 3
(
ÉÉ3 4
int
ÉÉ4 7
index
ÉÉ8 =
,
ÉÉ= >
long
ÉÉ? C
value
ÉÉD I
)
ÉÉI J
=>
ÉÉK M
this
ÉÉN R
.
ÉÉR S

UnwrapCore
ÉÉS ]
(
ÉÉ] ^
)
ÉÉ^ _
.
ÉÉ_ `

_SetLongLE
ÉÉ` j
(
ÉÉj k
this
ÉÉk o
.
ÉÉo p
Idx
ÉÉp s
(
ÉÉs t
index
ÉÉt y
)
ÉÉy z
,
ÉÉz {
valueÉÉ| Å
)ÉÉÅ Ç
;ÉÉÇ É
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ #
SetBytes
ÖÖ$ ,
(
ÖÖ, -
int
ÖÖ- 0
index
ÖÖ1 6
,
ÖÖ6 7
byte
ÖÖ8 <
[
ÖÖ< =
]
ÖÖ= >
src
ÖÖ? B
,
ÖÖB C
int
ÖÖD G
srcIndex
ÖÖH P
,
ÖÖP Q
int
ÖÖR U
length
ÖÖV \
)
ÖÖ\ ]
{
ÜÜ 	
this
áá 
.
áá 
CheckIndex0
áá 
(
áá 
index
áá "
,
áá" #
length
áá$ *
)
áá* +
;
áá+ ,
this
àà 
.
àà 
Unwrap
àà 
(
àà 
)
àà 
.
àà 
SetBytes
àà "
(
àà" #
this
àà# '
.
àà' (
Idx
àà( +
(
àà+ ,
index
àà, 1
)
àà1 2
,
àà2 3
src
àà4 7
,
àà7 8
srcIndex
àà9 A
,
ààA B
length
ààC I
)
ààI J
;
ààJ K
return
ââ 
this
ââ 
;
ââ 
}
ää 	
public
åå 
override
åå 
IByteBuffer
åå #
SetBytes
åå$ ,
(
åå, -
int
åå- 0
index
åå1 6
,
åå6 7
IByteBuffer
åå8 C
src
ååD G
,
ååG H
int
ååI L
srcIndex
ååM U
,
ååU V
int
ååW Z
length
åå[ a
)
ååa b
{
çç 	
this
éé 
.
éé 
CheckIndex0
éé 
(
éé 
index
éé "
,
éé" #
length
éé$ *
)
éé* +
;
éé+ ,
this
èè 
.
èè 
Unwrap
èè 
(
èè 
)
èè 
.
èè 
SetBytes
èè "
(
èè" #
this
èè# '
.
èè' (
Idx
èè( +
(
èè+ ,
index
èè, 1
)
èè1 2
,
èè2 3
src
èè4 7
,
èè7 8
srcIndex
èè9 A
,
èèA B
length
èèC I
)
èèI J
;
èèJ K
return
êê 
this
êê 
;
êê 
}
ëë 	
public
ìì 
override
ìì 
IByteBuffer
ìì #
GetBytes
ìì$ ,
(
ìì, -
int
ìì- 0
index
ìì1 6
,
ìì6 7
Stream
ìì8 >
destination
ìì? J
,
ììJ K
int
ììL O
length
ììP V
)
ììV W
{
îî 	
this
ïï 
.
ïï 
CheckIndex0
ïï 
(
ïï 
index
ïï "
,
ïï" #
length
ïï$ *
)
ïï* +
;
ïï+ ,
return
ññ 
this
ññ 
.
ññ 
Unwrap
ññ 
(
ññ 
)
ññ  
.
ññ  !
GetBytes
ññ! )
(
ññ) *
this
ññ* .
.
ññ. /
Idx
ññ/ 2
(
ññ2 3
index
ññ3 8
)
ññ8 9
,
ññ9 :
destination
ññ; F
,
ññF G
length
ññH N
)
ññN O
;
ññO P
}
óó 	
public
ôô 
override
ôô 
Task
ôô 
<
ôô 
int
ôô  
>
ôô  !
SetBytesAsync
ôô" /
(
ôô/ 0
int
ôô0 3
index
ôô4 9
,
ôô9 :
Stream
ôô; A
src
ôôB E
,
ôôE F
int
ôôG J
length
ôôK Q
,
ôôQ R
CancellationToken
ôôS d
cancellationToken
ôôe v
)
ôôv w
{
öö 	
this
õõ 
.
õõ 
CheckIndex0
õõ 
(
õõ 
index
õõ "
,
õõ" #
length
õõ$ *
)
õõ* +
;
õõ+ ,
return
úú 
this
úú 
.
úú 
Unwrap
úú 
(
úú 
)
úú  
.
úú  !
SetBytesAsync
úú! .
(
úú. /
this
úú/ 3
.
úú3 4
Idx
úú4 7
(
úú7 8
index
úú8 =
)
úú= >
,
úú> ?
src
úú@ C
,
úúC D
length
úúE K
,
úúK L
cancellationToken
úúM ^
)
úú^ _
;
úú_ `
}
ùù 	
public
üü 
override
üü 
int
üü 
ForEachByte
üü '
(
üü' (
int
üü( +
index
üü, 1
,
üü1 2
int
üü3 6
length
üü7 =
,
üü= >
IByteProcessor
üü? M
	processor
üüN W
)
üüW X
{
†† 	
this
°° 
.
°° 
CheckIndex0
°° 
(
°° 
index
°° "
,
°°" #
length
°°$ *
)
°°* +
;
°°+ ,
int
¢¢ 
ret
¢¢ 
=
¢¢ 
this
¢¢ 
.
¢¢ 
Unwrap
¢¢ !
(
¢¢! "
)
¢¢" #
.
¢¢# $
ForEachByte
¢¢$ /
(
¢¢/ 0
this
¢¢0 4
.
¢¢4 5
Idx
¢¢5 8
(
¢¢8 9
index
¢¢9 >
)
¢¢> ?
,
¢¢? @
length
¢¢A G
,
¢¢G H
	processor
¢¢I R
)
¢¢R S
;
¢¢S T
if
££ 
(
££ 
ret
££ 
<
££ 
this
££ 
.
££ 

adjustment
££ %
)
££% &
{
§§ 
return
•• 
-
•• 
$num
•• 
;
•• 
}
¶¶ 
return
ßß 
ret
ßß 
-
ßß 
this
ßß 
.
ßß 

adjustment
ßß (
;
ßß( )
}
®® 	
public
™™ 
override
™™ 
int
™™ 
ForEachByteDesc
™™ +
(
™™+ ,
int
™™, /
index
™™0 5
,
™™5 6
int
™™7 :
length
™™; A
,
™™A B
IByteProcessor
™™C Q
	processor
™™R [
)
™™[ \
{
´´ 	
this
¨¨ 
.
¨¨ 
CheckIndex0
¨¨ 
(
¨¨ 
index
¨¨ "
,
¨¨" #
length
¨¨$ *
)
¨¨* +
;
¨¨+ ,
int
≠≠ 
ret
≠≠ 
=
≠≠ 
this
≠≠ 
.
≠≠ 
Unwrap
≠≠ !
(
≠≠! "
)
≠≠" #
.
≠≠# $
ForEachByteDesc
≠≠$ 3
(
≠≠3 4
this
≠≠4 8
.
≠≠8 9
Idx
≠≠9 <
(
≠≠< =
index
≠≠= B
)
≠≠B C
,
≠≠C D
length
≠≠E K
,
≠≠K L
	processor
≠≠M V
)
≠≠V W
;
≠≠W X
if
ÆÆ 
(
ÆÆ 
ret
ÆÆ 
<
ÆÆ 
this
ÆÆ 
.
ÆÆ 

adjustment
ÆÆ %
)
ÆÆ% &
{
ØØ 
return
∞∞ 
-
∞∞ 
$num
∞∞ 
;
∞∞ 
}
±± 
return
≤≤ 
ret
≤≤ 
-
≤≤ 
this
≤≤ 
.
≤≤ 

adjustment
≤≤ (
;
≤≤( )
}
≥≥ 	
int
µµ 
Idx
µµ 
(
µµ 
int
µµ 
index
µµ 
)
µµ 
=>
µµ 
index
µµ #
+
µµ$ %
this
µµ& *
.
µµ* +

adjustment
µµ+ 5
;
µµ5 6
}
∂∂ 
}∑∑ ÑΩ
oC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PooledUnsafeDirectByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

unsafe 
class (
PooledUnsafeDirectByteBuffer 4
:5 6
PooledByteBuffer7 G
<G H
byteH L
[L M
]M N
>N O
{ 
byte 
* 
memoryAddress 
; 
internal 
static (
PooledUnsafeDirectByteBuffer 4
NewInstance5 @
(@ A
intA D
maxCapacityE P
)P Q
{ 	
return 
new (
PooledUnsafeDirectByteBuffer 3
(3 4
maxCapacity4 ?
)? @
;@ A
} 	(
PooledUnsafeDirectByteBuffer $
($ %
int% (
maxCapacity) 4
)4 5
: 
base 
( 
maxCapacity 
) 
{ 	
} 	
internal 
override 
void 
Init #
(# $
	PoolChunk$ -
<- .
byte. 2
[2 3
]3 4
>4 5
chunk6 ;
,; <
long= A
handleB H
,H I
intJ M
offsetN T
,T U
intV Y
lengthZ `
,` a
intb e
	maxLengthf o
,o p
PoolThreadCache 
< 
byte  
[  !
]! "
>" #
cache$ )
)) *
{ 	
base 
. 
Init 
( 
chunk 
, 
handle #
,# $
offset% +
,+ ,
length- 3
,3 4
	maxLength5 >
,> ?
cache@ E
)E F
;F G
this 
. 
InitMemoryAddress "
(" #
)# $
;$ %
} 	
internal!! 
override!! 
void!! 
InitUnpooled!! +
(!!+ ,
	PoolChunk!!, 5
<!!5 6
byte!!6 :
[!!: ;
]!!; <
>!!< =
chunk!!> C
,!!C D
int!!E H
length!!I O
)!!O P
{"" 	
base## 
.## 
InitUnpooled## 
(## 
chunk## #
,### $
length##% +
)##+ ,
;##, -
this$$ 
.$$ 
InitMemoryAddress$$ "
($$" #
)$$# $
;$$$ %
}%% 	
void'' 
InitMemoryAddress'' 
('' 
)''  
{(( 	
this)) 
.)) 
memoryAddress)) 
=))  
())! "
byte))" &
*))& '
)))' (
Unsafe))( .
.)). /
	AsPointer))/ 8
())8 9
ref))9 <
this))= A
.))A B
Memory))B H
[))H I
this))I M
.))M N
Offset))N T
]))T U
)))U V
;))V W
}** 	
public,, 
override,, 
bool,, 
IsDirect,, %
=>,,& (
true,,) -
;,,- .
internal.. 
void.. 
Reuse.. 
(.. 
int.. 
maxCapacity..  +
)..+ ,
{// 	
this00 
.00 
SetMaxCapacity00 
(00  
maxCapacity00  +
)00+ ,
;00, -
this11 
.11 
SetReferenceCount11 "
(11" #
$num11# $
)11$ %
;11% &
this22 
.22 
	SetIndex022 
(22 
$num22 
,22 
$num22 
)22  
;22  !
this33 
.33 
DiscardMarks33 
(33 
)33 
;33  
}44 	
	protected66 
internal66 
override66 #
byte66$ (
_GetByte66) 1
(661 2
int662 5
index666 ;
)66; <
=>66= ?
*66@ A
(66A B
this66B F
.66F G
memoryAddress66G T
+66U V
index66W \
)66\ ]
;66] ^
	protected88 
internal88 
override88 #
short88$ )
	_GetShort88* 3
(883 4
int884 7
index888 =
)88= >
=>88? A 
UnsafeByteBufferUtil88B V
.88V W
GetShort88W _
(88_ `
this88` d
.88d e
Addr88e i
(88i j
index88j o
)88o p
)88p q
;88q r
	protected:: 
internal:: 
override:: #
short::$ )
_GetShortLE::* 5
(::5 6
int::6 9
index::: ?
)::? @
=>::A C 
UnsafeByteBufferUtil::D X
.::X Y

GetShortLE::Y c
(::c d
this::d h
.::h i
Addr::i m
(::m n
index::n s
)::s t
)::t u
;::u v
	protected<< 
internal<< 
override<< #
int<<$ '
_GetUnsignedMedium<<( :
(<<: ;
int<<; >
index<<? D
)<<D E
=><<F H 
UnsafeByteBufferUtil<<I ]
.<<] ^
GetUnsignedMedium<<^ o
(<<o p
this<<p t
.<<t u
Addr<<u y
(<<y z
index<<z 
)	<< Ä
)
<<Ä Å
;
<<Å Ç
	protected>> 
internal>> 
override>> #
int>>$ ' 
_GetUnsignedMediumLE>>( <
(>>< =
int>>= @
index>>A F
)>>F G
=>>>H J 
UnsafeByteBufferUtil>>K _
.>>_ `
GetUnsignedMediumLE>>` s
(>>s t
this>>t x
.>>x y
Addr>>y }
(>>} ~
index	>>~ É
)
>>É Ñ
)
>>Ñ Ö
;
>>Ö Ü
	protected@@ 
internal@@ 
override@@ #
int@@$ '
_GetInt@@( /
(@@/ 0
int@@0 3
index@@4 9
)@@9 :
=>@@; = 
UnsafeByteBufferUtil@@> R
.@@R S
GetInt@@S Y
(@@Y Z
this@@Z ^
.@@^ _
Addr@@_ c
(@@c d
index@@d i
)@@i j
)@@j k
;@@k l
	protectedBB 
internalBB 
overrideBB #
intBB$ '
	_GetIntLEBB( 1
(BB1 2
intBB2 5
indexBB6 ;
)BB; <
=>BB= ? 
UnsafeByteBufferUtilBB@ T
.BBT U
GetIntLEBBU ]
(BB] ^
thisBB^ b
.BBb c
AddrBBc g
(BBg h
indexBBh m
)BBm n
)BBn o
;BBo p
	protectedDD 
internalDD 
overrideDD #
longDD$ (
_GetLongDD) 1
(DD1 2
intDD2 5
indexDD6 ;
)DD; <
=>DD= ? 
UnsafeByteBufferUtilDD@ T
.DDT U
GetLongDDU \
(DD\ ]
thisDD] a
.DDa b
AddrDDb f
(DDf g
indexDDg l
)DDl m
)DDm n
;DDn o
	protectedFF 
internalFF 
overrideFF #
longFF$ (

_GetLongLEFF) 3
(FF3 4
intFF4 7
indexFF8 =
)FF= >
=>FF? A 
UnsafeByteBufferUtilFFB V
.FFV W
	GetLongLEFFW `
(FF` a
thisFFa e
.FFe f
AddrFFf j
(FFj k
indexFFk p
)FFp q
)FFq r
;FFr s
publicHH 
overrideHH 
IByteBufferHH #
GetBytesHH$ ,
(HH, -
intHH- 0
indexHH1 6
,HH6 7
IByteBufferHH8 C
dstHHD G
,HHG H
intHHI L
dstIndexHHM U
,HHU V
intHHW Z
lengthHH[ a
)HHa b
{II 	
thisJJ 
.JJ 

CheckIndexJJ 
(JJ 
indexJJ !
,JJ! "
lengthJJ# )
)JJ) *
;JJ* + 
UnsafeByteBufferUtilKK  
.KK  !
GetBytesKK! )
(KK) *
thisKK* .
,KK. /
thisKK0 4
.KK4 5
AddrKK5 9
(KK9 :
indexKK: ?
)KK? @
,KK@ A
indexKKB G
,KKG H
dstKKI L
,KKL M
dstIndexKKN V
,KKV W
lengthKKX ^
)KK^ _
;KK_ `
returnLL 
thisLL 
;LL 
}MM 	
publicOO 
overrideOO 
IByteBufferOO #
GetBytesOO$ ,
(OO, -
intOO- 0
indexOO1 6
,OO6 7
byteOO8 <
[OO< =
]OO= >
dstOO? B
,OOB C
intOOD G
dstIndexOOH P
,OOP Q
intOOR U
lengthOOV \
)OO\ ]
{PP 	
thisQQ 
.QQ 

CheckIndexQQ 
(QQ 
indexQQ !
,QQ! "
lengthQQ# )
)QQ) *
;QQ* + 
UnsafeByteBufferUtilRR  
.RR  !
GetBytesRR! )
(RR) *
thisRR* .
,RR. /
thisRR0 4
.RR4 5
AddrRR5 9
(RR9 :
indexRR: ?
)RR? @
,RR@ A
indexRRB G
,RRG H
dstRRI L
,RRL M
dstIndexRRN V
,RRV W
lengthRRX ^
)RR^ _
;RR_ `
returnSS 
thisSS 
;SS 
}TT 	
publicVV 
overrideVV 
IByteBufferVV #
GetBytesVV$ ,
(VV, -
intVV- 0
indexVV1 6
,VV6 7
StreamVV8 >
outputVV? E
,VVE F
intVVG J
lengthVVK Q
)VVQ R
{WW 	 
UnsafeByteBufferUtilXX  
.XX  !
GetBytesXX! )
(XX) *
thisXX* .
,XX. /
thisXX0 4
.XX4 5
AddrXX5 9
(XX9 :
indexXX: ?
)XX? @
,XX@ A
indexXXB G
,XXG H
outputXXI O
,XXO P
lengthXXQ W
)XXW X
;XXX Y
returnYY 
thisYY 
;YY 
}ZZ 	
	protected\\ 
internal\\ 
override\\ #
void\\$ (
_SetByte\\) 1
(\\1 2
int\\2 5
index\\6 ;
,\\; <
int\\= @
value\\A F
)\\F G
=>\\H J
*\\K L
(\\L M
this\\M Q
.\\Q R
memoryAddress\\R _
+\\` a
index\\b g
)\\g h
=\\i j
	unchecked\\k t
(\\t u
(\\u v
byte\\v z
)\\z {
value	\\{ Ä
)
\\Ä Å
;
\\Å Ç
	protected^^ 
internal^^ 
override^^ #
void^^$ (
	_SetShort^^) 2
(^^2 3
int^^3 6
index^^7 <
,^^< =
int^^> A
value^^B G
)^^G H
=>^^I K 
UnsafeByteBufferUtil^^L `
.^^` a
SetShort^^a i
(^^i j
this^^j n
.^^n o
Addr^^o s
(^^s t
index^^t y
)^^y z
,^^z {
value	^^| Å
)
^^Å Ç
;
^^Ç É
	protected`` 
internal`` 
override`` #
void``$ (
_SetShortLE``) 4
(``4 5
int``5 8
index``9 >
,``> ?
int``@ C
value``D I
)``I J
=>``K M 
UnsafeByteBufferUtil``N b
.``b c

SetShortLE``c m
(``m n
this``n r
.``r s
Addr``s w
(``w x
index``x }
)``} ~
,``~ 
value
``Ä Ö
)
``Ö Ü
;
``Ü á
	protectedbb 
internalbb 
overridebb #
voidbb$ (

_SetMediumbb) 3
(bb3 4
intbb4 7
indexbb8 =
,bb= >
intbb? B
valuebbC H
)bbH I
=>bbJ L 
UnsafeByteBufferUtilbbM a
.bba b
	SetMediumbbb k
(bbk l
thisbbl p
.bbp q
Addrbbq u
(bbu v
indexbbv {
)bb{ |
,bb| }
value	bb~ É
)
bbÉ Ñ
;
bbÑ Ö
	protecteddd 
internaldd 
overridedd #
voiddd$ (
_SetMediumLEdd) 5
(dd5 6
intdd6 9
indexdd: ?
,dd? @
intddA D
valueddE J
)ddJ K
=>ddL N 
UnsafeByteBufferUtilddO c
.ddc d
SetMediumLEddd o
(ddo p
thisddp t
.ddt u
Addrddu y
(ddy z
indexddz 
)	dd Ä
,
ddÄ Å
value
ddÇ á
)
ddá à
;
ddà â
	protectedff 
internalff 
overrideff #
voidff$ (
_SetIntff) 0
(ff0 1
intff1 4
indexff5 :
,ff: ;
intff< ?
valueff@ E
)ffE F
=>ffG I 
UnsafeByteBufferUtilffJ ^
.ff^ _
SetIntff_ e
(ffe f
thisfff j
.ffj k
Addrffk o
(ffo p
indexffp u
)ffu v
,ffv w
valueffx }
)ff} ~
;ff~ 
	protectedhh 
internalhh 
overridehh #
voidhh$ (
	_SetIntLEhh) 2
(hh2 3
inthh3 6
indexhh7 <
,hh< =
inthh> A
valuehhB G
)hhG H
=>hhI K 
UnsafeByteBufferUtilhhL `
.hh` a
SetIntLEhha i
(hhi j
thishhj n
.hhn o
Addrhho s
(hhs t
indexhht y
)hhy z
,hhz {
value	hh| Å
)
hhÅ Ç
;
hhÇ É
	protectedjj 
internaljj 
overridejj #
voidjj$ (
_SetLongjj) 1
(jj1 2
intjj2 5
indexjj6 ;
,jj; <
longjj= A
valuejjB G
)jjG H
=>jjI K 
UnsafeByteBufferUtiljjL `
.jj` a
SetLongjja h
(jjh i
thisjji m
.jjm n
Addrjjn r
(jjr s
indexjjs x
)jjx y
,jjy z
value	jj{ Ä
)
jjÄ Å
;
jjÅ Ç
	protectedll 
internalll 
overridell #
voidll$ (

_SetLongLEll) 3
(ll3 4
intll4 7
indexll8 =
,ll= >
longll? C
valuellD I
)llI J
=>llK M 
UnsafeByteBufferUtilllN b
.llb c
	SetLongLEllc l
(lll m
thisllm q
.llq r
Addrllr v
(llv w
indexllw |
)ll| }
,ll} ~
value	ll Ñ
)
llÑ Ö
;
llÖ Ü
publicnn 
overridenn 
IByteBuffernn #
SetBytesnn$ ,
(nn, -
intnn- 0
indexnn1 6
,nn6 7
IByteBuffernn8 C
srcnnD G
,nnG H
intnnI L
srcIndexnnM U
,nnU V
intnnW Z
lengthnn[ a
)nna b
{oo 	
thispp 
.pp 

CheckIndexpp 
(pp 
indexpp !
,pp! "
lengthpp# )
)pp) *
;pp* + 
UnsafeByteBufferUtilqq  
.qq  !
SetBytesqq! )
(qq) *
thisqq* .
,qq. /
thisqq0 4
.qq4 5
Addrqq5 9
(qq9 :
indexqq: ?
)qq? @
,qq@ A
indexqqB G
,qqG H
srcqqI L
,qqL M
srcIndexqqN V
,qqV W
lengthqqX ^
)qq^ _
;qq_ `
returnrr 
thisrr 
;rr 
}ss 	
publicuu 
overrideuu 
IByteBufferuu #
SetBytesuu$ ,
(uu, -
intuu- 0
indexuu1 6
,uu6 7
byteuu8 <
[uu< =
]uu= >
srcuu? B
,uuB C
intuuD G
srcIndexuuH P
,uuP Q
intuuR U
lengthuuV \
)uu\ ]
{vv 	
thisww 
.ww 

CheckIndexww 
(ww 
indexww !
,ww! "
lengthww# )
)ww) *
;ww* + 
UnsafeByteBufferUtilxx  
.xx  !
SetBytesxx! )
(xx) *
thisxx* .
,xx. /
thisxx0 4
.xx4 5
Addrxx5 9
(xx9 :
indexxx: ?
)xx? @
,xx@ A
indexxxB G
,xxG H
srcxxI L
,xxL M
srcIndexxxN V
,xxV W
lengthxxX ^
)xx^ _
;xx_ `
returnyy 
thisyy 
;yy 
}zz 	
public|| 
override|| 
Task|| 
<|| 
int||  
>||  !
SetBytesAsync||" /
(||/ 0
int||0 3
index||4 9
,||9 :
Stream||; A
src||B E
,||E F
int||G J
length||K Q
,||Q R
CancellationToken||S d
cancellationToken||e v
)||v w
{}} 	
this~~ 
.~~ 

CheckIndex~~ 
(~~ 
index~~ !
,~~! "
length~~# )
)~~) *
;~~* +
return  
UnsafeByteBufferUtil '
.' (
SetBytesAsync( 5
(5 6
this6 :
,: ;
this< @
.@ A
AddrA E
(E F
indexF K
)K L
,L M
indexN S
,S T
srcU X
,X Y
lengthZ `
,` a
cancellationTokenb s
)s t
;t u
}
ÄÄ 	
public
ÇÇ 
override
ÇÇ 
IByteBuffer
ÇÇ #
Copy
ÇÇ$ (
(
ÇÇ( )
int
ÇÇ) ,
index
ÇÇ- 2
,
ÇÇ2 3
int
ÇÇ4 7
length
ÇÇ8 >
)
ÇÇ> ?
{
ÉÉ 	
this
ÑÑ 
.
ÑÑ 

CheckIndex
ÑÑ 
(
ÑÑ 
index
ÑÑ !
,
ÑÑ! "
length
ÑÑ# )
)
ÑÑ) *
;
ÑÑ* +
return
ÖÖ "
UnsafeByteBufferUtil
ÖÖ '
.
ÖÖ' (
Copy
ÖÖ( ,
(
ÖÖ, -
this
ÖÖ- 1
,
ÖÖ1 2
this
ÖÖ3 7
.
ÖÖ7 8
Addr
ÖÖ8 <
(
ÖÖ< =
index
ÖÖ= B
)
ÖÖB C
,
ÖÖC D
index
ÖÖE J
,
ÖÖJ K
length
ÖÖL R
)
ÖÖR S
;
ÖÖS T
}
ÜÜ 	
public
àà 
override
àà 
int
àà 
IoBufferCount
àà )
=>
àà* ,
$num
àà- .
;
àà. /
public
ää 
override
ää 
ArraySegment
ää $
<
ää$ %
byte
ää% )
>
ää) *
GetIoBuffer
ää+ 6
(
ää6 7
int
ää7 :
index
ää; @
,
ää@ A
int
ääB E
length
ääF L
)
ääL M
{
ãã 	
this
åå 
.
åå 

CheckIndex
åå 
(
åå 
index
åå !
,
åå! "
length
åå# )
)
åå) *
;
åå* +
index
çç 
=
çç 
this
çç 
.
çç 
Idx
çç 
(
çç 
index
çç "
)
çç" #
;
çç# $
return
éé 
new
éé 
ArraySegment
éé #
<
éé# $
byte
éé$ (
>
éé( )
(
éé) *
this
éé* .
.
éé. /
Memory
éé/ 5
,
éé5 6
index
éé7 <
,
éé< =
length
éé> D
)
ééD E
;
ééE F
}
èè 	
public
ëë 
override
ëë 
ArraySegment
ëë $
<
ëë$ %
byte
ëë% )
>
ëë) *
[
ëë* +
]
ëë+ ,
GetIoBuffers
ëë- 9
(
ëë9 :
int
ëë: =
index
ëë> C
,
ëëC D
int
ëëE H
length
ëëI O
)
ëëO P
=>
ëëQ S
new
ëëT W
[
ëëW X
]
ëëX Y
{
ëëZ [
this
ëë\ `
.
ëë` a
GetIoBuffer
ëëa l
(
ëël m
index
ëëm r
,
ëër s
length
ëët z
)
ëëz {
}
ëë| }
;
ëë} ~
public
ìì 
override
ìì 
bool
ìì 
HasArray
ìì %
=>
ìì& (
true
ìì) -
;
ìì- .
public
ïï 
override
ïï 
byte
ïï 
[
ïï 
]
ïï 
Array
ïï $
{
ññ 	
get
óó 
{
òò 
this
ôô 
.
ôô 
EnsureAccessible
ôô %
(
ôô% &
)
ôô& '
;
ôô' (
return
öö 
this
öö 
.
öö 
Memory
öö "
;
öö" #
}
õõ 
}
úú 	
public
ûû 
override
ûû 
int
ûû 
ArrayOffset
ûû '
=>
ûû( *
this
ûû+ /
.
ûû/ 0
Offset
ûû0 6
;
ûû6 7
public
†† 
override
†† 
bool
†† 
HasMemoryAddress
†† -
=>
††. 0
true
††1 5
;
††5 6
public
¢¢ 
override
¢¢ 
ref
¢¢ 
byte
¢¢  &
GetPinnableMemoryAddress
¢¢! 9
(
¢¢9 :
)
¢¢: ;
{
££ 	
this
§§ 
.
§§ 
EnsureAccessible
§§ !
(
§§! "
)
§§" #
;
§§# $
return
•• 
ref
•• 
this
•• 
.
•• 
Memory
•• "
[
••" #
this
••# '
.
••' (
Offset
••( .
]
••. /
;
••/ 0
}
¶¶ 	
public
®® 
override
®® 
IntPtr
®® #
AddressOfPinnedMemory
®® 4
(
®®4 5
)
®®5 6
=>
®®7 9
(
®®: ;
IntPtr
®®; A
)
®®A B
this
®®B F
.
®®F G
memoryAddress
®®G T
;
®®T U
[
™™ 	

MethodImpl
™™	 
(
™™ 
MethodImplOptions
™™ %
.
™™% & 
AggressiveInlining
™™& 8
)
™™8 9
]
™™9 :
byte
´´ 
*
´´ 
Addr
´´ 
(
´´ 
int
´´ 
index
´´ 
)
´´ 
=>
´´  
this
´´! %
.
´´% &
memoryAddress
´´& 3
+
´´4 5
index
´´6 ;
;
´´; <
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #
SetZero
≠≠$ +
(
≠≠+ ,
int
≠≠, /
index
≠≠0 5
,
≠≠5 6
int
≠≠7 :
length
≠≠; A
)
≠≠A B
{
ÆÆ 	
this
ØØ 
.
ØØ 

CheckIndex
ØØ 
(
ØØ 
index
ØØ !
,
ØØ! "
length
ØØ# )
)
ØØ) *
;
ØØ* +"
UnsafeByteBufferUtil
∞∞  
.
∞∞  !
SetZero
∞∞! (
(
∞∞( )
this
∞∞) -
.
∞∞- .
Addr
∞∞. 2
(
∞∞2 3
index
∞∞3 8
)
∞∞8 9
,
∞∞9 :
length
∞∞; A
)
∞∞A B
;
∞∞B C
return
±± 
this
±± 
;
±± 
}
≤≤ 	
public
¥¥ 
override
¥¥ 
IByteBuffer
¥¥ #
	WriteZero
¥¥$ -
(
¥¥- .
int
¥¥. 1
length
¥¥2 8
)
¥¥8 9
{
µµ 	
this
∂∂ 
.
∂∂ 
EnsureWritable
∂∂ 
(
∂∂  
length
∂∂  &
)
∂∂& '
;
∂∂' (
int
∑∑ 
wIndex
∑∑ 
=
∑∑ 
this
∑∑ 
.
∑∑ 
WriterIndex
∑∑ )
;
∑∑) *"
UnsafeByteBufferUtil
∏∏  
.
∏∏  !
SetZero
∏∏! (
(
∏∏( )
this
∏∏) -
.
∏∏- .
Addr
∏∏. 2
(
∏∏2 3
wIndex
∏∏3 9
)
∏∏9 :
,
∏∏: ;
length
∏∏< B
)
∏∏B C
;
∏∏C D
this
ππ 
.
ππ 
SetWriterIndex
ππ 
(
ππ  
wIndex
ππ  &
+
ππ' (
length
ππ) /
)
ππ/ 0
;
ππ0 1
return
∫∫ 
this
∫∫ 
;
∫∫ 
}
ªª 	
}
ºº 
}ΩΩ Èß
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolSubpage.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed

 

class

 
PoolSubpage

 
<

 
T

 
>

 
:

  !
IPoolSubpageMetric

" 4
{ 
internal 
readonly 
	PoolChunk #
<# $
T$ %
>% &
Chunk' ,
;, -
readonly 
int 
memoryMapIdx !
;! "
readonly 
int 
	runOffset 
; 
readonly 
int 
pageSize 
; 
readonly 
long 
[ 
] 
bitmap 
; 
internal 
PoolSubpage 
< 
T 
> 
Prev  $
;$ %
internal 
PoolSubpage 
< 
T 
> 
Next  $
;$ %
internal 
bool 
DoNotDestroy "
;" #
internal 
int 
ElemSize 
; 
int 
maxNumElems 
; 
int 
bitmapLength 
; 
int 
	nextAvail 
; 
int 
numAvail 
; 
public!! 
PoolSubpage!! 
(!! 
int!! 
pageSize!! '
)!!' (
{"" 	
this## 
.## 
Chunk## 
=## 
null## 
;## 
this$$ 
.$$ 
memoryMapIdx$$ 
=$$ 
-$$  !
$num$$! "
;$$" #
this%% 
.%% 
	runOffset%% 
=%% 
-%% 
$num%% 
;%%  
this&& 
.&& 
ElemSize&& 
=&& 
-&& 
$num&& 
;&& 
this'' 
.'' 
pageSize'' 
='' 
pageSize'' $
;''$ %
this(( 
.(( 
bitmap(( 
=(( 
null(( 
;(( 
})) 	
public++ 
PoolSubpage++ 
(++ 
PoolSubpage++ &
<++& '
T++' (
>++( )
head++* .
,++. /
	PoolChunk++0 9
<++9 :
T++: ;
>++; <
chunk++= B
,++B C
int++D G
memoryMapIdx++H T
,++T U
int++V Y
	runOffset++Z c
,++c d
int++e h
pageSize++i q
,++q r
int++s v
elemSize++w 
)	++ Ä
{,, 	
this-- 
.-- 
Chunk-- 
=-- 
chunk-- 
;-- 
this.. 
... 
memoryMapIdx.. 
=.. 
memoryMapIdx..  ,
;.., -
this// 
.// 
	runOffset// 
=// 
	runOffset// &
;//& '
this00 
.00 
pageSize00 
=00 
pageSize00 $
;00$ %
this11 
.11 
bitmap11 
=11 
new11 
long11 "
[11" #
pageSize11# +
.11+ ,
RightUShift11, 7
(117 8
$num118 :
)11: ;
]11; <
;11< =
this22 
.22 
Init22 
(22 
head22 
,22 
elemSize22 $
)22$ %
;22% &
}33 	
public55 
void55 
Init55 
(55 
PoolSubpage55 $
<55$ %
T55% &
>55& '
head55( ,
,55, -
int55. 1
elemSize552 :
)55: ;
{66 	
this77 
.77 
DoNotDestroy77 
=77 
true77  $
;77$ %
this88 
.88 
ElemSize88 
=88 
elemSize88 $
;88$ %
if99 
(99 
elemSize99 
!=99 
$num99 
)99 
{:: 
this;; 
.;; 
maxNumElems;;  
=;;! "
this;;# '
.;;' (
numAvail;;( 0
=;;1 2
this;;3 7
.;;7 8
pageSize;;8 @
/;;A B
elemSize;;C K
;;;K L
this<< 
.<< 
	nextAvail<< 
=<<  
$num<<! "
;<<" #
this== 
.== 
bitmapLength== !
===" #
this==$ (
.==( )
maxNumElems==) 4
.==4 5
RightUShift==5 @
(==@ A
$num==A B
)==B C
;==C D
if>> 
(>> 
(>> 
this>> 
.>> 
maxNumElems>> %
&>>& '
$num>>( *
)>>* +
!=>>, .
$num>>/ 0
)>>0 1
{?? 
this@@ 
.@@ 
bitmapLength@@ %
++@@% '
;@@' (
}AA 
forCC 
(CC 
intCC 
iCC 
=CC 
$numCC 
;CC 
iCC  !
<CC" #
thisCC$ (
.CC( )
bitmapLengthCC) 5
;CC5 6
iCC7 8
++CC8 :
)CC: ;
{DD 
thisEE 
.EE 
bitmapEE 
[EE  
iEE  !
]EE! "
=EE# $
$numEE% &
;EE& '
}FF 
}GG 
thisII 
.II 
	AddToPoolII 
(II 
headII 
)II  
;II  !
}JJ 	
internalPP 
longPP 
AllocatePP 
(PP 
)PP  
{QQ 	
ifRR 
(RR 
thisRR 
.RR 
ElemSizeRR 
==RR  
$numRR! "
)RR" #
{SS 
returnTT 
thisTT 
.TT 
ToHandleTT $
(TT$ %
$numTT% &
)TT& '
;TT' (
}UU 
ifWW 
(WW 
thisWW 
.WW 
numAvailWW 
==WW  
$numWW! "
||WW# %
!WW& '
thisWW' +
.WW+ ,
DoNotDestroyWW, 8
)WW8 9
{XX 
returnYY 
-YY 
$numYY 
;YY 
}ZZ 
int\\ 
	bitmapIdx\\ 
=\\ 
this\\  
.\\  !
GetNextAvail\\! -
(\\- .
)\\. /
;\\/ 0
int]] 
q]] 
=]] 
	bitmapIdx]] 
.]] 
RightUShift]] )
(]]) *
$num]]* +
)]]+ ,
;]], -
int^^ 
r^^ 
=^^ 
	bitmapIdx^^ 
&^^ 
$num^^  "
;^^" #
Contract__ 
.__ 
Assert__ 
(__ 
(__ 
this__ !
.__! "
bitmap__" (
[__( )
q__) *
]__* +
.__+ ,
RightUShift__, 7
(__7 8
r__8 9
)__9 :
&__; <
$num__= >
)__> ?
==__@ B
$num__C D
)__D E
;__E F
this`` 
.`` 
bitmap`` 
[`` 
q`` 
]`` 
|=`` 
$num``  
<<``! #
r``$ %
;``% &
ifbb 
(bb 
--bb 
thisbb 
.bb 
numAvailbb 
==bb  "
$numbb# $
)bb$ %
{cc 
thisdd 
.dd 
RemoveFromPooldd #
(dd# $
)dd$ %
;dd% &
}ee 
returngg 
thisgg 
.gg 
ToHandlegg  
(gg  !
	bitmapIdxgg! *
)gg* +
;gg+ ,
}hh 	
internaloo 
booloo 
Freeoo 
(oo 
PoolSubpageoo &
<oo& '
Too' (
>oo( )
headoo* .
,oo. /
intoo0 3
	bitmapIdxoo4 =
)oo= >
{pp 	
ifqq 
(qq 
thisqq 
.qq 
ElemSizeqq 
==qq  
$numqq! "
)qq" #
{rr 
returnss 
truess 
;ss 
}tt 
intvv 
qvv 
=vv 
	bitmapIdxvv 
.vv 
RightUShiftvv )
(vv) *
$numvv* +
)vv+ ,
;vv, -
intww 
rww 
=ww 
	bitmapIdxww 
&ww 
$numww  "
;ww" #
Debugxx 
.xx 
Assertxx 
(xx 
(xx 
thisxx 
.xx 
bitmapxx %
[xx% &
qxx& '
]xx' (
.xx( )
RightUShiftxx) 4
(xx4 5
rxx5 6
)xx6 7
&xx8 9
$numxx: ;
)xx; <
!=xx= ?
$numxx@ A
)xxA B
;xxB C
thisyy 
.yy 
bitmapyy 
[yy 
qyy 
]yy 
^=yy 
$numyy  
<<yy! #
ryy$ %
;yy% &
this{{ 
.{{ 
SetNextAvail{{ 
({{ 
	bitmapIdx{{ '
){{' (
;{{( )
if}} 
(}} 
this}} 
.}} 
numAvail}} 
++}} 
==}}  "
$num}}# $
)}}$ %
{~~ 
this 
. 
	AddToPool 
( 
head #
)# $
;$ %
return
ÄÄ 
true
ÄÄ 
;
ÄÄ 
}
ÅÅ 
if
ÉÉ 
(
ÉÉ 
this
ÉÉ 
.
ÉÉ 
numAvail
ÉÉ 
!=
ÉÉ  
this
ÉÉ! %
.
ÉÉ% &
maxNumElems
ÉÉ& 1
)
ÉÉ1 2
{
ÑÑ 
return
ÖÖ 
true
ÖÖ 
;
ÖÖ 
}
ÜÜ 
else
áá 
{
àà 
if
ää 
(
ää 
this
ää 
.
ää 
Prev
ää 
==
ää  
this
ää! %
.
ää% &
Next
ää& *
)
ää* +
{
ãã 
return
çç 
true
çç 
;
çç  
}
éé 
this
ëë 
.
ëë 
DoNotDestroy
ëë !
=
ëë" #
false
ëë$ )
;
ëë) *
this
íí 
.
íí 
RemoveFromPool
íí #
(
íí# $
)
íí$ %
;
íí% &
return
ìì 
false
ìì 
;
ìì 
}
îî 
}
ïï 	
void
óó 
	AddToPool
óó 
(
óó 
PoolSubpage
óó "
<
óó" #
T
óó# $
>
óó$ %
head
óó& *
)
óó* +
{
òò 	
Debug
ôô 
.
ôô 
Assert
ôô 
(
ôô 
this
ôô 
.
ôô 
Prev
ôô "
==
ôô# %
null
ôô& *
&&
ôô+ -
this
ôô. 2
.
ôô2 3
Next
ôô3 7
==
ôô8 :
null
ôô; ?
)
ôô? @
;
ôô@ A
this
õõ 
.
õõ 
Prev
õõ 
=
õõ 
head
õõ 
;
õõ 
this
úú 
.
úú 
Next
úú 
=
úú 
head
úú 
.
úú 
Next
úú !
;
úú! "
this
ùù 
.
ùù 
Next
ùù 
.
ùù 
Prev
ùù 
=
ùù 
this
ùù !
;
ùù! "
head
ûû 
.
ûû 
Next
ûû 
=
ûû 
this
ûû 
;
ûû 
}
üü 	
void
°° 
RemoveFromPool
°° 
(
°° 
)
°° 
{
¢¢ 	
Debug
££ 
.
££ 
Assert
££ 
(
££ 
this
££ 
.
££ 
Prev
££ "
!=
££# %
null
££& *
&&
££+ -
this
££. 2
.
££2 3
Next
££3 7
!=
££8 :
null
££; ?
)
££? @
;
££@ A
this
•• 
.
•• 
Prev
•• 
.
•• 
Next
•• 
=
•• 
this
•• !
.
••! "
Next
••" &
;
••& '
this
¶¶ 
.
¶¶ 
Next
¶¶ 
.
¶¶ 
Prev
¶¶ 
=
¶¶ 
this
¶¶ !
.
¶¶! "
Prev
¶¶" &
;
¶¶& '
this
ßß 
.
ßß 
Next
ßß 
=
ßß 
null
ßß 
;
ßß 
this
®® 
.
®® 
Prev
®® 
=
®® 
null
®® 
;
®® 
}
©© 	
void
´´ 
SetNextAvail
´´ 
(
´´ 
int
´´ 
	bitmapIdx
´´ '
)
´´' (
=>
´´) +
this
´´, 0
.
´´0 1
	nextAvail
´´1 :
=
´´; <
	bitmapIdx
´´= F
;
´´F G
int
≠≠ 
GetNextAvail
≠≠ 
(
≠≠ 
)
≠≠ 
{
ÆÆ 	
int
ØØ 
	nextAvail
ØØ 
=
ØØ 
this
ØØ  
.
ØØ  !
	nextAvail
ØØ! *
;
ØØ* +
if
∞∞ 
(
∞∞ 
	nextAvail
∞∞ 
>=
∞∞ 
$num
∞∞ 
)
∞∞ 
{
±± 
this
≤≤ 
.
≤≤ 
	nextAvail
≤≤ 
=
≤≤  
-
≤≤! "
$num
≤≤" #
;
≤≤# $
return
≥≥ 
	nextAvail
≥≥  
;
≥≥  !
}
¥¥ 
return
µµ 
this
µµ 
.
µµ 
FindNextAvail
µµ %
(
µµ% &
)
µµ& '
;
µµ' (
}
∂∂ 	
int
∏∏ 
FindNextAvail
∏∏ 
(
∏∏ 
)
∏∏ 
{
ππ 	
long
∫∫ 
[
∫∫ 
]
∫∫ 
bitmap
∫∫ 
=
∫∫ 
this
∫∫  
.
∫∫  !
bitmap
∫∫! '
;
∫∫' (
int
ªª 
bitmapLength
ªª 
=
ªª 
this
ªª #
.
ªª# $
bitmapLength
ªª$ 0
;
ªª0 1
for
ºº 
(
ºº 
int
ºº 
i
ºº 
=
ºº 
$num
ºº 
;
ºº 
i
ºº 
<
ºº 
bitmapLength
ºº  ,
;
ºº, -
i
ºº. /
++
ºº/ 1
)
ºº1 2
{
ΩΩ 
long
ææ 
bits
ææ 
=
ææ 
bitmap
ææ "
[
ææ" #
i
ææ# $
]
ææ$ %
;
ææ% &
if
øø 
(
øø 
~
øø 
bits
øø 
!=
øø 
$num
øø 
)
øø 
{
¿¿ 
return
¡¡ 
this
¡¡ 
.
¡¡  
FindNextAvail0
¡¡  .
(
¡¡. /
i
¡¡/ 0
,
¡¡0 1
bits
¡¡2 6
)
¡¡6 7
;
¡¡7 8
}
¬¬ 
}
√√ 
return
ƒƒ 
-
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
}
≈≈ 	
int
«« 
FindNextAvail0
«« 
(
«« 
int
«« 
i
««  
,
««  !
long
««" &
bits
««' +
)
««+ ,
{
»» 	
int
…… 
maxNumElems
…… 
=
…… 
this
…… "
.
……" #
maxNumElems
……# .
;
……. /
int
   
baseVal
   
=
   
i
   
<<
   
$num
    
;
    !
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
j
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
j
ÃÃ 
<
ÃÃ 
$num
ÃÃ  "
;
ÃÃ" #
j
ÃÃ$ %
++
ÃÃ% '
)
ÃÃ' (
{
ÕÕ 
if
ŒŒ 
(
ŒŒ 
(
ŒŒ 
bits
ŒŒ 
&
ŒŒ 
$num
ŒŒ 
)
ŒŒ 
==
ŒŒ !
$num
ŒŒ" #
)
ŒŒ# $
{
œœ 
int
–– 
val
–– 
=
–– 
baseVal
–– %
|
––& '
j
––( )
;
––) *
if
—— 
(
—— 
val
—— 
<
—— 
maxNumElems
—— )
)
——) *
{
““ 
return
”” 
val
”” "
;
””" #
}
‘‘ 
else
’’ 
{
÷÷ 
break
◊◊ 
;
◊◊ 
}
ÿÿ 
}
ŸŸ 
bits
⁄⁄ 
=
⁄⁄ 
bits
⁄⁄ 
.
⁄⁄ 
RightUShift
⁄⁄ '
(
⁄⁄' (
$num
⁄⁄( )
)
⁄⁄) *
;
⁄⁄* +
}
€€ 
return
‹‹ 
-
‹‹ 
$num
‹‹ 
;
‹‹ 
}
›› 	
long
ﬂﬂ 
ToHandle
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
	bitmapIdx
ﬂﬂ #
)
ﬂﬂ# $
=>
ﬂﬂ% '
$num
ﬂﬂ( ;
|
ﬂﬂ< =
(
ﬂﬂ> ?
long
ﬂﬂ? C
)
ﬂﬂC D
	bitmapIdx
ﬂﬂD M
<<
ﬂﬂN P
$num
ﬂﬂQ S
|
ﬂﬂT U
(
ﬂﬂV W
uint
ﬂﬂW [
)
ﬂﬂ[ \
this
ﬂﬂ\ `
.
ﬂﬂ` a
memoryMapIdx
ﬂﬂa m
;
ﬂﬂm n
public
·· 
override
·· 
string
·· 
ToString
·· '
(
··' (
)
··( )
{
‚‚ 	
bool
„„ 
doNotDestroy
„„ 
;
„„ 
int
‰‰ 
maxNumElems
‰‰ 
;
‰‰ 
int
ÂÂ 
numAvail
ÂÂ 
;
ÂÂ 
int
ÊÊ 
elemSize
ÊÊ 
;
ÊÊ 
lock
ÁÁ 
(
ÁÁ 
this
ÁÁ 
.
ÁÁ 
Chunk
ÁÁ 
.
ÁÁ 
Arena
ÁÁ "
)
ÁÁ" #
{
ËË 
if
ÈÈ 
(
ÈÈ 
!
ÈÈ 
this
ÈÈ 
.
ÈÈ 
DoNotDestroy
ÈÈ &
)
ÈÈ& '
{
ÍÍ 
doNotDestroy
ÎÎ  
=
ÎÎ! "
false
ÎÎ# (
;
ÎÎ( )
maxNumElems
ÌÌ 
=
ÌÌ  !
numAvail
ÌÌ" *
=
ÌÌ+ ,
elemSize
ÌÌ- 5
=
ÌÌ6 7
-
ÌÌ8 9
$num
ÌÌ9 :
;
ÌÌ: ;
}
ÓÓ 
else
ÔÔ 
{
 
doNotDestroy
ÒÒ  
=
ÒÒ! "
true
ÒÒ# '
;
ÒÒ' (
maxNumElems
ÚÚ 
=
ÚÚ  !
this
ÚÚ" &
.
ÚÚ& '
maxNumElems
ÚÚ' 2
;
ÚÚ2 3
numAvail
ÛÛ 
=
ÛÛ 
this
ÛÛ #
.
ÛÛ# $
numAvail
ÛÛ$ ,
;
ÛÛ, -
elemSize
ÙÙ 
=
ÙÙ 
this
ÙÙ #
.
ÙÙ# $
ElemSize
ÙÙ$ ,
;
ÙÙ, -
}
ıı 
}
ˆˆ 
if
¯¯ 
(
¯¯ 
!
¯¯ 
doNotDestroy
¯¯ 
)
¯¯ 
{
˘˘ 
return
˙˙ 
$str
˙˙ 
+
˙˙ 
this
˙˙ !
.
˙˙! "
memoryMapIdx
˙˙" .
+
˙˙/ 0
$str
˙˙1 @
;
˙˙@ A
}
˚˚ 
return
˝˝ 
$str
˝˝ 
+
˝˝ 
this
˝˝ 
.
˝˝ 
memoryMapIdx
˝˝ *
+
˝˝+ ,
$str
˝˝- 1
+
˝˝2 3
(
˝˝4 5
maxNumElems
˝˝5 @
-
˝˝A B
numAvail
˝˝C K
)
˝˝K L
+
˝˝M N
$str
˝˝O R
+
˝˝S T
maxNumElems
˝˝U `
+
˝˝a b
$str
˛˛ 
+
˛˛ 
this
˛˛ #
.
˛˛# $
	runOffset
˛˛$ -
+
˛˛. /
$str
˛˛0 <
+
˛˛= >
this
˛˛? C
.
˛˛C D
pageSize
˛˛D L
+
˛˛M N
$str
˛˛O ]
+
˛˛^ _
elemSize
˛˛` h
+
˛˛i j
$str
˛˛k n
;
˛˛n o
}
ˇˇ 	
public
ÅÅ 
int
ÅÅ 
MaxNumElements
ÅÅ !
{
ÇÇ 	
get
ÉÉ 
{
ÑÑ 
lock
ÖÖ 
(
ÖÖ 
this
ÖÖ 
.
ÖÖ 
Chunk
ÖÖ  
.
ÖÖ  !
Arena
ÖÖ! &
)
ÖÖ& '
{
ÜÜ 
return
áá 
this
áá 
.
áá  
maxNumElems
áá  +
;
áá+ ,
}
àà 
}
ââ 
}
ää 	
public
åå 
int
åå 
NumAvailable
åå 
{
çç 	
get
éé 
{
èè 
lock
êê 
(
êê 
this
êê 
.
êê 
Chunk
êê  
.
êê  !
Arena
êê! &
)
êê& '
{
ëë 
return
íí 
this
íí 
.
íí  
numAvail
íí  (
;
íí( )
}
ìì 
}
îî 
}
ïï 	
public
óó 
int
óó 
ElementSize
óó 
{
òò 	
get
ôô 
{
öö 
lock
õõ 
(
õõ 
this
õõ 
.
õõ 
Chunk
õõ  
.
õõ  !
Arena
õõ! &
)
õõ& '
{
úú 
return
ùù 
this
ùù 
.
ùù  
ElemSize
ùù  (
;
ùù( )
}
ûû 
}
üü 
}
†† 	
public
¢¢ 
int
¢¢ 
PageSize
¢¢ 
=>
¢¢ 
this
¢¢ #
.
¢¢# $
pageSize
¢¢$ ,
;
¢¢, -
internal
§§ 
void
§§ 
Destroy
§§ 
(
§§ 
)
§§ 
=>
§§  "
this
§§# '
.
§§' (
Chunk
§§( -
?
§§- .
.
§§. /
Destroy
§§/ 6
(
§§6 7
)
§§7 8
;
§§8 9
}
•• 
}¶¶ ® 
bC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\PoolThreadCache.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class 
PoolThreadCache  
<  !
T! "
>" #
{ 
static 
readonly 
IInternalLogger '
Logger( .
=/ 0!
InternalLoggerFactory1 F
.F G
GetInstanceG R
<R S
PoolThreadCacheS b
<b c
Tc d
>d e
>e f
(f g
)g h
;h i
internal 
readonly 
	PoolArena #
<# $
T$ %
>% &
	HeapArena' 0
;0 1
internal 
readonly 
	PoolArena #
<# $
T$ %
>% &
DirectArena' 2
;2 3
readonly"" 
MemoryRegionCache"" "
[""" #
]""# $!
tinySubPageHeapCaches""% :
;"": ;
readonly## 
MemoryRegionCache## "
[##" #
]### $"
smallSubPageHeapCaches##% ;
;##; <
readonly$$ 
MemoryRegionCache$$ "
[$$" #
]$$# $#
tinySubPageDirectCaches$$% <
;$$< =
readonly%% 
MemoryRegionCache%% "
[%%" #
]%%# $$
smallSubPageDirectCaches%%% =
;%%= >
readonly&& 
MemoryRegionCache&& "
[&&" #
]&&# $
normalHeapCaches&&% 5
;&&5 6
readonly'' 
MemoryRegionCache'' "
[''" #
]''# $
normalDirectCaches''% 7
;''7 8
readonly** 
int** !
numShiftsNormalDirect** *
;*** +
readonly++ 
int++ 
numShiftsNormalHeap++ (
;++( )
readonly,, 
int,, (
freeSweepAllocationThreshold,, 1
;,,1 2
int.. 
allocations.. 
;.. 
readonly00 
Thread00 
deathWatchThread00 (
;00( )
readonly11 
Action11 
freeTask11  
;11  !
internal66 
PoolThreadCache66  
(66  !
	PoolArena66! *
<66* +
T66+ ,
>66, -
	heapArena66. 7
,667 8
	PoolArena669 B
<66B C
T66C D
>66D E
directArena66F Q
,66Q R
int77 
tinyCacheSize77 
,77 
int77 "
smallCacheSize77# 1
,771 2
int773 6
normalCacheSize777 F
,77F G
int88 #
maxCachedBufferCapacity88 '
,88' (
int88) ,(
freeSweepAllocationThreshold88- I
)88I J
{99 	
Contract:: 
.:: 
Requires:: 
(:: #
maxCachedBufferCapacity:: 5
>=::6 8
$num::9 :
)::: ;
;::; <
Contract;; 
.;; 
Requires;; 
(;; (
freeSweepAllocationThreshold;; :
>;;; <
$num;;= >
);;> ?
;;;? @
this== 
.== (
freeSweepAllocationThreshold== -
===. /(
freeSweepAllocationThreshold==0 L
;==L M
this>> 
.>> 
	HeapArena>> 
=>> 
	heapArena>> &
;>>& '
this?? 
.?? 
DirectArena?? 
=?? 
directArena?? *
;??* +
if@@ 
(@@ 
directArena@@ 
!=@@ 
null@@ #
)@@# $
{AA 
thisBB 
.BB #
tinySubPageDirectCachesBB ,
=BB- .
CreateSubPageCachesBB/ B
(BBB C
tinyCacheSizeCC !
,CC! "
	PoolArenaCC# ,
<CC, -
TCC- .
>CC. /
.CC/ 0
NumTinySubpagePoolsCC0 C
,CCC D
	SizeClassCCE N
.CCN O
TinyCCO S
)CCS T
;CCT U
thisDD 
.DD $
smallSubPageDirectCachesDD -
=DD. /
CreateSubPageCachesDD0 C
(DDC D
smallCacheSizeEE "
,EE" #
directArenaEE$ /
.EE/ 0 
NumSmallSubpagePoolsEE0 D
,EED E
	SizeClassEEF O
.EEO P
SmallEEP U
)EEU V
;EEV W
thisGG 
.GG !
numShiftsNormalDirectGG *
=GG+ ,
Log2GG- 1
(GG1 2
directArenaGG2 =
.GG= >
PageSizeGG> F
)GGF G
;GGG H
thisHH 
.HH 
normalDirectCachesHH '
=HH( )
CreateNormalCachesHH* <
(HH< =
normalCacheSizeII #
,II# $#
maxCachedBufferCapacityII% <
,II< =
directArenaII> I
)III J
;IIJ K
directArenaKK 
.KK $
IncrementNumThreadCachesKK 4
(KK4 5
)KK5 6
;KK6 7
}LL 
elseMM 
{NN 
thisPP 
.PP #
tinySubPageDirectCachesPP ,
=PP- .
nullPP/ 3
;PP3 4
thisQQ 
.QQ $
smallSubPageDirectCachesQQ -
=QQ. /
nullQQ0 4
;QQ4 5
thisRR 
.RR 
normalDirectCachesRR '
=RR( )
nullRR* .
;RR. /
thisSS 
.SS !
numShiftsNormalDirectSS *
=SS+ ,
-SS- .
$numSS. /
;SS/ 0
}TT 
ifUU 
(UU 
	heapArenaUU 
!=UU 
nullUU !
)UU! "
{VV 
thisXX 
.XX !
tinySubPageHeapCachesXX *
=XX+ ,
CreateSubPageCachesXX- @
(XX@ A
tinyCacheSizeYY !
,YY! "
	PoolArenaYY# ,
<YY, -
TYY- .
>YY. /
.YY/ 0
NumTinySubpagePoolsYY0 C
,YYC D
	SizeClassYYE N
.YYN O
TinyYYO S
)YYS T
;YYT U
thisZZ 
.ZZ "
smallSubPageHeapCachesZZ +
=ZZ, -
CreateSubPageCachesZZ. A
(ZZA B
smallCacheSize[[ "
,[[" #
	heapArena[[$ -
.[[- . 
NumSmallSubpagePools[[. B
,[[B C
	SizeClass[[D M
.[[M N
Small[[N S
)[[S T
;[[T U
this]] 
.]] 
numShiftsNormalHeap]] (
=]]) *
Log2]]+ /
(]]/ 0
	heapArena]]0 9
.]]9 :
PageSize]]: B
)]]B C
;]]C D
this^^ 
.^^ 
normalHeapCaches^^ %
=^^& '
CreateNormalCaches^^( :
(^^: ;
normalCacheSize__ #
,__# $#
maxCachedBufferCapacity__% <
,__< =
	heapArena__> G
)__G H
;__H I
	heapArenaaa 
.aa $
IncrementNumThreadCachesaa 2
(aa2 3
)aa3 4
;aa4 5
}bb 
elsecc 
{dd 
thisff 
.ff !
tinySubPageHeapCachesff *
=ff+ ,
nullff- 1
;ff1 2
thisgg 
.gg "
smallSubPageHeapCachesgg +
=gg, -
nullgg. 2
;gg2 3
thishh 
.hh 
normalHeapCacheshh %
=hh& '
nullhh( ,
;hh, -
thisii 
.ii 
numShiftsNormalHeapii (
=ii) *
-ii+ ,
$numii, -
;ii- .
}jj 
ifmm 
(mm 
thismm 
.mm #
tinySubPageDirectCachesmm ,
!=mm- /
nullmm0 4
||mm5 7
thismm8 <
.mm< =$
smallSubPageDirectCachesmm= U
!=mmV X
nullmmY ]
||mm^ `
thismma e
.mme f
normalDirectCachesmmf x
!=mmy {
null	mm| Ä
||nn 
thisnn 
.nn !
tinySubPageHeapCachesnn -
!=nn. 0
nullnn1 5
||nn6 8
thisnn9 =
.nn= >"
smallSubPageHeapCachesnn> T
!=nnU W
nullnnX \
||nn] _
thisnn` d
.nnd e
normalHeapCachesnne u
!=nnv x
nullnny }
)nn} ~
{oo 
thispp 
.pp 
freeTaskpp 
=pp 
thispp  $
.pp$ %
Free0pp% *
;pp* +
thisqq 
.qq 
deathWatchThreadqq %
=qq& '
Threadqq( .
.qq. /
CurrentThreadqq/ <
;qq< =
ThreadDeathWatcheruu "
.uu" #
Watchuu# (
(uu( )
thisuu) -
.uu- .
deathWatchThreaduu. >
,uu> ?
thisuu@ D
.uuD E
freeTaskuuE M
)uuM N
;uuN O
}vv 
elseww 
{xx 
thisyy 
.yy 
freeTaskyy 
=yy 
nullyy  $
;yy$ %
thiszz 
.zz 
deathWatchThreadzz %
=zz& '
nullzz( ,
;zz, -
}{{ 
}|| 	
static~~ 
MemoryRegionCache~~  
[~~  !
]~~! "
CreateSubPageCaches~~# 6
(~~6 7
int 
	cacheSize 
, 
int 
	numCaches (
,( )
	SizeClass* 3
	sizeClass4 =
)= >
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
	cacheSize
ÅÅ 
>
ÅÅ 
$num
ÅÅ 
)
ÅÅ 
{
ÇÇ 
var
ÉÉ 
cache
ÉÉ 
=
ÉÉ 
new
ÉÉ 
MemoryRegionCache
ÉÉ  1
[
ÉÉ1 2
	numCaches
ÉÉ2 ;
]
ÉÉ; <
;
ÉÉ< =
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
i
ÑÑ  !
<
ÑÑ" #
cache
ÑÑ$ )
.
ÑÑ) *
Length
ÑÑ* 0
;
ÑÑ0 1
i
ÑÑ2 3
++
ÑÑ3 5
)
ÑÑ5 6
{
ÖÖ 
cache
áá 
[
áá 
i
áá 
]
áá 
=
áá 
new
áá "&
SubPageMemoryRegionCache
áá# ;
(
áá; <
	cacheSize
áá< E
,
ááE F
	sizeClass
ááG P
)
ááP Q
;
ááQ R
}
àà 
return
ââ 
cache
ââ 
;
ââ 
}
ää 
else
ãã 
{
åå 
return
çç 
null
çç 
;
çç 
}
éé 
}
èè 	
static
ëë 
MemoryRegionCache
ëë  
[
ëë  !
]
ëë! " 
CreateNormalCaches
ëë# 5
(
ëë5 6
int
íí 
	cacheSize
íí 
,
íí 
int
íí %
maxCachedBufferCapacity
íí 6
,
íí6 7
	PoolArena
íí8 A
<
ííA B
T
ííB C
>
ííC D
area
ííE I
)
ííI J
{
ìì 	
if
îî 
(
îî 
	cacheSize
îî 
>
îî 
$num
îî 
)
îî 
{
ïï 
int
ññ 
max
ññ 
=
ññ 
Math
ññ 
.
ññ 
Min
ññ "
(
ññ" #
area
ññ# '
.
ññ' (
	ChunkSize
ññ( 1
,
ññ1 2%
maxCachedBufferCapacity
ññ3 J
)
ññJ K
;
ññK L
int
óó 
	arraySize
óó 
=
óó 
Math
óó  $
.
óó$ %
Max
óó% (
(
óó( )
$num
óó) *
,
óó* +
Log2
óó, 0
(
óó0 1
max
óó1 4
/
óó5 6
area
óó7 ;
.
óó; <
PageSize
óó< D
)
óóD E
+
óóF G
$num
óóH I
)
óóI J
;
óóJ K
var
ôô 
cache
ôô 
=
ôô 
new
ôô 
MemoryRegionCache
ôô  1
[
ôô1 2
	arraySize
ôô2 ;
]
ôô; <
;
ôô< =
for
öö 
(
öö 
int
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö  !
<
öö" #
cache
öö$ )
.
öö) *
Length
öö* 0
;
öö0 1
i
öö2 3
++
öö3 5
)
öö5 6
{
õõ 
cache
úú 
[
úú 
i
úú 
]
úú 
=
úú 
new
úú "%
NormalMemoryRegionCache
úú# :
(
úú: ;
	cacheSize
úú; D
)
úúD E
;
úúE F
}
ùù 
return
ûû 
cache
ûû 
;
ûû 
}
üü 
else
†† 
{
°° 
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 
}
§§ 	
static
¶¶ 
int
¶¶ 
Log2
¶¶ 
(
¶¶ 
int
¶¶ 
val
¶¶ 
)
¶¶  
{
ßß 	
int
©© 
res
©© 
=
©© 
$num
©© 
;
©© 
while
™™ 
(
™™ 
val
™™ 
>
™™ 
$num
™™ 
)
™™ 
{
´´ 
val
¨¨ 
>>=
¨¨ 
$num
¨¨ 
;
¨¨ 
res
≠≠ 
++
≠≠ 
;
≠≠ 
}
ÆÆ 
return
ØØ 
res
ØØ 
;
ØØ 
}
∞∞ 	
internal
µµ 
bool
µµ 
AllocateTiny
µµ "
(
µµ" #
	PoolArena
µµ# ,
<
µµ, -
T
µµ- .
>
µµ. /
area
µµ0 4
,
µµ4 5
PooledByteBuffer
µµ6 F
<
µµF G
T
µµG H
>
µµH I
buf
µµJ M
,
µµM N
int
µµO R
reqCapacity
µµS ^
,
µµ^ _
int
µµ` c
normCapacity
µµd p
)
µµp q
=>
µµr t
this
∂∂ 
.
∂∂ 
Allocate
∂∂ 
(
∂∂ 
this
∂∂ 
.
∂∂ 
CacheForTiny
∂∂ +
(
∂∂+ ,
area
∂∂, 0
,
∂∂0 1
normCapacity
∂∂2 >
)
∂∂> ?
,
∂∂? @
buf
∂∂A D
,
∂∂D E
reqCapacity
∂∂F Q
)
∂∂Q R
;
∂∂R S
internal
ªª 
bool
ªª 
AllocateSmall
ªª #
(
ªª# $
	PoolArena
ªª$ -
<
ªª- .
T
ªª. /
>
ªª/ 0
area
ªª1 5
,
ªª5 6
PooledByteBuffer
ªª7 G
<
ªªG H
T
ªªH I
>
ªªI J
buf
ªªK N
,
ªªN O
int
ªªP S
reqCapacity
ªªT _
,
ªª_ `
int
ªªa d
normCapacity
ªªe q
)
ªªq r
=>
ªªs u
this
ºº 
.
ºº 
Allocate
ºº 
(
ºº 
this
ºº 
.
ºº 
CacheForSmall
ºº ,
(
ºº, -
area
ºº- 1
,
ºº1 2
normCapacity
ºº3 ?
)
ºº? @
,
ºº@ A
buf
ººB E
,
ººE F
reqCapacity
ººG R
)
ººR S
;
ººS T
internal
¡¡ 
bool
¡¡ 
AllocateNormal
¡¡ $
(
¡¡$ %
	PoolArena
¡¡% .
<
¡¡. /
T
¡¡/ 0
>
¡¡0 1
area
¡¡2 6
,
¡¡6 7
PooledByteBuffer
¡¡8 H
<
¡¡H I
T
¡¡I J
>
¡¡J K
buf
¡¡L O
,
¡¡O P
int
¡¡Q T
reqCapacity
¡¡U `
,
¡¡` a
int
¡¡b e
normCapacity
¡¡f r
)
¡¡r s
=>
¡¡t v
this
¬¬ 
.
¬¬ 
Allocate
¬¬ 
(
¬¬ 
this
¬¬ 
.
¬¬ 
CacheForNormal
¬¬ -
(
¬¬- .
area
¬¬. 2
,
¬¬2 3
normCapacity
¬¬4 @
)
¬¬@ A
,
¬¬A B
buf
¬¬C F
,
¬¬F G
reqCapacity
¬¬H S
)
¬¬S T
;
¬¬T U
bool
ƒƒ 
Allocate
ƒƒ 
(
ƒƒ 
MemoryRegionCache
ƒƒ '
cache
ƒƒ( -
,
ƒƒ- .
PooledByteBuffer
ƒƒ/ ?
<
ƒƒ? @
T
ƒƒ@ A
>
ƒƒA B
buf
ƒƒC F
,
ƒƒF G
int
ƒƒH K
reqCapacity
ƒƒL W
)
ƒƒW X
{
≈≈ 	
if
∆∆ 
(
∆∆ 
cache
∆∆ 
==
∆∆ 
null
∆∆ 
)
∆∆ 
{
«« 
return
…… 
false
…… 
;
…… 
}
   
bool
ÀÀ 
	allocated
ÀÀ 
=
ÀÀ 
cache
ÀÀ "
.
ÀÀ" #
Allocate
ÀÀ# +
(
ÀÀ+ ,
buf
ÀÀ, /
,
ÀÀ/ 0
reqCapacity
ÀÀ1 <
)
ÀÀ< =
;
ÀÀ= >
if
ÃÃ 
(
ÃÃ 
++
ÃÃ 
this
ÃÃ 
.
ÃÃ 
allocations
ÃÃ "
>=
ÃÃ# %
this
ÃÃ& *
.
ÃÃ* +*
freeSweepAllocationThreshold
ÃÃ+ G
)
ÃÃG H
{
ÕÕ 
this
ŒŒ 
.
ŒŒ 
allocations
ŒŒ  
=
ŒŒ! "
$num
ŒŒ# $
;
ŒŒ$ %
this
œœ 
.
œœ 
Trim
œœ 
(
œœ 
)
œœ 
;
œœ 
}
–– 
return
—— 
	allocated
—— 
;
—— 
}
““ 	
internal
ÿÿ 
bool
ÿÿ 
Add
ÿÿ 
(
ÿÿ 
	PoolArena
ÿÿ #
<
ÿÿ# $
T
ÿÿ$ %
>
ÿÿ% &
area
ÿÿ' +
,
ÿÿ+ ,
	PoolChunk
ÿÿ- 6
<
ÿÿ6 7
T
ÿÿ7 8
>
ÿÿ8 9
chunk
ÿÿ: ?
,
ÿÿ? @
long
ÿÿA E
handle
ÿÿF L
,
ÿÿL M
int
ÿÿN Q
normCapacity
ÿÿR ^
,
ÿÿ^ _
	SizeClass
ÿÿ` i
	sizeClass
ÿÿj s
)
ÿÿs t
{
ŸŸ 	
MemoryRegionCache
⁄⁄ 
cache
⁄⁄ #
=
⁄⁄$ %
this
⁄⁄& *
.
⁄⁄* +
Cache
⁄⁄+ 0
(
⁄⁄0 1
area
⁄⁄1 5
,
⁄⁄5 6
normCapacity
⁄⁄7 C
,
⁄⁄C D
	sizeClass
⁄⁄E N
)
⁄⁄N O
;
⁄⁄O P
if
€€ 
(
€€ 
cache
€€ 
==
€€ 
null
€€ 
)
€€ 
{
‹‹ 
return
›› 
false
›› 
;
›› 
}
ﬁﬁ 
return
ﬂﬂ 
cache
ﬂﬂ 
.
ﬂﬂ 
Add
ﬂﬂ 
(
ﬂﬂ 
chunk
ﬂﬂ "
,
ﬂﬂ" #
handle
ﬂﬂ$ *
)
ﬂﬂ* +
;
ﬂﬂ+ ,
}
‡‡ 	
MemoryRegionCache
‚‚ 
Cache
‚‚ 
(
‚‚  
	PoolArena
‚‚  )
<
‚‚) *
T
‚‚* +
>
‚‚+ ,
area
‚‚- 1
,
‚‚1 2
int
‚‚3 6
normCapacity
‚‚7 C
,
‚‚C D
	SizeClass
‚‚E N
	sizeClass
‚‚O X
)
‚‚X Y
{
„„ 	
switch
‰‰ 
(
‰‰ 
	sizeClass
‰‰ 
)
‰‰ 
{
ÂÂ 
case
ÊÊ 
	SizeClass
ÊÊ 
.
ÊÊ 
Normal
ÊÊ %
:
ÊÊ% &
return
ÁÁ 
this
ÁÁ 
.
ÁÁ  
CacheForNormal
ÁÁ  .
(
ÁÁ. /
area
ÁÁ/ 3
,
ÁÁ3 4
normCapacity
ÁÁ5 A
)
ÁÁA B
;
ÁÁB C
case
ËË 
	SizeClass
ËË 
.
ËË 
Small
ËË $
:
ËË$ %
return
ÈÈ 
this
ÈÈ 
.
ÈÈ  
CacheForSmall
ÈÈ  -
(
ÈÈ- .
area
ÈÈ. 2
,
ÈÈ2 3
normCapacity
ÈÈ4 @
)
ÈÈ@ A
;
ÈÈA B
case
ÍÍ 
	SizeClass
ÍÍ 
.
ÍÍ 
Tiny
ÍÍ #
:
ÍÍ# $
return
ÎÎ 
this
ÎÎ 
.
ÎÎ  
CacheForTiny
ÎÎ  ,
(
ÎÎ, -
area
ÎÎ- 1
,
ÎÎ1 2
normCapacity
ÎÎ3 ?
)
ÎÎ? @
;
ÎÎ@ A
default
ÏÏ 
:
ÏÏ 
throw
ÌÌ 
new
ÌÌ )
ArgumentOutOfRangeException
ÌÌ 9
(
ÌÌ9 :
)
ÌÌ: ;
;
ÌÌ; <
}
ÓÓ 
}
ÔÔ 	
internal
ÙÙ 
void
ÙÙ 
Free
ÙÙ 
(
ÙÙ 
)
ÙÙ 
{
ıı 	
if
ˆˆ 
(
ˆˆ 
this
ˆˆ 
.
ˆˆ 
freeTask
ˆˆ 
!=
ˆˆ  
null
ˆˆ! %
)
ˆˆ% &
{
˜˜ 
Debug
¯¯ 
.
¯¯ 
Assert
¯¯ 
(
¯¯ 
this
¯¯ !
.
¯¯! "
deathWatchThread
¯¯" 2
!=
¯¯3 5
null
¯¯6 :
)
¯¯: ;
;
¯¯; < 
ThreadDeathWatcher
˘˘ "
.
˘˘" #
Unwatch
˘˘# *
(
˘˘* +
this
˘˘+ /
.
˘˘/ 0
deathWatchThread
˘˘0 @
,
˘˘@ A
this
˘˘B F
.
˘˘F G
freeTask
˘˘G O
)
˘˘O P
;
˘˘P Q
}
˙˙ 
this
¸¸ 
.
¸¸ 
Free0
¸¸ 
(
¸¸ 
)
¸¸ 
;
¸¸ 
}
˝˝ 	
void
ˇˇ 
Free0
ˇˇ 
(
ˇˇ 
)
ˇˇ 
{
ÄÄ 	
int
ÅÅ 
numFreed
ÅÅ 
=
ÅÅ 
Free
ÅÅ 
(
ÅÅ  
this
ÅÅ  $
.
ÅÅ$ %%
tinySubPageDirectCaches
ÅÅ% <
)
ÅÅ< =
+
ÅÅ> ?
Free
ÇÇ 
(
ÇÇ 
this
ÇÇ 
.
ÇÇ &
smallSubPageDirectCaches
ÇÇ 2
)
ÇÇ2 3
+
ÇÇ4 5
Free
ÉÉ 
(
ÉÉ 
this
ÉÉ 
.
ÉÉ  
normalDirectCaches
ÉÉ ,
)
ÉÉ, -
+
ÉÉ. /
Free
ÑÑ 
(
ÑÑ 
this
ÑÑ 
.
ÑÑ #
tinySubPageHeapCaches
ÑÑ /
)
ÑÑ/ 0
+
ÑÑ1 2
Free
ÖÖ 
(
ÖÖ 
this
ÖÖ 
.
ÖÖ $
smallSubPageHeapCaches
ÖÖ 0
)
ÖÖ0 1
+
ÖÖ2 3
Free
ÜÜ 
(
ÜÜ 
this
ÜÜ 
.
ÜÜ 
normalHeapCaches
ÜÜ *
)
ÜÜ* +
;
ÜÜ+ ,
if
àà 
(
àà 
numFreed
àà 
>
àà 
$num
àà 
&&
àà 
Logger
àà  &
.
àà& '
DebugEnabled
àà' 3
)
àà3 4
{
ââ 
Logger
ää 
.
ää 
Debug
ää 
(
ää 
$str
ää N
,
ääN O
numFreed
ääP X
,
ääX Y
this
ääZ ^
.
ää^ _
deathWatchThread
ää_ o
.
ääo p
Name
ääp t
)
äät u
;
ääu v
}
ãã 
this
çç 
.
çç 
DirectArena
çç 
?
çç 
.
çç &
DecrementNumThreadCaches
çç 6
(
çç6 7
)
çç7 8
;
çç8 9
this
éé 
.
éé 
	HeapArena
éé 
?
éé 
.
éé &
DecrementNumThreadCaches
éé 4
(
éé4 5
)
éé5 6
;
éé6 7
}
èè 	
static
ëë 
int
ëë 
Free
ëë 
(
ëë 
MemoryRegionCache
ëë )
[
ëë) *
]
ëë* +
caches
ëë, 2
)
ëë2 3
{
íí 	
if
ìì 
(
ìì 
caches
ìì 
==
ìì 
null
ìì 
)
ìì 
{
îî 
return
ïï 
$num
ïï 
;
ïï 
}
ññ 
int
òò 
numFreed
òò 
=
òò 
$num
òò 
;
òò 
foreach
ôô 
(
ôô 
MemoryRegionCache
ôô &
c
ôô' (
in
ôô) +
caches
ôô, 2
)
ôô2 3
{
öö 
numFreed
õõ 
+=
õõ 
Free
õõ  
(
õõ  !
c
õõ! "
)
õõ" #
;
õõ# $
}
úú 
return
ùù 
numFreed
ùù 
;
ùù 
}
ûû 	
static
†† 
int
†† 
Free
†† 
(
†† 
MemoryRegionCache
†† )
cache
††* /
)
††/ 0
{
°° 	
if
¢¢ 
(
¢¢ 
cache
¢¢ 
==
¢¢ 
null
¢¢ 
)
¢¢ 
{
££ 
return
§§ 
$num
§§ 
;
§§ 
}
•• 
return
¶¶ 
cache
¶¶ 
.
¶¶ 
Free
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶  
}
ßß 	
internal
©© 
void
©© 
Trim
©© 
(
©© 
)
©© 
{
™™ 	
Trim
´´ 
(
´´ 
this
´´ 
.
´´ %
tinySubPageDirectCaches
´´ -
)
´´- .
;
´´. /
Trim
¨¨ 
(
¨¨ 
this
¨¨ 
.
¨¨ &
smallSubPageDirectCaches
¨¨ .
)
¨¨. /
;
¨¨/ 0
Trim
≠≠ 
(
≠≠ 
this
≠≠ 
.
≠≠  
normalDirectCaches
≠≠ (
)
≠≠( )
;
≠≠) *
Trim
ÆÆ 
(
ÆÆ 
this
ÆÆ 
.
ÆÆ #
tinySubPageHeapCaches
ÆÆ +
)
ÆÆ+ ,
;
ÆÆ, -
Trim
ØØ 
(
ØØ 
this
ØØ 
.
ØØ $
smallSubPageHeapCaches
ØØ ,
)
ØØ, -
;
ØØ- .
Trim
∞∞ 
(
∞∞ 
this
∞∞ 
.
∞∞ 
normalHeapCaches
∞∞ &
)
∞∞& '
;
∞∞' (
}
±± 	
static
≥≥ 
void
≥≥ 
Trim
≥≥ 
(
≥≥ 
MemoryRegionCache
≥≥ *
[
≥≥* +
]
≥≥+ ,
caches
≥≥- 3
)
≥≥3 4
{
¥¥ 	
if
µµ 
(
µµ 
caches
µµ 
==
µµ 
null
µµ 
)
µµ 
{
∂∂ 
return
∑∑ 
;
∑∑ 
}
∏∏ 
foreach
ππ 
(
ππ 
MemoryRegionCache
ππ &
c
ππ' (
in
ππ) +
caches
ππ, 2
)
ππ2 3
{
∫∫ 
Trim
ªª 
(
ªª 
c
ªª 
)
ªª 
;
ªª 
}
ºº 
}
ΩΩ 	
static
øø 
void
øø 
Trim
øø 
(
øø 
MemoryRegionCache
øø *
cache
øø+ 0
)
øø0 1
=>
øø2 4
cache
øø5 :
?
øø: ;
.
øø; <
Trim
øø< @
(
øø@ A
)
øøA B
;
øøB C
MemoryRegionCache
¡¡ 
CacheForTiny
¡¡ &
(
¡¡& '
	PoolArena
¡¡' 0
<
¡¡0 1
T
¡¡1 2
>
¡¡2 3
area
¡¡4 8
,
¡¡8 9
int
¡¡: =
normCapacity
¡¡> J
)
¡¡J K
{
¬¬ 	
int
√√ 
idx
√√ 
=
√√ 
	PoolArena
√√ 
<
√√  
T
√√  !
>
√√! "
.
√√" #
TinyIdx
√√# *
(
√√* +
normCapacity
√√+ 7
)
√√7 8
;
√√8 9
return
ƒƒ 
Cache
ƒƒ 
(
ƒƒ 
area
ƒƒ 
.
ƒƒ 
IsDirect
ƒƒ &
?
ƒƒ' (
this
ƒƒ) -
.
ƒƒ- .%
tinySubPageDirectCaches
ƒƒ. E
:
ƒƒF G
this
ƒƒH L
.
ƒƒL M#
tinySubPageHeapCaches
ƒƒM b
,
ƒƒb c
idx
ƒƒd g
)
ƒƒg h
;
ƒƒh i
}
≈≈ 	
MemoryRegionCache
«« 
CacheForSmall
«« '
(
««' (
	PoolArena
««( 1
<
««1 2
T
««2 3
>
««3 4
area
««5 9
,
««9 :
int
««; >
normCapacity
««? K
)
««K L
{
»» 	
int
…… 
idx
…… 
=
…… 
	PoolArena
…… 
<
……  
T
……  !
>
……! "
.
……" #
SmallIdx
……# +
(
……+ ,
normCapacity
……, 8
)
……8 9
;
……9 :
return
   
Cache
   
(
   
area
   
.
   
IsDirect
   &
?
  ' (
this
  ) -
.
  - .&
smallSubPageDirectCaches
  . F
:
  G H
this
  I M
.
  M N$
smallSubPageHeapCaches
  N d
,
  d e
idx
  f i
)
  i j
;
  j k
}
ÀÀ 	
MemoryRegionCache
ÕÕ 
CacheForNormal
ÕÕ (
(
ÕÕ( )
	PoolArena
ÕÕ) 2
<
ÕÕ2 3
T
ÕÕ3 4
>
ÕÕ4 5
area
ÕÕ6 :
,
ÕÕ: ;
int
ÕÕ< ?
normCapacity
ÕÕ@ L
)
ÕÕL M
{
ŒŒ 	
if
œœ 
(
œœ 
area
œœ 
.
œœ 
IsDirect
œœ 
)
œœ 
{
–– 
int
—— 
idx
—— 
=
—— 
Log2
—— 
(
—— 
normCapacity
—— +
>>
——, .
this
——/ 3
.
——3 4#
numShiftsNormalDirect
——4 I
)
——I J
;
——J K
return
““ 
Cache
““ 
(
““ 
this
““ !
.
““! " 
normalDirectCaches
““" 4
,
““4 5
idx
““6 9
)
““9 :
;
““: ;
}
”” 
int
‘‘ 
idx1
‘‘ 
=
‘‘ 
Log2
‘‘ 
(
‘‘ 
normCapacity
‘‘ (
>>
‘‘) +
this
‘‘, 0
.
‘‘0 1!
numShiftsNormalHeap
‘‘1 D
)
‘‘D E
;
‘‘E F
return
’’ 
Cache
’’ 
(
’’ 
this
’’ 
.
’’ 
normalHeapCaches
’’ .
,
’’. /
idx1
’’0 4
)
’’4 5
;
’’5 6
}
÷÷ 	
static
ÿÿ 
MemoryRegionCache
ÿÿ  
Cache
ÿÿ! &
(
ÿÿ& '
MemoryRegionCache
ÿÿ' 8
[
ÿÿ8 9
]
ÿÿ9 :
cache
ÿÿ; @
,
ÿÿ@ A
int
ÿÿB E
idx
ÿÿF I
)
ÿÿI J
{
ŸŸ 	
if
⁄⁄ 
(
⁄⁄ 
cache
⁄⁄ 
==
⁄⁄ 
null
⁄⁄ 
||
⁄⁄  
idx
⁄⁄! $
>
⁄⁄% &
cache
⁄⁄' ,
.
⁄⁄, -
Length
⁄⁄- 3
-
⁄⁄4 5
$num
⁄⁄6 7
)
⁄⁄7 8
{
€€ 
return
‹‹ 
null
‹‹ 
;
‹‹ 
}
›› 
return
ﬁﬁ 
cache
ﬁﬁ 
[
ﬁﬁ 
idx
ﬁﬁ 
]
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
sealed
‰‰ 
class
‰‰ &
SubPageMemoryRegionCache
‰‰ -
:
‰‰. /
MemoryRegionCache
‰‰0 A
{
ÂÂ 	
internal
ÊÊ &
SubPageMemoryRegionCache
ÊÊ -
(
ÊÊ- .
int
ÊÊ. 1
size
ÊÊ2 6
,
ÊÊ6 7
	SizeClass
ÊÊ8 A
	sizeClass
ÊÊB K
)
ÊÊK L
:
ÁÁ 
base
ÁÁ 
(
ÁÁ 
size
ÁÁ 
,
ÁÁ 
	sizeClass
ÁÁ &
)
ÁÁ& '
{
ËË 
}
ÈÈ 
	protected
ÎÎ 
override
ÎÎ 
void
ÎÎ #
InitBuf
ÎÎ$ +
(
ÎÎ+ ,
	PoolChunk
ÏÏ 
<
ÏÏ 
T
ÏÏ 
>
ÏÏ 
chunk
ÏÏ "
,
ÏÏ" #
long
ÏÏ$ (
handle
ÏÏ) /
,
ÏÏ/ 0
PooledByteBuffer
ÏÏ1 A
<
ÏÏA B
T
ÏÏB C
>
ÏÏC D
buf
ÏÏE H
,
ÏÏH I
int
ÏÏJ M
reqCapacity
ÏÏN Y
)
ÏÏY Z
=>
ÏÏ[ ]
chunk
ÌÌ 
.
ÌÌ  
InitBufWithSubpage
ÌÌ (
(
ÌÌ( )
buf
ÌÌ) ,
,
ÌÌ, -
handle
ÌÌ. 4
,
ÌÌ4 5
reqCapacity
ÌÌ6 A
)
ÌÌA B
;
ÌÌB C
}
ÓÓ 	
sealed
ÛÛ 
class
ÛÛ %
NormalMemoryRegionCache
ÛÛ ,
:
ÛÛ- .
MemoryRegionCache
ÛÛ/ @
{
ÙÙ 	
internal
ıı %
NormalMemoryRegionCache
ıı ,
(
ıı, -
int
ıı- 0
size
ıı1 5
)
ıı5 6
:
ˆˆ 
base
ˆˆ 
(
ˆˆ 
size
ˆˆ 
,
ˆˆ 
	SizeClass
ˆˆ &
.
ˆˆ& '
Normal
ˆˆ' -
)
ˆˆ- .
{
˜˜ 
}
¯¯ 
	protected
˙˙ 
override
˙˙ 
void
˙˙ #
InitBuf
˙˙$ +
(
˙˙+ ,
	PoolChunk
˚˚ 
<
˚˚ 
T
˚˚ 
>
˚˚ 
chunk
˚˚ "
,
˚˚" #
long
˚˚$ (
handle
˚˚) /
,
˚˚/ 0
PooledByteBuffer
˚˚1 A
<
˚˚A B
T
˚˚B C
>
˚˚C D
buf
˚˚E H
,
˚˚H I
int
˚˚J M
reqCapacity
˚˚N Y
)
˚˚Y Z
=>
˚˚[ ]
chunk
¸¸ 
.
¸¸ 
InitBuf
¸¸ 
(
¸¸ 
buf
¸¸ !
,
¸¸! "
handle
¸¸# )
,
¸¸) *
reqCapacity
¸¸+ 6
)
¸¸6 7
;
¸¸7 8
}
˝˝ 	
abstract
ˇˇ 
class
ˇˇ 
MemoryRegionCache
ˇˇ (
{
ÄÄ 	
readonly
ÅÅ 
int
ÅÅ 
size
ÅÅ 
;
ÅÅ 
readonly
ÇÇ 
IQueue
ÇÇ 
<
ÇÇ 
Entry
ÇÇ !
>
ÇÇ! "
queue
ÇÇ# (
;
ÇÇ( )
readonly
ÉÉ 
	SizeClass
ÉÉ 
	sizeClass
ÉÉ (
;
ÉÉ( )
int
ÑÑ 
allocations
ÑÑ 
;
ÑÑ 
	protected
ÜÜ 
MemoryRegionCache
ÜÜ '
(
ÜÜ' (
int
ÜÜ( +
size
ÜÜ, 0
,
ÜÜ0 1
	SizeClass
ÜÜ2 ;
	sizeClass
ÜÜ< E
)
ÜÜE F
{
áá 
this
àà 
.
àà 
size
àà 
=
àà 
MathUtil
àà $
.
àà$ %,
SafeFindNextPositivePowerOfTwo
àà% C
(
ààC D
size
ààD H
)
ààH I
;
ààI J
this
ââ 
.
ââ 
queue
ââ 
=
ââ 
PlatformDependent
ââ .
.
ââ. /
NewFixedMpscQueue
ââ/ @
<
ââ@ A
Entry
ââA F
>
ââF G
(
ââG H
this
ââH L
.
ââL M
size
ââM Q
)
ââQ R
;
ââR S
this
ää 
.
ää 
	sizeClass
ää 
=
ää  
	sizeClass
ää! *
;
ää* +
}
ãã 
	protected
êê 
abstract
êê 
void
êê #
InitBuf
êê$ +
(
êê+ ,
	PoolChunk
êê, 5
<
êê5 6
T
êê6 7
>
êê7 8
chunk
êê9 >
,
êê> ?
long
êê@ D
handle
êêE K
,
êêK L
PooledByteBuffer
ëë  
<
ëë  !
T
ëë! "
>
ëë" #
buf
ëë$ '
,
ëë' (
int
ëë) ,
reqCapacity
ëë- 8
)
ëë8 9
;
ëë9 :
public
ññ 
bool
ññ 
Add
ññ 
(
ññ 
	PoolChunk
ññ %
<
ññ% &
T
ññ& '
>
ññ' (
chunk
ññ) .
,
ññ. /
long
ññ0 4
handle
ññ5 ;
)
ññ; <
{
óó 
Entry
òò 
entry
òò 
=
òò 
NewEntry
òò &
(
òò& '
chunk
òò' ,
,
òò, -
handle
òò. 4
)
òò4 5
;
òò5 6
bool
ôô 
queued
ôô 
=
ôô 
this
ôô "
.
ôô" #
queue
ôô# (
.
ôô( )

TryEnqueue
ôô) 3
(
ôô3 4
entry
ôô4 9
)
ôô9 :
;
ôô: ;
if
öö 
(
öö 
!
öö 
queued
öö 
)
öö 
{
õõ 
entry
ùù 
.
ùù 
Recycle
ùù !
(
ùù! "
)
ùù" #
;
ùù# $
}
ûû 
return
†† 
queued
†† 
;
†† 
}
°° 
public
¶¶ 
bool
¶¶ 
Allocate
¶¶  
(
¶¶  !
PooledByteBuffer
¶¶! 1
<
¶¶1 2
T
¶¶2 3
>
¶¶3 4
buf
¶¶5 8
,
¶¶8 9
int
¶¶: =
reqCapacity
¶¶> I
)
¶¶I J
{
ßß 
if
®® 
(
®® 
!
®® 
this
®® 
.
®® 
queue
®® 
.
®®  

TryDequeue
®®  *
(
®®* +
out
®®+ .
Entry
®®/ 4
entry
®®5 :
)
®®: ;
)
®®; <
{
©© 
return
™™ 
false
™™  
;
™™  !
}
´´ 
this
¨¨ 
.
¨¨ 
InitBuf
¨¨ 
(
¨¨ 
entry
¨¨ "
.
¨¨" #
Chunk
¨¨# (
,
¨¨( )
entry
¨¨* /
.
¨¨/ 0
Handle
¨¨0 6
,
¨¨6 7
buf
¨¨8 ;
,
¨¨; <
reqCapacity
¨¨= H
)
¨¨H I
;
¨¨I J
entry
≠≠ 
.
≠≠ 
Recycle
≠≠ 
(
≠≠ 
)
≠≠ 
;
≠≠  
++
∞∞ 
this
∞∞ 
.
∞∞ 
allocations
∞∞ "
;
∞∞" #
return
±± 
true
±± 
;
±± 
}
≤≤ 
public
∑∑ 
int
∑∑ 
Free
∑∑ 
(
∑∑ 
)
∑∑ 
=>
∑∑  
this
∑∑! %
.
∑∑% &
Free
∑∑& *
(
∑∑* +
int
∑∑+ .
.
∑∑. /
MaxValue
∑∑/ 7
)
∑∑7 8
;
∑∑8 9
int
ππ 
Free
ππ 
(
ππ 
int
ππ 
max
ππ 
)
ππ 
{
∫∫ 
int
ªª 
numFreed
ªª 
=
ªª 
$num
ªª  
;
ªª  !
for
ºº 
(
ºº 
;
ºº 
numFreed
ºº 
<
ºº  !
max
ºº" %
;
ºº% &
numFreed
ºº' /
++
ºº/ 1
)
ºº1 2
{
ΩΩ 
if
ææ 
(
ææ 
this
ææ 
.
ææ 
queue
ææ "
.
ææ" #

TryDequeue
ææ# -
(
ææ- .
out
ææ. 1
Entry
ææ2 7
entry
ææ8 =
)
ææ= >
)
ææ> ?
{
øø 
this
¿¿ 
.
¿¿ 
	FreeEntry
¿¿ &
(
¿¿& '
entry
¿¿' ,
)
¿¿, -
;
¿¿- .
}
¡¡ 
else
¬¬ 
{
√√ 
return
≈≈ 
numFreed
≈≈ '
;
≈≈' (
}
∆∆ 
}
«« 
return
»» 
numFreed
»» 
;
»»  
}
…… 
public
ŒŒ 
void
ŒŒ 
Trim
ŒŒ 
(
ŒŒ 
)
ŒŒ 
{
œœ 
int
–– 
toFree
–– 
=
–– 
this
–– !
.
––! "
size
––" &
-
––' (
this
––) -
.
––- .
allocations
––. 9
;
––9 :
this
—— 
.
—— 
allocations
——  
=
——! "
$num
——# $
;
——$ %
if
‘‘ 
(
‘‘ 
toFree
‘‘ 
>
‘‘ 
$num
‘‘ 
)
‘‘ 
{
’’ 
this
÷÷ 
.
÷÷ 
Free
÷÷ 
(
÷÷ 
toFree
÷÷ $
)
÷÷$ %
;
÷÷% &
}
◊◊ 
}
ÿÿ 
void
⁄⁄ 
	FreeEntry
⁄⁄ 
(
⁄⁄ 
Entry
⁄⁄  
entry
⁄⁄! &
)
⁄⁄& '
{
€€ 
	PoolChunk
‹‹ 
<
‹‹ 
T
‹‹ 
>
‹‹ 
chunk
‹‹ "
=
‹‹# $
entry
‹‹% *
.
‹‹* +
Chunk
‹‹+ 0
;
‹‹0 1
long
›› 
handle
›› 
=
›› 
entry
›› #
.
››# $
Handle
››$ *
;
››* +
entry
‡‡ 
.
‡‡ 
Recycle
‡‡ 
(
‡‡ 
)
‡‡ 
;
‡‡  
chunk
‚‚ 
.
‚‚ 
Arena
‚‚ 
.
‚‚ 
	FreeChunk
‚‚ %
(
‚‚% &
chunk
‚‚& +
,
‚‚+ ,
handle
‚‚- 3
,
‚‚3 4
this
‚‚5 9
.
‚‚9 :
	sizeClass
‚‚: C
)
‚‚C D
;
‚‚D E
}
„„ 
sealed
ÂÂ 
class
ÂÂ 
Entry
ÂÂ 
{
ÊÊ 
readonly
ÁÁ 
ThreadLocalPool
ÁÁ (
.
ÁÁ( )
Handle
ÁÁ) /
recyclerHandle
ÁÁ0 >
;
ÁÁ> ?
public
ËË 
	PoolChunk
ËË  
<
ËË  !
T
ËË! "
>
ËË" #
Chunk
ËË$ )
;
ËË) *
public
ÈÈ 
long
ÈÈ 
Handle
ÈÈ "
=
ÈÈ# $
-
ÈÈ% &
$num
ÈÈ& '
;
ÈÈ' (
public
ÎÎ 
Entry
ÎÎ 
(
ÎÎ 
ThreadLocalPool
ÎÎ ,
.
ÎÎ, -
Handle
ÎÎ- 3
recyclerHandle
ÎÎ4 B
)
ÎÎB C
{
ÏÏ 
this
ÌÌ 
.
ÌÌ 
recyclerHandle
ÌÌ '
=
ÌÌ( )
recyclerHandle
ÌÌ* 8
;
ÌÌ8 9
}
ÓÓ 
internal
 
void
 
Recycle
 %
(
% &
)
& '
{
ÒÒ 
this
ÚÚ 
.
ÚÚ 
Chunk
ÚÚ 
=
ÚÚ  
null
ÚÚ! %
;
ÚÚ% &
this
ÛÛ 
.
ÛÛ 
Handle
ÛÛ 
=
ÛÛ  !
-
ÛÛ" #
$num
ÛÛ# $
;
ÛÛ$ %
this
ÙÙ 
.
ÙÙ 
recyclerHandle
ÙÙ '
.
ÙÙ' (
Release
ÙÙ( /
(
ÙÙ/ 0
this
ÙÙ0 4
)
ÙÙ4 5
;
ÙÙ5 6
}
ıı 
}
ˆˆ 
static
¯¯ 
Entry
¯¯ 
NewEntry
¯¯ !
(
¯¯! "
	PoolChunk
¯¯" +
<
¯¯+ ,
T
¯¯, -
>
¯¯- .
chunk
¯¯/ 4
,
¯¯4 5
long
¯¯6 :
handle
¯¯; A
)
¯¯A B
{
˘˘ 
Entry
˙˙ 
entry
˙˙ 
=
˙˙ 
Recycler
˙˙ &
.
˙˙& '
Take
˙˙' +
(
˙˙+ ,
)
˙˙, -
;
˙˙- .
entry
˚˚ 
.
˚˚ 
Chunk
˚˚ 
=
˚˚ 
chunk
˚˚ #
;
˚˚# $
entry
¸¸ 
.
¸¸ 
Handle
¸¸ 
=
¸¸ 
handle
¸¸ %
;
¸¸% &
return
˝˝ 
entry
˝˝ 
;
˝˝ 
}
˛˛ 
static
ÄÄ 
readonly
ÄÄ 
ThreadLocalPool
ÄÄ +
<
ÄÄ+ ,
Entry
ÄÄ, 1
>
ÄÄ1 2
Recycler
ÄÄ3 ;
=
ÄÄ< =
new
ÄÄ> A
ThreadLocalPool
ÄÄB Q
<
ÄÄQ R
Entry
ÄÄR W
>
ÄÄW X
(
ÄÄX Y
handle
ÄÄY _
=>
ÄÄ` b
new
ÄÄc f
Entry
ÄÄg l
(
ÄÄl m
handle
ÄÄm s
)
ÄÄs t
)
ÄÄt u
;
ÄÄu v
}
ÅÅ 	
}
ÇÇ 
}ÉÉ ≥
jC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 
$
NeutralResourcesLanguage #
(# $
$str$ +
)+ ,
], -
[ 
assembly 	
:	 

AssemblyMetadata 
( 
$str )
,) *
$str+ 1
)1 2
]2 3ì
eC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Properties\Friends.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str	 Ç
)
Ç É
]
É Ñ
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str	 ˇ
)
ˇ Ä
]
Ä Å´3
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ReadOnlyByteBufferStream.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class $
ReadOnlyByteBufferStream 0
:1 2
Stream3 9
{ 
readonly 
IByteBuffer 
buffer #
;# $
bool %
releaseReferenceOnClosure &
;& '
public $
ReadOnlyByteBufferStream '
(' (
IByteBuffer( 3
buffer4 :
,: ;
bool< @%
releaseReferenceOnClosureA Z
)Z [
{ 	
Contract 
. 
Requires 
( 
buffer $
!=% '
null( ,
), -
;- .
this 
. 
buffer 
= 
buffer  
;  !
this 
. %
releaseReferenceOnClosure *
=+ ,%
releaseReferenceOnClosure- F
;F G
} 	
public 
override 
bool 
CanRead $
=>% '
true( ,
;, -
public 
override 
bool 
CanSeek $
=>% '
true( ,
;, -
public 
override 
bool 
CanWrite %
=>& (
false) .
;. /
public 
override 
long 
Length #
=>$ &
this' +
.+ ,
buffer, 2
.2 3
WriterIndex3 >
;> ?
public   
override   
long   
Position   %
{!! 	
get"" 
=>"" 
this"" 
."" 
buffer"" 
."" 
ReaderIndex"" *
;""* +
set## 
=>## 
this## 
.## 
buffer## 
.## 
SetReaderIndex## -
(##- .
(##. /
int##/ 2
)##2 3
value##3 8
)##8 9
;##9 :
}$$ 	
public&& 
override&& 
int&& 
Read&&  
(&&  !
byte&&! %
[&&% &
]&&& '
output&&( .
,&&. /
int&&0 3
offset&&4 :
,&&: ;
int&&< ?
count&&@ E
)&&E F
{'' 	
if(( 
((( 
offset(( 
+(( 
count(( 
>((  
output((! '
.((' (
Length((( .
)((. /
{)) 
throw** 
new** 
ArgumentException** +
(**+ ,
$"**, .
$str**. 9
{**9 :
nameof**: @
(**@ A
offset**A G
)**G H
}**H I
$str**I N
{**N O
nameof**O U
(**U V
count**V [
)**[ \
}**\ ]
$str**] q
{**q r
nameof**r x
(**x y
output**y 
)	** Ä
}
**Ä Å
$str
**Å à
"
**à â
)
**â ä
;
**ä ã
}++ 
int-- 
read-- 
=-- 
Math-- 
.-- 
Min-- 
(--  
count--  %
,--% &
this--' +
.--+ ,
buffer--, 2
.--2 3
ReadableBytes--3 @
)--@ A
;--A B
this.. 
... 
buffer.. 
... 
	ReadBytes.. !
(..! "
output.." (
,..( )
offset..* 0
,..0 1
read..2 6
)..6 7
;..7 8
return// 
read// 
;// 
}00 	
public22 
override22 
void22 
Flush22 "
(22" #
)22# $
{33 	
}44 	
	protected66 
override66 
void66 
Dispose66  '
(66' (
bool66( ,
	disposing66- 6
)666 7
{77 	
if88 
(88 
this88 
.88 %
releaseReferenceOnClosure88 .
)88. /
{99 
this:: 
.:: %
releaseReferenceOnClosure:: .
=::/ 0
false::1 6
;::6 7
if;; 
(;; 
	disposing;; 
);; 
{<< 
this== 
.== 
buffer== 
.==  
Release==  '
(==' (
)==( )
;==) *
}>> 
else?? 
{@@ 
thisAA 
.AA 
bufferAA 
.AA  
SafeReleaseAA  +
(AA+ ,
)AA, -
;AA- .
}BB 
}CC 
}DD 	
publicFF 
overrideFF 
longFF 
SeekFF !
(FF! "
longFF" &
offsetFF' -
,FF- .

SeekOriginFF/ 9
originFF: @
)FF@ A
{GG 	
ifHH 
(HH 
originHH 
==HH 

SeekOriginHH $
.HH$ %
CurrentHH% ,
)HH, -
{II 
offsetJJ 
+=JJ 
thisJJ 
.JJ 
PositionJJ '
;JJ' (
}KK 
elseLL 
ifLL 
(LL 
originLL 
==LL 

SeekOriginLL )
.LL) *
EndLL* -
)LL- .
{MM 
offsetNN 
+=NN 
thisNN 
.NN 
LengthNN %
;NN% &
}OO 
thisQQ 
.QQ 
PositionQQ 
=QQ 
offsetQQ "
;QQ" #
returnRR 
thisRR 
.RR 
PositionRR  
;RR  !
}SS 	
publicUU 
overrideUU 
voidUU 
	SetLengthUU &
(UU& '
longUU' +
valueUU, 1
)UU1 2
{VV 	
throwWW 
newWW !
NotSupportedExceptionWW +
(WW+ ,
)WW, -
;WW- .
}XX 	
publicZZ 
overrideZZ 
voidZZ 
WriteZZ "
(ZZ" #
byteZZ# '
[ZZ' (
]ZZ( )
inputZZ* /
,ZZ/ 0
intZZ1 4
offsetZZ5 ;
,ZZ; <
intZZ= @
countZZA F
)ZZF G
{[[ 	
throw\\ 
new\\ !
NotSupportedException\\ +
(\\+ ,
)\\, -
;\\- .
}]] 	
}^^ 
}__ ßK
lC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\SimpleLeakAwareByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class

 	%
SimpleLeakAwareByteBuffer


 #
:

$ %
WrappedByteBuffer

& 7
{ 
	protected 
readonly  
IResourceLeakTracker /
Leak0 4
;4 5
readonly 
IByteBuffer 
trackedByteBuf +
;+ ,
internal %
SimpleLeakAwareByteBuffer *
(* +
IByteBuffer+ 6
wrapped7 >
,> ?
IByteBuffer@ K
trackedByteBufL Z
,Z [ 
IResourceLeakTracker\ p
leakq u
)u v
: 
base 
( 
wrapped 
) 
{ 	
Contract 
. 
Requires 
( 
trackedByteBuf ,
!=- /
null0 4
)4 5
;5 6
Contract 
. 
Requires 
( 
leak "
!=# %
null& *
)* +
;+ ,
this 
. 
trackedByteBuf 
=  !
trackedByteBuf" 0
;0 1
this 
. 
Leak 
= 
leak 
; 
} 	
internal %
SimpleLeakAwareByteBuffer *
(* +
IByteBuffer+ 6
wrapped7 >
,> ? 
IResourceLeakTracker@ T
leakU Y
)Y Z
: 
this 
( 
wrapped 
, 
wrapped #
,# $
leak% )
)) *
{ 	
} 	
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
=>, .
this/ 3
.3 4(
NewSharedLeakAwareByteBuffer4 P
(P Q
baseQ U
.U V
SliceV [
([ \
)\ ]
)] ^
;^ _
public   
override   
IByteBuffer   #
RetainedSlice  $ 1
(  1 2
)  2 3
=>  4 6
this  7 ;
.  ; <
UnwrappedDerived  < L
(  L M
base  M Q
.  Q R
RetainedSlice  R _
(  _ `
)  ` a
)  a b
;  b c
public"" 
override"" 
IByteBuffer"" #
RetainedSlice""$ 1
(""1 2
int""2 5
index""6 ;
,""; <
int""= @
length""A G
)""G H
=>""I K
this""L P
.""P Q
UnwrappedDerived""Q a
(""a b
base""b f
.""f g
RetainedSlice""g t
(""t u
index""u z
,""z {
length	""| Ç
)
""Ç É
)
""É Ñ
;
""Ñ Ö
public$$ 
override$$ 
IByteBuffer$$ #
RetainedDuplicate$$$ 5
($$5 6
)$$6 7
=>$$8 :
this$$; ?
.$$? @
UnwrappedDerived$$@ P
($$P Q
base$$Q U
.$$U V
RetainedDuplicate$$V g
($$g h
)$$h i
)$$i j
;$$j k
public&& 
override&& 
IByteBuffer&& #
ReadRetainedSlice&&$ 5
(&&5 6
int&&6 9
length&&: @
)&&@ A
=>&&B D
this&&E I
.&&I J
UnwrappedDerived&&J Z
(&&Z [
base&&[ _
.&&_ `
ReadRetainedSlice&&` q
(&&q r
length&&r x
)&&x y
)&&y z
;&&z {
public(( 
override(( 
IByteBuffer(( #
Slice(($ )
((() *
int((* -
index((. 3
,((3 4
int((5 8
length((9 ?
)((? @
=>((A C
this((D H
.((H I(
NewSharedLeakAwareByteBuffer((I e
(((e f
base((f j
.((j k
Slice((k p
(((p q
index((q v
,((v w
length((x ~
)((~ 
)	(( Ä
;
((Ä Å
public** 
override** 
IByteBuffer** #
	Duplicate**$ -
(**- .
)**. /
=>**0 2
this**3 7
.**7 8(
NewSharedLeakAwareByteBuffer**8 T
(**T U
base**U Y
.**Y Z
	Duplicate**Z c
(**c d
)**d e
)**e f
;**f g
public,, 
override,, 
IByteBuffer,, #
	ReadSlice,,$ -
(,,- .
int,,. 1
length,,2 8
),,8 9
=>,,: <
this,,= A
.,,A B(
NewSharedLeakAwareByteBuffer,,B ^
(,,^ _
base,,_ c
.,,c d
	ReadSlice,,d m
(,,m n
length,,n t
),,t u
),,u v
;,,v w
public.. 
override.. 
IReferenceCounted.. )
Touch..* /
(../ 0
)..0 1
=>..2 4
this..5 9
;..9 :
public00 
override00 
IReferenceCounted00 )
Touch00* /
(00/ 0
object000 6
hint007 ;
)00; <
=>00= ?
this00@ D
;00D E
public22 
override22 
bool22 
Release22 $
(22$ %
)22% &
{33 	
if44 
(44 
base44 
.44 
Release44 
(44 
)44 
)44 
{55 
this66 
.66 
	CloseLeak66 
(66 
)66  
;66  !
return77 
true77 
;77 
}88 
return:: 
false:: 
;:: 
};; 	
public== 
override== 
bool== 
Release== $
(==$ %
int==% (
	decrement==) 2
)==2 3
{>> 	
if?? 
(?? 
base?? 
.?? 
Release?? 
(?? 
	decrement?? &
)??& '
)??' (
{@@ 
thisAA 
.AA 
	CloseLeakAA 
(AA 
)AA  
;AA  !
returnBB 
trueBB 
;BB 
}CC 
returnDD 
falseDD 
;DD 
}EE 	
voidGG 
	CloseLeakGG 
(GG 
)GG 
{HH 	
boolKK 
closedKK 
=KK 
thisKK 
.KK 
LeakKK #
.KK# $
CloseKK$ )
(KK) *
thisKK* .
.KK. /
trackedByteBufKK/ =
)KK= >
;KK> ?
DebugLL 
.LL 
AssertLL 
(LL 
closedLL 
)LL  
;LL  !
}MM 	
IByteBufferOO 
UnwrappedDerivedOO $
(OO$ %
IByteBufferOO% 0
derivedOO1 8
)OO8 9
{PP 	
ifQQ 
(QQ 
derivedQQ 
isQQ +
AbstractPooledDerivedByteBufferQQ :
bufferQQ; A
)QQA B
{QQC D
bufferSS 
.SS 
ParentSS 
(SS 
thisSS "
)SS" #
;SS# $ 
IResourceLeakTrackerUU $
newLeakUU% ,
=UU- .
AbstractByteBufferUU/ A
.UUA B
LeakDetectorUUB N
.UUN O
TrackUUO T
(UUT U
bufferUUU [
)UU[ \
;UU\ ]
ifVV 
(VV 
newLeakVV 
==VV 
nullVV #
)VV# $
{WW 
returnYY 
derivedYY "
;YY" #
}ZZ 
return\\ 
this\\ 
.\\ "
NewLeakAwareByteBuffer\\ 2
(\\2 3
buffer\\3 9
,\\9 :
newLeak\\; B
)\\B C
;\\C D
}]] 
return__ 
this__ 
.__ (
NewSharedLeakAwareByteBuffer__ 4
(__4 5
derived__5 <
)__< =
;__= >
}`` 	%
SimpleLeakAwareByteBufferbb !(
NewSharedLeakAwareByteBufferbb" >
(bb> ?
IByteBufferbb? J
wrappedbbK R
)bbR S
=>bbT V
thisbbW [
.bb[ \"
NewLeakAwareByteBufferbb\ r
(bbr s
wrappedbbs z
,bbz {
this	bb| Ä
.
bbÄ Å
trackedByteBuf
bbÅ è
,
bbè ê
this
bbë ï
.
bbï ñ
Leak
bbñ ö
)
bbö õ
;
bbõ ú%
SimpleLeakAwareByteBufferdd !"
NewLeakAwareByteBufferdd" 8
(dd8 9
IByteBufferdd9 D
wrappedddE L
,ddL M 
IResourceLeakTrackerddN b
leakTrackerddc n
)ddn o
=>ddp r
thisdds w
.ddw x#
NewLeakAwareByteBuffer	ddx é
(
ddé è
wrapped
ddè ñ
,
ddñ ó
wrapped
ddò ü
,
ddü †
leakTracker
dd° ¨
)
dd¨ ≠
;
dd≠ Æ
	protectedff 
virtualff %
SimpleLeakAwareByteBufferff 3"
NewLeakAwareByteBufferff4 J
(ffJ K
IByteBufferffK V
bufffW Z
,ffZ [
IByteBufferff\ g

trackedBufffh r
,ffr s!
IResourceLeakTracker	fft à
leakTracker
ffâ î
)
ffî ï
=>
ffñ ò
newgg %
SimpleLeakAwareByteBuffergg )
(gg) *
bufgg* -
,gg- .

trackedBufgg/ 9
,gg9 :
leakTrackergg; F
)ggF G
;ggG H
}hh 
}ii ó8
uC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\SimpleLeakAwareCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class

 	.
"SimpleLeakAwareCompositeByteBuffer


 ,
:

- .&
WrappedCompositeByteBuffer

/ I
{ 
	protected 
readonly  
IResourceLeakTracker /
Leak0 4
;4 5
internal .
"SimpleLeakAwareCompositeByteBuffer 3
(3 4
CompositeByteBuffer4 G
wrappedH O
,O P 
IResourceLeakTrackerQ e
leakf j
)j k
:l m
basen r
(r s
wrappeds z
)z {
{ 	
Contract 
. 
Requires 
( 
leak "
!=# %
null& *
)* +
;+ ,
this 
. 
Leak 
= 
leak 
; 
} 	
public 
override 
bool 
Release $
($ %
)% &
{ 	
IByteBuffer 
	unwrapped !
=" #
this$ (
.( )
Unwrap) /
(/ 0
)0 1
;1 2
if 
( 
base 
. 
Release 
( 
) 
) 
{ 
this 
. 
	CloseLeak 
( 
	unwrapped (
)( )
;) *
return 
true 
; 
} 
return 
false 
; 
}   	
public"" 
override"" 
bool"" 
Release"" $
(""$ %
int""% (
	decrement"") 2
)""2 3
{## 	
IByteBuffer&& 
	unwrapped&& !
=&&" #
this&&$ (
.&&( )
Unwrap&&) /
(&&/ 0
)&&0 1
;&&1 2
if'' 
('' 
base'' 
.'' 
Release'' 
('' 
	decrement'' &
)''& '
)''' (
{(( 
this)) 
.)) 
	CloseLeak)) 
()) 
	unwrapped)) (
)))( )
;))) *
return** 
true** 
;** 
}++ 
return-- 
false-- 
;-- 
}.. 	
void00 
	CloseLeak00 
(00 
IByteBuffer00 "
trackedByteBuf00# 1
)001 2
{11 	
bool44 
closed44 
=44 
this44 
.44 
Leak44 #
.44# $
Close44$ )
(44) *
trackedByteBuf44* 8
)448 9
;449 :
Debug55 
.55 
Assert55 
(55 
closed55 
)55  
;55  !
}66 	
public88 
override88 
IByteBuffer88 #
Slice88$ )
(88) *
)88* +
=>88, .
this88/ 3
.883 4"
NewLeakAwareByteBuffer884 J
(88J K
base88K O
.88O P
Slice88P U
(88U V
)88V W
)88W X
;88X Y
public:: 
override:: 
IByteBuffer:: #
Slice::$ )
(::) *
int::* -
index::. 3
,::3 4
int::5 8
length::9 ?
)::? @
=>::A C
this::D H
.::H I"
NewLeakAwareByteBuffer::I _
(::_ `
base::` d
.::d e
Slice::e j
(::j k
index::k p
,::p q
length::r x
)::x y
)::y z
;::z {
public<< 
override<< 
IByteBuffer<< #
	Duplicate<<$ -
(<<- .
)<<. /
=><<0 2
this<<3 7
.<<7 8"
NewLeakAwareByteBuffer<<8 N
(<<N O
base<<O S
.<<S T
	Duplicate<<T ]
(<<] ^
)<<^ _
)<<_ `
;<<` a
public>> 
override>> 
IByteBuffer>> #
	ReadSlice>>$ -
(>>- .
int>>. 1
length>>2 8
)>>8 9
=>>>: <
this>>= A
.>>A B"
NewLeakAwareByteBuffer>>B X
(>>X Y
base>>Y ]
.>>] ^
	ReadSlice>>^ g
(>>g h
length>>h n
)>>n o
)>>o p
;>>p q
public@@ 
override@@ 
IByteBuffer@@ #
RetainedSlice@@$ 1
(@@1 2
)@@2 3
=>@@4 6
this@@7 ;
.@@; <"
NewLeakAwareByteBuffer@@< R
(@@R S
base@@S W
.@@W X
RetainedSlice@@X e
(@@e f
)@@f g
)@@g h
;@@h i
publicBB 
overrideBB 
IByteBufferBB #
RetainedSliceBB$ 1
(BB1 2
intBB2 5
indexBB6 ;
,BB; <
intBB= @
lengthBBA G
)BBG H
=>BBI K
thisBBL P
.BBP Q"
NewLeakAwareByteBufferBBQ g
(BBg h
baseBBh l
.BBl m
RetainedSliceBBm z
(BBz {
index	BB{ Ä
,
BBÄ Å
length
BBÇ à
)
BBà â
)
BBâ ä
;
BBä ã
publicDD 
overrideDD 
IByteBufferDD #
RetainedDuplicateDD$ 5
(DD5 6
)DD6 7
=>DD8 :
thisDD; ?
.DD? @"
NewLeakAwareByteBufferDD@ V
(DDV W
baseDDW [
.DD[ \
RetainedDuplicateDD\ m
(DDm n
)DDn o
)DDo p
;DDp q
publicFF 
overrideFF 
IByteBufferFF #
ReadRetainedSliceFF$ 5
(FF5 6
intFF6 9
lengthFF: @
)FF@ A
=>FFB D
thisFFE I
.FFI J"
NewLeakAwareByteBufferFFJ `
(FF` a
baseFFa e
.FFe f
ReadRetainedSliceFFf w
(FFw x
lengthFFx ~
)FF~ 
)	FF Ä
;
FFÄ Å%
SimpleLeakAwareByteBufferHH !"
NewLeakAwareByteBufferHH" 8
(HH8 9
IByteBufferHH9 D
wrappedHHE L
)HHL M
=>HHN P
thisHHQ U
.HHU V"
NewLeakAwareByteBufferHHV l
(HHl m
wrappedHHm t
,HHt u
thisHHv z
.HHz {
Unwrap	HH{ Å
(
HHÅ Ç
)
HHÇ É
,
HHÉ Ñ
this
HHÖ â
.
HHâ ä
Leak
HHä é
)
HHé è
;
HHè ê
	protectedJJ 
virtualJJ %
SimpleLeakAwareByteBufferJJ 3"
NewLeakAwareByteBufferJJ4 J
(JJJ K
IByteBufferJJK V
wrappedJJW ^
,JJ^ _
IByteBufferJJ` k
trackedByteBufJJl z
,JJz {!
IResourceLeakTracker	JJ| ê
leakTracker
JJë ú
)
JJú ù
=>
JJû †
newKK %
SimpleLeakAwareByteBufferKK )
(KK) *
wrappedKK* 1
,KK1 2
trackedByteBufKK3 A
,KKA B
leakTrackerKKC N
)KKN O
;KKO P
}LL 
}MM ∆∑
^C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\ThrowHelper.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

class 
ThrowHelper 
{ 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &

NoInlining& 0
)0 1
]1 2
internal 
static 
void /
#ThrowIndexOutOfRangeException_Index @
(@ A
intA D
indexE J
,J K
intL O
lengthP V
,V W
intX [
capacity\ d
)d e
{ 	
throw '
GetIndexOutOfRangeException -
(- .
). /
;/ 0$
IndexOutOfRangeException $'
GetIndexOutOfRangeException% @
(@ A
)A B
{ 
return 
new $
IndexOutOfRangeException 3
(3 4
string4 :
.: ;
Format; A
(A B
$strB u
,u v
indexw |
,| }
length	~ Ñ
,
Ñ Ö
capacity
Ü é
)
é è
)
è ê
;
ê ë
} 
} 	
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &

NoInlining& 0
)0 1
]1 2
internal 
static 
void 2
&ThrowIndexOutOfRangeException_SrcIndex C
(C D
intD G
srcIndexH P
)P Q
{ 	
throw '
GetIndexOutOfRangeException -
(- .
). /
;/ 0$
IndexOutOfRangeException $'
GetIndexOutOfRangeException% @
(@ A
)A B
{   
return!! 
new!! $
IndexOutOfRangeException!! 3
(!!3 4
string!!4 :
.!!: ;
Format!!; A
(!!A B
$str!!B Q
,!!Q R
srcIndex!!S [
)!![ \
)!!\ ]
;!!] ^
}"" 
}## 	
[%% 	

MethodImpl%%	 
(%% 
MethodImplOptions%% %
.%%% &

NoInlining%%& 0
)%%0 1
]%%1 2
internal&& 
static&& 
void&& 2
&ThrowIndexOutOfRangeException_SrcIndex&& C
(&&C D
int&&D G
srcIndex&&H P
,&&P Q
int&&R U
length&&V \
,&&\ ]
int&&^ a
srcCapacity&&b m
)&&m n
{'' 	
throw(( '
GetIndexOutOfRangeException(( -
(((- .
)((. /
;((/ 0$
IndexOutOfRangeException** $'
GetIndexOutOfRangeException**% @
(**@ A
)**A B
{++ 
return,, 
new,, $
IndexOutOfRangeException,, 3
(,,3 4
string,,4 :
.,,: ;
Format,,; A
(,,A B
$str,,B x
,,,x y
srcIndex	,,z Ç
,
,,Ç É
length
,,Ñ ä
,
,,ä ã
srcCapacity
,,å ó
)
,,ó ò
)
,,ò ô
;
,,ô ö
}-- 
}.. 	
[00 	

MethodImpl00	 
(00 
MethodImplOptions00 %
.00% &

NoInlining00& 0
)000 1
]001 2
internal11 
static11 
void11 2
&ThrowIndexOutOfRangeException_DstIndex11 C
(11C D
int11D G
dstIndex11H P
)11P Q
{22 	
throw33 '
GetIndexOutOfRangeException33 -
(33- .
)33. /
;33/ 0$
IndexOutOfRangeException55 $'
GetIndexOutOfRangeException55% @
(55@ A
)55A B
{66 
return77 
new77 $
IndexOutOfRangeException77 3
(773 4
string774 :
.77: ;
Format77; A
(77A B
$str77B Q
,77Q R
dstIndex77S [
)77[ \
)77\ ]
;77] ^
}88 
}99 	
[;; 	

MethodImpl;;	 
(;; 
MethodImplOptions;; %
.;;% &

NoInlining;;& 0
);;0 1
];;1 2
internal<< 
static<< 
void<< 2
&ThrowIndexOutOfRangeException_DstIndex<< C
(<<C D
int<<D G
dstIndex<<H P
,<<P Q
int<<R U
length<<V \
,<<\ ]
int<<_ b
dstCapacity<<c n
)<<n o
{== 	
throw>> '
GetIndexOutOfRangeException>> -
(>>- .
)>>. /
;>>/ 0$
IndexOutOfRangeException@@ $'
GetIndexOutOfRangeException@@% @
(@@@ A
)@@A B
{AA 
returnBB 
newBB $
IndexOutOfRangeExceptionBB 3
(BB3 4
stringBB4 :
.BB: ;
FormatBB; A
(BBA B
$strBBB x
,BBx y
dstIndex	BBz Ç
,
BBÇ É
length
BBÑ ä
,
BBä ã
dstCapacity
BBå ó
)
BBó ò
)
BBò ô
;
BBô ö
}CC 
}DD 	
[FF 	

MethodImplFF	 
(FF 
MethodImplOptionsFF %
.FF% &

NoInliningFF& 0
)FF0 1
]FF1 2
internalGG 
staticGG 
voidGG 5
)ThrowIndexOutOfRangeException_ReaderIndexGG F
(GGF G
intGGG J
indexGGK P
,GGP Q
intGGR U
writerIndexGGV a
)GGa b
{HH 	
throwII '
GetIndexOutOfRangeExceptionII -
(II- .
)II. /
;II/ 0$
IndexOutOfRangeExceptionKK $'
GetIndexOutOfRangeExceptionKK% @
(KK@ A
)KKA B
{LL 
returnMM 
newMM $
IndexOutOfRangeExceptionMM 3
(MM3 4
stringMM4 :
.MM: ;
FormatMM; A
(MMA B
$str	MMB Ñ
,
MMÑ Ö
index
MMÜ ã
,
MMã å
writerIndex
MMç ò
)
MMò ô
)
MMô ö
;
MMö õ
}NN 
}OO 	
[QQ 	

MethodImplQQ	 
(QQ 
MethodImplOptionsQQ %
.QQ% &

NoInliningQQ& 0
)QQ0 1
]QQ1 2
internalRR 
staticRR 
voidRR 5
)ThrowIndexOutOfRangeException_ReaderIndexRR F
(RRF G
intRRG J 
minimumReadableBytesRRK _
,RR_ `
intRRa d
readerIndexRRe p
,RRp q
intRRr u
writerIndex	RRv Å
,
RRÅ Ç 
AbstractByteBuffer
RRÉ ï
buf
RRñ ô
)
RRô ö
{SS 	
throwTT '
GetIndexOutOfRangeExceptionTT -
(TT- .
)TT. /
;TT/ 0$
IndexOutOfRangeExceptionVV $'
GetIndexOutOfRangeExceptionVV% @
(VV@ A
)VVA B
{WW 
returnXX 
newXX $
IndexOutOfRangeExceptionXX 3
(XX3 4
stringXX4 :
.XX: ;
FormatXX; A
(XXA B
$str	XXB Ä
,
XXÄ Å
readerIndex
XXÇ ç
,
XXç é"
minimumReadableBytes
XXè £
,
XX£ §
writerIndex
XX• ∞
,
XX∞ ±
buf
XX≤ µ
)
XXµ ∂
)
XX∂ ∑
;
XX∑ ∏
}YY 
}ZZ 	
[\\ 	

MethodImpl\\	 
(\\ 
MethodImplOptions\\ %
.\\% &

NoInlining\\& 0
)\\0 1
]\\1 2
internal]] 
static]] 
void]] 5
)ThrowIndexOutOfRangeException_WriterIndex]] F
(]]F G
int]]G J
index]]K P
,]]P Q
int]]R U
readerIndex]]V a
,]]a b
int]]c f
capacity]]g o
)]]o p
{^^ 	
throw__ '
GetIndexOutOfRangeException__ -
(__- .
)__. /
;__/ 0$
IndexOutOfRangeExceptionaa $'
GetIndexOutOfRangeExceptionaa% @
(aa@ A
)aaA B
{bb 
returncc 
newcc $
IndexOutOfRangeExceptioncc 3
(cc3 4
stringcc4 :
.cc: ;
Formatcc; A
(ccA B
$str	ccB ñ
,
ccñ ó
index
ccò ù
,
ccù û
readerIndex
ccü ™
,
cc™ ´
capacity
cc¨ ¥
)
cc¥ µ
)
ccµ ∂
;
cc∂ ∑
}dd 
}ee 	
[gg 	

MethodImplgg	 
(gg 
MethodImplOptionsgg %
.gg% &

NoInlininggg& 0
)gg0 1
]gg1 2
internalhh 
statichh 
voidhh 5
)ThrowIndexOutOfRangeException_WriterIndexhh F
(hhF G
inthhG J
minWritableByteshhK [
,hh[ \
inthh] `
writerIndexhha l
,hhl m
inthhn q
maxCapacityhhr }
,hh} ~
AbstractByteBuffer	hh ë
buf
hhí ï
)
hhï ñ
{ii 	
throwjj '
GetIndexOutOfRangeExceptionjj -
(jj- .
)jj. /
;jj/ 0$
IndexOutOfRangeExceptionll $'
GetIndexOutOfRangeExceptionll% @
(ll@ A
)llA B
{mm 
returnnn 
newnn $
IndexOutOfRangeExceptionnn 3
(nn3 4
stringnn4 :
.nn: ;
Formatnn; A
(nnA B
$"nnB D
$strnnD P
{nnP Q
$numnnQ R
}nnR S
$strnnS h
{nnh i
$numnni j
}nnj k
$str	nnk Å
{
nnÅ Ç
$num
nnÇ É
}
nnÉ Ñ
$str
nnÑ á
{
nná à
$num
nnà â
}
nnâ ä
"
nnä ã
,
nnã å
writerIndex
nnç ò
,
nnò ô
minWritableBytes
nnö ™
,
nn™ ´
maxCapacity
nn¨ ∑
,
nn∑ ∏
buf
nnπ º
)
nnº Ω
)
nnΩ æ
;
nnæ ø
}oo 
}pp 	
[rr 	

MethodImplrr	 
(rr 
MethodImplOptionsrr %
.rr% &

NoInliningrr& 0
)rr0 1
]rr1 2
internalss 
staticss 
voidss ;
/ThrowIndexOutOfRangeException_ReaderWriterIndexss L
(ssL M
intssM P
readerIndexssQ \
,ss\ ]
intss^ a
writerIndexssb m
,ssm n
intsso r
capacitysss {
)ss{ |
{tt 	
throwuu '
GetIndexOutOfRangeExceptionuu -
(uu- .
)uu. /
;uu/ 0$
IndexOutOfRangeExceptionww $'
GetIndexOutOfRangeExceptionww% @
(ww@ A
)wwA B
{xx 
returnyy 
newyy $
IndexOutOfRangeExceptionyy 3
(yy3 4
stringyy4 :
.yy: ;
Formatyy; A
(yyA B
$str	yyB £
,
yy£ §
readerIndex
yy• ∞
,
yy∞ ±
writerIndex
yy≤ Ω
,
yyΩ æ
capacity
yyø «
)
yy« »
)
yy» …
;
yy…  
}zz 
}{{ 	
[}} 	

MethodImpl}}	 
(}} 
MethodImplOptions}} %
.}}% &

NoInlining}}& 0
)}}0 1
]}}1 2
internal~~ 
static~~ 
void~~ 7
+ThrowIndexOutOfRangeException_ReadableBytes~~ H
(~~H I
int~~I L
length~~M S
,~~S T
IByteBuffer~~U `
src~~a d
)~~d e
{ 	
throw
ÄÄ )
GetIndexOutOfRangeException
ÄÄ -
(
ÄÄ- .
)
ÄÄ. /
;
ÄÄ/ 0&
IndexOutOfRangeException
ÇÇ $)
GetIndexOutOfRangeException
ÇÇ% @
(
ÇÇ@ A
)
ÇÇA B
{
ÉÉ 
return
ÑÑ 
new
ÑÑ &
IndexOutOfRangeException
ÑÑ 3
(
ÑÑ3 4
string
ÑÑ4 :
.
ÑÑ: ;
Format
ÑÑ; A
(
ÑÑA B
$strÑÑB Ä
,ÑÑÄ Å
lengthÑÑÇ à
,ÑÑà â
srcÑÑä ç
.ÑÑç é
ReadableBytesÑÑé õ
,ÑÑõ ú
srcÑÑù †
)ÑÑ† °
)ÑÑ° ¢
;ÑÑ¢ £
}
ÖÖ 
}
ÜÜ 	
[
àà 	

MethodImpl
àà	 
(
àà 
MethodImplOptions
àà %
.
àà% &

NoInlining
àà& 0
)
àà0 1
]
àà1 2
internal
ââ 
static
ââ 
void
ââ 9
+ThrowIndexOutOfRangeException_WritableBytes
ââ H
(
ââH I
int
ââI L
length
ââM S
,
ââS T
IByteBuffer
ââU `
dst
ââa d
)
ââd e
{
ää 	
throw
ãã )
GetIndexOutOfRangeException
ãã -
(
ãã- .
)
ãã. /
;
ãã/ 0&
IndexOutOfRangeException
çç $)
GetIndexOutOfRangeException
çç% @
(
çç@ A
)
ççA B
{
éé 
return
èè 
new
èè &
IndexOutOfRangeException
èè 3
(
èè3 4
string
èè4 :
.
èè: ;
Format
èè; A
(
èèA B
$strèèB ê
,èèê ë
lengthèèí ò
,èèò ô
dstèèö ù
.èèù û
WritableBytesèèû ´
,èè´ ¨
dstèè≠ ∞
)èè∞ ±
)èè± ≤
;èè≤ ≥
}
êê 
}
ëë 	
[
ìì 	

MethodImpl
ìì	 
(
ìì 
MethodImplOptions
ìì %
.
ìì% &

NoInlining
ìì& 0
)
ìì0 1
]
ìì1 2
internal
îî 
static
îî 
void
îî /
!ThrowIndexOutOfRangeException_Src
îî >
(
îî> ?
int
îî? B
srcIndex
îîC K
,
îîK L
int
îîM P
length
îîQ W
,
îîW X
int
îîY \
count
îî] b
)
îîb c
{
ïï 	
throw
ññ )
GetIndexOutOfRangeException
ññ -
(
ññ- .
)
ññ. /
;
ññ/ 0&
IndexOutOfRangeException
òò $)
GetIndexOutOfRangeException
òò% @
(
òò@ A
)
òòA B
{
ôô 
return
öö 
new
öö &
IndexOutOfRangeException
öö 3
(
öö3 4
string
öö4 :
.
öö: ;
Format
öö; A
(
ööA B
$strööB Ö
,ööÖ Ü
srcIndexööá è
,ööè ê
lengthööë ó
,ööó ò
countööô û
)ööû ü
)ööü †
;öö† °
}
õõ 
}
úú 	
[
ûû 	

MethodImpl
ûû	 
(
ûû 
MethodImplOptions
ûû %
.
ûû% &

NoInlining
ûû& 0
)
ûû0 1
]
ûû1 2
internal
üü 
static
üü 
void
üü 1
#ThrowIllegalReferenceCountException
üü @
(
üü@ A
int
üüA D
count
üüE J
)
üüJ K
{
†† 	
throw
°° /
!GetIllegalReferenceCountException
°° 3
(
°°3 4
)
°°4 5
;
°°5 6,
IllegalReferenceCountException
££ */
!GetIllegalReferenceCountException
££+ L
(
££L M
)
££M N
{
§§ 
return
•• 
new
•• ,
IllegalReferenceCountException
•• 9
(
••9 :
count
••: ?
)
••? @
;
••@ A
}
¶¶ 
}
ßß 	
[
©© 	

MethodImpl
©©	 
(
©© 
MethodImplOptions
©© %
.
©©% &

NoInlining
©©& 0
)
©©0 1
]
©©1 2
internal
™™ 
static
™™ 
void
™™ C
5ThrowArgumentOutOfRangeException_MinimumReadableBytes
™™ R
(
™™R S
int
™™S V"
minimumReadableBytes
™™W k
)
™™k l
{
´´ 	
throw
¨¨ ,
GetArgumentOutOfRangeException
¨¨ 0
(
¨¨0 1
)
¨¨1 2
;
¨¨2 3)
ArgumentOutOfRangeException
ÆÆ ',
GetArgumentOutOfRangeException
ÆÆ( F
(
ÆÆF G
)
ÆÆG H
{
ØØ 
return
∞∞ 
new
∞∞ )
ArgumentOutOfRangeException
∞∞ 6
(
∞∞6 7
$str
∞∞7 M
,
∞∞M N
string
∞∞O U
.
∞∞U V
Format
∞∞V \
(
∞∞\ ]
$str∞∞] â
,∞∞â ä$
minimumReadableBytes∞∞ã ü
)∞∞ü †
)∞∞† °
;∞∞° ¢
}
±± 
}
≤≤ 	
[
¥¥ 	

MethodImpl
¥¥	 
(
¥¥ 
MethodImplOptions
¥¥ %
.
¥¥% &

NoInlining
¥¥& 0
)
¥¥0 1
]
¥¥1 2
internal
µµ 
static
µµ 
void
µµ >
0ThrowArgumentOutOfRangeException_InitialCapacity
µµ M
(
µµM N
)
µµN O
{
∂∂ 	
throw
∑∑ ,
GetArgumentOutOfRangeException
∑∑ 0
(
∑∑0 1
)
∑∑1 2
;
∑∑2 3)
ArgumentOutOfRangeException
ππ ',
GetArgumentOutOfRangeException
ππ( F
(
ππF G
)
ππG H
{
∫∫ 
return
ªª 
new
ªª )
ArgumentOutOfRangeException
ªª 6
(
ªª6 7
$str
ªª7 H
,
ªªH I
$str
ªªJ u
)
ªªu v
;
ªªv w
}
ºº 
}
ΩΩ 	
[
øø 	

MethodImpl
øø	 
(
øø 
MethodImplOptions
øø %
.
øø% &

NoInlining
øø& 0
)
øø0 1
]
øø1 2
internal
¿¿ 
static
¿¿ 
void
¿¿ >
0ThrowArgumentOutOfRangeException_InitialCapacity
¿¿ M
(
¿¿M N
int
¿¿N Q
initialCapacity
¿¿R a
,
¿¿a b
int
¿¿c f
maxCapacity
¿¿g r
)
¿¿r s
{
¡¡ 	
throw
¬¬ ,
GetArgumentOutOfRangeException
¬¬ 0
(
¬¬0 1
)
¬¬1 2
;
¬¬2 3)
ArgumentOutOfRangeException
ƒƒ ',
GetArgumentOutOfRangeException
ƒƒ( F
(
ƒƒF G
)
ƒƒG H
{
≈≈ 
return
∆∆ 
new
∆∆ )
ArgumentOutOfRangeException
∆∆ 6
(
∆∆6 7
$str
∆∆7 H
,
∆∆H I
string
∆∆J P
.
∆∆P Q
Format
∆∆Q W
(
∆∆W X
$str∆∆X ñ
,∆∆ñ ó
initialCapacity∆∆ò ß
,∆∆ß ®
maxCapacity∆∆© ¥
)∆∆¥ µ
)∆∆µ ∂
;∆∆∂ ∑
}
«« 
}
»» 	
[
   	

MethodImpl
  	 
(
   
MethodImplOptions
   %
.
  % &

NoInlining
  & 0
)
  0 1
]
  1 2
internal
ÀÀ 
static
ÀÀ 
void
ÀÀ ?
1ThrowArgumentOutOfRangeException_MinWritableBytes
ÀÀ N
(
ÀÀN O
)
ÀÀO P
{
ÃÃ 	
throw
ÕÕ ,
GetArgumentOutOfRangeException
ÕÕ 0
(
ÕÕ0 1
)
ÕÕ1 2
;
ÕÕ2 3)
ArgumentOutOfRangeException
œœ ',
GetArgumentOutOfRangeException
œœ( F
(
œœF G
)
œœG H
{
–– 
return
—— 
new
—— )
ArgumentOutOfRangeException
—— 6
(
——6 7
$str
——7 I
,
——I J
$str
——K ~
)
——~ 
;—— Ä
}
““ 
}
”” 	
[
’’ 	

MethodImpl
’’	 
(
’’ 
MethodImplOptions
’’ %
.
’’% &

NoInlining
’’& 0
)
’’0 1
]
’’1 2
internal
÷÷ 
static
÷÷ 
void
÷÷ =
/ThrowArgumentOutOfRangeException_MinNewCapacity
÷÷ L
(
÷÷L M
int
÷÷M P
minNewCapacity
÷÷Q _
)
÷÷_ `
{
◊◊ 	
throw
ÿÿ ,
GetArgumentOutOfRangeException
ÿÿ 0
(
ÿÿ0 1
)
ÿÿ1 2
;
ÿÿ2 3)
ArgumentOutOfRangeException
⁄⁄ ',
GetArgumentOutOfRangeException
⁄⁄( F
(
⁄⁄F G
)
⁄⁄G H
{
€€ 
return
‹‹ 
new
‹‹ )
ArgumentOutOfRangeException
‹‹ 6
(
‹‹6 7
$str
‹‹7 G
,
‹‹G H
string
‹‹I O
.
‹‹O P
Format
‹‹P V
(
‹‹V W
$str
‹‹W {
,
‹‹{ |
minNewCapacity‹‹} ã
)‹‹ã å
)‹‹å ç
;‹‹ç é
}
›› 
}
ﬁﬁ 	
[
‡‡ 	

MethodImpl
‡‡	 
(
‡‡ 
MethodImplOptions
‡‡ %
.
‡‡% &

NoInlining
‡‡& 0
)
‡‡0 1
]
‡‡1 2
internal
·· 
static
·· 
void
·· :
,ThrowArgumentOutOfRangeException_MaxCapacity
·· I
(
··I J
int
··J M
minNewCapacity
··N \
,
··\ ]
int
··^ a
maxCapacity
··b m
)
··m n
{
‚‚ 	
throw
„„ ,
GetArgumentOutOfRangeException
„„ 0
(
„„0 1
)
„„1 2
;
„„2 3)
ArgumentOutOfRangeException
ÂÂ ',
GetArgumentOutOfRangeException
ÂÂ( F
(
ÂÂF G
)
ÂÂG H
{
ÊÊ 
return
ÁÁ 
new
ÁÁ )
ArgumentOutOfRangeException
ÁÁ 6
(
ÁÁ6 7
$str
ÁÁ7 D
,
ÁÁD E
string
ÁÁF L
.
ÁÁL M
Format
ÁÁM S
(
ÁÁS T
$strÁÁT ñ
,ÁÁñ ó
minNewCapacityÁÁò ¶
,ÁÁ¶ ß
maxCapacityÁÁ® ≥
)ÁÁ≥ ¥
)ÁÁ¥ µ
;ÁÁµ ∂
}
ËË 
}
ÈÈ 	
[
ÎÎ 	

MethodImpl
ÎÎ	 
(
ÎÎ 
MethodImplOptions
ÎÎ %
.
ÎÎ% &

NoInlining
ÎÎ& 0
)
ÎÎ0 1
]
ÎÎ1 2
internal
ÏÏ 
static
ÏÏ 
void
ÏÏ 7
)ThrowArgumentOutOfRangeException_Capacity
ÏÏ F
(
ÏÏF G
int
ÏÏG J
newCapacity
ÏÏK V
,
ÏÏV W
int
ÏÏX [
maxCapacity
ÏÏ\ g
)
ÏÏg h
{
ÌÌ 	
throw
ÓÓ ,
GetArgumentOutOfRangeException
ÓÓ 0
(
ÓÓ0 1
)
ÓÓ1 2
;
ÓÓ2 3)
ArgumentOutOfRangeException
 ',
GetArgumentOutOfRangeException
( F
(
F G
)
G H
{
ÒÒ 
return
ÚÚ 
new
ÚÚ )
ArgumentOutOfRangeException
ÚÚ 6
(
ÚÚ6 7
$str
ÚÚ7 D
,
ÚÚD E
string
ÚÚF L
.
ÚÚL M
Format
ÚÚM S
(
ÚÚS T
$"
ÚÚT V
$str
ÚÚV c
{
ÚÚc d
$num
ÚÚd e
}
ÚÚe f
$str
ÚÚf t
{
ÚÚt u
$num
ÚÚu v
}
ÚÚv w
$str
ÚÚw x
"
ÚÚx y
,
ÚÚy z
newCapacityÚÚ{ Ü
,ÚÚÜ á
maxCapacityÚÚà ì
)ÚÚì î
)ÚÚî ï
;ÚÚï ñ
}
ÛÛ 
}
ÙÙ 	
[
ˆˆ 	

MethodImpl
ˆˆ	 
(
ˆˆ 
MethodImplOptions
ˆˆ %
.
ˆˆ% &

NoInlining
ˆˆ& 0
)
ˆˆ0 1
]
ˆˆ1 2
internal
˜˜ 
static
˜˜ 
void
˜˜ ,
ThrowArgumentNullException_Dst
˜˜ ;
(
˜˜; <
)
˜˜< =
{
¯¯ 	
throw
˘˘ ,
GetArgumentOutOfRangeException
˘˘ 0
(
˘˘0 1
)
˘˘1 2
;
˘˘2 3#
ArgumentNullException
˚˚ !,
GetArgumentOutOfRangeException
˚˚" @
(
˚˚@ A
)
˚˚A B
{
¸¸ 
return
˝˝ 
new
˝˝ #
ArgumentNullException
˝˝ 0
(
˝˝0 1
$str
˝˝1 6
)
˝˝6 7
;
˝˝7 8
}
˛˛ 
}
ˇˇ 	
}
ÄÄ 
}ÅÅ ﬁ¢
[C:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\Unpooled.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

static 
class 
Unpooled  
{ 
static 
readonly '
UnpooledByteBufferAllocator 3
	Allocator4 =
=> ?'
UnpooledByteBufferAllocator@ [
.[ \
Default\ c
;c d
public 
static 
readonly 
IByteBuffer *
Empty+ 0
=1 2
	Allocator3 <
.< =
Buffer= C
(C D
$numD E
,E F
$numG H
)H I
;I J
public 
static 
IByteBuffer !
Buffer" (
(( )
)) *
=>+ -
	Allocator. 7
.7 8

HeapBuffer8 B
(B C
)C D
;D E
public 
static 
IByteBuffer !
DirectBuffer" .
(. /
)/ 0
=>1 3
	Allocator4 =
.= >
DirectBuffer> J
(J K
)K L
;L M
public 
static 
IByteBuffer !
Buffer" (
(( )
int) ,
initialCapacity- <
)< =
=>> @
	AllocatorA J
.J K

HeapBufferK U
(U V
initialCapacityV e
)e f
;f g
public 
static 
IByteBuffer !
DirectBuffer" .
(. /
int/ 2
initialCapacity3 B
)B C
=>D F
	AllocatorG P
.P Q
DirectBufferQ ]
(] ^
initialCapacity^ m
)m n
;n o
public 
static 
IByteBuffer !
Buffer" (
(( )
int) ,
initialCapacity- <
,< =
int> A
maxCapacityB M
)M N
=>O Q
	Allocator 
. 

HeapBuffer  
(  !
initialCapacity! 0
,0 1
maxCapacity2 =
)= >
;> ?
public   
static   
IByteBuffer   !
DirectBuffer  " .
(  . /
int  / 2
initialCapacity  3 B
,  B C
int  D G
maxCapacity  H S
)  S T
=>  U W
	Allocator!! 
.!! 
DirectBuffer!! "
(!!" #
initialCapacity!!# 2
,!!2 3
maxCapacity!!4 ?
)!!? @
;!!@ A
public'' 
static'' 
IByteBuffer'' !
WrappedBuffer''" /
(''/ 0
byte''0 4
[''4 5
]''5 6
array''7 <
)''< =
=>''> @
array(( 
.(( 
Length(( 
==(( 
$num(( 
?(( 
Empty((  %
:((' (
new(() ,"
UnpooledHeapByteBuffer((- C
(((C D
	Allocator((D M
,((M N
array((O T
,((T U
array((V [
.(([ \
Length((\ b
)((b c
;((c d
public// 
static// 
IByteBuffer// !
WrappedBuffer//" /
(/// 0
byte//0 4
[//4 5
]//5 6
array//7 <
,//< =
int//> A
offset//B H
,//H I
int//J M
length//N T
)//T U
{00 	
if11 
(11 
length11 
==11 
$num11 
)11 
{22 
return33 
Empty33 
;33 
}44 
if66 
(66 
offset66 
==66 
$num66 
&&66 
length66 %
==66& (
array66) .
.66. /
Length66/ 5
)665 6
{77 
return88 
WrappedBuffer88 $
(88$ %
array88% *
)88* +
;88+ ,
}99 
return;; 
WrappedBuffer;;  
(;;  !
array;;! &
);;& '
.;;' (
Slice;;( -
(;;- .
offset;;. 4
,;;4 5
length;;6 <
);;< =
;;;= >
}<< 	
publicDD 
staticDD 
IByteBufferDD !
WrappedBufferDD" /
(DD/ 0
IByteBufferDD0 ;
bufferDD< B
)DDB C
{EE 	
ifFF 
(FF 
bufferFF 
.FF 

IsReadableFF !
(FF! "
)FF" #
)FF# $
{GG 
returnHH 
bufferHH 
.HH 
SliceHH #
(HH# $
)HH$ %
;HH% &
}II 
elseJJ 
{KK 
bufferLL 
.LL 
ReleaseLL 
(LL 
)LL  
;LL  !
returnMM 
EmptyMM 
;MM 
}NN 
}OO 	
publicUU 
staticUU 
IByteBufferUU !
WrappedBufferUU" /
(UU/ 0
paramsUU0 6
byteUU7 ;
[UU; <
]UU< =
[UU= >
]UU> ?
arraysUU@ F
)UUF G
=>UUH J
WrappedBufferUUK X
(UUX Y'
AbstractByteBufferAllocatorUUY t
.UUt u!
DefaultMaxComponents	UUu â
,
UUâ ä
arrays
UUã ë
)
UUë í
;
UUí ì
public]] 
static]] 
IByteBuffer]] !
WrappedBuffer]]" /
(]]/ 0
params]]0 6
IByteBuffer]]7 B
[]]B C
]]]C D
buffers]]E L
)]]L M
=>]]N P
WrappedBuffer]]Q ^
(]]^ _'
AbstractByteBufferAllocator]]_ z
.]]z {!
DefaultMaxComponents	]]{ è
,
]]è ê
buffers
]]ë ò
)
]]ò ô
;
]]ô ö
publiccc 
staticcc 
IByteBuffercc !
WrappedBuffercc" /
(cc/ 0
intcc0 3
maxNumComponentscc4 D
,ccD E
paramsccF L
byteccM Q
[ccQ R
]ccR S
[ccS T
]ccT U
arraysccV \
)cc\ ]
{dd 	
switchee 
(ee 
arraysee 
.ee 
Lengthee !
)ee! "
{ff 
casegg 
$numgg 
:gg 
breakhh 
;hh 
caseii 
$numii 
:ii 
ifjj 
(jj 
arraysjj 
[jj 
$numjj  
]jj  !
.jj! "
Lengthjj" (
!=jj) +
$numjj, -
)jj- .
{kk 
returnll 
WrappedBufferll ,
(ll, -
arraysll- 3
[ll3 4
$numll4 5
]ll5 6
)ll6 7
;ll7 8
}mm 
breaknn 
;nn 
defaultoo 
:oo 
varqq 

componentsqq "
=qq# $
newqq% (
Listqq) -
<qq- .
IByteBufferqq. 9
>qq9 :
(qq: ;
arraysqq; A
.qqA B
LengthqqB H
)qqH I
;qqI J
foreachrr 
(rr 
byterr !
[rr! "
]rr" #
arrayrr$ )
inrr* ,
arraysrr- 3
)rr3 4
{ss 
iftt 
(tt 
arraytt !
==tt" $
nulltt% )
)tt) *
{uu 
breakvv !
;vv! "
}ww 
ifxx 
(xx 
arrayxx !
.xx! "
Lengthxx" (
>xx) *
$numxx+ ,
)xx, -
{yy 

componentszz &
.zz& '
Addzz' *
(zz* +
WrappedBufferzz+ 8
(zz8 9
arrayzz9 >
)zz> ?
)zz? @
;zz@ A
}{{ 
}|| 
if~~ 
(~~ 

components~~ "
.~~" #
Count~~# (
>~~) *
$num~~+ ,
)~~, -
{ 
return
ÄÄ 
new
ÄÄ "!
CompositeByteBuffer
ÄÄ# 6
(
ÄÄ6 7
	Allocator
ÄÄ7 @
,
ÄÄ@ A
false
ÄÄB G
,
ÄÄG H
maxNumComponents
ÄÄI Y
,
ÄÄY Z

components
ÄÄ[ e
)
ÄÄe f
;
ÄÄf g
}
ÅÅ 
break
ÇÇ 
;
ÇÇ 
}
ÉÉ 
return
ÖÖ 
Empty
ÖÖ 
;
ÖÖ 
}
ÜÜ 	
public
èè 
static
èè 
IByteBuffer
èè !
WrappedBuffer
èè" /
(
èè/ 0
int
èè0 3
maxNumComponents
èè4 D
,
èèD E
params
èèF L
IByteBuffer
èèM X
[
èèX Y
]
èèY Z
buffers
èè[ b
)
èèb c
{
êê 	
switch
ëë 
(
ëë 
buffers
ëë 
.
ëë 
Length
ëë "
)
ëë" #
{
íí 
case
ìì 
$num
ìì 
:
ìì 
break
îî 
;
îî 
case
ïï 
$num
ïï 
:
ïï 
IByteBuffer
ññ 
buffer
ññ  &
=
ññ' (
buffers
ññ) 0
[
ññ0 1
$num
ññ1 2
]
ññ2 3
;
ññ3 4
if
óó 
(
óó 
buffer
óó 
.
óó 

IsReadable
óó )
(
óó) *
)
óó* +
)
óó+ ,
return
òò 
WrappedBuffer
òò ,
(
òò, -
buffer
òò- 3
)
òò3 4
;
òò4 5
else
ôô 
buffer
öö 
.
öö 
Release
öö &
(
öö& '
)
öö' (
;
öö( )
break
õõ 
;
õõ 
default
úú 
:
úú 
for
ùù 
(
ùù 
int
ùù 
i
ùù 
=
ùù  
$num
ùù! "
;
ùù" #
i
ùù$ %
<
ùù& '
buffers
ùù( /
.
ùù/ 0
Length
ùù0 6
;
ùù6 7
i
ùù8 9
++
ùù9 ;
)
ùù; <
{
ûû 
IByteBuffer
üü #
buf
üü$ '
=
üü( )
buffers
üü* 1
[
üü1 2
i
üü2 3
]
üü3 4
;
üü4 5
if
†† 
(
†† 
buf
†† 
.
††  

IsReadable
††  *
(
††* +
)
††+ ,
)
††, -
return
°° "
new
°°# &!
CompositeByteBuffer
°°' :
(
°°: ;
	Allocator
°°; D
,
°°D E
false
°°F K
,
°°K L
maxNumComponents
°°M ]
,
°°] ^
buffers
°°_ f
,
°°f g
i
°°h i
,
°°i j
buffers
°°k r
.
°°r s
Length
°°s y
)
°°y z
;
°°z {
else
¢¢ 
buf
££ 
.
££  
Release
££  '
(
££' (
)
££( )
;
££) *
}
§§ 
break
•• 
;
•• 
}
¶¶ 
return
®® 
Empty
®® 
;
®® 
}
©© 	
public
´´ 
static
´´ !
CompositeByteBuffer
´´ )
CompositeBuffer
´´* 9
(
´´9 :
)
´´: ;
=>
´´< >
CompositeBuffer
´´? N
(
´´N O)
AbstractByteBufferAllocator
´´O j
.
´´j k"
DefaultMaxComponents
´´k 
)´´ Ä
;´´Ä Å
public
≠≠ 
static
≠≠ !
CompositeByteBuffer
≠≠ )
CompositeBuffer
≠≠* 9
(
≠≠9 :
int
≠≠: =
maxNumComponents
≠≠> N
)
≠≠N O
=>
≠≠P R
new
≠≠S V!
CompositeByteBuffer
≠≠W j
(
≠≠j k
	Allocator
≠≠k t
,
≠≠t u
false
≠≠v {
,
≠≠{ |
maxNumComponents≠≠} ç
)≠≠ç é
;≠≠é è
public
∂∂ 
static
∂∂ 
IByteBuffer
∂∂ !
CopiedBuffer
∂∂" .
(
∂∂. /
byte
∂∂/ 3
[
∂∂3 4
]
∂∂4 5
array
∂∂6 ;
)
∂∂; <
{
∑∑ 	
if
∏∏ 
(
∏∏ 
array
∏∏ 
.
∏∏ 
Length
∏∏ 
==
∏∏ 
$num
∏∏  !
)
∏∏! "
{
ππ 
return
∫∫ 
Empty
∫∫ 
;
∫∫ 
}
ªª 
var
ΩΩ 
newArray
ΩΩ 
=
ΩΩ 
new
ΩΩ 
byte
ΩΩ #
[
ΩΩ# $
array
ΩΩ$ )
.
ΩΩ) *
Length
ΩΩ* 0
]
ΩΩ0 1
;
ΩΩ1 2
PlatformDependent
ææ 
.
ææ 

CopyMemory
ææ (
(
ææ( )
array
ææ) .
,
ææ. /
$num
ææ0 1
,
ææ1 2
newArray
ææ3 ;
,
ææ; <
$num
ææ= >
,
ææ> ?
array
ææ@ E
.
ææE F
Length
ææF L
)
ææL M
;
ææM N
return
¿¿ 
WrappedBuffer
¿¿  
(
¿¿  !
newArray
¿¿! )
)
¿¿) *
;
¿¿* +
}
¡¡ 	
public
ŒŒ 
static
ŒŒ 
IByteBuffer
ŒŒ !
CopiedBuffer
ŒŒ" .
(
ŒŒ. /
byte
ŒŒ/ 3
[
ŒŒ3 4
]
ŒŒ4 5
array
ŒŒ6 ;
,
ŒŒ; <
int
ŒŒ= @
offset
ŒŒA G
,
ŒŒG H
int
ŒŒI L
length
ŒŒM S
)
ŒŒS T
{
œœ 	
if
–– 
(
–– 
length
–– 
==
–– 
$num
–– 
)
–– 
{
—— 
return
““ 
Empty
““ 
;
““ 
}
”” 
var
’’ 
copy
’’ 
=
’’ 
new
’’ 
byte
’’ 
[
’’  
length
’’  &
]
’’& '
;
’’' (
PlatformDependent
÷÷ 
.
÷÷ 

CopyMemory
÷÷ (
(
÷÷( )
array
÷÷) .
,
÷÷. /
offset
÷÷0 6
,
÷÷6 7
copy
÷÷8 <
,
÷÷< =
$num
÷÷> ?
,
÷÷? @
length
÷÷A G
)
÷÷G H
;
÷÷H I
return
◊◊ 
WrappedBuffer
◊◊  
(
◊◊  !
copy
◊◊! %
)
◊◊% &
;
◊◊& '
}
ÿÿ 	
public
·· 
static
·· 
IByteBuffer
·· !
CopiedBuffer
··" .
(
··. /
IByteBuffer
··/ :
buffer
··; A
)
··A B
{
‚‚ 	
int
„„ 
readable
„„ 
=
„„ 
buffer
„„ !
.
„„! "
ReadableBytes
„„" /
;
„„/ 0
if
‰‰ 
(
‰‰ 
readable
‰‰ 
>
‰‰ 
$num
‰‰ 
)
‰‰ 
{
ÂÂ 
IByteBuffer
ÊÊ 
copy
ÊÊ  
=
ÊÊ! "
Buffer
ÊÊ# )
(
ÊÊ) *
readable
ÊÊ* 2
)
ÊÊ2 3
;
ÊÊ3 4
copy
ÁÁ 
.
ÁÁ 

WriteBytes
ÁÁ 
(
ÁÁ  
buffer
ÁÁ  &
,
ÁÁ& '
buffer
ÁÁ( .
.
ÁÁ. /
ReaderIndex
ÁÁ/ :
,
ÁÁ: ;
readable
ÁÁ< D
)
ÁÁD E
;
ÁÁE F
return
ËË 
copy
ËË 
;
ËË 
}
ÈÈ 
else
ÍÍ 
{
ÎÎ 
return
ÏÏ 
Empty
ÏÏ 
;
ÏÏ 
}
ÌÌ 
}
ÓÓ 	
public
˜˜ 
static
˜˜ 
IByteBuffer
˜˜ !
CopiedBuffer
˜˜" .
(
˜˜. /
params
˜˜/ 5
byte
˜˜6 :
[
˜˜: ;
]
˜˜; <
[
˜˜< =
]
˜˜= >
arrays
˜˜? E
)
˜˜E F
{
¯¯ 	
switch
˘˘ 
(
˘˘ 
arrays
˘˘ 
.
˘˘ 
Length
˘˘ !
)
˘˘! "
{
˙˙ 
case
˚˚ 
$num
˚˚ 
:
˚˚ 
return
¸¸ 
Empty
¸¸  
;
¸¸  !
case
˝˝ 
$num
˝˝ 
:
˝˝ 
return
˛˛ 
arrays
˛˛ !
[
˛˛! "
$num
˛˛" #
]
˛˛# $
.
˛˛$ %
Length
˛˛% +
==
˛˛, .
$num
˛˛/ 0
?
˛˛1 2
Empty
˛˛3 8
:
˛˛9 :
CopiedBuffer
˛˛; G
(
˛˛G H
arrays
˛˛H N
[
˛˛N O
$num
˛˛O P
]
˛˛P Q
)
˛˛Q R
;
˛˛R S
}
ˇˇ 
int
ÇÇ 
length
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
foreach
ÉÉ 
(
ÉÉ 
byte
ÉÉ 
[
ÉÉ 
]
ÉÉ 
a
ÉÉ 
in
ÉÉ  
arrays
ÉÉ! '
)
ÉÉ' (
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
int
ÖÖ 
.
ÖÖ 
MaxValue
ÖÖ  
-
ÖÖ! "
length
ÖÖ# )
<
ÖÖ* +
a
ÖÖ, -
.
ÖÖ- .
Length
ÖÖ. 4
)
ÖÖ4 5
{
ÜÜ 
throw
áá 
new
áá 
ArgumentException
áá /
(
áá/ 0
$str
áá0 f
)
ááf g
;
áág h
}
àà 
length
ââ 
+=
ââ 
a
ââ 
.
ââ 
Length
ââ "
;
ââ" #
}
ää 
if
åå 
(
åå 
length
åå 
==
åå 
$num
åå 
)
åå 
{
çç 
return
éé 
Empty
éé 
;
éé 
}
èè 
var
ëë 
mergedArray
ëë 
=
ëë 
new
ëë !
byte
ëë" &
[
ëë& '
length
ëë' -
]
ëë- .
;
ëë. /
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
,
íí 
j
íí 
=
íí 
$num
íí  !
;
íí! "
i
íí# $
<
íí% &
arrays
íí' -
.
íí- .
Length
íí. 4
;
íí4 5
i
íí6 7
++
íí7 9
)
íí9 :
{
ìì 
byte
îî 
[
îî 
]
îî 
a
îî 
=
îî 
arrays
îî !
[
îî! "
i
îî" #
]
îî# $
;
îî$ %
PlatformDependent
ïï !
.
ïï! "

CopyMemory
ïï" ,
(
ïï, -
a
ïï- .
,
ïï. /
$num
ïï0 1
,
ïï1 2
mergedArray
ïï3 >
,
ïï> ?
j
ïï@ A
,
ïïA B
a
ïïC D
.
ïïD E
Length
ïïE K
)
ïïK L
;
ïïL M
j
ññ 
+=
ññ 
a
ññ 
.
ññ 
Length
ññ 
;
ññ 
}
óó 
return
ôô 
WrappedBuffer
ôô  
(
ôô  !
mergedArray
ôô! ,
)
ôô, -
;
ôô- .
}
öö 	
public
££ 
static
££ 
IByteBuffer
££ !
CopiedBuffer
££" .
(
££. /
params
££/ 5
IByteBuffer
££6 A
[
££A B
]
££B C
buffers
££D K
)
££K L
{
§§ 	
switch
•• 
(
•• 
buffers
•• 
.
•• 
Length
•• "
)
••" #
{
¶¶ 
case
ßß 
$num
ßß 
:
ßß 
return
®® 
Empty
®®  
;
®®  !
case
©© 
$num
©© 
:
©© 
return
™™ 
CopiedBuffer
™™ '
(
™™' (
buffers
™™( /
[
™™/ 0
$num
™™0 1
]
™™1 2
)
™™2 3
;
™™3 4
}
´´ 
int
ÆÆ 
length
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
foreach
ØØ 
(
ØØ 
IByteBuffer
ØØ  
b
ØØ! "
in
ØØ# %
buffers
ØØ& -
)
ØØ- .
{
∞∞ 
int
±± 
bLen
±± 
=
±± 
b
±± 
.
±± 
ReadableBytes
±± *
;
±±* +
if
≤≤ 
(
≤≤ 
bLen
≤≤ 
<=
≤≤ 
$num
≤≤ 
)
≤≤ 
{
≥≥ 
continue
¥¥ 
;
¥¥ 
}
µµ 
if
∂∂ 
(
∂∂ 
int
∂∂ 
.
∂∂ 
MaxValue
∂∂  
-
∂∂! "
length
∂∂# )
<
∂∂* +
bLen
∂∂, 0
)
∂∂0 1
{
∑∑ 
throw
∏∏ 
new
∏∏ 
ArgumentException
∏∏ /
(
∏∏/ 0
$str
∏∏0 g
)
∏∏g h
;
∏∏h i
}
ππ 
length
ªª 
+=
ªª 
bLen
ªª 
;
ªª 
}
ºº 
if
ææ 
(
ææ 
length
ææ 
==
ææ 
$num
ææ 
)
ææ 
{
øø 
return
¿¿ 
Empty
¿¿ 
;
¿¿ 
}
¡¡ 
var
√√ 
mergedArray
√√ 
=
√√ 
new
√√ !
byte
√√" &
[
√√& '
length
√√' -
]
√√- .
;
√√. /
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
j
ƒƒ 
=
ƒƒ 
$num
ƒƒ  !
;
ƒƒ! "
i
ƒƒ# $
<
ƒƒ% &
buffers
ƒƒ' .
.
ƒƒ. /
Length
ƒƒ/ 5
;
ƒƒ5 6
i
ƒƒ7 8
++
ƒƒ8 :
)
ƒƒ: ;
{
≈≈ 
IByteBuffer
∆∆ 
b
∆∆ 
=
∆∆ 
buffers
∆∆  '
[
∆∆' (
i
∆∆( )
]
∆∆) *
;
∆∆* +
int
«« 
bLen
«« 
=
«« 
b
«« 
.
«« 
ReadableBytes
«« *
;
««* +
b
»» 
.
»» 
GetBytes
»» 
(
»» 
b
»» 
.
»» 
ReaderIndex
»» (
,
»»( )
mergedArray
»»* 5
,
»»5 6
j
»»7 8
,
»»8 9
bLen
»»: >
)
»»> ?
;
»»? @
j
…… 
+=
…… 
bLen
…… 
;
…… 
}
   
return
ÃÃ 
WrappedBuffer
ÃÃ  
(
ÃÃ  !
mergedArray
ÃÃ! ,
)
ÃÃ, -
;
ÃÃ- .
}
ÕÕ 	
public
œœ 
static
œœ 
IByteBuffer
œœ !
CopiedBuffer
œœ" .
(
œœ. /
char
œœ/ 3
[
œœ3 4
]
œœ4 5
array
œœ6 ;
,
œœ; <
int
œœ= @
offset
œœA G
,
œœG H
int
œœI L
length
œœM S
,
œœS T
Encoding
œœU ]
encoding
œœ^ f
)
œœf g
{
–– 	
Contract
—— 
.
—— 
Requires
—— 
(
—— 
array
—— #
!=
——$ &
null
——' +
)
——+ ,
;
——, -
return
““ 
length
““ 
==
““ 
$num
““ 
?
““  
Empty
““! &
:
““' (
CopiedBuffer
““) 5
(
““5 6
new
““6 9
string
““: @
(
““@ A
array
““A F
,
““F G
offset
““H N
,
““N O
length
““P V
)
““V W
,
““W X
encoding
““Y a
)
““a b
;
““b c
}
”” 	
public
’’ 
static
’’ 
IByteBuffer
’’ !
CopiedBuffer
’’" .
(
’’. /
string
’’/ 5
value
’’6 ;
,
’’; <
Encoding
’’= E
encoding
’’F N
)
’’N O
=>
’’P R
ByteBufferUtil
’’S a
.
’’a b
EncodeString0
’’b o
(
’’o p
	Allocator
’’p y
,
’’y z
true
’’{ 
,’’ Ä
value’’Å Ü
,’’Ü á
encoding’’à ê
,’’ê ë
$num’’í ì
)’’ì î
;’’î ï
public
⁄⁄ 
static
⁄⁄ 
IByteBuffer
⁄⁄ !
CopyInt
⁄⁄" )
(
⁄⁄) *
int
⁄⁄* -
value
⁄⁄. 3
)
⁄⁄3 4
{
€€ 	
IByteBuffer
‹‹ 
buf
‹‹ 
=
‹‹ 
Buffer
‹‹ $
(
‹‹$ %
$num
‹‹% &
)
‹‹& '
;
‹‹' (
buf
›› 
.
›› 
WriteInt
›› 
(
›› 
value
›› 
)
›› 
;
››  
return
ﬁﬁ 
buf
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
public
‰‰ 
static
‰‰ 
IByteBuffer
‰‰ !
CopyInt
‰‰" )
(
‰‰) *
params
‰‰* 0
int
‰‰1 4
[
‰‰4 5
]
‰‰5 6
values
‰‰7 =
)
‰‰= >
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
values
ÊÊ 
==
ÊÊ 
null
ÊÊ 
||
ÊÊ !
values
ÊÊ" (
.
ÊÊ( )
Length
ÊÊ) /
==
ÊÊ0 2
$num
ÊÊ3 4
)
ÊÊ4 5
{
ÁÁ 
return
ËË 
Empty
ËË 
;
ËË 
}
ÈÈ 
IByteBuffer
ÎÎ 
buffer
ÎÎ 
=
ÎÎ  
Buffer
ÎÎ! '
(
ÎÎ' (
values
ÎÎ( .
.
ÎÎ. /
Length
ÎÎ/ 5
*
ÎÎ6 7
$num
ÎÎ8 9
)
ÎÎ9 :
;
ÎÎ: ;
foreach
ÏÏ 
(
ÏÏ 
int
ÏÏ 
v
ÏÏ 
in
ÏÏ 
values
ÏÏ $
)
ÏÏ$ %
{
ÌÌ 
buffer
ÓÓ 
.
ÓÓ 
WriteInt
ÓÓ 
(
ÓÓ  
v
ÓÓ  !
)
ÓÓ! "
;
ÓÓ" #
}
ÔÔ 
return
ÒÒ 
buffer
ÒÒ 
;
ÒÒ 
}
ÚÚ 	
public
˜˜ 
static
˜˜ 
IByteBuffer
˜˜ !
	CopyShort
˜˜" +
(
˜˜+ ,
int
˜˜, /
value
˜˜0 5
)
˜˜5 6
{
¯¯ 	
IByteBuffer
˘˘ 
buf
˘˘ 
=
˘˘ 
Buffer
˘˘ $
(
˘˘$ %
$num
˘˘% &
)
˘˘& '
;
˘˘' (
buf
˙˙ 
.
˙˙ 

WriteShort
˙˙ 
(
˙˙ 
value
˙˙  
)
˙˙  !
;
˙˙! "
return
˚˚ 
buf
˚˚ 
;
˚˚ 
}
¸¸ 	
public
ÅÅ 
static
ÅÅ 
IByteBuffer
ÅÅ !
	CopyShort
ÅÅ" +
(
ÅÅ+ ,
params
ÅÅ, 2
short
ÅÅ3 8
[
ÅÅ8 9
]
ÅÅ9 :
values
ÅÅ; A
)
ÅÅA B
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
values
ÉÉ 
==
ÉÉ 
null
ÉÉ 
||
ÉÉ !
values
ÉÉ" (
.
ÉÉ( )
Length
ÉÉ) /
==
ÉÉ0 2
$num
ÉÉ3 4
)
ÉÉ4 5
{
ÑÑ 
return
ÖÖ 
Empty
ÖÖ 
;
ÖÖ 
}
ÜÜ 
IByteBuffer
àà 
buffer
àà 
=
àà  
Buffer
àà! '
(
àà' (
values
àà( .
.
àà. /
Length
àà/ 5
*
àà6 7
$num
àà8 9
)
àà9 :
;
àà: ;
foreach
ââ 
(
ââ 
short
ââ 
v
ââ 
in
ââ 
values
ââ  &
)
ââ& '
{
ää 
buffer
ãã 
.
ãã 

WriteShort
ãã !
(
ãã! "
v
ãã" #
)
ãã# $
;
ãã$ %
}
åå 
return
éé 
buffer
éé 
;
éé 
}
èè 	
public
îî 
static
îî 
IByteBuffer
îî !
	CopyShort
îî" +
(
îî+ ,
params
îî, 2
int
îî3 6
[
îî6 7
]
îî7 8
values
îî9 ?
)
îî? @
{
ïï 	
if
ññ 
(
ññ 
values
ññ 
==
ññ 
null
ññ 
||
ññ !
values
ññ" (
.
ññ( )
Length
ññ) /
==
ññ0 2
$num
ññ3 4
)
ññ4 5
{
óó 
return
òò 
Empty
òò 
;
òò 
}
ôô 
IByteBuffer
õõ 
buffer
õõ 
=
õõ  
Buffer
õõ! '
(
õõ' (
values
õõ( .
.
õõ. /
Length
õõ/ 5
*
õõ6 7
$num
õõ8 9
)
õõ9 :
;
õõ: ;
foreach
úú 
(
úú 
int
úú 
v
úú 
in
úú 
values
úú $
)
úú$ %
{
ùù 
buffer
ûû 
.
ûû 

WriteShort
ûû !
(
ûû! "
v
ûû" #
)
ûû# $
;
ûû$ %
}
üü 
return
†† 
buffer
†† 
;
†† 
}
°° 	
public
¶¶ 
static
¶¶ 
IByteBuffer
¶¶ !

CopyMedium
¶¶" ,
(
¶¶, -
int
¶¶- 0
value
¶¶1 6
)
¶¶6 7
{
ßß 	
IByteBuffer
®® 
buf
®® 
=
®® 
Buffer
®® $
(
®®$ %
$num
®®% &
)
®®& '
;
®®' (
buf
©© 
.
©© 
WriteMedium
©© 
(
©© 
value
©© !
)
©©! "
;
©©" #
return
™™ 
buf
™™ 
;
™™ 
}
´´ 	
public
∞∞ 
static
∞∞ 
IByteBuffer
∞∞ !

CopyMedium
∞∞" ,
(
∞∞, -
params
∞∞- 3
int
∞∞4 7
[
∞∞7 8
]
∞∞8 9
values
∞∞: @
)
∞∞@ A
{
±± 	
if
≤≤ 
(
≤≤ 
values
≤≤ 
==
≤≤ 
null
≤≤ 
||
≤≤ !
values
≤≤" (
.
≤≤( )
Length
≤≤) /
==
≤≤0 2
$num
≤≤3 4
)
≤≤4 5
{
≥≥ 
return
¥¥ 
Empty
¥¥ 
;
¥¥ 
}
µµ 
IByteBuffer
∑∑ 
buffer
∑∑ 
=
∑∑  
Buffer
∑∑! '
(
∑∑' (
values
∑∑( .
.
∑∑. /
Length
∑∑/ 5
*
∑∑6 7
$num
∑∑8 9
)
∑∑9 :
;
∑∑: ;
foreach
∏∏ 
(
∏∏ 
int
∏∏ 
v
∏∏ 
in
∏∏ 
values
∏∏ $
)
∏∏$ %
{
ππ 
buffer
∫∫ 
.
∫∫ 
WriteMedium
∫∫ "
(
∫∫" #
v
∫∫# $
)
∫∫$ %
;
∫∫% &
}
ªª 
return
ΩΩ 
buffer
ΩΩ 
;
ΩΩ 
}
ææ 	
public
√√ 
static
√√ 
IByteBuffer
√√ !
CopyLong
√√" *
(
√√* +
long
√√+ /
value
√√0 5
)
√√5 6
{
ƒƒ 	
IByteBuffer
≈≈ 
buf
≈≈ 
=
≈≈ 
Buffer
≈≈ $
(
≈≈$ %
$num
≈≈% &
)
≈≈& '
;
≈≈' (
buf
∆∆ 
.
∆∆ 
	WriteLong
∆∆ 
(
∆∆ 
value
∆∆ 
)
∆∆  
;
∆∆  !
return
«« 
buf
«« 
;
«« 
}
»» 	
public
ÕÕ 
static
ÕÕ 
IByteBuffer
ÕÕ !
CopyLong
ÕÕ" *
(
ÕÕ* +
params
ÕÕ+ 1
long
ÕÕ2 6
[
ÕÕ6 7
]
ÕÕ7 8
values
ÕÕ9 ?
)
ÕÕ? @
{
ŒŒ 	
if
œœ 
(
œœ 
values
œœ 
==
œœ 
null
œœ 
||
œœ !
values
œœ" (
.
œœ( )
Length
œœ) /
==
œœ0 2
$num
œœ3 4
)
œœ4 5
{
–– 
return
—— 
Empty
—— 
;
—— 
}
““ 
IByteBuffer
‘‘ 
buffer
‘‘ 
=
‘‘  
Buffer
‘‘! '
(
‘‘' (
values
‘‘( .
.
‘‘. /
Length
‘‘/ 5
*
‘‘6 7
$num
‘‘8 9
)
‘‘9 :
;
‘‘: ;
foreach
’’ 
(
’’ 
long
’’ 
v
’’ 
in
’’ 
values
’’ %
)
’’% &
{
÷÷ 
buffer
◊◊ 
.
◊◊ 
	WriteLong
◊◊  
(
◊◊  !
v
◊◊! "
)
◊◊" #
;
◊◊# $
}
ÿÿ 
return
⁄⁄ 
buffer
⁄⁄ 
;
⁄⁄ 
}
€€ 	
public
‡‡ 
static
‡‡ 
IByteBuffer
‡‡ !
CopyBoolean
‡‡" -
(
‡‡- .
bool
‡‡. 2
value
‡‡3 8
)
‡‡8 9
{
·· 	
IByteBuffer
‚‚ 
buf
‚‚ 
=
‚‚ 
Buffer
‚‚ $
(
‚‚$ %
$num
‚‚% &
)
‚‚& '
;
‚‚' (
buf
„„ 
.
„„ 
WriteBoolean
„„ 
(
„„ 
value
„„ "
)
„„" #
;
„„# $
return
‰‰ 
buf
‰‰ 
;
‰‰ 
}
ÂÂ 	
public
ÍÍ 
static
ÍÍ 
IByteBuffer
ÍÍ !
CopyBoolean
ÍÍ" -
(
ÍÍ- .
params
ÍÍ. 4
bool
ÍÍ5 9
[
ÍÍ9 :
]
ÍÍ: ;
values
ÍÍ< B
)
ÍÍB C
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
values
ÏÏ 
==
ÏÏ 
null
ÏÏ 
||
ÏÏ !
values
ÏÏ" (
.
ÏÏ( )
Length
ÏÏ) /
==
ÏÏ0 2
$num
ÏÏ3 4
)
ÏÏ4 5
{
ÌÌ 
return
ÓÓ 
Empty
ÓÓ 
;
ÓÓ 
}
ÔÔ 
IByteBuffer
ÒÒ 
buffer
ÒÒ 
=
ÒÒ  
Buffer
ÒÒ! '
(
ÒÒ' (
values
ÒÒ( .
.
ÒÒ. /
Length
ÒÒ/ 5
)
ÒÒ5 6
;
ÒÒ6 7
foreach
ÚÚ 
(
ÚÚ 
bool
ÚÚ 
v
ÚÚ 
in
ÚÚ 
values
ÚÚ %
)
ÚÚ% &
{
ÛÛ 
buffer
ÙÙ 
.
ÙÙ 
WriteBoolean
ÙÙ #
(
ÙÙ# $
v
ÙÙ$ %
)
ÙÙ% &
;
ÙÙ& '
}
ıı 
return
˜˜ 
buffer
˜˜ 
;
˜˜ 
}
¯¯ 	
public
˝˝ 
static
˝˝ 
IByteBuffer
˝˝ !
	CopyFloat
˝˝" +
(
˝˝+ ,
float
˝˝, 1
value
˝˝2 7
)
˝˝7 8
{
˛˛ 	
IByteBuffer
ˇˇ 
buf
ˇˇ 
=
ˇˇ 
Buffer
ˇˇ $
(
ˇˇ$ %
$num
ˇˇ% &
)
ˇˇ& '
;
ˇˇ' (
buf
ÄÄ 
.
ÄÄ 

WriteFloat
ÄÄ 
(
ÄÄ 
value
ÄÄ  
)
ÄÄ  !
;
ÄÄ! "
return
ÅÅ 
buf
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
public
áá 
static
áá 
IByteBuffer
áá !
	CopyFloat
áá" +
(
áá+ ,
params
áá, 2
float
áá3 8
[
áá8 9
]
áá9 :
values
áá; A
)
ááA B
{
àà 	
if
ââ 
(
ââ 
values
ââ 
==
ââ 
null
ââ 
||
ââ !
values
ââ" (
.
ââ( )
Length
ââ) /
==
ââ0 2
$num
ââ3 4
)
ââ4 5
{
ää 
return
ãã 
Empty
ãã 
;
ãã 
}
åå 
IByteBuffer
éé 
buffer
éé 
=
éé  
Buffer
éé! '
(
éé' (
values
éé( .
.
éé. /
Length
éé/ 5
*
éé6 7
$num
éé8 9
)
éé9 :
;
éé: ;
foreach
èè 
(
èè 
float
èè 
v
èè 
in
èè 
values
èè  &
)
èè& '
{
êê 
buffer
ëë 
.
ëë 

WriteFloat
ëë !
(
ëë! "
v
ëë" #
)
ëë# $
;
ëë$ %
}
íí 
return
îî 
buffer
îî 
;
îî 
}
ïï 	
public
öö 
static
öö 
IByteBuffer
öö !

CopyDouble
öö" ,
(
öö, -
double
öö- 3
value
öö4 9
)
öö9 :
{
õõ 	
IByteBuffer
úú 
buf
úú 
=
úú 
Buffer
úú $
(
úú$ %
$num
úú% &
)
úú& '
;
úú' (
buf
ùù 
.
ùù 
WriteDouble
ùù 
(
ùù 
value
ùù !
)
ùù! "
;
ùù" #
return
ûû 
buf
ûû 
;
ûû 
}
üü 	
public
§§ 
static
§§ 
IByteBuffer
§§ !

CopyDouble
§§" ,
(
§§, -
params
§§- 3
double
§§4 :
[
§§: ;
]
§§; <
values
§§= C
)
§§C D
{
•• 	
if
¶¶ 
(
¶¶ 
values
¶¶ 
==
¶¶ 
null
¶¶ 
||
¶¶ !
values
¶¶" (
.
¶¶( )
Length
¶¶) /
==
¶¶0 2
$num
¶¶3 4
)
¶¶4 5
{
ßß 
return
®® 
Empty
®® 
;
®® 
}
©© 
IByteBuffer
´´ 
buffer
´´ 
=
´´  
Buffer
´´! '
(
´´' (
values
´´( .
.
´´. /
Length
´´/ 5
*
´´6 7
$num
´´8 9
)
´´9 :
;
´´: ;
foreach
¨¨ 
(
¨¨ 
double
¨¨ 
v
¨¨ 
in
¨¨  
values
¨¨! '
)
¨¨' (
{
≠≠ 
buffer
ÆÆ 
.
ÆÆ 
WriteDouble
ÆÆ "
(
ÆÆ" #
v
ÆÆ# $
)
ÆÆ$ %
;
ÆÆ% &
}
ØØ 
return
±± 
buffer
±± 
;
±± 
}
≤≤ 	
public
∑∑ 
static
∑∑ 
IByteBuffer
∑∑ ! 
UnreleasableBuffer
∑∑" 4
(
∑∑4 5
IByteBuffer
∑∑5 @
buffer
∑∑A G
)
∑∑G H
=>
∑∑I K
new
∑∑L O$
UnreleasableByteBuffer
∑∑P f
(
∑∑f g
buffer
∑∑g m
)
∑∑m n
;
∑∑n o
}
∏∏ 
}ππ ¯h
nC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledByteBufferAllocator.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

sealed 
class '
UnpooledByteBufferAllocator 3
:4 5'
AbstractByteBufferAllocator6 Q
,Q R.
"IByteBufferAllocatorMetricProviderS u
{ 
readonly -
!UnpooledByteBufferAllocatorMetric 2
metric3 9
=: ;
new< ?-
!UnpooledByteBufferAllocatorMetric@ a
(a b
)b c
;c d
readonly 
bool 
disableLeakDetector )
;) *
public 
static 
readonly '
UnpooledByteBufferAllocator :
Default; B
=C D
new '
UnpooledByteBufferAllocator +
(+ ,
PlatformDependent, =
.= >!
DirectBufferPreferred> S
)S T
;T U
public '
UnpooledByteBufferAllocator *
(* +
)+ ,
: 
this 
( 
false 
, 
false 
)  
{ 	
} 	
public 
unsafe '
UnpooledByteBufferAllocator 1
(1 2
bool2 6
preferDirect7 C
)C D
: 
this 
( 
preferDirect 
,  
false! &
)& '
{ 	
} 	
public 
unsafe '
UnpooledByteBufferAllocator 1
(1 2
bool2 6
preferDirect7 C
,C D
boolE I
disableLeakDetectorJ ]
)] ^
:   
base   
(   
preferDirect   
)    
{!! 	
this"" 
."" 
disableLeakDetector"" $
=""% &
disableLeakDetector""' :
;"": ;
}## 	
	protected%% 
override%% 
IByteBuffer%% &
NewHeapBuffer%%' 4
(%%4 5
int%%5 8
initialCapacity%%9 H
,%%H I
int%%J M
maxCapacity%%N Y
)%%Y Z
=>%%[ ]
new&& .
"InstrumentedUnpooledHeapByteBuffer&& 2
(&&2 3
this&&3 7
,&&7 8
initialCapacity&&9 H
,&&H I
maxCapacity&&J U
)&&U V
;&&V W
	protected(( 
unsafe(( 
override(( !
IByteBuffer((" -
NewDirectBuffer((. =
(((= >
int((> A
initialCapacity((B Q
,((Q R
int((S V
maxCapacity((W b
)((b c
{)) 	
IByteBuffer** 
buf** 
=** 
new** !6
*InstrumentedUnpooledUnsafeDirectByteBuffer**" L
(**L M
this**M Q
,**Q R
initialCapacity**S b
,**b c
maxCapacity**d o
)**o p
;**p q
return++ 
this++ 
.++ 
disableLeakDetector++ +
?++, -
buf++. 1
:++2 3
ToLeakAwareBuffer++4 E
(++E F
buf++F I
)++I J
;++J K
},, 	
public.. 
override.. 
CompositeByteBuffer.. +
CompositeHeapBuffer.., ?
(..? @
int..@ C
maxNumComponents..D T
)..T U
{// 	
var00 
buf00 
=00 
new00 
CompositeByteBuffer00 -
(00- .
this00. 2
,002 3
false004 9
,009 :
maxNumComponents00; K
)00K L
;00L M
return11 
this11 
.11 
disableLeakDetector11 +
?11, -
buf11. 1
:112 3
ToLeakAwareBuffer114 E
(11E F
buf11F I
)11I J
;11J K
}22 	
public44 
unsafe44 
override44 
CompositeByteBuffer44 2!
CompositeDirectBuffer443 H
(44H I
int44I L
maxNumComponents44M ]
)44] ^
{55 	
var66 
buf66 
=66 
new66 
CompositeByteBuffer66 -
(66- .
this66. 2
,662 3
true664 8
,668 9
maxNumComponents66: J
)66J K
;66K L
return77 
this77 
.77 
disableLeakDetector77 +
?77, -
buf77. 1
:772 3
ToLeakAwareBuffer774 E
(77E F
buf77F I
)77I J
;77J K
}88 	
public:: 
override:: 
bool::  
IsDirectBufferPooled:: 1
=>::2 4
false::5 :
;::: ;
public<< &
IByteBufferAllocatorMetric<< )
Metric<<* 0
=><<1 3
this<<4 8
.<<8 9
metric<<9 ?
;<<? @
internal>> 
void>> 
IncrementDirect>> %
(>>% &
int>>& )
amount>>* 0
)>>0 1
=>>>2 4
this>>5 9
.>>9 :
metric>>: @
.>>@ A
DirectCounter>>A N
(>>N O
amount>>O U
)>>U V
;>>V W
internal@@ 
void@@ 
DecrementDirect@@ %
(@@% &
int@@& )
amount@@* 0
)@@0 1
=>@@2 4
this@@5 9
.@@9 :
metric@@: @
.@@@ A
DirectCounter@@A N
(@@N O
-@@O P
amount@@P V
)@@V W
;@@W X
internalBB 
voidBB 
IncrementHeapBB #
(BB# $
intBB$ '
amountBB( .
)BB. /
=>BB0 2
thisBB3 7
.BB7 8
metricBB8 >
.BB> ?
HeapCounterBB? J
(BBJ K
amountBBK Q
)BBQ R
;BBR S
internalDD 
voidDD 
DecrementHeapDD #
(DD# $
intDD$ '
amountDD( .
)DD. /
=>DD0 2
thisDD3 7
.DD7 8
metricDD8 >
.DD> ?
HeapCounterDD? J
(DDJ K
-DDK L
amountDDL R
)DDR S
;DDS T
sealedFF 
classFF .
"InstrumentedUnpooledHeapByteBufferFF 7
:FF8 9"
UnpooledHeapByteBufferFF: P
{GG 	
internalHH .
"InstrumentedUnpooledHeapByteBufferHH 7
(HH7 8'
UnpooledByteBufferAllocatorII +
allocII, 1
,II1 2
intII3 6
initialCapacityII7 F
,IIF G
intIIH K
maxCapacityIIL W
)IIW X
:JJ 
baseJJ 
(JJ 
allocJJ 
,JJ 
initialCapacityJJ -
,JJ- .
maxCapacityJJ/ :
)JJ: ;
{KK 
(LL 
(LL '
UnpooledByteBufferAllocatorLL -
)LL- .
thisLL. 2
.LL2 3
	AllocatorLL3 <
)LL< =
.LL= >
IncrementHeapLL> K
(LLK L
initialCapacityLLL [
)LL[ \
;LL\ ]
}MM 
	protectedOO 
overrideOO 
byteOO #
[OO# $
]OO$ %
AllocateArrayOO& 3
(OO3 4
intOO4 7
initialCapacityOO8 G
)OOG H
{PP 
byteQQ 
[QQ 
]QQ 
bytesQQ 
=QQ 
baseQQ #
.QQ# $
AllocateArrayQQ$ 1
(QQ1 2
initialCapacityQQ2 A
)QQA B
;QQB C
(RR 
(RR '
UnpooledByteBufferAllocatorRR -
)RR- .
thisRR. 2
.RR2 3
	AllocatorRR3 <
)RR< =
.RR= >
IncrementHeapRR> K
(RRK L
bytesRRL Q
.RRQ R
LengthRRR X
)RRX Y
;RRY Z
returnSS 
bytesSS 
;SS 
}TT 
	protectedVV 
overrideVV 
voidVV #
	FreeArrayVV$ -
(VV- .
byteVV. 2
[VV2 3
]VV3 4
bytesVV5 :
)VV: ;
{WW 
intXX 
lengthXX 
=XX 
bytesXX "
.XX" #
LengthXX# )
;XX) *
baseYY 
.YY 
	FreeArrayYY 
(YY 
bytesYY $
)YY$ %
;YY% &
(ZZ 
(ZZ '
UnpooledByteBufferAllocatorZZ -
)ZZ- .
thisZZ. 2
.ZZ2 3
	AllocatorZZ3 <
)ZZ< =
.ZZ= >
DecrementHeapZZ> K
(ZZK L
lengthZZL R
)ZZR S
;ZZS T
}[[ 
}\\ 	
sealed^^ 
class^^ 6
*InstrumentedUnpooledUnsafeDirectByteBuffer^^ ?
:^^@ A*
UnpooledUnsafeDirectByteBuffer^^B `
{__ 	
internal`` 6
*InstrumentedUnpooledUnsafeDirectByteBuffer`` ?
(``? @'
UnpooledByteBufferAllocatoraa +
allocaa, 1
,aa1 2
intaa3 6
initialCapacityaa7 F
,aaF G
intaaH K
maxCapacityaaL W
)aaW X
:bb 
basebb 
(bb 
allocbb 
,bb 
initialCapacitybb -
,bb- .
maxCapacitybb/ :
)bb: ;
{cc 
(dd 
(dd '
UnpooledByteBufferAllocatordd -
)dd- .
thisdd. 2
.dd2 3
	Allocatordd3 <
)dd< =
.dd= >
IncrementDirectdd> M
(ddM N
initialCapacityddN ]
)dd] ^
;dd^ _
}ee 
	protectedgg 
overridegg 
bytegg #
[gg# $
]gg$ %
AllocateDirectgg& 4
(gg4 5
intgg5 8
initialCapacitygg9 H
)ggH I
{hh 
byteii 
[ii 
]ii 
bytesii 
=ii 
baseii #
.ii# $
AllocateDirectii$ 2
(ii2 3
initialCapacityii3 B
)iiB C
;iiC D
(jj 
(jj '
UnpooledByteBufferAllocatorjj -
)jj- .
thisjj. 2
.jj2 3
	Allocatorjj3 <
)jj< =
.jj= >
IncrementDirectjj> M
(jjM N
bytesjjN S
.jjS T
LengthjjT Z
)jjZ [
;jj[ \
returnkk 
byteskk 
;kk 
}ll 
	protectednn 
overridenn 
voidnn #

FreeDirectnn$ .
(nn. /
bytenn/ 3
[nn3 4
]nn4 5
arraynn6 ;
)nn; <
{oo 
intpp 
capacitypp 
=pp 
arraypp $
.pp$ %
Lengthpp% +
;pp+ ,
baseqq 
.qq 

FreeDirectqq 
(qq  
arrayqq  %
)qq% &
;qq& '
(rr 
(rr '
UnpooledByteBufferAllocatorrr -
)rr- .
thisrr. 2
.rr2 3
	Allocatorrr3 <
)rr< =
.rr= >
DecrementDirectrr> M
(rrM N
capacityrrN V
)rrV W
;rrW X
}ss 
}tt 	
sealedvv 
classvv -
!UnpooledByteBufferAllocatorMetricvv 6
:vv7 8&
IByteBufferAllocatorMetricvv9 S
{ww 	
longxx 
usedHeapMemoryxx 
;xx  
longyy 
userDirectMemoryyy !
;yy! "
public{{ 
long{{ 
UsedHeapMemory{{ &
=>{{' )
Volatile{{* 2
.{{2 3
Read{{3 7
({{7 8
ref{{8 ;
this{{< @
.{{@ A
usedHeapMemory{{A O
){{O P
;{{P Q
public}} 
long}} 
UsedDirectMemory}} (
=>}}) +
Volatile}}, 4
.}}4 5
Read}}5 9
(}}9 :
ref}}: =
this}}> B
.}}B C
userDirectMemory}}C S
)}}S T
;}}T U
public 
void 
HeapCounter #
(# $
int$ '
amount( .
). /
=>0 2
Interlocked3 >
.> ?
Add? B
(B C
refC F
thisG K
.K L
usedHeapMemoryL Z
,Z [
amount\ b
)b c
;c d
public
ÅÅ 
void
ÅÅ 
DirectCounter
ÅÅ %
(
ÅÅ% &
int
ÅÅ& )
amount
ÅÅ* 0
)
ÅÅ0 1
=>
ÅÅ2 4
Interlocked
ÅÅ5 @
.
ÅÅ@ A
Add
ÅÅA D
(
ÅÅD E
ref
ÅÅE H
this
ÅÅI M
.
ÅÅM N
userDirectMemory
ÅÅN ^
,
ÅÅ^ _
amount
ÅÅ` f
)
ÅÅf g
;
ÅÅg h
public
ÉÉ 
override
ÉÉ 
string
ÉÉ "
ToString
ÉÉ# +
(
ÉÉ+ ,
)
ÉÉ, -
=>
ÉÉ. 0
$"
ÉÉ1 3
{
ÉÉ3 4

StringUtil
ÉÉ4 >
.
ÉÉ> ?
SimpleClassName
ÉÉ? N
(
ÉÉN O
this
ÉÉO S
)
ÉÉS T
}
ÉÉT U
$str
ÉÉU g
{
ÉÉg h
this
ÉÉh l
.
ÉÉl m
UsedHeapMemory
ÉÉm {
}
ÉÉ{ |
$strÉÉ| ê
{ÉÉê ë
thisÉÉë ï
.ÉÉï ñ 
UsedDirectMemoryÉÉñ ¶
}ÉÉ¶ ß
$strÉÉß ®
"ÉÉ® ©
;ÉÉ© ™
}
ÑÑ 	
}
ÖÖ 
}ÜÜ ˘ì
oC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledDuplicatedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	(
UnpooledDuplicatedByteBuffer
 &
:' (%
AbstractDerivedByteBuffer) B
{ 
readonly 
AbstractByteBuffer #
buffer$ *
;* +
public (
UnpooledDuplicatedByteBuffer +
(+ ,
AbstractByteBuffer, >
buffer? E
)E F
: 
this 
( 
buffer 
, 
buffer !
.! "
ReaderIndex" -
,- .
buffer/ 5
.5 6
WriterIndex6 A
)A B
{ 	
} 	
internal (
UnpooledDuplicatedByteBuffer -
(- .
AbstractByteBuffer. @
bufferA G
,G H
intI L
readerIndexM X
,X Y
intZ ]
writerIndex^ i
)i j
: 
base 
( 
buffer 
. 
MaxCapacity %
)% &
{ 	
if 
( 
buffer 
is (
UnpooledDuplicatedByteBuffer 6

duplicated7 A
)A B
{ 
this 
. 
buffer 
= 

duplicated (
.( )
buffer) /
;/ 0
} 
else 
if 
( 
buffer 
is +
AbstractPooledDerivedByteBuffer >
)> ?
{ 
this 
. 
buffer 
= 
( 
AbstractByteBuffer 1
)1 2
buffer2 8
.8 9
Unwrap9 ?
(? @
)@ A
;A B
} 
else   
{!! 
this"" 
."" 
buffer"" 
="" 
buffer"" $
;""$ %
}## 
this%% 
.%% 
	SetIndex0%% 
(%% 
readerIndex%% &
,%%& '
writerIndex%%( 3
)%%3 4
;%%4 5
this&& 
.&& 
	MarkIndex&& 
(&& 
)&& 
;&& 
}'' 	
public)) 
override)) 
IByteBuffer)) #
Unwrap))$ *
())* +
)))+ ,
=>))- /
this))0 4
.))4 5

UnwrapCore))5 ?
())? @
)))@ A
;))A B
public++ 
override++ 
IByteBuffer++ #
Copy++$ (
(++( )
int++) ,
index++- 2
,++2 3
int++4 7
length++8 >
)++> ?
=>++@ B
this++C G
.++G H
Unwrap++H N
(++N O
)++O P
.++P Q
Copy++Q U
(++U V
index++V [
,++[ \
length++] c
)++c d
;++d e
	protected-- 
AbstractByteBuffer-- $

UnwrapCore--% /
(--/ 0
)--0 1
=>--2 4
this--5 9
.--9 :
buffer--: @
;--@ A
public// 
override//  
IByteBufferAllocator// ,
	Allocator//- 6
=>//7 9
this//: >
.//> ?
Unwrap//? E
(//E F
)//F G
.//G H
	Allocator//H Q
;//Q R
public11 
override11 
bool11 
IsDirect11 %
=>11& (
this11) -
.11- .
Unwrap11. 4
(114 5
)115 6
.116 7
IsDirect117 ?
;11? @
public33 
override33 
int33 
Capacity33 $
=>33% '
this33( ,
.33, -
Unwrap33- 3
(333 4
)334 5
.335 6
Capacity336 >
;33> ?
public55 
override55 
IByteBuffer55 #
AdjustCapacity55$ 2
(552 3
int553 6
newCapacity557 B
)55B C
=>55D F
this55G K
.55K L
Unwrap55L R
(55R S
)55S T
.55T U
AdjustCapacity55U c
(55c d
newCapacity55d o
)55o p
;55p q
public77 
override77 
int77 
IoBufferCount77 )
=>77* ,
this77- 1
.771 2
Unwrap772 8
(778 9
)779 :
.77: ;
IoBufferCount77; H
;77H I
public99 
override99 
bool99 
HasArray99 %
=>99& (
this99) -
.99- .
Unwrap99. 4
(994 5
)995 6
.996 7
HasArray997 ?
;99? @
public;; 
override;; 
byte;; 
[;; 
];; 
Array;; $
=>;;% '
this;;( ,
.;;, -
Unwrap;;- 3
(;;3 4
);;4 5
.;;5 6
Array;;6 ;
;;;; <
public== 
override== 
int== 
ArrayOffset== '
=>==( *
this==+ /
.==/ 0
Unwrap==0 6
(==6 7
)==7 8
.==8 9
ArrayOffset==9 D
;==D E
public?? 
override?? 
bool?? 
HasMemoryAddress?? -
=>??. 0
this??1 5
.??5 6
Unwrap??6 <
(??< =
)??= >
.??> ?
HasMemoryAddress??? O
;??O P
publicAA 
overrideAA 
refAA 
byteAA  $
GetPinnableMemoryAddressAA! 9
(AA9 :
)AA: ;
=>AA< >
refAA? B
thisAAC G
.AAG H
UnwrapAAH N
(AAN O
)AAO P
.AAP Q$
GetPinnableMemoryAddressAAQ i
(AAi j
)AAj k
;AAk l
publicCC 
overrideCC 
IntPtrCC !
AddressOfPinnedMemoryCC 4
(CC4 5
)CC5 6
=>CC7 9
thisCC: >
.CC> ?
UnwrapCC? E
(CCE F
)CCF G
.CCG H!
AddressOfPinnedMemoryCCH ]
(CC] ^
)CC^ _
;CC_ `
	protectedEE 
internalEE 
overrideEE #
byteEE$ (
_GetByteEE) 1
(EE1 2
intEE2 5
indexEE6 ;
)EE; <
=>EE= ?
thisEE@ D
.EED E

UnwrapCoreEEE O
(EEO P
)EEP Q
.EEQ R
_GetByteEER Z
(EEZ [
indexEE[ `
)EE` a
;EEa b
	protectedGG 
internalGG 
overrideGG #
shortGG$ )
	_GetShortGG* 3
(GG3 4
intGG4 7
indexGG8 =
)GG= >
=>GG? A
thisGGB F
.GGF G

UnwrapCoreGGG Q
(GGQ R
)GGR S
.GGS T
	_GetShortGGT ]
(GG] ^
indexGG^ c
)GGc d
;GGd e
	protectedII 
internalII 
overrideII #
shortII$ )
_GetShortLEII* 5
(II5 6
intII6 9
indexII: ?
)II? @
=>IIA C
thisIID H
.IIH I

UnwrapCoreIII S
(IIS T
)IIT U
.IIU V
_GetShortLEIIV a
(IIa b
indexIIb g
)IIg h
;IIh i
	protectedKK 
internalKK 
overrideKK #
intKK$ '
_GetUnsignedMediumKK( :
(KK: ;
intKK; >
indexKK? D
)KKD E
=>KKF H
thisKKI M
.KKM N

UnwrapCoreKKN X
(KKX Y
)KKY Z
.KKZ [
_GetUnsignedMediumKK[ m
(KKm n
indexKKn s
)KKs t
;KKt u
	protectedMM 
internalMM 
overrideMM #
intMM$ ' 
_GetUnsignedMediumLEMM( <
(MM< =
intMM= @
indexMMA F
)MMF G
=>MMH J
thisMMK O
.MMO P

UnwrapCoreMMP Z
(MMZ [
)MM[ \
.MM\ ] 
_GetUnsignedMediumLEMM] q
(MMq r
indexMMr w
)MMw x
;MMx y
	protectedOO 
internalOO 
overrideOO #
intOO$ '
_GetIntOO( /
(OO/ 0
intOO0 3
indexOO4 9
)OO9 :
=>OO; =
thisOO> B
.OOB C

UnwrapCoreOOC M
(OOM N
)OON O
.OOO P
_GetIntOOP W
(OOW X
indexOOX ]
)OO] ^
;OO^ _
	protectedQQ 
internalQQ 
overrideQQ #
intQQ$ '
	_GetIntLEQQ( 1
(QQ1 2
intQQ2 5
indexQQ6 ;
)QQ; <
=>QQ= ?
thisQQ@ D
.QQD E

UnwrapCoreQQE O
(QQO P
)QQP Q
.QQQ R
	_GetIntLEQQR [
(QQ[ \
indexQQ\ a
)QQa b
;QQb c
	protectedSS 
internalSS 
overrideSS #
longSS$ (
_GetLongSS) 1
(SS1 2
intSS2 5
indexSS6 ;
)SS; <
=>SS= ?
thisSS@ D
.SSD E

UnwrapCoreSSE O
(SSO P
)SSP Q
.SSQ R
_GetLongSSR Z
(SSZ [
indexSS[ `
)SS` a
;SSa b
	protectedUU 
internalUU 
overrideUU #
longUU$ (

_GetLongLEUU) 3
(UU3 4
intUU4 7
indexUU8 =
)UU= >
=>UU? A
thisUUB F
.UUF G

UnwrapCoreUUG Q
(UUQ R
)UUR S
.UUS T

_GetLongLEUUT ^
(UU^ _
indexUU_ d
)UUd e
;UUe f
publicWW 
overrideWW 
IByteBufferWW #
GetBytesWW$ ,
(WW, -
intWW- 0
indexWW1 6
,WW6 7
IByteBufferWW8 C
destinationWWD O
,WWO P
intWWQ T
dstIndexWWU ]
,WW] ^
intWW_ b
lengthWWc i
)WWi j
=>WWk m
thisWWn r
.WWr s
UnwrapWWs y
(WWy z
)WWz {
.WW{ |
GetBytes	WW| Ñ
(
WWÑ Ö
index
WWÖ ä
,
WWä ã
destination
WWå ó
,
WWó ò
dstIndex
WWô °
,
WW° ¢
length
WW£ ©
)
WW© ™
;
WW™ ´
publicYY 
overrideYY 
IByteBufferYY #
GetBytesYY$ ,
(YY, -
intYY- 0
indexYY1 6
,YY6 7
byteYY8 <
[YY< =
]YY= >
destinationYY? J
,YYJ K
intYYL O
dstIndexYYP X
,YYX Y
intYYZ ]
lengthYY^ d
)YYd e
=>YYf h
thisYYi m
.YYm n
UnwrapYYn t
(YYt u
)YYu v
.YYv w
GetBytesYYw 
(	YY Ä
index
YYÄ Ö
,
YYÖ Ü
destination
YYá í
,
YYí ì
dstIndex
YYî ú
,
YYú ù
length
YYû §
)
YY§ •
;
YY• ¶
public[[ 
override[[ 
IByteBuffer[[ #
GetBytes[[$ ,
([[, -
int[[- 0
index[[1 6
,[[6 7
Stream[[8 >
destination[[? J
,[[J K
int[[L O
length[[P V
)[[V W
=>[[X Z
this[[[ _
.[[_ `
Unwrap[[` f
([[f g
)[[g h
.[[h i
GetBytes[[i q
([[q r
index[[r w
,[[w x
destination	[[y Ñ
,
[[Ñ Ö
length
[[Ü å
)
[[å ç
;
[[ç é
	protected]] 
internal]] 
override]] #
void]]$ (
_SetByte]]) 1
(]]1 2
int]]2 5
index]]6 ;
,]]; <
int]]= @
value]]A F
)]]F G
=>]]H J
this]]K O
.]]O P

UnwrapCore]]P Z
(]]Z [
)]][ \
.]]\ ]
_SetByte]]] e
(]]e f
index]]f k
,]]k l
value]]m r
)]]r s
;]]s t
	protected__ 
internal__ 
override__ #
void__$ (
	_SetShort__) 2
(__2 3
int__3 6
index__7 <
,__< =
int__> A
value__B G
)__G H
=>__I K
this__L P
.__P Q

UnwrapCore__Q [
(__[ \
)__\ ]
.__] ^
	_SetShort__^ g
(__g h
index__h m
,__m n
value__o t
)__t u
;__u v
	protectedaa 
internalaa 
overrideaa #
voidaa$ (
_SetShortLEaa) 4
(aa4 5
intaa5 8
indexaa9 >
,aa> ?
intaa@ C
valueaaD I
)aaI J
=>aaK M
thisaaN R
.aaR S

UnwrapCoreaaS ]
(aa] ^
)aa^ _
.aa_ `
_SetShortLEaa` k
(aak l
indexaal q
,aaq r
valueaas x
)aax y
;aay z
	protectedcc 
internalcc 
overridecc #
voidcc$ (

_SetMediumcc) 3
(cc3 4
intcc4 7
indexcc8 =
,cc= >
intcc? B
valueccC H
)ccH I
=>ccJ L
thisccM Q
.ccQ R

UnwrapCoreccR \
(cc\ ]
)cc] ^
.cc^ _

_SetMediumcc_ i
(cci j
indexccj o
,cco p
valueccq v
)ccv w
;ccw x
	protectedee 
internalee 
overrideee #
voidee$ (
_SetMediumLEee) 5
(ee5 6
intee6 9
indexee: ?
,ee? @
inteeA D
valueeeE J
)eeJ K
=>eeL N
thiseeO S
.eeS T

UnwrapCoreeeT ^
(ee^ _
)ee_ `
.ee` a
_SetMediumLEeea m
(eem n
indexeen s
,ees t
valueeeu z
)eez {
;ee{ |
publicgg 
overridegg 
IByteBuffergg #
SetBytesgg$ ,
(gg, -
intgg- 0
indexgg1 6
,gg6 7
IByteBuffergg8 C
srcggD G
,ggG H
intggI L
srcIndexggM U
,ggU V
intggW Z
lengthgg[ a
)gga b
=>ggc e
thisggf j
.ggj k
Unwrapggk q
(ggq r
)ggr s
.ggs t
SetBytesggt |
(gg| }
index	gg} Ç
,
ggÇ É
src
ggÑ á
,
ggá à
srcIndex
ggâ ë
,
ggë í
length
ggì ô
)
ggô ö
;
ggö õ
publicii 
overrideii 
Taskii 
<ii 
intii  
>ii  !
SetBytesAsyncii" /
(ii/ 0
intii0 3
indexii4 9
,ii9 :
Streamii; A
srciiB E
,iiE F
intiiG J
lengthiiK Q
,iiQ R
CancellationTokeniiS d
cancellationTokeniie v
)iiv w
=>iix z
thisii{ 
.	ii Ä
Unwrap
iiÄ Ü
(
iiÜ á
)
iiá à
.
iià â
SetBytesAsync
iiâ ñ
(
iiñ ó
index
iió ú
,
iiú ù
src
iiû °
,
ii° ¢
length
ii£ ©
,
ii© ™
cancellationToken
ii´ º
)
iiº Ω
;
iiΩ æ
publickk 
overridekk 
IByteBufferkk #
SetByteskk$ ,
(kk, -
intkk- 0
indexkk1 6
,kk6 7
bytekk8 <
[kk< =
]kk= >
srckk? B
,kkB C
intkkD G
srcIndexkkH P
,kkP Q
intkkR U
lengthkkV \
)kk\ ]
=>kk^ `
thiskka e
.kke f
Unwrapkkf l
(kkl m
)kkm n
.kkn o
SetByteskko w
(kkw x
indexkkx }
,kk} ~
src	kk Ç
,
kkÇ É
srcIndex
kkÑ å
,
kkå ç
length
kké î
)
kkî ï
;
kkï ñ
	protectedmm 
internalmm 
overridemm #
voidmm$ (
_SetIntmm) 0
(mm0 1
intmm1 4
indexmm5 :
,mm: ;
intmm< ?
valuemm@ E
)mmE F
=>mmG I
thismmJ N
.mmN O

UnwrapCoremmO Y
(mmY Z
)mmZ [
.mm[ \
_SetIntmm\ c
(mmc d
indexmmd i
,mmi j
valuemmk p
)mmp q
;mmq r
	protectedoo 
internaloo 
overrideoo #
voidoo$ (
	_SetIntLEoo) 2
(oo2 3
intoo3 6
indexoo7 <
,oo< =
intoo> A
valueooB G
)ooG H
=>ooI K
thisooL P
.ooP Q

UnwrapCoreooQ [
(oo[ \
)oo\ ]
.oo] ^
	_SetIntLEoo^ g
(oog h
indexooh m
,oom n
valueooo t
)oot u
;oou v
	protectedqq 
internalqq 
overrideqq #
voidqq$ (
_SetLongqq) 1
(qq1 2
intqq2 5
indexqq6 ;
,qq; <
longqq= A
valueqqB G
)qqG H
=>qqI K
thisqqL P
.qqP Q

UnwrapCoreqqQ [
(qq[ \
)qq\ ]
.qq] ^
_SetLongqq^ f
(qqf g
indexqqg l
,qql m
valueqqn s
)qqs t
;qqt u
	protectedss 
internalss 
overridess #
voidss$ (

_SetLongLEss) 3
(ss3 4
intss4 7
indexss8 =
,ss= >
longss? C
valuessD I
)ssI J
=>ssK M
thisssN R
.ssR S

UnwrapCoressS ]
(ss] ^
)ss^ _
.ss_ `

_SetLongLEss` j
(ssj k
indexssk p
,ssp q
valuessr w
)ssw x
;ssx y
publicuu 
overrideuu 
intuu 
ForEachByteuu '
(uu' (
intuu( +
indexuu, 1
,uu1 2
intuu3 6
lengthuu7 =
,uu= >
IByteProcessoruu? M
	processoruuN W
)uuW X
=>uuY [
thisuu\ `
.uu` a
Unwrapuua g
(uug h
)uuh i
.uui j
ForEachByteuuj u
(uuu v
indexuuv {
,uu{ |
length	uu} É
,
uuÉ Ñ
	processor
uuÖ é
)
uué è
;
uuè ê
publicww 
overrideww 
intww 
ForEachByteDescww +
(ww+ ,
intww, /
indexww0 5
,ww5 6
intww7 :
lengthww; A
,wwA B
IByteProcessorwwC Q
	processorwwR [
)ww[ \
=>ww] _
thisww` d
.wwd e
Unwrapwwe k
(wwk l
)wwl m
.wwm n
ForEachByteDescwwn }
(ww} ~
index	ww~ É
,
wwÉ Ñ
length
wwÖ ã
,
wwã å
	processor
wwç ñ
)
wwñ ó
;
wwó ò
}xx 
}yy °¿
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledHeapByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

class "
UnpooledHeapByteBuffer '
:( ).
"AbstractReferenceCountedByteBuffer* L
{ 
readonly  
IByteBufferAllocator %
	allocator& /
;/ 0
byte 
[ 
] 
array 
; 
	protected 
internal "
UnpooledHeapByteBuffer 1
(1 2 
IByteBufferAllocator2 F
allocG L
,L M
intN Q
initialCapacityR a
,a b
intc f
maxCapacityg r
)r s
: 
base 
( 
maxCapacity 
) 
{ 	
Contract 
. 
Requires 
( 
alloc #
!=$ &
null' +
)+ ,
;, -
Contract 
. 
Requires 
( 
initialCapacity -
<=. 0
maxCapacity1 <
)< =
;= >
this 
. 
	allocator 
= 
alloc "
;" #
this 
. 
SetArray 
( 
this 
. 
NewArray '
(' (
initialCapacity( 7
)7 8
)8 9
;9 :
this 
. 
	SetIndex0 
( 
$num 
, 
$num 
)  
;  !
} 	
	protected 
internal "
UnpooledHeapByteBuffer 1
(1 2 
IByteBufferAllocator2 F
allocG L
,L M
byteN R
[R S
]S T
initialArrayU a
,a b
intc f
maxCapacityg r
)r s
: 
base 
( 
maxCapacity 
) 
{   	
Contract!! 
.!! 
Requires!! 
(!! 
alloc!! #
!=!!$ &
null!!' +
)!!+ ,
;!!, -
Contract"" 
."" 
Requires"" 
("" 
initialArray"" *
!=""+ -
null"". 2
)""2 3
;""3 4
if$$ 
($$ 
initialArray$$ 
.$$ 
Length$$ #
>$$$ %
maxCapacity$$& 1
)$$1 2
{%% 
throw&& 
new&& 
ArgumentException&& +
(&&+ ,
$"&&, .
$str&&. >
{&&> ?
initialArray&&? K
.&&K L
Length&&L R
}&&R S
$str&&S c
{&&c d
maxCapacity&&d o
}&&o p
$str&&p q
"&&q r
)&&r s
;&&s t
}'' 
this)) 
.)) 
	allocator)) 
=)) 
alloc)) "
;))" #
this** 
.** 
SetArray** 
(** 
initialArray** &
)**& '
;**' (
this++ 
.++ 
	SetIndex0++ 
(++ 
$num++ 
,++ 
initialArray++ *
.++* +
Length+++ 1
)++1 2
;++2 3
},, 	
	protected.. 
virtual.. 
byte.. 
[.. 
]..  
AllocateArray..! .
(... /
int../ 2
initialCapacity..3 B
)..B C
=>..D F
this..G K
...K L
NewArray..L T
(..T U
initialCapacity..U d
)..d e
;..e f
	protected00 
byte00 
[00 
]00 
NewArray00 !
(00! "
int00" %
initialCapacity00& 5
)005 6
=>007 9
new00: =
byte00> B
[00B C
initialCapacity00C R
]00R S
;00S T
	protected22 
virtual22 
void22 
	FreeArray22 (
(22( )
byte22) -
[22- .
]22. /
bytes220 5
)225 6
{33 	
}55 	
	protected77 
void77 
SetArray77 
(77  
byte77  $
[77$ %
]77% &
initialArray77' 3
)773 4
=>775 7
this778 <
.77< =
array77= B
=77C D
initialArray77E Q
;77Q R
public99 
override99  
IByteBufferAllocator99 ,
	Allocator99- 6
=>997 9
this99: >
.99> ?
	allocator99? H
;99H I
public;; 
override;; 
bool;; 
IsDirect;; %
=>;;& (
false;;) .
;;;. /
public== 
override== 
int== 
Capacity== $
{>> 	
get?? 
{@@ 
thisAA 
.AA 
EnsureAccessibleAA %
(AA% &
)AA& '
;AA' (
returnBB 
thisBB 
.BB 
arrayBB !
.BB! "
LengthBB" (
;BB( )
}CC 
}DD 	
publicFF 
overrideFF 
IByteBufferFF #
AdjustCapacityFF$ 2
(FF2 3
intFF3 6
newCapacityFF7 B
)FFB C
{GG 	
thisHH 
.HH 
CheckNewCapacityHH !
(HH! "
newCapacityHH" -
)HH- .
;HH. /
intJJ 
oldCapacityJJ 
=JJ 
thisJJ "
.JJ" #
arrayJJ# (
.JJ( )
LengthJJ) /
;JJ/ 0
byteKK 
[KK 
]KK 
oldArrayKK 
=KK 
thisKK "
.KK" #
arrayKK# (
;KK( )
ifLL 
(LL 
newCapacityLL 
>LL 
oldCapacityLL )
)LL) *
{MM 
byteNN 
[NN 
]NN 
newArrayNN 
=NN  !
thisNN" &
.NN& '
AllocateArrayNN' 4
(NN4 5
newCapacityNN5 @
)NN@ A
;NNA B
PlatformDependentOO !
.OO! "

CopyMemoryOO" ,
(OO, -
thisOO- 1
.OO1 2
arrayOO2 7
,OO7 8
$numOO9 :
,OO: ;
newArrayOO< D
,OOD E
$numOOF G
,OOG H
oldCapacityOOI T
)OOT U
;OOU V
thisQQ 
.QQ 
SetArrayQQ 
(QQ 
newArrayQQ &
)QQ& '
;QQ' (
thisRR 
.RR 
	FreeArrayRR 
(RR 
oldArrayRR '
)RR' (
;RR( )
}SS 
elseTT 
ifTT 
(TT 
newCapacityTT  
<TT! "
oldCapacityTT# .
)TT. /
{UU 
byteVV 
[VV 
]VV 
newArrayVV 
=VV  !
thisVV" &
.VV& '
AllocateArrayVV' 4
(VV4 5
newCapacityVV5 @
)VV@ A
;VVA B
intWW 
readerIndexWW 
=WW  !
thisWW" &
.WW& '
ReaderIndexWW' 2
;WW2 3
ifXX 
(XX 
readerIndexXX 
<XX  !
newCapacityXX" -
)XX- .
{YY 
intZZ 
writerIndexZZ #
=ZZ$ %
thisZZ& *
.ZZ* +
WriterIndexZZ+ 6
;ZZ6 7
if[[ 
([[ 
writerIndex[[ #
>[[$ %
newCapacity[[& 1
)[[1 2
{\\ 
this]] 
.]] 
SetWriterIndex0]] ,
(]], -
writerIndex]]- 8
=]]9 :
newCapacity]]; F
)]]F G
;]]G H
}^^ 
PlatformDependent`` %
.``% &

CopyMemory``& 0
(``0 1
this``1 5
.``5 6
array``6 ;
,``; <
readerIndex``= H
,``H I
newArray``J R
,``R S
$num``T U
,``U V
writerIndex``W b
-``c d
readerIndex``e p
)``p q
;``q r
}aa 
elsebb 
{cc 
thisdd 
.dd 
SetIndexdd !
(dd! "
newCapacitydd" -
,dd- .
newCapacitydd/ :
)dd: ;
;dd; <
}ee 
thisgg 
.gg 
SetArraygg 
(gg 
newArraygg &
)gg& '
;gg' (
thishh 
.hh 
	FreeArrayhh 
(hh 
oldArrayhh '
)hh' (
;hh( )
}ii 
returnjj 
thisjj 
;jj 
}kk 	
publicmm 
overridemm 
boolmm 
HasArraymm %
=>mm& (
truemm) -
;mm- .
publicoo 
overrideoo 
byteoo 
[oo 
]oo 
Arrayoo $
{pp 	
getqq 
{rr 
thisss 
.ss 
EnsureAccessibless %
(ss% &
)ss& '
;ss' (
returntt 
thistt 
.tt 
arraytt !
;tt! "
}uu 
}vv 	
publicxx 
overridexx 
intxx 
ArrayOffsetxx '
=>xx( *
$numxx+ ,
;xx, -
publiczz 
overridezz 
boolzz 
HasMemoryAddresszz -
=>zz. 0
truezz1 5
;zz5 6
public|| 
override|| 
ref|| 
byte||  $
GetPinnableMemoryAddress||! 9
(||9 :
)||: ;
{}} 	
this~~ 
.~~ 
EnsureAccessible~~ !
(~~! "
)~~" #
;~~# $
return 
ref 
this 
. 
array !
[! "
$num" #
]# $
;$ %
}
ÄÄ 	
public
ÇÇ 
override
ÇÇ 
IntPtr
ÇÇ #
AddressOfPinnedMemory
ÇÇ 4
(
ÇÇ4 5
)
ÇÇ5 6
=>
ÇÇ7 9
IntPtr
ÇÇ: @
.
ÇÇ@ A
Zero
ÇÇA E
;
ÇÇE F
public
ÑÑ 
override
ÑÑ 
IByteBuffer
ÑÑ #
GetBytes
ÑÑ$ ,
(
ÑÑ, -
int
ÑÑ- 0
index
ÑÑ1 6
,
ÑÑ6 7
IByteBuffer
ÑÑ8 C
dst
ÑÑD G
,
ÑÑG H
int
ÑÑI L
dstIndex
ÑÑM U
,
ÑÑU V
int
ÑÑW Z
length
ÑÑ[ a
)
ÑÑa b
{
ÖÖ 	
this
ÜÜ 
.
ÜÜ 
CheckDstIndex
ÜÜ 
(
ÜÜ 
index
ÜÜ $
,
ÜÜ$ %
length
ÜÜ& ,
,
ÜÜ, -
dstIndex
ÜÜ. 6
,
ÜÜ6 7
dst
ÜÜ8 ;
.
ÜÜ; <
Capacity
ÜÜ< D
)
ÜÜD E
;
ÜÜE F
if
áá 
(
áá 
dst
áá 
.
áá 
HasArray
áá 
)
áá 
{
àà 
this
ââ 
.
ââ 
GetBytes
ââ 
(
ââ 
index
ââ #
,
ââ# $
dst
ââ% (
.
ââ( )
Array
ââ) .
,
ââ. /
dst
ââ0 3
.
ââ3 4
ArrayOffset
ââ4 ?
+
ââ@ A
dstIndex
ââB J
,
ââJ K
length
ââL R
)
ââR S
;
ââS T
}
ää 
else
ãã 
{
åå 
dst
çç 
.
çç 
SetBytes
çç 
(
çç 
dstIndex
çç %
,
çç% &
this
çç' +
.
çç+ ,
array
çç, 1
,
çç1 2
index
çç3 8
,
çç8 9
length
çç: @
)
çç@ A
;
ççA B
}
éé 
return
êê 
this
êê 
;
êê 
}
ëë 	
public
ìì 
override
ìì 
IByteBuffer
ìì #
GetBytes
ìì$ ,
(
ìì, -
int
ìì- 0
index
ìì1 6
,
ìì6 7
byte
ìì8 <
[
ìì< =
]
ìì= >
dst
ìì? B
,
ììB C
int
ììD G
dstIndex
ììH P
,
ììP Q
int
ììR U
length
ììV \
)
ìì\ ]
{
îî 	
this
ïï 
.
ïï 
CheckDstIndex
ïï 
(
ïï 
index
ïï $
,
ïï$ %
length
ïï& ,
,
ïï, -
dstIndex
ïï. 6
,
ïï6 7
dst
ïï8 ;
.
ïï; <
Length
ïï< B
)
ïïB C
;
ïïC D
PlatformDependent
ññ 
.
ññ 

CopyMemory
ññ (
(
ññ( )
this
ññ) -
.
ññ- .
array
ññ. 3
,
ññ3 4
index
ññ5 :
,
ññ: ;
dst
ññ< ?
,
ññ? @
dstIndex
ññA I
,
ññI J
length
ññK Q
)
ññQ R
;
ññR S
return
óó 
this
óó 
;
óó 
}
òò 	
public
öö 
override
öö 
IByteBuffer
öö #
GetBytes
öö$ ,
(
öö, -
int
öö- 0
index
öö1 6
,
öö6 7
Stream
öö8 >
destination
öö? J
,
ööJ K
int
ööL O
length
ööP V
)
ööV W
{
õõ 	
this
úú 
.
úú 
EnsureAccessible
úú !
(
úú! "
)
úú" #
;
úú# $
destination
ùù 
.
ùù 
Write
ùù 
(
ùù 
this
ùù "
.
ùù" #
Array
ùù# (
,
ùù( )
this
ùù* .
.
ùù. /
ArrayOffset
ùù/ :
+
ùù; <
index
ùù= B
,
ùùB C
length
ùùD J
)
ùùJ K
;
ùùK L
return
ûû 
this
ûû 
;
ûû 
}
üü 	
public
°° 
override
°° 
IByteBuffer
°° #
SetBytes
°°$ ,
(
°°, -
int
°°- 0
index
°°1 6
,
°°6 7
IByteBuffer
°°8 C
src
°°D G
,
°°G H
int
°°I L
srcIndex
°°M U
,
°°U V
int
°°W Z
length
°°[ a
)
°°a b
{
¢¢ 	
this
££ 
.
££ 
CheckSrcIndex
££ 
(
££ 
index
££ $
,
££$ %
length
££& ,
,
££, -
srcIndex
££. 6
,
££6 7
src
££8 ;
.
££; <
Capacity
££< D
)
££D E
;
££E F
if
§§ 
(
§§ 
src
§§ 
.
§§ 
HasArray
§§ 
)
§§ 
{
•• 
this
¶¶ 
.
¶¶ 
SetBytes
¶¶ 
(
¶¶ 
index
¶¶ #
,
¶¶# $
src
¶¶% (
.
¶¶( )
Array
¶¶) .
,
¶¶. /
src
¶¶0 3
.
¶¶3 4
ArrayOffset
¶¶4 ?
+
¶¶@ A
srcIndex
¶¶B J
,
¶¶J K
length
¶¶L R
)
¶¶R S
;
¶¶S T
}
ßß 
else
®® 
{
©© 
src
™™ 
.
™™ 
GetBytes
™™ 
(
™™ 
srcIndex
™™ %
,
™™% &
this
™™' +
.
™™+ ,
array
™™, 1
,
™™1 2
index
™™3 8
,
™™8 9
length
™™: @
)
™™@ A
;
™™A B
}
´´ 
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
SetBytes
ØØ$ ,
(
ØØ, -
int
ØØ- 0
index
ØØ1 6
,
ØØ6 7
byte
ØØ8 <
[
ØØ< =
]
ØØ= >
src
ØØ? B
,
ØØB C
int
ØØD G
srcIndex
ØØH P
,
ØØP Q
int
ØØR U
length
ØØV \
)
ØØ\ ]
{
∞∞ 	
this
±± 
.
±± 
CheckSrcIndex
±± 
(
±± 
index
±± $
,
±±$ %
length
±±& ,
,
±±, -
srcIndex
±±. 6
,
±±6 7
src
±±8 ;
.
±±; <
Length
±±< B
)
±±B C
;
±±C D
PlatformDependent
≤≤ 
.
≤≤ 

CopyMemory
≤≤ (
(
≤≤( )
src
≤≤) ,
,
≤≤, -
srcIndex
≤≤. 6
,
≤≤6 7
this
≤≤8 <
.
≤≤< =
array
≤≤= B
,
≤≤B C
index
≤≤D I
,
≤≤I J
length
≤≤K Q
)
≤≤Q R
;
≤≤R S
return
≥≥ 
this
≥≥ 
;
≥≥ 
}
¥¥ 	
public
∂∂ 
override
∂∂ 
async
∂∂ 
Task
∂∂ "
<
∂∂" #
int
∂∂# &
>
∂∂& '
SetBytesAsync
∂∂( 5
(
∂∂5 6
int
∂∂6 9
index
∂∂: ?
,
∂∂? @
Stream
∂∂A G
src
∂∂H K
,
∂∂K L
int
∂∂M P
length
∂∂Q W
,
∂∂W X
CancellationToken
∂∂Y j
cancellationToken
∂∂k |
)
∂∂| }
{
∑∑ 	
this
∏∏ 
.
∏∏ 
EnsureAccessible
∏∏ !
(
∏∏! "
)
∏∏" #
;
∏∏# $
int
ππ 
	readTotal
ππ 
=
ππ 
$num
ππ 
;
ππ 
int
∫∫ 
read
∫∫ 
;
∫∫ 
int
ªª 
offset
ªª 
=
ªª 
this
ªª 
.
ªª 
ArrayOffset
ªª )
+
ªª* +
index
ªª, 1
;
ªª1 2
do
ºº 
{
ΩΩ 
read
ææ 
=
ææ 
await
ææ 
src
ææ  
.
ææ  !
	ReadAsync
ææ! *
(
ææ* +
this
ææ+ /
.
ææ/ 0
Array
ææ0 5
,
ææ5 6
offset
ææ7 =
+
ææ> ?
	readTotal
ææ@ I
,
ææI J
length
ææK Q
-
ææR S
	readTotal
ææT ]
,
ææ] ^
cancellationToken
ææ_ p
)
ææp q
;
ææq r
	readTotal
øø 
+=
øø 
read
øø !
;
øø! "
}
¿¿ 
while
¡¡ 
(
¡¡ 
read
¡¡ 
>
¡¡ 
$num
¡¡ 
&&
¡¡ 
	readTotal
¡¡ (
<
¡¡) *
length
¡¡+ 1
)
¡¡1 2
;
¡¡2 3
return
√√ 
	readTotal
√√ 
;
√√ 
}
ƒƒ 	
public
∆∆ 
override
∆∆ 
int
∆∆ 
IoBufferCount
∆∆ )
=>
∆∆* ,
$num
∆∆- .
;
∆∆. /
public
»» 
override
»» 
ArraySegment
»» $
<
»»$ %
byte
»»% )
>
»») *
GetIoBuffer
»»+ 6
(
»»6 7
int
»»7 :
index
»»; @
,
»»@ A
int
»»B E
length
»»F L
)
»»L M
{
…… 	
this
   
.
   
EnsureAccessible
   !
(
  ! "
)
  " #
;
  # $
return
ÀÀ 
new
ÀÀ 
ArraySegment
ÀÀ #
<
ÀÀ# $
byte
ÀÀ$ (
>
ÀÀ( )
(
ÀÀ) *
this
ÀÀ* .
.
ÀÀ. /
array
ÀÀ/ 4
,
ÀÀ4 5
index
ÀÀ6 ;
,
ÀÀ; <
length
ÀÀ= C
)
ÀÀC D
;
ÀÀD E
}
ÃÃ 	
public
ŒŒ 
override
ŒŒ 
ArraySegment
ŒŒ $
<
ŒŒ$ %
byte
ŒŒ% )
>
ŒŒ) *
[
ŒŒ* +
]
ŒŒ+ ,
GetIoBuffers
ŒŒ- 9
(
ŒŒ9 :
int
ŒŒ: =
index
ŒŒ> C
,
ŒŒC D
int
ŒŒE H
length
ŒŒI O
)
ŒŒO P
=>
ŒŒQ S
new
ŒŒT W
[
ŒŒW X
]
ŒŒX Y
{
ŒŒZ [
this
ŒŒ\ `
.
ŒŒ` a
GetIoBuffer
ŒŒa l
(
ŒŒl m
index
ŒŒm r
,
ŒŒr s
length
ŒŒt z
)
ŒŒz {
}
ŒŒ| }
;
ŒŒ} ~
public
–– 
override
–– 
byte
–– 
GetByte
–– $
(
––$ %
int
––% (
index
––) .
)
––. /
{
—— 	
this
““ 
.
““ 
EnsureAccessible
““ !
(
““! "
)
““" #
;
““# $
return
”” 
this
”” 
.
”” 
_GetByte
””  
(
””  !
index
””! &
)
””& '
;
””' (
}
‘‘ 	
	protected
÷÷ 
internal
÷÷ 
override
÷÷ #
byte
÷÷$ (
_GetByte
÷÷) 1
(
÷÷1 2
int
÷÷2 5
index
÷÷6 ;
)
÷÷; <
=>
÷÷= ? 
HeapByteBufferUtil
÷÷@ R
.
÷÷R S
GetByte
÷÷S Z
(
÷÷Z [
this
÷÷[ _
.
÷÷_ `
array
÷÷` e
,
÷÷e f
index
÷÷g l
)
÷÷l m
;
÷÷m n
public
ÿÿ 
override
ÿÿ 
IByteBuffer
ÿÿ #
SetZero
ÿÿ$ +
(
ÿÿ+ ,
int
ÿÿ, /
index
ÿÿ0 5
,
ÿÿ5 6
int
ÿÿ7 :
length
ÿÿ; A
)
ÿÿA B
{
ŸŸ 	
this
⁄⁄ 
.
⁄⁄ 

CheckIndex
⁄⁄ 
(
⁄⁄ 
index
⁄⁄ !
,
⁄⁄! "
length
⁄⁄# )
)
⁄⁄) *
;
⁄⁄* +
PlatformDependent
€€ 
.
€€ 
Clear
€€ #
(
€€# $
this
€€$ (
.
€€( )
array
€€) .
,
€€. /
index
€€0 5
,
€€5 6
length
€€7 =
)
€€= >
;
€€> ?
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
›› 	
public
ﬂﬂ 
override
ﬂﬂ 
short
ﬂﬂ 
GetShort
ﬂﬂ &
(
ﬂﬂ& '
int
ﬂﬂ' *
index
ﬂﬂ+ 0
)
ﬂﬂ0 1
{
‡‡ 	
this
·· 
.
·· 
EnsureAccessible
·· !
(
··! "
)
··" #
;
··# $
return
‚‚ 
this
‚‚ 
.
‚‚ 
	_GetShort
‚‚ !
(
‚‚! "
index
‚‚" '
)
‚‚' (
;
‚‚( )
}
„„ 	
	protected
ÂÂ 
internal
ÂÂ 
override
ÂÂ #
short
ÂÂ$ )
	_GetShort
ÂÂ* 3
(
ÂÂ3 4
int
ÂÂ4 7
index
ÂÂ8 =
)
ÂÂ= >
=>
ÂÂ? A 
HeapByteBufferUtil
ÂÂB T
.
ÂÂT U
GetShort
ÂÂU ]
(
ÂÂ] ^
this
ÂÂ^ b
.
ÂÂb c
array
ÂÂc h
,
ÂÂh i
index
ÂÂj o
)
ÂÂo p
;
ÂÂp q
public
ÁÁ 
override
ÁÁ 
short
ÁÁ 

GetShortLE
ÁÁ (
(
ÁÁ( )
int
ÁÁ) ,
index
ÁÁ- 2
)
ÁÁ2 3
{
ËË 	
this
ÈÈ 
.
ÈÈ 
EnsureAccessible
ÈÈ !
(
ÈÈ! "
)
ÈÈ" #
;
ÈÈ# $
return
ÍÍ 
this
ÍÍ 
.
ÍÍ 
_GetShortLE
ÍÍ #
(
ÍÍ# $
index
ÍÍ$ )
)
ÍÍ) *
;
ÍÍ* +
}
ÎÎ 	
	protected
ÌÌ 
internal
ÌÌ 
override
ÌÌ #
short
ÌÌ$ )
_GetShortLE
ÌÌ* 5
(
ÌÌ5 6
int
ÌÌ6 9
index
ÌÌ: ?
)
ÌÌ? @
=>
ÌÌA C 
HeapByteBufferUtil
ÌÌD V
.
ÌÌV W

GetShortLE
ÌÌW a
(
ÌÌa b
this
ÌÌb f
.
ÌÌf g
array
ÌÌg l
,
ÌÌl m
index
ÌÌn s
)
ÌÌs t
;
ÌÌt u
public
ÔÔ 
override
ÔÔ 
int
ÔÔ 
GetUnsignedMedium
ÔÔ -
(
ÔÔ- .
int
ÔÔ. 1
index
ÔÔ2 7
)
ÔÔ7 8
{
 	
this
ÒÒ 
.
ÒÒ 
EnsureAccessible
ÒÒ !
(
ÒÒ! "
)
ÒÒ" #
;
ÒÒ# $
return
ÚÚ 
this
ÚÚ 
.
ÚÚ  
_GetUnsignedMedium
ÚÚ *
(
ÚÚ* +
index
ÚÚ+ 0
)
ÚÚ0 1
;
ÚÚ1 2
}
ÛÛ 	
	protected
ıı 
internal
ıı 
override
ıı #
int
ıı$ ' 
_GetUnsignedMedium
ıı( :
(
ıı: ;
int
ıı; >
index
ıı? D
)
ııD E
=>
ııF H 
HeapByteBufferUtil
ııI [
.
ıı[ \
GetUnsignedMedium
ıı\ m
(
ıım n
this
ıın r
.
ıır s
array
ııs x
,
ııx y
index
ıız 
)ıı Ä
;ııÄ Å
public
˜˜ 
override
˜˜ 
int
˜˜ !
GetUnsignedMediumLE
˜˜ /
(
˜˜/ 0
int
˜˜0 3
index
˜˜4 9
)
˜˜9 :
{
¯¯ 	
this
˘˘ 
.
˘˘ 
EnsureAccessible
˘˘ !
(
˘˘! "
)
˘˘" #
;
˘˘# $
return
˙˙ 
this
˙˙ 
.
˙˙ "
_GetUnsignedMediumLE
˙˙ ,
(
˙˙, -
index
˙˙- 2
)
˙˙2 3
;
˙˙3 4
}
˚˚ 	
	protected
˝˝ 
internal
˝˝ 
override
˝˝ #
int
˝˝$ '"
_GetUnsignedMediumLE
˝˝( <
(
˝˝< =
int
˝˝= @
index
˝˝A F
)
˝˝F G
=>
˝˝H J 
HeapByteBufferUtil
˝˝K ]
.
˝˝] ^!
GetUnsignedMediumLE
˝˝^ q
(
˝˝q r
this
˝˝r v
.
˝˝v w
array
˝˝w |
,
˝˝| }
index˝˝~ É
)˝˝É Ñ
;˝˝Ñ Ö
public
ˇˇ 
override
ˇˇ 
int
ˇˇ 
GetInt
ˇˇ "
(
ˇˇ" #
int
ˇˇ# &
index
ˇˇ' ,
)
ˇˇ, -
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
EnsureAccessible
ÅÅ !
(
ÅÅ! "
)
ÅÅ" #
;
ÅÅ# $
return
ÇÇ 
this
ÇÇ 
.
ÇÇ 
_GetInt
ÇÇ 
(
ÇÇ  
index
ÇÇ  %
)
ÇÇ% &
;
ÇÇ& '
}
ÉÉ 	
	protected
ÖÖ 
internal
ÖÖ 
override
ÖÖ #
int
ÖÖ$ '
_GetInt
ÖÖ( /
(
ÖÖ/ 0
int
ÖÖ0 3
index
ÖÖ4 9
)
ÖÖ9 :
=>
ÖÖ; = 
HeapByteBufferUtil
ÖÖ> P
.
ÖÖP Q
GetInt
ÖÖQ W
(
ÖÖW X
this
ÖÖX \
.
ÖÖ\ ]
array
ÖÖ] b
,
ÖÖb c
index
ÖÖd i
)
ÖÖi j
;
ÖÖj k
public
áá 
override
áá 
int
áá 
GetIntLE
áá $
(
áá$ %
int
áá% (
index
áá) .
)
áá. /
{
àà 	
this
ââ 
.
ââ 
EnsureAccessible
ââ !
(
ââ! "
)
ââ" #
;
ââ# $
return
ää 
this
ää 
.
ää 
	_GetIntLE
ää !
(
ää! "
index
ää" '
)
ää' (
;
ää( )
}
ãã 	
	protected
çç 
internal
çç 
override
çç #
int
çç$ '
	_GetIntLE
çç( 1
(
çç1 2
int
çç2 5
index
çç6 ;
)
çç; <
=>
çç= ? 
HeapByteBufferUtil
çç@ R
.
ççR S
GetIntLE
ççS [
(
çç[ \
this
çç\ `
.
çç` a
array
çça f
,
ççf g
index
ççh m
)
ççm n
;
ççn o
public
èè 
override
èè 
long
èè 
GetLong
èè $
(
èè$ %
int
èè% (
index
èè) .
)
èè. /
{
êê 	
this
ëë 
.
ëë 
EnsureAccessible
ëë !
(
ëë! "
)
ëë" #
;
ëë# $
return
íí 
this
íí 
.
íí 
_GetLong
íí  
(
íí  !
index
íí! &
)
íí& '
;
íí' (
}
ìì 	
	protected
ïï 
internal
ïï 
override
ïï #
long
ïï$ (
_GetLong
ïï) 1
(
ïï1 2
int
ïï2 5
index
ïï6 ;
)
ïï; <
=>
ïï= ? 
HeapByteBufferUtil
ïï@ R
.
ïïR S
GetLong
ïïS Z
(
ïïZ [
this
ïï[ _
.
ïï_ `
array
ïï` e
,
ïïe f
index
ïïg l
)
ïïl m
;
ïïm n
public
óó 
override
óó 
long
óó 
	GetLongLE
óó &
(
óó& '
int
óó' *
index
óó+ 0
)
óó0 1
{
òò 	
this
ôô 
.
ôô 
EnsureAccessible
ôô !
(
ôô! "
)
ôô" #
;
ôô# $
return
öö 
this
öö 
.
öö 

_GetLongLE
öö "
(
öö" #
index
öö# (
)
öö( )
;
öö) *
}
õõ 	
	protected
ùù 
internal
ùù 
override
ùù #
long
ùù$ (

_GetLongLE
ùù) 3
(
ùù3 4
int
ùù4 7
index
ùù8 =
)
ùù= >
=>
ùù? A 
HeapByteBufferUtil
ùùB T
.
ùùT U
	GetLongLE
ùùU ^
(
ùù^ _
this
ùù_ c
.
ùùc d
array
ùùd i
,
ùùi j
index
ùùk p
)
ùùp q
;
ùùq r
public
üü 
override
üü 
IByteBuffer
üü #
SetByte
üü$ +
(
üü+ ,
int
üü, /
index
üü0 5
,
üü5 6
int
üü7 :
value
üü; @
)
üü@ A
{
†† 	
this
°° 
.
°° 
EnsureAccessible
°° !
(
°°! "
)
°°" #
;
°°# $
this
¢¢ 
.
¢¢ 
_SetByte
¢¢ 
(
¢¢ 
index
¢¢ 
,
¢¢  
value
¢¢! &
)
¢¢& '
;
¢¢' (
return
££ 
this
££ 
;
££ 
}
§§ 	
	protected
¶¶ 
internal
¶¶ 
override
¶¶ #
void
¶¶$ (
_SetByte
¶¶) 1
(
¶¶1 2
int
¶¶2 5
index
¶¶6 ;
,
¶¶; <
int
¶¶= @
value
¶¶A F
)
¶¶F G
=>
¶¶H J 
HeapByteBufferUtil
¶¶K ]
.
¶¶] ^
SetByte
¶¶^ e
(
¶¶e f
this
¶¶f j
.
¶¶j k
array
¶¶k p
,
¶¶p q
index
¶¶r w
,
¶¶w x
value
¶¶y ~
)
¶¶~ 
;¶¶ Ä
public
®® 
override
®® 
IByteBuffer
®® #
SetShort
®®$ ,
(
®®, -
int
®®- 0
index
®®1 6
,
®®6 7
int
®®8 ;
value
®®< A
)
®®A B
{
©© 	
this
™™ 
.
™™ 
EnsureAccessible
™™ !
(
™™! "
)
™™" #
;
™™# $
this
´´ 
.
´´ 
	_SetShort
´´ 
(
´´ 
index
´´  
,
´´  !
value
´´" '
)
´´' (
;
´´( )
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
	protected
ØØ 
internal
ØØ 
override
ØØ #
void
ØØ$ (
	_SetShort
ØØ) 2
(
ØØ2 3
int
ØØ3 6
index
ØØ7 <
,
ØØ< =
int
ØØ> A
value
ØØB G
)
ØØG H
=>
ØØI K 
HeapByteBufferUtil
ØØL ^
.
ØØ^ _
SetShort
ØØ_ g
(
ØØg h
this
ØØh l
.
ØØl m
array
ØØm r
,
ØØr s
index
ØØt y
,
ØØy z
valueØØ{ Ä
)ØØÄ Å
;ØØÅ Ç
public
±± 
override
±± 
IByteBuffer
±± #

SetShortLE
±±$ .
(
±±. /
int
±±/ 2
index
±±3 8
,
±±8 9
int
±±: =
value
±±> C
)
±±C D
{
≤≤ 	
this
≥≥ 
.
≥≥ 
EnsureAccessible
≥≥ !
(
≥≥! "
)
≥≥" #
;
≥≥# $
this
¥¥ 
.
¥¥ 
_SetShortLE
¥¥ 
(
¥¥ 
index
¥¥ "
,
¥¥" #
value
¥¥$ )
)
¥¥) *
;
¥¥* +
return
µµ 
this
µµ 
;
µµ 
}
∂∂ 	
	protected
∏∏ 
internal
∏∏ 
override
∏∏ #
void
∏∏$ (
_SetShortLE
∏∏) 4
(
∏∏4 5
int
∏∏5 8
index
∏∏9 >
,
∏∏> ?
int
∏∏@ C
value
∏∏D I
)
∏∏I J
=>
∏∏K M 
HeapByteBufferUtil
∏∏N `
.
∏∏` a

SetShortLE
∏∏a k
(
∏∏k l
this
∏∏l p
.
∏∏p q
array
∏∏q v
,
∏∏v w
index
∏∏x }
,
∏∏} ~
value∏∏ Ñ
)∏∏Ñ Ö
;∏∏Ö Ü
public
∫∫ 
override
∫∫ 
IByteBuffer
∫∫ #
	SetMedium
∫∫$ -
(
∫∫- .
int
∫∫. 1
index
∫∫2 7
,
∫∫7 8
int
∫∫9 <
value
∫∫= B
)
∫∫B C
{
ªª 	
this
ºº 
.
ºº 
EnsureAccessible
ºº !
(
ºº! "
)
ºº" #
;
ºº# $
this
ΩΩ 
.
ΩΩ 

_SetMedium
ΩΩ 
(
ΩΩ 
index
ΩΩ !
,
ΩΩ! "
value
ΩΩ# (
)
ΩΩ( )
;
ΩΩ) *
return
ææ 
this
ææ 
;
ææ 
}
øø 	
	protected
¡¡ 
internal
¡¡ 
override
¡¡ #
void
¡¡$ (

_SetMedium
¡¡) 3
(
¡¡3 4
int
¡¡4 7
index
¡¡8 =
,
¡¡= >
int
¡¡? B
value
¡¡C H
)
¡¡H I
=>
¡¡J L 
HeapByteBufferUtil
¡¡M _
.
¡¡_ `
	SetMedium
¡¡` i
(
¡¡i j
this
¡¡j n
.
¡¡n o
array
¡¡o t
,
¡¡t u
index
¡¡v {
,
¡¡{ |
value¡¡} Ç
)¡¡Ç É
;¡¡É Ñ
public
√√ 
override
√√ 
IByteBuffer
√√ #
SetMediumLE
√√$ /
(
√√/ 0
int
√√0 3
index
√√4 9
,
√√9 :
int
√√; >
value
√√? D
)
√√D E
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
EnsureAccessible
≈≈ !
(
≈≈! "
)
≈≈" #
;
≈≈# $
this
∆∆ 
.
∆∆ 
_SetMediumLE
∆∆ 
(
∆∆ 
index
∆∆ #
,
∆∆# $
value
∆∆% *
)
∆∆* +
;
∆∆+ ,
return
«« 
this
«« 
;
«« 
}
»» 	
	protected
   
internal
   
override
   #
void
  $ (
_SetMediumLE
  ) 5
(
  5 6
int
  6 9
index
  : ?
,
  ? @
int
  A D
value
  E J
)
  J K
=>
  L N 
HeapByteBufferUtil
  O a
.
  a b
SetMediumLE
  b m
(
  m n
this
  n r
.
  r s
array
  s x
,
  x y
index
  z 
,   Ä
value  Å Ü
)  Ü á
;  á à
public
ÃÃ 
override
ÃÃ 
IByteBuffer
ÃÃ #
SetInt
ÃÃ$ *
(
ÃÃ* +
int
ÃÃ+ .
index
ÃÃ/ 4
,
ÃÃ4 5
int
ÃÃ6 9
value
ÃÃ: ?
)
ÃÃ? @
{
ÕÕ 	
this
ŒŒ 
.
ŒŒ 
EnsureAccessible
ŒŒ !
(
ŒŒ! "
)
ŒŒ" #
;
ŒŒ# $
this
œœ 
.
œœ 
_SetInt
œœ 
(
œœ 
index
œœ 
,
œœ 
value
œœ  %
)
œœ% &
;
œœ& '
return
–– 
this
–– 
;
–– 
}
—— 	
	protected
”” 
internal
”” 
override
”” #
void
””$ (
_SetInt
””) 0
(
””0 1
int
””1 4
index
””5 :
,
””: ;
int
””< ?
value
””@ E
)
””E F
=>
””G I 
HeapByteBufferUtil
””J \
.
””\ ]
SetInt
””] c
(
””c d
this
””d h
.
””h i
array
””i n
,
””n o
index
””p u
,
””u v
value
””w |
)
””| }
;
””} ~
public
’’ 
override
’’ 
IByteBuffer
’’ #
SetIntLE
’’$ ,
(
’’, -
int
’’- 0
index
’’1 6
,
’’6 7
int
’’8 ;
value
’’< A
)
’’A B
{
÷÷ 	
this
◊◊ 
.
◊◊ 
EnsureAccessible
◊◊ !
(
◊◊! "
)
◊◊" #
;
◊◊# $
this
ÿÿ 
.
ÿÿ 
	_SetIntLE
ÿÿ 
(
ÿÿ 
index
ÿÿ  
,
ÿÿ  !
value
ÿÿ" '
)
ÿÿ' (
;
ÿÿ( )
return
ŸŸ 
this
ŸŸ 
;
ŸŸ 
}
⁄⁄ 	
	protected
‹‹ 
internal
‹‹ 
override
‹‹ #
void
‹‹$ (
	_SetIntLE
‹‹) 2
(
‹‹2 3
int
‹‹3 6
index
‹‹7 <
,
‹‹< =
int
‹‹> A
value
‹‹B G
)
‹‹G H
=>
‹‹I K 
HeapByteBufferUtil
‹‹L ^
.
‹‹^ _
SetIntLE
‹‹_ g
(
‹‹g h
this
‹‹h l
.
‹‹l m
array
‹‹m r
,
‹‹r s
index
‹‹t y
,
‹‹y z
value‹‹{ Ä
)‹‹Ä Å
;‹‹Å Ç
public
ﬁﬁ 
override
ﬁﬁ 
IByteBuffer
ﬁﬁ #
SetLong
ﬁﬁ$ +
(
ﬁﬁ+ ,
int
ﬁﬁ, /
index
ﬁﬁ0 5
,
ﬁﬁ5 6
long
ﬁﬁ7 ;
value
ﬁﬁ< A
)
ﬁﬁA B
{
ﬂﬂ 	
this
‡‡ 
.
‡‡ 
EnsureAccessible
‡‡ !
(
‡‡! "
)
‡‡" #
;
‡‡# $
this
·· 
.
·· 
_SetLong
·· 
(
·· 
index
·· 
,
··  
value
··! &
)
··& '
;
··' (
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
„„ 	
	protected
ÂÂ 
internal
ÂÂ 
override
ÂÂ #
void
ÂÂ$ (
_SetLong
ÂÂ) 1
(
ÂÂ1 2
int
ÂÂ2 5
index
ÂÂ6 ;
,
ÂÂ; <
long
ÂÂ= A
value
ÂÂB G
)
ÂÂG H
=>
ÂÂI K 
HeapByteBufferUtil
ÂÂL ^
.
ÂÂ^ _
SetLong
ÂÂ_ f
(
ÂÂf g
this
ÂÂg k
.
ÂÂk l
array
ÂÂl q
,
ÂÂq r
index
ÂÂs x
,
ÂÂx y
value
ÂÂz 
)ÂÂ Ä
;ÂÂÄ Å
public
ÁÁ 
override
ÁÁ 
IByteBuffer
ÁÁ #
	SetLongLE
ÁÁ$ -
(
ÁÁ- .
int
ÁÁ. 1
index
ÁÁ2 7
,
ÁÁ7 8
long
ÁÁ9 =
value
ÁÁ> C
)
ÁÁC D
{
ËË 	
this
ÈÈ 
.
ÈÈ 
EnsureAccessible
ÈÈ !
(
ÈÈ! "
)
ÈÈ" #
;
ÈÈ# $
this
ÍÍ 
.
ÍÍ 

_SetLongLE
ÍÍ 
(
ÍÍ 
index
ÍÍ !
,
ÍÍ! "
value
ÍÍ# (
)
ÍÍ( )
;
ÍÍ) *
return
ÎÎ 
this
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
	protected
ÓÓ 
internal
ÓÓ 
override
ÓÓ #
void
ÓÓ$ (

_SetLongLE
ÓÓ) 3
(
ÓÓ3 4
int
ÓÓ4 7
index
ÓÓ8 =
,
ÓÓ= >
long
ÓÓ? C
value
ÓÓD I
)
ÓÓI J
=>
ÓÓK M 
HeapByteBufferUtil
ÓÓN `
.
ÓÓ` a
	SetLongLE
ÓÓa j
(
ÓÓj k
this
ÓÓk o
.
ÓÓo p
array
ÓÓp u
,
ÓÓu v
index
ÓÓw |
,
ÓÓ| }
valueÓÓ~ É
)ÓÓÉ Ñ
;ÓÓÑ Ö
public
 
override
 
IByteBuffer
 #
Copy
$ (
(
( )
int
) ,
index
- 2
,
2 3
int
4 7
length
8 >
)
> ?
{
ÒÒ 	
this
ÚÚ 
.
ÚÚ 

CheckIndex
ÚÚ 
(
ÚÚ 
index
ÚÚ !
,
ÚÚ! "
length
ÚÚ# )
)
ÚÚ) *
;
ÚÚ* +
var
ÛÛ 
copiedArray
ÛÛ 
=
ÛÛ 
new
ÛÛ !
byte
ÛÛ" &
[
ÛÛ& '
length
ÛÛ' -
]
ÛÛ- .
;
ÛÛ. /
PlatformDependent
ÙÙ 
.
ÙÙ 

CopyMemory
ÙÙ (
(
ÙÙ( )
this
ÙÙ) -
.
ÙÙ- .
array
ÙÙ. 3
,
ÙÙ3 4
index
ÙÙ5 :
,
ÙÙ: ;
copiedArray
ÙÙ< G
,
ÙÙG H
$num
ÙÙI J
,
ÙÙJ K
length
ÙÙL R
)
ÙÙR S
;
ÙÙS T
return
ˆˆ 
new
ˆˆ $
UnpooledHeapByteBuffer
ˆˆ -
(
ˆˆ- .
this
ˆˆ. 2
.
ˆˆ2 3
	Allocator
ˆˆ3 <
,
ˆˆ< =
copiedArray
ˆˆ> I
,
ˆˆI J
this
ˆˆK O
.
ˆˆO P
MaxCapacity
ˆˆP [
)
ˆˆ[ \
;
ˆˆ\ ]
}
˜˜ 	
	protected
˘˘ 
internal
˘˘ 
override
˘˘ #
void
˘˘$ (

Deallocate
˘˘) 3
(
˘˘3 4
)
˘˘4 5
{
˙˙ 	
this
˚˚ 
.
˚˚ 
	FreeArray
˚˚ 
(
˚˚ 
this
˚˚ 
.
˚˚  
array
˚˚  %
)
˚˚% &
;
˚˚& '
this
¸¸ 
.
¸¸ 
array
¸¸ 
=
¸¸ 
null
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
override
ˇˇ 
IByteBuffer
ˇˇ #
Unwrap
ˇˇ$ *
(
ˇˇ* +
)
ˇˇ+ ,
=>
ˇˇ- /
null
ˇˇ0 4
;
ˇˇ4 5
}
ÄÄ 
}ÅÅ ËP
kC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledSlicedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	$
UnpooledSlicedByteBuffer
 "
:# $,
 AbstractUnpooledSlicedByteBuffer% E
{ 
internal $
UnpooledSlicedByteBuffer )
() *
AbstractByteBuffer* <
buffer= C
,C D
intE H
indexI N
,N O
intP S
lengthT Z
)Z [
:		 
base		 
(		 
buffer		 
,		 
index		  
,		  !
length		" (
)		( )
{

 	
} 	
public 
override 
int 
Capacity $
=>% '
this( ,
., -
MaxCapacity- 8
;8 9
	protected 
AbstractByteBuffer $

UnwrapCore% /
(/ 0
)0 1
=>2 4
(5 6
AbstractByteBuffer6 H
)H I
thisI M
.M N
UnwrapN T
(T U
)U V
;V W
	protected 
internal 
override #
byte$ (
_GetByte) 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
_GetByteR Z
(Z [
this[ _
._ `
Idx` c
(c d
indexd i
)i j
)j k
;k l
	protected 
internal 
override #
short$ )
	_GetShort* 3
(3 4
int4 7
index8 =
)= >
=>? A
thisB F
.F G

UnwrapCoreG Q
(Q R
)R S
.S T
	_GetShortT ]
(] ^
this^ b
.b c
Idxc f
(f g
indexg l
)l m
)m n
;n o
	protected 
internal 
override #
short$ )
_GetShortLE* 5
(5 6
int6 9
index: ?
)? @
=>A C
thisD H
.H I

UnwrapCoreI S
(S T
)T U
.U V
_GetShortLEV a
(a b
thisb f
.f g
Idxg j
(j k
indexk p
)p q
)q r
;r s
	protected 
internal 
override #
int$ '
_GetUnsignedMedium( :
(: ;
int; >
index? D
)D E
=>F H
thisI M
.M N

UnwrapCoreN X
(X Y
)Y Z
.Z [
_GetUnsignedMedium[ m
(m n
thisn r
.r s
Idxs v
(v w
indexw |
)| }
)} ~
;~ 
	protected 
internal 
override #
int$ ' 
_GetUnsignedMediumLE( <
(< =
int= @
indexA F
)F G
=>H J
thisK O
.O P

UnwrapCoreP Z
(Z [
)[ \
.\ ] 
_GetUnsignedMediumLE] q
(q r
thisr v
.v w
Idxw z
(z {
index	{ Ä
)
Ä Å
)
Å Ç
;
Ç É
	protected 
internal 
override #
int$ '
_GetInt( /
(/ 0
int0 3
index4 9
)9 :
=>; =
this> B
.B C

UnwrapCoreC M
(M N
)N O
.O P
_GetIntP W
(W X
thisX \
.\ ]
Idx] `
(` a
indexa f
)f g
)g h
;h i
	protected 
internal 
override #
int$ '
	_GetIntLE( 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
	_GetIntLER [
([ \
this\ `
.` a
Idxa d
(d e
indexe j
)j k
)k l
;l m
	protected 
internal 
override #
long$ (
_GetLong) 1
(1 2
int2 5
index6 ;
); <
=>= ?
this@ D
.D E

UnwrapCoreE O
(O P
)P Q
.Q R
_GetLongR Z
(Z [
this[ _
._ `
Idx` c
(c d
indexd i
)i j
)j k
;k l
	protected!! 
internal!! 
override!! #
long!!$ (

_GetLongLE!!) 3
(!!3 4
int!!4 7
index!!8 =
)!!= >
=>!!? A
this!!B F
.!!F G

UnwrapCore!!G Q
(!!Q R
)!!R S
.!!S T

_GetLongLE!!T ^
(!!^ _
this!!_ c
.!!c d
Idx!!d g
(!!g h
index!!h m
)!!m n
)!!n o
;!!o p
	protected## 
internal## 
override## #
void##$ (
_SetByte##) 1
(##1 2
int##2 5
index##6 ;
,##; <
int##= @
value##A F
)##F G
=>##H J
this##K O
.##O P

UnwrapCore##P Z
(##Z [
)##[ \
.##\ ]
_SetByte##] e
(##e f
this##f j
.##j k
Idx##k n
(##n o
index##o t
)##t u
,##u v
value##w |
)##| }
;##} ~
	protected%% 
internal%% 
override%% #
void%%$ (
	_SetShort%%) 2
(%%2 3
int%%3 6
index%%7 <
,%%< =
int%%> A
value%%B G
)%%G H
=>%%I K
this%%L P
.%%P Q

UnwrapCore%%Q [
(%%[ \
)%%\ ]
.%%] ^
	_SetShort%%^ g
(%%g h
this%%h l
.%%l m
Idx%%m p
(%%p q
index%%q v
)%%v w
,%%w x
value%%y ~
)%%~ 
;	%% Ä
	protected'' 
internal'' 
override'' #
void''$ (
_SetShortLE'') 4
(''4 5
int''5 8
index''9 >
,''> ?
int''@ C
value''D I
)''I J
=>''K M
this''N R
.''R S

UnwrapCore''S ]
(''] ^
)''^ _
.''_ `
_SetShortLE''` k
(''k l
this''l p
.''p q
Idx''q t
(''t u
index''u z
)''z {
,''{ |
value	''} Ç
)
''Ç É
;
''É Ñ
	protected)) 
internal)) 
override)) #
void))$ (

_SetMedium))) 3
())3 4
int))4 7
index))8 =
,))= >
int))? B
value))C H
)))H I
=>))J L
this))M Q
.))Q R

UnwrapCore))R \
())\ ]
)))] ^
.))^ _

_SetMedium))_ i
())i j
this))j n
.))n o
Idx))o r
())r s
index))s x
)))x y
,))y z
value	)){ Ä
)
))Ä Å
;
))Å Ç
	protected++ 
internal++ 
override++ #
void++$ (
_SetMediumLE++) 5
(++5 6
int++6 9
index++: ?
,++? @
int++A D
value++E J
)++J K
=>++L N
this++O S
.++S T

UnwrapCore++T ^
(++^ _
)++_ `
.++` a
_SetMediumLE++a m
(++m n
this++n r
.++r s
Idx++s v
(++v w
index++w |
)++| }
,++} ~
value	++ Ñ
)
++Ñ Ö
;
++Ö Ü
	protected-- 
internal-- 
override-- #
void--$ (
_SetInt--) 0
(--0 1
int--1 4
index--5 :
,--: ;
int--< ?
value--@ E
)--E F
=>--G I
this--J N
.--N O

UnwrapCore--O Y
(--Y Z
)--Z [
.--[ \
_SetInt--\ c
(--c d
this--d h
.--h i
Idx--i l
(--l m
index--m r
)--r s
,--s t
value--u z
)--z {
;--{ |
	protected// 
internal// 
override// #
void//$ (
	_SetIntLE//) 2
(//2 3
int//3 6
index//7 <
,//< =
int//> A
value//B G
)//G H
=>//I K
this//L P
.//P Q

UnwrapCore//Q [
(//[ \
)//\ ]
.//] ^
	_SetIntLE//^ g
(//g h
this//h l
.//l m
Idx//m p
(//p q
index//q v
)//v w
,//w x
value//y ~
)//~ 
;	// Ä
	protected11 
internal11 
override11 #
void11$ (
_SetLong11) 1
(111 2
int112 5
index116 ;
,11; <
long11= A
value11B G
)11G H
=>11I K
this11L P
.11P Q

UnwrapCore11Q [
(11[ \
)11\ ]
.11] ^
_SetLong11^ f
(11f g
this11g k
.11k l
Idx11l o
(11o p
index11p u
)11u v
,11v w
value11x }
)11} ~
;11~ 
	protected33 
internal33 
override33 #
void33$ (

_SetLongLE33) 3
(333 4
int334 7
index338 =
,33= >
long33? C
value33D I
)33I J
=>33K M
this33N R
.33R S

UnwrapCore33S ]
(33] ^
)33^ _
.33_ `

_SetLongLE33` j
(33j k
this33k o
.33o p
Idx33p s
(33s t
index33t y
)33y z
,33z {
value	33| Å
)
33Å Ç
;
33Ç É
}44 
}55 ≤§
qC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnpooledUnsafeDirectByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
public 

unsafe 
class *
UnpooledUnsafeDirectByteBuffer 6
:7 8.
"AbstractReferenceCountedByteBuffer9 [
{ 
readonly  
IByteBufferAllocator %
	allocator& /
;/ 0
int 
capacity 
; 
bool 
	doNotFree 
; 
byte 
[ 
] 
buffer 
; 
public *
UnpooledUnsafeDirectByteBuffer -
(- . 
IByteBufferAllocator. B
allocC H
,H I
intJ M
initialCapacityN ]
,] ^
int_ b
maxCapacityc n
)n o
: 
base 
( 
maxCapacity 
) 
{ 	
Contract 
. 
Requires 
( 
alloc #
!=$ &
null' +
)+ ,
;, -
Contract 
. 
Requires 
( 
initialCapacity -
>=. 0
$num1 2
)2 3
;3 4
Contract 
. 
Requires 
( 
maxCapacity )
>=* ,
$num- .
). /
;/ 0
if   
(   
initialCapacity   
>    !
maxCapacity  " -
)  - .
{!! 
throw"" 
new"" 
ArgumentException"" +
(""+ ,
$""", .
$str"". >
{""> ?
initialCapacity""? N
}""N O
$str""O _
{""_ `
maxCapacity""` k
}""k l
$str""l m
"""m n
)""n o
;""o p
}## 
this%% 
.%% 
	allocator%% 
=%% 
alloc%% "
;%%" #
this&& 
.&& 
SetByteBuffer&& 
(&& 
this&& #
.&&# $
NewArray&&$ ,
(&&, -
initialCapacity&&- <
)&&< =
,&&= >
false&&? D
)&&D E
;&&E F
}'' 	
	protected)) *
UnpooledUnsafeDirectByteBuffer)) 0
())0 1 
IByteBufferAllocator))1 E
alloc))F K
,))K L
byte))M Q
[))Q R
]))R S
initialBuffer))T a
,))a b
int))c f
maxCapacity))g r
,))r s
bool))t x
doFree))y 
)	)) Ä
:** 
base** 
(** 
maxCapacity** 
)** 
{++ 	
Contract,, 
.,, 
Requires,, 
(,, 
alloc,, #
!=,,$ &
null,,' +
),,+ ,
;,,, -
Contract-- 
.-- 
Requires-- 
(-- 
initialBuffer-- +
!=--, .
null--/ 3
)--3 4
;--4 5
int// 
initialCapacity// 
=//  !
initialBuffer//" /
./// 0
Length//0 6
;//6 7
if00 
(00 
initialCapacity00 
>00  !
maxCapacity00" -
)00- .
{11 
throw22 
new22 
ArgumentException22 +
(22+ ,
$"22, .
$str22. >
{22> ?
initialCapacity22? N
}22N O
$str22O _
{22_ `
maxCapacity22` k
}22k l
$str22l m
"22m n
)22n o
;22o p
}33 
this55 
.55 
	allocator55 
=55 
alloc55 "
;55" #
this66 
.66 
	doNotFree66 
=66 
!66 
doFree66 $
;66$ %
this77 
.77 
SetByteBuffer77 
(77 
initialBuffer77 ,
,77, -
false77. 3
)773 4
;774 5
}88 	
	protected:: 
virtual:: 
byte:: 
[:: 
]::  
AllocateDirect::! /
(::/ 0
int::0 3
initialCapacity::4 C
)::C D
=>::E G
this::H L
.::L M
NewArray::M U
(::U V
initialCapacity::V e
)::e f
;::f g
	protected<< 
byte<< 
[<< 
]<< 
NewArray<< !
(<<! "
int<<" %
initialCapacity<<& 5
)<<5 6
=><<7 9
new<<: =
byte<<> B
[<<B C
initialCapacity<<C R
]<<R S
;<<S T
	protected>> 
virtual>> 
void>> 

FreeDirect>> )
(>>) *
byte>>* .
[>>. /
]>>/ 0
array>>1 6
)>>6 7
{?? 	
}AA 	
voidCC 
SetByteBufferCC 
(CC 
byteCC 
[CC  
]CC  !
arrayCC" '
,CC' (
boolCC) -
tryFreeCC. 5
)CC5 6
{DD 	
ifEE 
(EE 
tryFreeEE 
)EE 
{FF 
byteGG 
[GG 
]GG 
	oldBufferGG  
=GG! "
thisGG# '
.GG' (
bufferGG( .
;GG. /
ifHH 
(HH 
	oldBufferHH 
!=HH  
nullHH! %
)HH% &
{II 
ifJJ 
(JJ 
thisJJ 
.JJ 
	doNotFreeJJ &
)JJ& '
{KK 
thisLL 
.LL 
	doNotFreeLL &
=LL' (
falseLL) .
;LL. /
}MM 
elseNN 
{OO 
thisPP 
.PP 

FreeDirectPP '
(PP' (
	oldBufferPP( 1
)PP1 2
;PP2 3
}QQ 
}RR 
}SS 
thisTT 
.TT 
bufferTT 
=TT 
arrayTT 
;TT  
thisUU 
.UU 
capacityUU 
=UU 
arrayUU !
.UU! "
LengthUU" (
;UU( )
}VV 	
publicXX 
overrideXX 
boolXX 
IsDirectXX %
=>XX& (
trueXX) -
;XX- .
publicZZ 
overrideZZ 
intZZ 
CapacityZZ $
=>ZZ% '
thisZZ( ,
.ZZ, -
capacityZZ- 5
;ZZ5 6
public\\ 
override\\ 
IByteBuffer\\ #
AdjustCapacity\\$ 2
(\\2 3
int\\3 6
newCapacity\\7 B
)\\B C
{]] 	
this^^ 
.^^ 
CheckNewCapacity^^ !
(^^! "
newCapacity^^" -
)^^- .
;^^. /
int`` 
rIdx`` 
=`` 
this`` 
.`` 
ReaderIndex`` '
;``' (
intaa 
wIdxaa 
=aa 
thisaa 
.aa 
WriterIndexaa '
;aa' (
intcc 
oldCapacitycc 
=cc 
thiscc "
.cc" #
capacitycc# +
;cc+ ,
ifdd 
(dd 
newCapacitydd 
>dd 
oldCapacitydd )
)dd) *
{ee 
byteff 
[ff 
]ff 
	oldBufferff  
=ff! "
thisff# '
.ff' (
bufferff( .
;ff. /
bytegg 
[gg 
]gg 
	newBuffergg  
=gg! "
thisgg# '
.gg' (
AllocateDirectgg( 6
(gg6 7
newCapacitygg7 B
)ggB C
;ggC D
PlatformDependenthh !
.hh! "

CopyMemoryhh" ,
(hh, -
	oldBufferhh- 6
,hh6 7
$numhh8 9
,hh9 :
	newBufferhh; D
,hhD E
$numhhF G
,hhG H
oldCapacityhhI T
)hhT U
;hhU V
thisii 
.ii 
SetByteBufferii "
(ii" #
	newBufferii# ,
,ii, -
trueii. 2
)ii2 3
;ii3 4
}jj 
elsekk 
ifkk 
(kk 
newCapacitykk  
<kk! "
oldCapacitykk# .
)kk. /
{ll 
bytemm 
[mm 
]mm 
	oldBuffermm  
=mm! "
thismm# '
.mm' (
buffermm( .
;mm. /
bytenn 
[nn 
]nn 
	newBuffernn  
=nn! "
thisnn# '
.nn' (
AllocateDirectnn( 6
(nn6 7
newCapacitynn7 B
)nnB C
;nnC D
ifoo 
(oo 
rIdxoo 
<oo 
newCapacityoo &
)oo& '
{pp 
ifqq 
(qq 
wIdxqq 
>qq 
newCapacityqq *
)qq* +
{rr 
thisss 
.ss 
SetWriterIndexss +
(ss+ ,
wIdxss, 0
=ss1 2
newCapacityss3 >
)ss> ?
;ss? @
}tt 
PlatformDependentuu %
.uu% &

CopyMemoryuu& 0
(uu0 1
	oldBufferuu1 :
,uu: ;
rIdxuu< @
,uu@ A
	newBufferuuB K
,uuK L
$numuuM N
,uuN O
wIdxuuP T
-uuU V
rIdxuuW [
)uu[ \
;uu\ ]
}vv 
elseww 
{xx 
thisyy 
.yy 
SetIndexyy !
(yy! "
newCapacityyy" -
,yy- .
newCapacityyy/ :
)yy: ;
;yy; <
}zz 
this{{ 
.{{ 
SetByteBuffer{{ "
({{" #
	newBuffer{{# ,
,{{, -
true{{. 2
){{2 3
;{{3 4
}|| 
return}} 
this}} 
;}} 
}~~ 	
public
ÄÄ 
override
ÄÄ "
IByteBufferAllocator
ÄÄ ,
	Allocator
ÄÄ- 6
=>
ÄÄ7 9
this
ÄÄ: >
.
ÄÄ> ?
	allocator
ÄÄ? H
;
ÄÄH I
public
ÇÇ 
override
ÇÇ 
bool
ÇÇ 
HasArray
ÇÇ %
=>
ÇÇ& (
true
ÇÇ) -
;
ÇÇ- .
public
ÑÑ 
override
ÑÑ 
byte
ÑÑ 
[
ÑÑ 
]
ÑÑ 
Array
ÑÑ $
{
ÖÖ 	
get
ÜÜ 
{
áá 
this
àà 
.
àà 
EnsureAccessible
àà %
(
àà% &
)
àà& '
;
àà' (
return
ââ 
this
ââ 
.
ââ 
buffer
ââ "
;
ââ" #
}
ää 
}
ãã 	
public
çç 
override
çç 
int
çç 
ArrayOffset
çç '
=>
çç( *
$num
çç+ ,
;
çç, -
public
èè 
override
èè 
bool
èè 
HasMemoryAddress
èè -
=>
èè. 0
true
èè1 5
;
èè5 6
public
ëë 
override
ëë 
ref
ëë 
byte
ëë  &
GetPinnableMemoryAddress
ëë! 9
(
ëë9 :
)
ëë: ;
{
íí 	
this
ìì 
.
ìì 
EnsureAccessible
ìì !
(
ìì! "
)
ìì" #
;
ìì# $
return
îî 
ref
îî 
this
îî 
.
îî 
buffer
îî "
[
îî" #
$num
îî# $
]
îî$ %
;
îî% &
}
ïï 	
public
óó 
override
óó 
IntPtr
óó #
AddressOfPinnedMemory
óó 4
(
óó4 5
)
óó5 6
=>
óó7 9
IntPtr
óó: @
.
óó@ A
Zero
óóA E
;
óóE F
	protected
ôô 
internal
ôô 
override
ôô #
byte
ôô$ (
_GetByte
ôô) 1
(
ôô1 2
int
ôô2 5
index
ôô6 ;
)
ôô; <
=>
ôô= ?
this
ôô@ D
.
ôôD E
buffer
ôôE K
[
ôôK L
index
ôôL Q
]
ôôQ R
;
ôôR S
	protected
õõ 
internal
õõ 
override
õõ #
short
õõ$ )
	_GetShort
õõ* 3
(
õõ3 4
int
õõ4 7
index
õõ8 =
)
õõ= >
{
úú 	
fixed
ùù 
(
ùù 
byte
ùù 
*
ùù 
addr
ùù 
=
ùù 
&
ùù  !
this
ùù! %
.
ùù% &
Addr
ùù& *
(
ùù* +
index
ùù+ 0
)
ùù0 1
)
ùù1 2
return
ûû "
UnsafeByteBufferUtil
ûû +
.
ûû+ ,
GetShort
ûû, 4
(
ûû4 5
addr
ûû5 9
)
ûû9 :
;
ûû: ;
}
üü 	
	protected
°° 
internal
°° 
override
°° #
short
°°$ )
_GetShortLE
°°* 5
(
°°5 6
int
°°6 9
index
°°: ?
)
°°? @
{
¢¢ 	
fixed
££ 
(
££ 
byte
££ 
*
££ 
addr
££ 
=
££ 
&
££  !
this
££! %
.
££% &
Addr
££& *
(
££* +
index
££+ 0
)
££0 1
)
££1 2
return
§§ "
UnsafeByteBufferUtil
§§ +
.
§§+ ,

GetShortLE
§§, 6
(
§§6 7
addr
§§7 ;
)
§§; <
;
§§< =
}
•• 	
	protected
ßß 
internal
ßß 
override
ßß #
int
ßß$ ' 
_GetUnsignedMedium
ßß( :
(
ßß: ;
int
ßß; >
index
ßß? D
)
ßßD E
{
®® 	
fixed
©© 
(
©© 
byte
©© 
*
©© 
addr
©© 
=
©© 
&
©©  !
this
©©! %
.
©©% &
Addr
©©& *
(
©©* +
index
©©+ 0
)
©©0 1
)
©©1 2
return
™™ "
UnsafeByteBufferUtil
™™ +
.
™™+ ,
GetUnsignedMedium
™™, =
(
™™= >
addr
™™> B
)
™™B C
;
™™C D
}
´´ 	
	protected
≠≠ 
internal
≠≠ 
override
≠≠ #
int
≠≠$ '"
_GetUnsignedMediumLE
≠≠( <
(
≠≠< =
int
≠≠= @
index
≠≠A F
)
≠≠F G
{
ÆÆ 	
fixed
ØØ 
(
ØØ 
byte
ØØ 
*
ØØ 
addr
ØØ 
=
ØØ 
&
ØØ  !
this
ØØ! %
.
ØØ% &
Addr
ØØ& *
(
ØØ* +
index
ØØ+ 0
)
ØØ0 1
)
ØØ1 2
return
∞∞ "
UnsafeByteBufferUtil
∞∞ +
.
∞∞+ ,!
GetUnsignedMediumLE
∞∞, ?
(
∞∞? @
addr
∞∞@ D
)
∞∞D E
;
∞∞E F
}
±± 	
	protected
≥≥ 
internal
≥≥ 
override
≥≥ #
int
≥≥$ '
_GetInt
≥≥( /
(
≥≥/ 0
int
≥≥0 3
index
≥≥4 9
)
≥≥9 :
{
¥¥ 	
fixed
µµ 
(
µµ 
byte
µµ 
*
µµ 
addr
µµ 
=
µµ 
&
µµ  !
this
µµ! %
.
µµ% &
Addr
µµ& *
(
µµ* +
index
µµ+ 0
)
µµ0 1
)
µµ1 2
return
∂∂ "
UnsafeByteBufferUtil
∂∂ +
.
∂∂+ ,
GetInt
∂∂, 2
(
∂∂2 3
addr
∂∂3 7
)
∂∂7 8
;
∂∂8 9
}
∑∑ 	
	protected
ππ 
internal
ππ 
override
ππ #
int
ππ$ '
	_GetIntLE
ππ( 1
(
ππ1 2
int
ππ2 5
index
ππ6 ;
)
ππ; <
{
∫∫ 	
fixed
ªª 
(
ªª 
byte
ªª 
*
ªª 
addr
ªª 
=
ªª 
&
ªª  !
this
ªª! %
.
ªª% &
Addr
ªª& *
(
ªª* +
index
ªª+ 0
)
ªª0 1
)
ªª1 2
return
ºº "
UnsafeByteBufferUtil
ºº +
.
ºº+ ,
GetIntLE
ºº, 4
(
ºº4 5
addr
ºº5 9
)
ºº9 :
;
ºº: ;
}
ΩΩ 	
	protected
øø 
internal
øø 
override
øø #
long
øø$ (
_GetLong
øø) 1
(
øø1 2
int
øø2 5
index
øø6 ;
)
øø; <
{
¿¿ 	
fixed
¡¡ 
(
¡¡ 
byte
¡¡ 
*
¡¡ 
addr
¡¡ 
=
¡¡ 
&
¡¡  !
this
¡¡! %
.
¡¡% &
Addr
¡¡& *
(
¡¡* +
index
¡¡+ 0
)
¡¡0 1
)
¡¡1 2
return
¬¬ "
UnsafeByteBufferUtil
¬¬ +
.
¬¬+ ,
GetLong
¬¬, 3
(
¬¬3 4
addr
¬¬4 8
)
¬¬8 9
;
¬¬9 :
}
√√ 	
	protected
≈≈ 
internal
≈≈ 
override
≈≈ #
long
≈≈$ (

_GetLongLE
≈≈) 3
(
≈≈3 4
int
≈≈4 7
index
≈≈8 =
)
≈≈= >
{
∆∆ 	
fixed
«« 
(
«« 
byte
«« 
*
«« 
addr
«« 
=
«« 
&
««  !
this
««! %
.
««% &
Addr
««& *
(
««* +
index
««+ 0
)
««0 1
)
««1 2
return
»» "
UnsafeByteBufferUtil
»» +
.
»»+ ,
	GetLongLE
»», 5
(
»»5 6
addr
»»6 :
)
»»: ;
;
»»; <
}
…… 	
public
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ #
GetBytes
ÀÀ$ ,
(
ÀÀ, -
int
ÀÀ- 0
index
ÀÀ1 6
,
ÀÀ6 7
IByteBuffer
ÀÀ8 C
dst
ÀÀD G
,
ÀÀG H
int
ÀÀI L
dstIndex
ÀÀM U
,
ÀÀU V
int
ÀÀW Z
length
ÀÀ[ a
)
ÀÀa b
{
ÃÃ 	
this
ÕÕ 
.
ÕÕ 

CheckIndex
ÕÕ 
(
ÕÕ 
index
ÕÕ !
,
ÕÕ! "
length
ÕÕ# )
)
ÕÕ) *
;
ÕÕ* +
fixed
ŒŒ 
(
ŒŒ 
byte
ŒŒ 
*
ŒŒ 
addr
ŒŒ 
=
ŒŒ 
&
ŒŒ  !
this
ŒŒ! %
.
ŒŒ% &
Addr
ŒŒ& *
(
ŒŒ* +
index
ŒŒ+ 0
)
ŒŒ0 1
)
ŒŒ1 2"
UnsafeByteBufferUtil
œœ $
.
œœ$ %
GetBytes
œœ% -
(
œœ- .
this
œœ. 2
,
œœ2 3
addr
œœ4 8
,
œœ8 9
index
œœ: ?
,
œœ? @
dst
œœA D
,
œœD E
dstIndex
œœF N
,
œœN O
length
œœP V
)
œœV W
;
œœW X
return
–– 
this
–– 
;
–– 
}
—— 	
public
”” 
override
”” 
IByteBuffer
”” #
GetBytes
””$ ,
(
””, -
int
””- 0
index
””1 6
,
””6 7
byte
””8 <
[
””< =
]
””= >
dst
””? B
,
””B C
int
””D G
dstIndex
””H P
,
””P Q
int
””R U
length
””V \
)
””\ ]
{
‘‘ 	
this
’’ 
.
’’ 

CheckIndex
’’ 
(
’’ 
index
’’ !
,
’’! "
length
’’# )
)
’’) *
;
’’* +
fixed
÷÷ 
(
÷÷ 
byte
÷÷ 
*
÷÷ 
addr
÷÷ 
=
÷÷ 
&
÷÷  !
this
÷÷! %
.
÷÷% &
Addr
÷÷& *
(
÷÷* +
index
÷÷+ 0
)
÷÷0 1
)
÷÷1 2"
UnsafeByteBufferUtil
◊◊ $
.
◊◊$ %
GetBytes
◊◊% -
(
◊◊- .
this
◊◊. 2
,
◊◊2 3
addr
◊◊4 8
,
◊◊8 9
index
◊◊: ?
,
◊◊? @
dst
◊◊A D
,
◊◊D E
dstIndex
◊◊F N
,
◊◊N O
length
◊◊P V
)
◊◊V W
;
◊◊W X
return
ÿÿ 
this
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
	protected
€€ 
internal
€€ 
override
€€ #
void
€€$ (
_SetByte
€€) 1
(
€€1 2
int
€€2 5
index
€€6 ;
,
€€; <
int
€€= @
value
€€A F
)
€€F G
=>
€€H J
this
€€K O
.
€€O P
buffer
€€P V
[
€€V W
index
€€W \
]
€€\ ]
=
€€^ _
	unchecked
€€` i
(
€€i j
(
€€j k
byte
€€k o
)
€€o p
value
€€p u
)
€€u v
;
€€v w
	protected
›› 
internal
›› 
override
›› #
void
››$ (
	_SetShort
››) 2
(
››2 3
int
››3 6
index
››7 <
,
››< =
int
››> A
value
››B G
)
››G H
{
ﬁﬁ 	
fixed
ﬂﬂ 
(
ﬂﬂ 
byte
ﬂﬂ 
*
ﬂﬂ 
addr
ﬂﬂ 
=
ﬂﬂ 
&
ﬂﬂ  !
this
ﬂﬂ! %
.
ﬂﬂ% &
Addr
ﬂﬂ& *
(
ﬂﬂ* +
index
ﬂﬂ+ 0
)
ﬂﬂ0 1
)
ﬂﬂ1 2"
UnsafeByteBufferUtil
‡‡ $
.
‡‡$ %
SetShort
‡‡% -
(
‡‡- .
addr
‡‡. 2
,
‡‡2 3
value
‡‡4 9
)
‡‡9 :
;
‡‡: ;
}
·· 	
	protected
„„ 
internal
„„ 
override
„„ #
void
„„$ (
_SetShortLE
„„) 4
(
„„4 5
int
„„5 8
index
„„9 >
,
„„> ?
int
„„@ C
value
„„D I
)
„„I J
{
‰‰ 	
fixed
ÂÂ 
(
ÂÂ 
byte
ÂÂ 
*
ÂÂ 
addr
ÂÂ 
=
ÂÂ 
&
ÂÂ  !
this
ÂÂ! %
.
ÂÂ% &
Addr
ÂÂ& *
(
ÂÂ* +
index
ÂÂ+ 0
)
ÂÂ0 1
)
ÂÂ1 2"
UnsafeByteBufferUtil
ÊÊ $
.
ÊÊ$ %

SetShortLE
ÊÊ% /
(
ÊÊ/ 0
addr
ÊÊ0 4
,
ÊÊ4 5
value
ÊÊ6 ;
)
ÊÊ; <
;
ÊÊ< =
}
ÁÁ 	
	protected
ÈÈ 
internal
ÈÈ 
override
ÈÈ #
void
ÈÈ$ (

_SetMedium
ÈÈ) 3
(
ÈÈ3 4
int
ÈÈ4 7
index
ÈÈ8 =
,
ÈÈ= >
int
ÈÈ? B
value
ÈÈC H
)
ÈÈH I
{
ÍÍ 	
fixed
ÎÎ 
(
ÎÎ 
byte
ÎÎ 
*
ÎÎ 
addr
ÎÎ 
=
ÎÎ 
&
ÎÎ  !
this
ÎÎ! %
.
ÎÎ% &
Addr
ÎÎ& *
(
ÎÎ* +
index
ÎÎ+ 0
)
ÎÎ0 1
)
ÎÎ1 2"
UnsafeByteBufferUtil
ÏÏ $
.
ÏÏ$ %
	SetMedium
ÏÏ% .
(
ÏÏ. /
addr
ÏÏ/ 3
,
ÏÏ3 4
value
ÏÏ5 :
)
ÏÏ: ;
;
ÏÏ; <
}
ÌÌ 	
	protected
ÔÔ 
internal
ÔÔ 
override
ÔÔ #
void
ÔÔ$ (
_SetMediumLE
ÔÔ) 5
(
ÔÔ5 6
int
ÔÔ6 9
index
ÔÔ: ?
,
ÔÔ? @
int
ÔÔA D
value
ÔÔE J
)
ÔÔJ K
{
 	
fixed
ÒÒ 
(
ÒÒ 
byte
ÒÒ 
*
ÒÒ 
addr
ÒÒ 
=
ÒÒ 
&
ÒÒ  !
this
ÒÒ! %
.
ÒÒ% &
Addr
ÒÒ& *
(
ÒÒ* +
index
ÒÒ+ 0
)
ÒÒ0 1
)
ÒÒ1 2"
UnsafeByteBufferUtil
ÚÚ $
.
ÚÚ$ %
SetMediumLE
ÚÚ% 0
(
ÚÚ0 1
addr
ÚÚ1 5
,
ÚÚ5 6
value
ÚÚ7 <
)
ÚÚ< =
;
ÚÚ= >
}
ÛÛ 	
	protected
ıı 
internal
ıı 
override
ıı #
void
ıı$ (
_SetInt
ıı) 0
(
ıı0 1
int
ıı1 4
index
ıı5 :
,
ıı: ;
int
ıı< ?
value
ıı@ E
)
ııE F
{
ˆˆ 	
fixed
˜˜ 
(
˜˜ 
byte
˜˜ 
*
˜˜ 
addr
˜˜ 
=
˜˜ 
&
˜˜  !
this
˜˜! %
.
˜˜% &
Addr
˜˜& *
(
˜˜* +
index
˜˜+ 0
)
˜˜0 1
)
˜˜1 2"
UnsafeByteBufferUtil
¯¯ $
.
¯¯$ %
SetInt
¯¯% +
(
¯¯+ ,
addr
¯¯, 0
,
¯¯0 1
value
¯¯2 7
)
¯¯7 8
;
¯¯8 9
}
˘˘ 	
	protected
˚˚ 
internal
˚˚ 
override
˚˚ #
void
˚˚$ (
	_SetIntLE
˚˚) 2
(
˚˚2 3
int
˚˚3 6
index
˚˚7 <
,
˚˚< =
int
˚˚> A
value
˚˚B G
)
˚˚G H
{
¸¸ 	
fixed
˝˝ 
(
˝˝ 
byte
˝˝ 
*
˝˝ 
addr
˝˝ 
=
˝˝ 
&
˝˝  !
this
˝˝! %
.
˝˝% &
Addr
˝˝& *
(
˝˝* +
index
˝˝+ 0
)
˝˝0 1
)
˝˝1 2"
UnsafeByteBufferUtil
˛˛ $
.
˛˛$ %
SetIntLE
˛˛% -
(
˛˛- .
addr
˛˛. 2
,
˛˛2 3
value
˛˛4 9
)
˛˛9 :
;
˛˛: ;
}
ˇˇ 	
	protected
ÅÅ 
internal
ÅÅ 
override
ÅÅ #
void
ÅÅ$ (
_SetLong
ÅÅ) 1
(
ÅÅ1 2
int
ÅÅ2 5
index
ÅÅ6 ;
,
ÅÅ; <
long
ÅÅ= A
value
ÅÅB G
)
ÅÅG H
{
ÇÇ 	
fixed
ÉÉ 
(
ÉÉ 
byte
ÉÉ 
*
ÉÉ 
addr
ÉÉ 
=
ÉÉ 
&
ÉÉ  !
this
ÉÉ! %
.
ÉÉ% &
Addr
ÉÉ& *
(
ÉÉ* +
index
ÉÉ+ 0
)
ÉÉ0 1
)
ÉÉ1 2"
UnsafeByteBufferUtil
ÑÑ $
.
ÑÑ$ %
SetLong
ÑÑ% ,
(
ÑÑ, -
addr
ÑÑ- 1
,
ÑÑ1 2
value
ÑÑ3 8
)
ÑÑ8 9
;
ÑÑ9 :
}
ÖÖ 	
	protected
áá 
internal
áá 
override
áá #
void
áá$ (

_SetLongLE
áá) 3
(
áá3 4
int
áá4 7
index
áá8 =
,
áá= >
long
áá? C
value
ááD I
)
ááI J
{
àà 	
fixed
ââ 
(
ââ 
byte
ââ 
*
ââ 
addr
ââ 
=
ââ 
&
ââ  !
this
ââ! %
.
ââ% &
Addr
ââ& *
(
ââ* +
index
ââ+ 0
)
ââ0 1
)
ââ1 2"
UnsafeByteBufferUtil
ää $
.
ää$ %
	SetLongLE
ää% .
(
ää. /
addr
ää/ 3
,
ää3 4
value
ää5 :
)
ää: ;
;
ää; <
}
ãã 	
public
çç 
override
çç 
IByteBuffer
çç #
SetBytes
çç$ ,
(
çç, -
int
çç- 0
index
çç1 6
,
çç6 7
IByteBuffer
çç8 C
src
ççD G
,
ççG H
int
ççI L
srcIndex
ççM U
,
ççU V
int
ççW Z
length
çç[ a
)
çça b
{
éé 	
this
èè 
.
èè 

CheckIndex
èè 
(
èè 
index
èè !
,
èè! "
length
èè# )
)
èè) *
;
èè* +
fixed
êê 
(
êê 
byte
êê 
*
êê 
addr
êê 
=
êê 
&
êê  !
this
êê! %
.
êê% &
Addr
êê& *
(
êê* +
index
êê+ 0
)
êê0 1
)
êê1 2"
UnsafeByteBufferUtil
ëë $
.
ëë$ %
SetBytes
ëë% -
(
ëë- .
this
ëë. 2
,
ëë2 3
addr
ëë4 8
,
ëë8 9
index
ëë: ?
,
ëë? @
src
ëëA D
,
ëëD E
srcIndex
ëëF N
,
ëëN O
length
ëëP V
)
ëëV W
;
ëëW X
return
íí 
this
íí 
;
íí 
}
ìì 	
public
ïï 
override
ïï 
IByteBuffer
ïï #
SetBytes
ïï$ ,
(
ïï, -
int
ïï- 0
index
ïï1 6
,
ïï6 7
byte
ïï8 <
[
ïï< =
]
ïï= >
src
ïï? B
,
ïïB C
int
ïïD G
srcIndex
ïïH P
,
ïïP Q
int
ïïR U
length
ïïV \
)
ïï\ ]
{
ññ 	
this
óó 
.
óó 

CheckIndex
óó 
(
óó 
index
óó !
,
óó! "
length
óó# )
)
óó) *
;
óó* +
if
òò 
(
òò 
length
òò 
!=
òò 
$num
òò 
)
òò 
{
ôô 
fixed
öö 
(
öö 
byte
öö 
*
öö 
addr
öö !
=
öö" #
&
öö$ %
this
öö% )
.
öö) *
Addr
öö* .
(
öö. /
index
öö/ 4
)
öö4 5
)
öö5 6"
UnsafeByteBufferUtil
õõ (
.
õõ( )
SetBytes
õõ) 1
(
õõ1 2
this
õõ2 6
,
õõ6 7
addr
õõ8 <
,
õõ< =
index
õõ> C
,
õõC D
src
õõE H
,
õõH I
srcIndex
õõJ R
,
õõR S
length
õõT Z
)
õõZ [
;
õõ[ \
}
úú 
return
ùù 
this
ùù 
;
ùù 
}
ûû 	
public
†† 
override
†† 
IByteBuffer
†† #
GetBytes
††$ ,
(
††, -
int
††- 0
index
††1 6
,
††6 7
Stream
††8 >
output
††? E
,
††E F
int
††G J
length
††K Q
)
††Q R
{
°° 	
this
¢¢ 
.
¢¢ 

CheckIndex
¢¢ 
(
¢¢ 
index
¢¢ !
,
¢¢! "
length
¢¢# )
)
¢¢) *
;
¢¢* +
fixed
££ 
(
££ 
byte
££ 
*
££ 
addr
££ 
=
££ 
&
££  !
this
££! %
.
££% &
Addr
££& *
(
££* +
index
££+ 0
)
££0 1
)
££1 2"
UnsafeByteBufferUtil
§§ $
.
§§$ %
GetBytes
§§% -
(
§§- .
this
§§. 2
,
§§2 3
addr
§§4 8
,
§§8 9
index
§§: ?
,
§§? @
output
§§A G
,
§§G H
length
§§I O
)
§§O P
;
§§P Q
return
•• 
this
•• 
;
•• 
}
¶¶ 	
public
®® 
override
®® 
Task
®® 
<
®® 
int
®®  
>
®®  !
SetBytesAsync
®®" /
(
®®/ 0
int
®®0 3
index
®®4 9
,
®®9 :
Stream
®®; A
src
®®B E
,
®®E F
int
®®G J
length
®®K Q
,
®®Q R
CancellationToken
®®S d
cancellationToken
®®e v
)
®®v w
{
©© 	
this
™™ 
.
™™ 

CheckIndex
™™ 
(
™™ 
index
™™ !
,
™™! "
length
™™# )
)
™™) *
;
™™* +
fixed
´´ 
(
´´ 
byte
´´ 
*
´´ 
addr
´´ 
=
´´ 
&
´´  !
this
´´! %
.
´´% &
Addr
´´& *
(
´´* +
index
´´+ 0
)
´´0 1
)
´´1 2
{
¨¨ 
return
≠≠ "
UnsafeByteBufferUtil
≠≠ +
.
≠≠+ ,
SetBytesAsync
≠≠, 9
(
≠≠9 :
this
≠≠: >
,
≠≠> ?
addr
≠≠@ D
,
≠≠D E
index
≠≠F K
,
≠≠K L
src
≠≠M P
,
≠≠P Q
length
≠≠R X
,
≠≠X Y
cancellationToken
≠≠Z k
)
≠≠k l
;
≠≠l m
}
ÆÆ 
}
ØØ 	
public
±± 
override
±± 
int
±± 
IoBufferCount
±± )
=>
±±* ,
$num
±±- .
;
±±. /
public
≥≥ 
override
≥≥ 
ArraySegment
≥≥ $
<
≥≥$ %
byte
≥≥% )
>
≥≥) *
GetIoBuffer
≥≥+ 6
(
≥≥6 7
int
≥≥7 :
index
≥≥; @
,
≥≥@ A
int
≥≥B E
length
≥≥F L
)
≥≥L M
{
¥¥ 	
this
µµ 
.
µµ 

CheckIndex
µµ 
(
µµ 
index
µµ !
,
µµ! "
length
µµ# )
)
µµ) *
;
µµ* +
return
∂∂ 
new
∂∂ 
ArraySegment
∂∂ #
<
∂∂# $
byte
∂∂$ (
>
∂∂( )
(
∂∂) *
this
∂∂* .
.
∂∂. /
buffer
∂∂/ 5
,
∂∂5 6
index
∂∂7 <
,
∂∂< =
length
∂∂> D
)
∂∂D E
;
∂∂E F
}
∑∑ 	
public
ππ 
override
ππ 
ArraySegment
ππ $
<
ππ$ %
byte
ππ% )
>
ππ) *
[
ππ* +
]
ππ+ ,
GetIoBuffers
ππ- 9
(
ππ9 :
int
ππ: =
index
ππ> C
,
ππC D
int
ππE H
length
ππI O
)
ππO P
=>
ππQ S
new
ππT W
[
ππW X
]
ππX Y
{
ππZ [
this
ππ\ `
.
ππ` a
GetIoBuffer
ππa l
(
ππl m
index
ππm r
,
ππr s
length
ππt z
)
ππz {
}
ππ| }
;
ππ} ~
public
ªª 
override
ªª 
IByteBuffer
ªª #
Copy
ªª$ (
(
ªª( )
int
ªª) ,
index
ªª- 2
,
ªª2 3
int
ªª4 7
length
ªª8 >
)
ªª> ?
{
ºº 	
this
ΩΩ 
.
ΩΩ 

CheckIndex
ΩΩ 
(
ΩΩ 
index
ΩΩ !
,
ΩΩ! "
length
ΩΩ# )
)
ΩΩ) *
;
ΩΩ* +
fixed
ææ 
(
ææ 
byte
ææ 
*
ææ 
addr
ææ 
=
ææ 
&
ææ  !
this
ææ! %
.
ææ% &
Addr
ææ& *
(
ææ* +
index
ææ+ 0
)
ææ0 1
)
ææ1 2
return
øø "
UnsafeByteBufferUtil
øø +
.
øø+ ,
Copy
øø, 0
(
øø0 1
this
øø1 5
,
øø5 6
addr
øø7 ;
,
øø; <
index
øø= B
,
øøB C
length
øøD J
)
øøJ K
;
øøK L
}
¿¿ 	
	protected
¬¬ 
internal
¬¬ 
override
¬¬ #
void
¬¬$ (

Deallocate
¬¬) 3
(
¬¬3 4
)
¬¬4 5
{
√√ 	
byte
ƒƒ 
[
ƒƒ 
]
ƒƒ 
buf
ƒƒ 
=
ƒƒ 
this
ƒƒ 
.
ƒƒ 
buffer
ƒƒ $
;
ƒƒ$ %
if
≈≈ 
(
≈≈ 
buf
≈≈ 
==
≈≈ 
null
≈≈ 
)
≈≈ 
{
∆∆ 
return
«« 
;
«« 
}
»» 
this
   
.
   
buffer
   
=
   
null
   
;
   
if
ÃÃ 
(
ÃÃ 
!
ÃÃ 
this
ÃÃ 
.
ÃÃ 
	doNotFree
ÃÃ 
)
ÃÃ  
{
ÕÕ 
this
ŒŒ 
.
ŒŒ 

FreeDirect
ŒŒ 
(
ŒŒ  
buf
ŒŒ  #
)
ŒŒ# $
;
ŒŒ$ %
}
œœ 
}
–– 	
public
““ 
override
““ 
IByteBuffer
““ #
Unwrap
““$ *
(
““* +
)
““+ ,
=>
““- /
null
““0 4
;
““4 5
[
‘‘ 	

MethodImpl
‘‘	 
(
‘‘ 
MethodImplOptions
‘‘ %
.
‘‘% & 
AggressiveInlining
‘‘& 8
)
‘‘8 9
]
‘‘9 :
ref
’’ 
byte
’’ 
Addr
’’ 
(
’’ 
int
’’ 
index
’’ 
)
’’  
=>
’’! #
ref
’’$ '
this
’’( ,
.
’’, -
buffer
’’- 3
[
’’3 4
index
’’4 9
]
’’9 :
;
’’: ;
public
◊◊ 
override
◊◊ 
IByteBuffer
◊◊ #
SetZero
◊◊$ +
(
◊◊+ ,
int
◊◊, /
index
◊◊0 5
,
◊◊5 6
int
◊◊7 :
length
◊◊; A
)
◊◊A B
{
ÿÿ 	
this
ŸŸ 
.
ŸŸ 

CheckIndex
ŸŸ 
(
ŸŸ 
index
ŸŸ !
,
ŸŸ! "
length
ŸŸ# )
)
ŸŸ) *
;
ŸŸ* +
fixed
⁄⁄ 
(
⁄⁄ 
byte
⁄⁄ 
*
⁄⁄ 
addr
⁄⁄ 
=
⁄⁄ 
&
⁄⁄  !
this
⁄⁄! %
.
⁄⁄% &
Addr
⁄⁄& *
(
⁄⁄* +
index
⁄⁄+ 0
)
⁄⁄0 1
)
⁄⁄1 2"
UnsafeByteBufferUtil
€€ $
.
€€$ %
SetZero
€€% ,
(
€€, -
addr
€€- 1
,
€€1 2
length
€€3 9
)
€€9 :
;
€€: ;
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
›› 	
public
ﬂﬂ 
override
ﬂﬂ 
IByteBuffer
ﬂﬂ #
	WriteZero
ﬂﬂ$ -
(
ﬂﬂ- .
int
ﬂﬂ. 1
length
ﬂﬂ2 8
)
ﬂﬂ8 9
{
‡‡ 	
this
·· 
.
·· 
EnsureWritable
·· 
(
··  
length
··  &
)
··& '
;
··' (
int
‚‚ 
wIndex
‚‚ 
=
‚‚ 
this
‚‚ 
.
‚‚ 
WriterIndex
‚‚ )
;
‚‚) *
fixed
„„ 
(
„„ 
byte
„„ 
*
„„ 
addr
„„ 
=
„„ 
&
„„  !
this
„„! %
.
„„% &
Addr
„„& *
(
„„* +
wIndex
„„+ 1
)
„„1 2
)
„„2 3"
UnsafeByteBufferUtil
‰‰ $
.
‰‰$ %
SetZero
‰‰% ,
(
‰‰, -
addr
‰‰- 1
,
‰‰1 2
length
‰‰3 9
)
‰‰9 :
;
‰‰: ;
this
ÂÂ 
.
ÂÂ 
SetWriterIndex
ÂÂ 
(
ÂÂ  
wIndex
ÂÂ  &
+
ÂÂ' (
length
ÂÂ) /
)
ÂÂ/ 0
;
ÂÂ0 1
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
}
ËË 
}ÈÈ É#
iC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnreleasableByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
sealed 

class "
UnreleasableByteBuffer '
:( )
WrappedByteBuffer* ;
{ 
internal "
UnreleasableByteBuffer '
(' (
IByteBuffer( 3
buf4 7
)7 8
:9 :
base; ?
(? @
buf@ C
)C D
{		 	
}

 	
public 
override 
IByteBuffer #
	ReadSlice$ -
(- .
int. 1
length2 8
)8 9
=>: <
new= @"
UnreleasableByteBufferA W
(W X
thisX \
.\ ]
Buf] `
.` a
	ReadSlicea j
(j k
lengthk q
)q r
)r s
;s t
public 
override 
IByteBuffer #
ReadRetainedSlice$ 5
(5 6
int6 9
length: @
)@ A
=>B D
thisD H
.H I
	ReadSliceI R
(R S
lengthS Y
)Y Z
;Z [
public 
override 
IByteBuffer #
Slice$ )
() *
)* +
=>, .
new/ 2"
UnreleasableByteBuffer3 I
(I J
thisJ N
.N O
BufO R
.R S
SliceS X
(X Y
)Y Z
)Z [
;[ \
public 
override 
IByteBuffer #
RetainedSlice$ 1
(1 2
)2 3
=>4 6
this7 ;
.; <
Slice< A
(A B
)B C
;C D
public 
override 
IByteBuffer #
Slice$ )
() *
int* -
index. 3
,3 4
int5 8
length9 ?
)? @
=>A C
newD G"
UnreleasableByteBufferH ^
(^ _
this_ c
.c d
Bufd g
.g h
Sliceh m
(m n
indexn s
,s t
lengthu {
){ |
)| }
;} ~
public 
override 
IByteBuffer #
RetainedSlice$ 1
(1 2
int2 5
index6 ;
,; <
int= @
lengthA G
)G H
=>I K
thisL P
.P Q
SliceQ V
(V W
indexW \
,\ ]
length^ d
)d e
;e f
public!! 
override!! 
IByteBuffer!! #
	Duplicate!!$ -
(!!- .
)!!. /
=>!!0 2
new!!3 6"
UnreleasableByteBuffer!!7 M
(!!M N
this!!N R
.!!R S
Buf!!S V
.!!V W
	Duplicate!!W `
(!!` a
)!!a b
)!!b c
;!!c d
public&& 
override&& 
IByteBuffer&& #
RetainedDuplicate&&$ 5
(&&5 6
)&&6 7
=>&&8 :
this&&; ?
.&&? @
	Duplicate&&@ I
(&&I J
)&&J K
;&&K L
public(( 
override(( 
IReferenceCounted(( )
Retain((* 0
(((0 1
)((1 2
=>((3 5
this((6 :
;((: ;
public** 
override** 
IReferenceCounted** )
Retain*** 0
(**0 1
int**1 4
	increment**5 >
)**> ?
=>**@ B
this**C G
;**G H
public,, 
override,, 
IReferenceCounted,, )
Touch,,* /
(,,/ 0
),,0 1
=>,,2 4
this,,5 9
;,,9 :
public.. 
override.. 
IReferenceCounted.. )
Touch..* /
(../ 0
object..0 6
hint..7 ;
)..; <
=>..= ?
this..@ D
;..D E
public00 
override00 
bool00 
Release00 $
(00$ %
)00% &
=>00' )
false00* /
;00/ 0
public22 
override22 
bool22 
Release22 $
(22$ %
int22% (
	decrement22) 2
)222 3
=>224 6
false227 <
;22< =
}33 
}44 ¬ÿ
gC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\UnsafeByteBufferUtil.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
static 

unsafe 
class  
UnsafeByteBufferUtil ,
{ 
const 
byte 
Zero 
= 
$num 
; 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 
GetShort &
(& '
byte' +
*+ ,
bytes- 2
)2 3
=>4 6
	unchecked 
( 
( 
short 
) 
( 
( 
(  
*  !
bytes! &
)& '
<<( *
$num+ ,
), -
|. /
*0 1
(1 2
bytes2 7
+8 9
$num: ;
); <
)< =
)= >
;> ?
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
short 

GetShortLE (
(( )
byte) -
*- .
bytes/ 4
)4 5
=>6 8
	unchecked 
( 
( 
short 
) 
( 
( 
*  
bytes  %
)% &
|' (
() *
** +
(+ ,
bytes, 1
+2 3
$num4 5
)5 6
<<7 9
$num: ;
); <
)< =
)= >
;> ?
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
internal 
static 
int 
GetUnsignedMedium -
(- .
byte. 2
*2 3
bytes4 9
)9 :
=>; =
* 
bytes 
<< 
$num 
| 
* 
( 
bytes 
+ 
$num 
) 
<< 
$num 
| 
*   
(   
bytes   
+   
$num   
)   
;   
["" 	

MethodImpl""	 
("" 
MethodImplOptions"" %
.""% &
AggressiveInlining""& 8
)""8 9
]""9 :
internal## 
static## 
int## 
GetUnsignedMediumLE## /
(##/ 0
byte##0 4
*##4 5
bytes##6 ;
)##; <
=>##= ?
*$$ 
bytes$$ 
|$$ 
*%% 
(%% 
bytes%% 
+%% 
$num%% 
)%% 
<<%% 
$num%% 
|%% 
*&& 
(&& 
bytes&& 
+&& 
$num&& 
)&& 
<<&& 
$num&& 
;&& 
[(( 	

MethodImpl((	 
((( 
MethodImplOptions(( %
.((% &
AggressiveInlining((& 8
)((8 9
]((9 :
internal)) 
static)) 
int)) 
GetInt)) "
())" #
byte))# '
*))' (
bytes))) .
))). /
=>))0 2
(** 
*** 
bytes** 
<<** 
$num** 
)** 
|** 
(++ 
*++ 
(++ 
bytes++ 
+++ 
$num++ 
)++ 
<<++ 
$num++ 
)++  
|++! "
(,, 
*,, 
(,, 
bytes,, 
+,, 
$num,, 
),, 
<<,, 
$num,, 
),, 
|,,  !
(-- 
*-- 
(-- 
bytes-- 
+-- 
$num-- 
)-- 
)-- 
;-- 
[// 	

MethodImpl//	 
(// 
MethodImplOptions// %
.//% &
AggressiveInlining//& 8
)//8 9
]//9 :
internal00 
static00 
int00 
GetIntLE00 $
(00$ %
byte00% )
*00) *
bytes00+ 0
)000 1
=>002 4
*11 
bytes11 
|11 
(22 
*22 
(22 
bytes22 
+22 
$num22 
)22 
<<22 
$num22 
)22 
|22  !
(33 
*33 
(33 
bytes33 
+33 
$num33 
)33 
<<33 
$num33 
)33  
|33! "
(44 
*44 
(44 
bytes44 
+44 
$num44 
)44 
<<44 
$num44 
)44  
;44  !
[66 	

MethodImpl66	 
(66 
MethodImplOptions66 %
.66% &
AggressiveInlining66& 8
)668 9
]669 :
internal77 
static77 
long77 
GetLong77 $
(77$ %
byte77% )
*77) *
bytes77+ 0
)770 1
{88 	
	unchecked99 
{:: 
int;; 
i1;; 
=;; 
(;; 
*;; 
bytes;;  
<<;;! #
$num;;$ &
);;& '
|;;( )
(;;* +
*;;+ ,
(;;, -
bytes;;- 2
+;;3 4
$num;;5 6
);;6 7
<<;;8 :
$num;;; =
);;= >
|;;? @
(;;A B
*;;B C
(;;C D
bytes;;D I
+;;J K
$num;;L M
);;M N
<<;;O Q
$num;;R S
);;S T
|;;U V
(;;W X
*;;X Y
(;;Y Z
bytes;;Z _
+;;` a
$num;;b c
);;c d
);;d e
;;;e f
int<< 
i2<< 
=<< 
(<< 
*<< 
(<< 
bytes<< !
+<<" #
$num<<$ %
)<<% &
<<<<' )
$num<<* ,
)<<, -
|<<. /
(<<0 1
*<<1 2
(<<2 3
bytes<<3 8
+<<9 :
$num<<; <
)<<< =
<<<<> @
$num<<A C
)<<C D
|<<E F
(<<G H
*<<H I
(<<I J
bytes<<J O
+<<P Q
$num<<R S
)<<S T
<<<<U W
$num<<X Y
)<<Y Z
|<<[ \
*<<] ^
(<<^ _
bytes<<_ d
+<<e f
$num<<g h
)<<h i
;<<i j
return== 
(== 
uint== 
)== 
i2== 
|==  !
(==" #
(==# $
long==$ (
)==( )
i1==) +
<<==, .
$num==/ 1
)==1 2
;==2 3
}>> 
}?? 	
[AA 	

MethodImplAA	 
(AA 
MethodImplOptionsAA %
.AA% &
AggressiveInliningAA& 8
)AA8 9
]AA9 :
internalBB 
staticBB 
longBB 
	GetLongLEBB &
(BB& '
byteBB' +
*BB+ ,
bytesBB- 2
)BB2 3
{CC 	
	uncheckedDD 
{EE 
intFF 
i1FF 
=FF 
*FF 
bytesFF 
|FF  !
(FF" #
*FF# $
(FF$ %
bytesFF% *
+FF+ ,
$numFF- .
)FF. /
<<FF0 2
$numFF3 4
)FF4 5
|FF6 7
(FF8 9
*FF9 :
(FF: ;
bytesFF; @
+FFA B
$numFFC D
)FFD E
<<FFF H
$numFFI K
)FFK L
|FFM N
(FFO P
*FFP Q
(FFQ R
bytesFFR W
+FFX Y
$numFFZ [
)FF[ \
<<FF] _
$numFF` b
)FFb c
;FFc d
intGG 
i2GG 
=GG 
*GG 
(GG 
bytesGG  
+GG! "
$numGG# $
)GG$ %
|GG& '
(GG( )
*GG) *
(GG* +
bytesGG+ 0
+GG1 2
$numGG3 4
)GG4 5
<<GG6 8
$numGG9 :
)GG: ;
|GG< =
(GG> ?
*GG? @
(GG@ A
bytesGGA F
+GGG H
$numGGI J
)GGJ K
<<GGL N
$numGGO Q
)GGQ R
|GGS T
(GGU V
*GGV W
(GGW X
bytesGGX ]
+GG^ _
$numGG` a
)GGa b
<<GGc e
$numGGf h
)GGh i
;GGi j
returnHH 
(HH 
uintHH 
)HH 
i1HH 
|HH  !
(HH" #
(HH# $
longHH$ (
)HH( )
i2HH) +
<<HH, .
$numHH/ 1
)HH1 2
;HH2 3
}II 
}JJ 	
[LL 	

MethodImplLL	 
(LL 
MethodImplOptionsLL %
.LL% &
AggressiveInliningLL& 8
)LL8 9
]LL9 :
internalMM 
staticMM 
voidMM 
SetShortMM %
(MM% &
byteMM& *
*MM* +
bytesMM, 1
,MM1 2
intMM3 6
valueMM7 <
)MM< =
{NN 	
	uncheckedOO 
{PP 
*QQ 
bytesQQ 
=QQ 
(QQ 
byteQQ 
)QQ 
(QQ  
(QQ  !
ushortQQ! '
)QQ' (
valueQQ( -
>>QQ. 0
$numQQ1 2
)QQ2 3
;QQ3 4
*RR 
(RR 
bytesRR 
+RR 
$numRR 
)RR 
=RR 
(RR  
byteRR  $
)RR$ %
valueRR% *
;RR* +
}SS 
}TT 	
[VV 	

MethodImplVV	 
(VV 
MethodImplOptionsVV %
.VV% &
AggressiveInliningVV& 8
)VV8 9
]VV9 :
internalWW 
staticWW 
voidWW 

SetShortLEWW '
(WW' (
byteWW( ,
*WW, -
bytesWW. 3
,WW3 4
intWW5 8
valueWW9 >
)WW> ?
{XX 	
	uncheckedYY 
{ZZ 
*[[ 
bytes[[ 
=[[ 
([[ 
byte[[ 
)[[ 
value[[ $
;[[$ %
*\\ 
(\\ 
bytes\\ 
+\\ 
$num\\ 
)\\ 
=\\ 
(\\  
byte\\  $
)\\$ %
(\\% &
(\\& '
ushort\\' -
)\\- .
value\\. 3
>>\\4 6
$num\\7 8
)\\8 9
;\\9 :
}]] 
}^^ 	
[`` 	

MethodImpl``	 
(`` 
MethodImplOptions`` %
.``% &
AggressiveInlining``& 8
)``8 9
]``9 :
internalaa 
staticaa 
voidaa 
	SetMediumaa &
(aa& '
byteaa' +
*aa+ ,
bytesaa- 2
,aa2 3
intaa4 7
valueaa8 =
)aa= >
{bb 	
	uncheckedcc 
{dd 
uintee 
unsignedValueee "
=ee# $
(ee% &
uintee& *
)ee* +
valueee+ 0
;ee0 1
*ff 
bytesff 
=ff 
(ff 
byteff 
)ff 
(ff  
unsignedValueff  -
>>ff. 0
$numff1 3
)ff3 4
;ff4 5
*gg 
(gg 
bytesgg 
+gg 
$numgg 
)gg 
=gg 
(gg  
bytegg  $
)gg$ %
(gg% &
unsignedValuegg& 3
>>gg4 6
$numgg7 8
)gg8 9
;gg9 :
*hh 
(hh 
byteshh 
+hh 
$numhh 
)hh 
=hh 
(hh  
bytehh  $
)hh$ %
unsignedValuehh% 2
;hh2 3
}ii 
}jj 	
[ll 	

MethodImplll	 
(ll 
MethodImplOptionsll %
.ll% &
AggressiveInliningll& 8
)ll8 9
]ll9 :
internalmm 
staticmm 
voidmm 
SetMediumLEmm (
(mm( )
bytemm) -
*mm- .
bytesmm/ 4
,mm4 5
intmm6 9
valuemm: ?
)mm? @
{nn 	
	uncheckedoo 
{pp 
uintqq 
unsignedValueqq "
=qq# $
(qq% &
uintqq& *
)qq* +
valueqq+ 0
;qq0 1
*rr 
bytesrr 
=rr 
(rr 
byterr 
)rr 
unsignedValuerr ,
;rr, -
*ss 
(ss 
bytesss 
+ss 
$numss 
)ss 
=ss 
(ss  
bytess  $
)ss$ %
(ss% &
unsignedValuess& 3
>>ss4 6
$numss7 8
)ss8 9
;ss9 :
*tt 
(tt 
bytestt 
+tt 
$numtt 
)tt 
=tt 
(tt  
bytett  $
)tt$ %
(tt% &
unsignedValuett& 3
>>tt4 6
$numtt7 9
)tt9 :
;tt: ;
}uu 
}vv 	
[xx 	

MethodImplxx	 
(xx 
MethodImplOptionsxx %
.xx% &
AggressiveInliningxx& 8
)xx8 9
]xx9 :
internalyy 
staticyy 
voidyy 
SetIntyy #
(yy# $
byteyy$ (
*yy( )
bytesyy* /
,yy/ 0
intyy1 4
valueyy5 :
)yy: ;
{zz 	
	unchecked{{ 
{|| 
uint}} 
unsignedValue}} "
=}}# $
(}}% &
uint}}& *
)}}* +
value}}+ 0
;}}0 1
*~~ 
bytes~~ 
=~~ 
(~~ 
byte~~ 
)~~ 
(~~  
unsignedValue~~  -
>>~~. 0
$num~~1 3
)~~3 4
;~~4 5
* 
( 
bytes 
+ 
$num 
) 
= 
(  
byte  $
)$ %
(% &
unsignedValue& 3
>>4 6
$num7 9
)9 :
;: ;
*
ÄÄ 
(
ÄÄ 
bytes
ÄÄ 
+
ÄÄ 
$num
ÄÄ 
)
ÄÄ 
=
ÄÄ 
(
ÄÄ  
byte
ÄÄ  $
)
ÄÄ$ %
(
ÄÄ% &
unsignedValue
ÄÄ& 3
>>
ÄÄ4 6
$num
ÄÄ7 8
)
ÄÄ8 9
;
ÄÄ9 :
*
ÅÅ 
(
ÅÅ 
bytes
ÅÅ 
+
ÅÅ 
$num
ÅÅ 
)
ÅÅ 
=
ÅÅ 
(
ÅÅ  
byte
ÅÅ  $
)
ÅÅ$ %
unsignedValue
ÅÅ% 2
;
ÅÅ2 3
}
ÇÇ 
}
ÉÉ 	
[
ÖÖ 	

MethodImpl
ÖÖ	 
(
ÖÖ 
MethodImplOptions
ÖÖ %
.
ÖÖ% & 
AggressiveInlining
ÖÖ& 8
)
ÖÖ8 9
]
ÖÖ9 :
internal
ÜÜ 
static
ÜÜ 
void
ÜÜ 
SetIntLE
ÜÜ %
(
ÜÜ% &
byte
ÜÜ& *
*
ÜÜ* +
bytes
ÜÜ, 1
,
ÜÜ1 2
int
ÜÜ3 6
value
ÜÜ7 <
)
ÜÜ< =
{
áá 	
	unchecked
àà 
{
ââ 
uint
ää 
unsignedValue
ää "
=
ää# $
(
ää% &
uint
ää& *
)
ää* +
value
ää+ 0
;
ää0 1
*
ãã 
bytes
ãã 
=
ãã 
(
ãã 
byte
ãã 
)
ãã 
unsignedValue
ãã ,
;
ãã, -
*
åå 
(
åå 
bytes
åå 
+
åå 
$num
åå 
)
åå 
=
åå 
(
åå  
byte
åå  $
)
åå$ %
(
åå% &
unsignedValue
åå& 3
>>
åå4 6
$num
åå7 8
)
åå8 9
;
åå9 :
*
çç 
(
çç 
bytes
çç 
+
çç 
$num
çç 
)
çç 
=
çç 
(
çç  
byte
çç  $
)
çç$ %
(
çç% &
unsignedValue
çç& 3
>>
çç4 6
$num
çç7 9
)
çç9 :
;
çç: ;
*
éé 
(
éé 
bytes
éé 
+
éé 
$num
éé 
)
éé 
=
éé 
(
éé  
byte
éé  $
)
éé$ %
(
éé% &
unsignedValue
éé& 3
>>
éé4 6
$num
éé7 9
)
éé9 :
;
éé: ;
}
èè 
}
êê 	
[
íí 	

MethodImpl
íí	 
(
íí 
MethodImplOptions
íí %
.
íí% & 
AggressiveInlining
íí& 8
)
íí8 9
]
íí9 :
internal
ìì 
static
ìì 
void
ìì 
SetLong
ìì $
(
ìì$ %
byte
ìì% )
*
ìì) *
bytes
ìì+ 0
,
ìì0 1
long
ìì2 6
value
ìì7 <
)
ìì< =
{
îî 	
	unchecked
ïï 
{
ññ 
ulong
óó 
unsignedValue
óó #
=
óó$ %
(
óó& '
ulong
óó' ,
)
óó, -
value
óó- 2
;
óó2 3
*
òò 
bytes
òò 
=
òò 
(
òò 
byte
òò 
)
òò 
(
òò  
unsignedValue
òò  -
>>
òò. 0
$num
òò1 3
)
òò3 4
;
òò4 5
*
ôô 
(
ôô 
bytes
ôô 
+
ôô 
$num
ôô 
)
ôô 
=
ôô 
(
ôô  
byte
ôô  $
)
ôô$ %
(
ôô% &
unsignedValue
ôô& 3
>>
ôô4 6
$num
ôô7 9
)
ôô9 :
;
ôô: ;
*
öö 
(
öö 
bytes
öö 
+
öö 
$num
öö 
)
öö 
=
öö 
(
öö  
byte
öö  $
)
öö$ %
(
öö% &
unsignedValue
öö& 3
>>
öö4 6
$num
öö7 9
)
öö9 :
;
öö: ;
*
õõ 
(
õõ 
bytes
õõ 
+
õõ 
$num
õõ 
)
õõ 
=
õõ 
(
õõ  
byte
õõ  $
)
õõ$ %
(
õõ% &
unsignedValue
õõ& 3
>>
õõ4 6
$num
õõ7 9
)
õõ9 :
;
õõ: ;
*
úú 
(
úú 
bytes
úú 
+
úú 
$num
úú 
)
úú 
=
úú 
(
úú  
byte
úú  $
)
úú$ %
(
úú% &
unsignedValue
úú& 3
>>
úú4 6
$num
úú7 9
)
úú9 :
;
úú: ;
*
ùù 
(
ùù 
bytes
ùù 
+
ùù 
$num
ùù 
)
ùù 
=
ùù 
(
ùù  
byte
ùù  $
)
ùù$ %
(
ùù% &
unsignedValue
ùù& 3
>>
ùù4 6
$num
ùù7 9
)
ùù9 :
;
ùù: ;
*
ûû 
(
ûû 
bytes
ûû 
+
ûû 
$num
ûû 
)
ûû 
=
ûû 
(
ûû  
byte
ûû  $
)
ûû$ %
(
ûû% &
unsignedValue
ûû& 3
>>
ûû4 6
$num
ûû7 8
)
ûû8 9
;
ûû9 :
*
üü 
(
üü 
bytes
üü 
+
üü 
$num
üü 
)
üü 
=
üü 
(
üü  
byte
üü  $
)
üü$ %
unsignedValue
üü% 2
;
üü2 3
}
†† 
}
°° 	
[
££ 	

MethodImpl
££	 
(
££ 
MethodImplOptions
££ %
.
££% & 
AggressiveInlining
££& 8
)
££8 9
]
££9 :
internal
§§ 
static
§§ 
void
§§ 
	SetLongLE
§§ &
(
§§& '
byte
§§' +
*
§§+ ,
bytes
§§- 2
,
§§2 3
long
§§4 8
value
§§9 >
)
§§> ?
{
•• 	
	unchecked
¶¶ 
{
ßß 
ulong
®® 
unsignedValue
®® #
=
®®$ %
(
®®& '
ulong
®®' ,
)
®®, -
value
®®- 2
;
®®2 3
*
©© 
bytes
©© 
=
©© 
(
©© 
byte
©© 
)
©© 
unsignedValue
©© ,
;
©©, -
*
™™ 
(
™™ 
bytes
™™ 
+
™™ 
$num
™™ 
)
™™ 
=
™™ 
(
™™  
byte
™™  $
)
™™$ %
(
™™% &
unsignedValue
™™& 3
>>
™™4 6
$num
™™7 8
)
™™8 9
;
™™9 :
*
´´ 
(
´´ 
bytes
´´ 
+
´´ 
$num
´´ 
)
´´ 
=
´´ 
(
´´  
byte
´´  $
)
´´$ %
(
´´% &
unsignedValue
´´& 3
>>
´´4 6
$num
´´7 9
)
´´9 :
;
´´: ;
*
¨¨ 
(
¨¨ 
bytes
¨¨ 
+
¨¨ 
$num
¨¨ 
)
¨¨ 
=
¨¨ 
(
¨¨  
byte
¨¨  $
)
¨¨$ %
(
¨¨% &
unsignedValue
¨¨& 3
>>
¨¨4 6
$num
¨¨7 9
)
¨¨9 :
;
¨¨: ;
*
≠≠ 
(
≠≠ 
bytes
≠≠ 
+
≠≠ 
$num
≠≠ 
)
≠≠ 
=
≠≠ 
(
≠≠  
byte
≠≠  $
)
≠≠$ %
(
≠≠% &
unsignedValue
≠≠& 3
>>
≠≠4 6
$num
≠≠7 9
)
≠≠9 :
;
≠≠: ;
*
ÆÆ 
(
ÆÆ 
bytes
ÆÆ 
+
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
=
ÆÆ 
(
ÆÆ  
byte
ÆÆ  $
)
ÆÆ$ %
(
ÆÆ% &
unsignedValue
ÆÆ& 3
>>
ÆÆ4 6
$num
ÆÆ7 9
)
ÆÆ9 :
;
ÆÆ: ;
*
ØØ 
(
ØØ 
bytes
ØØ 
+
ØØ 
$num
ØØ 
)
ØØ 
=
ØØ 
(
ØØ  
byte
ØØ  $
)
ØØ$ %
(
ØØ% &
unsignedValue
ØØ& 3
>>
ØØ4 6
$num
ØØ7 9
)
ØØ9 :
;
ØØ: ;
*
∞∞ 
(
∞∞ 
bytes
∞∞ 
+
∞∞ 
$num
∞∞ 
)
∞∞ 
=
∞∞ 
(
∞∞  
byte
∞∞  $
)
∞∞$ %
(
∞∞% &
unsignedValue
∞∞& 3
>>
∞∞4 6
$num
∞∞7 9
)
∞∞9 :
;
∞∞: ;
}
±± 
}
≤≤ 	
internal
¥¥ 
static
¥¥ 
void
¥¥ 
SetZero
¥¥ $
(
¥¥$ %
byte
¥¥% )
[
¥¥) *
]
¥¥* +
array
¥¥, 1
,
¥¥1 2
int
¥¥3 6
index
¥¥7 <
,
¥¥< =
int
¥¥> A
length
¥¥B H
)
¥¥H I
{
µµ 	
if
∂∂ 
(
∂∂ 
length
∂∂ 
==
∂∂ 
$num
∂∂ 
)
∂∂ 
{
∑∑ 
return
∏∏ 
;
∏∏ 
}
ππ 
PlatformDependent
∫∫ 
.
∫∫ 
	SetMemory
∫∫ '
(
∫∫' (
array
∫∫( -
,
∫∫- .
index
∫∫/ 4
,
∫∫4 5
length
∫∫6 <
,
∫∫< =
Zero
∫∫> B
)
∫∫B C
;
∫∫C D
}
ªª 	
internal
ΩΩ 
static
ΩΩ 
IByteBuffer
ΩΩ #
Copy
ΩΩ$ (
(
ΩΩ( ) 
AbstractByteBuffer
ΩΩ) ;
buf
ΩΩ< ?
,
ΩΩ? @
byte
ΩΩA E
*
ΩΩE F
addr
ΩΩG K
,
ΩΩK L
int
ΩΩM P
index
ΩΩQ V
,
ΩΩV W
int
ΩΩX [
length
ΩΩ\ b
)
ΩΩb c
{
ææ 	
IByteBuffer
øø 
copy
øø 
=
øø 
buf
øø "
.
øø" #
	Allocator
øø# ,
.
øø, -
DirectBuffer
øø- 9
(
øø9 :
length
øø: @
,
øø@ A
buf
øøB E
.
øøE F
MaxCapacity
øøF Q
)
øøQ R
;
øøR S
if
¿¿ 
(
¿¿ 
length
¿¿ 
!=
¿¿ 
$num
¿¿ 
)
¿¿ 
{
¡¡ 
if
¬¬ 
(
¬¬ 
copy
¬¬ 
.
¬¬ 
HasMemoryAddress
¬¬ )
)
¬¬) *
{
√√ 
IntPtr
ƒƒ 
ptr
ƒƒ 
=
ƒƒ  
copy
ƒƒ! %
.
ƒƒ% &#
AddressOfPinnedMemory
ƒƒ& ;
(
ƒƒ; <
)
ƒƒ< =
;
ƒƒ= >
if
≈≈ 
(
≈≈ 
ptr
≈≈ 
!=
≈≈ 
IntPtr
≈≈ %
.
≈≈% &
Zero
≈≈& *
)
≈≈* +
{
∆∆ 
PlatformDependent
«« )
.
««) *

CopyMemory
««* 4
(
««4 5
addr
««5 9
,
««9 :
(
««; <
byte
««< @
*
««@ A
)
««A B
ptr
««B E
,
««E F
length
««G M
)
««M N
;
««N O
}
»» 
else
…… 
{
   
fixed
ÀÀ 
(
ÀÀ 
byte
ÀÀ #
*
ÀÀ# $
dst
ÀÀ% (
=
ÀÀ) *
&
ÀÀ+ ,
copy
ÀÀ, 0
.
ÀÀ0 1&
GetPinnableMemoryAddress
ÀÀ1 I
(
ÀÀI J
)
ÀÀJ K
)
ÀÀK L
{
ÃÃ 
PlatformDependent
ÕÕ -
.
ÕÕ- .

CopyMemory
ÕÕ. 8
(
ÕÕ8 9
addr
ÕÕ9 =
,
ÕÕ= >
dst
ÕÕ? B
,
ÕÕB C
length
ÕÕD J
)
ÕÕJ K
;
ÕÕK L
}
ŒŒ 
}
œœ 
copy
–– 
.
–– 
SetIndex
–– !
(
––! "
$num
––" #
,
––# $
length
––% +
)
––+ ,
;
––, -
}
—— 
else
““ 
{
”” 
copy
‘‘ 
.
‘‘ 

WriteBytes
‘‘ #
(
‘‘# $
buf
‘‘$ '
,
‘‘' (
index
‘‘) .
,
‘‘. /
length
‘‘0 6
)
‘‘6 7
;
‘‘7 8
}
’’ 
}
÷÷ 
return
◊◊ 
copy
◊◊ 
;
◊◊ 
}
ÿÿ 	
internal
⁄⁄ 
static
⁄⁄ 
int
⁄⁄ 
SetBytes
⁄⁄ $
(
⁄⁄$ % 
AbstractByteBuffer
⁄⁄% 7
buf
⁄⁄8 ;
,
⁄⁄; <
byte
⁄⁄= A
*
⁄⁄A B
addr
⁄⁄C G
,
⁄⁄G H
int
⁄⁄I L
index
⁄⁄M R
,
⁄⁄R S
Stream
⁄⁄T Z
input
⁄⁄[ `
,
⁄⁄` a
int
⁄⁄b e
length
⁄⁄f l
)
⁄⁄l m
{
€€ 	
if
‹‹ 
(
‹‹ 
length
‹‹ 
==
‹‹ 
$num
‹‹ 
)
‹‹ 
{
›› 
return
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
IByteBuffer
·· 
tmpBuf
·· 
=
··  
buf
··! $
.
··$ %
	Allocator
··% .
.
··. /

HeapBuffer
··/ 9
(
··9 :
length
··: @
)
··@ A
;
··A B
try
‚‚ 
{
„„ 
byte
‰‰ 
[
‰‰ 
]
‰‰ 
tmp
‰‰ 
=
‰‰ 
tmpBuf
‰‰ #
.
‰‰# $
Array
‰‰$ )
;
‰‰) *
int
ÂÂ 
offset
ÂÂ 
=
ÂÂ 
tmpBuf
ÂÂ #
.
ÂÂ# $
ArrayOffset
ÂÂ$ /
;
ÂÂ/ 0
int
ÊÊ 
	readBytes
ÊÊ 
=
ÊÊ 
input
ÊÊ  %
.
ÊÊ% &
Read
ÊÊ& *
(
ÊÊ* +
tmp
ÊÊ+ .
,
ÊÊ. /
offset
ÊÊ0 6
,
ÊÊ6 7
length
ÊÊ8 >
)
ÊÊ> ?
;
ÊÊ? @
if
ÁÁ 
(
ÁÁ 
	readBytes
ÁÁ 
>
ÁÁ 
$num
ÁÁ  !
)
ÁÁ! "
{
ËË 
PlatformDependent
ÈÈ %
.
ÈÈ% &

CopyMemory
ÈÈ& 0
(
ÈÈ0 1
tmp
ÈÈ1 4
,
ÈÈ4 5
offset
ÈÈ6 <
,
ÈÈ< =
addr
ÈÈ> B
,
ÈÈB C
	readBytes
ÈÈD M
)
ÈÈM N
;
ÈÈN O
}
ÍÍ 
return
ÏÏ 
	readBytes
ÏÏ  
;
ÏÏ  !
}
ÌÌ 
finally
ÓÓ 
{
ÔÔ 
tmpBuf
 
.
 
Release
 
(
 
)
  
;
  !
}
ÒÒ 
}
ÚÚ 	
internal
ÙÙ 
static
ÙÙ 
Task
ÙÙ 
<
ÙÙ 
int
ÙÙ  
>
ÙÙ  !
SetBytesAsync
ÙÙ" /
(
ÙÙ/ 0 
AbstractByteBuffer
ÙÙ0 B
buf
ÙÙC F
,
ÙÙF G
byte
ÙÙH L
*
ÙÙL M
addr
ÙÙN R
,
ÙÙR S
int
ÙÙT W
index
ÙÙX ]
,
ÙÙ] ^
Stream
ÙÙ_ e
input
ÙÙf k
,
ÙÙk l
int
ÙÙm p
length
ÙÙq w
,
ÙÙw x 
CancellationTokenÙÙy ä!
cancellationTokenÙÙã ú
)ÙÙú ù
{
ıı 	
if
ˆˆ 
(
ˆˆ 
length
ˆˆ 
==
ˆˆ 
$num
ˆˆ 
)
ˆˆ 
{
˜˜ 
return
¯¯ 
TaskEx
¯¯ 
.
¯¯ 
Zero
¯¯ "
;
¯¯" #
}
˘˘ 
IByteBuffer
˚˚ 
tmpBuf
˚˚ 
=
˚˚  
buf
˚˚! $
.
˚˚$ %
	Allocator
˚˚% .
.
˚˚. /

HeapBuffer
˚˚/ 9
(
˚˚9 :
length
˚˚: @
)
˚˚@ A
;
˚˚A B
return
¸¸ 
tmpBuf
¸¸ 
.
¸¸ 
SetBytesAsync
¸¸ '
(
¸¸' (
$num
¸¸( )
,
¸¸) *
input
¸¸+ 0
,
¸¸0 1
length
¸¸2 8
,
¸¸8 9
cancellationToken
¸¸: K
)
¸¸K L
.
˝˝ 
ContinueWith
˝˝ 
(
˝˝ 
t
˝˝ 
=>
˝˝  "
{
˝˝# $
try
˛˛ 
{
ˇˇ 
var
ÄÄ 
read
ÄÄ  
=
ÄÄ! "
t
ÄÄ# $
.
ÄÄ$ %
Result
ÄÄ% +
;
ÄÄ+ ,
if
ÅÅ 
(
ÅÅ 
read
ÅÅ  
>
ÅÅ! "
$num
ÅÅ# $
)
ÅÅ$ %
{
ÇÇ 
PlatformDependent
ÉÉ -
.
ÉÉ- .

CopyMemory
ÉÉ. 8
(
ÉÉ8 9
tmpBuf
ÉÉ9 ?
.
ÉÉ? @
Array
ÉÉ@ E
,
ÉÉE F
tmpBuf
ÉÉG M
.
ÉÉM N
ArrayOffset
ÉÉN Y
,
ÉÉY Z
addr
ÉÉ[ _
,
ÉÉ_ `
read
ÉÉa e
)
ÉÉe f
;
ÉÉf g
}
ÑÑ 
return
ÖÖ 
read
ÖÖ #
;
ÖÖ# $
}
ÜÜ 
finally
áá 
{
àà 
tmpBuf
ââ 
.
ââ 
Release
ââ &
(
ââ& '
)
ââ' (
;
ââ( )
}
ää 
}
ãã 
)
ãã 
;
ãã 
}
åå 	
internal
éé 
static
éé 
void
éé 
GetBytes
éé %
(
éé% & 
AbstractByteBuffer
éé& 8
buf
éé9 <
,
éé< =
byte
éé> B
*
ééB C
addr
ééD H
,
ééH I
int
ééJ M
index
ééN S
,
ééS T
IByteBuffer
ééU `
dst
ééa d
,
ééd e
int
ééf i
dstIndex
ééj r
,
éér s
int
éét w
length
ééx ~
)
éé~ 
{
èè 	
Contract
êê 
.
êê 
Requires
êê 
(
êê 
dst
êê !
!=
êê" $
null
êê% )
)
êê) *
;
êê* +
if
íí 
(
íí 
MathUtil
íí 
.
íí 
IsOutOfBounds
íí &
(
íí& '
dstIndex
íí' /
,
íí/ 0
length
íí1 7
,
íí7 8
dst
íí9 <
.
íí< =
Capacity
íí= E
)
ííE F
)
ííF G
{
ìì 
ThrowHelper
îî 
.
îî 4
&ThrowIndexOutOfRangeException_DstIndex
îî B
(
îîB C
dstIndex
îîC K
)
îîK L
;
îîL M
}
ïï 
if
óó 
(
óó 
dst
óó 
.
óó 
HasMemoryAddress
óó $
)
óó$ %
{
òò 
IntPtr
ôô 
ptr
ôô 
=
ôô 
dst
ôô  
.
ôô  !#
AddressOfPinnedMemory
ôô! 6
(
ôô6 7
)
ôô7 8
;
ôô8 9
if
öö 
(
öö 
ptr
öö 
!=
öö 
IntPtr
öö !
.
öö! "
Zero
öö" &
)
öö& '
{
õõ 
PlatformDependent
úú %
.
úú% &

CopyMemory
úú& 0
(
úú0 1
addr
úú1 5
,
úú5 6
(
úú7 8
byte
úú8 <
*
úú< =
)
úú= >
(
úú> ?
ptr
úú? B
+
úúC D
dstIndex
úúE M
)
úúM N
,
úúN O
length
úúP V
)
úúV W
;
úúW X
}
ùù 
else
ûû 
{
üü 
fixed
†† 
(
†† 
byte
†† 
*
††  
destination
††! ,
=
††- .
&
††/ 0
dst
††0 3
.
††3 4&
GetPinnableMemoryAddress
††4 L
(
††L M
)
††M N
)
††N O
{
°° 
PlatformDependent
¢¢ )
.
¢¢) *

CopyMemory
¢¢* 4
(
¢¢4 5
addr
¢¢5 9
,
¢¢9 :
destination
¢¢; F
+
¢¢G H
dstIndex
¢¢I Q
,
¢¢Q R
length
¢¢S Y
)
¢¢Y Z
;
¢¢Z [
}
££ 
}
§§ 
}
•• 
else
¶¶ 
if
¶¶ 
(
¶¶ 
dst
¶¶ 
.
¶¶ 
HasArray
¶¶ !
)
¶¶! "
{
ßß 
PlatformDependent
®® !
.
®®! "

CopyMemory
®®" ,
(
®®, -
addr
®®- 1
,
®®1 2
dst
®®3 6
.
®®6 7
Array
®®7 <
,
®®< =
dst
®®> A
.
®®A B
ArrayOffset
®®B M
+
®®N O
dstIndex
®®P X
,
®®X Y
length
®®Z `
)
®®` a
;
®®a b
}
©© 
else
™™ 
{
´´ 
dst
¨¨ 
.
¨¨ 
SetBytes
¨¨ 
(
¨¨ 
dstIndex
¨¨ %
,
¨¨% &
buf
¨¨' *
,
¨¨* +
index
¨¨, 1
,
¨¨1 2
length
¨¨3 9
)
¨¨9 :
;
¨¨: ;
}
≠≠ 
}
ÆÆ 	
internal
∞∞ 
static
∞∞ 
void
∞∞ 
GetBytes
∞∞ %
(
∞∞% & 
AbstractByteBuffer
∞∞& 8
buf
∞∞9 <
,
∞∞< =
byte
∞∞> B
*
∞∞B C
addr
∞∞D H
,
∞∞H I
int
∞∞J M
index
∞∞N S
,
∞∞S T
byte
∞∞U Y
[
∞∞Y Z
]
∞∞Z [
dst
∞∞\ _
,
∞∞_ `
int
∞∞a d
dstIndex
∞∞e m
,
∞∞m n
int
∞∞o r
length
∞∞s y
)
∞∞y z
{
±± 	
Contract
≤≤ 
.
≤≤ 
Requires
≤≤ 
(
≤≤ 
dst
≤≤ !
!=
≤≤" $
null
≤≤% )
)
≤≤) *
;
≤≤* +
if
¥¥ 
(
¥¥ 
MathUtil
¥¥ 
.
¥¥ 
IsOutOfBounds
¥¥ &
(
¥¥& '
dstIndex
¥¥' /
,
¥¥/ 0
length
¥¥1 7
,
¥¥7 8
dst
¥¥9 <
.
¥¥< =
Length
¥¥= C
)
¥¥C D
)
¥¥D E
{
µµ 
ThrowHelper
∂∂ 
.
∂∂ 4
&ThrowIndexOutOfRangeException_DstIndex
∂∂ B
(
∂∂B C
dstIndex
∂∂C K
)
∂∂K L
;
∂∂L M
}
∑∑ 
if
∏∏ 
(
∏∏ 
length
∏∏ 
!=
∏∏ 
$num
∏∏ 
)
∏∏ 
{
ππ 
PlatformDependent
∫∫ !
.
∫∫! "

CopyMemory
∫∫" ,
(
∫∫, -
addr
∫∫- 1
,
∫∫1 2
dst
∫∫3 6
,
∫∫6 7
dstIndex
∫∫8 @
,
∫∫@ A
length
∫∫B H
)
∫∫H I
;
∫∫I J
}
ªª 
}
ºº 	
internal
ææ 
static
ææ 
void
ææ 
SetBytes
ææ %
(
ææ% & 
AbstractByteBuffer
ææ& 8
buf
ææ9 <
,
ææ< =
byte
ææ> B
*
ææB C
addr
ææD H
,
ææH I
int
ææJ M
index
ææN S
,
ææS T
IByteBuffer
ææU `
src
ææa d
,
ææd e
int
ææf i
srcIndex
ææj r
,
æær s
int
ææt w
length
ææx ~
)
ææ~ 
{
øø 	
Contract
¿¿ 
.
¿¿ 
Requires
¿¿ 
(
¿¿ 
src
¿¿ !
!=
¿¿" $
null
¿¿% )
)
¿¿) *
;
¿¿* +
if
¬¬ 
(
¬¬ 
MathUtil
¬¬ 
.
¬¬ 
IsOutOfBounds
¬¬ &
(
¬¬& '
srcIndex
¬¬' /
,
¬¬/ 0
length
¬¬1 7
,
¬¬7 8
src
¬¬9 <
.
¬¬< =
Capacity
¬¬= E
)
¬¬E F
)
¬¬F G
{
√√ 
ThrowHelper
ƒƒ 
.
ƒƒ 4
&ThrowIndexOutOfRangeException_SrcIndex
ƒƒ B
(
ƒƒB C
srcIndex
ƒƒC K
)
ƒƒK L
;
ƒƒL M
}
≈≈ 
if
«« 
(
«« 
length
«« 
!=
«« 
$num
«« 
)
«« 
{
»» 
if
…… 
(
…… 
src
…… 
.
…… 
HasMemoryAddress
…… (
)
……( )
{
   
IntPtr
ÀÀ 
ptr
ÀÀ 
=
ÀÀ  
src
ÀÀ! $
.
ÀÀ$ %#
AddressOfPinnedMemory
ÀÀ% :
(
ÀÀ: ;
)
ÀÀ; <
;
ÀÀ< =
if
ÃÃ 
(
ÃÃ 
ptr
ÃÃ 
!=
ÃÃ 
IntPtr
ÃÃ %
.
ÃÃ% &
Zero
ÃÃ& *
)
ÃÃ* +
{
ÕÕ 
PlatformDependent
ŒŒ )
.
ŒŒ) *

CopyMemory
ŒŒ* 4
(
ŒŒ4 5
(
ŒŒ5 6
byte
ŒŒ6 :
*
ŒŒ: ;
)
ŒŒ; <
(
ŒŒ< =
ptr
ŒŒ= @
+
ŒŒA B
srcIndex
ŒŒC K
)
ŒŒK L
,
ŒŒL M
addr
ŒŒN R
,
ŒŒR S
length
ŒŒT Z
)
ŒŒZ [
;
ŒŒ[ \
}
œœ 
else
–– 
{
—— 
fixed
““ 
(
““ 
byte
““ #
*
““# $
source
““% +
=
““, -
&
““. /
src
““/ 2
.
““2 3&
GetPinnableMemoryAddress
““3 K
(
““K L
)
““L M
)
““M N
{
”” 
PlatformDependent
‘‘ -
.
‘‘- .

CopyMemory
‘‘. 8
(
‘‘8 9
source
‘‘9 ?
+
‘‘@ A
srcIndex
‘‘B J
,
‘‘J K
addr
‘‘L P
,
‘‘P Q
length
‘‘R X
)
‘‘X Y
;
‘‘Y Z
}
’’ 
}
÷÷ 
}
◊◊ 
else
ÿÿ 
if
ÿÿ 
(
ÿÿ 
src
ÿÿ 
.
ÿÿ 
HasArray
ÿÿ %
)
ÿÿ% &
{
ŸŸ 
PlatformDependent
⁄⁄ %
.
⁄⁄% &

CopyMemory
⁄⁄& 0
(
⁄⁄0 1
src
⁄⁄1 4
.
⁄⁄4 5
Array
⁄⁄5 :
,
⁄⁄: ;
src
⁄⁄< ?
.
⁄⁄? @
ArrayOffset
⁄⁄@ K
+
⁄⁄L M
srcIndex
⁄⁄N V
,
⁄⁄V W
addr
⁄⁄X \
,
⁄⁄\ ]
length
⁄⁄^ d
)
⁄⁄d e
;
⁄⁄e f
}
€€ 
else
‹‹ 
{
›› 
src
ﬁﬁ 
.
ﬁﬁ 
GetBytes
ﬁﬁ  
(
ﬁﬁ  !
srcIndex
ﬁﬁ! )
,
ﬁﬁ) *
buf
ﬁﬁ+ .
,
ﬁﬁ. /
index
ﬁﬁ0 5
,
ﬁﬁ5 6
length
ﬁﬁ7 =
)
ﬁﬁ= >
;
ﬁﬁ> ?
}
ﬂﬂ 
}
‡‡ 
}
·· 	
internal
‰‰ 
static
‰‰ 
void
‰‰ 
SetBytes
‰‰ %
(
‰‰% & 
AbstractByteBuffer
‰‰& 8
buf
‰‰9 <
,
‰‰< =
byte
‰‰> B
*
‰‰B C
addr
‰‰D H
,
‰‰H I
int
‰‰J M
index
‰‰N S
,
‰‰S T
byte
‰‰U Y
[
‰‰Y Z
]
‰‰Z [
src
‰‰\ _
,
‰‰_ `
int
‰‰a d
srcIndex
‰‰e m
,
‰‰m n
int
‰‰o r
length
‰‰s y
)
‰‰y z
=>
‰‰{ }
PlatformDependent
ÂÂ !
.
ÂÂ! "

CopyMemory
ÂÂ" ,
(
ÂÂ, -
src
ÂÂ- 0
,
ÂÂ0 1
srcIndex
ÂÂ2 :
,
ÂÂ: ;
addr
ÂÂ< @
,
ÂÂ@ A
length
ÂÂB H
)
ÂÂH I
;
ÂÂI J
internal
ÁÁ 
static
ÁÁ 
void
ÁÁ 
GetBytes
ÁÁ %
(
ÁÁ% & 
AbstractByteBuffer
ÁÁ& 8
buf
ÁÁ9 <
,
ÁÁ< =
byte
ÁÁ> B
*
ÁÁB C
addr
ÁÁD H
,
ÁÁH I
int
ÁÁJ M
index
ÁÁN S
,
ÁÁS T
Stream
ÁÁU [
output
ÁÁ\ b
,
ÁÁb c
int
ÁÁd g
length
ÁÁh n
)
ÁÁn o
{
ËË 	
if
ÈÈ 
(
ÈÈ 
length
ÈÈ 
!=
ÈÈ 
$num
ÈÈ 
)
ÈÈ 
{
ÍÍ 
IByteBuffer
ÎÎ 
tmpBuf
ÎÎ "
=
ÎÎ# $
buf
ÎÎ% (
.
ÎÎ( )
	Allocator
ÎÎ) 2
.
ÎÎ2 3

HeapBuffer
ÎÎ3 =
(
ÎÎ= >
length
ÎÎ> D
)
ÎÎD E
;
ÎÎE F
try
ÏÏ 
{
ÌÌ 
byte
ÓÓ 
[
ÓÓ 
]
ÓÓ 
tmp
ÓÓ 
=
ÓÓ  
tmpBuf
ÓÓ! '
.
ÓÓ' (
Array
ÓÓ( -
;
ÓÓ- .
int
ÔÔ 
offset
ÔÔ 
=
ÔÔ  
tmpBuf
ÔÔ! '
.
ÔÔ' (
ArrayOffset
ÔÔ( 3
;
ÔÔ3 4
PlatformDependent
 %
.
% &

CopyMemory
& 0
(
0 1
addr
1 5
,
5 6
tmp
7 :
,
: ;
offset
< B
,
B C
length
D J
)
J K
;
K L
output
ÒÒ 
.
ÒÒ 
Write
ÒÒ  
(
ÒÒ  !
tmp
ÒÒ! $
,
ÒÒ$ %
offset
ÒÒ& ,
,
ÒÒ, -
length
ÒÒ. 4
)
ÒÒ4 5
;
ÒÒ5 6
}
ÚÚ 
finally
ÛÛ 
{
ÙÙ 
tmpBuf
ıı 
.
ıı 
Release
ıı "
(
ıı" #
)
ıı# $
;
ıı$ %
}
ˆˆ 
}
˜˜ 
}
¯¯ 	
internal
˙˙ 
static
˙˙ 
void
˙˙ 
SetZero
˙˙ $
(
˙˙$ %
byte
˙˙% )
*
˙˙) *
addr
˙˙+ /
,
˙˙/ 0
int
˙˙1 4
length
˙˙5 ;
)
˙˙; <
{
˚˚ 	
if
¸¸ 
(
¸¸ 
length
¸¸ 
==
¸¸ 
$num
¸¸ 
)
¸¸ 
{
˝˝ 
return
˛˛ 
;
˛˛ 
}
ˇˇ 
PlatformDependent
ÄÄ 
.
ÄÄ 
	SetMemory
ÄÄ '
(
ÄÄ' (
addr
ÄÄ( ,
,
ÄÄ, -
length
ÄÄ. 4
,
ÄÄ4 5
Zero
ÄÄ6 :
)
ÄÄ: ;
;
ÄÄ; <
}
ÅÅ 	
internal
ÉÉ 
static
ÉÉ 
string
ÉÉ 
	GetString
ÉÉ (
(
ÉÉ( )
byte
ÉÉ) -
*
ÉÉ- .
src
ÉÉ/ 2
,
ÉÉ2 3
int
ÉÉ4 7
length
ÉÉ8 >
,
ÉÉ> ?
Encoding
ÉÉ@ H
encoding
ÉÉI Q
)
ÉÉQ R
{
ÑÑ 	
return
ÜÜ 
encoding
ÜÜ 
.
ÜÜ 
	GetString
ÜÜ %
(
ÜÜ% &
src
ÜÜ& )
,
ÜÜ) *
length
ÜÜ+ 1
)
ÜÜ1 2
;
ÜÜ2 3
}
çç 	
internal
èè 
static
èè ,
UnpooledUnsafeDirectByteBuffer
èè 6'
NewUnsafeDirectByteBuffer
èè7 P
(
èèP Q"
IByteBufferAllocator
èèQ e
alloc
èèf k
,
èèk l
int
èèm p
initialCapacityèèq Ä
,èèÄ Å
intèèÇ Ö
maxCapacityèèÜ ë
)èèë í
=>èèì ï
new
êê ,
UnpooledUnsafeDirectByteBuffer
êê .
(
êê. /
alloc
êê/ 4
,
êê4 5
initialCapacity
êê6 E
,
êêE F
maxCapacity
êêG R
)
êêR S
;
êêS T
}
ëë 
}íí Æ—
dC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\WrappedByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	
WrappedByteBuffer
 
: 
IByteBuffer )
{ 
	protected 
readonly 
IByteBuffer &
Buf' *
;* +
	protected 
WrappedByteBuffer #
(# $
IByteBuffer$ /
buf0 3
)3 4
{ 	
Contract 
. 
Requires 
( 
buf !
!=" $
null% )
)) *
;* +
this 
. 
Buf 
= 
buf 
; 
} 	
public 
bool 
HasMemoryAddress $
=>% '
this( ,
., -
Buf- 0
.0 1
HasMemoryAddress1 A
;A B
public!! 
ref!! 
byte!! $
GetPinnableMemoryAddress!! 0
(!!0 1
)!!1 2
=>!!3 5
ref!!6 9
this!!: >
.!!> ?
Buf!!? B
.!!B C$
GetPinnableMemoryAddress!!C [
(!![ \
)!!\ ]
;!!] ^
public## 
IntPtr## !
AddressOfPinnedMemory## +
(##+ ,
)##, -
=>##. 0
this##1 5
.##5 6
Buf##6 9
.##9 :!
AddressOfPinnedMemory##: O
(##O P
)##P Q
;##Q R
public%% 
int%% 
Capacity%% 
=>%% 
this%% #
.%%# $
Buf%%$ '
.%%' (
Capacity%%( 0
;%%0 1
public'' 
virtual'' 
IByteBuffer'' "
AdjustCapacity''# 1
(''1 2
int''2 5
newCapacity''6 A
)''A B
{(( 	
this)) 
.)) 
Buf)) 
.)) 
AdjustCapacity)) #
())# $
newCapacity))$ /
)))/ 0
;))0 1
return** 
this** 
;** 
}++ 	
public-- 
int-- 
MaxCapacity-- 
=>-- !
this--" &
.--& '
Buf--' *
.--* +
MaxCapacity--+ 6
;--6 7
public//  
IByteBufferAllocator// #
	Allocator//$ -
=>//. 0
this//1 5
.//5 6
Buf//6 9
.//9 :
	Allocator//: C
;//C D
public11 
IByteBuffer11 
Unwrap11 !
(11! "
)11" #
=>11$ &
this11' +
.11+ ,
Buf11, /
;11/ 0
public33 
bool33 
IsDirect33 
=>33 
this33  $
.33$ %
Buf33% (
.33( )
IsDirect33) 1
;331 2
public55 
int55 
ReaderIndex55 
=>55 !
this55" &
.55& '
Buf55' *
.55* +
ReaderIndex55+ 6
;556 7
public77 
IByteBuffer77 
SetReaderIndex77 )
(77) *
int77* -
readerIndex77. 9
)779 :
{88 	
this99 
.99 
Buf99 
.99 
SetReaderIndex99 #
(99# $
readerIndex99$ /
)99/ 0
;990 1
return:: 
this:: 
;:: 
};; 	
public== 
int== 
WriterIndex== 
=>== !
this==" &
.==& '
Buf==' *
.==* +
WriterIndex==+ 6
;==6 7
public?? 
IByteBuffer?? 
SetWriterIndex?? )
(??) *
int??* -
writerIndex??. 9
)??9 :
{@@ 	
thisAA 
.AA 
BufAA 
.AA 
SetWriterIndexAA #
(AA# $
writerIndexAA$ /
)AA/ 0
;AA0 1
returnBB 
thisBB 
;BB 
}CC 	
publicEE 
virtualEE 
IByteBufferEE "
SetIndexEE# +
(EE+ ,
intEE, /
readerIndexEE0 ;
,EE; <
intEE= @
writerIndexEEA L
)EEL M
{FF 	
thisGG 
.GG 
BufGG 
.GG 
SetIndexGG 
(GG 
readerIndexGG )
,GG) *
writerIndexGG+ 6
)GG6 7
;GG7 8
returnHH 
thisHH 
;HH 
}II 	
publicKK 
intKK 
ReadableBytesKK  
=>KK! #
thisKK$ (
.KK( )
BufKK) ,
.KK, -
ReadableBytesKK- :
;KK: ;
publicMM 
intMM 
WritableBytesMM  
=>MM! #
thisMM$ (
.MM( )
BufMM) ,
.MM, -
WritableBytesMM- :
;MM: ;
publicOO 
intOO 
MaxWritableBytesOO #
=>OO$ &
thisOO' +
.OO+ ,
BufOO, /
.OO/ 0
MaxWritableBytesOO0 @
;OO@ A
publicQQ 
boolQQ 

IsReadableQQ 
(QQ 
)QQ  
=>QQ! #
thisQQ$ (
.QQ( )
BufQQ) ,
.QQ, -

IsReadableQQ- 7
(QQ7 8
)QQ8 9
;QQ9 :
publicSS 
boolSS 

IsWritableSS 
(SS 
)SS  
=>SS! #
thisSS$ (
.SS( )
BufSS) ,
.SS, -

IsWritableSS- 7
(SS7 8
)SS8 9
;SS9 :
publicUU 
IByteBufferUU 
ClearUU  
(UU  !
)UU! "
{VV 	
thisWW 
.WW 
BufWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
returnXX 
thisXX 
;XX 
}YY 	
public[[ 
IByteBuffer[[ 
MarkReaderIndex[[ *
([[* +
)[[+ ,
{\\ 	
this]] 
.]] 
Buf]] 
.]] 
MarkReaderIndex]] $
(]]$ %
)]]% &
;]]& '
return^^ 
this^^ 
;^^ 
}__ 	
publicaa 
IByteBufferaa 
ResetReaderIndexaa +
(aa+ ,
)aa, -
{bb 	
thiscc 
.cc 
Bufcc 
.cc 
ResetReaderIndexcc %
(cc% &
)cc& '
;cc' (
returndd 
thisdd 
;dd 
}ee 	
publicgg 
IByteBuffergg 
MarkWriterIndexgg *
(gg* +
)gg+ ,
{hh 	
thisii 
.ii 
Bufii 
.ii 
MarkWriterIndexii $
(ii$ %
)ii% &
;ii& '
returnjj 
thisjj 
;jj 
}kk 	
publicmm 
IByteBuffermm 
ResetWriterIndexmm +
(mm+ ,
)mm, -
{nn 	
thisoo 
.oo 
Bufoo 
.oo 
ResetWriterIndexoo %
(oo% &
)oo& '
;oo' (
returnpp 
thispp 
;pp 
}qq 	
publicss 
virtualss 
IByteBufferss "
DiscardReadBytesss# 3
(ss3 4
)ss4 5
{tt 	
thisuu 
.uu 
Bufuu 
.uu 
DiscardReadBytesuu %
(uu% &
)uu& '
;uu' (
returnvv 
thisvv 
;vv 
}ww 	
publicyy 
virtualyy 
IByteBufferyy " 
DiscardSomeReadBytesyy# 7
(yy7 8
)yy8 9
{zz 	
this{{ 
.{{ 
Buf{{ 
.{{  
DiscardSomeReadBytes{{ )
({{) *
){{* +
;{{+ ,
return|| 
this|| 
;|| 
}}} 	
public 
virtual 
IByteBuffer "
EnsureWritable# 1
(1 2
int2 5
minWritableBytes6 F
)F G
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
Buf
ÅÅ 
.
ÅÅ 
EnsureWritable
ÅÅ #
(
ÅÅ# $
minWritableBytes
ÅÅ$ 4
)
ÅÅ4 5
;
ÅÅ5 6
return
ÇÇ 
this
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
virtual
ÖÖ 
int
ÖÖ 
EnsureWritable
ÖÖ )
(
ÖÖ) *
int
ÖÖ* -
minWritableBytes
ÖÖ. >
,
ÖÖ> ?
bool
ÖÖ@ D
force
ÖÖE J
)
ÖÖJ K
=>
ÖÖL N
this
ÖÖO S
.
ÖÖS T
Buf
ÖÖT W
.
ÖÖW X
EnsureWritable
ÖÖX f
(
ÖÖf g
minWritableBytes
ÖÖg w
,
ÖÖw x
force
ÖÖy ~
)
ÖÖ~ 
;ÖÖ Ä
public
áá 
virtual
áá 
bool
áá 

GetBoolean
áá &
(
áá& '
int
áá' *
index
áá+ 0
)
áá0 1
=>
áá2 4
this
áá5 9
.
áá9 :
Buf
áá: =
.
áá= >

GetBoolean
áá> H
(
ááH I
index
ááI N
)
ááN O
;
ááO P
public
ââ 
virtual
ââ 
byte
ââ 
GetByte
ââ #
(
ââ# $
int
ââ$ '
index
ââ( -
)
ââ- .
=>
ââ/ 1
this
ââ2 6
.
ââ6 7
Buf
ââ7 :
.
ââ: ;
GetByte
ââ; B
(
ââB C
index
ââC H
)
ââH I
;
ââI J
public
ãã 
virtual
ãã 
short
ãã 
GetShort
ãã %
(
ãã% &
int
ãã& )
index
ãã* /
)
ãã/ 0
=>
ãã1 3
this
ãã4 8
.
ãã8 9
Buf
ãã9 <
.
ãã< =
GetShort
ãã= E
(
ããE F
index
ããF K
)
ããK L
;
ããL M
public
çç 
virtual
çç 
short
çç 

GetShortLE
çç '
(
çç' (
int
çç( +
index
çç, 1
)
çç1 2
=>
çç3 5
this
çç6 :
.
çç: ;
Buf
çç; >
.
çç> ?

GetShortLE
çç? I
(
ççI J
index
ççJ O
)
ççO P
;
ççP Q
public
èè 
virtual
èè 
ushort
èè 
GetUnsignedShort
èè .
(
èè. /
int
èè/ 2
index
èè3 8
)
èè8 9
=>
èè: <
this
èè= A
.
èèA B
Buf
èèB E
.
èèE F
GetUnsignedShort
èèF V
(
èèV W
index
èèW \
)
èè\ ]
;
èè] ^
public
ëë 
virtual
ëë 
ushort
ëë  
GetUnsignedShortLE
ëë 0
(
ëë0 1
int
ëë1 4
index
ëë5 :
)
ëë: ;
=>
ëë< >
this
ëë? C
.
ëëC D
Buf
ëëD G
.
ëëG H 
GetUnsignedShortLE
ëëH Z
(
ëëZ [
index
ëë[ `
)
ëë` a
;
ëëa b
public
ìì 
virtual
ìì 
int
ìì 
	GetMedium
ìì $
(
ìì$ %
int
ìì% (
index
ìì) .
)
ìì. /
=>
ìì0 2
this
ìì3 7
.
ìì7 8
Buf
ìì8 ;
.
ìì; <
	GetMedium
ìì< E
(
ììE F
index
ììF K
)
ììK L
;
ììL M
public
ïï 
virtual
ïï 
int
ïï 
GetMediumLE
ïï &
(
ïï& '
int
ïï' *
index
ïï+ 0
)
ïï0 1
=>
ïï2 4
this
ïï5 9
.
ïï9 :
Buf
ïï: =
.
ïï= >
GetMediumLE
ïï> I
(
ïïI J
index
ïïJ O
)
ïïO P
;
ïïP Q
public
óó 
virtual
óó 
int
óó 
GetUnsignedMedium
óó ,
(
óó, -
int
óó- 0
index
óó1 6
)
óó6 7
=>
óó8 :
this
óó; ?
.
óó? @
Buf
óó@ C
.
óóC D
GetUnsignedMedium
óóD U
(
óóU V
index
óóV [
)
óó[ \
;
óó\ ]
public
ôô 
virtual
ôô 
int
ôô !
GetUnsignedMediumLE
ôô .
(
ôô. /
int
ôô/ 2
index
ôô3 8
)
ôô8 9
=>
ôô: <
this
ôô= A
.
ôôA B
Buf
ôôB E
.
ôôE F!
GetUnsignedMediumLE
ôôF Y
(
ôôY Z
index
ôôZ _
)
ôô_ `
;
ôô` a
public
õõ 
virtual
õõ 
int
õõ 
GetInt
õõ !
(
õõ! "
int
õõ" %
index
õõ& +
)
õõ+ ,
=>
õõ- /
this
õõ0 4
.
õõ4 5
Buf
õõ5 8
.
õõ8 9
GetInt
õõ9 ?
(
õõ? @
index
õõ@ E
)
õõE F
;
õõF G
public
ùù 
virtual
ùù 
int
ùù 
GetIntLE
ùù #
(
ùù# $
int
ùù$ '
index
ùù( -
)
ùù- .
=>
ùù/ 1
this
ùù2 6
.
ùù6 7
Buf
ùù7 :
.
ùù: ;
GetIntLE
ùù; C
(
ùùC D
index
ùùD I
)
ùùI J
;
ùùJ K
public
üü 
virtual
üü 
uint
üü 
GetUnsignedInt
üü *
(
üü* +
int
üü+ .
index
üü/ 4
)
üü4 5
=>
üü6 8
this
üü9 =
.
üü= >
Buf
üü> A
.
üüA B
GetUnsignedInt
üüB P
(
üüP Q
index
üüQ V
)
üüV W
;
üüW X
public
°° 
virtual
°° 
uint
°° 
GetUnsignedIntLE
°° ,
(
°°, -
int
°°- 0
index
°°1 6
)
°°6 7
=>
°°8 :
this
°°; ?
.
°°? @
Buf
°°@ C
.
°°C D
GetUnsignedIntLE
°°D T
(
°°T U
index
°°U Z
)
°°Z [
;
°°[ \
public
££ 
virtual
££ 
long
££ 
GetLong
££ #
(
££# $
int
££$ '
index
££( -
)
££- .
=>
££/ 1
this
££2 6
.
££6 7
Buf
££7 :
.
££: ;
GetLong
££; B
(
££B C
index
££C H
)
££H I
;
££I J
public
•• 
virtual
•• 
long
•• 
	GetLongLE
•• %
(
••% &
int
••& )
index
••* /
)
••/ 0
=>
••1 3
this
••4 8
.
••8 9
Buf
••9 <
.
••< =
	GetLongLE
••= F
(
••F G
index
••G L
)
••L M
;
••M N
public
ßß 
virtual
ßß 
char
ßß 
GetChar
ßß #
(
ßß# $
int
ßß$ '
index
ßß( -
)
ßß- .
=>
ßß/ 1
this
ßß2 6
.
ßß6 7
Buf
ßß7 :
.
ßß: ;
GetChar
ßß; B
(
ßßB C
index
ßßC H
)
ßßH I
;
ßßI J
public
©© 
virtual
©© 
float
©© 
GetFloat
©© %
(
©©% &
int
©©& )
index
©©* /
)
©©/ 0
=>
©©1 3
this
©©4 8
.
©©8 9
Buf
©©9 <
.
©©< =
GetFloat
©©= E
(
©©E F
index
©©F K
)
©©K L
;
©©L M
public
´´ 
float
´´ 

GetFloatLE
´´ 
(
´´  
int
´´  #
index
´´$ )
)
´´) *
=>
´´+ -
this
´´. 2
.
´´2 3
Buf
´´3 6
.
´´6 7

GetFloatLE
´´7 A
(
´´A B
index
´´B G
)
´´G H
;
´´H I
public
≠≠ 
virtual
≠≠ 
double
≠≠ 
	GetDouble
≠≠ '
(
≠≠' (
int
≠≠( +
index
≠≠, 1
)
≠≠1 2
=>
≠≠3 5
this
≠≠6 :
.
≠≠: ;
Buf
≠≠; >
.
≠≠> ?
	GetDouble
≠≠? H
(
≠≠H I
index
≠≠I N
)
≠≠N O
;
≠≠O P
public
ØØ 
double
ØØ 
GetDoubleLE
ØØ !
(
ØØ! "
int
ØØ" %
index
ØØ& +
)
ØØ+ ,
=>
ØØ- /
this
ØØ0 4
.
ØØ4 5
Buf
ØØ5 8
.
ØØ8 9
GetDoubleLE
ØØ9 D
(
ØØD E
index
ØØE J
)
ØØJ K
;
ØØK L
public
±± 
virtual
±± 
IByteBuffer
±± "
GetBytes
±±# +
(
±±+ ,
int
±±, /
index
±±0 5
,
±±5 6
IByteBuffer
±±7 B
dst
±±C F
)
±±F G
{
≤≤ 	
this
≥≥ 
.
≥≥ 
Buf
≥≥ 
.
≥≥ 
GetBytes
≥≥ 
(
≥≥ 
index
≥≥ #
,
≥≥# $
dst
≥≥% (
)
≥≥( )
;
≥≥) *
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
virtual
∑∑ 
IByteBuffer
∑∑ "
GetBytes
∑∑# +
(
∑∑+ ,
int
∑∑, /
index
∑∑0 5
,
∑∑5 6
IByteBuffer
∑∑7 B
dst
∑∑C F
,
∑∑F G
int
∑∑H K
length
∑∑L R
)
∑∑R S
{
∏∏ 	
this
ππ 
.
ππ 
Buf
ππ 
.
ππ 
GetBytes
ππ 
(
ππ 
index
ππ #
,
ππ# $
dst
ππ% (
,
ππ( )
length
ππ* 0
)
ππ0 1
;
ππ1 2
return
∫∫ 
this
∫∫ 
;
∫∫ 
}
ªª 	
public
ΩΩ 
virtual
ΩΩ 
IByteBuffer
ΩΩ "
GetBytes
ΩΩ# +
(
ΩΩ+ ,
int
ΩΩ, /
index
ΩΩ0 5
,
ΩΩ5 6
IByteBuffer
ΩΩ7 B
dst
ΩΩC F
,
ΩΩF G
int
ΩΩH K
dstIndex
ΩΩL T
,
ΩΩT U
int
ΩΩV Y
length
ΩΩZ `
)
ΩΩ` a
{
ææ 	
this
øø 
.
øø 
Buf
øø 
.
øø 
GetBytes
øø 
(
øø 
index
øø #
,
øø# $
dst
øø% (
,
øø( )
dstIndex
øø* 2
,
øø2 3
length
øø4 :
)
øø: ;
;
øø; <
return
¿¿ 
this
¿¿ 
;
¿¿ 
}
¡¡ 	
public
√√ 
virtual
√√ 
IByteBuffer
√√ "
GetBytes
√√# +
(
√√+ ,
int
√√, /
index
√√0 5
,
√√5 6
byte
√√7 ;
[
√√; <
]
√√< =
dst
√√> A
)
√√A B
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
Buf
≈≈ 
.
≈≈ 
GetBytes
≈≈ 
(
≈≈ 
index
≈≈ #
,
≈≈# $
dst
≈≈% (
)
≈≈( )
;
≈≈) *
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
virtual
…… 
IByteBuffer
…… "
GetBytes
……# +
(
……+ ,
int
……, /
index
……0 5
,
……5 6
byte
……7 ;
[
……; <
]
……< =
dst
……> A
,
……A B
int
……C F
dstIndex
……G O
,
……O P
int
……Q T
length
……U [
)
……[ \
{
   	
this
ÀÀ 
.
ÀÀ 
Buf
ÀÀ 
.
ÀÀ 
GetBytes
ÀÀ 
(
ÀÀ 
index
ÀÀ #
,
ÀÀ# $
dst
ÀÀ% (
,
ÀÀ( )
dstIndex
ÀÀ* 2
,
ÀÀ2 3
length
ÀÀ4 :
)
ÀÀ: ;
;
ÀÀ; <
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
œœ 
virtual
œœ 
IByteBuffer
œœ "
GetBytes
œœ# +
(
œœ+ ,
int
œœ, /
index
œœ0 5
,
œœ5 6
Stream
œœ7 =
output
œœ> D
,
œœD E
int
œœF I
length
œœJ P
)
œœP Q
{
–– 	
this
—— 
.
—— 
Buf
—— 
.
—— 
GetBytes
—— 
(
—— 
index
—— #
,
——# $
output
——% +
,
——+ ,
length
——- 3
)
——3 4
;
——4 5
return
““ 
this
““ 
;
““ 
}
”” 	
public
’’ 
ICharSequence
’’ 
GetCharSequence
’’ ,
(
’’, -
int
’’- 0
index
’’1 6
,
’’6 7
int
’’8 ;
length
’’< B
,
’’B C
Encoding
’’D L
encoding
’’M U
)
’’U V
=>
’’W Y
this
’’Z ^
.
’’^ _
Buf
’’_ b
.
’’b c
GetCharSequence
’’c r
(
’’r s
index
’’s x
,
’’x y
length’’z Ä
,’’Ä Å
encoding’’Ç ä
)’’ä ã
;’’ã å
public
◊◊ 
string
◊◊ 
	GetString
◊◊ 
(
◊◊  
int
◊◊  #
index
◊◊$ )
,
◊◊) *
int
◊◊+ .
length
◊◊/ 5
,
◊◊5 6
Encoding
◊◊7 ?
encoding
◊◊@ H
)
◊◊H I
=>
◊◊J L
this
◊◊M Q
.
◊◊Q R
Buf
◊◊R U
.
◊◊U V
	GetString
◊◊V _
(
◊◊_ `
index
◊◊` e
,
◊◊e f
length
◊◊g m
,
◊◊m n
encoding
◊◊o w
)
◊◊w x
;
◊◊x y
public
ŸŸ 
virtual
ŸŸ 
IByteBuffer
ŸŸ "

SetBoolean
ŸŸ# -
(
ŸŸ- .
int
ŸŸ. 1
index
ŸŸ2 7
,
ŸŸ7 8
bool
ŸŸ9 =
value
ŸŸ> C
)
ŸŸC D
{
⁄⁄ 	
this
€€ 
.
€€ 
Buf
€€ 
.
€€ 

SetBoolean
€€ 
(
€€  
index
€€  %
,
€€% &
value
€€' ,
)
€€, -
;
€€- .
return
‹‹ 
this
‹‹ 
;
‹‹ 
}
›› 	
public
ﬂﬂ 
virtual
ﬂﬂ 
IByteBuffer
ﬂﬂ "
SetByte
ﬂﬂ# *
(
ﬂﬂ* +
int
ﬂﬂ+ .
index
ﬂﬂ/ 4
,
ﬂﬂ4 5
int
ﬂﬂ6 9
value
ﬂﬂ: ?
)
ﬂﬂ? @
{
‡‡ 	
this
·· 
.
·· 
Buf
·· 
.
·· 
SetByte
·· 
(
·· 
index
·· "
,
··" #
value
··$ )
)
··) *
;
··* +
return
‚‚ 
this
‚‚ 
;
‚‚ 
}
„„ 	
public
ÂÂ 
virtual
ÂÂ 
IByteBuffer
ÂÂ "
SetShort
ÂÂ# +
(
ÂÂ+ ,
int
ÂÂ, /
index
ÂÂ0 5
,
ÂÂ5 6
int
ÂÂ7 :
value
ÂÂ; @
)
ÂÂ@ A
{
ÊÊ 	
this
ÁÁ 
.
ÁÁ 
Buf
ÁÁ 
.
ÁÁ 
SetShort
ÁÁ 
(
ÁÁ 
index
ÁÁ #
,
ÁÁ# $
value
ÁÁ% *
)
ÁÁ* +
;
ÁÁ+ ,
return
ËË 
this
ËË 
;
ËË 
}
ÈÈ 	
public
ÎÎ 
virtual
ÎÎ 
IByteBuffer
ÎÎ "

SetShortLE
ÎÎ# -
(
ÎÎ- .
int
ÎÎ. 1
index
ÎÎ2 7
,
ÎÎ7 8
int
ÎÎ9 <
value
ÎÎ= B
)
ÎÎB C
{
ÏÏ 	
this
ÌÌ 
.
ÌÌ 
Buf
ÌÌ 
.
ÌÌ 

SetShortLE
ÌÌ 
(
ÌÌ  
index
ÌÌ  %
,
ÌÌ% &
value
ÌÌ' ,
)
ÌÌ, -
;
ÌÌ- .
return
ÓÓ 
this
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
public
ÒÒ 
IByteBuffer
ÒÒ 
SetUnsignedShort
ÒÒ +
(
ÒÒ+ ,
int
ÒÒ, /
index
ÒÒ0 5
,
ÒÒ5 6
ushort
ÒÒ7 =
value
ÒÒ> C
)
ÒÒC D
=>
ÒÒE G
this
ÒÒH L
.
ÒÒL M
Buf
ÒÒM P
.
ÒÒP Q
SetUnsignedShort
ÒÒQ a
(
ÒÒa b
index
ÒÒb g
,
ÒÒg h
value
ÒÒi n
)
ÒÒn o
;
ÒÒo p
public
ÛÛ 
IByteBuffer
ÛÛ  
SetUnsignedShortLE
ÛÛ -
(
ÛÛ- .
int
ÛÛ. 1
index
ÛÛ2 7
,
ÛÛ7 8
ushort
ÛÛ9 ?
value
ÛÛ@ E
)
ÛÛE F
=>
ÛÛG I
this
ÛÛJ N
.
ÛÛN O
Buf
ÛÛO R
.
ÛÛR S 
SetUnsignedShortLE
ÛÛS e
(
ÛÛe f
index
ÛÛf k
,
ÛÛk l
value
ÛÛm r
)
ÛÛr s
;
ÛÛs t
public
ıı 
virtual
ıı 
IByteBuffer
ıı "
	SetMedium
ıı# ,
(
ıı, -
int
ıı- 0
index
ıı1 6
,
ıı6 7
int
ıı8 ;
value
ıı< A
)
ııA B
{
ˆˆ 	
this
˜˜ 
.
˜˜ 
Buf
˜˜ 
.
˜˜ 
	SetMedium
˜˜ 
(
˜˜ 
index
˜˜ $
,
˜˜$ %
value
˜˜& +
)
˜˜+ ,
;
˜˜, -
return
¯¯ 
this
¯¯ 
;
¯¯ 
}
˘˘ 	
public
˚˚ 
virtual
˚˚ 
IByteBuffer
˚˚ "
SetMediumLE
˚˚# .
(
˚˚. /
int
˚˚/ 2
index
˚˚3 8
,
˚˚8 9
int
˚˚: =
value
˚˚> C
)
˚˚C D
{
¸¸ 	
this
˝˝ 
.
˝˝ 
Buf
˝˝ 
.
˝˝ 
SetMediumLE
˝˝  
(
˝˝  !
index
˝˝! &
,
˝˝& '
value
˝˝( -
)
˝˝- .
;
˝˝. /
return
˛˛ 
this
˛˛ 
;
˛˛ 
}
ˇˇ 	
public
ÅÅ 
virtual
ÅÅ 
IByteBuffer
ÅÅ "
SetInt
ÅÅ# )
(
ÅÅ) *
int
ÅÅ* -
index
ÅÅ. 3
,
ÅÅ3 4
int
ÅÅ5 8
value
ÅÅ9 >
)
ÅÅ> ?
{
ÇÇ 	
this
ÉÉ 
.
ÉÉ 
Buf
ÉÉ 
.
ÉÉ 
SetInt
ÉÉ 
(
ÉÉ 
index
ÉÉ !
,
ÉÉ! "
value
ÉÉ# (
)
ÉÉ( )
;
ÉÉ) *
return
ÑÑ 
this
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
áá 
virtual
áá 
IByteBuffer
áá "
SetIntLE
áá# +
(
áá+ ,
int
áá, /
index
áá0 5
,
áá5 6
int
áá7 :
value
áá; @
)
áá@ A
{
àà 	
this
ââ 
.
ââ 
Buf
ââ 
.
ââ 
SetIntLE
ââ 
(
ââ 
index
ââ #
,
ââ# $
value
ââ% *
)
ââ* +
;
ââ+ ,
return
ää 
this
ää 
;
ää 
}
ãã 	
public
çç 
IByteBuffer
çç 
SetUnsignedInt
çç )
(
çç) *
int
çç* -
index
çç. 3
,
çç3 4
uint
çç5 9
value
çç: ?
)
çç? @
=>
ççA C
this
ççD H
.
ççH I
Buf
ççI L
.
ççL M
SetUnsignedInt
ççM [
(
çç[ \
index
çç\ a
,
çça b
value
ççc h
)
ççh i
;
ççi j
public
èè 
IByteBuffer
èè 
SetUnsignedIntLE
èè +
(
èè+ ,
int
èè, /
index
èè0 5
,
èè5 6
uint
èè7 ;
value
èè< A
)
èèA B
=>
èèC E
this
èèF J
.
èèJ K
Buf
èèK N
.
èèN O
SetUnsignedIntLE
èèO _
(
èè_ `
index
èè` e
,
èèe f
value
èèg l
)
èèl m
;
èèm n
public
ëë 
virtual
ëë 
IByteBuffer
ëë "
SetLong
ëë# *
(
ëë* +
int
ëë+ .
index
ëë/ 4
,
ëë4 5
long
ëë6 :
value
ëë; @
)
ëë@ A
{
íí 	
this
ìì 
.
ìì 
Buf
ìì 
.
ìì 
SetLong
ìì 
(
ìì 
index
ìì "
,
ìì" #
value
ìì$ )
)
ìì) *
;
ìì* +
return
îî 
this
îî 
;
îî 
}
ïï 	
public
óó 
virtual
óó 
IByteBuffer
óó "
	SetLongLE
óó# ,
(
óó, -
int
óó- 0
index
óó1 6
,
óó6 7
long
óó8 <
value
óó= B
)
óóB C
{
òò 	
this
ôô 
.
ôô 
Buf
ôô 
.
ôô 
	SetLongLE
ôô 
(
ôô 
index
ôô $
,
ôô$ %
value
ôô& +
)
ôô+ ,
;
ôô, -
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
virtual
ùù 
IByteBuffer
ùù "
SetChar
ùù# *
(
ùù* +
int
ùù+ .
index
ùù/ 4
,
ùù4 5
char
ùù6 :
value
ùù; @
)
ùù@ A
{
ûû 	
this
üü 
.
üü 
Buf
üü 
.
üü 
SetChar
üü 
(
üü 
index
üü "
,
üü" #
value
üü$ )
)
üü) *
;
üü* +
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
virtual
££ 
IByteBuffer
££ "
SetFloat
££# +
(
££+ ,
int
££, /
index
££0 5
,
££5 6
float
££7 <
value
££= B
)
££B C
{
§§ 	
this
•• 
.
•• 
Buf
•• 
.
•• 
SetFloat
•• 
(
•• 
index
•• #
,
••# $
value
••% *
)
••* +
;
••+ ,
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
ßß 	
public
©© 
IByteBuffer
©© 

SetFloatLE
©© %
(
©©% &
int
©©& )
index
©©* /
,
©©/ 0
float
©©1 6
value
©©7 <
)
©©< =
{
™™ 	
this
´´ 
.
´´ 
Buf
´´ 
.
´´ 

SetFloatLE
´´ 
(
´´  
index
´´  %
,
´´% &
value
´´' ,
)
´´, -
;
´´- .
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
public
ØØ 
virtual
ØØ 
IByteBuffer
ØØ "
	SetDouble
ØØ# ,
(
ØØ, -
int
ØØ- 0
index
ØØ1 6
,
ØØ6 7
double
ØØ8 >
value
ØØ? D
)
ØØD E
{
∞∞ 	
this
±± 
.
±± 
Buf
±± 
.
±± 
	SetDouble
±± 
(
±± 
index
±± $
,
±±$ %
value
±±& +
)
±±+ ,
;
±±, -
return
≤≤ 
this
≤≤ 
;
≤≤ 
}
≥≥ 	
public
µµ 
IByteBuffer
µµ 
SetDoubleLE
µµ &
(
µµ& '
int
µµ' *
index
µµ+ 0
,
µµ0 1
double
µµ2 8
value
µµ9 >
)
µµ> ?
{
∂∂ 	
this
∑∑ 
.
∑∑ 
Buf
∑∑ 
.
∑∑ 
SetDoubleLE
∑∑  
(
∑∑  !
index
∑∑! &
,
∑∑& '
value
∑∑( -
)
∑∑- .
;
∑∑. /
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
public
ªª 
virtual
ªª 
IByteBuffer
ªª "
SetBytes
ªª# +
(
ªª+ ,
int
ªª, /
index
ªª0 5
,
ªª5 6
IByteBuffer
ªª7 B
src
ªªC F
)
ªªF G
{
ºº 	
this
ΩΩ 
.
ΩΩ 
Buf
ΩΩ 
.
ΩΩ 
SetBytes
ΩΩ 
(
ΩΩ 
index
ΩΩ #
,
ΩΩ# $
src
ΩΩ% (
)
ΩΩ( )
;
ΩΩ) *
return
ææ 
this
ææ 
;
ææ 
}
øø 	
public
¡¡ 
virtual
¡¡ 
IByteBuffer
¡¡ "
SetBytes
¡¡# +
(
¡¡+ ,
int
¡¡, /
index
¡¡0 5
,
¡¡5 6
IByteBuffer
¡¡7 B
src
¡¡C F
,
¡¡F G
int
¡¡H K
length
¡¡L R
)
¡¡R S
{
¬¬ 	
this
√√ 
.
√√ 
Buf
√√ 
.
√√ 
SetBytes
√√ 
(
√√ 
index
√√ #
,
√√# $
src
√√% (
,
√√( )
length
√√* 0
)
√√0 1
;
√√1 2
return
ƒƒ 
this
ƒƒ 
;
ƒƒ 
}
≈≈ 	
public
«« 
virtual
«« 
IByteBuffer
«« "
SetBytes
««# +
(
««+ ,
int
««, /
index
««0 5
,
««5 6
IByteBuffer
««7 B
src
««C F
,
««F G
int
««H K
srcIndex
««L T
,
««T U
int
««V Y
length
««Z `
)
««` a
{
»» 	
this
…… 
.
…… 
Buf
…… 
.
…… 
SetBytes
…… 
(
…… 
index
…… #
,
……# $
src
……% (
,
……( )
srcIndex
……* 2
,
……2 3
length
……4 :
)
……: ;
;
……; <
return
   
this
   
;
   
}
ÀÀ 	
public
ÕÕ 
virtual
ÕÕ 
IByteBuffer
ÕÕ "
SetBytes
ÕÕ# +
(
ÕÕ+ ,
int
ÕÕ, /
index
ÕÕ0 5
,
ÕÕ5 6
byte
ÕÕ7 ;
[
ÕÕ; <
]
ÕÕ< =
src
ÕÕ> A
)
ÕÕA B
{
ŒŒ 	
this
œœ 
.
œœ 
Buf
œœ 
.
œœ 
SetBytes
œœ 
(
œœ 
index
œœ #
,
œœ# $
src
œœ% (
)
œœ( )
;
œœ) *
return
–– 
this
–– 
;
–– 
}
—— 	
public
”” 
virtual
”” 
IByteBuffer
”” "
SetBytes
””# +
(
””+ ,
int
””, /
index
””0 5
,
””5 6
byte
””7 ;
[
””; <
]
””< =
src
””> A
,
””A B
int
””C F
srcIndex
””G O
,
””O P
int
””Q T
length
””U [
)
””[ \
{
‘‘ 	
this
’’ 
.
’’ 
Buf
’’ 
.
’’ 
SetBytes
’’ 
(
’’ 
index
’’ #
,
’’# $
src
’’% (
,
’’( )
srcIndex
’’* 2
,
’’2 3
length
’’4 :
)
’’: ;
;
’’; <
return
÷÷ 
this
÷÷ 
;
÷÷ 
}
◊◊ 	
public
ŸŸ 
virtual
ŸŸ 
Task
ŸŸ 
<
ŸŸ 
int
ŸŸ 
>
ŸŸ  
SetBytesAsync
ŸŸ! .
(
ŸŸ. /
int
ŸŸ/ 2
index
ŸŸ3 8
,
ŸŸ8 9
Stream
ŸŸ: @
src
ŸŸA D
,
ŸŸD E
int
ŸŸF I
length
ŸŸJ P
,
ŸŸP Q
CancellationToken
ŸŸR c
cancellationToken
ŸŸd u
)
ŸŸu v
=>
ŸŸw y
this
ŸŸz ~
.
ŸŸ~ 
BufŸŸ Ç
.ŸŸÇ É
SetBytesAsyncŸŸÉ ê
(ŸŸê ë
indexŸŸë ñ
,ŸŸñ ó
srcŸŸò õ
,ŸŸõ ú
lengthŸŸù £
,ŸŸ£ §!
cancellationTokenŸŸ• ∂
)ŸŸ∂ ∑
;ŸŸ∑ ∏
public
€€ 
int
€€ 
	SetString
€€ 
(
€€ 
int
€€  
index
€€! &
,
€€& '
string
€€( .
value
€€/ 4
,
€€4 5
Encoding
€€6 >
encoding
€€? G
)
€€G H
=>
€€I K
this
€€L P
.
€€P Q
Buf
€€Q T
.
€€T U
	SetString
€€U ^
(
€€^ _
index
€€_ d
,
€€d e
value
€€f k
,
€€k l
encoding
€€m u
)
€€u v
;
€€v w
public
›› 
virtual
›› 
IByteBuffer
›› "
SetZero
››# *
(
››* +
int
››+ .
index
››/ 4
,
››4 5
int
››6 9
length
››: @
)
››@ A
{
ﬁﬁ 	
this
ﬂﬂ 
.
ﬂﬂ 
Buf
ﬂﬂ 
.
ﬂﬂ 
SetZero
ﬂﬂ 
(
ﬂﬂ 
index
ﬂﬂ "
,
ﬂﬂ" #
length
ﬂﬂ$ *
)
ﬂﬂ* +
;
ﬂﬂ+ ,
return
‡‡ 
this
‡‡ 
;
‡‡ 
}
·· 	
public
„„ 
int
„„ 
SetCharSequence
„„ "
(
„„" #
int
„„# &
index
„„' ,
,
„„, -
ICharSequence
„„. ;
sequence
„„< D
,
„„D E
Encoding
„„F N
encoding
„„O W
)
„„W X
=>
„„Y [
this
„„\ `
.
„„` a
Buf
„„a d
.
„„d e
SetCharSequence
„„e t
(
„„t u
index
„„u z
,
„„z {
sequence„„| Ñ
,„„Ñ Ö
encoding„„Ü é
)„„é è
;„„è ê
public
ÂÂ 
virtual
ÂÂ 
bool
ÂÂ 
ReadBoolean
ÂÂ '
(
ÂÂ' (
)
ÂÂ( )
=>
ÂÂ* ,
this
ÂÂ- 1
.
ÂÂ1 2
Buf
ÂÂ2 5
.
ÂÂ5 6
ReadBoolean
ÂÂ6 A
(
ÂÂA B
)
ÂÂB C
;
ÂÂC D
public
ÁÁ 
virtual
ÁÁ 
byte
ÁÁ 
ReadByte
ÁÁ $
(
ÁÁ$ %
)
ÁÁ% &
=>
ÁÁ' )
this
ÁÁ* .
.
ÁÁ. /
Buf
ÁÁ/ 2
.
ÁÁ2 3
ReadByte
ÁÁ3 ;
(
ÁÁ; <
)
ÁÁ< =
;
ÁÁ= >
public
ÈÈ 
virtual
ÈÈ 
short
ÈÈ 
	ReadShort
ÈÈ &
(
ÈÈ& '
)
ÈÈ' (
=>
ÈÈ) +
this
ÈÈ, 0
.
ÈÈ0 1
Buf
ÈÈ1 4
.
ÈÈ4 5
	ReadShort
ÈÈ5 >
(
ÈÈ> ?
)
ÈÈ? @
;
ÈÈ@ A
public
ÎÎ 
virtual
ÎÎ 
short
ÎÎ 
ReadShortLE
ÎÎ (
(
ÎÎ( )
)
ÎÎ) *
=>
ÎÎ+ -
this
ÎÎ. 2
.
ÎÎ2 3
Buf
ÎÎ3 6
.
ÎÎ6 7
ReadShortLE
ÎÎ7 B
(
ÎÎB C
)
ÎÎC D
;
ÎÎD E
public
ÌÌ 
virtual
ÌÌ 
ushort
ÌÌ 
ReadUnsignedShort
ÌÌ /
(
ÌÌ/ 0
)
ÌÌ0 1
=>
ÌÌ2 4
this
ÌÌ5 9
.
ÌÌ9 :
Buf
ÌÌ: =
.
ÌÌ= >
ReadUnsignedShort
ÌÌ> O
(
ÌÌO P
)
ÌÌP Q
;
ÌÌQ R
public
ÔÔ 
virtual
ÔÔ 
ushort
ÔÔ !
ReadUnsignedShortLE
ÔÔ 1
(
ÔÔ1 2
)
ÔÔ2 3
=>
ÔÔ4 6
this
ÔÔ7 ;
.
ÔÔ; <
Buf
ÔÔ< ?
.
ÔÔ? @!
ReadUnsignedShortLE
ÔÔ@ S
(
ÔÔS T
)
ÔÔT U
;
ÔÔU V
public
ÒÒ 
virtual
ÒÒ 
int
ÒÒ 

ReadMedium
ÒÒ %
(
ÒÒ% &
)
ÒÒ& '
=>
ÒÒ( *
this
ÒÒ+ /
.
ÒÒ/ 0
Buf
ÒÒ0 3
.
ÒÒ3 4

ReadMedium
ÒÒ4 >
(
ÒÒ> ?
)
ÒÒ? @
;
ÒÒ@ A
public
ÛÛ 
virtual
ÛÛ 
int
ÛÛ 
ReadMediumLE
ÛÛ '
(
ÛÛ' (
)
ÛÛ( )
=>
ÛÛ* ,
this
ÛÛ- 1
.
ÛÛ1 2
Buf
ÛÛ2 5
.
ÛÛ5 6
ReadMediumLE
ÛÛ6 B
(
ÛÛB C
)
ÛÛC D
;
ÛÛD E
public
ıı 
virtual
ıı 
int
ıı  
ReadUnsignedMedium
ıı -
(
ıı- .
)
ıı. /
=>
ıı0 2
this
ıı3 7
.
ıı7 8
Buf
ıı8 ;
.
ıı; < 
ReadUnsignedMedium
ıı< N
(
ııN O
)
ııO P
;
ııP Q
public
˜˜ 
virtual
˜˜ 
int
˜˜ "
ReadUnsignedMediumLE
˜˜ /
(
˜˜/ 0
)
˜˜0 1
=>
˜˜2 4
this
˜˜5 9
.
˜˜9 :
Buf
˜˜: =
.
˜˜= >"
ReadUnsignedMediumLE
˜˜> R
(
˜˜R S
)
˜˜S T
;
˜˜T U
public
˘˘ 
virtual
˘˘ 
int
˘˘ 
ReadInt
˘˘ "
(
˘˘" #
)
˘˘# $
=>
˘˘% '
this
˘˘( ,
.
˘˘, -
Buf
˘˘- 0
.
˘˘0 1
ReadInt
˘˘1 8
(
˘˘8 9
)
˘˘9 :
;
˘˘: ;
public
˚˚ 
virtual
˚˚ 
int
˚˚ 
	ReadIntLE
˚˚ $
(
˚˚$ %
)
˚˚% &
=>
˚˚' )
this
˚˚* .
.
˚˚. /
Buf
˚˚/ 2
.
˚˚2 3
	ReadIntLE
˚˚3 <
(
˚˚< =
)
˚˚= >
;
˚˚> ?
public
˝˝ 
virtual
˝˝ 
uint
˝˝ 
ReadUnsignedInt
˝˝ +
(
˝˝+ ,
)
˝˝, -
=>
˝˝. 0
this
˝˝1 5
.
˝˝5 6
Buf
˝˝6 9
.
˝˝9 :
ReadUnsignedInt
˝˝: I
(
˝˝I J
)
˝˝J K
;
˝˝K L
public
ˇˇ 
virtual
ˇˇ 
uint
ˇˇ 
ReadUnsignedIntLE
ˇˇ -
(
ˇˇ- .
)
ˇˇ. /
=>
ˇˇ0 2
this
ˇˇ3 7
.
ˇˇ7 8
Buf
ˇˇ8 ;
.
ˇˇ; <
ReadUnsignedIntLE
ˇˇ< M
(
ˇˇM N
)
ˇˇN O
;
ˇˇO P
public
ÅÅ 
virtual
ÅÅ 
long
ÅÅ 
ReadLong
ÅÅ $
(
ÅÅ$ %
)
ÅÅ% &
=>
ÅÅ' )
this
ÅÅ* .
.
ÅÅ. /
Buf
ÅÅ/ 2
.
ÅÅ2 3
ReadLong
ÅÅ3 ;
(
ÅÅ; <
)
ÅÅ< =
;
ÅÅ= >
public
ÉÉ 
virtual
ÉÉ 
long
ÉÉ 

ReadLongLE
ÉÉ &
(
ÉÉ& '
)
ÉÉ' (
=>
ÉÉ) +
this
ÉÉ, 0
.
ÉÉ0 1
Buf
ÉÉ1 4
.
ÉÉ4 5

ReadLongLE
ÉÉ5 ?
(
ÉÉ? @
)
ÉÉ@ A
;
ÉÉA B
public
ÖÖ 
virtual
ÖÖ 
char
ÖÖ 
ReadChar
ÖÖ $
(
ÖÖ$ %
)
ÖÖ% &
=>
ÖÖ' )
this
ÖÖ* .
.
ÖÖ. /
Buf
ÖÖ/ 2
.
ÖÖ2 3
ReadChar
ÖÖ3 ;
(
ÖÖ; <
)
ÖÖ< =
;
ÖÖ= >
public
áá 
virtual
áá 
float
áá 
	ReadFloat
áá &
(
áá& '
)
áá' (
=>
áá) +
this
áá, 0
.
áá0 1
Buf
áá1 4
.
áá4 5
	ReadFloat
áá5 >
(
áá> ?
)
áá? @
;
áá@ A
public
ââ 
float
ââ 
ReadFloatLE
ââ  
(
ââ  !
)
ââ! "
=>
ââ# %
this
ââ& *
.
ââ* +
Buf
ââ+ .
.
ââ. /
ReadFloatLE
ââ/ :
(
ââ: ;
)
ââ; <
;
ââ< =
public
ãã 
virtual
ãã 
double
ãã 

ReadDouble
ãã (
(
ãã( )
)
ãã) *
=>
ãã+ -
this
ãã. 2
.
ãã2 3
Buf
ãã3 6
.
ãã6 7

ReadDouble
ãã7 A
(
ããA B
)
ããB C
;
ããC D
public
çç 
double
çç 
ReadDoubleLE
çç "
(
çç" #
)
çç# $
=>
çç% '
this
çç( ,
.
çç, -
Buf
çç- 0
.
çç0 1
ReadDoubleLE
çç1 =
(
çç= >
)
çç> ?
;
çç? @
public
èè 
virtual
èè 
IByteBuffer
èè "
	ReadBytes
èè# ,
(
èè, -
int
èè- 0
length
èè1 7
)
èè7 8
=>
èè9 ;
this
èè< @
.
èè@ A
Buf
èèA D
.
èèD E
	ReadBytes
èèE N
(
èèN O
length
èèO U
)
èèU V
;
èèV W
public
ëë 
virtual
ëë 
IByteBuffer
ëë "
	ReadSlice
ëë# ,
(
ëë, -
int
ëë- 0
length
ëë1 7
)
ëë7 8
=>
ëë9 ;
this
ëë< @
.
ëë@ A
Buf
ëëA D
.
ëëD E
	ReadSlice
ëëE N
(
ëëN O
length
ëëO U
)
ëëU V
;
ëëV W
public
ìì 
virtual
ìì 
IByteBuffer
ìì "
ReadRetainedSlice
ìì# 4
(
ìì4 5
int
ìì5 8
length
ìì9 ?
)
ìì? @
=>
ììA C
this
ììD H
.
ììH I
Buf
ììI L
.
ììL M
ReadRetainedSlice
ììM ^
(
ìì^ _
length
ìì_ e
)
ììe f
;
ììf g
public
ïï 
Task
ïï 
WriteBytesAsync
ïï #
(
ïï# $
Stream
ïï$ *
stream
ïï+ 1
,
ïï1 2
int
ïï3 6
length
ïï7 =
)
ïï= >
=>
ïï? A
this
ïïB F
.
ïïF G
Buf
ïïG J
.
ïïJ K
WriteBytesAsync
ïïK Z
(
ïïZ [
stream
ïï[ a
,
ïïa b
length
ïïc i
)
ïïi j
;
ïïj k
public
óó 
virtual
óó 
IByteBuffer
óó "
	ReadBytes
óó# ,
(
óó, -
IByteBuffer
óó- 8
dst
óó9 <
)
óó< =
{
òò 	
this
ôô 
.
ôô 
Buf
ôô 
.
ôô 
	ReadBytes
ôô 
(
ôô 
dst
ôô "
)
ôô" #
;
ôô# $
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
virtual
ùù 
IByteBuffer
ùù "
	ReadBytes
ùù# ,
(
ùù, -
IByteBuffer
ùù- 8
dst
ùù9 <
,
ùù< =
int
ùù> A
length
ùùB H
)
ùùH I
{
ûû 	
this
üü 
.
üü 
Buf
üü 
.
üü 
	ReadBytes
üü 
(
üü 
dst
üü "
,
üü" #
length
üü$ *
)
üü* +
;
üü+ ,
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
virtual
££ 
IByteBuffer
££ "
	ReadBytes
££# ,
(
££, -
IByteBuffer
££- 8
dst
££9 <
,
££< =
int
££> A
dstIndex
££B J
,
££J K
int
££L O
length
££P V
)
££V W
{
§§ 	
this
•• 
.
•• 
Buf
•• 
.
•• 
	ReadBytes
•• 
(
•• 
dst
•• "
,
••" #
dstIndex
••$ ,
,
••, -
length
••. 4
)
••4 5
;
••5 6
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
ßß 	
public
©© 
virtual
©© 
IByteBuffer
©© "
	ReadBytes
©©# ,
(
©©, -
byte
©©- 1
[
©©1 2
]
©©2 3
dst
©©4 7
)
©©7 8
{
™™ 	
this
´´ 
.
´´ 
Buf
´´ 
.
´´ 
	ReadBytes
´´ 
(
´´ 
dst
´´ "
)
´´" #
;
´´# $
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
public
ØØ 
virtual
ØØ 
IByteBuffer
ØØ "
	ReadBytes
ØØ# ,
(
ØØ, -
byte
ØØ- 1
[
ØØ1 2
]
ØØ2 3
dst
ØØ4 7
,
ØØ7 8
int
ØØ9 <
dstIndex
ØØ= E
,
ØØE F
int
ØØG J
length
ØØK Q
)
ØØQ R
{
∞∞ 	
this
±± 
.
±± 
Buf
±± 
.
±± 
	ReadBytes
±± 
(
±± 
dst
±± "
,
±±" #
dstIndex
±±$ ,
,
±±, -
length
±±. 4
)
±±4 5
;
±±5 6
return
≤≤ 
this
≤≤ 
;
≤≤ 
}
≥≥ 	
public
µµ 
virtual
µµ 
IByteBuffer
µµ "
	ReadBytes
µµ# ,
(
µµ, -
Stream
µµ- 3
output
µµ4 :
,
µµ: ;
int
µµ< ?
length
µµ@ F
)
µµF G
{
∂∂ 	
this
∑∑ 
.
∑∑ 
Buf
∑∑ 
.
∑∑ 
	ReadBytes
∑∑ 
(
∑∑ 
output
∑∑ %
,
∑∑% &
length
∑∑' -
)
∑∑- .
;
∑∑. /
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
public
ªª 
ICharSequence
ªª 
ReadCharSequence
ªª -
(
ªª- .
int
ªª. 1
length
ªª2 8
,
ªª8 9
Encoding
ªª: B
encoding
ªªC K
)
ªªK L
=>
ªªM O
this
ªªP T
.
ªªT U
Buf
ªªU X
.
ªªX Y
ReadCharSequence
ªªY i
(
ªªi j
length
ªªj p
,
ªªp q
encoding
ªªr z
)
ªªz {
;
ªª{ |
public
ΩΩ 
string
ΩΩ 

ReadString
ΩΩ  
(
ΩΩ  !
int
ΩΩ! $
length
ΩΩ% +
,
ΩΩ+ ,
Encoding
ΩΩ- 5
encoding
ΩΩ6 >
)
ΩΩ> ?
=>
ΩΩ@ B
this
ΩΩC G
.
ΩΩG H
Buf
ΩΩH K
.
ΩΩK L

ReadString
ΩΩL V
(
ΩΩV W
length
ΩΩW ]
,
ΩΩ] ^
encoding
ΩΩ_ g
)
ΩΩg h
;
ΩΩh i
public
øø 
virtual
øø 
IByteBuffer
øø "
	SkipBytes
øø# ,
(
øø, -
int
øø- 0
length
øø1 7
)
øø7 8
{
¿¿ 	
this
¡¡ 
.
¡¡ 
Buf
¡¡ 
.
¡¡ 
	SkipBytes
¡¡ 
(
¡¡ 
length
¡¡ %
)
¡¡% &
;
¡¡& '
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
√√ 	
public
≈≈ 
virtual
≈≈ 
IByteBuffer
≈≈ "
WriteBoolean
≈≈# /
(
≈≈/ 0
bool
≈≈0 4
value
≈≈5 :
)
≈≈: ;
{
∆∆ 	
this
«« 
.
«« 
Buf
«« 
.
«« 
WriteBoolean
«« !
(
««! "
value
««" '
)
««' (
;
««( )
return
»» 
this
»» 
;
»» 
}
…… 	
public
ÀÀ 
virtual
ÀÀ 
IByteBuffer
ÀÀ "
	WriteByte
ÀÀ# ,
(
ÀÀ, -
int
ÀÀ- 0
value
ÀÀ1 6
)
ÀÀ6 7
{
ÃÃ 	
this
ÕÕ 
.
ÕÕ 
Buf
ÕÕ 
.
ÕÕ 
	WriteByte
ÕÕ 
(
ÕÕ 
value
ÕÕ $
)
ÕÕ$ %
;
ÕÕ% &
return
ŒŒ 
this
ŒŒ 
;
ŒŒ 
}
œœ 	
public
—— 
virtual
—— 
IByteBuffer
—— "

WriteShort
——# -
(
——- .
int
——. 1
value
——2 7
)
——7 8
{
““ 	
this
”” 
.
”” 
Buf
”” 
.
”” 

WriteShort
”” 
(
””  
value
””  %
)
””% &
;
””& '
return
‘‘ 
this
‘‘ 
;
‘‘ 
}
’’ 	
public
◊◊ 
virtual
◊◊ 
IByteBuffer
◊◊ "
WriteShortLE
◊◊# /
(
◊◊/ 0
int
◊◊0 3
value
◊◊4 9
)
◊◊9 :
{
ÿÿ 	
this
ŸŸ 
.
ŸŸ 
Buf
ŸŸ 
.
ŸŸ 
WriteShortLE
ŸŸ !
(
ŸŸ! "
value
ŸŸ" '
)
ŸŸ' (
;
ŸŸ( )
return
⁄⁄ 
this
⁄⁄ 
;
⁄⁄ 
}
€€ 	
public
›› 
IByteBuffer
››  
WriteUnsignedShort
›› -
(
››- .
ushort
››. 4
value
››5 :
)
››: ;
=>
››< >
this
››? C
.
››C D
Buf
››D G
.
››G H 
WriteUnsignedShort
››H Z
(
››Z [
value
››[ `
)
››` a
;
››a b
public
ﬂﬂ 
IByteBuffer
ﬂﬂ "
WriteUnsignedShortLE
ﬂﬂ /
(
ﬂﬂ/ 0
ushort
ﬂﬂ0 6
value
ﬂﬂ7 <
)
ﬂﬂ< =
=>
ﬂﬂ> @
this
ﬂﬂA E
.
ﬂﬂE F
Buf
ﬂﬂF I
.
ﬂﬂI J"
WriteUnsignedShortLE
ﬂﬂJ ^
(
ﬂﬂ^ _
value
ﬂﬂ_ d
)
ﬂﬂd e
;
ﬂﬂe f
public
·· 
virtual
·· 
IByteBuffer
·· "
WriteMedium
··# .
(
··. /
int
··/ 2
value
··3 8
)
··8 9
{
‚‚ 	
this
„„ 
.
„„ 
Buf
„„ 
.
„„ 
WriteMedium
„„  
(
„„  !
value
„„! &
)
„„& '
;
„„' (
return
‰‰ 
this
‰‰ 
;
‰‰ 
}
ÂÂ 	
public
ÁÁ 
virtual
ÁÁ 
IByteBuffer
ÁÁ "
WriteMediumLE
ÁÁ# 0
(
ÁÁ0 1
int
ÁÁ1 4
value
ÁÁ5 :
)
ÁÁ: ;
{
ËË 	
this
ÈÈ 
.
ÈÈ 
Buf
ÈÈ 
.
ÈÈ 
WriteMediumLE
ÈÈ "
(
ÈÈ" #
value
ÈÈ# (
)
ÈÈ( )
;
ÈÈ) *
return
ÍÍ 
this
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ÌÌ 
virtual
ÌÌ 
IByteBuffer
ÌÌ "
WriteInt
ÌÌ# +
(
ÌÌ+ ,
int
ÌÌ, /
value
ÌÌ0 5
)
ÌÌ5 6
{
ÓÓ 	
this
ÔÔ 
.
ÔÔ 
Buf
ÔÔ 
.
ÔÔ 
WriteInt
ÔÔ 
(
ÔÔ 
value
ÔÔ #
)
ÔÔ# $
;
ÔÔ$ %
return
 
this
 
;
 
}
ÒÒ 	
public
ÛÛ 
virtual
ÛÛ 
IByteBuffer
ÛÛ "

WriteIntLE
ÛÛ# -
(
ÛÛ- .
int
ÛÛ. 1
value
ÛÛ2 7
)
ÛÛ7 8
{
ÙÙ 	
this
ıı 
.
ıı 
Buf
ıı 
.
ıı 

WriteIntLE
ıı 
(
ıı  
value
ıı  %
)
ıı% &
;
ıı& '
return
ˆˆ 
this
ˆˆ 
;
ˆˆ 
}
˜˜ 	
public
˘˘ 
virtual
˘˘ 
IByteBuffer
˘˘ "
	WriteLong
˘˘# ,
(
˘˘, -
long
˘˘- 1
value
˘˘2 7
)
˘˘7 8
{
˙˙ 	
this
˚˚ 
.
˚˚ 
Buf
˚˚ 
.
˚˚ 
	WriteLong
˚˚ 
(
˚˚ 
value
˚˚ $
)
˚˚$ %
;
˚˚% &
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
virtual
ˇˇ 
IByteBuffer
ˇˇ "
WriteLongLE
ˇˇ# .
(
ˇˇ. /
long
ˇˇ/ 3
value
ˇˇ4 9
)
ˇˇ9 :
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
Buf
ÅÅ 
.
ÅÅ 
WriteLongLE
ÅÅ  
(
ÅÅ  !
value
ÅÅ! &
)
ÅÅ& '
;
ÅÅ' (
return
ÇÇ 
this
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
virtual
ÖÖ 
IByteBuffer
ÖÖ "
	WriteChar
ÖÖ# ,
(
ÖÖ, -
char
ÖÖ- 1
value
ÖÖ2 7
)
ÖÖ7 8
{
ÜÜ 	
this
áá 
.
áá 
Buf
áá 
.
áá 
	WriteChar
áá 
(
áá 
value
áá $
)
áá$ %
;
áá% &
return
àà 
this
àà 
;
àà 
}
ââ 	
public
ãã 
virtual
ãã 
IByteBuffer
ãã "

WriteFloat
ãã# -
(
ãã- .
float
ãã. 3
value
ãã4 9
)
ãã9 :
{
åå 	
this
çç 
.
çç 
Buf
çç 
.
çç 

WriteFloat
çç 
(
çç  
value
çç  %
)
çç% &
;
çç& '
return
éé 
this
éé 
;
éé 
}
èè 	
public
ëë 
IByteBuffer
ëë 
WriteFloatLE
ëë '
(
ëë' (
float
ëë( -
value
ëë. 3
)
ëë3 4
{
íí 	
this
ìì 
.
ìì 
Buf
ìì 
.
ìì 
WriteFloatLE
ìì !
(
ìì! "
value
ìì" '
)
ìì' (
;
ìì( )
return
îî 
this
îî 
;
îî 
}
ïï 	
public
óó 
virtual
óó 
IByteBuffer
óó "
WriteDouble
óó# .
(
óó. /
double
óó/ 5
value
óó6 ;
)
óó; <
{
òò 	
this
ôô 
.
ôô 
Buf
ôô 
.
ôô 
WriteDouble
ôô  
(
ôô  !
value
ôô! &
)
ôô& '
;
ôô' (
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
IByteBuffer
ùù 
WriteDoubleLE
ùù (
(
ùù( )
double
ùù) /
value
ùù0 5
)
ùù5 6
{
ûû 	
this
üü 
.
üü 
Buf
üü 
.
üü 
WriteDoubleLE
üü "
(
üü" #
value
üü# (
)
üü( )
;
üü) *
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
virtual
££ 
IByteBuffer
££ "

WriteBytes
££# -
(
££- .
IByteBuffer
££. 9
src
££: =
)
££= >
{
§§ 	
this
•• 
.
•• 
Buf
•• 
.
•• 

WriteBytes
•• 
(
••  
src
••  #
)
••# $
;
••$ %
return
¶¶ 
this
¶¶ 
;
¶¶ 
}
ßß 	
public
©© 
virtual
©© 
IByteBuffer
©© "

WriteBytes
©©# -
(
©©- .
IByteBuffer
©©. 9
src
©©: =
,
©©= >
int
©©? B
length
©©C I
)
©©I J
{
™™ 	
this
´´ 
.
´´ 
Buf
´´ 
.
´´ 

WriteBytes
´´ 
(
´´  
src
´´  #
,
´´# $
length
´´% +
)
´´+ ,
;
´´, -
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
public
ØØ 
virtual
ØØ 
IByteBuffer
ØØ "

WriteBytes
ØØ# -
(
ØØ- .
IByteBuffer
ØØ. 9
src
ØØ: =
,
ØØ= >
int
ØØ? B
srcIndex
ØØC K
,
ØØK L
int
ØØM P
length
ØØQ W
)
ØØW X
{
∞∞ 	
this
±± 
.
±± 
Buf
±± 
.
±± 

WriteBytes
±± 
(
±±  
src
±±  #
,
±±# $
srcIndex
±±% -
,
±±- .
length
±±/ 5
)
±±5 6
;
±±6 7
return
≤≤ 
this
≤≤ 
;
≤≤ 
}
≥≥ 	
public
µµ 
virtual
µµ 
IByteBuffer
µµ "

WriteBytes
µµ# -
(
µµ- .
byte
µµ. 2
[
µµ2 3
]
µµ3 4
src
µµ5 8
)
µµ8 9
{
∂∂ 	
this
∑∑ 
.
∑∑ 
Buf
∑∑ 
.
∑∑ 

WriteBytes
∑∑ 
(
∑∑  
src
∑∑  #
)
∑∑# $
;
∑∑$ %
return
∏∏ 
this
∏∏ 
;
∏∏ 
}
ππ 	
public
ªª 
virtual
ªª 
IByteBuffer
ªª "

WriteBytes
ªª# -
(
ªª- .
byte
ªª. 2
[
ªª2 3
]
ªª3 4
src
ªª5 8
,
ªª8 9
int
ªª: =
srcIndex
ªª> F
,
ªªF G
int
ªªH K
length
ªªL R
)
ªªR S
{
ºº 	
this
ΩΩ 
.
ΩΩ 
Buf
ΩΩ 
.
ΩΩ 

WriteBytes
ΩΩ 
(
ΩΩ  
src
ΩΩ  #
,
ΩΩ# $
srcIndex
ΩΩ% -
,
ΩΩ- .
length
ΩΩ/ 5
)
ΩΩ5 6
;
ΩΩ6 7
return
ææ 
this
ææ 
;
ææ 
}
øø 	
public
¡¡ 
virtual
¡¡ 
Task
¡¡ 
WriteBytesAsync
¡¡ +
(
¡¡+ ,
Stream
¡¡, 2
input
¡¡3 8
,
¡¡8 9
int
¡¡: =
length
¡¡> D
,
¡¡D E
CancellationToken
¡¡F W
cancellationToken
¡¡X i
)
¡¡i j
=>
¡¡k m
this
¡¡n r
.
¡¡r s
Buf
¡¡s v
.
¡¡v w
WriteBytesAsync¡¡w Ü
(¡¡Ü á
input¡¡á å
,¡¡å ç
length¡¡é î
,¡¡î ï!
cancellationToken¡¡ñ ß
)¡¡ß ®
;¡¡® ©
public
√√ 
virtual
√√ 
IByteBuffer
√√ "
	WriteZero
√√# ,
(
√√, -
int
√√- 0
length
√√1 7
)
√√7 8
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
Buf
≈≈ 
.
≈≈ 
	WriteZero
≈≈ 
(
≈≈ 
length
≈≈ %
)
≈≈% &
;
≈≈& '
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
int
…… 
WriteCharSequence
…… $
(
……$ %
ICharSequence
……% 2
sequence
……3 ;
,
……; <
Encoding
……= E
encoding
……F N
)
……N O
=>
……P R
this
……S W
.
……W X
Buf
……X [
.
……[ \
WriteCharSequence
……\ m
(
……m n
sequence
……n v
,
……v w
encoding……x Ä
)……Ä Å
;……Å Ç
public
ÀÀ 
int
ÀÀ 
WriteString
ÀÀ 
(
ÀÀ 
string
ÀÀ %
value
ÀÀ& +
,
ÀÀ+ ,
Encoding
ÀÀ- 5
encoding
ÀÀ6 >
)
ÀÀ> ?
=>
ÀÀ@ B
this
ÀÀC G
.
ÀÀG H
Buf
ÀÀH K
.
ÀÀK L
WriteString
ÀÀL W
(
ÀÀW X
value
ÀÀX ]
,
ÀÀ] ^
encoding
ÀÀ_ g
)
ÀÀg h
;
ÀÀh i
public
ÕÕ 
virtual
ÕÕ 
int
ÕÕ 
IndexOf
ÕÕ "
(
ÕÕ" #
int
ÕÕ# &
	fromIndex
ÕÕ' 0
,
ÕÕ0 1
int
ÕÕ2 5
toIndex
ÕÕ6 =
,
ÕÕ= >
byte
ÕÕ? C
value
ÕÕD I
)
ÕÕI J
=>
ÕÕK M
this
ÕÕN R
.
ÕÕR S
Buf
ÕÕS V
.
ÕÕV W
IndexOf
ÕÕW ^
(
ÕÕ^ _
	fromIndex
ÕÕ_ h
,
ÕÕh i
toIndex
ÕÕj q
,
ÕÕq r
value
ÕÕs x
)
ÕÕx y
;
ÕÕy z
public
œœ 
virtual
œœ 
int
œœ 
BytesBefore
œœ &
(
œœ& '
byte
œœ' +
value
œœ, 1
)
œœ1 2
=>
œœ3 5
this
œœ6 :
.
œœ: ;
Buf
œœ; >
.
œœ> ?
BytesBefore
œœ? J
(
œœJ K
value
œœK P
)
œœP Q
;
œœQ R
public
—— 
virtual
—— 
int
—— 
BytesBefore
—— &
(
——& '
int
——' *
length
——+ 1
,
——1 2
byte
——3 7
value
——8 =
)
——= >
=>
——? A
this
——B F
.
——F G
Buf
——G J
.
——J K
BytesBefore
——K V
(
——V W
length
——W ]
,
——] ^
value
——_ d
)
——d e
;
——e f
public
”” 
virtual
”” 
int
”” 
BytesBefore
”” &
(
””& '
int
””' *
index
””+ 0
,
””0 1
int
””2 5
length
””6 <
,
””< =
byte
””> B
value
””C H
)
””H I
=>
””J L
this
””M Q
.
””Q R
Buf
””R U
.
””U V
BytesBefore
””V a
(
””a b
index
””b g
,
””g h
length
””i o
,
””o p
value
””q v
)
””v w
;
””w x
public
’’ 
virtual
’’ 
int
’’ 
ForEachByte
’’ &
(
’’& '
IByteProcessor
’’' 5
	processor
’’6 ?
)
’’? @
=>
’’A C
this
’’D H
.
’’H I
Buf
’’I L
.
’’L M
ForEachByte
’’M X
(
’’X Y
	processor
’’Y b
)
’’b c
;
’’c d
public
◊◊ 
virtual
◊◊ 
int
◊◊ 
ForEachByte
◊◊ &
(
◊◊& '
int
◊◊' *
index
◊◊+ 0
,
◊◊0 1
int
◊◊2 5
length
◊◊6 <
,
◊◊< =
IByteProcessor
◊◊> L
	processor
◊◊M V
)
◊◊V W
=>
◊◊X Z
this
◊◊[ _
.
◊◊_ `
Buf
◊◊` c
.
◊◊c d
ForEachByte
◊◊d o
(
◊◊o p
index
◊◊p u
,
◊◊u v
length
◊◊w }
,
◊◊} ~
	processor◊◊ à
)◊◊à â
;◊◊â ä
public
ŸŸ 
virtual
ŸŸ 
int
ŸŸ 
ForEachByteDesc
ŸŸ *
(
ŸŸ* +
IByteProcessor
ŸŸ+ 9
	processor
ŸŸ: C
)
ŸŸC D
=>
ŸŸE G
this
ŸŸH L
.
ŸŸL M
Buf
ŸŸM P
.
ŸŸP Q
ForEachByteDesc
ŸŸQ `
(
ŸŸ` a
	processor
ŸŸa j
)
ŸŸj k
;
ŸŸk l
public
€€ 
virtual
€€ 
int
€€ 
ForEachByteDesc
€€ *
(
€€* +
int
€€+ .
index
€€/ 4
,
€€4 5
int
€€6 9
length
€€: @
,
€€@ A
IByteProcessor
€€B P
	processor
€€Q Z
)
€€Z [
=>
€€\ ^
this
€€_ c
.
€€c d
Buf
€€d g
.
€€g h
ForEachByteDesc
€€h w
(
€€w x
index
€€x }
,
€€} ~
length€€ Ö
,€€Ö Ü
	processor€€á ê
)€€ê ë
;€€ë í
public
›› 
virtual
›› 
IByteBuffer
›› "
Copy
››# '
(
››' (
)
››( )
=>
››* ,
this
››- 1
.
››1 2
Buf
››2 5
.
››5 6
Copy
››6 :
(
››: ;
)
››; <
;
››< =
public
ﬂﬂ 
virtual
ﬂﬂ 
IByteBuffer
ﬂﬂ "
Copy
ﬂﬂ# '
(
ﬂﬂ' (
int
ﬂﬂ( +
index
ﬂﬂ, 1
,
ﬂﬂ1 2
int
ﬂﬂ3 6
length
ﬂﬂ7 =
)
ﬂﬂ= >
=>
ﬂﬂ? A
this
ﬂﬂB F
.
ﬂﬂF G
Buf
ﬂﬂG J
.
ﬂﬂJ K
Copy
ﬂﬂK O
(
ﬂﬂO P
index
ﬂﬂP U
,
ﬂﬂU V
length
ﬂﬂW ]
)
ﬂﬂ] ^
;
ﬂﬂ^ _
public
·· 
virtual
·· 
IByteBuffer
·· "
Slice
··# (
(
··( )
)
··) *
=>
··+ -
this
··. 2
.
··2 3
Buf
··3 6
.
··6 7
Slice
··7 <
(
··< =
)
··= >
;
··> ?
public
„„ 
virtual
„„ 
IByteBuffer
„„ "
RetainedSlice
„„# 0
(
„„0 1
)
„„1 2
=>
„„3 5
this
„„6 :
.
„„: ;
Buf
„„; >
.
„„> ?
RetainedSlice
„„? L
(
„„L M
)
„„M N
;
„„N O
public
ÂÂ 
virtual
ÂÂ 
IByteBuffer
ÂÂ "
Slice
ÂÂ# (
(
ÂÂ( )
int
ÂÂ) ,
index
ÂÂ- 2
,
ÂÂ2 3
int
ÂÂ4 7
length
ÂÂ8 >
)
ÂÂ> ?
=>
ÂÂ@ B
this
ÂÂC G
.
ÂÂG H
Buf
ÂÂH K
.
ÂÂK L
Slice
ÂÂL Q
(
ÂÂQ R
index
ÂÂR W
,
ÂÂW X
length
ÂÂY _
)
ÂÂ_ `
;
ÂÂ` a
public
ÁÁ 
virtual
ÁÁ 
IByteBuffer
ÁÁ "
RetainedSlice
ÁÁ# 0
(
ÁÁ0 1
int
ÁÁ1 4
index
ÁÁ5 :
,
ÁÁ: ;
int
ÁÁ< ?
length
ÁÁ@ F
)
ÁÁF G
=>
ÁÁH J
this
ÁÁK O
.
ÁÁO P
Buf
ÁÁP S
.
ÁÁS T
RetainedSlice
ÁÁT a
(
ÁÁa b
index
ÁÁb g
,
ÁÁg h
length
ÁÁi o
)
ÁÁo p
;
ÁÁp q
public
ÈÈ 
virtual
ÈÈ 
IByteBuffer
ÈÈ "
	Duplicate
ÈÈ# ,
(
ÈÈ, -
)
ÈÈ- .
=>
ÈÈ/ 1
this
ÈÈ2 6
.
ÈÈ6 7
Buf
ÈÈ7 :
.
ÈÈ: ;
	Duplicate
ÈÈ; D
(
ÈÈD E
)
ÈÈE F
;
ÈÈF G
public
ÎÎ 
virtual
ÎÎ 
IByteBuffer
ÎÎ "
RetainedDuplicate
ÎÎ# 4
(
ÎÎ4 5
)
ÎÎ5 6
=>
ÎÎ7 9
this
ÎÎ: >
.
ÎÎ> ?
Buf
ÎÎ? B
.
ÎÎB C
RetainedDuplicate
ÎÎC T
(
ÎÎT U
)
ÎÎU V
;
ÎÎV W
public
ÌÌ 
virtual
ÌÌ 
int
ÌÌ 
IoBufferCount
ÌÌ (
=>
ÌÌ) +
this
ÌÌ, 0
.
ÌÌ0 1
Buf
ÌÌ1 4
.
ÌÌ4 5
IoBufferCount
ÌÌ5 B
;
ÌÌB C
public
ÔÔ 
virtual
ÔÔ 
ArraySegment
ÔÔ #
<
ÔÔ# $
byte
ÔÔ$ (
>
ÔÔ( )
GetIoBuffer
ÔÔ* 5
(
ÔÔ5 6
)
ÔÔ6 7
=>
ÔÔ8 :
this
ÔÔ; ?
.
ÔÔ? @
Buf
ÔÔ@ C
.
ÔÔC D
GetIoBuffer
ÔÔD O
(
ÔÔO P
)
ÔÔP Q
;
ÔÔQ R
public
ÒÒ 
virtual
ÒÒ 
ArraySegment
ÒÒ #
<
ÒÒ# $
byte
ÒÒ$ (
>
ÒÒ( )
GetIoBuffer
ÒÒ* 5
(
ÒÒ5 6
int
ÒÒ6 9
index
ÒÒ: ?
,
ÒÒ? @
int
ÒÒA D
length
ÒÒE K
)
ÒÒK L
=>
ÒÒM O
this
ÒÒP T
.
ÒÒT U
Buf
ÒÒU X
.
ÒÒX Y
GetIoBuffer
ÒÒY d
(
ÒÒd e
index
ÒÒe j
,
ÒÒj k
length
ÒÒl r
)
ÒÒr s
;
ÒÒs t
public
ÛÛ 
virtual
ÛÛ 
ArraySegment
ÛÛ #
<
ÛÛ# $
byte
ÛÛ$ (
>
ÛÛ( )
[
ÛÛ) *
]
ÛÛ* +
GetIoBuffers
ÛÛ, 8
(
ÛÛ8 9
)
ÛÛ9 :
=>
ÛÛ; =
this
ÛÛ> B
.
ÛÛB C
Buf
ÛÛC F
.
ÛÛF G
GetIoBuffers
ÛÛG S
(
ÛÛS T
)
ÛÛT U
;
ÛÛU V
public
ıı 
virtual
ıı 
ArraySegment
ıı #
<
ıı# $
byte
ıı$ (
>
ıı( )
[
ıı) *
]
ıı* +
GetIoBuffers
ıı, 8
(
ıı8 9
int
ıı9 <
index
ıı= B
,
ııB C
int
ııD G
length
ııH N
)
ııN O
=>
ııP R
this
ııS W
.
ııW X
Buf
ııX [
.
ıı[ \
GetIoBuffers
ıı\ h
(
ııh i
index
ııi n
,
ıın o
length
ııp v
)
ııv w
;
ııw x
public
˜˜ 
bool
˜˜ 
HasArray
˜˜ 
=>
˜˜ 
this
˜˜  $
.
˜˜$ %
Buf
˜˜% (
.
˜˜( )
HasArray
˜˜) 1
;
˜˜1 2
public
˘˘ 
int
˘˘ 
ArrayOffset
˘˘ 
=>
˘˘ !
this
˘˘" &
.
˘˘& '
Buf
˘˘' *
.
˘˘* +
ArrayOffset
˘˘+ 6
;
˘˘6 7
public
˚˚ 
byte
˚˚ 
[
˚˚ 
]
˚˚ 
Array
˚˚ 
=>
˚˚ 
this
˚˚ #
.
˚˚# $
Buf
˚˚$ '
.
˚˚' (
Array
˚˚( -
;
˚˚- .
public
˝˝ 
virtual
˝˝ 
string
˝˝ 
ToString
˝˝ &
(
˝˝& '
Encoding
˝˝' /
encoding
˝˝0 8
)
˝˝8 9
=>
˝˝: <
this
˝˝= A
.
˝˝A B
Buf
˝˝B E
.
˝˝E F
ToString
˝˝F N
(
˝˝N O
encoding
˝˝O W
)
˝˝W X
;
˝˝X Y
public
ˇˇ 
virtual
ˇˇ 
string
ˇˇ 
ToString
ˇˇ &
(
ˇˇ& '
int
ˇˇ' *
index
ˇˇ+ 0
,
ˇˇ0 1
int
ˇˇ2 5
length
ˇˇ6 <
,
ˇˇ< =
Encoding
ˇˇ> F
encoding
ˇˇG O
)
ˇˇO P
=>
ˇˇQ S
this
ˇˇT X
.
ˇˇX Y
Buf
ˇˇY \
.
ˇˇ\ ]
ToString
ˇˇ] e
(
ˇˇe f
index
ˇˇf k
,
ˇˇk l
length
ˇˇm s
,
ˇˇs t
encoding
ˇˇu }
)
ˇˇ} ~
;
ˇˇ~ 
public
ÅÅ 
override
ÅÅ 
int
ÅÅ 
GetHashCode
ÅÅ '
(
ÅÅ' (
)
ÅÅ( )
=>
ÅÅ* ,
this
ÅÅ- 1
.
ÅÅ1 2
Buf
ÅÅ2 5
.
ÅÅ5 6
GetHashCode
ÅÅ6 A
(
ÅÅA B
)
ÅÅB C
;
ÅÅC D
public
ÉÉ 
override
ÉÉ 
bool
ÉÉ 
Equals
ÉÉ #
(
ÉÉ# $
object
ÉÉ$ *
obj
ÉÉ+ .
)
ÉÉ. /
=>
ÉÉ0 2
this
ÉÉ3 7
.
ÉÉ7 8
Buf
ÉÉ8 ;
.
ÉÉ; <
Equals
ÉÉ< B
(
ÉÉB C
obj
ÉÉC F
)
ÉÉF G
;
ÉÉG H
public
ÖÖ 
bool
ÖÖ 
Equals
ÖÖ 
(
ÖÖ 
IByteBuffer
ÖÖ &
buffer
ÖÖ' -
)
ÖÖ- .
=>
ÖÖ/ 1
this
ÖÖ2 6
.
ÖÖ6 7
Buf
ÖÖ7 :
.
ÖÖ: ;
Equals
ÖÖ; A
(
ÖÖA B
buffer
ÖÖB H
)
ÖÖH I
;
ÖÖI J
public
áá 
int
áá 
	CompareTo
áá 
(
áá 
IByteBuffer
áá (
buffer
áá) /
)
áá/ 0
=>
áá1 3
this
áá4 8
.
áá8 9
Buf
áá9 <
.
áá< =
	CompareTo
áá= F
(
ááF G
buffer
ááG M
)
ááM N
;
ááN O
public
ââ 
override
ââ 
string
ââ 
ToString
ââ '
(
ââ' (
)
ââ( )
=>
ââ* ,
this
ââ- 1
.
ââ1 2
GetType
ââ2 9
(
ââ9 :
)
ââ: ;
.
ââ; <
Name
ââ< @
+
ââA B
$char
ââC F
+
ââG H
this
ââI M
.
ââM N
Buf
ââN Q
+
ââR S
$char
ââT W
;
ââW X
public
ãã 
virtual
ãã 
IReferenceCounted
ãã (
Retain
ãã) /
(
ãã/ 0
int
ãã0 3
	increment
ãã4 =
)
ãã= >
{
åå 	
this
çç 
.
çç 
Buf
çç 
.
çç 
Retain
çç 
(
çç 
	increment
çç %
)
çç% &
;
çç& '
return
éé 
this
éé 
;
éé 
}
èè 	
public
ëë 
virtual
ëë 
IReferenceCounted
ëë (
Retain
ëë) /
(
ëë/ 0
)
ëë0 1
{
íí 	
this
ìì 
.
ìì 
Buf
ìì 
.
ìì 
Retain
ìì 
(
ìì 
)
ìì 
;
ìì 
return
îî 
this
îî 
;
îî 
}
ïï 	
public
óó 
virtual
óó 
IReferenceCounted
óó (
Touch
óó) .
(
óó. /
)
óó/ 0
{
òò 	
this
ôô 
.
ôô 
Buf
ôô 
.
ôô 
Touch
ôô 
(
ôô 
)
ôô 
;
ôô 
return
öö 
this
öö 
;
öö 
}
õõ 	
public
ùù 
virtual
ùù 
IReferenceCounted
ùù (
Touch
ùù) .
(
ùù. /
object
ùù/ 5
hint
ùù6 :
)
ùù: ;
{
ûû 	
this
üü 
.
üü 
Buf
üü 
.
üü 
Touch
üü 
(
üü 
hint
üü 
)
üü  
;
üü  !
return
†† 
this
†† 
;
†† 
}
°° 	
public
££ 
bool
££ 

IsReadable
££ 
(
££ 
int
££ "
size
££# '
)
££' (
=>
££) +
this
££, 0
.
££0 1
Buf
££1 4
.
££4 5

IsReadable
££5 ?
(
££? @
size
££@ D
)
££D E
;
££E F
public
•• 
bool
•• 

IsWritable
•• 
(
•• 
int
•• "
size
••# '
)
••' (
=>
••) +
this
••, 0
.
••0 1
Buf
••1 4
.
••4 5

IsWritable
••5 ?
(
••? @
size
••@ D
)
••D E
;
••E F
public
ßß 
int
ßß 
ReferenceCount
ßß !
=>
ßß" $
this
ßß% )
.
ßß) *
Buf
ßß* -
.
ßß- .
ReferenceCount
ßß. <
;
ßß< =
public
©© 
virtual
©© 
bool
©© 
Release
©© #
(
©©# $
)
©©$ %
=>
©©& (
this
©©) -
.
©©- .
Buf
©©. 1
.
©©1 2
Release
©©2 9
(
©©9 :
)
©©: ;
;
©©; <
public
´´ 
virtual
´´ 
bool
´´ 
Release
´´ #
(
´´# $
int
´´$ '
	decrement
´´( 1
)
´´1 2
=>
´´3 5
this
´´6 :
.
´´: ;
Buf
´´; >
.
´´> ?
Release
´´? F
(
´´F G
	decrement
´´G P
)
´´P Q
;
´´Q R
}
¨¨ 
}≠≠ –à
mC:\Users\husain.sardaria\Desktop\DotNetty-dev\DotNetty-dev\src\DotNetty.Buffers\WrappedCompositeByteBuffer.cs
	namespace 	
DotNetty
 
. 
Buffers 
{ 
class 	&
WrappedCompositeByteBuffer
 $
:% &
CompositeByteBuffer' :
{ 
readonly 
CompositeByteBuffer $
wrapped% ,
;, -
internal &
WrappedCompositeByteBuffer +
(+ ,
CompositeByteBuffer, ?
wrapped@ G
)G H
:I J
baseK O
(O P
wrappedP W
.W X
	AllocatorX a
)a b
{ 	
this 
. 
wrapped 
= 
wrapped "
;" #
this 
. 
SetMaxCapacity 
(  
this  $
.$ %
wrapped% ,
., -
MaxCapacity- 8
)8 9
;9 :
} 	
public 
override 
bool 
Release $
($ %
)% &
=>' )
this* .
.. /
wrapped/ 6
.6 7
Release7 >
(> ?
)? @
;@ A
public 
override 
bool 
Release $
($ %
int% (
	decrement) 2
)2 3
=>4 6
this7 ;
.; <
wrapped< C
.C D
ReleaseD K
(K L
	decrementL U
)U V
;V W
public 
sealed 
override 
int "
ReaderIndex# .
=>/ 1
this2 6
.6 7
wrapped7 >
.> ?
ReaderIndex? J
;J K
public 
sealed 
override 
int "
WriterIndex# .
=>/ 1
this2 6
.6 7
wrapped7 >
.> ?
WriterIndex? J
;J K
public!! 
sealed!! 
override!! 
bool!! #

IsReadable!!$ .
(!!. /
)!!/ 0
=>!!1 3
this!!4 8
.!!8 9
wrapped!!9 @
.!!@ A

IsReadable!!A K
(!!K L
)!!L M
;!!M N
public## 
sealed## 
override## 
bool## #

IsReadable##$ .
(##. /
int##/ 2
numBytes##3 ;
)##; <
=>##= ?
this##@ D
.##D E
wrapped##E L
.##L M

IsReadable##M W
(##W X
numBytes##X `
)##` a
;##a b
public%% 
sealed%% 
override%% 
bool%% #

IsWritable%%$ .
(%%. /
)%%/ 0
=>%%1 3
this%%4 8
.%%8 9
wrapped%%9 @
.%%@ A

IsWritable%%A K
(%%K L
)%%L M
;%%M N
public'' 
sealed'' 
override'' 
int'' "
ReadableBytes''# 0
=>''1 3
this''4 8
.''8 9
wrapped''9 @
.''@ A
ReadableBytes''A N
;''N O
public)) 
sealed)) 
override)) 
int)) "
WritableBytes))# 0
=>))1 3
this))4 8
.))8 9
wrapped))9 @
.))@ A
WritableBytes))A N
;))N O
public++ 
sealed++ 
override++ 
int++ "
MaxWritableBytes++# 3
=>++4 6
this++7 ;
.++; <
wrapped++< C
.++C D
MaxWritableBytes++D T
;++T U
public-- 
override-- 
int-- 
EnsureWritable-- *
(--* +
int--+ .
minWritableBytes--/ ?
,--? @
bool--A E
force--F K
)--K L
=>--M O
this--P T
.--T U
wrapped--U \
.--\ ]
EnsureWritable--] k
(--k l
minWritableBytes--l |
,--| }
force	--~ É
)
--É Ñ
;
--Ñ Ö
public// 
override// 
short// 
GetShort// &
(//& '
int//' *
index//+ 0
)//0 1
=>//2 4
this//5 9
.//9 :
wrapped//: A
.//A B
GetShort//B J
(//J K
index//K P
)//P Q
;//Q R
public11 
override11 
short11 

GetShortLE11 (
(11( )
int11) ,
index11- 2
)112 3
=>114 6
this117 ;
.11; <
wrapped11< C
.11C D

GetShortLE11D N
(11N O
index11O T
)11T U
;11U V
public33 
override33 
int33 
GetUnsignedMedium33 -
(33- .
int33. 1
index332 7
)337 8
=>339 ;
this33< @
.33@ A
wrapped33A H
.33H I
GetUnsignedMedium33I Z
(33Z [
index33[ `
)33` a
;33a b
public55 
override55 
int55 
GetUnsignedMediumLE55 /
(55/ 0
int550 3
index554 9
)559 :
=>55; =
this55> B
.55B C
wrapped55C J
.55J K
GetUnsignedMediumLE55K ^
(55^ _
index55_ d
)55d e
;55e f
public77 
override77 
int77 
GetInt77 "
(77" #
int77# &
index77' ,
)77, -
=>77. 0
this771 5
.775 6
wrapped776 =
.77= >
GetInt77> D
(77D E
index77E J
)77J K
;77K L
public99 
override99 
int99 
GetIntLE99 $
(99$ %
int99% (
index99) .
)99. /
=>990 2
this993 7
.997 8
wrapped998 ?
.99? @
GetIntLE99@ H
(99H I
index99I N
)99N O
;99O P
public;; 
override;; 
long;; 
GetLong;; $
(;;$ %
int;;% (
index;;) .
);;. /
=>;;0 2
this;;3 7
.;;7 8
wrapped;;8 ?
.;;? @
GetLong;;@ G
(;;G H
index;;H M
);;M N
;;;N O
public== 
override== 
long== 
	GetLongLE== &
(==& '
int==' *
index==+ 0
)==0 1
=>==2 4
this==5 9
.==9 :
wrapped==: A
.==A B
	GetLongLE==B K
(==K L
index==L Q
)==Q R
;==R S
public?? 
override?? 
char?? 
GetChar?? $
(??$ %
int??% (
index??) .
)??. /
=>??0 2
this??3 7
.??7 8
wrapped??8 ?
.??? @
GetChar??@ G
(??G H
index??H M
)??M N
;??N O
publicAA 
overrideAA 
IByteBufferAA #

SetShortLEAA$ .
(AA. /
intAA/ 2
indexAA3 8
,AA8 9
intAA: =
valueAA> C
)AAC D
=>AAE G
thisAAH L
.AAL M
wrappedAAM T
.AAT U

SetShortLEAAU _
(AA_ `
indexAA` e
,AAe f
valueAAg l
)AAl m
;AAm n
publicCC 
overrideCC 
IByteBufferCC #
SetMediumLECC$ /
(CC/ 0
intCC0 3
indexCC4 9
,CC9 :
intCC; >
valueCC? D
)CCD E
=>CCF H
thisCCI M
.CCM N
wrappedCCN U
.CCU V
SetMediumLECCV a
(CCa b
indexCCb g
,CCg h
valueCCi n
)CCn o
;CCo p
publicEE 
overrideEE 
IByteBufferEE #
SetIntLEEE$ ,
(EE, -
intEE- 0
indexEE1 6
,EE6 7
intEE8 ;
valueEE< A
)EEA B
=>EEC E
thisEEF J
.EEJ K
wrappedEEK R
.EER S
SetIntLEEES [
(EE[ \
indexEE\ a
,EEa b
valueEEc h
)EEh i
;EEi j
publicGG 
overrideGG 
IByteBufferGG #
	SetLongLEGG$ -
(GG- .
intGG. 1
indexGG2 7
,GG7 8
longGG9 =
valueGG> C
)GGC D
=>GGE G
thisGGH L
.GGL M
wrappedGGM T
.GGT U
	SetLongLEGGU ^
(GG^ _
indexGG_ d
,GGd e
valueGGf k
)GGk l
;GGl m
publicII 
overrideII 
byteII 
ReadByteII %
(II% &
)II& '
=>II( *
thisII+ /
.II/ 0
wrappedII0 7
.II7 8
ReadByteII8 @
(II@ A
)IIA B
;IIB C
publicKK 
overrideKK 
shortKK 
	ReadShortKK '
(KK' (
)KK( )
=>KK* ,
thisKK- 1
.KK1 2
wrappedKK2 9
.KK9 :
	ReadShortKK: C
(KKC D
)KKD E
;KKE F
publicMM 
overrideMM 
shortMM 
ReadShortLEMM )
(MM) *
)MM* +
=>MM, .
thisMM/ 3
.MM3 4
wrappedMM4 ;
.MM; <
ReadShortLEMM< G
(MMG H
)MMH I
;MMI J
publicOO 
overrideOO 
intOO 
ReadUnsignedMediumOO .
(OO. /
)OO/ 0
=>OO1 3
thisOO4 8
.OO8 9
wrappedOO9 @
.OO@ A
ReadUnsignedMediumOOA S
(OOS T
)OOT U
;OOU V
publicQQ 
overrideQQ 
intQQ  
ReadUnsignedMediumLEQQ 0
(QQ0 1
)QQ1 2
=>QQ3 5
thisQQ6 :
.QQ: ;
wrappedQQ; B
.QQB C 
ReadUnsignedMediumLEQQC W
(QQW X
)QQX Y
;QQY Z
publicSS 
overrideSS 
intSS 
ReadIntSS #
(SS# $
)SS$ %
=>SS& (
thisSS) -
.SS- .
wrappedSS. 5
.SS5 6
ReadIntSS6 =
(SS= >
)SS> ?
;SS? @
publicUU 
overrideUU 
intUU 
	ReadIntLEUU %
(UU% &
)UU& '
=>UU( *
thisUU+ /
.UU/ 0
wrappedUU0 7
.UU7 8
	ReadIntLEUU8 A
(UUA B
)UUB C
;UUC D
publicWW 
overrideWW 
longWW 
ReadLongWW %
(WW% &
)WW& '
=>WW( *
thisWW+ /
.WW/ 0
wrappedWW0 7
.WW7 8
ReadLongWW8 @
(WW@ A
)WWA B
;WWB C
publicYY 
overrideYY 
longYY 

ReadLongLEYY '
(YY' (
)YY( )
=>YY* ,
thisYY- 1
.YY1 2
wrappedYY2 9
.YY9 :

ReadLongLEYY: D
(YYD E
)YYE F
;YYF G
public[[ 
override[[ 
IByteBuffer[[ #
	ReadBytes[[$ -
([[- .
int[[. 1
length[[2 8
)[[8 9
=>[[: <
this[[= A
.[[A B
wrapped[[B I
.[[I J
	ReadBytes[[J S
([[S T
length[[T Z
)[[Z [
;[[[ \
public]] 
override]] 
IByteBuffer]] #
Slice]]$ )
(]]) *
)]]* +
=>]], .
this]]/ 3
.]]3 4
wrapped]]4 ;
.]]; <
Slice]]< A
(]]A B
)]]B C
;]]C D
public__ 
override__ 
IByteBuffer__ #
Slice__$ )
(__) *
int__* -
index__. 3
,__3 4
int__5 8
length__9 ?
)__? @
=>__A C
this__D H
.__H I
wrapped__I P
.__P Q
Slice__Q V
(__V W
index__W \
,__\ ]
length__^ d
)__d e
;__e f
publicaa 
overrideaa 
stringaa 
ToStringaa '
(aa' (
Encodingaa( 0
encodingaa1 9
)aa9 :
=>aa; =
thisaa> B
.aaB C
wrappedaaC J
.aaJ K
ToStringaaK S
(aaS T
encodingaaT \
)aa\ ]
;aa] ^
publiccc 
overridecc 
stringcc 
ToStringcc '
(cc' (
intcc( +
indexcc, 1
,cc1 2
intcc3 6
lengthcc7 =
,cc= >
Encodingcc? G
encodingccH P
)ccP Q
=>ccR T
thisccU Y
.ccY Z
wrappedccZ a
.cca b
ToStringccb j
(ccj k
indexcck p
,ccp q
lengthccr x
,ccx y
encoding	ccz Ç
)
ccÇ É
;
ccÉ Ñ
publicee 
overrideee 
intee 
IndexOfee #
(ee# $
intee$ '
	fromIndexee( 1
,ee1 2
intee3 6
toIndexee7 >
,ee> ?
byteee@ D
valueeeE J
)eeJ K
=>eeL N
thiseeO S
.eeS T
wrappedeeT [
.ee[ \
IndexOfee\ c
(eec d
	fromIndexeed m
,eem n
toIndexeeo v
,eev w
valueeex }
)ee} ~
;ee~ 
publicgg 
overridegg 
intgg 
BytesBeforegg '
(gg' (
intgg( +
indexgg, 1
,gg1 2
intgg3 6
lengthgg7 =
,gg= >
bytegg? C
valueggD I
)ggI J
=>ggK M
thisggN R
.ggR S
wrappedggS Z
.ggZ [
BytesBeforegg[ f
(ggf g
indexggg l
,ggl m
lengthggn t
,ggt u
valueggv {
)gg{ |
;gg| }
publicii 
overrideii 
intii 
ForEachByteii '
(ii' (
IByteProcessorii( 6
	processorii7 @
)ii@ A
=>iiB D
thisiiE I
.iiI J
wrappediiJ Q
.iiQ R
ForEachByteiiR ]
(ii] ^
	processorii^ g
)iig h
;iih i
publickk 
overridekk 
intkk 
ForEachBytekk '
(kk' (
intkk( +
indexkk, 1
,kk1 2
intkk3 6
lengthkk7 =
,kk= >
IByteProcessorkk? M
	processorkkN W
)kkW X
=>kkY [
thiskk\ `
.kk` a
wrappedkka h
.kkh i
ForEachBytekki t
(kkt u
indexkku z
,kkz {
length	kk| Ç
,
kkÇ É
	processor
kkÑ ç
)
kkç é
;
kké è
publicmm 
overridemm 
intmm 
ForEachByteDescmm +
(mm+ ,
IByteProcessormm, :
	processormm; D
)mmD E
=>mmF H
thismmI M
.mmM N
wrappedmmN U
.mmU V
ForEachByteDescmmV e
(mme f
	processormmf o
)mmo p
;mmp q
publicoo 
overrideoo 
intoo 
ForEachByteDescoo +
(oo+ ,
intoo, /
indexoo0 5
,oo5 6
intoo7 :
lengthoo; A
,ooA B
IByteProcessorooC Q
	processorooR [
)oo[ \
=>oo] _
thisoo` d
.ood e
wrappedooe l
.ool m
ForEachByteDescoom |
(oo| }
index	oo} Ç
,
ooÇ É
length
ooÑ ä
,
ooä ã
	processor
ooå ï
)
ooï ñ
;
ooñ ó
publicqq 
sealedqq 
overrideqq 
intqq "
GetHashCodeqq# .
(qq. /
)qq/ 0
=>qq1 3
thisqq4 8
.qq8 9
wrappedqq9 @
.qq@ A
GetHashCodeqqA L
(qqL M
)qqM N
;qqN O
publicss 
sealedss 
overridess 
boolss #
Equalsss$ *
(ss* +
IByteBufferss+ 6
bufss7 :
)ss: ;
=>ss< >
thisss? C
.ssC D
wrappedssD K
.ssK L
EqualsssL R
(ssR S
bufssS V
)ssV W
;ssW X
publicuu 
sealeduu 
overrideuu 
intuu "
	CompareTouu# ,
(uu, -
IByteBufferuu- 8
thatuu9 =
)uu= >
=>uu? A
thisuuB F
.uuF G
wrappeduuG N
.uuN O
	CompareTouuO X
(uuX Y
thatuuY ]
)uu] ^
;uu^ _
publicww 
sealedww 
overrideww 
intww "
ReferenceCountww# 1
=>ww2 4
thisww5 9
.ww9 :
wrappedww: A
.wwA B
ReferenceCountwwB P
;wwP Q
publicyy 
overrideyy 
IByteBufferyy #
	Duplicateyy$ -
(yy- .
)yy. /
=>yy0 2
thisyy3 7
.yy7 8
wrappedyy8 ?
.yy? @
	Duplicateyy@ I
(yyI J
)yyJ K
;yyK L
public{{ 
override{{ 
IByteBuffer{{ #
	ReadSlice{{$ -
({{- .
int{{. 1
length{{2 8
){{8 9
=>{{: <
this{{= A
.{{A B
wrapped{{B I
.{{I J
	ReadSlice{{J S
({{S T
length{{T Z
){{Z [
;{{[ \
public}} 
override}} 
IByteBuffer}} #
WriteShortLE}}$ 0
(}}0 1
int}}1 4
value}}5 :
)}}: ;
=>}}< >
this}}? C
.}}C D
wrapped}}D K
.}}K L
WriteShortLE}}L X
(}}X Y
value}}Y ^
)}}^ _
;}}_ `
public 
override 
IByteBuffer #
WriteMediumLE$ 1
(1 2
int2 5
value6 ;
); <
=>= ?
this@ D
.D E
wrappedE L
.L M
WriteMediumLEM Z
(Z [
value[ `
)` a
;a b
public
ÅÅ 
override
ÅÅ 
IByteBuffer
ÅÅ #

WriteIntLE
ÅÅ$ .
(
ÅÅ. /
int
ÅÅ/ 2
value
ÅÅ3 8
)
ÅÅ8 9
=>
ÅÅ: <
this
ÅÅ= A
.
ÅÅA B
wrapped
ÅÅB I
.
ÅÅI J

WriteIntLE
ÅÅJ T
(
ÅÅT U
value
ÅÅU Z
)
ÅÅZ [
;
ÅÅ[ \
public
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ #
WriteLongLE
ÉÉ$ /
(
ÉÉ/ 0
long
ÉÉ0 4
value
ÉÉ5 :
)
ÉÉ: ;
=>
ÉÉ< >
this
ÉÉ? C
.
ÉÉC D
wrapped
ÉÉD K
.
ÉÉK L
WriteLongLE
ÉÉL W
(
ÉÉW X
value
ÉÉX ]
)
ÉÉ] ^
;
ÉÉ^ _
public
ÖÖ 
override
ÖÖ 
Task
ÖÖ 
WriteBytesAsync
ÖÖ ,
(
ÖÖ, -
Stream
ÖÖ- 3
stream
ÖÖ4 :
,
ÖÖ: ;
int
ÖÖ< ?
length
ÖÖ@ F
,
ÖÖF G
CancellationToken
ÖÖH Y
cancellationToken
ÖÖZ k
)
ÖÖk l
=>
ÖÖm o
this
ÖÖp t
.
ÖÖt u
wrapped
ÖÖu |
.
ÖÖ| }
WriteBytesAsyncÖÖ} å
(ÖÖå ç
streamÖÖç ì
,ÖÖì î
lengthÖÖï õ
,ÖÖõ ú!
cancellationTokenÖÖù Æ
)ÖÖÆ Ø
;ÖÖØ ∞
public
áá 
override
áá !
CompositeByteBuffer
áá +
AddComponent
áá, 8
(
áá8 9
IByteBuffer
áá9 D
buffer
ááE K
)
ááK L
{
àà 	
this
ââ 
.
ââ 
wrapped
ââ 
.
ââ 
AddComponent
ââ %
(
ââ% &
buffer
ââ& ,
)
ââ, -
;
ââ- .
return
ää 
this
ää 
;
ää 
}
ãã 	
public
çç 
override
çç !
CompositeByteBuffer
çç +
AddComponents
çç, 9
(
çç9 :
params
çç: @
IByteBuffer
ççA L
[
ççL M
]
ççM N
buffers
ççO V
)
ççV W
{
éé 	
this
èè 
.
èè 
wrapped
èè 
.
èè 
AddComponents
èè &
(
èè& '
buffers
èè' .
)
èè. /
;
èè/ 0
return
êê 
this
êê 
;
êê 
}
ëë 	
public
ìì 
override
ìì !
CompositeByteBuffer
ìì +
AddComponents
ìì, 9
(
ìì9 :
IEnumerable
ìì: E
<
ììE F
IByteBuffer
ììF Q
>
ììQ R
buffers
ììS Z
)
ììZ [
{
îî 	
this
ïï 
.
ïï 
wrapped
ïï 
.
ïï 
AddComponents
ïï &
(
ïï& '
buffers
ïï' .
)
ïï. /
;
ïï/ 0
return
ññ 
this
ññ 
;
ññ 
}
óó 	
public
ôô 
override
ôô !
CompositeByteBuffer
ôô +
AddComponent
ôô, 8
(
ôô8 9
int
ôô9 <
cIndex
ôô= C
,
ôôC D
IByteBuffer
ôôE P
buffer
ôôQ W
)
ôôW X
{
öö 	
this
õõ 
.
õõ 
wrapped
õõ 
.
õõ 
AddComponent
õõ %
(
õõ% &
cIndex
õõ& ,
,
õõ, -
buffer
õõ. 4
)
õõ4 5
;
õõ5 6
return
úú 
this
úú 
;
úú 
}
ùù 	
public
üü 
override
üü !
CompositeByteBuffer
üü +
AddComponents
üü, 9
(
üü9 :
int
üü: =
cIndex
üü> D
,
üüD E
params
üüF L
IByteBuffer
üüM X
[
üüX Y
]
üüY Z
buffers
üü[ b
)
üüb c
{
†† 	
this
°° 
.
°° 
wrapped
°° 
.
°° 
AddComponents
°° &
(
°°& '
cIndex
°°' -
,
°°- .
buffers
°°/ 6
)
°°6 7
;
°°7 8
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
override
•• !
CompositeByteBuffer
•• +
AddComponents
••, 9
(
••9 :
int
••: =
cIndex
••> D
,
••D E
IEnumerable
••F Q
<
••Q R
IByteBuffer
••R ]
>
••] ^
buffers
••_ f
)
••f g
{
¶¶ 	
this
ßß 
.
ßß 
wrapped
ßß 
.
ßß 
AddComponents
ßß &
(
ßß& '
cIndex
ßß' -
,
ßß- .
buffers
ßß/ 6
)
ßß6 7
;
ßß7 8
return
®® 
this
®® 
;
®® 
}
©© 	
public
´´ 
override
´´ !
CompositeByteBuffer
´´ +
AddComponent
´´, 8
(
´´8 9
bool
´´9 =!
increaseWriterIndex
´´> Q
,
´´Q R
IByteBuffer
´´S ^
buffer
´´_ e
)
´´e f
{
¨¨ 	
this
≠≠ 
.
≠≠ 
wrapped
≠≠ 
.
≠≠ 
AddComponent
≠≠ %
(
≠≠% &!
increaseWriterIndex
≠≠& 9
,
≠≠9 :
buffer
≠≠; A
)
≠≠A B
;
≠≠B C
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ØØ 	
public
±± 
override
±± !
CompositeByteBuffer
±± +
AddComponents
±±, 9
(
±±9 :
bool
±±: >!
increaseWriterIndex
±±? R
,
±±R S
params
±±T Z
IByteBuffer
±±[ f
[
±±f g
]
±±g h
buffers
±±i p
)
±±p q
{
≤≤ 	
this
≥≥ 
.
≥≥ 
wrapped
≥≥ 
.
≥≥ 
AddComponents
≥≥ &
(
≥≥& '!
increaseWriterIndex
≥≥' :
,
≥≥: ;
buffers
≥≥< C
)
≥≥C D
;
≥≥D E
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
override
∑∑ !
CompositeByteBuffer
∑∑ +
AddComponents
∑∑, 9
(
∑∑9 :
bool
∑∑: >!
increaseWriterIndex
∑∑? R
,
∑∑R S
IEnumerable
∑∑T _
<
∑∑_ `
IByteBuffer
∑∑` k
>
∑∑k l
buffers
∑∑m t
)
∑∑t u
{
∏∏ 	
this
ππ 
.
ππ 
wrapped
ππ 
.
ππ 
AddComponents
ππ &
(
ππ& '!
increaseWriterIndex
ππ' :
,
ππ: ;
buffers
ππ< C
)
ππC D
;
ππD E
return
∫∫ 
this
∫∫ 
;
∫∫ 
}
ªª 	
public
ΩΩ 
override
ΩΩ !
CompositeByteBuffer
ΩΩ +
AddComponent
ΩΩ, 8
(
ΩΩ8 9
bool
ΩΩ9 =!
increaseWriterIndex
ΩΩ> Q
,
ΩΩQ R
int
ΩΩS V
cIndex
ΩΩW ]
,
ΩΩ] ^
IByteBuffer
ΩΩ_ j
buffer
ΩΩk q
)
ΩΩq r
{
ææ 	
this
øø 
.
øø 
wrapped
øø 
.
øø 
AddComponent
øø %
(
øø% &!
increaseWriterIndex
øø& 9
,
øø9 :
cIndex
øø; A
,
øøA B
buffer
øøC I
)
øøI J
;
øøJ K
return
¿¿ 
this
¿¿ 
;
¿¿ 
}
¡¡ 	
public
√√ 
override
√√ !
CompositeByteBuffer
√√ +
RemoveComponent
√√, ;
(
√√; <
int
√√< ?
cIndex
√√@ F
)
√√F G
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
wrapped
≈≈ 
.
≈≈ 
RemoveComponent
≈≈ (
(
≈≈( )
cIndex
≈≈) /
)
≈≈/ 0
;
≈≈0 1
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
override
…… !
CompositeByteBuffer
…… +
RemoveComponents
……, <
(
……< =
int
……= @
cIndex
……A G
,
……G H
int
……I L
numComponents
……M Z
)
……Z [
{
   	
this
ÀÀ 
.
ÀÀ 
wrapped
ÀÀ 
.
ÀÀ 
RemoveComponents
ÀÀ )
(
ÀÀ) *
cIndex
ÀÀ* 0
,
ÀÀ0 1
numComponents
ÀÀ2 ?
)
ÀÀ? @
;
ÀÀ@ A
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
œœ 
override
œœ 
IEnumerator
œœ #
<
œœ# $
IByteBuffer
œœ$ /
>
œœ/ 0
GetEnumerator
œœ1 >
(
œœ> ?
)
œœ? @
=>
œœA C
this
œœD H
.
œœH I
wrapped
œœI P
.
œœP Q
GetEnumerator
œœQ ^
(
œœ^ _
)
œœ_ `
;
œœ` a
public
—— 
override
—— 
IList
—— 
<
—— 
IByteBuffer
—— )
>
——) *
	Decompose
——+ 4
(
——4 5
int
——5 8
offset
——9 ?
,
——? @
int
——A D
length
——E K
)
——K L
=>
——M O
this
——P T
.
——T U
wrapped
——U \
.
——\ ]
	Decompose
——] f
(
——f g
offset
——g m
,
——m n
length
——o u
)
——u v
;
——v w
public
”” 
sealed
”” 
override
”” 
bool
”” #
HasArray
””$ ,
=>
””- /
this
””0 4
.
””4 5
wrapped
””5 <
.
””< =
HasArray
””= E
;
””E F
public
’’ 
sealed
’’ 
override
’’ 
byte
’’ #
[
’’# $
]
’’$ %
Array
’’& +
=>
’’, .
this
’’/ 3
.
’’3 4
wrapped
’’4 ;
.
’’; <
Array
’’< A
;
’’A B
public
◊◊ 
sealed
◊◊ 
override
◊◊ 
int
◊◊ "
ArrayOffset
◊◊# .
=>
◊◊/ 1
this
◊◊2 6
.
◊◊6 7
wrapped
◊◊7 >
.
◊◊> ?
ArrayOffset
◊◊? J
;
◊◊J K
public
ŸŸ 
sealed
ŸŸ 
override
ŸŸ 
int
ŸŸ "
Capacity
ŸŸ# +
=>
ŸŸ, .
this
ŸŸ/ 3
.
ŸŸ3 4
wrapped
ŸŸ4 ;
.
ŸŸ; <
Capacity
ŸŸ< D
;
ŸŸD E
public
€€ 
override
€€ 
IByteBuffer
€€ #
AdjustCapacity
€€$ 2
(
€€2 3
int
€€3 6
newCapacity
€€7 B
)
€€B C
{
‹‹ 	
this
›› 
.
›› 
wrapped
›› 
.
›› 
AdjustCapacity
›› '
(
››' (
newCapacity
››( 3
)
››3 4
;
››4 5
return
ﬁﬁ 
this
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
public
·· 
sealed
·· 
override
·· "
IByteBufferAllocator
·· 3
	Allocator
··4 =
=>
··> @
this
··A E
.
··E F
wrapped
··F M
.
··M N
	Allocator
··N W
;
··W X
public
„„ 
sealed
„„ 
override
„„ 
int
„„ "
NumComponents
„„# 0
=>
„„1 3
this
„„4 8
.
„„8 9
wrapped
„„9 @
.
„„@ A
NumComponents
„„A N
;
„„N O
public
ÂÂ 
sealed
ÂÂ 
override
ÂÂ 
int
ÂÂ "
MaxNumComponents
ÂÂ# 3
=>
ÂÂ4 6
this
ÂÂ7 ;
.
ÂÂ; <
wrapped
ÂÂ< C
.
ÂÂC D
MaxNumComponents
ÂÂD T
;
ÂÂT U
public
ÁÁ 
sealed
ÁÁ 
override
ÁÁ 
int
ÁÁ "
ToComponentIndex
ÁÁ# 3
(
ÁÁ3 4
int
ÁÁ4 7
offset
ÁÁ8 >
)
ÁÁ> ?
=>
ÁÁ@ B
this
ÁÁC G
.
ÁÁG H
wrapped
ÁÁH O
.
ÁÁO P
ToComponentIndex
ÁÁP `
(
ÁÁ` a
offset
ÁÁa g
)
ÁÁg h
;
ÁÁh i
public
ÈÈ 
sealed
ÈÈ 
override
ÈÈ 
int
ÈÈ "
ToByteIndex
ÈÈ# .
(
ÈÈ. /
int
ÈÈ/ 2
cIndex
ÈÈ3 9
)
ÈÈ9 :
=>
ÈÈ; =
this
ÈÈ> B
.
ÈÈB C
wrapped
ÈÈC J
.
ÈÈJ K
ToByteIndex
ÈÈK V
(
ÈÈV W
cIndex
ÈÈW ]
)
ÈÈ] ^
;
ÈÈ^ _
public
ÎÎ 
override
ÎÎ 
byte
ÎÎ 
GetByte
ÎÎ $
(
ÎÎ$ %
int
ÎÎ% (
index
ÎÎ) .
)
ÎÎ. /
=>
ÎÎ0 2
this
ÎÎ3 7
.
ÎÎ7 8
wrapped
ÎÎ8 ?
.
ÎÎ? @
GetByte
ÎÎ@ G
(
ÎÎG H
index
ÎÎH M
)
ÎÎM N
;
ÎÎN O
	protected
ÌÌ 
internal
ÌÌ 
sealed
ÌÌ !
override
ÌÌ" *
byte
ÌÌ+ /
_GetByte
ÌÌ0 8
(
ÌÌ8 9
int
ÌÌ9 <
index
ÌÌ= B
)
ÌÌB C
=>
ÌÌD F
this
ÌÌG K
.
ÌÌK L
wrapped
ÌÌL S
.
ÌÌS T
_GetByte
ÌÌT \
(
ÌÌ\ ]
index
ÌÌ] b
)
ÌÌb c
;
ÌÌc d
	protected
ÔÔ 
internal
ÔÔ 
sealed
ÔÔ !
override
ÔÔ" *
short
ÔÔ+ 0
	_GetShort
ÔÔ1 :
(
ÔÔ: ;
int
ÔÔ; >
index
ÔÔ? D
)
ÔÔD E
=>
ÔÔF H
this
ÔÔI M
.
ÔÔM N
wrapped
ÔÔN U
.
ÔÔU V
	_GetShort
ÔÔV _
(
ÔÔ_ `
index
ÔÔ` e
)
ÔÔe f
;
ÔÔf g
	protected
ÒÒ 
internal
ÒÒ 
sealed
ÒÒ !
override
ÒÒ" *
short
ÒÒ+ 0
_GetShortLE
ÒÒ1 <
(
ÒÒ< =
int
ÒÒ= @
index
ÒÒA F
)
ÒÒF G
=>
ÒÒH J
this
ÒÒK O
.
ÒÒO P
wrapped
ÒÒP W
.
ÒÒW X
_GetShortLE
ÒÒX c
(
ÒÒc d
index
ÒÒd i
)
ÒÒi j
;
ÒÒj k
	protected
ÛÛ 
internal
ÛÛ 
sealed
ÛÛ !
override
ÛÛ" *
int
ÛÛ+ . 
_GetUnsignedMedium
ÛÛ/ A
(
ÛÛA B
int
ÛÛB E
index
ÛÛF K
)
ÛÛK L
=>
ÛÛM O
this
ÛÛP T
.
ÛÛT U
wrapped
ÛÛU \
.
ÛÛ\ ] 
_GetUnsignedMedium
ÛÛ] o
(
ÛÛo p
index
ÛÛp u
)
ÛÛu v
;
ÛÛv w
	protected
ıı 
internal
ıı 
sealed
ıı !
override
ıı" *
int
ıı+ ."
_GetUnsignedMediumLE
ıı/ C
(
ııC D
int
ııD G
index
ııH M
)
ııM N
=>
ııO Q
this
ııR V
.
ııV W
wrapped
ııW ^
.
ıı^ _"
_GetUnsignedMediumLE
ıı_ s
(
ııs t
index
ııt y
)
ııy z
;
ıız {
	protected
˜˜ 
internal
˜˜ 
sealed
˜˜ !
override
˜˜" *
int
˜˜+ .
_GetInt
˜˜/ 6
(
˜˜6 7
int
˜˜7 :
index
˜˜; @
)
˜˜@ A
=>
˜˜B D
this
˜˜E I
.
˜˜I J
wrapped
˜˜J Q
.
˜˜Q R
_GetInt
˜˜R Y
(
˜˜Y Z
index
˜˜Z _
)
˜˜_ `
;
˜˜` a
	protected
˘˘ 
internal
˘˘ 
sealed
˘˘ !
override
˘˘" *
int
˘˘+ .
	_GetIntLE
˘˘/ 8
(
˘˘8 9
int
˘˘9 <
index
˘˘= B
)
˘˘B C
=>
˘˘D F
this
˘˘G K
.
˘˘K L
wrapped
˘˘L S
.
˘˘S T
	_GetIntLE
˘˘T ]
(
˘˘] ^
index
˘˘^ c
)
˘˘c d
;
˘˘d e
	protected
˚˚ 
internal
˚˚ 
sealed
˚˚ !
override
˚˚" *
long
˚˚+ /
_GetLong
˚˚0 8
(
˚˚8 9
int
˚˚9 <
index
˚˚= B
)
˚˚B C
=>
˚˚D F
this
˚˚G K
.
˚˚K L
wrapped
˚˚L S
.
˚˚S T
_GetLong
˚˚T \
(
˚˚\ ]
index
˚˚] b
)
˚˚b c
;
˚˚c d
	protected
˝˝ 
internal
˝˝ 
sealed
˝˝ !
override
˝˝" *
long
˝˝+ /

_GetLongLE
˝˝0 :
(
˝˝: ;
int
˝˝; >
index
˝˝? D
)
˝˝D E
=>
˝˝F H
this
˝˝I M
.
˝˝M N
wrapped
˝˝N U
.
˝˝U V

_GetLongLE
˝˝V `
(
˝˝` a
index
˝˝a f
)
˝˝f g
;
˝˝g h
public
ˇˇ 
override
ˇˇ 
IByteBuffer
ˇˇ #
GetBytes
ˇˇ$ ,
(
ˇˇ, -
int
ˇˇ- 0
index
ˇˇ1 6
,
ˇˇ6 7
byte
ˇˇ8 <
[
ˇˇ< =
]
ˇˇ= >
dst
ˇˇ? B
,
ˇˇB C
int
ˇˇD G
dstIndex
ˇˇH P
,
ˇˇP Q
int
ˇˇR U
length
ˇˇV \
)
ˇˇ\ ]
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
wrapped
ÅÅ 
.
ÅÅ 
GetBytes
ÅÅ !
(
ÅÅ! "
index
ÅÅ" '
,
ÅÅ' (
dst
ÅÅ) ,
,
ÅÅ, -
dstIndex
ÅÅ. 6
,
ÅÅ6 7
length
ÅÅ8 >
)
ÅÅ> ?
;
ÅÅ? @
return
ÇÇ 
this
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
IByteBuffer
ÖÖ #
GetBytes
ÖÖ$ ,
(
ÖÖ, -
int
ÖÖ- 0
index
ÖÖ1 6
,
ÖÖ6 7
IByteBuffer
ÖÖ8 C
dst
ÖÖD G
,
ÖÖG H
int
ÖÖI L
dstIndex
ÖÖM U
,
ÖÖU V
int
ÖÖW Z
length
ÖÖ[ a
)
ÖÖa b
{
ÜÜ 	
this
áá 
.
áá 
wrapped
áá 
.
áá 
GetBytes
áá !
(
áá! "
index
áá" '
,
áá' (
dst
áá) ,
,
áá, -
dstIndex
áá. 6
,
áá6 7
length
áá8 >
)
áá> ?
;
áá? @
return
àà 
this
àà 
;
àà 
}
ââ 	
public
ãã 
override
ãã 
IByteBuffer
ãã #
GetBytes
ãã$ ,
(
ãã, -
int
ãã- 0
index
ãã1 6
,
ãã6 7
Stream
ãã8 >
destination
ãã? J
,
ããJ K
int
ããL O
length
ããP V
)
ããV W
=>
ããX Z
this
ãã[ _
.
ãã_ `
wrapped
ãã` g
.
ããg h
GetBytes
ããh p
(
ããp q
index
ããq v
,
ããv w
destinationããx É
,ããÉ Ñ
lengthããÖ ã
)ããã å
;ããå ç
public
çç 
override
çç 
IByteBuffer
çç #
SetByte
çç$ +
(
çç+ ,
int
çç, /
index
çç0 5
,
çç5 6
int
çç7 :
value
çç; @
)
çç@ A
{
éé 	
this
èè 
.
èè 
wrapped
èè 
.
èè 
SetByte
èè  
(
èè  !
index
èè! &
,
èè& '
value
èè( -
)
èè- .
;
èè. /
return
êê 
this
êê 
;
êê 
}
ëë 	
	protected
ìì 
internal
ìì 
sealed
ìì !
override
ìì" *
void
ìì+ /
_SetByte
ìì0 8
(
ìì8 9
int
ìì9 <
index
ìì= B
,
ììB C
int
ììD G
value
ììH M
)
ììM N
=>
ììO Q
this
ììR V
.
ììV W
wrapped
ììW ^
.
ìì^ _
_SetByte
ìì_ g
(
ììg h
index
ììh m
,
ììm n
value
ììo t
)
ììt u
;
ììu v
public
ïï 
override
ïï 
IByteBuffer
ïï #
SetShort
ïï$ ,
(
ïï, -
int
ïï- 0
index
ïï1 6
,
ïï6 7
int
ïï8 ;
value
ïï< A
)
ïïA B
{
ññ 	
this
óó 
.
óó 
wrapped
óó 
.
óó 
SetShort
óó !
(
óó! "
index
óó" '
,
óó' (
value
óó) .
)
óó. /
;
óó/ 0
return
òò 
this
òò 
;
òò 
}
ôô 	
	protected
õõ 
internal
õõ 
sealed
õõ !
override
õõ" *
void
õõ+ /
	_SetShort
õõ0 9
(
õõ9 :
int
õõ: =
index
õõ> C
,
õõC D
int
õõE H
value
õõI N
)
õõN O
=>
õõP R
this
õõS W
.
õõW X
wrapped
õõX _
.
õõ_ `
	_SetShort
õõ` i
(
õõi j
index
õõj o
,
õõo p
value
õõq v
)
õõv w
;
õõw x
	protected
ùù 
internal
ùù 
sealed
ùù !
override
ùù" *
void
ùù+ /
_SetShortLE
ùù0 ;
(
ùù; <
int
ùù< ?
index
ùù@ E
,
ùùE F
int
ùùG J
value
ùùK P
)
ùùP Q
=>
ùùR T
this
ùùU Y
.
ùùY Z
wrapped
ùùZ a
.
ùùa b
_SetShortLE
ùùb m
(
ùùm n
index
ùùn s
,
ùùs t
value
ùùu z
)
ùùz {
;
ùù{ |
public
üü 
override
üü 
IByteBuffer
üü #
	SetMedium
üü$ -
(
üü- .
int
üü. 1
index
üü2 7
,
üü7 8
int
üü9 <
value
üü= B
)
üüB C
{
†† 	
this
°° 
.
°° 
wrapped
°° 
.
°° 
	SetMedium
°° "
(
°°" #
index
°°# (
,
°°( )
value
°°* /
)
°°/ 0
;
°°0 1
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
	protected
•• 
internal
•• 
sealed
•• !
override
••" *
void
••+ /

_SetMedium
••0 :
(
••: ;
int
••; >
index
••? D
,
••D E
int
••F I
value
••J O
)
••O P
=>
••Q S
this
••T X
.
••X Y
wrapped
••Y `
.
••` a

_SetMedium
••a k
(
••k l
index
••l q
,
••q r
value
••s x
)
••x y
;
••y z
	protected
ßß 
internal
ßß 
sealed
ßß !
override
ßß" *
void
ßß+ /
_SetMediumLE
ßß0 <
(
ßß< =
int
ßß= @
index
ßßA F
,
ßßF G
int
ßßH K
value
ßßL Q
)
ßßQ R
=>
ßßS U
this
ßßV Z
.
ßßZ [
wrapped
ßß[ b
.
ßßb c
_SetMediumLE
ßßc o
(
ßßo p
index
ßßp u
,
ßßu v
value
ßßw |
)
ßß| }
;
ßß} ~
public
©© 
override
©© 
IByteBuffer
©© #
SetInt
©©$ *
(
©©* +
int
©©+ .
index
©©/ 4
,
©©4 5
int
©©6 9
value
©©: ?
)
©©? @
{
™™ 	
this
´´ 
.
´´ 
wrapped
´´ 
.
´´ 
SetInt
´´ 
(
´´  
index
´´  %
,
´´% &
value
´´' ,
)
´´, -
;
´´- .
return
¨¨ 
this
¨¨ 
;
¨¨ 
}
≠≠ 	
	protected
ØØ 
internal
ØØ 
sealed
ØØ !
override
ØØ" *
void
ØØ+ /
_SetInt
ØØ0 7
(
ØØ7 8
int
ØØ8 ;
index
ØØ< A
,
ØØA B
int
ØØC F
value
ØØG L
)
ØØL M
=>
ØØN P
this
ØØQ U
.
ØØU V
wrapped
ØØV ]
.
ØØ] ^
_SetInt
ØØ^ e
(
ØØe f
index
ØØf k
,
ØØk l
value
ØØm r
)
ØØr s
;
ØØs t
	protected
±± 
internal
±± 
sealed
±± !
override
±±" *
void
±±+ /
	_SetIntLE
±±0 9
(
±±9 :
int
±±: =
index
±±> C
,
±±C D
int
±±E H
value
±±I N
)
±±N O
=>
±±P R
this
±±S W
.
±±W X
wrapped
±±X _
.
±±_ `
	_SetIntLE
±±` i
(
±±i j
index
±±j o
,
±±o p
value
±±q v
)
±±v w
;
±±w x
public
≥≥ 
override
≥≥ 
IByteBuffer
≥≥ #
SetLong
≥≥$ +
(
≥≥+ ,
int
≥≥, /
index
≥≥0 5
,
≥≥5 6
long
≥≥7 ;
value
≥≥< A
)
≥≥A B
{
¥¥ 	
this
µµ 
.
µµ 
wrapped
µµ 
.
µµ 
SetLong
µµ  
(
µµ  !
index
µµ! &
,
µµ& '
value
µµ( -
)
µµ- .
;
µµ. /
return
∂∂ 
this
∂∂ 
;
∂∂ 
}
∑∑ 	
	protected
ππ 
internal
ππ 
sealed
ππ !
override
ππ" *
void
ππ+ /
_SetLong
ππ0 8
(
ππ8 9
int
ππ9 <
index
ππ= B
,
ππB C
long
ππD H
value
ππI N
)
ππN O
=>
ππP R
this
ππS W
.
ππW X
wrapped
ππX _
.
ππ_ `
_SetLong
ππ` h
(
ππh i
index
ππi n
,
ππn o
value
ππp u
)
ππu v
;
ππv w
	protected
ªª 
internal
ªª 
sealed
ªª !
override
ªª" *
void
ªª+ /

_SetLongLE
ªª0 :
(
ªª: ;
int
ªª; >
index
ªª? D
,
ªªD E
long
ªªF J
value
ªªK P
)
ªªP Q
=>
ªªR T
this
ªªU Y
.
ªªY Z
wrapped
ªªZ a
.
ªªa b

_SetLongLE
ªªb l
(
ªªl m
index
ªªm r
,
ªªr s
value
ªªt y
)
ªªy z
;
ªªz {
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
SetBytes
ΩΩ$ ,
(
ΩΩ, -
int
ΩΩ- 0
index
ΩΩ1 6
,
ΩΩ6 7
byte
ΩΩ8 <
[
ΩΩ< =
]
ΩΩ= >
src
ΩΩ? B
,
ΩΩB C
int
ΩΩD G
srcIndex
ΩΩH P
,
ΩΩP Q
int
ΩΩR U
length
ΩΩV \
)
ΩΩ\ ]
{
ææ 	
this
øø 
.
øø 
wrapped
øø 
.
øø 
SetBytes
øø !
(
øø! "
index
øø" '
,
øø' (
src
øø) ,
,
øø, -
srcIndex
øø. 6
,
øø6 7
length
øø8 >
)
øø> ?
;
øø? @
return
¿¿ 
this
¿¿ 
;
¿¿ 
}
¡¡ 	
public
√√ 
override
√√ 
IByteBuffer
√√ #
SetBytes
√√$ ,
(
√√, -
int
√√- 0
index
√√1 6
,
√√6 7
IByteBuffer
√√8 C
src
√√D G
,
√√G H
int
√√I L
srcIndex
√√M U
,
√√U V
int
√√W Z
length
√√[ a
)
√√a b
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
wrapped
≈≈ 
.
≈≈ 
SetBytes
≈≈ !
(
≈≈! "
index
≈≈" '
,
≈≈' (
src
≈≈) ,
,
≈≈, -
srcIndex
≈≈. 6
,
≈≈6 7
length
≈≈8 >
)
≈≈> ?
;
≈≈? @
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
override
…… 
Task
…… 
<
…… 
int
……  
>
……  !
SetBytesAsync
……" /
(
……/ 0
int
……0 3
index
……4 9
,
……9 :
Stream
……; A
src
……B E
,
……E F
int
……G J
length
……K Q
,
……Q R
CancellationToken
……S d
cancellationToken
……e v
)
……v w
=>
……x z
this
……{ 
.…… Ä
wrapped……Ä á
.……á à
SetBytesAsync……à ï
(……ï ñ
index……ñ õ
,……õ ú
src……ù †
,……† °
length……¢ ®
,……® ©!
cancellationToken……™ ª
)……ª º
;……º Ω
public
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ #
Copy
ÀÀ$ (
(
ÀÀ( )
)
ÀÀ) *
=>
ÀÀ+ -
this
ÀÀ. 2
.
ÀÀ2 3
wrapped
ÀÀ3 :
.
ÀÀ: ;
Copy
ÀÀ; ?
(
ÀÀ? @
)
ÀÀ@ A
;
ÀÀA B
public
ÕÕ 
override
ÕÕ 
IByteBuffer
ÕÕ #
Copy
ÕÕ$ (
(
ÕÕ( )
int
ÕÕ) ,
index
ÕÕ- 2
,
ÕÕ2 3
int
ÕÕ4 7
length
ÕÕ8 >
)
ÕÕ> ?
=>
ÕÕ@ B
this
ÕÕC G
.
ÕÕG H
wrapped
ÕÕH O
.
ÕÕO P
Copy
ÕÕP T
(
ÕÕT U
index
ÕÕU Z
,
ÕÕZ [
length
ÕÕ\ b
)
ÕÕb c
;
ÕÕc d
public
œœ 
sealed
œœ 
override
œœ 
IByteBuffer
œœ *
this
œœ+ /
[
œœ/ 0
int
œœ0 3
cIndex
œœ4 :
]
œœ: ;
=>
œœ< >
this
œœ? C
.
œœC D
wrapped
œœD K
[
œœK L
cIndex
œœL R
]
œœR S
;
œœS T
public
—— 
sealed
—— 
override
—— 
IByteBuffer
—— *
ComponentAtOffset
——+ <
(
——< =
int
——= @
offset
——A G
)
——G H
=>
——I K
this
——L P
.
——P Q
wrapped
——Q X
.
——X Y
ComponentAtOffset
——Y j
(
——j k
offset
——k q
)
——q r
;
——r s
public
”” 
sealed
”” 
override
”” 
IByteBuffer
”” *
InternalComponent
””+ <
(
””< =
int
””= @
cIndex
””A G
)
””G H
=>
””I K
this
””L P
.
””P Q
wrapped
””Q X
.
””X Y
InternalComponent
””Y j
(
””j k
cIndex
””k q
)
””q r
;
””r s
public
’’ 
sealed
’’ 
override
’’ 
IByteBuffer
’’ *'
InternalComponentAtOffset
’’+ D
(
’’D E
int
’’E H
offset
’’I O
)
’’O P
=>
’’Q S
this
’’T X
.
’’X Y
wrapped
’’Y `
.
’’` a'
InternalComponentAtOffset
’’a z
(
’’z {
offset’’{ Å
)’’Å Ç
;’’Ç É
public
◊◊ 
override
◊◊ 
int
◊◊ 
IoBufferCount
◊◊ )
=>
◊◊* ,
this
◊◊- 1
.
◊◊1 2
wrapped
◊◊2 9
.
◊◊9 :
IoBufferCount
◊◊: G
;
◊◊G H
public
ŸŸ 
override
ŸŸ 
ArraySegment
ŸŸ $
<
ŸŸ$ %
byte
ŸŸ% )
>
ŸŸ) *
GetIoBuffer
ŸŸ+ 6
(
ŸŸ6 7
int
ŸŸ7 :
index
ŸŸ; @
,
ŸŸ@ A
int
ŸŸB E
length
ŸŸF L
)
ŸŸL M
=>
ŸŸN P
this
ŸŸQ U
.
ŸŸU V
wrapped
ŸŸV ]
.
ŸŸ] ^
GetIoBuffer
ŸŸ^ i
(
ŸŸi j
index
ŸŸj o
,
ŸŸo p
length
ŸŸq w
)
ŸŸw x
;
ŸŸx y
public
€€ 
override
€€ 
ArraySegment
€€ $
<
€€$ %
byte
€€% )
>
€€) *
[
€€* +
]
€€+ ,
GetIoBuffers
€€- 9
(
€€9 :
int
€€: =
index
€€> C
,
€€C D
int
€€E H
length
€€I O
)
€€O P
=>
€€Q S
this
€€T X
.
€€X Y
wrapped
€€Y `
.
€€` a
GetIoBuffers
€€a m
(
€€m n
index
€€n s
,
€€s t
length
€€u {
)
€€{ |
;
€€| }
public
›› 
override
›› !
CompositeByteBuffer
›› +
Consolidate
››, 7
(
››7 8
)
››8 9
{
ﬁﬁ 	
this
ﬂﬂ 
.
ﬂﬂ 
wrapped
ﬂﬂ 
.
ﬂﬂ 
Consolidate
ﬂﬂ $
(
ﬂﬂ$ %
)
ﬂﬂ% &
;
ﬂﬂ& '
return
‡‡ 
this
‡‡ 
;
‡‡ 
}
·· 	
public
„„ 
override
„„ !
CompositeByteBuffer
„„ +
Consolidate
„„, 7
(
„„7 8
int
„„8 ;
cIndex
„„< B
,
„„B C
int
„„D G
numComponents
„„H U
)
„„U V
{
‰‰ 	
this
ÂÂ 
.
ÂÂ 
wrapped
ÂÂ 
.
ÂÂ 
Consolidate
ÂÂ $
(
ÂÂ$ %
cIndex
ÂÂ% +
,
ÂÂ+ ,
numComponents
ÂÂ- :
)
ÂÂ: ;
;
ÂÂ; <
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
public
ÈÈ 
override
ÈÈ !
CompositeByteBuffer
ÈÈ +#
DiscardReadComponents
ÈÈ, A
(
ÈÈA B
)
ÈÈB C
{
ÍÍ 	
this
ÎÎ 
.
ÎÎ 
wrapped
ÎÎ 
.
ÎÎ #
DiscardReadComponents
ÎÎ .
(
ÎÎ. /
)
ÎÎ/ 0
;
ÎÎ0 1
return
ÏÏ 
this
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
public
ÔÔ 
override
ÔÔ 
IByteBuffer
ÔÔ #
DiscardReadBytes
ÔÔ$ 4
(
ÔÔ4 5
)
ÔÔ5 6
{
 	
this
ÒÒ 
.
ÒÒ 
wrapped
ÒÒ 
.
ÒÒ 
DiscardReadBytes
ÒÒ )
(
ÒÒ) *
)
ÒÒ* +
;
ÒÒ+ ,
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
ıı 
sealed
ıı 
override
ıı 
string
ıı %
ToString
ıı& .
(
ıı. /
)
ıı/ 0
=>
ıı1 3
this
ıı4 8
.
ıı8 9
wrapped
ıı9 @
.
ıı@ A
ToString
ııA I
(
ııI J
)
ııJ K
;
ııK L
public
˜˜ 
sealed
˜˜ 
override
˜˜ 
IByteBuffer
˜˜ *
SetReaderIndex
˜˜+ 9
(
˜˜9 :
int
˜˜: =
readerIndex
˜˜> I
)
˜˜I J
{
¯¯ 	
this
˘˘ 
.
˘˘ 
wrapped
˘˘ 
.
˘˘ 
SetReaderIndex
˘˘ '
(
˘˘' (
readerIndex
˘˘( 3
)
˘˘3 4
;
˘˘4 5
return
˙˙ 
this
˙˙ 
;
˙˙ 
}
˚˚ 	
public
˝˝ 
sealed
˝˝ 
override
˝˝ 
IByteBuffer
˝˝ *
SetWriterIndex
˝˝+ 9
(
˝˝9 :
int
˝˝: =
writerIndex
˝˝> I
)
˝˝I J
{
˛˛ 	
this
ˇˇ 
.
ˇˇ 
wrapped
ˇˇ 
.
ˇˇ 
SetWriterIndex
ˇˇ '
(
ˇˇ' (
writerIndex
ˇˇ( 3
)
ˇˇ3 4
;
ˇˇ4 5
return
ÄÄ 
this
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ÉÉ 
sealed
ÉÉ 
override
ÉÉ 
IByteBuffer
ÉÉ *
SetIndex
ÉÉ+ 3
(
ÉÉ3 4
int
ÉÉ4 7
readerIndex
ÉÉ8 C
,
ÉÉC D
int
ÉÉE H
writerIndex
ÉÉI T
)
ÉÉT U
{
ÑÑ 	
this
ÖÖ 
.
ÖÖ 
wrapped
ÖÖ 
.
ÖÖ 
SetIndex
ÖÖ !
(
ÖÖ! "
readerIndex
ÖÖ" -
,
ÖÖ- .
writerIndex
ÖÖ/ :
)
ÖÖ: ;
;
ÖÖ; <
return
ÜÜ 
this
ÜÜ 
;
ÜÜ 
}
áá 	
public
ââ 
sealed
ââ 
override
ââ 
IByteBuffer
ââ *
Clear
ââ+ 0
(
ââ0 1
)
ââ1 2
{
ää 	
this
ãã 
.
ãã 
wrapped
ãã 
.
ãã 
Clear
ãã 
(
ãã 
)
ãã  
;
ãã  !
return
åå 
this
åå 
;
åå 
}
çç 	
public
èè 
sealed
èè 
override
èè 
IByteBuffer
èè *
MarkReaderIndex
èè+ :
(
èè: ;
)
èè; <
{
êê 	
this
ëë 
.
ëë 
wrapped
ëë 
.
ëë 
MarkReaderIndex
ëë (
(
ëë( )
)
ëë) *
;
ëë* +
return
íí 
this
íí 
;
íí 
}
ìì 	
public
ïï 
sealed
ïï 
override
ïï 
IByteBuffer
ïï *
ResetReaderIndex
ïï+ ;
(
ïï; <
)
ïï< =
{
ññ 	
this
óó 
.
óó 
wrapped
óó 
.
óó 
ResetReaderIndex
óó )
(
óó) *
)
óó* +
;
óó+ ,
return
òò 
this
òò 
;
òò 
}
ôô 	
public
õõ 
sealed
õõ 
override
õõ 
IByteBuffer
õõ *
MarkWriterIndex
õõ+ :
(
õõ: ;
)
õõ; <
{
úú 	
this
ùù 
.
ùù 
wrapped
ùù 
.
ùù 
MarkWriterIndex
ùù (
(
ùù( )
)
ùù) *
;
ùù* +
return
ûû 
this
ûû 
;
ûû 
}
üü 	
public
°° 
sealed
°° 
override
°° 
IByteBuffer
°° *
ResetWriterIndex
°°+ ;
(
°°; <
)
°°< =
{
¢¢ 	
this
££ 
.
££ 
wrapped
££ 
.
££ 
ResetWriterIndex
££ )
(
££) *
)
££* +
;
££+ ,
return
§§ 
this
§§ 
;
§§ 
}
•• 	
public
ßß 
override
ßß 
IByteBuffer
ßß #
EnsureWritable
ßß$ 2
(
ßß2 3
int
ßß3 6
minWritableBytes
ßß7 G
)
ßßG H
{
®® 	
this
©© 
.
©© 
wrapped
©© 
.
©© 
EnsureWritable
©© '
(
©©' (
minWritableBytes
©©( 8
)
©©8 9
;
©©9 :
return
™™ 
this
™™ 
;
™™ 
}
´´ 	
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #
GetBytes
≠≠$ ,
(
≠≠, -
int
≠≠- 0
index
≠≠1 6
,
≠≠6 7
IByteBuffer
≠≠8 C
dst
≠≠D G
)
≠≠G H
{
ÆÆ 	
this
ØØ 
.
ØØ 
wrapped
ØØ 
.
ØØ 
GetBytes
ØØ !
(
ØØ! "
index
ØØ" '
,
ØØ' (
dst
ØØ) ,
)
ØØ, -
;
ØØ- .
return
∞∞ 
this
∞∞ 
;
∞∞ 
}
±± 	
public
≥≥ 
override
≥≥ 
IByteBuffer
≥≥ #
GetBytes
≥≥$ ,
(
≥≥, -
int
≥≥- 0
index
≥≥1 6
,
≥≥6 7
IByteBuffer
≥≥8 C
dst
≥≥D G
,
≥≥G H
int
≥≥I L
length
≥≥M S
)
≥≥S T
{
¥¥ 	
this
µµ 
.
µµ 
wrapped
µµ 
.
µµ 
GetBytes
µµ !
(
µµ! "
index
µµ" '
,
µµ' (
dst
µµ) ,
,
µµ, -
length
µµ. 4
)
µµ4 5
;
µµ5 6
return
∂∂ 
this
∂∂ 
;
∂∂ 
}
∑∑ 	
public
ππ 
override
ππ 
IByteBuffer
ππ #
GetBytes
ππ$ ,
(
ππ, -
int
ππ- 0
index
ππ1 6
,
ππ6 7
byte
ππ8 <
[
ππ< =
]
ππ= >
dst
ππ? B
)
ππB C
{
∫∫ 	
this
ªª 
.
ªª 
wrapped
ªª 
.
ªª 
GetBytes
ªª !
(
ªª! "
index
ªª" '
,
ªª' (
dst
ªª) ,
)
ªª, -
;
ªª- .
return
ºº 
this
ºº 
;
ºº 
}
ΩΩ 	
public
øø 
override
øø 
IByteBuffer
øø #

SetBoolean
øø$ .
(
øø. /
int
øø/ 2
index
øø3 8
,
øø8 9
bool
øø: >
value
øø? D
)
øøD E
{
¿¿ 	
this
¡¡ 
.
¡¡ 
wrapped
¡¡ 
.
¡¡ 

SetBoolean
¡¡ #
(
¡¡# $
index
¡¡$ )
,
¡¡) *
value
¡¡+ 0
)
¡¡0 1
;
¡¡1 2
return
¬¬ 
this
¬¬ 
;
¬¬ 
}
√√ 	
public
≈≈ 
override
≈≈ 
IByteBuffer
≈≈ #
SetChar
≈≈$ +
(
≈≈+ ,
int
≈≈, /
index
≈≈0 5
,
≈≈5 6
char
≈≈7 ;
value
≈≈< A
)
≈≈A B
{
∆∆ 	
this
«« 
.
«« 
wrapped
«« 
.
«« 
SetChar
««  
(
««  !
index
««! &
,
««& '
value
««( -
)
««- .
;
««. /
return
»» 
this
»» 
;
»» 
}
…… 	
public
ÀÀ 
override
ÀÀ 
IByteBuffer
ÀÀ #
SetFloat
ÀÀ$ ,
(
ÀÀ, -
int
ÀÀ- 0
index
ÀÀ1 6
,
ÀÀ6 7
float
ÀÀ8 =
value
ÀÀ> C
)
ÀÀC D
{
ÃÃ 	
this
ÕÕ 
.
ÕÕ 
wrapped
ÕÕ 
.
ÕÕ 
SetFloat
ÕÕ !
(
ÕÕ! "
index
ÕÕ" '
,
ÕÕ' (
value
ÕÕ) .
)
ÕÕ. /
;
ÕÕ/ 0
return
ŒŒ 
this
ŒŒ 
;
ŒŒ 
}
œœ 	
public
—— 
override
—— 
IByteBuffer
—— #
	SetDouble
——$ -
(
——- .
int
——. 1
index
——2 7
,
——7 8
double
——9 ?
value
——@ E
)
——E F
{
““ 	
this
”” 
.
”” 
wrapped
”” 
.
”” 
	SetDouble
”” "
(
””" #
index
””# (
,
””( )
value
””* /
)
””/ 0
;
””0 1
return
‘‘ 
this
‘‘ 
;
‘‘ 
}
’’ 	
public
◊◊ 
override
◊◊ 
IByteBuffer
◊◊ #
SetBytes
◊◊$ ,
(
◊◊, -
int
◊◊- 0
index
◊◊1 6
,
◊◊6 7
IByteBuffer
◊◊8 C
src
◊◊D G
)
◊◊G H
{
ÿÿ 	
this
ŸŸ 
.
ŸŸ 
wrapped
ŸŸ 
.
ŸŸ 
SetBytes
ŸŸ !
(
ŸŸ! "
index
ŸŸ" '
,
ŸŸ' (
src
ŸŸ) ,
)
ŸŸ, -
;
ŸŸ- .
return
⁄⁄ 
this
⁄⁄ 
;
⁄⁄ 
}
€€ 	
public
›› 
override
›› 
IByteBuffer
›› #
SetBytes
››$ ,
(
››, -
int
››- 0
index
››1 6
,
››6 7
IByteBuffer
››8 C
src
››D G
,
››G H
int
››I L
length
››M S
)
››S T
{
ﬁﬁ 	
this
ﬂﬂ 
.
ﬂﬂ 
wrapped
ﬂﬂ 
.
ﬂﬂ 
SetBytes
ﬂﬂ !
(
ﬂﬂ! "
index
ﬂﬂ" '
,
ﬂﬂ' (
src
ﬂﬂ) ,
,
ﬂﬂ, -
length
ﬂﬂ. 4
)
ﬂﬂ4 5
;
ﬂﬂ5 6
return
‡‡ 
this
‡‡ 
;
‡‡ 
}
·· 	
public
„„ 
override
„„ 
IByteBuffer
„„ #
SetBytes
„„$ ,
(
„„, -
int
„„- 0
index
„„1 6
,
„„6 7
byte
„„8 <
[
„„< =
]
„„= >
src
„„? B
)
„„B C
{
‰‰ 	
this
ÂÂ 
.
ÂÂ 
wrapped
ÂÂ 
.
ÂÂ 
SetBytes
ÂÂ !
(
ÂÂ! "
index
ÂÂ" '
,
ÂÂ' (
src
ÂÂ) ,
)
ÂÂ, -
;
ÂÂ- .
return
ÊÊ 
this
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
public
ÈÈ 
override
ÈÈ 
IByteBuffer
ÈÈ #
SetZero
ÈÈ$ +
(
ÈÈ+ ,
int
ÈÈ, /
index
ÈÈ0 5
,
ÈÈ5 6
int
ÈÈ7 :
length
ÈÈ; A
)
ÈÈA B
{
ÍÍ 	
this
ÎÎ 
.
ÎÎ 
wrapped
ÎÎ 
.
ÎÎ 
SetZero
ÎÎ  
(
ÎÎ  !
index
ÎÎ! &
,
ÎÎ& '
length
ÎÎ( .
)
ÎÎ. /
;
ÎÎ/ 0
return
ÏÏ 
this
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
public
ÔÔ 
override
ÔÔ 
IByteBuffer
ÔÔ #
	ReadBytes
ÔÔ$ -
(
ÔÔ- .
IByteBuffer
ÔÔ. 9
dst
ÔÔ: =
)
ÔÔ= >
{
 	
this
ÒÒ 
.
ÒÒ 
wrapped
ÒÒ 
.
ÒÒ 
	ReadBytes
ÒÒ "
(
ÒÒ" #
dst
ÒÒ# &
)
ÒÒ& '
;
ÒÒ' (
return
ÚÚ 
this
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
public
ıı 
override
ıı 
IByteBuffer
ıı #
	ReadBytes
ıı$ -
(
ıı- .
IByteBuffer
ıı. 9
dst
ıı: =
,
ıı= >
int
ıı? B
length
ııC I
)
ııI J
{
ˆˆ 	
this
˜˜ 
.
˜˜ 
wrapped
˜˜ 
.
˜˜ 
	ReadBytes
˜˜ "
(
˜˜" #
dst
˜˜# &
,
˜˜& '
length
˜˜( .
)
˜˜. /
;
˜˜/ 0
return
¯¯ 
this
¯¯ 
;
¯¯ 
}
˘˘ 	
public
˚˚ 
override
˚˚ 
IByteBuffer
˚˚ #
	ReadBytes
˚˚$ -
(
˚˚- .
IByteBuffer
˚˚. 9
dst
˚˚: =
,
˚˚= >
int
˚˚? B
dstIndex
˚˚C K
,
˚˚K L
int
˚˚M P
length
˚˚Q W
)
˚˚W X
{
¸¸ 	
this
˝˝ 
.
˝˝ 
wrapped
˝˝ 
.
˝˝ 
	ReadBytes
˝˝ "
(
˝˝" #
dst
˝˝# &
,
˝˝& '
dstIndex
˝˝( 0
,
˝˝0 1
length
˝˝2 8
)
˝˝8 9
;
˝˝9 :
return
˛˛ 
this
˛˛ 
;
˛˛ 
}
ˇˇ 	
public
ÅÅ 
override
ÅÅ 
IByteBuffer
ÅÅ #
	ReadBytes
ÅÅ$ -
(
ÅÅ- .
byte
ÅÅ. 2
[
ÅÅ2 3
]
ÅÅ3 4
dst
ÅÅ5 8
)
ÅÅ8 9
{
ÇÇ 	
this
ÉÉ 
.
ÉÉ 
wrapped
ÉÉ 
.
ÉÉ 
	ReadBytes
ÉÉ "
(
ÉÉ" #
dst
ÉÉ# &
)
ÉÉ& '
;
ÉÉ' (
return
ÑÑ 
this
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
áá 
override
áá 
IByteBuffer
áá #
	ReadBytes
áá$ -
(
áá- .
byte
áá. 2
[
áá2 3
]
áá3 4
dst
áá5 8
,
áá8 9
int
áá: =
dstIndex
áá> F
,
ááF G
int
ááH K
length
ááL R
)
ááR S
{
àà 	
this
ââ 
.
ââ 
wrapped
ââ 
.
ââ 
	ReadBytes
ââ "
(
ââ" #
dst
ââ# &
,
ââ& '
dstIndex
ââ( 0
,
ââ0 1
length
ââ2 8
)
ââ8 9
;
ââ9 :
return
ää 
this
ää 
;
ää 
}
ãã 	
public
çç 
override
çç 
ICharSequence
çç %
GetCharSequence
çç& 5
(
çç5 6
int
çç6 9
index
çç: ?
,
çç? @
int
ççA D
length
ççE K
,
ççK L
Encoding
ççM U
encoding
ççV ^
)
çç^ _
=>
çç` b
this
ççc g
.
ççg h
wrapped
ççh o
.
çço p
GetCharSequence
ççp 
(çç Ä
indexççÄ Ö
,ççÖ Ü
lengthççá ç
,ççç é
encodingççè ó
)ççó ò
;ççò ô
public
èè 
override
èè 
ICharSequence
èè %
ReadCharSequence
èè& 6
(
èè6 7
int
èè7 :
length
èè; A
,
èèA B
Encoding
èèC K
encoding
èèL T
)
èèT U
=>
èèV X
this
èèY ]
.
èè] ^
wrapped
èè^ e
.
èèe f
ReadCharSequence
èèf v
(
èèv w
length
èèw }
,
èè} ~
encodingèè á
)èèá à
;èèà â
public
ëë 
override
ëë 
int
ëë 
SetCharSequence
ëë +
(
ëë+ ,
int
ëë, /
index
ëë0 5
,
ëë5 6
ICharSequence
ëë7 D
sequence
ëëE M
,
ëëM N
Encoding
ëëO W
encoding
ëëX `
)
ëë` a
=>
ëëb d
this
ëëe i
.
ëëi j
wrapped
ëëj q
.
ëëq r
SetCharSequenceëër Å
(ëëÅ Ç
indexëëÇ á
,ëëá à
sequenceëëâ ë
,ëëë í
encodingëëì õ
)ëëõ ú
;ëëú ù
public
ìì 
override
ìì 
string
ìì 
	GetString
ìì (
(
ìì( )
int
ìì) ,
index
ìì- 2
,
ìì2 3
int
ìì4 7
length
ìì8 >
,
ìì> ?
Encoding
ìì@ H
encoding
ììI Q
)
ììQ R
=>
ììS U
this
ììV Z
.
ììZ [
wrapped
ìì[ b
.
ììb c
	GetString
ììc l
(
ììl m
index
ììm r
,
ììr s
length
ììt z
,
ììz {
encodingìì| Ñ
)ììÑ Ö
;ììÖ Ü
public
ïï 
override
ïï 
string
ïï 

ReadString
ïï )
(
ïï) *
int
ïï* -
length
ïï. 4
,
ïï4 5
Encoding
ïï6 >
encoding
ïï? G
)
ïïG H
=>
ïïI K
this
ïïL P
.
ïïP Q
wrapped
ïïQ X
.
ïïX Y

ReadString
ïïY c
(
ïïc d
length
ïïd j
,
ïïj k
encoding
ïïl t
)
ïït u
;
ïïu v
public
óó 
override
óó 
int
óó 
	SetString
óó %
(
óó% &
int
óó& )
index
óó* /
,
óó/ 0
string
óó1 7
value
óó8 =
,
óó= >
Encoding
óó? G
encoding
óóH P
)
óóP Q
=>
óóR T
this
óóU Y
.
óóY Z
wrapped
óóZ a
.
óóa b
	SetString
óób k
(
óók l
index
óól q
,
óóq r
value
óós x
,
óóx y
encodingóóz Ç
)óóÇ É
;óóÉ Ñ
public
ôô 
override
ôô 
IByteBuffer
ôô #
	ReadBytes
ôô$ -
(
ôô- .
Stream
ôô. 4
destination
ôô5 @
,
ôô@ A
int
ôôB E
length
ôôF L
)
ôôL M
=>
ôôN P
this
ôôQ U
.
ôôU V
wrapped
ôôV ]
.
ôô] ^
	ReadBytes
ôô^ g
(
ôôg h
destination
ôôh s
,
ôôs t
length
ôôu {
)
ôô{ |
;
ôô| }
public
õõ 
override
õõ 
int
õõ 
WriteCharSequence
õõ -
(
õõ- .
ICharSequence
õõ. ;
sequence
õõ< D
,
õõD E
Encoding
õõF N
encoding
õõO W
)
õõW X
=>
õõY [
this
õõ\ `
.
õõ` a
wrapped
õõa h
.
õõh i
WriteCharSequence
õõi z
(
õõz {
sequenceõõ{ É
,õõÉ Ñ
encodingõõÖ ç
)õõç é
;õõé è
public
ùù 
override
ùù 
int
ùù 
WriteString
ùù '
(
ùù' (
string
ùù( .
value
ùù/ 4
,
ùù4 5
Encoding
ùù6 >
encoding
ùù? G
)
ùùG H
=>
ùùI K
this
ùùL P
.
ùùP Q
wrapped
ùùQ X
.
ùùX Y
WriteString
ùùY d
(
ùùd e
value
ùùe j
,
ùùj k
encoding
ùùl t
)
ùùt u
;
ùùu v
public
üü 
override
üü 
IByteBuffer
üü #
	SkipBytes
üü$ -
(
üü- .
int
üü. 1
length
üü2 8
)
üü8 9
{
†† 	
this
°° 
.
°° 
wrapped
°° 
.
°° 
	SkipBytes
°° "
(
°°" #
length
°°# )
)
°°) *
;
°°* +
return
¢¢ 
this
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
override
•• 
IByteBuffer
•• #
WriteBoolean
••$ 0
(
••0 1
bool
••1 5
value
••6 ;
)
••; <
{
¶¶ 	
this
ßß 
.
ßß 
wrapped
ßß 
.
ßß 
WriteBoolean
ßß %
(
ßß% &
value
ßß& +
)
ßß+ ,
;
ßß, -
return
®® 
this
®® 
;
®® 
}
©© 	
public
´´ 
override
´´ 
IByteBuffer
´´ #
	WriteByte
´´$ -
(
´´- .
int
´´. 1
value
´´2 7
)
´´7 8
{
¨¨ 	
this
≠≠ 
.
≠≠ 
wrapped
≠≠ 
.
≠≠ 
	WriteByte
≠≠ "
(
≠≠" #
value
≠≠# (
)
≠≠( )
;
≠≠) *
return
ÆÆ 
this
ÆÆ 
;
ÆÆ 
}
ØØ 	
public
±± 
override
±± 
IByteBuffer
±± #

WriteShort
±±$ .
(
±±. /
int
±±/ 2
value
±±3 8
)
±±8 9
{
≤≤ 	
this
≥≥ 
.
≥≥ 
wrapped
≥≥ 
.
≥≥ 

WriteShort
≥≥ #
(
≥≥# $
value
≥≥$ )
)
≥≥) *
;
≥≥* +
return
¥¥ 
this
¥¥ 
;
¥¥ 
}
µµ 	
public
∑∑ 
override
∑∑ 
IByteBuffer
∑∑ #
WriteMedium
∑∑$ /
(
∑∑/ 0
int
∑∑0 3
value
∑∑4 9
)
∑∑9 :
{
∏∏ 	
this
ππ 
.
ππ 
wrapped
ππ 
.
ππ 
WriteMedium
ππ $
(
ππ$ %
value
ππ% *
)
ππ* +
;
ππ+ ,
return
∫∫ 
this
∫∫ 
;
∫∫ 
}
ªª 	
public
ΩΩ 
override
ΩΩ 
IByteBuffer
ΩΩ #
WriteInt
ΩΩ$ ,
(
ΩΩ, -
int
ΩΩ- 0
value
ΩΩ1 6
)
ΩΩ6 7
{
ææ 	
this
øø 
.
øø 
wrapped
øø 
.
øø 
WriteInt
øø !
(
øø! "
value
øø" '
)
øø' (
;
øø( )
return
¿¿ 
this
¿¿ 
;
¿¿ 
}
¡¡ 	
public
√√ 
override
√√ 
IByteBuffer
√√ #
	WriteLong
√√$ -
(
√√- .
long
√√. 2
value
√√3 8
)
√√8 9
{
ƒƒ 	
this
≈≈ 
.
≈≈ 
wrapped
≈≈ 
.
≈≈ 
	WriteLong
≈≈ "
(
≈≈" #
value
≈≈# (
)
≈≈( )
;
≈≈) *
return
∆∆ 
this
∆∆ 
;
∆∆ 
}
«« 	
public
…… 
override
…… 
IByteBuffer
…… #
	WriteChar
……$ -
(
……- .
char
……. 2
value
……3 8
)
……8 9
{
   	
this
ÀÀ 
.
ÀÀ 
wrapped
ÀÀ 
.
ÀÀ 
	WriteChar
ÀÀ "
(
ÀÀ" #
value
ÀÀ# (
)
ÀÀ( )
;
ÀÀ) *
return
ÃÃ 
this
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
œœ 
override
œœ 
IByteBuffer
œœ #

WriteFloat
œœ$ .
(
œœ. /
float
œœ/ 4
value
œœ5 :
)
œœ: ;
{
–– 	
this
—— 
.
—— 
wrapped
—— 
.
—— 

WriteFloat
—— #
(
——# $
value
——$ )
)
——) *
;
——* +
return
““ 
this
““ 
;
““ 
}
”” 	
public
’’ 
override
’’ 
IByteBuffer
’’ #
WriteDouble
’’$ /
(
’’/ 0
double
’’0 6
value
’’7 <
)
’’< =
{
÷÷ 	
this
◊◊ 
.
◊◊ 
wrapped
◊◊ 
.
◊◊ 
WriteDouble
◊◊ $
(
◊◊$ %
value
◊◊% *
)
◊◊* +
;
◊◊+ ,
return
ÿÿ 
this
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
public
€€ 
override
€€ 
IByteBuffer
€€ #

WriteBytes
€€$ .
(
€€. /
IByteBuffer
€€/ :
src
€€; >
)
€€> ?
{
‹‹ 	
this
›› 
.
›› 
wrapped
›› 
.
›› 

WriteBytes
›› #
(
››# $
src
››$ '
)
››' (
;
››( )
return
ﬁﬁ 
this
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
public
·· 
override
·· 
IByteBuffer
·· #

WriteBytes
··$ .
(
··. /
IByteBuffer
··/ :
src
··; >
,
··> ?
int
··@ C
length
··D J
)
··J K
{
‚‚ 	
this
„„ 
.
„„ 
wrapped
„„ 
.
„„ 

WriteBytes
„„ #
(
„„# $
src
„„$ '
,
„„' (
length
„„) /
)
„„/ 0
;
„„0 1
return
‰‰ 
this
‰‰ 
;
‰‰ 
}
ÂÂ 	
public
ÁÁ 
override
ÁÁ 
IByteBuffer
ÁÁ #

WriteBytes
ÁÁ$ .
(
ÁÁ. /
IByteBuffer
ÁÁ/ :
src
ÁÁ; >
,
ÁÁ> ?
int
ÁÁ@ C
srcIndex
ÁÁD L
,
ÁÁL M
int
ÁÁN Q
length
ÁÁR X
)
ÁÁX Y
{
ËË 	
this
ÈÈ 
.
ÈÈ 
wrapped
ÈÈ 
.
ÈÈ 

WriteBytes
ÈÈ #
(
ÈÈ# $
src
ÈÈ$ '
,
ÈÈ' (
srcIndex
ÈÈ) 1
,
ÈÈ1 2
length
ÈÈ3 9
)
ÈÈ9 :
;
ÈÈ: ;
return
ÍÍ 
this
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ÌÌ 
override
ÌÌ 
IByteBuffer
ÌÌ #

WriteBytes
ÌÌ$ .
(
ÌÌ. /
byte
ÌÌ/ 3
[
ÌÌ3 4
]
ÌÌ4 5
src
ÌÌ6 9
)
ÌÌ9 :
{
ÓÓ 	
this
ÔÔ 
.
ÔÔ 
wrapped
ÔÔ 
.
ÔÔ 

WriteBytes
ÔÔ #
(
ÔÔ# $
src
ÔÔ$ '
)
ÔÔ' (
;
ÔÔ( )
return
 
this
 
;
 
}
ÒÒ 	
public
ÛÛ 
override
ÛÛ 
IByteBuffer
ÛÛ #

WriteBytes
ÛÛ$ .
(
ÛÛ. /
byte
ÛÛ/ 3
[
ÛÛ3 4
]
ÛÛ4 5
src
ÛÛ6 9
,
ÛÛ9 :
int
ÛÛ; >
srcIndex
ÛÛ? G
,
ÛÛG H
int
ÛÛI L
length
ÛÛM S
)
ÛÛS T
{
ÙÙ 	
this
ıı 
.
ıı 
wrapped
ıı 
.
ıı 

WriteBytes
ıı #
(
ıı# $
src
ıı$ '
,
ıı' (
srcIndex
ıı) 1
,
ıı1 2
length
ıı3 9
)
ıı9 :
;
ıı: ;
return
ˆˆ 
this
ˆˆ 
;
ˆˆ 
}
˜˜ 	
public
˘˘ 
override
˘˘ 
IByteBuffer
˘˘ #
	WriteZero
˘˘$ -
(
˘˘- .
int
˘˘. 1
length
˘˘2 8
)
˘˘8 9
{
˙˙ 	
this
˚˚ 
.
˚˚ 
wrapped
˚˚ 
.
˚˚ 
	WriteZero
˚˚ "
(
˚˚" #
length
˚˚# )
)
˚˚) *
;
˚˚* +
return
¸¸ 
this
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
override
ˇˇ 
IReferenceCounted
ˇˇ )
Retain
ˇˇ* 0
(
ˇˇ0 1
int
ˇˇ1 4
	increment
ˇˇ5 >
)
ˇˇ> ?
{
ÄÄ 	
this
ÅÅ 
.
ÅÅ 
wrapped
ÅÅ 
.
ÅÅ 
Retain
ÅÅ 
(
ÅÅ  
	increment
ÅÅ  )
)
ÅÅ) *
;
ÅÅ* +
return
ÇÇ 
this
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
IReferenceCounted
ÖÖ )
Retain
ÖÖ* 0
(
ÖÖ0 1
)
ÖÖ1 2
{
ÜÜ 	
this
áá 
.
áá 
wrapped
áá 
.
áá 
Retain
áá 
(
áá  
)
áá  !
;
áá! "
return
àà 
this
àà 
;
àà 
}
ââ 	
public
ãã 
override
ãã 
IReferenceCounted
ãã )
Touch
ãã* /
(
ãã/ 0
)
ãã0 1
{
åå 	
this
çç 
.
çç 
wrapped
çç 
.
çç 
Touch
çç 
(
çç 
)
çç  
;
çç  !
return
éé 
this
éé 
;
éé 
}
èè 	
public
ëë 
override
ëë 
IReferenceCounted
ëë )
Touch
ëë* /
(
ëë/ 0
object
ëë0 6
hint
ëë7 ;
)
ëë; <
{
íí 	
this
ìì 
.
ìì 
wrapped
ìì 
.
ìì 
Touch
ìì 
(
ìì 
hint
ìì #
)
ìì# $
;
ìì$ %
return
îî 
this
îî 
;
îî 
}
ïï 	
public
óó 
override
óó 
IByteBuffer
óó #"
DiscardSomeReadBytes
óó$ 8
(
óó8 9
)
óó9 :
{
òò 	
this
ôô 
.
ôô 
wrapped
ôô 
.
ôô "
DiscardSomeReadBytes
ôô -
(
ôô- .
)
ôô. /
;
ôô/ 0
return
öö 
this
öö 
;
öö 
}
õõ 	
	protected
ùù 
internal
ùù 
sealed
ùù !
override
ùù" *
void
ùù+ /

Deallocate
ùù0 :
(
ùù: ;
)
ùù; <
=>
ùù= ?
this
ùù@ D
.
ùùD E
wrapped
ùùE L
.
ùùL M

Deallocate
ùùM W
(
ùùW X
)
ùùX Y
;
ùùY Z
public
üü 
sealed
üü 
override
üü 
IByteBuffer
üü *
Unwrap
üü+ 1
(
üü1 2
)
üü2 3
=>
üü4 6
this
üü7 ;
.
üü; <
wrapped
üü< C
;
üüC D
public
°° 
sealed
°° 
override
°° 
IntPtr
°° %#
AddressOfPinnedMemory
°°& ;
(
°°; <
)
°°< =
=>
°°> @
this
°°A E
.
°°E F
wrapped
°°F M
.
°°M N#
AddressOfPinnedMemory
°°N c
(
°°c d
)
°°d e
;
°°e f
public
££ 
sealed
££ 
override
££ 
ref
££ "
byte
££# '&
GetPinnableMemoryAddress
££( @
(
££@ A
)
££A B
=>
££C E
ref
££F I
this
££J N
.
££N O
wrapped
££O V
.
££V W&
GetPinnableMemoryAddress
££W o
(
££o p
)
££p q
;
££q r
public
•• 
sealed
•• 
override
•• 
bool
•• #
HasMemoryAddress
••$ 4
=>
••5 7
this
••8 <
.
••< =
wrapped
••= D
.
••D E
HasMemoryAddress
••E U
;
••U V
public
ßß 
sealed
ßß 
override
ßß 
bool
ßß #

IsWritable
ßß$ .
(
ßß. /
int
ßß/ 2
size
ßß3 7
)
ßß7 8
=>
ßß9 ;
this
ßß< @
.
ßß@ A
wrapped
ßßA H
.
ßßH I

IsWritable
ßßI S
(
ßßS T
size
ßßT X
)
ßßX Y
;
ßßY Z
public
©© 
sealed
©© 
override
©© 
int
©© "
MaxCapacity
©©# .
=>
©©/ 1
this
©©2 6
.
©©6 7
wrapped
©©7 >
.
©©> ?
MaxCapacity
©©? J
;
©©J K
public
´´ 
sealed
´´ 
override
´´ 
bool
´´ #
IsDirect
´´$ ,
=>
´´- /
this
´´0 4
.
´´4 5
wrapped
´´5 <
.
´´< =
IsDirect
´´= E
;
´´E F
public
≠≠ 
override
≠≠ 
IByteBuffer
≠≠ #
ReadRetainedSlice
≠≠$ 5
(
≠≠5 6
int
≠≠6 9
length
≠≠: @
)
≠≠@ A
=>
≠≠B D
this
≠≠E I
.
≠≠I J
wrapped
≠≠J Q
.
≠≠Q R
ReadRetainedSlice
≠≠R c
(
≠≠c d
length
≠≠d j
)
≠≠j k
;
≠≠k l
public
ØØ 
override
ØØ 
IByteBuffer
ØØ #
RetainedDuplicate
ØØ$ 5
(
ØØ5 6
)
ØØ6 7
=>
ØØ8 :
this
ØØ; ?
.
ØØ? @
wrapped
ØØ@ G
.
ØØG H
RetainedDuplicate
ØØH Y
(
ØØY Z
)
ØØZ [
;
ØØ[ \
public
±± 
override
±± 
IByteBuffer
±± #
RetainedSlice
±±$ 1
(
±±1 2
)
±±2 3
=>
±±4 6
this
±±7 ;
.
±±; <
wrapped
±±< C
.
±±C D
RetainedSlice
±±D Q
(
±±Q R
)
±±R S
;
±±S T
public
≥≥ 
override
≥≥ 
IByteBuffer
≥≥ #
RetainedSlice
≥≥$ 1
(
≥≥1 2
int
≥≥2 5
index
≥≥6 ;
,
≥≥; <
int
≥≥= @
length
≥≥A G
)
≥≥G H
=>
≥≥I K
this
≥≥L P
.
≥≥P Q
wrapped
≥≥Q X
.
≥≥X Y
RetainedSlice
≥≥Y f
(
≥≥f g
index
≥≥g l
,
≥≥l m
length
≥≥n t
)
≥≥t u
;
≥≥u v
}
¥¥ 
}µµ 